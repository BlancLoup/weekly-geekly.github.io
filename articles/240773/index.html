<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Atom - TypeScript implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky and I ... a professional cyclist. During my life I tried many iron horses, but ultimately I stopped at a self-made ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Atom - TypeScript implementation</h1><div class="post__text post__text-html js-mediator-article">  Hello, my name is Dmitry Karlovsky and I ... a professional cyclist.  During my life I tried many iron horses, but ultimately I stopped at a self-made one.  Not that I really liked to work with a file, spending a lot of free time to reinvent the wheel, but the end result, where every bump is not given pain in the lower half of the body, is worth it.  And now, when you know that I started all this for a reason, and to make the world a better place, let me introduce to you the TypeScript / JavaScript module $ jin.atom. <br><br>  Summary of the <a href="http://habrahabr.ru/post/235121/">previous series</a> : the simplest application has reached a critical level of complexity, and to cope with it, the atom abstraction was introduced, which absorbed the entire routine, allowing the developer to concentrate on the description of invariants in a functional style, without losing connection with the object-oriented platform .  All theory and pictures are there.  There will also be a lot of practice, code samples and console dumps. <br><a name="habracut"></a><br><h4>  <b>Why precisely TypeScript?</b> </h4><br>  The first implementation of the module was in pure JavaScript, but recently it was rewritten in TypeScript.  TypeScript is practically the same JavaScript, but with classes, type deduction and normal lambdas.  More, it practically does not additionally change anything and, as a result, it integrates very well with regular JavaScript code.  You can directly access TypeScript modules from JavaScript and vice versa.  Unless, for JS, it is advisable to still write the so-called "declarations of the environment" in order not to lose the advantages that static typing gives.  And she gives the following bonuses: <br>  * Tips in the IDE save the programmer from having to keep in memory the documentation on all methods and properties of all classes. <br>  * Search all places of use of the entity - indispensable when refactoring. <br>  * Identification of inconsistencies in types between different parts of the application at the stage of editing / assembly. <br>  Unfortunately, there are also disadvantages: <br>  * Sometimes you have to dance with a tambourine, explaining to the compiler what you mean. <br><br>  There are two alternatives to TypeScript: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>JSDoc</b> is an extremely non-expressive format for static description of dynamic code in comments.  Often the volume of JSDoc-comments (without taking into account the verbal description) is obtained more than the actual useful code.  Illustrative example: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @callback onTitleChange_handler * @param {string} next * @param {string} prev */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * @param {onTitleChange_handler} handler */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTitleChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> handler </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } onTitleChange( /** * @type {onTitleChange_handler} */ function( next, prev ){ // ... } )</span></span></code> </pre> <br>  <b>Dart</b> - suck another language, which, however, is designed for translation in JavaScript.  It uses completely different idioms, which has many limitations when integrating with JavaScript code, significantly more memory consumption, problems when debugging using the tools built into browsers, and the code generated from Dart is quite bulky noodles.  The above example, looks like this: <br><br><pre> <code class="javascript hljs"> typedef <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> onTitleChange_handler( <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> next , <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> prev ); onTitleChange( onTitleChange_handler handler ){ <span class="hljs-comment"><span class="hljs-comment">// ... } void main() { onTitleChange( ( next, prev ) =&gt; { // ... }); }</span></span></code> </pre><br>  Already better, but also requires the introduction of too many named interfaces / types.  This is the main disadvantage of nominative typing.  In <b>TypeScript</b> , structural is used: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTitleChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> handler : ( next : string , prev : string </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> )</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } onTitleChange( ( next, prev ) =&gt; { // ... });</span></span></code> </pre><br>  But it is possible to give names to interfaces if necessary: <br><br><pre> <code class="javascript hljs"> interface onTitleChange_handler { ( next : string , <span class="hljs-attr"><span class="hljs-attr">prev</span></span> : string ) : <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTitleChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> handler : onTitleChange_handler </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } onTitleChange( ( next, prev ) =&gt; { // ... });</span></span></code> </pre><br>  Total, at transition to TypeScript: <br>  + decreases the amount of code <br>  + improved integration with the development environment <br>  + Additional validation checks appear as you type. <br>  - the need to translate to javascript before execution is added <br><br><h4>  <b>FRP Myths and Legends</b> </h4><br>  Reactive libraries can be divided into two main types: <br>  1. Actually FunctionalRP, where the whole application is described as a set of pure functions. <br>  2. ProceduralRP, which is often confused with FRP.  They describe the application imperatively in the form of streams of events (streams). <br><br>  In the second case, the application is described as a set of procedures of the form: take data from different places, apply certain transformations to them successively, and then write them to other places. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = Bacon.combine( [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseTarget, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseCoords ] , <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> target, coords </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target + <span class="hljs-string"><span class="hljs-string">' '</span></span> + coords } ) .map( trimSpaces ) .map( htmlEncode ) .map( htmlParse ) .onValue( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> messaage </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById( <span class="hljs-string"><span class="hljs-string">'log'</span></span> ).appendChild( message ) } )</code> </pre><br>  Compare with the same, written in a less veiled form: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onChange( [ <span class="hljs-string"><span class="hljs-string">'mouseCoords'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseTarget'</span></span> ] , <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseTarget + <span class="hljs-string"><span class="hljs-string">' '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseCoords message = trimSpaces( message ) message = htmlEncode( message ) message = htmlParse( message ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById( <span class="hljs-string"><span class="hljs-string">'log'</span></span> ).appendChild( message ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireChange( <span class="hljs-string"><span class="hljs-string">'message'</span></span> ) }</code> </pre><br>  Known PRP libraries ( <a href="https://github.com/Reactive-Extensions/RxJS">Rx</a> , <a href="">Bacon</a> ) in accordance with the PRP architecture have a rather complex API.  The difficulty lies both in the huge number of methods that implement all kinds of operators on streams, and in how the simplest operations are described.  For example, the correct conditional branching would look like this: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = config.flatMapLatest( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> config </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mouseCoords.map( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> coords </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Mouse coords is '</span></span> + coords } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mouseTarget.map( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> target </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Mouse target is '</span></span> + target } } } )</code> </pre><br>  And here is the wrong: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = Bacon.combineWith( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> config, coords, target </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Mouse coords is '</span></span> + coords } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Mouse target is '</span></span> + target } }, config, mouseCoords, mouseTarget )</code> </pre><br>  The second option is much simpler and more intuitive, but in it the calculation of the message value will occur with any changes in all three streams, although it is obvious that at any time this value depends on only two of the three streams.  In the first version there is no such problem, but this has been achieved by a considerable complication of logic. <br><br>  Looking ahead, I will show for comparison the correct code on atoms: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = $jin.atom.prop( { <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config.get() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Mouse coords is '</span></span> + coords.get() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Mouse target is '</span></span> + target.get() } } } )</code> </pre><br>  In simple terms, in PRP it is convenient to describe dependencies, where data sources are relatively few and their composition practically does not change, and in FRP, on the contrary, the set of sources can be arbitrary and dynamic without loss of expressiveness.  With data consumers, the opposite is true: in PRP, the same state can change with many different streams, and in FRP, exactly one function is responsible for one state, by which it is always clear how the value is formed and on which it directly depends. <br><br>  Another popular misconception is that reactivity is only needed at the intersection of a model and a view.  However, in fact, reactivity is a more fundamental concept.  It is necessary to maintain invariants between states.  Any cache is a state.  Any persistent storage is a state.  Any visualization is a state.  States are everywhere and they are not independent even within the same application layer. <br><br><h4>  <b>Properties</b> </h4><br>  Before undertaking the realization of atoms, it is worthwhile to distinguish between two concepts: value (RValue) and container (LValue). <br><br>  The most famous container is the variable.  The variable supports only three interfaces: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count <span class="hljs-comment"><span class="hljs-comment">//       count = 2 //  return count //  </span></span></code> </pre><br>  Another equally well-known container is the field of the object.  It supports all variable interfaces: <br><br><pre> <code class="javascript hljs"> obj.count = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//   (   )      return obj.count //   </span></span></code> </pre><br>  But in addition to them, the field supports a couple more: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.field <span class="hljs-comment"><span class="hljs-comment">//   'field' in obj //    </span></span></code> </pre><br>  As you can see, there are not so many interfaces and they look completely different.  To implement more complex containers, which are undoubtedly atoms, we need much more interfaces, so we implement such a container as a class.  Here is how the implementation of a variable might look: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.vary({}) <span class="hljs-comment"><span class="hljs-comment">//   count.set( 2 ) //   count.get() //  </span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/eb2/e6b/4a6/eb2e6b4a6987dc95ccb189dce0b14de1.png" alt="image"><br><br>  On the one hand, we changed the awl to soap: the container (count variable) stores another container (instance of the $ jin.prop.vary class) that stores the actual value.  On the other hand, the container object, in contrast to a normal variable, is already the essence of the ‚Äúfirst class‚Äù, that is, it can be passed as an argument to a function or returned from it as a result and so on.  This is sometimes useful, but in the overwhelming majority of cases - unnecessarily.  Much more useful if the interface implementations differ from the standard ones: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.proxy({ <span class="hljs-attr"><span class="hljs-attr">put</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title = next }, <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title }, }) title.set( <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   title.get() //  </span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/f05/376/ccd/f05376ccd5b913a21645a031f22fee5b.png" alt="image"><br><br>  $ jin.prop.proxy - implementation of a stateless container, which can be either a ‚Äúnormal variable‚Äù or a ‚Äúproperty of an object‚Äù: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = { get title( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.proxy({ <span class="hljs-attr"><span class="hljs-attr">put</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title = next }, <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title }, }) } } doc.title.set( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   doc.title.get() //  </span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/1a9/f5b/5cf/1a9f5b5cf61f05e353b12f9158a64939.png" alt="image"><br><br>  In this case, the get interface calls the pull handler, and the set call put.  Such a replacement was not made casual - in general, these are really completely different interfaces.  To understand the difference, just enter the state and add obvious conditions: <br>  1) get calls pull only if the value is not set yet, otherwise it just returns it - the so-called ‚Äúlazy initialization‚Äù <br>  2) set causes put only if the set value is different from the current one - this prevents execution of the put idly. <br><br>  For example, if we work with the name of the document only through our container, then we can define it so that it doesn‚Äôt need to access the slow browser api again: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = { get title( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.vary({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span> : <span class="hljs-string"><span class="hljs-string">'_title'</span></span>, <span class="hljs-attr"><span class="hljs-attr">put</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title = next }, <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title }, }) } } doc.title.set( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//      doc.title.get() //   doc.title.update() //   </span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/cbd/68c/7cf/cbd68c7cfcd419eae635d7e23b7ea1dc.png" alt="image"><br><br>  If in the last two examples you were confused by such a cumbersome definition of a property, then let me tell you why it is so.  In this case, it could be defined and easier: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = { <span class="hljs-attr"><span class="hljs-attr">title</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.vary({ <span class="hljs-attr"><span class="hljs-attr">put</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title = next }, <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title }, }) } doc.title.set( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> )</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/bea/a47/aff/beaa47aff785877ea1a6080a5cabdc64.png" alt="image"><br><br>  So it should be done for properties that do not need the possibility of inheritance.  But if you declare a property in a prototype class like this, then all instances will work with the same container, which is usually not what you want.  But it is necessary that each instance has its own containers.  To do this, we create a container through the getter and give it a link to the object and the name of the field in it - it is in it that the container will save its data (or save itself - depends on the implementation).  Another vivid example of using such a getter is a lazy registry, with an arbitrary number of keys: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> info = { <span class="hljs-attr"><span class="hljs-attr">item</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> key </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.vary({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span> : <span class="hljs-string"><span class="hljs-string">'_item:'</span></span> + key, <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> }, }) } } info.item( <span class="hljs-string"><span class="hljs-string">'foo'</span></span> ).get() <span class="hljs-comment"><span class="hljs-comment">// 0 info.item( 'bar' ).set( 123 ) info.item( 'bar' ).get() // 123</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/ba2/f15/bd0ba2f159da0ba9c9bb3bdd499f39f9.png" alt="image"><br><br>  And, finally, a common situation is the delegation of another property: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { get name ( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.prop.vary({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> , <span class="hljs-attr"><span class="hljs-attr">name</span></span> : <span class="hljs-string"><span class="hljs-string">'_name'</span></span> , <span class="hljs-attr"><span class="hljs-attr">pull</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> prev </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> } }) } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = { get userName ( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.name } } app.userName.get() <span class="hljs-comment"><span class="hljs-comment">// Anonymous app.userName.set( 'Alice' ) // Anonymous app.userName.get() // Alice</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/937/ed1/6e3/937ed16e3ad6f62f029187c014d98133.png" alt="image"><br><br><h4>  <b>Reactive properties</b> </h4><br>  So now we are ready to create our first atom: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.atom.prop( { <span class="hljs-attr"><span class="hljs-attr">notify</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next, prev </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerText = next }, <span class="hljs-attr"><span class="hljs-attr">fail</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> error </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerText += <span class="hljs-string"><span class="hljs-string">' '</span></span> + error.message }, } ) message.push( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   message.fail( new Error( 'Exception' ) ) //   </span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/65c/879/086/65c879086f7d2b31adcd2e7991d5e299.png" alt="image"><br><br>  Everything is simple - when we change the value of an atom, the function notify (or fail) is immediately called, in which we can imperatively reflect the change of state at the oop runtime.  Normally, the FRP code of the application practically does not need such manual synchronization - most of them are easily eliminated by a declarative description of the version, according to which such synchronizing atoms are automatically generated.  But this is a topic for a separate large article, so that later we will focus on the capabilities of the atoms themselves. <br><br>  Atom is a generalization of the "promise", so it is not surprising that it supports and <a href="http://promisesaplus.com/">thenable interface</a> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.atom.prop({}) message.then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerText = next }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> error </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerText += <span class="hljs-string"><span class="hljs-string">' '</span></span> + error.message } ) message.push( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   message.fail( new Error( 'Exception' ) ) //    ,     </span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/6b0/c84/3af/6b0c843af00b6ce897edeb72ea3c0045.png" alt="image"><br><br>  It is important to keep in mind the promise limits: <br>  1. handler is called deferred <br>  2. The handler is called only once. <br><br>  The then method returns an atom that listens to the original atom and when it accepts a non-undefined value, it calls the handler and self-destructs. <br><br>  And now, finally, the FRP in action: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.atom.prop({ <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-string"><span class="hljs-string">'Alice'</span></span> }), <span class="hljs-attr"><span class="hljs-attr">lastName</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.atom.prop({ <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-string"><span class="hljs-string">'McGee'</span></span> }), <span class="hljs-attr"><span class="hljs-attr">getFullName</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        fullName : new $jin.prop.proxy(...) return user.firstName.get() + ' ' + user.lastName.get() } } var message = new $jin.atom.prop( { pull : function( ) { return 'Hello, ' + user.getFullName() }, notify : function( next , prev ) { document.body.innerText = next }, reap : function( ) { } } ) message.get() user.firstName.push( 'Alice' ) //   setTimeout( function( ) { user.lastName.push( 'Bob' ) //   }, 1000 )</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/807/3d8/edb/8073d8edb8a320ed25fc437032b00a3a.png" alt="image"><br><br>  Here, in general, everything is simple: message is implicitly declared as a function of the user.firstName and user.lastName properties, and when at least one of them changes, the message changes, and this is reflected in the document.  There are two features here: <br>  1. Atoms are lazy.  Until someone pulls them (via get or pull), they will be inactive. <br>  2. Atoms are prone to suicide.  If you do not override the behavior of reap, then atoms will destroy themselves, freeing memory when there is not a single atom dependent on them. <br><br>  Let's implement an atom that will track the pointer coordinates: <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//    var pointer = { handler : function( event ) { var point = event.changedTouches ? event.changedTouches[0] : event //        pointer.position.push([ point.clientX , point.clientY ]) event.preventDefault() }, position : new $jin.atom.prop( { pull : function( prev ) { //      document.body.addEventListener( 'mousemove' , pointer.handler , false ) document.body.addEventListener( 'dragover' , pointer.handler , false ) document.body.addEventListener( 'touchmove' , pointer.handler , false ) document.body.addEventListener( 'pointermove' , pointer.handler , false ) //   ,     return [ -1, -1 ] }, reap : function( ) { //       //   - document.body.removeEventListener( 'mousemove' , pointer.handler , false ) document.body.removeEventListener( 'dragover' , pointer.handler , false ) document.body.removeEventListener( 'touchmove' , pointer.handler , false ) document.body.removeEventListener( 'pointermove' , pointer.handler , false ) //  ,     pull      pointer.position.clear() } } ) } //     var title = new $jin.atom.prop( { pull : function( ) { return 'Mouse coords: ' + pointer.position.get() }, notify : function( next , prev ) { document.body.innerText = next }, reap : function( ) { } } ) title.pull() //  5     setTimeout( function( ) { title.disobeyAll() }, 5000 )</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/4d8/c62/a734d8c621a4ad551e281f327657b5ba.png" alt="image"><br><br><h4>  <b>Typed atoms</b> </h4><br>  Sometimes when changing the value of an atom, special logic is needed, which is different from the basic ‚Äúnew value replaces the old one‚Äù.  For example, if a Date instance is stored in an atom, then when inserted into an atom, it would be good to verify.  does he really point to another timestamp?  This is done by overriding the merge interface: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastUpdated = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.atom.prop( { <span class="hljs-attr"><span class="hljs-attr">merge</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next , prev </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !prev ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( prev.getTime() === next.getTime() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next }, <span class="hljs-attr"><span class="hljs-attr">notify</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next , prev </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerText += next.getFullYear() } } ) lastUpdated.push( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>( <span class="hljs-number"><span class="hljs-number">2014</span></span> , <span class="hljs-number"><span class="hljs-number">1</span></span> , <span class="hljs-number"><span class="hljs-number">1</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">//    2014 lastUpdated.push( new Date( 2014 , 1 , 1 ) ) //   lastUpdated.push( new Date( 2015 , 1 , 1 ) ) //    2015</span></span></code> </pre><br>  As the name suggests, the merge interface generally does not just a check, but also a merge of values.  For example, we need to store scattered data in it by key: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $jin.atom.prop( { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : {}, <span class="hljs-attr"><span class="hljs-attr">merge</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> next , prev </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   var updated = false for( var key in next ) { if( prev[ key ] === next[ key ] ) continue prev[ key ] = next[ key ] updated = true } //  ,    if( updated ) this.notify() return prev } }) userInfo.push({ firstName : 'Alice' }) userInfo.push({ lastName : 'McGee' }) userInfo.get() // { firstName: "Alice", lastName: "McGee" }</span></span></code> </pre><br>  In the chapter on properties, the main interfaces of variables and properties were listed, but there are many others: <br><br><pre> <code class="javascript hljs"> a ++ <span class="hljs-comment"><span class="hljs-comment">//      1    a += N //      N    //      </span></span></code> </pre><br>  These interfaces are for primitives.  Their behavior is rigidly defined and cannot be redefined.  But we have custom containers!  Let's write your container for numeric values: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> $jin.atom { <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">numb</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnerType</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jin</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jin</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">atom</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prop</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OwnerType</span></span></span><span class="hljs-class"> &gt; </span></span>{ summ( value ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.get() + value ) } multiply( value ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.get() * value ) } <span class="hljs-comment"><span class="hljs-comment">//     } } var count = new $jin.atom.numb({ value : 5 }) //     count.summ( -1 ) //    1 count.multiply( 2 ) //    count.get() //    (8)</span></span></code> </pre><br>  Here, in the example, TypeScript is already used, since inheritance in JavaScript is not very obvious because of what each framework has its own helper that implements it.  You can use them, as well as $ jin.atom.prop and $ jin.atom.numb and all the others are the most common javascript "functions with a prototype." <br><br>  But we are not limited to primitives alone - it is useful, for example, to have atoms for collections: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> $jin.atom { <span class="hljs-comment"><span class="hljs-comment">//    export class list&lt;ItemType,OwnerType extends $jin.object&gt; extends $jin.atom.prop&lt;ItemType[],OwnerType&gt; { // ,         merge( next : ItemType[] , prev : ItemType[] ) { next = super.merge( next , prev ) if( !next || !prev ) return next if( next.length !== prev.length ) return next for( var i = 0 ; i &lt; next.length ; ++i ) { if( next[ i ] !== prev[ i ] ) return next } return prev } //      append( values : ItemType[] ) { var value = this.get() value.push.apply( value, values ) this.notify( null , value ) //          } //      prepend( values : ItemType[] ) { var value = this.get() value.unshift.apply( value, values ) this.notify( null , value ) } //     } } var list = new $jin.atom.list({ value : [ 3 ] }) list.append([ 4 , 5 ]) list.prepend([ 1 , 2 ]) list.get() // [ 1 , 2 , 3 , 4 , 5 ]</span></span></code> </pre><br><h4>  <b>Summary</b> </h4><br>  Well, it's time to try it yourself.  But before that, I have to warn you that the project lives on pure enthusiasm, it is developed in its spare time, by one person, without any community or investment, so it does not have comprehensive documentation, heaps of examples, manuals, and answers to StackOverflow.  If you are interested in this topic - do not hesitate to ask questions, report on the doorposts, express ideas or even send patches. <br><br>  <a href="">The assembled JS library</a> ~ 27KB without compression <br>  <a href="https://github.com/nin-jin/pms-jin/tree/master/atom">Sources on TypeScript</a> <br>  <a href="http://jsfiddle.net/aro1fc8n/">JSFiddle stock</a> <br><br>  <b>Main classes:</b> <br>  $ jin.prop.proxy - stateless property <br>  $ jin.prop.vary - state property <br>  $ jin.atom.prop - reactive property <br><br>  <b>Constructor parameters (all optional):</b> <br>  owner - the owner of the atom, which must have a globally unique identifier in the objectPath field <br>  name - the name of the atom, unique within the owner <br>  value - the initial value <br>  get (value: T): T - called on every request for a value, by default, proxies the parameter <br>  pull (prev: T): T - called to ‚Äúpull in‚Äù values ‚Äã‚Äãfrom leading states (for example, from the server), by default it returns the current value <br>  merge (next: T, prev: T): T - called to validate and / or merge the new value with the current one, by default it returns the new value <br>  put (next: T, prev: T): void - reverse the pull operation, transfer the new value to the leading states (for example, to the server), by default write the new value to the atom <br>  reap (): void - is called.  when an atom is not signed by anyone and it can be safely removed, which is what the default does <br>  notify (next: T, prev: T): void - called when the current value changes, does nothing by default <br>  fail (error: Error): void - called when an exception object is saved instead of the current value <br><br>  <b>The basic methods of atoms:</b> <br>  get () - get value <br>  pull () - force a value <br>  update () - schedule update value <br>  set () - to offer a new value (which it can not write to itself but to the leading state) <br>  push () - force a new value <br>  fail (error) - force write exception object <br>  mutate ((prev: T) =&gt; T) - apply the transformation function <br>  then ((next: T1) =&gt; T2) - perform the function when the atom accepts the current value <br>  catch ((error: Error) =&gt; T2) - execute the function when the atom accepts the exception object <br><br><img src="http://nin-jin.github.io/etc/atoms/atoms.svg" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/240773/">https://habr.com/ru/post/240773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240761/index.html">Notes junior programmer: how to get the first job</a></li>
<li><a href="../240763/index.html">Expel evil spirits from the ReadyNAS</a></li>
<li><a href="../240765/index.html">Openssl closed four dangerous vulnerabilities</a></li>
<li><a href="../240767/index.html">mod_proctitle - Apache module for displaying requests and brief statistics in the program name (output of top and ps)</a></li>
<li><a href="../240769/index.html">Overview of JPA-RS New Features in EclipseLink</a></li>
<li><a href="../240775/index.html">Working with a COM port in a web project</a></li>
<li><a href="../240779/index.html">Create your own dojo widgets</a></li>
<li><a href="../240781/index.html">KodiCMS architecture</a></li>
<li><a href="../240783/index.html">Finger Trees (Part 1. Introduction)</a></li>
<li><a href="../240785/index.html">Simple Rest Api framework based on Phalcon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>