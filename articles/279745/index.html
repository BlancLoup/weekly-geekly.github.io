<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Template Turing Machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anyone interested in C ++ templates most likely heard about their Turing completeness and related jokes about "you can program while you program". In ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Template Turing Machine</h1><div class="post__text post__text-html js-mediator-article">  Anyone interested in C ++ templates most likely heard about their Turing completeness and related jokes about "you can program while you program".  In this post I will explain how using templates and constant expressions to build a real Turing machine that calculates the result of my work at compile time, where you can run existing programs.  For example, a diligent beaver with 4 states and 2 characters looks something like this: <br><pre><code class="cpp hljs">ADD_STATE(A); ADD_STATE(B); ADD_STATE(C); ADD_STATE(D); ADD_RULE(A, Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, Right, B); ADD_RULE(A, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, Left, B); ADD_RULE(B, Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, Left, A); ADD_RULE(B, <span class="hljs-number"><span class="hljs-number">1</span></span>, Blank, Left, C); ADD_RULE(C, Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, Right, Stop); ADD_RULE(C, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, Left, D); ADD_RULE(D, Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, Right, D); ADD_RULE(D, <span class="hljs-number"><span class="hljs-number">1</span></span>, Blank, Right, A); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tape = Tape&lt;Blank&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> machine = Machine&lt;A, <span class="hljs-number"><span class="hljs-number">0</span></span>, tape&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = Run&lt;machine&gt;::type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ print(result()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  At the exit, as expected, we get <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> _ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Here you can look at the code: <a href="https://ideone.com/MvBU3Z">https://ideone.com/MvBU3Z</a> .  Those who want to know how everything works inside, welcome under the cat. <br><a name="habracut"></a><br>  For the full operation of the Turing machine (MT further) you need the following: <br>  1. Ribbon with characters <br>  2. The way to read and write characters on the tape <br>  3. A way to navigate the tape and expand it as needed. <br>  4. The system of states and transition rules <br>  5. A way to calculate the next state of the whole system (machine + tape) <br>  6. The way to stop execution when the machine reaches the final state <br><br>  All operations must be performed on types and constant expressions, and not on variables as in ordinary life.  For consistency with the standard C ++ library, we will use the following calculation method: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   template&lt;class&gt; class Operation; //      template&lt;class Input&gt; class Operation { public: // ,    using type = typename Output; }</span></span></code> </pre><br>  Using the name ‚Äútype‚Äù to store the results will make possible some useful stunts with std :: conditional and std :: integral_constant, which we will see later. <br><br>  1. Since MT uses a finite alphabet, we can assume without loss of generality that the characters on the tape are represented by integers.  We agree that by default the tape contains the character specified by the Blank constant, equal to -1.  If desired, this value can be easily changed. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Blank = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = Tape&lt;xs...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(xs); };</code> </pre><br>  What can be done with the tape?  You can, for example, display it.  The print function will be the only function in the usual sense that will be used in the programs for our machine. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tape&lt;&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tape&lt;x, xs...&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == Blank) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"_ "</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } print(Tape&lt;xs...&gt;()); }</code> </pre><br>  It uses a standard recursive pattern trick.  Under the link you can look at the resulting code: <a href="https://ideone.com/DBHSC6">https://ideone.com/DBHSC6</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. Before going on to read and write, you need to do some auxiliary operations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concatenate</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... ys&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concatenate</span></span></span><span class="hljs-class">&lt;Tape&lt;xs...&gt;, Tape&lt;ys...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = Tape&lt;xs..., ys...&gt;; };</code> </pre><br>  Concatenation is simple. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invert</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invert</span></span></span><span class="hljs-class">&lt;Tape&lt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = Tape&lt;&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invert</span></span></span><span class="hljs-class">&lt;Tape&lt;x, xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concatenate&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Invert&lt;Tape&lt;xs...&gt;&gt;::type, Tape&lt;x&gt; &gt;::type; };</code> </pre><br>  Inversion is a bit more complicated: take the first character, move it to the end and concatenate with an inverted tail.  Inside recursion takes place as a result of which we get what we need.  Here is an example of a launch: <a href="https://ideone.com/47GKNp">https://ideone.com/47GKNp</a> <br><br>  Reading characters is where the magic begins with the standard library. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Read</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Read</span></span></span><span class="hljs-class">&lt;n, Tape&lt;x, xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; (n == <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, x&gt;, Read&lt;n - <span class="hljs-number"><span class="hljs-number">1</span></span>, Tape&lt;xs...&gt;&gt; &gt;::type::type; };</code> </pre><br>  The logic is actually relatively simple: if n == 0, we return the first character of the tape wrapped in std :: integral_constant, otherwise we reduce n by one and discard the first character.  What is the construction :: type :: type?  The first type refers to std :: conditional.  std :: conditional &lt;T, A, B&gt; :: type equals A, if T == true, and equals B in all other cases.  Thus, depending on the value of n, the whole structure will unfold in one of the following expressions: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, x&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = Read&lt;n - <span class="hljs-number"><span class="hljs-number">1</span></span>, Tape&lt;xs...&gt;&gt;::type;</code> </pre><br>  The first line is equivalent to type = std :: integral_constant &lt;int, x&gt;, the second will cause recursion.  But why it was impossible to write this code like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Read</span></span></span><span class="hljs-class">&lt;n, Tape&lt;x, xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; (n == <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, x&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Read&lt;n - <span class="hljs-number"><span class="hljs-number">1</span></span>, Tape&lt;xs...&gt;&gt;::type &gt;::type; };</code> </pre><br>  Solution: in the first case, the Read &lt;n - 1 template, Tape &lt;xs ... &gt;&gt; will be instantiated depending on the value of n, in the second case it will always be instantiated, since we explicitly use the internal alias (:: type).  If we just mention the name of the template, it will not be instantiated, if we try to use some of its insides, the template will be instantiated.  Thus, the expression from the second example will lead to infinite recursion, which will still stop, but with an error.  This will take with :: type :: type will be actively used in the future. <br>  Here you can look at an example of reading from the tape: <a href="https://ideone.com/vEyASt">https://ideone.com/vEyASt</a> <br><br>  Record.  Suppose we want to write on the tape instead of the character x the character y.  The write operation can be represented as dividing the entire tape into a part up to x, the x character itself and the part after x, replacing x with y and concatenating all the parts back into an integer.  Define operations to calculate the first n and last characters: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NLast</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NLast</span></span></span><span class="hljs-class">&lt;n, Tape&lt;x, xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; (n == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(xs)), Tape&lt;xs...&gt;, NLast&lt;n, Tape&lt;xs...&gt;&gt; &gt;::type::type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NFirst</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NFirst</span></span></span><span class="hljs-class">&lt;n, Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Invert&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NLast&lt; n, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Invert&lt;Tape&lt;xs...&gt;&gt;::type &gt;::type &gt;::type; };</code> </pre><br>  To get the last n characters, we'll do about the same thing we did for reading: shorten the tape one character at a time until the length of the remaining piece is equal to n.  To get the first n characters, flip the tape, take the last n characters, and flip the result.  Examples of use: <a href="https://ideone.com/igYF3W">https://ideone.com/igYF3W</a> . <br><br>  Finally, the direct entry: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Write</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Write</span></span></span><span class="hljs-class">&lt;pos, x, Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concatenate&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concatenate&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NFirst&lt;pos, Tape&lt;xs...&gt;&gt;::type, Tape&lt;x&gt; &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NLast&lt;(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(xs) - pos - <span class="hljs-number"><span class="hljs-number">1</span></span>), Tape&lt;xs...&gt;&gt;::type &gt;::type; };</code> </pre><br>  This code is not difficult to understand, knowing what is really happening here.  Record examples: <a href="https://ideone.com/w2mUdh">https://ideone.com/w2mUdh</a> <br><br>  At the moment, we have a class to represent the tape, and we can also read and write characters.  Now you need to learn how to move the tape. <br><br>  3. Our MT will support the following movement operations: Hold, Left and Right.  Each of them should be able to calculate the next position and the next state of the tape, knowing its current state and position.  If the car looks at the character at position 0 and we want to move it to the left, the tape needs to be expanded.  Similarly, in the case when the car looks at the final symbol and moves to the right. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hold</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hold</span></span></span><span class="hljs-class">&lt;pos, Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = pos; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tape = Tape&lt;xs...&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class">&lt;pos, Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; (pos &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, pos - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; &gt;::type(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tape = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; (pos &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>), Tape&lt;xs...&gt;, Tape&lt;Blank, xs...&gt; &gt;::type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class">&lt;pos, Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = pos + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tape = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; (pos &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(xs) - <span class="hljs-number"><span class="hljs-number">1</span></span>), Tape&lt;xs...&gt;, Tape&lt;xs..., Blank&gt; &gt;::type; };</code> </pre><br>  Examples: <a href="https://ideone.com/m5OTaT">https://ideone.com/m5OTaT</a> <br><br>  4. Now you can go to the states.  If the machine is in some state and reads the symbol from the tape, we need to know three things: what to write, where to go and what state to go.  It was decided to program the states as a group of template specializations, where each specialization corresponds to a pair (state, symbol), that is, a transition rule.  Suppose we want to set the following rule: being in state A and reading symbol 0, we need to write 1 instead, move to the right and go to state B. This rule will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&lt;0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> write = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tape</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">move</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class">&lt;pos, tape&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> next = B&lt;x&gt;; };</code> </pre><br>  Here is an excellent opportunity of modern C ++: alias template.  The ‚Äúmove‚Äù and ‚Äúnext‚Äù fields are not just types, but type templates; in the future they will be used by MT to calculate their next state.  Writing such a construction for each rule is quite tedious, so let's wrap up the task of switching rules to a macro.  The state, after passing into which the car should stop, is called Stop. <br><br>  5. To keep the state of the entire system (the state of the machine, its current position and the state of the tape), we define the class Machine.  The only thing that this class should be able to do is take one step of the simulation, calculate its next state. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pos</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Machine</span></span></span><span class="hljs-class">&lt;State, pos, Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> symbol = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Read&lt;pos, Tape&lt;xs...&gt;&gt;::type(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> state = State&lt;symbol&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> nextState = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> State&lt;symbol&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> next&lt;x&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> move = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> state::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> move&lt;pos, modifiedTape&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextPos = move::position; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> modifiedTape = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Write&lt;pos, state::write, Tape&lt;xs...&gt;&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> nextTape = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> move::tape; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> step = Machine&lt;nextState, nextPos, nextTape&gt;; };</code> </pre><br>  First we read the symbol from the tape and save it as a ‚Äúsymbol‚Äù.  Next, we instantiate the State class with a specific character value and get the transition rule.  The following machine condition is defined as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> nextState = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> State&lt;symbol&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> next&lt;x&gt;;</code> </pre><br>  Why do you need the keyword "template" before "next"?  According to the standard, it is necessary to write ‚Äútemplate‚Äù before the nested template name, if this name is used after the scope resolution operator ("::").  When calculating the move operation, you can observe the same effect. <br><br>  To calculate the next state of the tape, we write the new symbol into it and, if necessary, expand it by sequentially triggering the write and move operations.  The calculation of the new position is obvious. <br><br>  Finally, everything is ready, and we are able to calculate the next state of the system, take steps.  You can write a temporary helper function to display the state of the machine, come up with some simple program and follow its execution step by step: <a href="https://ideone.com/XuBDry">https://ideone.com/XuBDry</a> .  In this example, you can observe how the car is moving right and replacing everything in its path. <br><br>  6. Everything looks as if it works, but we have to go deeper: the input data for the process are the initial state of the machine, its position and the state of the tape, at the end we want to know just what happened to the tape when the machine has reached the Stop state.  Okay, let's write a class <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Run</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pos</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Run</span></span></span><span class="hljs-class">&lt;Machine&lt;State, pos, Tape&lt;xs...&gt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> step = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Machine&lt;State, pos, Tape&lt;xs...&gt;&gt;::step; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;State&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, Stop&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;&gt;::value, Tape&lt;xs...&gt;, Run&lt;step&gt; &gt;::type::type; };</code> </pre><br>  To check the condition of a stop, we instantiate the current state of the machine and the state of Stop with a value of 0, after which we compare them with each other by means of std :: is_same.  If they are equal, return the tape, otherwise take the next step and check the condition of the stop again. <br><br>  Now let's try to write something.  For example, increasing numbers in binary format.  Suppose that the number is written from left to right, as on a piece of paper. <br><pre> <code class="cpp hljs">ADD_STATE(S0); ADD_STATE(S1); ADD_STATE(S2); ADD_RULE(S0, Blank, Blank, Left, S1); ADD_RULE(S0, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Right, S0); ADD_RULE(S0, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, Right, S0); ADD_RULE(S1, Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, Right, S2); ADD_RULE(S1, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, Left, S2); ADD_RULE(S1, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Left, S1); ADD_RULE(S2, Blank, Blank, Hold, Stop); ADD_RULE(S2, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Right, S2); ADD_RULE(S2, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, Right, S2); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tape = Tape&lt;Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Blank&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = Run&lt;Machine&lt;S0, tape::length - <span class="hljs-number"><span class="hljs-number">1</span></span>, tape&gt;&gt;::type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ print(tape()); print(result()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  <a href="https://ideone.com/AgK4nx">https://ideone.com/AgK4nx</a> .  What to do if you want to run an incerement several times?  Of course, to write a separate operation class and call it several times, it's simple: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Increment</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Increment</span></span></span><span class="hljs-class">&lt;Tape&lt;xs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Run&lt;Machine&lt;S0, Tape&lt;xs...&gt;::length - <span class="hljs-number"><span class="hljs-number">1</span></span>, Tape&lt;xs...&gt;&gt;&gt;::type; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tape = Tape&lt;Blank, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Blank&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ print(tape()); print(Increment&lt;tape&gt;::type()); print(Increment&lt;Increment&lt;tape&gt;::type&gt;::type()); print(Increment&lt;Increment&lt;Increment&lt;tape&gt;::type&gt;::type&gt;::type()); print(Increment&lt;Increment&lt;Increment&lt;Increment&lt;tape&gt;::type&gt;::type&gt;::type&gt;::type()); print(Increment&lt;Increment&lt;Increment&lt;Increment&lt;Increment&lt;tape&gt;::type&gt;::type&gt;::type&gt;::type&gt;::type()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  <a href="https://ideone.com/zPyu6B">https://ideone.com/zPyu6B</a> <br><br>  On this joyous note I will allow myself to round out.  Here is the link to github: <a href="https://github.com/fnz/CTTM">https://github.com/fnz/CTTM</a> , pull-requests with new programs are especially welcome. </div><p>Source: <a href="https://habr.com/ru/post/279745/">https://habr.com/ru/post/279745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279733/index.html">ECMA-262 standard (JavaScript) in pictures, part 2</a></li>
<li><a href="../279735/index.html">Productivity in the development of Office Add-ins</a></li>
<li><a href="../279737/index.html">Replacing jitter exceptions</a></li>
<li><a href="../279739/index.html">Processing ‚Äúvideo 360‚Äù, image cleaning: algorithm and its implementation in C #</a></li>
<li><a href="../279743/index.html">NetApp StorageGrid object storage</a></li>
<li><a href="../279747/index.html">Porting FreeModbus 1.5 under STM32 HAL rs485 without RTOS</a></li>
<li><a href="../279749/index.html">Study: DDR4, considered ‚Äúinvulnerable‚Äù, is vulnerable to Rowhammer vulnerability</a></li>
<li><a href="../279751/index.html">Programmers misconceptions about phone numbers</a></li>
<li><a href="../279753/index.html">QA: Conference. The second wave of speakers</a></li>
<li><a href="../279757/index.html">TrueConf video conferencing. Review and comparison with Skype for Business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>