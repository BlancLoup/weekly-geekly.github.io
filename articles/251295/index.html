<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data compression methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My supervisor and I are preparing a small monograph on image processing. I decided to submit to the habrasoobshchestva court a chapter on image compre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data compression methods</h1><div class="post__text post__text-html js-mediator-article">  My supervisor and I are preparing a small monograph on image processing.  I decided to submit to the habrasoobshchestva court a chapter on image compression algorithms.  Since it is difficult to fit an entire chapter within one post, I decided to split it into three posts: <br>  1. Data compression methods; <br>  2. Image compression without loss; <br>  3. Compression of lossy images. <br>  Below you can see the first post of the series. <br><a name="habracut"></a><br>  At the moment there are a large number of lossless compression algorithms, which can be divided into two large groups: <br>  1. Flow and vocabulary algorithms.  Algorithms of the RLE (run-length encoding), LZ *, etc. families belong to this group. A feature of all algorithms of this group is that the encoding does not use information about the frequencies of the symbols in the message, but information about sequences that were encountered earlier. <br>  2. Algorithms of statistical (entropy) compression.  This group of algorithms compresses information using the uneven frequencies with which various symbols are encountered in a message.  The algorithms of this group include algorithms of arithmetic and prefix coding (using Shannon-Fanno, Huffman, intercept trees). <br>  In a separate group, you can select information conversion algorithms.  The algorithms of this group do not directly compress information, but their use greatly simplifies further compression using flow, vocabulary and entropy algorithms. <br><br><h1>  Flow and vocabulary algorithms </h1><br><h2>  Series Length Coding </h2><br>  Run-Length Encoding (RLE) coding is one of the simplest and most common data compression algorithms.  In this algorithm, a sequence of repeating characters is replaced by a character and the number of its repetitions. <br>  For example, the string ‚ÄúAAAAA‚Äù, which requires 5 bytes to be stored (provided that a single byte is reserved for storing one character), can be replaced by ‚Äú5A‚Äù consisting of two bytes.  Obviously, the more effective this algorithm is, the longer the series of repetitions. <br><br>  The main disadvantage of this algorithm is its extremely low efficiency on sequences of non-repeating characters.  For example, if we consider the sequence ‚ÄúABABAB‚Äù (6 bytes), then after applying the RLE algorithm, it will turn into ‚Äú111111‚Äù (12 bytes).  There are various methods to solve the problem of non-repeating characters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The simplest method is the following modification: a byte encoding the number of repetitions should store information not only about the number of repetitions, but also about their presence.  If the first bit is 1, then the next 7 bits indicate the number of repetitions of the corresponding character, and if the first bit is 0, then the next 7 bits indicate the number of characters to be taken without repeating.  If you encode "ABABAB" using this modification, we get "-6ABABAB" (7 bytes).  Obviously, the proposed method can significantly improve the efficiency of the RLE algorithm on non-repeating sequences of characters.  The implementation of the proposed approach is shown in Listing 1: <br><blockquote><ol><li>  <font color="#000000">type</font> </li><li>  TRLEEncodedString <font color="#000066">=</font> <font color="#000066">array</font> <font color="#000000">of</font> <font color="#000066">byte</font> <font color="#000066">;</font> </li><li>  <font color="#000000">function</font> RLEEncode <font color="#009900">(</font> InMsg <font color="#000066">:</font> ShortString <font color="#009900">)</font> <font color="#000066">:</font> TRLEEncodedString <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  MatchFl <font color="#000066">:</font> <font color="#000066">boolean</font> <font color="#000066">;</font> </li><li>  MatchCount <font color="#000066">:</font> <font color="#000066">shortint</font> <font color="#000066">;</font> </li><li>  EncodedString <font color="#000066">:</font> TRLEEncodedString <font color="#000066">;</font> </li><li>  N <font color="#000066">,</font> i <font color="#000066">:</font> <font color="#000066">byte</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#000066">;</font> </li><li>  SetLength <font color="#009900">(</font> EncodedString <font color="#000066">,</font> <font color="#cc66cc">2</font> <font color="#000066">*</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> &gt; <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  MatchFl <font color="#000066">:</font> <font color="#000066">=</font> <font color="#009900">(</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> &gt; <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#000066">and</font> <font color="#009900">(</font> InMsg <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#000066">=</font> InMsg <font color="#009900">[</font> <font color="#cc66cc">2</font> <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  MatchCount <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> <font color="#009900">(</font> MatchCount &lt; <font color="#000066">=</font> <font color="#cc66cc">126</font> <font color="#009900">)</font> <font color="#000066">and</font> <font color="#009900">(</font> MatchCount &lt;length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#009900">)</font> <font color="#000066">and</font> <font color="#009900">(</font> <font color="#009900">(</font> InMsg <font color="#009900">[</font> MatchCount <font color="#009900">]</font> <font color="#000066">=</font> InMsg <font color="#009900">[</font> MatchCount <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">=</font> MatchFl <font color="#009900">)</font> <font color="#000000">do</font> </li><li>  MatchCount <font color="#000066">:</font> <font color="#000066">=</font> MatchCount <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> MatchFl <font color="#000000">then</font> </li><li>  <font color="#000000">begin</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> N <font color="#000066">+</font> <font color="#cc66cc">2</font> <font color="#000066">;</font> </li><li>  EncodedString <font color="#009900">[</font> N <font color="#000066">-</font> <font color="#cc66cc">2</font> <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> MatchCount <font color="#000066">+</font> <font color="#cc66cc">128</font> <font color="#000066">;</font> </li><li>  EncodedString <font color="#009900">[</font> N <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">ord</font> <font color="#009900">(</font> InMsg <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> </li><li>  <font color="#000000">else</font> </li><li>  <font color="#000000">begin</font> </li><li>  <font color="#000000">if</font> MatchCount &lt;&gt; length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#000000">then</font> </li><li>  MatchCount <font color="#000066">:</font> <font color="#000066">=</font> MatchCount <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> N <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#000066">+</font> MatchCount <font color="#000066">;</font> </li><li>  EncodedString <font color="#009900">[</font> N <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000066">-</font> MatchCount <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">-</font> MatchCount <font color="#000066">+</font> <font color="#cc66cc">128</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">to</font> MatchCount <font color="#000000">do</font> </li><li>  EncodedString <font color="#009900">[</font> N <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000066">-</font> MatchCount <font color="#000066">+</font> i <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">ord</font> <font color="#009900">(</font> InMsg <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  delete <font color="#009900">(</font> InMsg <font color="#000066">,</font> <font color="#cc66cc">1</font> <font color="#000066">,</font> MatchCount <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  SetLength <font color="#009900">(</font> EncodedString <font color="#000066">,</font> N <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  RLEEncode <font color="#000066">:</font> <font color="#000066">=</font> EncodedString <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  Decoding a compressed message is very simple and comes down to a single pass through the compressed message, see Listing 2: <br><blockquote><ol><li>  <font color="#000000">type</font> </li><li>  TRLEEncodedString <font color="#000066">=</font> <font color="#000066">array</font> <font color="#000000">of</font> <font color="#000066">byte</font> <font color="#000066">;</font> </li><li>  <font color="#000000">function</font> RLEDecode <font color="#009900">(</font> InMsg <font color="#000066">:</font> TRLEEncodedString <font color="#009900">)</font> <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  RepeatCount <font color="#000066">:</font> <font color="#000066">shortint</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">,</font> j <font color="#000066">:</font> <font color="#000066">word</font> <font color="#000066">;</font> </li><li>  OutMsg <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> <font color="#ff0000">''</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> i &lt;length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  RepeatCount <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#000066">-</font> <font color="#cc66cc">128</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> RepeatCount &lt; <font color="#cc66cc">0</font> <font color="#000000">then</font> </li><li>  <font color="#000000">begin</font> </li><li>  RepeatCount <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">abs</font> <font color="#009900">(</font> RepeatCount <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> j <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000000">to</font> i <font color="#000066">+</font> RepeatCount <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000000">do</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">+</font> <font color="#000066">chr</font> <font color="#009900">(</font> InMsg <font color="#009900">[</font> j <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> RepeatCount <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> </li><li>  <font color="#000000">else</font> </li><li>  <font color="#000000">begin</font> </li><li>  <font color="#000000">for</font> j <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">to</font> RepeatCount <font color="#000000">do</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">+</font> <font color="#000066">chr</font> <font color="#009900">(</font> InMsg <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  RLEDecode <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  The second method of increasing the efficiency of the RLE algorithm is the use of information conversion algorithms that do not directly compress the data, but lead them to a form more convenient for compression.  As an example of such an algorithm, we consider the BWT permutation, named after the inventors of the Burrows-Wheeler transform.  This permutation does not change the characters themselves, but changes only their order in the string, while repeating substrings after applying the permutation are assembled into dense groups, which are much better compressed using the RLE algorithm.  A direct BWT conversion is reduced to a sequence of the following steps: <br>  1. Adding to the source line a special character for the line end, which is not found anywhere else; <br>  2. Getting all cyclic permutations of the source line; <br>  3. Sort received lines in lexicographical order; <br>  4. Return the last column of the resulting matrix. <br>  The implementation of this algorithm is shown in Listing 3. <br><blockquote><ol><li>  <font color="#000000">const</font> </li><li>  EOMsg <font color="#000066">=</font> <font color="#ff0000">'|'</font>  <font color="#000066">;</font> </li><li>  <font color="#000000">function</font> BWTEncode <font color="#009900">(</font> InMsg <font color="#000066">:</font> ShortString <font color="#009900">)</font> <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  OutMsg <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  ShiftTable <font color="#000066">:</font> <font color="#000066">array</font> <font color="#000000">of</font> ShortString <font color="#000066">;</font> </li><li>  LastChar <font color="#000066">:</font> ANSIChar <font color="#000066">;</font> </li><li>  N <font color="#000066">,</font> i <font color="#000066">:</font> <font color="#000066">word</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  InMsg <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#000066">+</font> EOMsg <font color="#000066">;</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  SetLength <font color="#009900">(</font> ShiftTable <font color="#000066">,</font> N <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  ShiftTable <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">2</font> <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  LastChar <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#009900">[</font> N <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  InMsg <font color="#000066">:</font> <font color="#000066">=</font> LastChar <font color="#000066">+</font> copy <font color="#009900">(</font> InMsg <font color="#000066">,</font> <font color="#cc66cc">1</font> <font color="#000066">,</font> N <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  ShiftTable <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  Sort <font color="#009900">(</font> ShiftTable <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> <font color="#ff0000">''</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">+</font> ShiftTable <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#009900">[</font> N <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  BWTEncode <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  The easiest way to explain this conversion is with a specific example.  Take the line "ANANAS" and agree that the symbol of the end of the line will be the symbol "|"  All cyclic permutations of this line and the result of their lexicographic sorting are given in Table.  one. <br><br><img src="https://habrastorage.org/files/233/d8d/a9d/233d8da9d10f49fca5ac4257b09bf8d0.png"><br><br>  Those.  the result of the direct conversion will be the string "| NNAAAC".  It is easy to notice that this string is much better than the original one, compressed by the RLE algorithm, since  there are long subsequences of repeated letters in it. <br>  A similar effect can be achieved with the help of other transformations, but the advantage of the BWT transformation is that it is reversible, although the inverse transformation is more complicated than the direct one.  In order to restore the original string, you must perform the following steps: <br>  Create an empty matrix of size n * n, where n is the number of characters in the encoded message; <br>  Fill the rightmost empty column with a coded message; <br>  Sort table rows in lexicographical order; <br>  Repeat steps 2-3 until there are empty columns; <br>  Return the line that ends with the end of line character. <br><br>  At first glance, the implementation of the inverse transform is not difficult, and one of the implementation options is shown in Listing 4. <br><blockquote><ol><li>  <font color="#000000">const</font> </li><li>  EOMsg <font color="#000066">=</font> <font color="#ff0000">'|'</font>  <font color="#000066">;</font> </li><li>  <font color="#000000">function</font> BWTDecode <font color="#009900">(</font> InMsg <font color="#000066">:</font> ShortString <font color="#009900">)</font> <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  OutMsg <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  ShiftTable <font color="#000066">:</font> <font color="#000066">array</font> <font color="#000000">of</font> ShortString <font color="#000066">;</font> </li><li>  N <font color="#000066">,</font> i <font color="#000066">,</font> j <font color="#000066">:</font> <font color="#000066">word</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> <font color="#ff0000">''</font> <font color="#000066">;</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  SetLength <font color="#009900">(</font> ShiftTable <font color="#000066">,</font> N <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  ShiftTable <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> <font color="#ff0000">''</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  <font color="#000000">for</font> j <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  ShiftTable <font color="#009900">[</font> j <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#009900">[</font> j <font color="#009900">]</font> <font color="#000066">+</font> ShiftTable <font color="#009900">[</font> j <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  Sort <font color="#009900">(</font> ShiftTable <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">1</font> <font color="#000000">to</font> N <font color="#000000">do</font> </li><li>  <font color="#000000">if</font> ShiftTable <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#009900">[</font> N <font color="#009900">]</font> <font color="#000066">=</font> EOMsg <font color="#000000">then</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> ShiftTable <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  delete <font color="#009900">(</font> OutMsg <font color="#000066">,</font> N <font color="#000066">,</font> <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  BWTDecode <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  But in practice, efficiency depends on the sorting algorithm chosen.  Trivial algorithms with quadratic complexity obviously have a very negative effect on speed, therefore it is recommended to use efficient algorithms. <br><br><img src="https://habrastorage.org/files/e36/319/2e6/e363192e6d60473f9eb0243e232eea18.png"><br><br>  After sorting the table obtained in the seventh step, it is necessary to select from the table a row ending with a ‚Äú|‚Äù character.  It is easy to see that this string is the only one.  So  we looked at the BWT transform using a specific example. <br><br>  Summarizing, we can say that the main advantage of a group of RLE algorithms is simplicity and speed of operation (including the speed of decoding), and the main disadvantage is inefficiency on non-repetitive character sets.  The use of special permutations increases the efficiency of the algorithm, but also greatly increases the running time (especially decoding). <br><br><h2>  Dictionary compression (LZ algorithms) </h2><br>  Group vocabulary algorithms, in contrast to the algorithms of the group RLE, encodes not the number of repetitions of characters, but the previously encountered sequences of characters.  During the operation of the algorithms under consideration, a table is dynamically created with a list of already encountered sequences and their corresponding codes.  This table is often called a dictionary, and the corresponding group of algorithms is called dictionary. <br><br>  The following describes the simplest version of the dictionary algorithm: <br>  Initialize the dictionary with all characters occurring in the input string; <br>  Find the longest sequence (S) in the dictionary that matches the beginning of the message to be encoded; <br>  Issue the code of the found sequence and delete it from the beginning of the encoded message; <br>  If the end of the message is not reached, read the next ¬© symbol and add Sc to the dictionary, go to step 2. Otherwise, exit. <br><br>  For example, the just-initialized dictionary for the phrase ‚ÄúKUKUSHKAKUKUKONKUKUPILAKAPUSHON‚Äù is given in Table.  3: <br><br><img src="https://habrastorage.org/files/765/c84/5a1/765c845a14834d88b0d6a9f300ed16b8.png"><br><br>  In the process of compression, the dictionary will be supplemented by sequences encountered in the message.  The process of replenishing the dictionary is given in Table.  four. <br><br><img src="https://habrastorage.org/files/89c/ca3/f15/89cca3f15e124c969e75b9a4b738fe0d.png"><br><br>  In the description of the algorithm, the description of the situation was intentionally omitted when the dictionary is full.  Depending on the variant of the algorithm, different behavior is possible: complete or partial cleaning of the dictionary, stopping the filling of the dictionary or expanding the dictionary with a corresponding increase in the code capacity.  Each of these approaches has certain disadvantages.  For example, stopping the replenishment of a dictionary can lead to a situation where the dictionary stores sequences that occur at the beginning of a compressible string, but are not encountered later.  At the same time, cleaning the dictionary can lead to the removal of frequent sequences.  Most implementations used when filling in the dictionary begin to track the degree of compression, and when it is lowered below a certain level, the dictionary is rebuilt.  Next will be considered the simplest implementation, stopping the replenishment of the dictionary when it is filled. <br><br>  To begin with, we define a dictionary as a record that stores not only the substrings encountered, but also the number of substrings stored in the dictionary: <br><blockquote><ol><li>  <font color="#000000">type</font> </li><li>  TDictionary <font color="#000066">=</font> <font color="#000066">record</font> </li><li>  WordCount <font color="#000066">:</font> <font color="#000066">byte</font> <font color="#000066">;</font> </li><li>  Words <font color="#000066">:</font> <font color="#000066">array</font> <font color="#000000">of</font> <font color="#000066">string</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  Previously encountered subsequences are stored in the Words array, and their code is the number of subsequences in this array. <br>  We will also define dictionary search and dictionary functions: <br><blockquote><ol><li>  <font color="#000000">const</font> </li><li>  MAX_DICT_LENGTH <font color="#000066">=</font> <font color="#cc66cc">256</font> <font color="#000066">;</font> </li><li></li><li>  <font color="#000000">function</font> FindInDict <font color="#009900">(</font> D <font color="#000066">:</font> TDictionary <font color="#000066">;</font> str <font color="#000066">:</font> ShortString <font color="#009900">)</font> <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  r <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">integer</font> <font color="#000066">;</font> </li><li>  fl <font color="#000066">:</font> <font color="#000066">boolean</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  r <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> d <font color="#000066">.</font>  <font color="#006600">WordCount</font> &gt; <font color="#cc66cc">0</font> <font color="#000000">then</font> </li><li>  <font color="#000000">begin</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> D.  <font color="#006600">WordCount</font> <font color="#000066">;</font> </li><li>  fl <font color="#000066">:</font> <font color="#000066">=</font> <font color="#000000">false</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> <font color="#009900">(</font> <font color="#000000">not</font> fl <font color="#009900">)</font> <font color="#000066">and</font> <font color="#009900">(</font> i&gt; <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#009900">)</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  fl <font color="#000066">:</font> <font color="#000066">=</font> D.  <font color="#006600">Words</font> <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#000066">=</font> str <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> fl <font color="#000000">then</font> </li><li>  r <font color="#000066">:</font> <font color="#000066">=</font> i <font color="#000066">;</font> </li><li>  FindInDict <font color="#000066">:</font> <font color="#000066">=</font> r <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li><li>  <font color="#000000">procedure</font> AddToDict <font color="#009900">(</font> <font color="#000000">var</font> D <font color="#000066">:</font> TDictionary <font color="#000066">;</font> str <font color="#000066">:</font> ShortString <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  <font color="#000000">if</font> d <font color="#000066">.</font>  <font color="#006600">WordCount</font> &lt;MAX_DICT_LENGTH <font color="#000000">then</font> </li><li>  <font color="#000000">begin</font> </li><li>  D.  <font color="#006600">WordCount</font> <font color="#000066">:</font> <font color="#000066">=</font> D.  <font color="#006600">WordCount</font> <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  SetLength <font color="#009900">(</font> D. <font color="#006600">Words</font> <font color="#000066">,</font> D. <font color="#006600">WordCount</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  D.  <font color="#006600">Words</font> <font color="#009900">[</font> D.  <font color="#006600">WordCount</font> <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> str <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  Using these functions, the coding process according to the described algorithm can be implemented as follows: <br><blockquote><ol><li>  <font color="#000000">function</font> LZWEncode <font color="#009900">(</font> InMsg <font color="#000066">:</font> ShortString <font color="#009900">)</font> <font color="#000066">:</font> TEncodedString <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  OutMsg <font color="#000066">:</font> TEncodedString <font color="#000066">;</font> </li><li>  tmpstr <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  D <font color="#000066">:</font> TDictionary <font color="#000066">;</font> </li><li>  i <font color="#000066">,</font> N <font color="#000066">:</font> <font color="#000066">byte</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  SetLength <font color="#009900">(</font> OutMsg <font color="#000066">,</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#000066">;</font> </li><li>  InitDict <font color="#009900">(</font> D <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> &gt; <font color="#cc66cc">0</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  tmpstr <font color="#000066">:</font> <font color="#000066">=</font> InMsg <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  <font color="#000000">while</font> <font color="#009900">(</font> FindInDict <font color="#009900">(</font> D <font color="#000066">,</font> tmpstr <font color="#009900">)</font> &gt; <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#009900">)</font> <font color="#000066">and</font> <font color="#009900">(</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> &gt; length <font color="#009900">(</font> tmpstr <font color="#009900">)</font> <font color="#009900">)</font> <font color="#000000">do</font> </li><li>  tmpstr <font color="#000066">:</font> <font color="#000066">=</font> tmpstr <font color="#000066">+</font> InMsg <font color="#009900">[</font> length <font color="#009900">(</font> tmpstr <font color="#009900">)</font> <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> FindInDict <font color="#009900">(</font> D <font color="#000066">,</font> tmpstr <font color="#009900">)</font> &lt; <font color="#cc66cc">0</font> <font color="#000000">then</font> </li><li>  delete <font color="#009900">(</font> tmpstr <font color="#000066">,</font> length <font color="#009900">(</font> tmpstr <font color="#009900">)</font> <font color="#000066">,</font> <font color="#cc66cc">1</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  OutMsg <font color="#009900">[</font> N <font color="#009900">]</font> <font color="#000066">:</font> <font color="#000066">=</font> FindInDict <font color="#009900">(</font> D <font color="#000066">,</font> tmpstr <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  N <font color="#000066">:</font> <font color="#000066">=</font> N <font color="#000066">+</font> <font color="#cc66cc">1</font> <font color="#000066">;</font> </li><li>  delete <font color="#009900">(</font> InMsg <font color="#000066">,</font> <font color="#cc66cc">1</font> <font color="#000066">,</font> length <font color="#009900">(</font> tmpstr <font color="#009900">)</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> &gt; <font color="#cc66cc">0</font> <font color="#000000">then</font> </li><li>  AddToDict <font color="#009900">(</font> D <font color="#000066">,</font> tmpstr <font color="#000066">+</font> InMsg <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  SetLength <font color="#009900">(</font> OutMsg <font color="#000066">,</font> N <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  LZWEncode <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  The result of coding will be the numbers of words in the dictionary. <br>  The decoding process is reduced to the direct decoding of codes, while there is no need to transfer the created dictionary, it is enough that during decoding the dictionary is initialized in the same way as when encoding.  Then the dictionary will be fully restored directly in the decoding process by concatenating the previous subsequence and the current character. <br><br>  The only problem is possible in the following situation: when it is necessary to decode a subsequence that is not yet in the dictionary.  It is easy to make sure that this is possible only when it is necessary to extract a substring that should be added at the current step.  This means that the substring satisfies the cSc pattern, i.e.  begins and ends with the same symbol.  In this case, cS is a substring added in the previous step.  The considered situation is the only one when it is necessary to decode a line that has not yet been added.  Given the above, we can offer the following decoding option for a compressed string: <br><blockquote><ol><li>  <font color="#000000">function</font> LZWDecode <font color="#009900">(</font> InMsg <font color="#000066">:</font> TEncodedString <font color="#009900">)</font> <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  <font color="#000000">var</font> </li><li>  D <font color="#000066">:</font> TDictionary <font color="#000066">;</font> </li><li>  OutMsg <font color="#000066">,</font> tmpstr <font color="#000066">:</font> ShortString <font color="#000066">;</font> </li><li>  i <font color="#000066">:</font> <font color="#000066">byte</font> <font color="#000066">;</font> </li><li>  <font color="#000000">begin</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> <font color="#ff0000">''</font> <font color="#000066">;</font> </li><li>  tmpstr <font color="#000066">:</font> <font color="#000066">=</font> <font color="#ff0000">''</font> <font color="#000066">;</font> </li><li>  InitDict <font color="#009900">(</font> D <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">for</font> i <font color="#000066">:</font> <font color="#000066">=</font> <font color="#cc66cc">0</font> <font color="#000000">to</font> length <font color="#009900">(</font> InMsg <font color="#009900">)</font> <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#000000">do</font> </li><li>  <font color="#000000">begin</font> </li><li>  <font color="#000000">if</font> InMsg <font color="#009900">[</font> i <font color="#009900">]</font> &gt; <font color="#000066">=</font> D.  <font color="#006600">WordCount</font> <font color="#000000">then</font> </li><li>  tmpstr <font color="#000066">:</font> <font color="#000066">=</font> D.  <font color="#006600">Words</font> <font color="#009900">[</font> InMsg <font color="#009900">[</font> i <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">]</font> <font color="#000066">+</font> D.  <font color="#006600">Words</font> <font color="#009900">[</font> InMsg <font color="#009900">[</font> i <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">]</font> <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> </li><li>  <font color="#000000">else</font> </li><li>  tmpstr <font color="#000066">:</font> <font color="#000066">=</font> D.  <font color="#006600">Words</font> <font color="#009900">[</font> InMsg <font color="#009900">[</font> i <font color="#009900">]</font> <font color="#009900">]</font> <font color="#000066">;</font> </li><li>  OutMsg <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">+</font> tmpstr <font color="#000066">;</font> </li><li>  <font color="#000000">if</font> i&gt; <font color="#cc66cc">0</font> <font color="#000000">then</font> </li><li>  AddToDict <font color="#009900">(</font> D <font color="#000066">,</font> D. <font color="#006600">Words</font> <font color="#009900">[</font> InMsg <font color="#009900">[</font> i <font color="#000066">-</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">]</font> <font color="#000066">+</font> tmpstr <font color="#009900">[</font> <font color="#cc66cc">1</font> <font color="#009900">]</font> <font color="#009900">)</font> <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li>  LZWDecode <font color="#000066">:</font> <font color="#000066">=</font> OutMsg <font color="#000066">;</font> </li><li>  <font color="#000000">end</font> <font color="#000066">;</font> </li><li></li></ol></blockquote><br>  The advantages of vocabulary algorithms are their greater compared to RLE compression efficiency.  Nevertheless, it should be understood that the actual use of these algorithms is associated with some implementation difficulties. <br><br><h1>  Entropy coding </h1><br><h2>  Encoding with Shannon-Fano trees </h2><br>  The Shannon-Fano algorithm is one of the first developed compression algorithms.  The algorithm is based on the idea of ‚Äã‚Äãrepresenting more frequent symbols using shorter codes.  In this case, codes obtained using the Shannon-Fano algorithm have the property of prefixity: i.e.  no code is the beginning of any other code.  The prefix property ensures that the encoding is one-to-one.  The algorithm for constructing Shannon-Fano codes is presented below: <br>  1. To break the alphabet into two parts, the total probabilities of the characters in which are as close as possible to each other. <br>  2. In the prefix code of the first part of the characters add 0, in the prefix code of the second part of the characters add 1. <br>  3. For each part (in which at least two characters) recursively perform steps 1-3. <br>  Despite the comparative simplicity, the Shannon-Fano algorithm is not without flaws, the most significant of which is non-optimal coding.  Although the split at each step is optimal, the algorithm does not guarantee an optimal result as a whole.  Consider, for example, the following line: "AAAABVGDEZH."  The corresponding Shannon-Fano tree and codes derived from it are shown in Fig.  one: <br><br><img src="https://habrastorage.org/files/ea6/cfb/55d/ea6cfb55d8544e778932e514b45cd890.png"><br><br>  Without encoding, the message will occupy 40 bits (provided that each character is encoded with 4 bits), and using the Shannon-Fano algorithm, 4 * 2 + 2 + 4 + 4 + 3 + 3 + 3 = 27 bits.  The message volume has decreased by 32.5%, but below it will be shown that this result can be significantly improved. <br><br><h2>  Huffman Tree Coding </h2><br>  The Huffman coding algorithm, developed a few years after the Shannon-Fano algorithm, also has the property of prefixity, and, in addition, the proven minimal redundancy, this is precisely due to its extremely wide distribution.  To obtain the Huffman codes, use the following algorithm: <br>  1. All symbols of the alphabet are represented as free nodes, with the weight of the node being proportional to the frequency of the symbol in the message; <br>  2. From the set of free nodes, two nodes are selected with a minimum weight and a new (parent) node is created with a weight equal to the sum of the weights of the selected nodes; <br>  3. The selected nodes are removed from the free list, and the parent node created on the basis of them is added to this list; <br>  4. Steps 2-3 are repeated as long as there are more than one node in the free list; <br>  5. Based on the constructed tree, each character of the alphabet is assigned a prefix code; <br>  6. The message is encoded by the received codes. <br><br>  Consider the same example as in the case of the Shannon-Fano algorithm.  The Huffman tree and codes received for the message ‚ÄúAAAABVGDEZH‚Äù are shown in Fig.  2: <br><br><img src="https://habrastorage.org/files/b75/90f/457/b7590f457b5a44fb9d3860d7204f8763.png"><br><br>  It is easy to calculate that the volume of the coded message will be 26 bits, which is less than in the Shannon-Fano algorithm.  Separately, it is worth noting that, in view of the popularity of the Huffman algorithm, there are currently many options for Huffman coding, including adaptive coding, which does not require the transmission of symbol frequencies. <br>  Among the shortcomings of the Huffman algorithm, a significant part of the problems associated with the complexity of implementation.  The use of real variables to store the frequency of symbols of symbols is associated with a loss of accuracy, therefore, in practice, integer variables are often used, but, since  the weight of the parent nodes is constantly growing, sooner or later an overflow occurs.  Thus, despite the simplicity of the algorithm, its correct implementation can still cause some difficulties, especially for large alphabets. <br><br><h2>  Coding with the help of trees </h2><br>  Encoding with the help of intersecting functions - an algorithm developed by the authors that allows to obtain prefix codes.  The algorithm is based on the idea of ‚Äã‚Äãbuilding a tree, each node of which contains a cutting function.  To describe the algorithm in more detail, you need to enter several definitions. <br>  A word is an ordered sequence of m bits (the number m is called the word depth). <br>  Literal secant - a pair of discharge-value discharge type.  For example, the literal (4,1) means that the 4 bits of the word must be equal to 1. If the condition of the literal is satisfied, then the literal is considered true, otherwise it is considered false. <br>  A k-bit secant is a set of k literals.  If all literals are true, then the secant function itself is true, otherwise it is false. <br><br>  The tree is built so that each knot divides the alphabet into as close as possible parts.  In Fig.  3 shows an example of a secant tree: <br><br><img src="https://habrastorage.org/files/a2c/574/040/a2c574040b8d479484048fe3fa859fdd.png"><br><br>  The tree of secant functions in the general case does not guarantee optimal coding, but it does provide extremely high speed of operation due to the simplicity of the operation in the nodes. <br><br><h2>  Arithmetic coding </h2><br>  Arithmetic coding is one of the most effective ways to compress information.  Unlike the Huffman algorithm, arithmetic coding allows encoding messages with entropy less than 1 bit per character.  Since  Most arithmetic coding algorithms are protected by patents, only the main ideas will be described below. <br>  Suppose that in the alphabet used N characters a_1, ..., a_N, with frequencies p_1, ..., p_N, respectively.  Then the algorithm of arithmetic coding will look as follows: <br>  For the working half-interval, take [0; 1); <br>  Split the working interval into N disjoint semi-intervals.  The length of the i-th half-interval is proportional to p_i. <br>  If the end of the message is not reached, select the i-th half-interval as the new working interval and go to step 2. Otherwise, return any number from the half-interval.  Writing this number in binary code will be a coded message. <br>  In Fig.  4 shows the encoding process of the message "ABAAV" <br><br><img src="https://habrastorage.org/files/474/e76/a23/474e76a236aa439497923044dc9d1dc1.png"><br><br>  When decoding, it is necessary to perform a similar sequence of actions, only at each step it is necessary to additionally determine which particular character was encoded. <br><br>  The obvious advantage of arithmetic coding is its efficiency, and the main (with the exception of patent restrictions) minus is the extremely high complexity of the coding and decoding processes. </div><p>Source: <a href="https://habr.com/ru/post/251295/">https://habr.com/ru/post/251295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251283/index.html">BattleGIS - JavaScript engine for playing Tanchiki</a></li>
<li><a href="../251285/index.html">Overview of Microsoft Azure platform updates for February</a></li>
<li><a href="../251289/index.html">Corporate and unincorporated IaaS: how not to get lost in the cloud market</a></li>
<li><a href="../251291/index.html">Data Owners - Thoughts on, Pros and Cons</a></li>
<li><a href="../251293/index.html">What bugs did LibreOffce find in PVS-Studio?</a></li>
<li><a href="../251297/index.html">Ekspozzer - creating a panorama from a video, averaging a video stream</a></li>
<li><a href="../251299/index.html">Lamp showing the weather forecast</a></li>
<li><a href="../251301/index.html">Administration of computers on the local network before loading the operating system</a></li>
<li><a href="../251303/index.html">16 months of functional programming</a></li>
<li><a href="../251307/index.html">node-seq in a new way (again about asynchrony)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>