<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Image fill algorithms, popular with video</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 

 Filling images is often a practical task, the essence of which is to fill a certain area of ‚Äã‚Äãan image, bounded by a contour defined by ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Image fill algorithms, popular with video</h1><div class="post__text post__text-html js-mediator-article"><h4>  annotation </h4><br><img src="https://habrastorage.org/storage/habraeffect/21/72/2172f1964343bec6fd56d0a0c0aebe99.png" alt="image" align="left"><br>  Filling images is often a practical task, the essence of which is to fill a certain area of ‚Äã‚Äãan image, bounded by a contour defined by color.  And it would seem simple, but often slow and crooked.  This article describes the well-known stack-based fill algorithms and provides an implementation in MatLab pseudo-code.  I tried to fill such a boring topic with interesting video clips, and described the process of obtaining them, again using MatLab.  In this article we will fill in Carlson who lives on the roof, as I did not find the habro-type for this purpose in normal resolution.  As well as a few lines of code on how to read and work with pictures in MatLab. <br><a name="habracut"></a><br><br><h4>  Preliminary information and background </h4><br>  In a simple way, we introduce the relation of connectivity or neighborhood on an ordered set of pairs of coordinates.  We will distinguish cases when a point has four neighbors (Fig.1a) and a case when a point has eight neighbors (Fig.1b). <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/cb/81/cb815a3113a05284a830f6fef56ee903.png" alt="image"></div><br>  Why do it and what to choose is shown in Figure 2. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/33/b6/33b6dd99476da42b5e73dc98f6914049.png" alt="image"></div><br>  In Figure 2, the squares depict conventional pixels of a digital image, with black pixels describing the boundary between two areas ‚Äî the upper and the lower.  We will fill the top white area with blue paint.  If we enter <b>only 4</b> neighbors for a point, the blue paint will not pass through the black border (Fig.2b) and the lower area will remain white, and if we use <b>eight</b> neighbors, then the black border and not the border at all, but the <i>sieve</i> through which and paint is spilled into the lower area. <br><br>  What kind of connectivity to choose?  On the plane, the choice is small - either 4 or 8 neighbors and the choice depends on the formulation of the original problem, but in a multidimensional space it is more and more difficult, even impossible to imagine, and in the article we will consider only the flat case.  In this case, we consider the case of four neighbors, which in a simple way extends to the case of eight. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage/habraeffect/20/5c/205c714229c110a88a6ed65ed0c388cf.png" alt="image" align="left">  Everyone noticed that the picture of Carlson, painted according to my taste and presentation in Paint, in the annotation of the article, is somehow crooked, is there a black outline on the border - a colored area - are there white and gray, eye-catching points?  This happened for the reason that our Carlson is not at all in binary color but in grayscale.  First of all, we remove this glaring flaw and binarize the picture, while we only need to work with one channel - let it be the first - red. <br>  So: <br><blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black">% <font color="#008000">//  </font> <br> source_image = imread( <font color="#A31515">'karlson.bmp'</font> ); <br> % <font color="#008000">//      </font> <br> gray_image = source_image(:,:,1); <br> % <font color="#008000">//    0.5</font> <br> bim=double(im2bw(gray_image, 0.5)); <br> % <font color="#008000">//  </font> <br> imagesc(bim); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font> .</a></code></code> </blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black">% <font color="#008000">//  </font> <br> source_image = imread( <font color="#A31515">'karlson.bmp'</font> ); <br> % <font color="#008000">//      </font> <br> gray_image = source_image(:,:,1); <br> % <font color="#008000">//    0.5</font> <br> bim=double(im2bw(gray_image, 0.5)); <br> % <font color="#008000">//  </font> <br> imagesc(bim); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font></a> .</code></code> <br>  Figure 3 shows the leg of our mischief in its original form (Fig. 3a) and after binarization (Fig. 3b), as we see, the contour has become expectedly thinner and now consists only of black dots, while some of the boundaries have disappeared. <br>  Next, we will look at two fill algorithms, but we will not program them recursively (so as not to dilute the extra holivars and avoid overflows), but expand the recursion to the stack. <br>  We define the terminology: <br><ul><li>  <b>The starting point</b> is the pixel in which the user pressed like a Point <i>with a can of paint</i> </li><li>  <b>Old color</b> - color of the area to be filled </li><li>  <b>New color</b> - the color of the area after the fill. </li></ul><br><br><h4>  Simple and slow fill algorithm </h4><br>  The edges of the image will also be considered the border of the image. <br>  The essence of the algorithm is simple: at the current point we check: if the old color is replace it with a new one, if it is new, then we do nothing.  Then we perform the same operation for four neighbors whose color is equal to the old color. <br>  Let me once <a href="http://lodev.org/cgtutor/floodfill.html">steal the source code</a> , with a recursive implementation, just to show the point: <br><blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black"><font color="#008000">//Recursive 4-way floodfill, crashes if recursion stack is full</font> <br> <font color="#0000ff">void</font> floodFill4( <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y, <font color="#0000ff">int</font> newColor, <font color="#0000ff">int</font> oldColor) <br> { <br> <font color="#0000ff">if</font> (x &gt;= 0 &amp;&amp; x &lt; w &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; h &amp;&amp; screenBuffer[x][y] == oldColor &amp;&amp; screenBuffer[x][y] != newColor) <br> { <br> screenBuffer[x][y] = newColor; <font color="#008000">//set color before starting recursion</font> <br> <br> floodFill4(x + 1, y,  newColor, oldColor); <br> floodFill4(x - 1, y,  newColor, oldColor); <br> floodFill4(x,  y + 1, newColor, oldColor); <br> floodFill4(x,  y - 1, newColor, oldColor); <br> } <br> }</font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font> .</a></code></code> </blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black"><font color="#008000">//Recursive 4-way floodfill, crashes if recursion stack is full</font> <br> <font color="#0000ff">void</font> floodFill4( <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y, <font color="#0000ff">int</font> newColor, <font color="#0000ff">int</font> oldColor) <br> { <br> <font color="#0000ff">if</font> (x &gt;= 0 &amp;&amp; x &lt; w &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; h &amp;&amp; screenBuffer[x][y] == oldColor &amp;&amp; screenBuffer[x][y] != newColor) <br> { <br> screenBuffer[x][y] = newColor; <font color="#008000">//set color before starting recursion</font> <br> <br> floodFill4(x + 1, y,  newColor, oldColor); <br> floodFill4(x - 1, y,  newColor, oldColor); <br> floodFill4(x,  y + 1, newColor, oldColor); <br> floodFill4(x,  y - 1, newColor, oldColor); <br> } <br> }</font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font></a> .</code></code> <br>  What will it look like on Matlab with a stack imitation?  That's how: <br><blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black">%   <br> source_image = imread( <font color="#A31515">'karlson.bmp'</font> ); <br> %       <br> gray_image = source_image(:,:,1); <br> %    0.5 <br> bim= <font color="#0000ff">double</font> (im2bw(gray_image, 0.5)); <br> %   <br> imagesc(bim); <br> <br> newColor = 0.5; oldColor = 1; <br> point.x = 48; point.y = 234; <br> stack = [point]; <br> [wh] = size(bim); <br> stack_size = []; <br> mov = avifile( <font color="#A31515">'karlson_fill2.avi'</font> , <font color="#A31515">'fps'</font> ,50); <br> figure; <br> <font color="#0000ff">while</font> (length(stack) ~=0) <br> point = stack(1); <br> stack(1) = []; %      <br> bim(point.x,point.y) = newColor; %   <br> <br> <font color="#0000ff">if</font> (point.x+1 &lt;= w &amp;&amp; bim(point.x+1,point.y) == oldColor) <br> newpoint.x = point.x+1; <br> newpoint.y = point.y; <br> stack = [stack newpoint]; <br> end; <br> <font color="#0000ff">if</font> (point.x-1 &gt; 0 &amp;&amp; bim(point.x-1,point.y) == oldColor) <br> newpoint.x = point.x-1; <br> newpoint.y = point.y; <br> stack = [stack newpoint]; <br> end; <br> <font color="#0000ff">if</font> (point.y+1 &lt;= h &amp;&amp; bim(point.x,point.y+1) == oldColor) <br> newpoint.x = point.x; <br> newpoint.y = point.y+1; <br> stack = [stack newpoint]; <br> end; <br> <font color="#0000ff">if</font> (point.y-1 &gt; 0 &amp;&amp; bim(point.x,point.y-1) == oldColor) <br> newpoint.x = point.x; <br> newpoint.y = point.y-1; <br> stack = [stack newpoint]; <br> end; <br> stack_size = [stack_size length(stack)]; <br> imagesc(bim); colormap gray; axis image; <br> F = getframe(gca); mov = addframe(mov,F); <br> end; <br> mov = close(mov); <br> figure; imagesc(bim); <br> figure; plot(stack_size);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font> .</a></code></code> </blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black">%   <br> source_image = imread( <font color="#A31515">'karlson.bmp'</font> ); <br> %       <br> gray_image = source_image(:,:,1); <br> %    0.5 <br> bim= <font color="#0000ff">double</font> (im2bw(gray_image, 0.5)); <br> %   <br> imagesc(bim); <br> <br> newColor = 0.5; oldColor = 1; <br> point.x = 48; point.y = 234; <br> stack = [point]; <br> [wh] = size(bim); <br> stack_size = []; <br> mov = avifile( <font color="#A31515">'karlson_fill2.avi'</font> , <font color="#A31515">'fps'</font> ,50); <br> figure; <br> <font color="#0000ff">while</font> (length(stack) ~=0) <br> point = stack(1); <br> stack(1) = []; %      <br> bim(point.x,point.y) = newColor; %   <br> <br> <font color="#0000ff">if</font> (point.x+1 &lt;= w &amp;&amp; bim(point.x+1,point.y) == oldColor) <br> newpoint.x = point.x+1; <br> newpoint.y = point.y; <br> stack = [stack newpoint]; <br> end; <br> <font color="#0000ff">if</font> (point.x-1 &gt; 0 &amp;&amp; bim(point.x-1,point.y) == oldColor) <br> newpoint.x = point.x-1; <br> newpoint.y = point.y; <br> stack = [stack newpoint]; <br> end; <br> <font color="#0000ff">if</font> (point.y+1 &lt;= h &amp;&amp; bim(point.x,point.y+1) == oldColor) <br> newpoint.x = point.x; <br> newpoint.y = point.y+1; <br> stack = [stack newpoint]; <br> end; <br> <font color="#0000ff">if</font> (point.y-1 &gt; 0 &amp;&amp; bim(point.x,point.y-1) == oldColor) <br> newpoint.x = point.x; <br> newpoint.y = point.y-1; <br> stack = [stack newpoint]; <br> end; <br> stack_size = [stack_size length(stack)]; <br> imagesc(bim); colormap gray; axis image; <br> F = getframe(gca); mov = addframe(mov,F); <br> end; <br> mov = close(mov); <br> figure; imagesc(bim); <br> figure; plot(stack_size);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font></a> .</code></code> <br>  You can go to drink tea, while the brow of our dandy is painted gray.  At the same time, the proposed code will also draw us a chart of the stack fullness at each iteration and we will discuss it.  And as a nice bonus code - the output also includes a video clip illustrating the filling.  Why I chose such a small detail as an eyebrow - because it is not possible to fill in something else, such as a belly, taking into account the features of the Matlab language, in a finite time. <br><br><img src="https://habrastorage.org/storage/habraeffect/22/93/2293170294ee568860f7eb3010def1a6.png" alt="image"><br><img src="https://habrastorage.org/storage/habraeffect/3d/34/3d3459a6f424806a2f2e05cb104c14d1.png" alt="image" align="left">  Actually, here are our results: The graph of the stack is shown in logarithmic coordinates in Figure 5. <br>  And the head with a colored eyebrow is depicted in Figure 6. A video illustrating the process of filling the area is proposed for viewing below.  Everything tells us that the algorithm works extremely slowly, look at Figure 5 (on the X axis - the iteration number, on the Y axis - the number of still raw points) how slowly the stack is emptied (consider the logarithmic coordinates), but the thing is There are too many unnecessary check points.  Those points that were filled at the previous stage are still checked at the following.  Of course this is no good.  Next, we will eliminate this injustice!  Video file - 50 frames per second. <br><iframe width="560" height="315" src="https://www.youtube.com/embed/ln-6aBXCMJk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h4>  Fill Algorithm - Fast, Lines </h4><br>  The essence of the recursive algorithm: <br>  We start to fill the current line from one edge to another. <br>  First up from the starting point and then down. <br>  We return to the starting point.  We look - if to the left of the starting point the old color and there is no border, then we fill the new line. <br>  We return to the starting point.  We look - if to the right of the starting point the old color and there is no border, then we fill the new line. <br><br>  Algorithm code: <br><blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black">clear all; <br> %   <br> source_image = imread( <font color="#A31515">'karlson.bmp'</font> ); <br> %       <br> gray_image = source_image(:,:,1); <br> %    0.5 <br> bim= <font color="#0000ff">double</font> (im2bw(gray_image, 0.5)); <br> %   <br> imagesc(bim); <br> <br> newColor = 0.5; oldColor = 1; <br> point.x = 17; point.y = 143; <br> stack = [point]; <br> [wh] = size(bim); <br> stack_size = []; spanLeft = 0; spanRight = 0; <br> <br> mov = avifile( <font color="#A31515">'karlson_fill3.avi'</font> , <font color="#A31515">'fps'</font> ,50); <br> figure; <br> <font color="#0000ff">while</font> (length(stack) ~=0) <br> point = stack(1); <br> stack(1) = []; %      <br> y1 = point.y; <br> <br> %    <br> <font color="#0000ff">while</font> (y1 &gt;= 1 &amp;&amp; bim(point.x,y1) == oldColor) y1 = y1 - 1; end; <br> y1 = y1 + 1; <br> spanLeft = 0; spanRight = 0; <br> %       <br> <font color="#0000ff">while</font> (y1 &lt; h &amp;&amp; bim(point.x,y1) == oldColor) <br> bim(point.x,y1) = newColor; %   <br> <font color="#0000ff">if</font> (spanLeft == 0 &amp;&amp; point.x &gt; 0 &amp;&amp; bim(point.x-1,y1) == oldColor) <br> newpoint.x = point.x-1; newpoint.y = y1; stack = [stack newpoint]; <br> spanLeft = 1; <br> elseif (spanLeft == 1 &amp;&amp; point.x &gt; 0 &amp;&amp; bim(point.x-1,y1) ~= oldColor) <br> spanLeft = 0; <br> end; <br> <br> <font color="#0000ff">if</font> (spanRight == 0 &amp;&amp; point.x &lt; w &amp;&amp; bim(point.x+1,y1) == oldColor) <br> newpoint.x = point.x+1; newpoint.y = y1; stack = [stack newpoint]; <br> spanRight= 1; <br> elseif (spanRight == 1 &amp;&amp; point.x &lt; w &amp;&amp; bim(point.x+1,y1) ~= oldColor) <br> spanRight = 0; <br> end; <br> <br> y1 = y1 + 1; <br> stack_size = [stack_size length(stack)]; <br> imagesc(bim); colormap gray; axis image; <br> F = getframe(gca); mov = addframe(mov,F); <br> end; <br> end; <br> mov = close(mov);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font> .</a></code></code> </blockquote> <code><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="black">clear all; <br> %   <br> source_image = imread( <font color="#A31515">'karlson.bmp'</font> ); <br> %       <br> gray_image = source_image(:,:,1); <br> %    0.5 <br> bim= <font color="#0000ff">double</font> (im2bw(gray_image, 0.5)); <br> %   <br> imagesc(bim); <br> <br> newColor = 0.5; oldColor = 1; <br> point.x = 17; point.y = 143; <br> stack = [point]; <br> [wh] = size(bim); <br> stack_size = []; spanLeft = 0; spanRight = 0; <br> <br> mov = avifile( <font color="#A31515">'karlson_fill3.avi'</font> , <font color="#A31515">'fps'</font> ,50); <br> figure; <br> <font color="#0000ff">while</font> (length(stack) ~=0) <br> point = stack(1); <br> stack(1) = []; %      <br> y1 = point.y; <br> <br> %    <br> <font color="#0000ff">while</font> (y1 &gt;= 1 &amp;&amp; bim(point.x,y1) == oldColor) y1 = y1 - 1; end; <br> y1 = y1 + 1; <br> spanLeft = 0; spanRight = 0; <br> %       <br> <font color="#0000ff">while</font> (y1 &lt; h &amp;&amp; bim(point.x,y1) == oldColor) <br> bim(point.x,y1) = newColor; %   <br> <font color="#0000ff">if</font> (spanLeft == 0 &amp;&amp; point.x &gt; 0 &amp;&amp; bim(point.x-1,y1) == oldColor) <br> newpoint.x = point.x-1; newpoint.y = y1; stack = [stack newpoint]; <br> spanLeft = 1; <br> elseif (spanLeft == 1 &amp;&amp; point.x &gt; 0 &amp;&amp; bim(point.x-1,y1) ~= oldColor) <br> spanLeft = 0; <br> end; <br> <br> <font color="#0000ff">if</font> (spanRight == 0 &amp;&amp; point.x &lt; w &amp;&amp; bim(point.x+1,y1) == oldColor) <br> newpoint.x = point.x+1; newpoint.y = y1; stack = [stack newpoint]; <br> spanRight= 1; <br> elseif (spanRight == 1 &amp;&amp; point.x &lt; w &amp;&amp; bim(point.x+1,y1) ~= oldColor) <br> spanRight = 0; <br> end; <br> <br> y1 = y1 + 1; <br> stack_size = [stack_size length(stack)]; <br> imagesc(bim); colormap gray; axis image; <br> F = getframe(gca); mov = addframe(mov,F); <br> end; <br> end; <br> mov = close(mov);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font></font></a> .</code></code> <br> <br><img src="https://habrastorage.org/storage/habraeffect/a5/9a/a59a0cf14555ad5a1a48e335e06eceb2.png" alt="image"><br>  In Figure 7, we have a graph of the stack population, but in normal coordinates.  A video illustrating the filling of the paw with a new color is offered below.  It is made the same way - 50 frames per second. <br><iframe width="560" height="315" src="https://www.youtube.com/embed/5wGlcwjyyJQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  As we see in this case, our stack (Fig. 7) turns out to be negligibly filled throughout the entire fill, and even with speed we won due to the search with a smaller depth. <br><br><h4>  Conclusion </h4><br>  In conclusion, I want to say - illustrate everything, even such simple algorithms, because there <b>is power in beauty</b> . <br>  Also forgive forgiveness for a long article and as a seed for perhaps the next <br>  Article cite the <a href="http://www.codeproject.com/KB/GDI/QuickFill.aspx">link</a> .  It describes another very interesting and very fast algorithm for filling me unfamiliar to this.  Perhaps there is a hero with free time, who will also analyze this algorithm in detail and with illustrations. <br>  And if someone has more powerful resources, then I propose to pour the belly of Carlson and put a video here, otherwise I have not enough patience while the video is being written.  The blessing for this is all the code. <br><br><h4>  Used sources </h4><br><ol><li>  Lode Vandevenne, Lode's Computer Graphics Tutorial - <a href="http://lodev.org/cgtutor/floodfill.html">link</a> </li><li>  Coloring about Carlson, who lives on the roof, taken from here - <a href="http://www.raskraska.com/raskraski/96/11.html">link</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/116374/">https://habr.com/ru/post/116374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116366/index.html">Activating TRIM SSDs on Mac OS X</a></li>
<li><a href="../116370/index.html">Mobile Form Design Principles</a></li>
<li><a href="../116371/index.html">Jack Dorsey will be back on Twitter</a></li>
<li><a href="../116372/index.html">Unit tests, we try to write correctly, so that later it would not be excruciatingly painful</a></li>
<li><a href="../116373/index.html">Young Entrepreneur Competition</a></li>
<li><a href="../116375/index.html">Reflections on the binding of "Login through ..." to one account</a></li>
<li><a href="../116376/index.html">Logging in Android applications</a></li>
<li><a href="../116378/index.html">American Express launches Paypal</a></li>
<li><a href="../116379/index.html">How to sell SaaS through hosters: the experience of the project "My Warehouse"</a></li>
<li><a href="../116380/index.html">Install video driver for SIS M671 / M672 family of video cards under Ubuntu 11.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>