<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linear algebra for game developers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a translation of a cycle of four articles ‚ÄúLinear algebra for game developers‚Äù, written by David Rosen and dedicated to linear algebra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linear algebra for game developers</h1><div class="post__text post__text-html js-mediator-article">  This article is a translation of a cycle of four articles ‚ÄúLinear algebra for game developers‚Äù, written by David Rosen and dedicated to linear algebra and its application in game development.  The original articles can be found here: <a href="http://blog.wolfire.com/2009/07/linear-algebra-for-game-developers-part-1/">part 1</a> , <a href="http://blog.wolfire.com/2009/07/linear-algebra-for-game-developers-part-2/">part 2</a> , <a href="http://blog.wolfire.com/2010/07/Linear-algebra-for-game-developers-part-3">part 3</a> and <a href="http://blog.wolfire.com/2010/07/Linear-algebra-for-game-developers-part-4">part 4</a> .  I did not publish translations in separate topics, but combined all the articles into one.  I think that it will be more convenient to perceive the material and work with it.  So let's get started. <br><a name="habracut"></a><br><br><h4>  Why do we need linear algebra? </h4><br>  One of the directions in linear algebra is the study of vectors.  If your game uses positioning of on-screen buttons, working with the camera and its direction, the speed of objects, then you will have to deal with vectors.  The better you understand linear algebra, the more control you get over the behavior of vectors and, therefore, over your game. <br><br><h4>  What is a vector? </h4><br>  In games, vectors are used to store locations, directions, and speeds.  Below is an example of a two-dimensional vector: <br><img src="https://habrastorage.org/storage1/8f02819d/528db2ee/e292f9df/620d67ea.jpg"><br>  The location vector (also called the "radius vector") indicates that a person is two meters east and one meter north of the starting point.  The speed vector shows that for a unit of time the plane moves three kilometers up and two miles to the left.  The direction vector tells us that the gun is pointing right. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you can see, the vector itself is just a set of numbers that takes on a particular meaning depending on the context.  For example, a vector (1, 0) can be both a direction for a weapon, as shown in the picture, and coordinates of a building one mile east of your current position.  Or the speed of the cochlea, which moves to the right at a speed of 1 mile per hour ( <i>approx. Translator: rather quickly for a snail, 44 centimeters per second</i> ). <br><br>  It is important to track units.  Suppose we have a vector V (3,5,2).  This tells us little.  Three what, five what?  In our game, <a href="http://www.wolfire.com/overgrowth">Overgrowth</a> distances are indicated in meters and speeds in meters per second.  The first number in this vector is the direction to the east, the second is the direction up, the third is the direction to the north.  Negative numbers denote opposite directions, west, down, and south.  The location defined by the vector V (3,5,2) is located three meters to the east, five meters above and two meters north, as shown in the image below. <br><br><img src="https://habrastorage.org/storage1/2e0616ec/08255cf8/cc576474/e34a8564.jpg"><br><br>  So, we learned the basics of working with vectors.  Now we learn how to use vectors. <br><br><h4>  Vector addition </h4><br>  To add vectors, we just need to add each of their components to each other.  For example: <br><br>  (0, 1, 4) + (3, -2, 5) = (0 + 3, 1-2, 4 + 5) = (3, -1, 9) <br><br>  Why do we need to add vectors?  Most often vector addition in games is used for physical integration.  Any physical object will have vectors for location, speed, and acceleration.  For each frame (usually one sixtieth of a second), we must integrate two vectors: add speed to location and acceleration to speed. <br><br>  Let's look at the <a href="http://mario.nintendo.com/">Mario</a> jumping example.  He starts from position (0, 0).  At the moment of the start of the jump, his speed (1, 3), he quickly moves up and to the right.  Its acceleration is (0, -1), as gravity pulls it down.  The picture shows what his jump looks like, divided into seven frames.  The black text shows its speed in each frame. <br><br><img src="https://habrastorage.org/storage1/5023c609/76dc0e13/e4ed9ccb/b08c92ec.jpg"><br><br>  Let's take a look at the first frames in more detail in order to understand how everything happens. <br><br>  For the first frame, we add Mario's speed (1, 3) to his location (0, 0) and get his new coordinates (1, 3).  Then we add the acceleration (0, -1) with its speed (1, 3) and get the new value of the Mario speed (1, 2). <br><br>  Do the same for the second frame.  Add the speed (1, 2) to the location (1, 3) and get the coordinates (2, 5).  Then we add acceleration (0, -1) to its speed (1, 2) and we get a new speed (1, 1). <br><br>  Usually, the player controls the acceleration of the game character using the keyboard or gamepad, and the game, in turn, calculates new values ‚Äã‚Äãfor speeds and position using physical addition (through vector addition).  This is the same problem that is solved in <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B8%25D1%2581%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">integral calculus</a> , we just greatly simplify it for our game.  I noticed that it was much easier for me to listen attentively to lectures on integral calculus, thinking about its practical application, which we have just described. <br><br><h4>  Subtract vectors </h4><br>  Subtraction is calculated according to the same principle as addition - we subtract the corresponding components of the vectors.  Subtracting vectors is convenient for getting a vector that shows from one location to another.  For example, let the player be located at the coordinates (1, 2) with a laser gun, and the enemy robot is located at the coordinates (4, 3).  To determine the motion vector of the laser beam that will hit the robot, we need to subtract the player‚Äôs location from the robot‚Äôs location.  We get: <br><br>  (4, 3) - (1, 2) = (4-1, 3-2) = (3, 1). <br><br><img src="https://habrastorage.org/storage1/fd9b14b2/010900d9/8e05346c/a3920ab4.jpg"><br><br><h4>  Vector multiplication by scalar </h4><br>  When we talk about vectors, we call individual numbers scalars.  For example (3, 4) is a vector, and 5 is a scalar.  In games, it is often necessary to multiply a vector by a number (scalar).  For example, simulating a simple air resistance by multiplying the player's speed by 0.9 in each frame.  To do this, we need to multiply each component of the vector by a scalar.  If the player‚Äôs speed is (10, 20), then the new speed will be: <br><br>  0.9 * (10, 20) = (0.9 * 10, 0.9 * 20) = (9, 18). <br><br><h4>  Vector length </h4><br>  If we have a ship with a velocity vector V (4, 3), we will also need to find out how fast it is moving in order to calculate the need for screen space or how much fuel is needed.  To do this, we need to find the length (modulus) of the vector V. The length of the vector is indicated by vertical lines, in our case the length of the vector V will be denoted as | V |. <br><br>  We can represent V as a right triangle with sides 4 and 3 and, using the Pythagorean theorem, obtain the hypotenuse from the expression: x <sup>2</sup> + y <sup>2</sup> = h <sup>2</sup> <br><br>  In our case, the length of the vector H with the components (x, y) we get from the square root: sqrt (x <sup>2</sup> + y <sup>2</sup> ). <br><br>  So, the speed of our ship is equal to: <br><br>  | V |  = sqrt (4 <sup>2</sup> + 3 <sup>2</sup> ) = sqrt (25) = 5 <br><br><img src="https://habrastorage.org/storage1/57e7cb45/10162029/e7932a3f/9abb347f.jpg"><br><br>  This approach is also used for three-dimensional vectors.  The length of the vector with the components (x, y, z) is calculated as sqrt (x <sup>2</sup> + y <sup>2</sup> + z <sup>2</sup> ) <br><br><h4>  Distance </h4><br>  If player P is at point (3, 3), and the explosion occurred at point E by coordinates (1, 2), we need to determine the distance between the player and the explosion in order to calculate the degree of damage caused to the player.  This is easy to do by combining the two operations described above: subtracting vectors and their length. <br>  We subtract P - E to get a vector between them.  And then we determine the length of this vector, which gives us the desired distance.  The order of the operands does not matter here, | E - P |  will give the same result. <br><br>  Distance = | P - E |  = | (3, 3) - (1, 2) |  = | (2, 1) |  = sqrt (2 <sup>2</sup> +1 <sup>2</sup> ) = sqrt (5) = 2.23 <br><br><img src="https://habrastorage.org/storage1/943b9357/32efb6aa/686dac13/c3795d70.jpg"><br><br><h4>  Normalization </h4><br>  When we deal with directions (as opposed to locations and speeds), it is important that the direction vector has a length of one.  This greatly simplifies our lives.  For example, let's say the gun is turned in the direction (1, 0) and fires a projectile at a speed of 20 meters per second.  What is the velocity vector for the projectile in this case? <br><br>  Since the direction vector has a length equal to one, we multiply the direction by the velocity of the projectile and get the velocity vector (20, 0).  If the same direction vector has a length other than one, we will not be able to do this.  The projectile will be either too fast or too slow. <br><br>  A vector with a length equal to one is called ‚Äúnormalized‚Äù.  How to make a vector normalized?  Pretty simple.  We divide each component of the vector by its length.  If, for example, we want to normalize a vector V with components (3, 4), we simply divide each component by its length, that is, by 5, and we get (3/5, 4/5).  Now, using the Pythagorean theorem, we make sure that its length is equal to one: <br><br>  (3/5) <sup>2</sup> + (4/5) <sup>2</sup> = 9/25 + 16/25 = 25/25 = 1 <br><br><h4>  Dot product of vectors </h4><br>  What is a scalar product (written as ‚Ä¢)?  To calculate the scalar product of two vectors, we must multiply their components, and then add the results together <br><br>  (a1, a2) ‚Ä¢ (b1, b2) = a1b1 + a2b2 <br><br>  For example: (3, 2) ‚Ä¢ (1, 4) = 3 * 1 + 2 * 4 = 11. At first glance it seems useless, but let's take a closer look at this: <br><br><img src="https://habrastorage.org/storage1/71c4db6a/463fe3b0/a599ed6f/f6ab365a.jpg"><br><br>  Here we can see that if the vectors are pointing in one direction, then their scalar product is greater than zero.  When they are perpendicular to each other, the scalar product is zero.  And when they point in opposite directions, their scalar product is less than zero. <br>  Basically, using the scalar product of vectors, you can calculate how many of them are pointing in one direction.  And although this is only a small part of the capabilities of the scalar product, it is already very useful for us. <br><br>  Suppose we have a guard, located in G (1, 3) looking in the direction of D (1,1), with a viewing angle of 180 degrees.  The main character of the game is watching him from the position H (3, 2).  How to determine whether the protagonist is in sight of the guard or not?  We do this by the scalar product of vectors G and V (a vector directed from the guard to the main character).  We will get the following: <br><br>  V = H - G = (3, 2) - (1, 3) = (3-1, 2-3) = (2, -1) <br>  D ‚Ä¢ V = (1, 1) ‚Ä¢ (2, -1) = 1 * 2 + 1 * -1 = 2-1 = 1 <br><br>  Since the unit is greater than zero, the main character is in the field of view of the guard. <br><br><img src="https://habrastorage.org/storage1/8f48b1b9/fb37e1fc/707d787c/463d239a.jpg"><br><br>  We already know that the scalar product is related to determining the direction of vectors.  And what is its more precise definition?  The mathematical expression of the scalar product of vectors is as follows: <br><br>  A ‚Ä¢ B = | A || B | cosŒò <br><br>  Where Œò (pronounced "theta") is the angle between vectors A and B. <br><br>  This allows us to find Œò (angle) using the expression: <br><br>  Œò = acos ([AB] / [| A || B |]) <br><br>  As I said earlier, normalizing vectors simplifies our lives.  And if A and B are normalized, the expression is simplified as follows: <br><br>  Œò = acos (AB) <br><br>  Let's look again at the scenario with the guard.  Let now the angle of view of the guard will be equal to 120 degrees.  We obtain the normalized vectors for the direction of the guard's look (D ') and for the direction from the guard to the protagonist (V').  Then we define the angle between them.  If the angle is more than 60 degrees (half of the viewing angle), then the main character is out of sight of the guard. <br><br>  D '= D / | D |  = (1, 1) / sqrt (1 <sup>2</sup> + 1 <sup>2</sup> ) = (1, 1) / sqrt (2) = (0.71, 0.71) <br>  V '= V / | V |  = (2, -1) / sqrt (2 <sup>2</sup> + (-1) <sup>2</sup> ) = (2, -1) / sqrt (5) = (0.89, -0.45) <br><br>  Œò = acos (D'V ') = acos (0.71 * 0.89 + 0.71 * (- 0.45)) = acos (0.31) = 72 <br><br>  The angle between the center of the field of view of the guard and the location of the main character is 72 degrees, hence the guard does not see him. <br><br><img src="https://habrastorage.org/storage1/ac7d3545/95251218/f89a580a/005303ff.jpg"><br><br>  I understand that it looks quite difficult, but this is because we do everything manually.  The program is all pretty simple.  Below is shown how I did it in our <a href="http://www.wolfire.com/overgrowth">Overgrowth</a> game with the help of C ++ libraries I wrote for working with vectors: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  vec2 guard_pos = vec2(1,3); vec2 guard_facing = vec2(1,1); vec2 hero_pos = vec2(3,2); //   vec2 guard_facing_n = normalize(guard_facing); vec2 guard_to_hero = normalize(hero_pos - guard_pos); //  float angle = acos(dot(guard_facing_n, guard_to_hero));</span></span></code> </pre> <br><br><h4>  Vector product </h4><br>  Suppose we have a ship with guns that shoot right and left along the course.  Assume that the boat is located along the direction vector (2, 1).  In what directions are guns firing now? <br><br>  It is quite simple in 2D graphics.  To rotate the direction 90 degrees clockwise, simply swap the components of the vector, and then swap the sign of the second component. <br>  (a, b) turns into (b, -a).  Consequently, for a ship located along the vector (2, 1), the cannons on the right along the board will fire in the direction (1, -2), and the guns from the left side will fire in the opposite direction.  Change the signs of the components of the vector and get (-1, 2). <br><br><img src="https://habrastorage.org/storage1/5d26a9bb/42f353c5/e3d8f428/481272da.jpg"><br><br>  And what if we want to calculate this all for three-dimensional graphics?  Consider the ship example. <br>  We have the vector of the mast M directed straight up (0, 1, 0) and the wind direction: north-northeast W (1, 0, 2).  And we want to calculate the direction vector of the sail S in order to ‚Äúcatch the wind‚Äù in the best way. <br><br>  To solve this problem, we use the vector product: S = M x W. <br><br><img src="https://habrastorage.org/storage1/0d6be9c5/f1678383/731c86a1/d6a3a246.jpg"><br><br>  The vector product A (a <sub>1</sub> , a <sub>2</sub> , a <sub>3</sub> ) and B (b <sub>1</sub> , b <sub>2</sub> , b <sub>3</sub> ) will be equal to: <br><br>  (a <sub>2</sub> b <sub>3</sub> -a <sub>3</sub> b <sub>2</sub> , a <sub>3</sub> b <sub>1</sub> -a <sub>1</sub> b <sub>3</sub> , a <sub>1</sub> b <sub>2</sub> -a <sub>2</sub> b <sub>1</sub> ) <br><br>  Now we substitute the values ‚Äã‚Äãwe need: <br><br>  S = MxW = (0, 1, 0) x (1, 0, 2) = ([1 * 2 - 0 * 0], [0 * 1 - 0 * 2], [0 * 0 - 1 * 1] ) = (2, 0, -1) <br><br>  For manual calculations it is quite difficult, but for graphics and gaming applications, I recommend writing a function similar to the one below and not going into details of such calculations. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cross</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 a, vec3 b)</span></span></span><span class="hljs-function"> </span></span>{ vec3 result; result[<span class="hljs-number"><span class="hljs-number">0</span></span>] = a[<span class="hljs-number"><span class="hljs-number">1</span></span>] * b[<span class="hljs-number"><span class="hljs-number">2</span></span>] - a[<span class="hljs-number"><span class="hljs-number">2</span></span>] * b[<span class="hljs-number"><span class="hljs-number">1</span></span>]; result[<span class="hljs-number"><span class="hljs-number">1</span></span>] = a[<span class="hljs-number"><span class="hljs-number">2</span></span>] * b[<span class="hljs-number"><span class="hljs-number">0</span></span>] - a[<span class="hljs-number"><span class="hljs-number">0</span></span>] * b[<span class="hljs-number"><span class="hljs-number">2</span></span>]; result[<span class="hljs-number"><span class="hljs-number">2</span></span>] = a[<span class="hljs-number"><span class="hljs-number">0</span></span>] * b[<span class="hljs-number"><span class="hljs-number">1</span></span>] - a[<span class="hljs-number"><span class="hljs-number">1</span></span>] * b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Vector artwork is often used in games to calculate surface normals.  Directions in which this or that surface "looks".  For example, consider a triangle with vectors A, B, and C. How do we find the direction in which the triangle "looks", that is, the direction perpendicular to its plane?  It seems difficult, but we have a tool for solving this problem. <br><br>  Use subtraction to determine the direction from A to C (C - A), let it be ‚Äúface 1‚Äù (Edge 1) and the direction from A to B (B - A), let it be ‚Äúface 2‚Äù (Edge 2) .  And then we apply the vector product to find a vector perpendicular to both of them, that is, perpendicular to the plane of the triangle, also called the "normal to the plane." <br><br><img src="https://habrastorage.org/storage1/4cd2dec2/fdc1ff06/275323c6/da28f868.jpg"><br><br>  This is what the code looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTriangleNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 a, vec3 b, vec3 c)</span></span></span><span class="hljs-function"> </span></span>{ vec3 edge1 = ba; vec3 edge2 = ca; vec3 normal = cross(edge1,edge2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normal; }</code> </pre><br>  In games, the basic expression of illuminance is written as N ‚Ä¢ L, where N is the normal to the illuminated surface, and L is the normalized vector of the direction of light.  As a result, the surface looks bright when light directly falls on it, and dark when it does not occur. <br><br>  We now turn to the consideration of such an important concept for game developers as the "transformation matrix" (transformation matrix). <br><br>  To begin, examine the "building blocks" of the transformation matrix. <br><br><h4>  Basic vector </h4><br>  Suppose we write the game <a href="http://ru.wikipedia.org/wiki/Asteroids">Asteroids</a> on a very old "hardware" and we need a simple two-dimensional spacecraft that can freely rotate in its plane.  The ship model looks like this: <br><br><img src="https://habrastorage.org/storage1/1d3c67c1/af2da09d/dc6a82e6/d9ba1d66.jpg"><br><br>  How do we draw a ship when the player turns it to an arbitrary degree, say 49 degrees counterclockwise.  Using trigonometry, we can write a two-dimensional rotation function that takes the coordinates of a point and the angle of rotation, and returns the coordinates of the offset point: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 point, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle)</span></span></span></span>{ vec2 rotated_point; rotated_point.x = point.x * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle) - point.y * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle); rotated_point.y = point.x * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle) + point.y * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotated_point; }</code> </pre><br>  Applying this function to all three points, we get the following picture: <br><br><img src="https://habrastorage.org/storage1/996aa068/89d24b3b/47ffa65f/67bf403a.jpg"><br><br>  Operations with sines and cosines work rather slowly, but since we only make calculations for three points, it will work fine even on the old ‚Äúhardware‚Äù ( <i>note of the translator: in cases when it is intended to use trigonometric functions intensively, to speed up the calculations, Memory organizes tables of values ‚Äã‚Äãfor each function and calculates them when the application is started. Then, when calculating a particular trigonometric function, the table is simply referenced</i> . <br><br>  Let now our ship looks like this: <br><br><img src="https://habrastorage.org/storage1/3f51c9f3/d54a5b5c/fd7ebc89/045a7462.jpg"><br><br>  Now the old approach will be too slow, since it will be necessary to turn a fairly large number of points.  One of the elegant solutions to this problem will sound like this: ‚ÄúWhat if, instead of turning each point of the ship model, we turn the coordinate grid of our model?‚Äù <br><br><img src="https://habrastorage.org/storage1/a699420a/9b10bcee/48264208/6cb91081.jpg"><br><br>  How it works?  Let's take a closer look at what the coordinates are. <br>  When we talk about a point with coordinates (3, 2), we say that its location is three steps from the point of reference on the coordinate axis X, and two steps from the point of reference on the coordinate axis Y. <br><br>  By default, the coordinate axes are arranged as follows: the vector of the coordinate axis X (1, ‚Äã‚Äã0), the vector of the coordinate axis Y (0, 1).  And we get the location: 3 (1, 0) + 2 (0, 1).  But coordinate axes do not have to be in this position.  If we rotate the coordinate axes, at this time we rotate all points in the coordinate lattice. <br><br>  To get the rotated X and Y axes, we will use the trigonometric functions that we talked about above.  If we rotate by 49 degrees, the new coordinate axis X will be obtained by rotating the vector (0, 1) 49 degrees, and the new coordinate axis Y will be obtained by rotating the vector (0, 1) 49 degrees.  So, the vector of the new X axis will be equal to (0.66, 0.75), and the vector of the new Y axis will be (-0.75, 0.66).  We do this manually for our simple three-point model to make sure that it works as it should: <br><br>  The coordinates of the top point (0, 2), which means that its new location is at 0 on the new (rotated) X axis and 2 on the new Y axis: <br><br>  0 * (0.66,0.75) + 2 * (- 0.75, 0.66) = (-1.5, 1.3) <br><br>  The lower left point is (-1, -1), which means that its new location is -1 on the rotated X axis, and -1 on the rotated Y axis: <br><br>  -1 * (0.66,0.75) + -1 * (- 0.75, 0.66) = (0.1, -1.4) <br><br>  Lower right point (1, -1), which means its new location is 1 on the rotated X axis, and -1 on the rotated Y axis <br><br>  1 * (0.66,0.75) + -1 * (- 0.75, 0.66) = (1.4, 0.1) <br><br><img src="https://habrastorage.org/storage1/09022a3f/4b454fde/7cb641c3/c0d8725e.jpg"><br><br>  We showed how the coordinates of the ship are displayed in a different coordinate grid with rotated axes (or "basis vectors").  This is convenient in our case, since it saves us from having to apply trigonometric transformations to each of the points of the ship model. <br><br>  Every time we change the basis vectors (1, 0) and (0, 1) to (a, b) and (c, d), then the new coordinate of the point (x, y) can be found using the expression: <br><br>  x (a, b) + y (c, d) <br><br>  Usually the basis vectors are (1, 0) and (0, 1) and we just get x (1, 0) + y (0, 1) = (x, y), and there is no need to take care of this further.  However, it is important to remember that we can use other basic vectors when we need it. <br><br><h4>  Matrices </h4><br>  Matrices are like two-dimensional vectors.  For example, a typical 2x2 matrix might look like this: <br><br><pre>    [acbd]
</pre><br>  When you multiply a matrix by a vector, you add the scalar product of each row to the vector by which it is multiplied.  For example, if we multiply the above matrix by the vector (x, y), then we get: <br><br>  (a, c) ‚Ä¢ (x, y) + (b, d) ‚Ä¢ (x, y) <br><br>  Being written differently, this expression looks like this: <br><br>  x (a, b) + y (c, d) <br><br>  Looks familiar, isn't it?  This is exactly the same expression that we used to change the basis vectors.  This means that by multiplying the 2x2 matrix by a two-dimensional vector, we thereby change the basis vectors.  For example, if we insert the standard basis vectors in (1, 0) and (0, 1) into the columns of the matrix, then we get: <br><br><pre> [ten 
  0 1]
</pre><br>  This is the identity matrix that does not give the effect that we can expect from the neutral basis vectors that we have indicated.  If, however, we rotate the base vectors by 49 degrees, we get: <br><br><pre> [0.66 -0.75 
  0.75 0.66]
</pre><br>  This matrix will rotate the 2D vector 49 degrees counterclockwise.  We can make the code of our game Asteriods more elegant using matrices like this.  For example, the rotation function of our ship might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateShip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> degrees)</span></span></span></span>{ Matrix2x2 R = GetRotationMatrix(degrees); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;num_points; ++i){ rotated_point[i] = R * point[i]; } }</code> </pre><br>  However, our code will be even more elegant if we can also include in this matrix the movement of the ship in space.  Then we will have a single data structure that will contain and apply information about the orientation of the object and its location in space. <br><br>  Fortunately, there is a way to achieve this, even though it does not look very elegant.  If we want to move using the vector (e, f), we only include it in our transformation matrix: <br><br><pre> [acebdf 0 0 1]
</pre><br>  And we add an additional unit to the end of each vector defining the location of the object, like this: <br><br>  [xy 1] <br><br>  Now, when we multiply them, we get: <br><br>  (a, c, e) ‚Ä¢ (x, y, 1) + (b, d, f) ‚Ä¢ (x, y, 1) + (0, 0, 1) ‚Ä¢ (x, y, 1) <br><br>  Which, in turn, can be written as: <br><br>  x (a, b) + y (c, d) + (e, f) <br><br>  Now we have a complete transformation mechanism, enclosed in a single matrix.  This is important if you do not take into account the elegance of the code, since with it we can now use all the standard matrix manipulations.  For example, multiply the matrices to add the desired effect, or we can invert the matrix to get the exact opposite position of the object. <br><br><h4>  Three-dimensional matrix </h4><br>  Matrices in three-dimensional space work the same way as in two-dimensional.  I gave examples of two-dimensional vectors and matrices, since they are simply displayed using a display showing a two-dimensional image.  We just need to define three columns for basis vectors, instead of two.  If the basis vectors are (a, b, c), (d, e, f) and (g, h, i) then our matrix will look like this: <br><br><pre> [adgbehcfi]
</pre><br>  If we need to move (j, k, l), then we add an extra column and row, as we said before: <br><br><pre> [adgjbehkcfil 0 0 0 1]
 </pre><br>  And we add one [1] to the vector, like this: <br><br>  [xyz 1] <br><br><h4>  Rotation in two-dimensional space </h4><br>  Since in our case we only have one axis of rotation (located on the display), the only thing we need to know is the angle.  I mentioned this earlier, mentioning that we can use trigonometric functions to implement a two-dimensional rotation function like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 point, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle)</span></span></span></span>{ vec2 rotated_point; rotated_point.x = point.x * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle) - point.y * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle); rotated_point.y = point.x * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle) + point.y * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotated_point; }</code> </pre><br>  More elegantly, this can be expressed in a matrix form.  To determine the matrix, we can apply this function to the axes (1, 0) and (0, 1) for the angle Œò, and then include the resulting axes in the columns of our matrix.  So let's start with the coordinate axis X (1, ‚Äã‚Äã0).  If we apply our function to it, we get: <br><br>  (1 * cos (Œò) - 0 * sin (Œò), 1 * sin (Œò) + 0 * cos (Œò)) = (cos (Œò), sin ()) <br><br>  Then, we include the coordinate axis Y (0, 1).  We get: <br><br>  (0 * cos (Œò) - 1 * sin (Œò), 0 * sin (Œò) + 1 * cos (Œò)) = (-sin (Œò), cos (Œò)) <br><br>  We include the obtained coordinate axes in the matrix, and we obtain a two-dimensional rotation matrix: <br><br><pre> [cos (Œò) -sin (Œò) 
  sin (Œò) cos (Œò)]
</pre><br>  Apply this matrix to <a href="http://ru.wikipedia.org/wiki/Blender">Suzanne</a> , the monkey from the Blender graphics package.  The angle of rotation Œò is 45 degrees clockwise. <br><br><img src="http://habrastorage.org/storage1/e425adb3/65f47c0a/d50ee434/cbd88b20.jpg"><br><br>  As you can see, it works.  But what if we need to rotate around a point other than (0, 0)? <br>  For example, we want to rotate the monkey's head around a point located in its ear: <br><br><img src="http://habrastorage.org/storage1/df45b131/754ee562/e7becb02/35e91914.jpg"><br><br>  To do this, we can start by creating the translation matrix T, which moves the object from the starting point to the point of rotation in the ear of the monkey, and the rotation matrix R, to rotate the object around the starting point.  Now, to rotate around a point in the ear, we can first move the point in the ear to the place of the initial point, by inverting the matrix T, written as T <sup>-1</sup> .  Then, we rotate the object around the starting point, using the R matrix, and then apply the T matrix to move the rotation point back to its original position. <br>  Below is an illustration of each of the steps described: <br><br><img src="http://habrastorage.org/storage1/5eb91170/b16c9d98/7ead79d6/eeecc5c7.jpg"><br><br>  This is an important pattern that we will apply later - applying rotation to two opposite transformations allows us to rotate an object in another ‚Äúspace‚Äù.  Which is very convenient and useful. <br><br>  Now consider the three-dimensional rotation. <br><br><h4>  3D rotation </h4><br>  Rotation around the Z axis works on the same principle as rotation in two-dimensional space.  We just need to change our old matrix by adding an additional column and row to it: <br><br><pre> [cos (Œò) -sin (Œò) 0 
  sin (Œò) cos (Œò) 0 
  0 0 1]
</pre><br>  Apply this matrix to the three-dimensional version of Suzanne, the monkey from the Blender package.  The angle of rotation Œò let it be equal to 45 degrees clockwise. <br><br><img src="http://habrastorage.org/storage1/416370a7/b2b77324/7e4cbe98/58abab42.jpg"><br><br>  Same.  Rotation only around the Z axis limits us, what about rotation around an arbitrary axis? <br><br><h4>  The rotation defined by the axis and angle (Axis-angle rotation) </h4><br>  The representation of rotation defined by the axis and angle is also known as rotation in exponential coordinates, parametrized by the rotation of two quantities.  The vector that determines the rotation of the guide axis (straight line) and the angle that describes the amount of rotation around this axis.  Rotation is carried out according to the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2580%25D1%2583%25D0%25BA%25D0%25B8">rule of the right hand</a> . <br><br>  So, rotation is defined by two parameters (axis, angle), where axis is the vector of the axis of rotation, and angle is the angle of rotation.  This technique is quite simple and is a starting point for many other rotation operations that I work with.  How to practically apply the rotation defined by the axis and angle? <br><br>  Suppose we are dealing with an axis of rotation shown in the figure below: <br><br><img src="http://habrastorage.org/storage1/74641b4a/ab2a300b/fef3adda/46cddbe0.jpg"><br><br>  We know how to rotate an object around the Z axis, and we know how to rotate an object in other spaces.  So, we just need to create a space where our axis of rotation will be the Z axis. And if this axis is the Z axis, then what will be the X and Y axes?  Let's do the calculations now. <br><br>  To create new X and Y axes, we only need to choose two vectors that are perpendicular to the new Z axis and perpendicular to each other.  We have already spoken earlier about vector multiplication, which takes two vectors and gives as a result a vector perpendicular to them. <br><br>  We have one vector now, this is the axis of rotation, let's call it A. Now let's take another random vector B, which is not in the same direction as vector A. Let it be (0, 0, 1) for example. <br><br>  Now we have the rotation axis A and the random vector B, we can get the normal C through the vector product A and B. C is perpendicular to the vectors A and B. Now we make the vector B perpendicular to the vectors A and C through their vector product.  And that's it, we have all the coordinate axes we need. <br><br>  In words, it sounds difficult, but it looks pretty simple in code or when shown in pictures. <br>  Below is what this looks like in code: <br><br><pre> <code class="cpp hljs">B = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); C = cross(A,B); B = cross(C,A);</code> </pre><br>  Here is an illustration for each step: <br><br><img src="http://habrastorage.org/storage1/fdb23dab/3781f978/7cc5097e/26c1f13c.jpg"><br><br>  Now, having information about new coordinate axes, we can create a matrix M, including each axis as a column in this matrix.  We need to make sure that vector A is the third column so that it is our new axis of coordinates Z. <br><br><pre> [B0 C0 A0 
  B1 C1 A1 
  B2 C2 A2]
</pre><br>  Now this is similar to what we did to rotate in two-dimensional space.  We can use the inverted matrix M to move to a new coordinate system, then rotate, according to the matrix R, to rotate the object around the Z axis, then apply the matrix M to return to the original coordinate space. <br><br><img src="http://habrastorage.org/storage1/ed577a62/873c11e7/02e64420/c1a3db0f.jpg"><br><br>  Now we can rotate the object around an arbitrary axis.  In the end, we can simply create a matrix T = T = M <sup>-1</sup> RM and use it many times, without additional efforts on our part.  There are more efficient ways of converting rotations, defined by the axis and angle into rotation, defined by matrices.  The approach we just described shows a lot of what we talked about earlier. <br><br>  The rotation defined by the axis and angle is perhaps the most intuitive way.  Applying it, it is very easy to invert the rotation by changing the sign at the corner, and it is easy to interpolate by interpolating the angle.  However, there is a serious limitation, and it lies in the fact that such a rotation is not summing.  That is, you cannot combine two rotations, defined by the axis and the angle to the third. <br>  The rotation defined by the axis and the angle is a good way to start, but it must be transformed into something else in order to be used in more complex cases. <br><br><h4>  Euler angles </h4><br>  Euler angles represent another method of rotation, consisting in three nested rotations about the X, Y, and Z axes. You may have encountered their use in games where the camera shows the action from the first person, or from the third person. <br><br>  Suppose you are playing a first-person shooter and you turned 30 degrees to the left and then looked 40 degrees up.  In the end, you get shot, fall, and as a result of the impact, the camera rotates around its axis by 45 degrees.  Below is shown the rotation using Euler angles (30, 40, 45). <br><br><img src="http://habrastorage.org/storage1/a4f9a0e9/7149d4a7/df16362c/5d0a43fa.jpg"><br><br>  Euler angles are a convenient and easy-to-manage tool.  But this method has two drawbacks. <br><br>  The first is the likelihood of a situation called <a href="http://www.wikiznanie.ru/ru-wz/index.php/%25D0%25A8%25D0%25B0%25D1%2580%25D0%25BD%25D0%25B8%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B7%25D0%25B0%25D0%25BC%25D0%25BE%25D0%25BA">‚Äúaxle lock‚Äù or ‚Äúhinge lock‚Äù (gimbal lock)</a> .  Imagine that you are playing a first-person shooter where you can look left, right, up and down, or turn the camera around the visual axis.  Now imagine that you are looking straight up.  In this situation, an attempt to look to the left or to the right will be similar to an attempt to rotate the camera.  In this case, all we can do is rotate the camera around its axis, or look down.  As you can imagine, this restriction makes it impractical to use Euler angles in flight simulators. <br><br>  The second is that interpolation between two Euler angles of rotation does not give the shortest path between them. <br>  For example, you have two interpolations between two identical rotations.  The first uses the Euler angle interpolation, the second uses spherical linear interpolation (SLERP) to find the shortest path. <br><br><img src="http://habrastorage.org/storage1/a847c23d/ebb88158/692bacbb/ea90283d.jpg"><br><br>  So, what is more suitable for interpolating rotations?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maybe matrices? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rotation using matrices </font></font></h4><br>     ,         .  ,          .       ,  -   . ,        -: <br><br><img src="http://habrastorage.org/storage1/f27ffbee/b15e1b16/68fa13c8/597062b6.jpg"><br><br>    ,    ,     ,        .  ,   ‚Äî  ,            . <br><br>       ¬´ ¬ª (candy wrapper effect),    .            <a href="http://www.youtube.com/WolfireGames">Overgrowth</a> ( <i>. :      </i> ). <br><br><img src="http://habrastorage.org/storage1/861bdb91/d5b69dc4/2ccd8bab/11e65e7e.jpg"><br><br> ,    ,  ,         ,    (gimbal lock),        .          .         ‚Äî     . <br><br> ,    ,     ,      . <br><br> ,      . ,    , . <br><br><h4>  </h4><br> -  ?   ,     ,      (axis-angle rotation),    . <br><br>      ,         ,      (gimbal lock).   - ,    ,         . <br><br> -   ,     (rotation formats)? <br>           .       ,  ,    ,       . ,   . <br><br> -      .         ,    . -,      ,       ,     . <br><br>  ,              .          ,      . <br><br> ¬´ ¬ª         . , ,     ,     .      ,    ,         . <br><br>   <a href="http://bulletphysics.org/">¬´Bullet¬ª</a>  <a href="http://www.blender.org/">¬´Blender¬ª</a>     . </div><p>Source: <a href="https://habr.com/ru/post/131931/">https://habr.com/ru/post/131931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131923/index.html">New version of Kinect for Windows SDK, new website and blog for developers released</a></li>
<li><a href="../131925/index.html">Online UML editor</a></li>
<li><a href="../131926/index.html">Why Agile doesn't suit you</a></li>
<li><a href="../131929/index.html">Apple infringed two Motorola Mobility patents. Apple may be banned in the EU</a></li>
<li><a href="../131930/index.html">New version of free tender b2b platform</a></li>
<li><a href="../131932/index.html">WP7 client for TechDays.ru</a></li>
<li><a href="../131933/index.html">Multi-WAN without a headache, or TP-Link TL-R480T +</a></li>
<li><a href="../131935/index.html">IPhone interface emulation with CSS</a></li>
<li><a href="../131936/index.html">The history of hacking a browser game. Return control</a></li>
<li><a href="../131937/index.html">Quick Attach to Process</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>