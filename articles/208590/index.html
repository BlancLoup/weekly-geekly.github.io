<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúFriends‚Äù redis with nginx</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is no secret that to protect against HTTP-DDoS, nginx is often used as a frontend and some other web server as backend. In this case, due to the la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúFriends‚Äù redis with nginx</h1><div class="post__text post__text-html js-mediator-article">  It is no secret that to protect against HTTP-DDoS, nginx is often used as a frontend and some other web server as backend.  In this case, due to the large load, there is a problem of storing logs for further analysis.  It can be stored in a text file, but, naturally, it is very inconvenient to analyze / rotate it.  You can drive data directly to, for example, mysql through the pipe, but winning in the convenience of the analysis we lose in performance, this is especially noticeable with fragmentation.  The golden mean will probably be a no-sql solution. <br>  For myself, I chose redis. <br><a name="habracut"></a><br>  To store the logs we will write a small module for nginx.  Initially, the module was implemented using the official C-shnogo client hiredis, but accidentally stumbled upon a similar <a href="http://www.binpress.com/app/nginx-redislog-module/998">module from Valery Kholodkov</a> , who already had more functionality, and the interaction was implemented without the use of third-party clients and decided to borrow his ideas (on tests, they showed almost equal performance values). <br>  In the module from Valeriy, the work of EVALSHA was corrected, minor bugs were fixed, and SETEX support was added. <br><div class="spoiler">  <b class="spoiler_title">ngx_http_redislog_module.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Copyright (C) 2012 Valery Kholodkov * 2014 Alexander V Makkoveev */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ngx_config.h&gt; #include &lt;ngx_core.h&gt; #include &lt;ngx_http.h&gt; #include &lt;nginx.h&gt; #define NGX_SOCKETLOG_FACILITY_LOCAL7 23 #define NGX_SOCKETLOG_SEVERITY_INFO 6 #define NGX_REDIS_APPEND "*3" CRLF "$6" CRLF "APPEND" CRLF #define NGX_REDIS_AUTH "*2" CRLF "$4" CRLF "AUTH" CRLF //#define NGX_DEF_FORMAT "combined" #define NGX_DEF_FORMAT "main" #define IF_DEBUG 0 #define IF_DEBUG_2 0 //***************************************************************************** typedef struct ngx_http_log_op_s ngx_http_log_op_t; typedef u_char *(*ngx_http_log_op_run_pt) (ngx_http_request_t *r, u_char *buf, ngx_http_log_op_t *op); typedef size_t (*ngx_http_log_op_getlen_pt) (ngx_http_request_t *r, uintptr_t data); struct ngx_redislog_peer; typedef void (*ngx_redislog_send_handler_pt)(struct ngx_redislog_peer*); struct ngx_http_log_op_s { size_t len; ngx_http_log_op_getlen_pt getlen; ngx_http_log_op_run_pt run; uintptr_t data; }; typedef struct { ngx_str_t name; #if defined nginx_version &amp;&amp; nginx_version &gt;= 7018 ngx_array_t *flushes; #endif ngx_array_t *ops; /* array of ngx_http_log_op_t */ } ngx_http_log_fmt_t; typedef struct { ngx_array_t formats; /* array of ngx_http_log_fmt_t */ ngx_uint_t combined_used; /* unsigned combined_used:1 */ } ngx_http_log_main_conf_t; typedef struct { ngx_str_t name; struct sockaddr *sockaddr; socklen_t socklen; ngx_msec_t write_timeout; ngx_msec_t read_timeout; ngx_msec_t connect_timeout; ngx_msec_t reconnect_timeout; ngx_msec_t flush_timeout; ngx_msec_t ping_timeout; ngx_bufs_t bufs; size_t recv_buf_size; ngx_str_t password; unsigned authenticate:1; } ngx_redislog_peer_conf_t; typedef struct { ngx_array_t *peers; } ngx_redislog_conf_t; typedef struct ngx_redislog_peer { ngx_redislog_peer_conf_t *conf; ngx_peer_connection_t conn; ngx_event_t reconnect_timer; ngx_event_t flush_timer; ngx_event_t ping_timer; ngx_log_t *log; ngx_pool_t *pool; ngx_chain_t *busy; ngx_chain_t *free; ngx_buf_t *recv_buf; ngx_uint_t discarded; ngx_uint_t reconnect_timeout; ngx_uint_t num_queued; ngx_uint_t state; u_char *password_pos; ngx_redislog_send_handler_pt send_handler; unsigned connecting:1; unsigned authenticated:1; unsigned flush_timer_set:1; } ngx_redislog_peer_t; typedef struct { ngx_str_t peer_name; ngx_uint_t peer_idx; ngx_http_log_fmt_t *format; ngx_http_complex_value_t *key; ngx_str_t command; ngx_str_t arg1; //*** //ngx_str_t arg_num; //*** ngx_http_complex_value_t *_if; ngx_http_complex_value_t *ifnot; unsigned has_arg1; } ngx_http_redislog_t; typedef struct { ngx_array_t *logs; /* array of ngx_http_redislog_t */ unsigned off; } ngx_http_redislog_conf_t; static ngx_array_t ngx_redislog_peers; static void ngx_redislog_reconnect_peer(ngx_redislog_peer_t *p); static void ngx_http_redislog_append(ngx_redislog_peer_t *p, u_char *buf, size_t len); static void ngx_http_redislog_send(ngx_redislog_peer_t *p); static void ngx_redislog_flush_handler(ngx_event_t*); static u_char *ngx_redislog_size(u_char*, u_char*, size_t); static size_t ngx_redislog_size_len(size_t); static ngx_int_t ngx_redislog_process_buf(ngx_redislog_peer_t*, ngx_buf_t*); static void ngx_redislog_read_handler(ngx_event_t *rev); static void ngx_redislog_idle_read_handler(ngx_event_t *rev); static char *ngx_http_redislog_set_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); static char *ngx_http_redislog_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf); static void *ngx_http_redislog_create_loc_conf(ngx_conf_t *cf); static char *ngx_http_redislog_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child); static ngx_int_t ngx_http_redislog_yyyy_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data); static ngx_int_t ngx_http_redislog_yyyymm_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data); static ngx_int_t ngx_http_redislog_yyyymmdd_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data); static ngx_int_t ngx_http_redislog_yyyymmddhh_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data); static void *ngx_redislog_create_conf(ngx_cycle_t *cycle); static ngx_int_t ngx_http_redislog_add_variables(ngx_conf_t *cf); static ngx_int_t ngx_http_redislog_init(ngx_conf_t *cf); static ngx_int_t ngx_redislog_init_process(ngx_cycle_t *cycle); static ngx_command_t ngx_http_redislog_commands[] = { { ngx_string("access_redislog"), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_SIF_CONF|NGX_HTTP_LIF_CONF |NGX_HTTP_LMT_CONF|NGX_CONF_TAKE1234, ngx_http_redislog_set_log, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL }, ngx_null_command }; static ngx_http_module_t ngx_http_redislog_module_ctx = { ngx_http_redislog_add_variables, /* preconfiguration */ ngx_http_redislog_init, /* postconfiguration */ NULL, /* create main configuration */ NULL, /* init main configuration */ NULL, /* create server configuration */ NULL, /* merge server configuration */ ngx_http_redislog_create_loc_conf, /* create location configration */ ngx_http_redislog_merge_loc_conf /* merge location configration */ }; extern ngx_module_t ngx_http_log_module; ngx_module_t ngx_http_redislog_module = { NGX_MODULE_V1, &amp;ngx_http_redislog_module_ctx, /* module context */ ngx_http_redislog_commands, /* module directives */ NGX_HTTP_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING }; static ngx_command_t ngx_redislog_commands[] = { { ngx_string("redislog"), NGX_MAIN_CONF|NGX_CONF_TAKE23, ngx_http_redislog_command, 0, 0, NULL }, ngx_null_command }; static ngx_core_module_t ngx_redislog_module_ctx = { ngx_string("redislog"), ngx_redislog_create_conf, NULL }; ngx_module_t ngx_core_redislog_module = { NGX_MODULE_V1, &amp;ngx_redislog_module_ctx, /* module context */ ngx_redislog_commands, /* module directives */ NGX_CORE_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ ngx_redislog_init_process, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING }; static ngx_http_variable_t ngx_http_redislog_variables[] = { { ngx_string("redislog_yyyy"), NULL, ngx_http_redislog_yyyy_variable, 0, 0, 0 }, { ngx_string("redislog_yyyymm"), NULL, ngx_http_redislog_yyyymm_variable, 0, 0, 0 }, { ngx_string("redislog_yyyymmdd"), NULL, ngx_http_redislog_yyyymmdd_variable, 0, 0, 0 }, { ngx_string("redislog_yyyymmddhh"), NULL, ngx_http_redislog_yyyymmddhh_variable, 0, 0, 0 }, { ngx_null_string, NULL, NULL, 0, 0, 0 } }; //----------------------------------------------------------------------------- ngx_int_t ngx_http_redislog_handler(ngx_http_request_t *r) { u_char *line, *p; size_t len, command_size_len, arg1_size_len, record_len, key_size_len, record_size_len; ngx_uint_t i, l; ngx_str_t key, _if, ifnot; ngx_http_redislog_t *log; ngx_http_log_op_t *op; ngx_http_redislog_conf_t *slcf; time_t time; ngx_tm_t tm; ngx_redislog_peer_t **peer; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, "http redislog handler"); slcf = ngx_http_get_module_loc_conf(r, ngx_http_redislog_module); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, "redislog conf=%p, off=%ud, logs=%p", slcf, slcf-&gt;off, slcf-&gt;logs); if(slcf-&gt;off || slcf-&gt;logs == NULL) { return NGX_OK; } time = ngx_time(); ngx_gmtime(time, &amp;tm); log = slcf-&gt;logs-&gt;elts; for (l = 0; l &lt; slcf-&gt;logs-&gt;nelts; l++) { #if defined nginx_version &amp;&amp; nginx_version &gt;= 7018 ngx_http_script_flush_no_cacheable_variables(r, log[l].format-&gt;flushes); #endif len = 0; op = log[l].format-&gt;ops-&gt;elts; for (i = 0; i &lt; log[l].format-&gt;ops-&gt;nelts; i++) { if (op[i].len == 0) { len += op[i].getlen(r, op[i].data); } else { len += op[i].len; } } if(log[l].ifnot != NULL) { if(ngx_http_complex_value(r, log[l].ifnot, &amp;ifnot) != NGX_OK) { return NGX_ERROR; } if(ifnot.len &amp;&amp; (ifnot.len != 1 || ifnot.data[0] != '0')) { continue; } } if(log[l]._if != NULL) { if(ngx_http_complex_value(r, log[l]._if, &amp;_if) != NGX_OK) { return NGX_ERROR; } if(!_if.len || (_if.len == 1 &amp;&amp; _if.data[0] == '0')) { continue; } } if(ngx_http_complex_value(r, log[l].key, &amp;key) != NGX_OK) { return NGX_ERROR; } command_size_len = ngx_redislog_size_len(log[l].command.len); key_size_len = ngx_redislog_size_len(key.len); if(log[l].arg1.len) { arg1_size_len = ngx_redislog_size_len(log[l].arg1.len); } else { arg1_size_len = 0; } len += 2 + sizeof(CRLF) - 1 + 1 + command_size_len + 1 + sizeof(CRLF) - 1 + command_size_len + sizeof(CRLF) - 1 + log[l].command.len + sizeof(CRLF) - 1 + key_size_len + sizeof(CRLF) - 1 + key.len + sizeof(CRLF) - 1 + 1 + NGX_OFF_T_LEN + sizeof(CRLF) - 1 + sizeof(CRLF) - 1; if(ngx_strncmp(log[l].command.data, "APPEND", 6) == 0) { len++; } if(log[l].has_arg1) { len += arg1_size_len + sizeof(CRLF) - 1 + log[l].arg1.len + sizeof(CRLF) - 1; } #if defined nginx_version &amp;&amp; nginx_version &gt;= 7003 line = ngx_pnalloc(r-&gt;pool, len); #else line = ngx_palloc(r-&gt;pool, len); #endif if (line == NULL) { return NGX_ERROR; } p = line; for(i = 0; i &lt; log[l].format-&gt;ops-&gt;nelts; i++) { p = op[i].run(r, p, &amp;op[i]); } if(ngx_strncmp(log[l].command.data, "APPEND", 6) == 0) { *p++ = LF; } record_len = p - line; record_size_len = ngx_redislog_size_len(record_len); p = line; /* * Redis append to time series command *3 $6 APPEND $nnn key $nnn log record */ *p++ = '*'; //*p++ = log[l].has_arg1 ? '4' : '3'; /* SETEX */ if(ngx_strncmp(log[l].command.data, "SETEX", 5) == 0) *p++ = '4'; else *p++ = log[l].has_arg1 ? '5' : '3'; p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); *p++ = '$'; //*p++ = '0'; p = ngx_redislog_size(p, p + command_size_len, log[l].command.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); p = ngx_copy(p, log[l].command.data, log[l].command.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); if(log[l].has_arg1 &amp;&amp; ngx_strncmp(log[l].command.data, "EVALSHA", 7) == 0) { *p++ = '$'; p = ngx_redislog_size(p, p + arg1_size_len, log[l].arg1.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); p = ngx_copy(p, log[l].arg1.data, log[l].arg1.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); *p++ = '$'; p = ngx_redislog_size(p, p + 1, 1); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); p = ngx_copy(p, "1", 1); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); } /* *p++ = '$'; *p++ = '1'; *p++ = LF; *p++ = '0'; *p++ = LF; */ *p++ = '$'; p = ngx_redislog_size(p, p + key_size_len, key.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); p = ngx_copy(p, key.data, key.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); if(log[l].has_arg1 &amp;&amp; ngx_strncmp(log[l].command.data, "SETEX", 5) == 0) { *p++ = '$'; p = ngx_redislog_size(p, p + arg1_size_len, log[l].arg1.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); p = ngx_copy(p, log[l].arg1.data, log[l].arg1.len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); } *p++ = '$'; p = ngx_redislog_size(p, p + record_size_len, record_len); p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); for(i = 0; i &lt; log[l].format-&gt;ops-&gt;nelts; i++) { p = op[i].run(r, p, &amp;op[i]); } if(ngx_strncmp(log[l].command.data, "APPEND", 6) == 0) { *p++ = LF; } p = ngx_copy(p, CRLF, sizeof(CRLF) - 1); peer = ngx_redislog_peers.elts; peer += log[l].peer_idx; ngx_http_redislog_append(*peer, line, p - line); //ngx_http_redislog_append(*peer, line, p - line + 5); } return NGX_OK; } static u_char *ngx_redislog_size(u_char *p, u_char *q, size_t sz) { u_char *end = q; while(p != q) { *--q = (sz % 10 + '0'); sz /= 10; } return end; } static size_t ngx_redislog_size_len(size_t sz) { size_t len = 0; while(sz != 0) { sz /= 10; len++; } return len; } static u_char* ngx_redislog_buf_append(ngx_buf_t *buf, u_char *p, size_t *len) { size_t remaining = buf-&gt;end - buf-&gt;last; if(remaining &gt; *len) { remaining = *len; } buf-&gt;last = ngx_copy(buf-&gt;last, p, remaining); *len -= remaining; return p + remaining; } static void ngx_http_redislog_append(ngx_redislog_peer_t *peer, u_char *buf, size_t len) { u_char *p; ngx_chain_t *last, *q; size_t remaining; ngx_uint_t num_busy = 0; /* * Find last busy buffer */ last = peer-&gt;busy; while(last != NULL &amp;&amp; last-&gt;next != NULL) { last = last-&gt;next; } /* * See if message fits into remaining space */ remaining = (last != NULL ? last-&gt;buf-&gt;end - last-&gt;buf-&gt;last : 0); q = peer-&gt;free; while(remaining &lt;= len &amp;&amp; q != NULL) { remaining += (q-&gt;buf-&gt;end - q-&gt;buf-&gt;last); q = q-&gt;next; } /* * No memory for this message, discard it */ if(remaining &lt; len) { peer-&gt;discarded++; return; } /* * Append message to the buffers */ if(last != NULL) { p = ngx_redislog_buf_append(last-&gt;buf, buf, &amp;len); } else { p = buf; } while(peer-&gt;free != NULL &amp;&amp; len != 0) { q = peer-&gt;free; p = ngx_redislog_buf_append(q-&gt;buf, p, &amp;len); peer-&gt;free = peer-&gt;free-&gt;next; q-&gt;next = NULL; if(last == NULL) { peer-&gt;busy = q; } else { last-&gt;next = q; } last = q; } peer-&gt;num_queued++; q = peer-&gt;busy; while(q != NULL) { num_busy++; q = q-&gt;next; } if(!peer-&gt;flush_timer_set) { peer-&gt;flush_timer.handler = ngx_redislog_flush_handler; peer-&gt;flush_timer.data = peer; peer-&gt;flush_timer.log = peer-&gt;conn.log; ngx_add_timer(&amp;peer-&gt;flush_timer, peer-&gt;conf-&gt;flush_timeout); peer-&gt;flush_timer_set = 1; } if(num_busy &gt;= 2) { ngx_log_debug1(NGX_LOG_DEBUG_HTTP, peer-&gt;conn.connection-&gt;log, 0, "redislog num queued is now %ud, set read handler", peer-&gt;num_queued); peer-&gt;conn.connection-&gt;read-&gt;handler = ngx_redislog_read_handler; /* * Send it */ ngx_http_redislog_send(peer); } } static void ngx_http_redislog_send(ngx_redislog_peer_t *p) { ngx_chain_t *written; ngx_connection_t *c; ngx_chain_t *dummy = NULL; c = p-&gt;conn.connection; if(c == NULL || c-&gt;fd == -1) { return; } if(!c-&gt;write-&gt;ready) { return; } if(p-&gt;flush_timer_set) { ngx_del_timer(&amp;p-&gt;flush_timer); p-&gt;flush_timer_set = 0; } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, "redislog send handler"); if(p-&gt;busy != NULL) { written = c-&gt;send_chain(c, p-&gt;busy, 0); if(written == NGX_CHAIN_ERROR) { ngx_log_error(NGX_LOG_ERR, c-&gt;log, 0, "redislog write error"); ngx_close_connection(c); ngx_redislog_reconnect_peer(p); return; } ngx_chain_update_chains(p-&gt;pool, &amp;p-&gt;free, &amp;p-&gt;busy, &amp;dummy, 0); if(written != NULL) { if(!c-&gt;write-&gt;ready &amp;&amp; !c-&gt;write-&gt;timer_set) { ngx_add_timer(c-&gt;write, p-&gt;conf-&gt;write_timeout); } if(ngx_handle_write_event(c-&gt;write, 0) != NGX_OK) { ngx_close_connection(c); ngx_redislog_reconnect_peer(p); } return; } } } static void ngx_redislog_auth_send(ngx_redislog_peer_t *peer) { ngx_connection_t *c; ngx_str_t *password; ssize_t n; c = peer-&gt;conn.connection; if(c == NULL || c-&gt;fd == -1) { return; } password = &amp;peer-&gt;conf-&gt;password; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, "redislog auth send handler"); n = c-&gt;send(c, peer-&gt;password_pos, password-&gt;len - (peer-&gt;password_pos - password-&gt;data)); if(n &gt; 0) { peer-&gt;password_pos += n; if(peer-&gt;password_pos &gt;= (password-&gt;data + password-&gt;len)) { peer-&gt;send_handler = ngx_http_redislog_send; ngx_http_redislog_send(peer); } return; } if(n == NGX_ERROR) { ngx_close_connection(c); ngx_redislog_reconnect_peer(peer); return; } if(!c-&gt;write-&gt;timer_set) { ngx_add_timer(c-&gt;write, peer-&gt;conf-&gt;write_timeout); } if(ngx_handle_write_event(c-&gt;write, 0) != NGX_OK) { ngx_close_connection(c); ngx_redislog_reconnect_peer(peer); return; } } static void ngx_redislog_flush_handler(ngx_event_t *ev) { ngx_redislog_peer_t *peer = ev-&gt;data; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, peer-&gt;log, 0, "redislog flush handler, set read handler"); peer-&gt;flush_timer_set = 0; peer-&gt;conn.connection-&gt;read-&gt;handler = ngx_redislog_read_handler; ngx_http_redislog_send(peer); } static void ngx_redislog_connected_handler(ngx_redislog_peer_t *peer) { ngx_connection_t *c; c = peer-&gt;conn.connection; ngx_del_timer(c-&gt;read); /* * Once the connection has been established, we need to * reset the reconnect timeout to it's initial value */ peer-&gt;reconnect_timeout = peer-&gt;conf-&gt;reconnect_timeout; if(peer-&gt;discarded != 0) { ngx_log_error(NGX_LOG_ERR, peer-&gt;log, 0, "redislog peer \"%V\" discarded %ui messages", &amp;peer-&gt;conf-&gt;name, peer-&gt;discarded); peer-&gt;discarded = 0; } } static ngx_int_t ngx_redislog_process_buf(ngx_redislog_peer_t *peer, ngx_buf_t *buf) { u_char *p, *q; p = buf-&gt;pos; q = buf-&gt;last; while(p != q) { if(!peer-&gt;state) { if(*p == '+' || *p == '-' || *p == ':') { if(peer-&gt;conf-&gt;authenticate &amp;&amp; !peer-&gt;authenticated) { if(*p == '-') { ngx_log_error(NGX_LOG_ERR, peer-&gt;log, 0, "redis authentication failure"); return NGX_ERROR; } peer-&gt;authenticated = 1; } else { if(peer-&gt;num_queued) { peer-&gt;num_queued--; } else { ngx_log_error(NGX_LOG_ERR, peer-&gt;log, 0, "too many responses from redis"); return NGX_ERROR; } } } if(*p == '-') { ngx_log_error(NGX_LOG_ERR, peer-&gt;log, 0, "redislog error"); } peer-&gt;state++; } else { if(*p == LF) { peer-&gt;state = 0; } else if(peer-&gt;state == 1) { if(*p == CR) { peer-&gt;state++; } } } p++; } buf-&gt;pos = p; return NGX_OK; } static void ngx_redislog_read_handler(ngx_event_t *rev) { ngx_connection_t *c; ngx_redislog_peer_t *peer; ngx_buf_t *buf; ssize_t n, size; ngx_int_t rc; c = rev-&gt;data; peer = c-&gt;data; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev-&gt;log, 0, "redislog read handler"); if(c-&gt;read-&gt;timer_set) { ngx_del_timer(c-&gt;read); } if(rev-&gt;timedout || c-&gt;error || c-&gt;close) { if(rev-&gt;timedout) { ngx_log_error(NGX_LOG_ERR, rev-&gt;log, NGX_ETIMEDOUT, "redislog peer timed out"); } if(rev-&gt;error) { ngx_log_error(NGX_LOG_ERR, rev-&gt;log, 0, "redislog peer connection error"); } ngx_close_connection(c); if(!c-&gt;close) { ngx_redislog_reconnect_peer(peer); } return; } buf = peer-&gt;recv_buf; for( ;; ) { for( ;; ) { if(buf-&gt;last == buf-&gt;end) { break; } size = buf-&gt;end - buf-&gt;last; n = c-&gt;recv(c, buf-&gt;last, size); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, "redislog peer recv %z", n); if(n == NGX_AGAIN) { break; } if(n == 0) { if(peer-&gt;num_queued != 0) { ngx_log_error(NGX_LOG_INFO, c-&gt;log, 0, "redis closed the connection prematurely"); } } if(n == 0 || n == NGX_ERROR) { c-&gt;error = 1; goto reconnect; } buf-&gt;last += n; } rc = ngx_redislog_process_buf(peer, buf); if(rc != NGX_OK) { goto reconnect; } buf-&gt;pos = buf-&gt;last = buf-&gt;start; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, "redislog num queued is now %ud", peer-&gt;num_queued); if(peer-&gt;num_queued == 0) { break; } if (!c-&gt;read-&gt;ready) { if(ngx_handle_read_event(c-&gt;read, 0) != NGX_OK) { goto reconnect; } if(!c-&gt;read-&gt;timer_set) { ngx_add_timer(c-&gt;read, peer-&gt;conf-&gt;read_timeout); } return; } } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev-&gt;log, 0, "redislog set idle read handler"); c-&gt;read-&gt;handler = ngx_redislog_idle_read_handler; return; reconnect: ngx_close_connection(c); ngx_redislog_reconnect_peer(peer); } static void ngx_redislog_idle_read_handler(ngx_event_t *rev) { ngx_connection_t *c; ngx_redislog_peer_t *peer; int n; char buf[1]; ngx_err_t err; c = rev-&gt;data; peer = c-&gt;data; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev-&gt;log, 0, "redislog idle read handler"); if(rev-&gt;timedout || c-&gt;error || c-&gt;close) { if(rev-&gt;timedout) { ngx_log_error(NGX_LOG_ERR, rev-&gt;log, NGX_ETIMEDOUT, "redislog peer timed out"); } if(rev-&gt;error) { ngx_log_error(NGX_LOG_ERR, rev-&gt;log, 0, "redislog peer connection error"); } ngx_close_connection(c); if(!c-&gt;close) { ngx_redislog_reconnect_peer(peer); } return; } #if (NGX_HAVE_KQUEUE) if (ngx_event_flags &amp; NGX_USE_KQUEUE_EVENT) { if(!rev-&gt;pending_eof) { goto no_error; } rev-&gt;eof = 1; c-&gt;error = 1; if(rev-&gt;kq_errno) { rev-&gt;error = 1; } goto reconnect; } #endif n = recv(c-&gt;fd, buf, 1, MSG_PEEK); err = ngx_socket_errno; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, rev-&gt;log, err, "redislog recv(): %d", n); if(n &gt; 0) { goto no_error; } if(n == -1) { if(err == NGX_EAGAIN) { goto no_error; } rev-&gt;error = 1; } else { err = 0; } rev-&gt;eof = 1; c-&gt;error = 1; ngx_log_error(NGX_LOG_ERR, rev-&gt;log, err, "redislog connection error"); #if (NGX_HAVE_KQUEUE) reconnect: #endif ngx_close_connection(c); ngx_redislog_reconnect_peer(peer); return; no_error: if(peer-&gt;connecting) { ngx_redislog_connected_handler(peer); peer-&gt;connecting = 0; } } static void ngx_redislog_write_handler(ngx_event_t *wev) { ngx_connection_t *c; ngx_redislog_peer_t *peer; c = wev-&gt;data; peer = c-&gt;data; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, wev-&gt;log, 0, "redislog write handler"); if(wev-&gt;timedout || c-&gt;error || c-&gt;close) { if(wev-&gt;timedout) { ngx_log_error(NGX_LOG_ERR, wev-&gt;log, NGX_ETIMEDOUT, "redislog peer timed out"); } if(wev-&gt;error) { ngx_log_error(NGX_LOG_ERR, wev-&gt;log, 0, "redislog peer connection error"); } ngx_close_connection(c); if(!c-&gt;close) { ngx_redislog_reconnect_peer(peer); } return; } if(peer-&gt;connecting) { ngx_redislog_connected_handler(peer); peer-&gt;connecting = 0; } if(c-&gt;write-&gt;timer_set) { ngx_del_timer(c-&gt;write); } peer-&gt;send_handler(peer); } static ngx_int_t ngx_redislog_connect_peer(ngx_redislog_peer_t *peer) { ngx_int_t rc; ngx_log_error(NGX_LOG_INFO, peer-&gt;log, 0, "redislog connect peer \"%V\"", &amp;peer-&gt;conf-&gt;name); peer-&gt;conn.sockaddr = peer-&gt;conf-&gt;sockaddr; peer-&gt;conn.socklen = peer-&gt;conf-&gt;socklen; peer-&gt;conn.name = &amp;peer-&gt;conf-&gt;name; peer-&gt;conn.get = ngx_event_get_peer; peer-&gt;conn.log = peer-&gt;log; peer-&gt;conn.log_error = NGX_ERROR_ERR; rc = ngx_event_connect_peer(&amp;peer-&gt;conn); if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) { if(peer-&gt;conn.connection) { ngx_close_connection(peer-&gt;conn.connection); } return NGX_ERROR; } peer-&gt;conn.connection-&gt;data = peer; peer-&gt;conn.connection-&gt;pool = peer-&gt;pool; peer-&gt;password_pos = peer-&gt;conf-&gt;password.data; peer-&gt;authenticated = 0; peer-&gt;conn.connection-&gt;read-&gt;handler = ngx_redislog_read_handler; peer-&gt;conn.connection-&gt;write-&gt;handler = ngx_redislog_write_handler; peer-&gt;send_handler = peer-&gt;conf-&gt;authenticate ? ngx_redislog_auth_send : ngx_http_redislog_send; ngx_add_timer(peer-&gt;conn.connection-&gt;read, peer-&gt;conf-&gt;connect_timeout); peer-&gt;connecting = 1; return NGX_OK; } static void ngx_redislog_connect_handler(ngx_event_t *ev) { ngx_int_t rc; ngx_redislog_peer_t *peer = ev-&gt;data; rc = ngx_redislog_connect_peer(peer); if(rc != NGX_OK) { ngx_redislog_reconnect_peer(peer); } } static void ngx_redislog_reconnect_peer(ngx_redislog_peer_t *p) { p-&gt;conn.connection = NULL; p-&gt;reconnect_timer.handler = ngx_redislog_connect_handler; p-&gt;reconnect_timer.data = p; p-&gt;reconnect_timer.log = p-&gt;conn.log; ngx_add_timer(&amp;p-&gt;reconnect_timer, p-&gt;reconnect_timeout); p-&gt;reconnect_timeout *= 2; if(p-&gt;discarded != 0) { ngx_log_error(NGX_LOG_ERR, p-&gt;log, 0, "redislog peer \"%V\" discarded %ui messages", &amp;p-&gt;conf-&gt;name, p-&gt;discarded); p-&gt;discarded = 0; } } static ngx_int_t ngx_http_redislog_yyyy_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) { u_char *line; line = ngx_palloc(r-&gt;pool, sizeof("yyyy")-1); if(line == NULL) { return NGX_ERROR; } (void) ngx_copy(line, ngx_cached_http_log_iso8601.data, sizeof("yyyy")-1); v-&gt;valid = 1; v-&gt;no_cacheable = 1; v-&gt;not_found = 0; v-&gt;data = line; v-&gt;len = sizeof("yyyy")-1; return NGX_OK; } static ngx_int_t ngx_http_redislog_yyyymm_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) { u_char *line, *p; line = ngx_palloc(r-&gt;pool, sizeof("yyyymm")-1); if(line == NULL) { return NGX_ERROR; } p = ngx_copy(line, ngx_cached_http_log_iso8601.data, sizeof("yyyy")-1); (void) ngx_copy(p, ngx_cached_http_log_iso8601.data + 5, sizeof("mm")-1); v-&gt;valid = 1; v-&gt;no_cacheable = 1; v-&gt;not_found = 0; v-&gt;data = line; v-&gt;len = sizeof("yyyymm")-1; return NGX_OK; } static ngx_int_t ngx_http_redislog_yyyymmdd_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) { u_char *line, *p; line = ngx_palloc(r-&gt;pool, sizeof("yyyymmdd")-1); if(line == NULL) { return NGX_ERROR; } p = ngx_copy(line, ngx_cached_http_log_iso8601.data, sizeof("yyyy")-1); p = ngx_copy(p, ngx_cached_http_log_iso8601.data + 5, sizeof("mm")-1); (void) ngx_copy(p, ngx_cached_http_log_iso8601.data + 8, sizeof("dd")-1); v-&gt;valid = 1; v-&gt;no_cacheable = 1; v-&gt;not_found = 0; v-&gt;data = line; v-&gt;len = sizeof("yyyymmdd")-1; return NGX_OK; } static ngx_int_t ngx_http_redislog_yyyymmddhh_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) { u_char *line, *p; line = ngx_palloc(r-&gt;pool, sizeof("yyyymmddhh")-1); if(line == NULL) { return NGX_ERROR; } p = ngx_copy(line, ngx_cached_http_log_iso8601.data, sizeof("yyyy")-1); p = ngx_copy(p, ngx_cached_http_log_iso8601.data + 5, sizeof("mm")-1); p = ngx_copy(p, ngx_cached_http_log_iso8601.data + 8, sizeof("dd")-1); (void) ngx_copy(p, ngx_cached_http_log_iso8601.data + 11, sizeof("hh")-1); v-&gt;valid = 1; v-&gt;no_cacheable = 1; v-&gt;not_found = 0; v-&gt;data = line; v-&gt;len = sizeof("yyyymmddhh")-1; return NGX_OK; } static void * ngx_http_redislog_create_loc_conf(ngx_conf_t *cf) { ngx_http_redislog_conf_t *conf; conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_redislog_conf_t)); if (conf == NULL) { return NGX_CONF_ERROR; } return conf; } static char * ngx_http_redislog_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child) { ngx_http_redislog_conf_t *prev = parent; ngx_http_redislog_conf_t *conf = child; if(conf-&gt;logs || conf-&gt;off) { return NGX_CONF_OK; } conf-&gt;logs = prev-&gt;logs; conf-&gt;off = prev-&gt;off; return NGX_CONF_OK; } static void * ngx_redislog_create_conf(ngx_cycle_t *cycle) { ngx_redislog_conf_t *slcf; slcf = ngx_pcalloc(cycle-&gt;pool, sizeof(ngx_redislog_conf_t)); if(slcf == NULL) { return NULL; } return slcf; } static ngx_int_t ngx_http_redislog_add_variables(ngx_conf_t *cf) { ngx_http_variable_t *var, *v; for (v = ngx_http_redislog_variables; v-&gt;name.len; v++) { var = ngx_http_add_variable(cf, &amp;v-&gt;name, v-&gt;flags); if (var == NULL) { return NGX_ERROR; } var-&gt;get_handler = v-&gt;get_handler; var-&gt;data = v-&gt;data; } return NGX_OK; } static ngx_int_t ngx_http_redislog_find_peer_by_name(ngx_conf_t *cf, ngx_str_t *name) { ngx_redislog_conf_t *slcf; ngx_redislog_peer_conf_t *pc; ngx_uint_t i; slcf = (ngx_redislog_conf_t *) ngx_get_conf(cf-&gt;cycle-&gt;conf_ctx, ngx_core_redislog_module); pc = slcf-&gt;peers-&gt;elts; for(i = 0; i &lt; slcf-&gt;peers-&gt;nelts; i++) { if(pc[i].name.len == name-&gt;len &amp;&amp; ngx_strncmp(pc[i].name.data, name-&gt;data, name-&gt;len) == 0) { return i; } } return NGX_DECLINED; } static char * ngx_http_redislog_set_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) { ngx_http_redislog_conf_t *slcf = conf; ngx_uint_t i; ngx_str_t *value, name, command, arg1, _if; //ngx_str_t arg_num; ngx_http_redislog_t *log; ngx_http_log_fmt_t *fmt; ngx_http_log_main_conf_t *lmcf; ngx_int_t rc; ngx_http_compile_complex_value_t ccv; unsigned format_set; format_set = 0; value = cf-&gt;args-&gt;elts; if (ngx_strcmp(value[1].data, "off") == 0) { slcf-&gt;off = 1; return NGX_CONF_OK; } slcf-&gt;off = 0; if (slcf-&gt;logs == NULL) { slcf-&gt;logs = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_http_redislog_t)); if (slcf-&gt;logs == NULL) { return NGX_CONF_ERROR; } } lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_log_module); if(lmcf == NULL) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "redislog module requires log module to be compiled in"); return NGX_CONF_ERROR; } log = ngx_array_push(slcf-&gt;logs); if (log == NULL) { return NGX_CONF_ERROR; } ngx_memzero(log, sizeof(ngx_http_redislog_t)); log-&gt;peer_name = value[1]; rc = ngx_http_redislog_find_peer_by_name(cf, &amp;log-&gt;peer_name); if(rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "redislog peer %V is not defined", &amp;log-&gt;peer_name); return NGX_CONF_ERROR; } log-&gt;peer_idx = rc; /* * Create and compile key */ log-&gt;key = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t)); if(log-&gt;key == NULL) { return NGX_CONF_ERROR; } ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[2]; ccv.complex_value = log-&gt;key; if(ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) { return NGX_CONF_ERROR; } ngx_str_set(&amp;command, "APPEND"); //ngx_str_set(&amp;arg1, ""); ngx_str_set(&amp;arg1, "test1"); //ngx_str_set(&amp;arg_num, "0"); ngx_str_set(&amp;name, "main"); if (cf-&gt;args-&gt;nelts &gt;= 4) { for (i = 3; i &lt; cf-&gt;args-&gt;nelts; i++) { if (ngx_strncmp(value[i].data, "format=", 7) == 0) { format_set = 1; name = value[i]; name.len -= 7; name.data += 7; if (ngx_strcmp(name.data, "combined") == 0) { lmcf-&gt;combined_used = 1; } continue; } if (ngx_strncmp(value[i].data, "command=", 8) == 0) { command = value[i]; command.len -= 8; command.data += 8; continue; } if (ngx_strncmp(value[i].data, "arg1=", 5) == 0) { arg1 = value[i]; arg1.len -= 5; arg1.data += 5; log-&gt;has_arg1 = 1; continue; } if (ngx_strncmp(value[i].data, "if=", 3) == 0) { if(log-&gt;_if != NULL) { continue; } _if = value[i]; _if.len -= 3; _if.data += 3; /* * Create and compile if script */ log-&gt;_if = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t)); if(log-&gt;_if == NULL) { return NGX_CONF_ERROR; } ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;_if; ccv.complex_value = log-&gt;_if; if(ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) { return NGX_CONF_ERROR; } continue; } if (ngx_strncmp(value[i].data, "ifnot=", 6) == 0) { if(log-&gt;ifnot != NULL) { continue; } _if = value[i]; _if.len -= 6; _if.data += 6; /* * Create and compile if script */ log-&gt;ifnot = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t)); if(log-&gt;ifnot == NULL) { return NGX_CONF_ERROR; } ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;_if; ccv.complex_value = log-&gt;ifnot; if(ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) { return NGX_CONF_ERROR; } continue; } ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "invalid parameter \"%V\"", &amp;value[i]); return NGX_CONF_ERROR; } } if(!format_set) { name.len = sizeof(NGX_DEF_FORMAT) - 1; name.data = (u_char *) NGX_DEF_FORMAT; lmcf-&gt;combined_used = 1; } log-&gt;command = command; if(log-&gt;has_arg1) { log-&gt;arg1 = arg1; } fmt = lmcf-&gt;formats.elts; for (i = 0; i &lt; lmcf-&gt;formats.nelts; i++) { if (fmt[i].name.len == name.len &amp;&amp; ngx_strcasecmp(fmt[i].name.data, name.data) == 0) { log-&gt;format = &amp;fmt[i]; goto done; } } ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "unknown log format \"%V\"", &amp;name); return NGX_CONF_ERROR; done: return NGX_CONF_OK; } static char * ngx_http_redislog_command(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) { ngx_str_t *value; ngx_redislog_conf_t *slcf; ngx_url_t u; ngx_redislog_peer_conf_t *peer; u_char *p; size_t pass_size_len; slcf = (ngx_redislog_conf_t *) ngx_get_conf(cf-&gt;cycle-&gt;conf_ctx, ngx_core_redislog_module); value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.url = value[2]; u.default_port = 6379; u.no_resolve = 0; if(ngx_parse_url(cf-&gt;pool, &amp;u) != NGX_OK) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, "%V: %s", &amp;u.host, u.err); return NGX_CONF_ERROR; } if(slcf-&gt;peers == NULL) { slcf-&gt;peers = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_redislog_peer_conf_t)); if (slcf-&gt;peers == NULL) { return NGX_CONF_ERROR; } } peer = ngx_array_push(slcf-&gt;peers); if(peer == NULL) { return NGX_CONF_ERROR; } peer-&gt;name = value[1]; peer-&gt;sockaddr = u.addrs[0].sockaddr; peer-&gt;socklen = u.addrs[0].socklen; if(cf-&gt;args-&gt;nelts &gt;= 4) { /* * Alloc space for authentication packet and create it */ pass_size_len = ngx_redislog_size_len(value[3].len); peer-&gt;password.len = sizeof(NGX_REDIS_AUTH)-1 + 1 + pass_size_len + sizeof(CRLF)-1 + value[3].len + sizeof(CRLF)-1; peer-&gt;password.data = ngx_palloc(cf-&gt;pool, peer-&gt;password.len); if(peer-&gt;password.data == NULL) { return NGX_CONF_ERROR; } p = ngx_copy(peer-&gt;password.data, NGX_REDIS_AUTH, sizeof(NGX_REDIS_AUTH)-1); *p++ = '$'; p = ngx_redislog_size(p, p + pass_size_len, value[3].len); p = ngx_copy(p, CRLF, sizeof(CRLF)-1); p = ngx_copy(p, value[3].data, value[3].len); p = ngx_copy(p, CRLF, sizeof(CRLF)-1); peer-&gt;authenticate = 1; } peer-&gt;write_timeout = 30000; peer-&gt;read_timeout = 30000; peer-&gt;connect_timeout = 30000; peer-&gt;reconnect_timeout = 5000; peer-&gt;flush_timeout = 2000; peer-&gt;ping_timeout = 30000; peer-&gt;bufs.num = 200; peer-&gt;bufs.size = 2048; peer-&gt;recv_buf_size = 1024; return NGX_CONF_OK; } static ngx_int_t ngx_http_redislog_init(ngx_conf_t *cf) { ngx_http_core_main_conf_t *cmcf; ngx_http_handler_pt *h; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_LOG_PHASE].handlers); if (h == NULL) { return NGX_ERROR; } *h = ngx_http_redislog_handler; return NGX_OK; } static ngx_int_t ngx_redislog_init_process(ngx_cycle_t *cycle) { ngx_int_t rc; ngx_redislog_conf_t *slcf; ngx_uint_t i; ngx_redislog_peer_conf_t *pc; ngx_redislog_peer_t *peer, **ppeer; slcf = (ngx_redislog_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_redislog_module); if(slcf-&gt;peers == NULL || slcf-&gt;peers-&gt;nelts == 0) { return NGX_OK; } rc = ngx_array_init(&amp;ngx_redislog_peers, cycle-&gt;pool, slcf-&gt;peers-&gt;nelts, sizeof(ngx_redislog_peer_t*)); if(rc != NGX_OK) { return rc; } pc = slcf-&gt;peers-&gt;elts; for(i = 0; i &lt; slcf-&gt;peers-&gt;nelts; i++) { ppeer = ngx_array_push(&amp;ngx_redislog_peers); if(ppeer == NULL) { return NGX_ERROR; } peer = ngx_pcalloc(cycle-&gt;pool, sizeof(ngx_redislog_peer_t)); if(peer == NULL) { return NGX_ERROR; } peer-&gt;free = ngx_create_chain_of_bufs(cycle-&gt;pool, &amp;pc[i].bufs); if(peer-&gt;free == NULL) { return NGX_ERROR; } peer-&gt;recv_buf = ngx_create_temp_buf(cycle-&gt;pool, pc[i].recv_buf_size); if(peer-&gt;recv_buf == NULL) { return NGX_HTTP_INTERNAL_SERVER_ERROR; } *ppeer = peer; peer-&gt;pool = cycle-&gt;pool; peer-&gt;conf = &amp;pc[i]; peer-&gt;log = cycle-&gt;log; peer-&gt;reconnect_timeout = pc[i].reconnect_timeout; ngx_redislog_connect_peer(peer); } return NGX_OK; }</span></span></span></span></code> </pre> <br></div></div><br><br>  Configuration example (we write with the key ‚Äú$ remote_addr ^ $ status ^ $ connection ^ $ connection_requests ^ $ msec‚Äù the value ‚Äú$ http_user_agent‚Äù, which will live for 20 seconds): <br><pre> <code class="bash hljs">root@redis:~ <span class="hljs-comment"><span class="hljs-comment"># cat /usr/local/etc/nginx/nginx.conf | egrep "(access_redislog|log_format)" | grep -v "#" log_format main '$http_user_agent'; access_redislog test $remote_addr^$status^$connection^$connection_requests^$msec command=SETEX arg1=20;</span></span></code> </pre><br>  Monitor in redis: <br><pre> <code class="bash hljs">root@redis:~ <span class="hljs-comment"><span class="hljs-comment"># redis-cli redis 127.0.0.1:6379&gt; monitor OK 1389288187.176047 [0 78.72.78.56:31865] "SETEX" "78.72.78.209^200^9^1^1389288185.175" "20" "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36"</span></span></code> </pre><br><br>  We solve a similar problem with the help of EVALSHA (just for example, of course, we don‚Äôt need to do that): <br>  Create a key: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sha1 -s "return {redis.call('SET',KEYS[1],ARGV[1]); redis.call('EXPIRE',KEYS[1],20);}" SHA1 ("return {redis.call('SET',KEYS[1],ARGV[1]); redis.call('EXPIRE',KEYS[1],20);}") = c82db723c86778baa89099e1b65ebf21cb48ce34 # cat /usr/local/etc/nginx/nginx.conf | egrep "(access_redislog|log_format)" | grep -v "#" log_format main '$http_user_agent'; access_redislog test $remote_addr^$status^$connection^$connection_requests^$msec command=EVALSHA arg1=c82db723c86778baa89099e1b65ebf21cb48ce34;</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Monitor: <br><pre> <code class="bash hljs">1389290907.814024 [0 78.72.78.56:21435] <span class="hljs-string"><span class="hljs-string">"EVALSHA"</span></span> <span class="hljs-string"><span class="hljs-string">"c82db723c86778baa89099e1b65ebf21cb48ce34"</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-string"><span class="hljs-string">"78.72.78.209^200^9^2^1389290905.813"</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36"</span></span> 1389290907.814091 [0 lua] <span class="hljs-string"><span class="hljs-string">"SET"</span></span> <span class="hljs-string"><span class="hljs-string">"78.72.78.209^200^9^2^1389290905.813"</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36"</span></span> 1389290907.814132 [0 lua] <span class="hljs-string"><span class="hljs-string">"EXPIRE"</span></span> <span class="hljs-string"><span class="hljs-string">"78.72.78.209^200^9^2^1389290905.813"</span></span> <span class="hljs-string"><span class="hljs-string">"20"</span></span></code> </pre><br><br>  Both operations (SETEX and EVALSHA) are atomic, but, of course, in the presence of a native SETEX, it is unwise to pull LUA for such tasks. <br>  For clarity, a couple of stress tests: <br><br>  Using native SETEX <br><div class="spoiler">  <b class="spoiler_title">ab</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ab -n 100000 -c 4 -v 0 http://127.0.0.1:80/ This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking 127.0.0.1 (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx/1.4.3 Server Hostname: 127.0.0.1 Server Port: 80 Document Path: / Document Length: 612 bytes Concurrency Level: 4 Time taken for tests: 4.338 seconds Complete requests: 100000 Failed requests: 0 Write errors: 0 Total transferred: 84400000 bytes HTML transferred: 61200000 bytes Requests per second: 23050.90 [#/sec] (mean) Time per request: 0.174 [ms] (mean) Time per request: 0.043 [ms] (mean, across all concurrent requests) Transfer rate: 18998.99 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 0 0 0.1 0 1 Waiting: 0 0 0.1 0 1 Total: 0 0 0.1 0 1 Percentage of the requests served within a certain time (ms) 50% 0 66% 0 75% 0 80% 0 90% 0 95% 0 98% 0 99% 0 100% 1 (longest request)</span></span></code> </pre><br></div></div><br><br>  Using SETEX implemented via EVAL <br><div class="spoiler">  <b class="spoiler_title">ab</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ab -n 100000 -c 4 -v 0 http://127.0.0.1:80/ This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking 127.0.0.1 (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx/1.4.3 Server Hostname: 127.0.0.1 Server Port: 80 Document Path: / Document Length: 612 bytes Concurrency Level: 4 Time taken for tests: 59.520 seconds Complete requests: 100000 Failed requests: 1413 (Connect: 0, Receive: 0, Length: 1413, Exceptions: 0) Write errors: 0 Total transferred: 83207428 bytes HTML transferred: 60335244 bytes Requests per second: 1680.12 [#/sec] (mean) Time per request: 2.381 [ms] (mean) Time per request: 0.595 [ms] (mean, across all concurrent requests) Transfer rate: 1365.22 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 1.1 0 251 Processing: 0 2 13.0 0 251 Waiting: 0 2 12.9 0 251 Total: 0 2 13.0 0 253 Percentage of the requests served within a certain time (ms) 50% 0 66% 0 75% 1 80% 1 90% 1 95% 1 98% 44 99% 77 100% 253 (longest request)</span></span></code> </pre><br></div></div><br><br>  Well, just writing to a file (in memory) <br><div class="spoiler">  <b class="spoiler_title">ab</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ab -n 100000 -c 4 -v 0 http://127.0.0.1:80/ This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking 127.0.0.1 (be patient) Completed 10000 requests Completed 20000 requests Completed 30000 requests Completed 40000 requests Completed 50000 requests Completed 60000 requests Completed 70000 requests Completed 80000 requests Completed 90000 requests Completed 100000 requests Finished 100000 requests Server Software: nginx/1.4.3 Server Hostname: 127.0.0.1 Server Port: 80 Document Path: / Document Length: 612 bytes Concurrency Level: 4 Time taken for tests: 4.544 seconds Complete requests: 100000 Failed requests: 0 Write errors: 0 Total transferred: 84400000 bytes HTML transferred: 61200000 bytes Requests per second: 22007.62 [#/sec] (mean) Time per request: 0.182 [ms] (mean) Time per request: 0.045 [ms] (mean, across all concurrent requests) Transfer rate: 18139.09 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 0 0 0.0 0 1 Waiting: 0 0 0.0 0 1 Total: 0 0 0.0 0 1 Percentage of the requests served within a certain time (ms) 50% 0 66% 0 75% 0 80% 0 90% 0 95% 0 98% 0 99% 0 100% 1 (longest request)</span></span></code> </pre><br></div></div><br><br>  Thus, the above implementation of storage with SETEX allowed us to achieve equal results with storage in a file plus we received autorotation of logs without any special costs. </div><p>Source: <a href="https://habr.com/ru/post/208590/">https://habr.com/ru/post/208590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208578/index.html">Play Pure Drive - smart tennis racket for everyone</a></li>
<li><a href="../208580/index.html">The use of machine learning in building AI for the game of Japanese chess (shogi)</a></li>
<li><a href="../208582/index.html">Text interface, part 2. User interaction</a></li>
<li><a href="../208586/index.html">Asterisk / FreePBX: Integration of number identifier with customer base</a></li>
<li><a href="../208588/index.html">JetBrains discounts for startups</a></li>
<li><a href="../208600/index.html">Backbone.Component - standalone UI components for Backbone.js</a></li>
<li><a href="../208604/index.html">What happens if you openly report on the vulnerabilities of government sites</a></li>
<li><a href="../208608/index.html">C # for system programming</a></li>
<li><a href="../208610/index.html">Samsung's smart home unveiled at CES 2014</a></li>
<li><a href="../208612/index.html">Cygnus private space ‚Äútruck‚Äù successfully launched for the second time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>