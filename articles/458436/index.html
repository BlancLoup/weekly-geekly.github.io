<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Typical logging errors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 


 I think almost every program has logging. Moreover, in a number of already new applications (which means with a sea of ‚Äã‚Äãnon-trivial con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Typical logging errors</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr! </p><br><p>  I think almost every program has logging.  Moreover, in a number of already new applications (which means with a sea of ‚Äã‚Äãnon-trivial conditions), logs often become vital on a combat server. </p><br><p>  However, despite the importance and prevalence of this technology, I noticed that people often make standard mistakes when working with them.  This article largely describes the behavior of .Net, but I made small inserts from the Java world, just to make a comparison. </p><a name="habracut"></a><br><h1 id="allokacii-vydelenie-pamyati">  Allocation (memory allocation) </h1><br><p> The most common mistake (according to my observations) is negligence in relation to small memory allocations near the place where the <code>log.Debug(...)</code> function is <code>log.Debug(...)</code> . </p><br><p>  So, our standard code in .Net: </p><br><pre> <code class="plaintext hljs">private static readonly ILog Log4NetLog = LogManager.GetLogger(typeof(Program)); private static readonly Logger NLogLog = NLog.LogManager.GetCurrentClassLogger(); private static void PublishData(int id, string name, EMail email, decimal amount) { Log4NetLog.Debug($"Id={id}"); // 1 Log4NetLog.DebugFormat("Id={0}", id); // 2 Log4NetLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); // 3 Log4NetLog.DebugFormat("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount); // 4 NLogLog.Debug($"Id={id}"); // 5 NLogLog.Debug("Id={0}", id); // 6 NLogLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); // 7 NLogLog.Debug("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount); // 8 }</code> </pre> <br><p>  In many respects, I only met the <a href="https://www.nuget.org/packages/log4net/">log4net</a> and <a href="https://github.com/NLog/NLog">NLog</a> libraries, and therefore I will use them in the examples. </p><br><p>  So the questions are: </p><br><ul><li>  In which lines will memory be allocated even if Debug is turned off? </li><li>  If memory is allocated, then how easy is it to detect in the same dotTrace, what specific loggers are to blame for this very memory allocation? </li></ul><br><p>  The correct answer to the first question: memory is not allocated only in paragraph "6".  And the answer to the second question: to catch this is incredibly difficult, since such code is often spread over the project.  You may recall a typical .Net application.  It will often have similar code that makes GC work. </p><br><p>  However, let's go through the technical details to see exactly where we will have an impact on performance. </p><br><p>  So, the first point: </p><br><pre> <code class="plaintext hljs">Log4NetLog.Debug($"Id={id}"); // 1</code> </pre> <br><p>  In fact, the compiler converts it to: </p><br><pre> <code class="plaintext hljs">var temp = string.Format("Id={0}", id); // &lt;--       Log4NetLog.Debug(temp);</code> </pre> <br><p>  That is, the first expression will essentially force the processor to create a string, passing it to the logger.  He will quickly verify that logging is not necessary, and therefore the string is simply created in memory.  And, what is important, if you dig out more such code, the lines will be created in heaps of program locations, that is, the program will work just a little slower.  Everywhere. </p><br><p>  The second example is slightly more efficient, since the string is not created in it: </p><br><pre> <code class="plaintext hljs">Log4NetLog.DebugFormat("Id={0}", id);</code> </pre> <br><p>  However, the memory is still allocated here, since boxing will occur.  Let me remind the signature of the DebugFormat method: </p><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><p>  As you can see, an entry type is required at the input.  However, we are trying to pass a meaningful type <code>int</code> .  As a result, each call will result in the removal of the <code>id</code> parameter in the heap, in order to pass it to the method.  And let me remind you that in the method itself the parameter is not needed, since the <code>Debug</code> is turned off by the condition of the problem. </p><br><p>  The following example is loaded and simple: </p><br><pre> <code class="plaintext hljs">Log4NetLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); // 3</code> </pre> <br><p>  I am sure that you already understood that again the line will stand out in a heap, and so on.  Therefore at once we will pass this example.  The following call method looks more efficient: </p><br><pre> <code class="plaintext hljs">Log4NetLog.DebugFormat("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount); // 4</code> </pre> <br><p>  And so, but let's calculate how many times it is necessary to allocate a piece of memory: </p><br><ul><li>  <code>email.Normalize()</code> results in the creation of an object.  That is why this object will stand out in the heap (or on the stack - it doesn‚Äôt matter, since boxing will make everything stand out in the heap) </li><li>  <code>id</code> will go to the heap, as we‚Äôve previously reviewed. </li><li>  Log4net has the following interface for similar long formatted calls: <code>void DebugFormat(string format, params object[] args)</code> .  As you can see, .Net will create an array in the heap to pass it to the <code>DebugFormat</code> method. </li></ul><br><p>  As a result, a rather typical call to a logging operation will result in a heap of objects in memory.  Which is pretty disappointing, since logging itself is often turned off.  However, move on to NLog. </p><br><p>  This line will trigger the selection of an object on the heap: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug($"Id={id}");</code> </pre> <br><p>  Everything is obvious here, but the line below does not have the following disadvantage: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug("Id={0}", id);</code> </pre> <br><p>  And the reason is that NLog has a special signature for ints: <code>void Debug(string message, int argument)</code> .  Moreover, even if you pass a different structure, the <code>void Debug&lt;TArgument&gt;([Localizable(false)] string message, TArgument argument)</code> method <code>void Debug&lt;TArgument&gt;([Localizable(false)] string message, TArgument argument)</code> called.  And this method does not require boxing, since after JIT a separate function will be created for each type (of course, this is not quite so, but the essence is important: there will be no boxing). </p><br><p>  I‚Äôll skip the easy-to-understand script with a large input line and go straight to: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug("Id={0}; name={1}; email={2}; amount={3}", id, name, email.Normalize(), amount);</code> </pre> <br><p>  Strangely enough, NLog did not increase the number of Generic parameters for the methods, and therefore the signature would be used: <code>void Debug([Localizable(false)] string message, params object[] args)</code> .  And it will again lead to the creation of objects in the heap and so on. </p><br><h2 id="vyvody-i-uluchsheniya">  Conclusions and improvements </h2><br><p>  The main conclusion is that if you have many calls of logging methods in the program that do not lead to a physical record in the file, then you can out of the blue start allocating a lot of unnecessary objects on the heap.  And thereby slowing down the work of the program. </p><br><p>  Conclusion 2: If you transfer not many objects to the method, then use NLog.  Due to the fact that it took care of the Generic parameters, you can be more relaxed about performance. </p><br><p>  However, in order to be completely safe, it is more logical to do this: </p><br><pre> <code class="plaintext hljs">if (NLogLog.IsDebugEnabled) { NLogLog.Debug($"Id={id}; name={name}; email={email.Normalize()}; amount={amount}"); }</code> </pre> <br><p>  Here the logging method will not be called if it is not necessary.  However, if you still have to reset the data to the log, then the convenient String Interpolation will be used.  Inside, loggers (at least the same NLog) are optimized to write a line to logs directly (i.e., formatting will take place immediately in the <code>Stream</code> , instead of creating a line in memory).  However, this optimization of NLog fades away from the fact that it is necessary to reset the data to a file. </p><br><h2 id="primer-iz-kotlin">  Kotlin example </h2><br><p>  To dilute the description of the work of popular loggers in .Net, I will give an interesting way to wrap calls in kotlin.  The idea is built literally on one interesting possibility of the language: <a href="https://kotlinlang.org/docs/reference/inline-functions.html">inline methods</a> .  So, a simple code for outputting something in debug: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ logger.debug { <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><p>  And it will be converted by the compiler into something like this: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(logger.isDebugEnabled){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message = <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span> logger.debug(message) }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception){ <span class="hljs-comment"><span class="hljs-comment">/*handle*/</span></span> } } } }</code> </pre> <br><p>  Here it is important: everything inside the curly braces near the <code>debug</code> is lyambda.  However, it will be built into your method, that is, a function object will not be created in the heaps.  Thus, you can hide large operations inside, which will be called only if you want to output the result in <code>debug</code> .  For example: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ logger.debug { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> idList = getIdList() <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$idList</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><p>  Here, <code>getIdList</code> will be called only if you need to send something to the file.  And all because the code is converted to: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeService</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : KLogging() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publishData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(logger.isDebugEnabled){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> idList = getIdList() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message = <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$idList</span></span></span><span class="hljs-string">"</span></span> logger.debug(message) }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (){ <span class="hljs-comment"><span class="hljs-comment">/*handle*/</span></span> } } logger.debug { <span class="hljs-string"><span class="hljs-string">"Identity: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br><h1 id="large-object--large-object-heap">  Large Object ==&gt; Large Object Heap </h1><br><p>  In addition to the previous example.  I am sure that many people know that in .Net / JVM there is the concept of "Large Object Heap".  More precisely, in Java there is no special definition, however allocators will often create large objects immediately in the last generation (to minimize the movement of objects and level the problem of fast memory penetration for a streaming allocator). </p><br><p>  Let's go back to the example: </p><br><pre> <code class="plaintext hljs">NLogLog.Debug($"Id={id}");</code> </pre> <br><p>  As you understand, if the <code>id</code> object has a <code>ToString</code> implementation that creates a string of size in megabytes, then the face has the following hits in LOH: </p><br><ul><li>  <code>ToString</code> call itself </li><li>  Formatting <code>$"Id={id}"</code> </li><li>  And if the developers of the logger did not catch all such things (and it is extremely difficult to write a test for the absence of objects in LOH), then the logger will add more problems. </li></ul><br><p>  And here you can use three ways to log such things: </p><br><ul><li>  Use special layout and do not require calling <code>ToString</code> .  For example, NLog has <a href="https://github.com/NLog/NLog/wiki/JsonLayout">JsonLayout</a> .  Thus, you can simply transfer an object to the logger, which will be serialized immediately into the resulting stream (for example, to a file). </li><li>  Write to the file yourself.  Or in other words - do not use the logger.  From myself I can only advise how to find out which file NLog will write to: <code>var filePath = NLog.LogManager.Configuration.AllTargets.OfType&lt;FileTarget&gt;().First().FileName.Render(LogEventInfo.CreateNullEvent())</code> .  Obviously, this function will return the first <code>FileTarget</code> , but if everyone writes to one folder, then in a similar way you can find out the folder for writing, and then directly send a dump of your object to a file. </li><li>  If you have log4j2 (exactly the second, this is important), then you can use <a href="http://logging.apache.org/log4j/2.x/log4j-api/xref/org/apache/logging/log4j/util/StringBuilderFormattable.html">StringBuilderFormattable</a> .  It is just created in order to output the data to the logger in chunks (moreover, in order not to allocate part of the chunks in the heap yet, since they have already been allocated). </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderFormattable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Writes a text representation of this object into the specified {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> StringBuilder}, ideally without allocating * temporary objects. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> buffer the StringBuilder to write into */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder buffer)</span></span></span></span>; }</code> </pre> <br><h1 id="sinhronnost-i-problemy-asinhronnosti">  Synchronicity (and asynchronous problems) </h1><br><p>  Once, in one program, I noticed that during load operations, about half the waiting time for the UI was for logging operations.  Once again: half of the time the program took to call <code>logger.Debug</code> or something like that.  And the reason is simple: we used log4net, which can only write files synchronously. </p><br><p>  From here I derived <strong>rule 1</strong> : the logger should always work in a different thread.  You should not block the application code for the sake of traces, because it is incredibly strange.  In other words - using NLog - it is always necessary to put down <code>async=true</code> in the <code>nlog</code> tag (it is the main one).  Or, as stated in the <a href="https://github.com/nlog/NLog/wiki/AsyncWrapper-target">example</a> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">targets</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">async</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> ... your targets go here ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">targets</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  If you use log4net, either redirect it to NLog, or make AsyncFileAppender. </p><br><p>  For the Java world: both Logback and Log4J2 have the ability to do asynchronous logging.  Here is a comparison from the <a href="https://logging.apache.org/log4j/2.0/manual/async.html">official site</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b9b/924/cb3/b9b924cb3725252b98aae0c6ffdc8aa0.png" alt="Picture"></p><br><p>  However, when everything is written asynchronously, another problem arises - what to do in case of critical errors?  After all, it happens that the program shuts down not because it left the <code>Main</code> stream (for example, the program can end by calling <code>Application.Exit</code> or <code>Environment.FailFast</code> , which is not very nice, but it occurs).  In this case, you should always call <code>Flush</code> before killing your process.  Otherwise, if you fall on the battle server, the most valuable information will be missed. </p><br><h1 id="vyvod">  Conclusion </h1><br><p>  I hope this article will help write fast programs with convenient logging.  I highlighted only a part of the problems that I see in the code.  All of them are not the most obvious, however, and not the most complex. </p><br><p>  In any case, as I said at the beginning, work with loggers is practically every application.  Moreover, according to my notes, about half of the classes themselves display something in the log.  Thus, the correct operation with these functions affects almost the entire application as a whole. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/458436/">https://habr.com/ru/post/458436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458420/index.html">AWS_Ru meetup at Raiffeisenbank</a></li>
<li><a href="../458426/index.html">Map projections: what is xkcd really joking about</a></li>
<li><a href="../458428/index.html">Google opens source code for the robots.txt parser</a></li>
<li><a href="../458432/index.html">Merge multiple packages into one Python namespace</a></li>
<li><a href="../458434/index.html">Training Cisco 200-125 CCNA v3.0. Day 11. VLAN Basics</a></li>
<li><a href="../45844/index.html">Stages of development of a promotional site</a></li>
<li><a href="../458440/index.html">Weekdays technical support: stories about what happens when you can‚Äôt get to the user</a></li>
<li><a href="../458444/index.html">Internet for summer resident. Part 4. One SIM card is enough</a></li>
<li><a href="../458446/index.html">Hyperscale data centers: who builds them and how much they cost</a></li>
<li><a href="../45845/index.html">Three conversations about blog advertising</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>