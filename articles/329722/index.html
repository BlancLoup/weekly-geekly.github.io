<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A comprehensive guide to using HTTP / 2 Server Push</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Alexander, and I am a front-end developer at Badoo. Perhaps one of the most debated topics in the world frontend in the past few yea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A comprehensive guide to using HTTP / 2 Server Push</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/08e/727/3f4/08e7273f4c624bcdb06e513fde3900a4.jpg"></p><br><p>  <em>Hello!</em>  <em>My name is Alexander, and I am a front-end developer at Badoo.</em>  <em>Perhaps one of the most debated topics in the world frontend in the past few years is the HTTP / 2 protocol.</em>  <em>And for good reason - because the transition to it opens up many opportunities for developers to accelerate and optimize sites.</em>  <em>This post is dedicated to just one of these features - Server Push.</em>  <em>Jeremy Wagner's article seemed interesting to me, and therefore I am sharing useful information with you.</em> </p><a name="habracut"></a><br><p>  Not so long ago, performance-oriented developer capabilities have noticeably changed.  And the emergence of HTTP / 2 was perhaps the most significant change.  HTTP / 2 is no longer a feature we are looking forward to - it already exists (and successfully helps to cope with problems like blocking the beginning of the queue and uncompressed headers that exist in HTTP / 1), and ‚Äúcomplete‚Äù with it goes Server Push ! </p><br><p>  This technology allows you to send site resources to users before they ask them.  This is an elegant way to achieve performance benefits for HTTP / 1 optimization methods, such as embedding, for example, and to avoid the disadvantages associated with this practice. </p><br><p>  From this article, you will learn everything about Server Push - from the principle of its work to the problems it solves: how to use it, how to determine if it works and what its effect on performance, and much more. </p><br><h3 id="chto-takoe-server-push">  What is Server Push? </h3><br><p>  Web sites are always accessed using the ‚ÄúRequest - Answer‚Äù template: a user sends a request to a remote server, which with a certain delay sends a response with the requested content. </p><br><p>  In the initial request to the web server, an HTML document is usually requested.  The server responds with the requested HTML resource.  The resulting HTML document is analyzed by the browser, as a result of which links to other resources, such as style sheets, scripts and images, are extracted from it.  After they are detected, the browser sends a separate request for each resource and receives the appropriate responses. </p><br><p> <a href=""><img src="https://habrastorage.org/web/15c/f55/7ce/15cf557ced6145d5be156e26b775184c.png"></a> </p><br><p>  The problem with this mechanism is that it forces the user to wait until the browser detects and extracts the necessary resources after the HTML document is loaded.  This delays rendering and increases download time. </p><br><p>  We have a solution to this problem.  Server Push allows the server to proactively push web site resources to the client before the user requests them explicitly.  That is, we can send in advance what the user needs for the requested page. </p><br><p> Suppose you have a website where all pages rely on styles defined in an external style sheet called <code>styles.css</code> .  When a user requests index.html from the server, we can send <code>styles.css</code> right after we start sending a response for <code>index.html</code> . </p><br><p> <a href=""><img src="https://habrastorage.org/web/11c/d32/ee7/11cd32ee742e4249812ca6503a901572.png"></a> </p><br><p>  Instead of waiting for the server to send <code>index.html</code> , and then - until the browser requests and receives the <code>styles.css</code> , the user only needs to wait for an answer to his initial request.  This response will contain both files: both <code>index.html</code> and <code>styles.css</code> .  This means that the browser can start rendering the page faster than if it had to wait. </p><br><p>  As you can see, using Server Push allows you to reduce the page rendering time.  And also - to solve some other problems, especially with regard to front-end development. </p><br><h3 id="kakie-problemy-reshaet-server-push">  What problems does Server Push solve? </h3><br><p>  Reducing the number of requests to the server to receive critical content is only one of the problems solved by Server Push, but not the only one. </p><br><p>  For example, Server Push is a suitable alternative to a number of anti-pattern HTTP / 1 optimizations, such as embedding CSS and JavaScript directly in HTML or using the <a href="https://en.wikipedia.org/wiki/Data_URI_scheme">data URI scheme</a> to embed binary data in CSS and HTML.  These methods have value in optimizing HTTP / 1, since they reduce the subjective page load time.  This means that although the total page load time cannot be reduced, the page will load faster for the user. </p><br><p>  Of course, it makes sense.  If you embed CSS in an HTML document in <code>&lt;style&gt;</code> tags, the browser can immediately apply the styles to the HTML, without waiting for them to be extracted from an external source.  This concept works for both embedded scripts and binary data when using the data URI scheme. </p><br><p> <a href=""><img src="https://habrastorage.org/web/5d7/019/ab0/5d7019ab083544f79b2326f72e80a0a3.png"></a> </p><br><p>  This seems like a good way to solve the problem, isn't it?  For HTTP / 1, where you have no other choice, of course!  But the flip side of the coin is that inline content cannot be effectively cached.  If a resource (for example, a stylesheet or a JavaScript file) remains external and modular, it can be cached much more efficiently.  And when the user goes to the next page, which requires the same resource, it can be pulled out of the cache, eliminating the need for additional requests to the server. </p><br><p> <a href=""><img src="https://habrastorage.org/web/105/5ee/b1c/1055eeb1cdd84bd4a2fb429f35c74c42.png"></a> </p><br><p>  However, when we embed content, it does not have its own caching context ‚Äî its caching context is the same as the resource in which it is embedded.  Take, for example, an HTML document with inline CSS.  If an HTML document caching policy always forces a fresh copy of the markup from the server, then the embedded CSS will never be cached by itself.  Of course, the document in which it is embedded can be cached, but other pages that contain the same duplicate CSS will be reloaded.  And even if the caching policy is less restrictive, HTML documents usually have a limited shelf life.  However, this is a compromise, which we are ready to make when optimizing HTTP / 1.  It really works, and it is quite effective for visiting the site for the first time.  But the first impression is often decisive. </p><br><p>  These are the problems that Server Push deals with.  When you push through resources, you get the same practical advantages as when embedding, but still save your resources in external files that have their own caching policy.  However, in this process there is one nuance that will be discussed at the end of the article.  In the meantime, let's continue. </p><br><p>  I explained in some detail why you should consider using Server Push, and also outlined a range of problems that this technology solves for both the user and the developer.  Now let's talk about how it is used. </p><br><h3 id="kak-ispolzovat-server-push">  How to use Server Push? </h3><br><p>  Using Server Push usually involves using the HTTP <code>Link</code> header in the following format: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Link</span></span>: &lt;/css/styles.css&gt;; rel=preload; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=style</code> </pre> <br><p>  Notice, I said "usually."  What you see above is actually a <a href="https://w3c.github.io/preload/">preload resource hint</a> .  This is a separate optimization other than Server Push, but most (not all) HTTP / 2 implementations will push the object specified in the <code>Link</code> header, which contains a hint of the <code>preload</code> resource.  If the server or client refuses to accept the pushed resource, the client will still be able to initiate early retrieval of the specified resource. </p><br><p>  The <code>as=style</code> portion of the header is optional.  It informs the browser about the type of content of the resource being pushed.  In this case, we use the <code>style</code> value to indicate that the object is a style sheet (you can specify <a href="https://w3c.github.io/preload/">other types of content</a> ).  It is important to note that omitting the <code>as</code> value may cause the browser to load the push resource twice.  So do not forget about it! </p><br><p>  Now that you know how the pushing starts, consider how we can set the <code>Link</code> header.  This can be done in two ways: </p><br><ul><li>  Web server settings (for example, <code>httpd.conf</code> or <code>.htaccess</code> for Apache); </li><li>  backend language function (for example, PHP <code>header</code> function). </li></ul><br><h3 id="ustanovka-zagolovka-link-v-nastroykah-veb-servera">  <code>Link</code> header setting in web server settings </h3><br><p>  Here is an example of setting up an Apache server (via <code>httpd.conf</code> or <code>.htaccess</code> ) to push the style sheet whenever an HTML file is requested: </p><br><pre> <code class="hljs pgsql">&lt;FilesMatch "\.html$"&gt; <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> Link "&lt;/css/styles.css&gt;; rel=preload; as=style" &lt;FilesMatch&gt;</code> </pre> <br><p>  Here we use the <code>FilesMatch</code> directive to select requests for files ending in <code>.html</code> .  When a request is received that meets this criterion, we add the <code>Link</code> header to the response, which instructs the server to push the resource <code>/css/styles.css</code> . </p><br><p>  <em>Note:</em> Apache HTTP / 2 module can also initiate resource pushing using the <code>H2PushResource</code> directive.  The documentation for this directive states that this method can trigger pushing earlier than using the <code>Link</code> header.  Depending on your particular installation, you may not have access to this feature.  Performance testing, shown later in this article, uses the <code>Link</code> header method. </p><br><p>  Currently Nginx does not support HTTP / 2 Server Push, and so far the software change list does not indicate that its support has been added.  This may change as the Nginx HTTP / 2 implementation evolves. </p><br><h3 id="ustanovka-zagolovka-link-v-bekend-kode">  Setting the <code>Link</code> header in the backend code </h3><br><p>  Another way to set the <code>Link</code> header is to use the server language.  This will help if you cannot change the settings of the web server.  Below is an example of using the PHP <code>header</code> function to set the <code>Link</code> header: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">header</span></span>("Link: &lt;/css/styles.css&gt;; rel=preload; as=style");</code> </pre> <br><p>  If your application is on a shared hosting, where there is no possibility to change the server settings, then this method is what you need.  You should be able to set this header in any server language.  Just be sure to do this before sending the response body, in order to avoid possible run-time errors. </p><br><h3 id="protalkivanie-neskolkih-resursov">  Pushing multiple resources </h3><br><p>  All our examples illustrate pushing through a single resource.  But what if you want to push a few?  It would be wise to do that, right?  In the end, the network consists not only of style sheets.  Here's how to do it: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Link</span></span>: &lt;/css/styles.css&gt;; rel=preload; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=style, &lt;/js/scripts.js&gt;; rel=preload; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=script, &lt;/img/logo.png&gt;; rel=preload; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=image</code> </pre> <br><p>  To push multiple resources through, simply separate each push directive with a comma.  Since resource hints are also added via the <code>Link</code> tag using this syntax, you can mix your push directives with other resource hints.  Here is an example of mixing with the <code>preconnect</code> hint: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Link</span></span>: &lt;/css/styles.css&gt;; rel=preload; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=style, &lt;https:<span class="hljs-comment"><span class="hljs-comment">//fonts.gstatic.com&gt;; rel=preconnect</span></span></code> </pre> <br><p>  Multiple <code>Link</code> headers are also allowed.  Here is how you can configure Apache to set up several <code>Link</code> headers for querying HTML documents: </p><br><pre> <code class="hljs pgsql">&lt;FilesMatch "\.html$"&gt; <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> Link "&lt;/css/styles.css&gt;; rel=preload; as=style" <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> Link "&lt;/js/scripts.js&gt;; rel=preload; as=script" &lt;FilesMatch&gt;</code> </pre> <br><p>  This syntax is more convenient than combining multiple values ‚Äã‚Äãseparated by commas, but it works just as well.  The only drawback is its lack of compactness, but the convenience is worth a few extra bytes transmitted over the network. </p><br><p>  Now that you know how to push through resources, let's see how to determine if it works. </p><br><h3 id="kak-opredelit-rabotaet-li-server-push">  How to determine if Server Push works? </h3><br><p>  So you added a <code>Link</code> header to tell the server to push something through.  The question remains: how to find out if it works at all? </p><br><p>  It depends on the browser.  In recent versions of Google Chrome, a pushable resource can be identified by the Initiator column in the Network tab of the Developer Tools window. </p><br><p> <a href=""><img src="https://habrastorage.org/web/be9/d14/a00/be9d14a002164d7e8211cbf50b5fae57.png"></a> </p><br><p>  In addition, if you hover the mouse over the Waterfall column on the same tab, we will get detailed information about the resource pushing time: </p><br><p><img src="https://habrastorage.org/web/491/99c/805/49199c805f934f13a94e1cffa085ef0d.png"></p><br><p>  Mozilla Firefox tools are less obvious in determining pushable resources.  The status of such resources in the network tool of the browser‚Äôs developer tools is indicated by a gray dot. </p><br><p> <a href=""><img src="https://habrastorage.org/web/e5b/7de/749/e5b7de7499cb4a2485166949114bf82d.png"></a> </p><br><p>  If you are looking for an exact way to determine if a resource was pushed through by the server, you can use the <code>nghttp</code> <a href="http2.org/">command line</a> <code>nghttp</code> to verify the response from the HTTP / 2 server, for example: </p><br><pre> <code class="hljs objectivec">nghttp -ans https:<span class="hljs-comment"><span class="hljs-comment">//jeremywagner.me</span></span></code> </pre> <br><p>  In this way, you will receive brief information about the resources involved in the transaction.  Pushed resources will be marked with an asterisk, for example: </p><br><pre> <code class="hljs pgsql">id responseEnd requestStart process code size request <span class="hljs-type"><span class="hljs-type">path</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> +<span class="hljs-number"><span class="hljs-number">50.28</span></span>ms +<span class="hljs-number"><span class="hljs-number">1.07</span></span>ms <span class="hljs-number"><span class="hljs-number">49.21</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>K / <span class="hljs-number"><span class="hljs-number">2</span></span> +<span class="hljs-number"><span class="hljs-number">50.47</span></span>ms * +<span class="hljs-number"><span class="hljs-number">42.10</span></span>ms <span class="hljs-number"><span class="hljs-number">8.37</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>K /css/<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>.css <span class="hljs-number"><span class="hljs-number">4</span></span> +<span class="hljs-number"><span class="hljs-number">50.56</span></span>ms * +<span class="hljs-number"><span class="hljs-number">42.15</span></span>ms <span class="hljs-number"><span class="hljs-number">8.41</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">157</span></span> /css/fonts-loaded.css <span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">50.59</span></span>ms * +<span class="hljs-number"><span class="hljs-number">42.16</span></span>ms <span class="hljs-number"><span class="hljs-number">8.43</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">279</span></span> /js/ga.js <span class="hljs-number"><span class="hljs-number">8</span></span> +<span class="hljs-number"><span class="hljs-number">50.62</span></span>ms * +<span class="hljs-number"><span class="hljs-number">42.17</span></span>ms <span class="hljs-number"><span class="hljs-number">8.44</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">243</span></span> /js/<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>-fonts.js <span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">74.29</span></span>ms * +<span class="hljs-number"><span class="hljs-number">42.18</span></span>ms <span class="hljs-number"><span class="hljs-number">32.11</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>K /img/<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>/jeremy.png <span class="hljs-number"><span class="hljs-number">17</span></span> +<span class="hljs-number"><span class="hljs-number">87.17</span></span>ms +<span class="hljs-number"><span class="hljs-number">50.65</span></span>ms <span class="hljs-number"><span class="hljs-number">36.51</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">668</span></span> /js/lazyload.js <span class="hljs-number"><span class="hljs-number">15</span></span> +<span class="hljs-number"><span class="hljs-number">87.21</span></span>ms +<span class="hljs-number"><span class="hljs-number">50.65</span></span>ms <span class="hljs-number"><span class="hljs-number">36.56</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>K /img/<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>/book<span class="hljs-number"><span class="hljs-number">-1</span></span>x.png <span class="hljs-number"><span class="hljs-number">19</span></span> +<span class="hljs-number"><span class="hljs-number">87.23</span></span>ms +<span class="hljs-number"><span class="hljs-number">50.65</span></span>ms <span class="hljs-number"><span class="hljs-number">36.58</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span> /js/debounce.js <span class="hljs-number"><span class="hljs-number">21</span></span> +<span class="hljs-number"><span class="hljs-number">87.25</span></span>ms +<span class="hljs-number"><span class="hljs-number">50.65</span></span>ms <span class="hljs-number"><span class="hljs-number">36.60</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">240</span></span> /js/nav.js <span class="hljs-number"><span class="hljs-number">23</span></span> +<span class="hljs-number"><span class="hljs-number">87.27</span></span>ms +<span class="hljs-number"><span class="hljs-number">50.65</span></span>ms <span class="hljs-number"><span class="hljs-number">36.62</span></span>ms <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">302</span></span> /js/attach-nav.js</code> </pre> <br><p>  Here I used <code>nghttp</code> on my own website, which (at least at the time of writing) pushed five resources.  The resources we are interested in are marked with an asterisk on the left side of the <code>requestStart</code> column. </p><br><p>  Now that we can determine when resources are being pushed through, let's see how Server Push affects the performance of a real website. </p><br><h3 id="zamer-proizvoditelnosti-server-push">  Server Push Performance Measurement </h3><br><p>  Measuring the effect of any performance improvement requires a good testing tool.  <a href="https://www.sitespeed.io/">Sitespeed.io</a> is a great tool available through <a href="https://www.npmjs.com/">npm</a> ;  It automates page testing and collects valuable performance indicators. </p><br><p>  So, we have chosen a suitable tool - go to the testing methodology. </p><br><h4 id="metodologiya-testirovaniya">  Testing Methodology </h4><br><p>  I wanted to measure the impact of Server Push on the performance of a website.  For the results to be relevant, I needed to establish comparison points for six separate scenarios.  These scripts are divided into two aspects: HTTP / 2 or HTTP / 1 is used.  On HTTP / 2 servers we measure the impact of Server Push by a number of indicators;  on HTTP / 1 servers - we want to see how the embedding of resources affects the performance by the same indicators, since the embedding should have approximately the same advantages that Server Push provides. </p><br><p>  Considered scenarios: </p><br><ul><li>  <strong>HTTP / 2 - No Enhancements</strong> <br>  In this state, the site operates under the HTTP / 2 protocol, but absolutely nothing is pushed. <br><ul><li>  <strong>HTTP / 2 - Push CSS</strong> <br>  Server Push is used, but only for the CSS site.  CSS site is very small, weighing just over 2 KB, compressed using <a href="https://www.smashingmagazine.com/2016/10/next-generation-server-compression-with-brotli/">the Brotli algorithm</a> . </li><li>  <strong>HTTP / 2 - Push Everything</strong> <br>  All resources that are used on the pages of the site are pushed.  This includes CSS, as well as 1.4 KB of JavaScript code scattered across six files, and 5.9 KB of SVG images scattered across five files.  All file sizes are indicated after compression (also using Brotli). </li><li>  <strong>HTTP / 1 - No Enhancements</strong> <br>  The website works using the HTTP / 1 protocol, and no resources were added to reduce the number of requests or increase the rendering speed. </li><li>  <strong>HTTP / 1 - Inline CSS</strong> <br>  All CSS site embedded. </li><li>  <strong>HTTP / 1 - Inline Everything</strong> <br>  All resources used on the pages of the website are embedded.  CSS and scripts are embedded, and SVG images are base64 encoded and embedded directly in the markup.  It should be noted that the data encoded in base64 format is about 1.37 times more than their uncoded equivalents. </li></ul></li></ul><br><p>  For each scenario, I initiated testing with the following command: </p><br><pre> <code class="hljs swift">sitespeed.io -d <span class="hljs-number"><span class="hljs-number">1</span></span> -m <span class="hljs-number"><span class="hljs-number">1</span></span> -n <span class="hljs-number"><span class="hljs-number">25</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> cable -b chrome ‚Äìv https:<span class="hljs-comment"><span class="hljs-comment">//jeremywagner.me</span></span></code> </pre> <br><p>  If you want to know what this command does, you can <a href="https://www.sitespeed.io/documentation/sitespeed.io/configuration/">see the documentation</a> .  In short, she checks the home page of my site at <a href="https://jeremywagner.me/">https://jeremywagner.me</a> with the following conditions: </p><br><ul><li>  links on the page are not scanned, only the specified page is tested; <br>  page tested 25 times; </li><li>  a network profile is used that corresponds to 28 milliseconds of the signal travel time back and forth, the incoming speed is 5000 kbps, the outgoing speed is 1000 kbps; </li><li>  The test is run using Google Chrome. </li></ul><br><p>  For each test, three indicators were collected and displayed: </p><br><ul><li><p>  <strong>First Paint Time</strong> <br>  This is the point in time when the page began to appear in the browser.  To make it seem that the page loads quickly, this indicator should be reduced as much as possible. </p><br></li><li><p>  <strong>DOMContentLoaded Time</strong> <br>  This is the time when the HTML document was fully loaded and parsed.  Synchronous JavaScript code blocks the parser and increases this index.  Using the <code>async</code> attribute in <code>&lt;script&gt;</code> tags can help prevent parser blocking. </p><br></li><li>  <strong>Page load time</strong> <br>  This is the time required to fully load the page and its resources. </li></ul><br><p>  Having determined the parameters of the test, let's look at the results. </p><br><h4 id="rezultaty-testirovaniya">  Test results </h4><br><p>  The tests were conducted according to the six scenarios indicated above, with the construction of graphs of the results.  Let's start by looking at how each script affects the start time of the page display: </p><br><p><img src="https://habrastorage.org/web/677/e80/4e5/677e804e51b042799dc5a688ad0821a6.png"></p><br><p>  First, a few words about how the schedule is set up.  Part of the graph in blue corresponds to the average time.  The orange part is the 90% level.  The gray part shows the maximum time. </p><br><p>  We now turn to what we see.  The slowest scenarios are websites with HTTP / 2 and HTTP / 1 support without any improvements.  We see that using Server Push for CSS helps to make a page on average about 8% faster than if this technology was not used, and even about 5% faster than embedding CSS on an HTTP / 1 server. </p><br><p>  However, when we push through all possible resources, the picture changes somewhat: the start time of the page display slightly increases.  On the HTTP / 1 server, where we embed everything possible, we achieve slightly lower performance. </p><br><p>  The conclusion is obvious: with Server Push, you can achieve slightly better results than with HTTP / 1 with embedding.  However, when we push through or embed a lot of resources, we see a decrease in returns. </p><br><p>  It is worth noting that for visiting the site for the first time, using Server Push or embedded resources is better than no improvement.  It is also necessary to mention that tests are conducted on a website with little resources, so this test case may not fully reflect what is achievable for your site. </p><br><p>  We proceed to consider the influence of each script on the DOMContentLoaded time: </p><br><p><img src="https://habrastorage.org/web/b8a/33d/b34/b8a33db34c5d4732bf4a8054eea354aa.png"></p><br><p>  The trends here are not very different from what we saw in the previous chart, with the exception of one noticeable deviation: an example in which we embed all possible resources on HTTP / 1 gives a rather low DOMContentLoaded time.  This is probably due to the fact that embedding reduces the amount of resources required for loading, which allows the parser to continue its work without interruptions. </p><br><p>  Finally, let's see how the full page load time changes in each scenario: </p><br><p><img src="https://habrastorage.org/web/45c/a2f/fbc/45ca2ffbc17e4b88875ab0844930bdc2.png"></p><br><p>  The trends of the previous graphs that we found are generally preserved here.  I found that pushing only CSS gave the best page load time.  Pushing too many resources in some cases can make the web server a little "lethargic", but it was still better than not pushing anything.  Compared to embedding Server Push, it gave results. </p><br><h3 id="predosterezheniya-pri-ispolzovanii-server-push">  Cautions when using Server Push </h3><br><p>  Server Push is not a panacea for the inefficient operation of your site.  To achieve good results, this technology must be used correctly.  And here are some important points. </p><br><h4 id="vy-mozhete-protolknut-slishkom-mnogo-resursov">  You may push too many resources. </h4><br><p>  In one of the scenarios above, I push a lot of resources, but they all make up a small part of the total data.  Pushing through a large amount of very large resources could immediately delay the display of your page, because the browser needs to load not only HTML, but also all other resources that are loaded in parallel.  It is best to be selective in what you are pushing.  Style sheets (as long as they are not very massive) are a good choice to start with.  Then appreciate what else it makes sense to push. </p><br><h4 id="vy-mozhete-protolknut-resursy-ne-otnosyaschiesya-k-tekuschey-stranice">  You can push resources other than the current page. </h4><br><p>  This is not always bad, especially if you have a visitor analyst.  A good example is the multipage registration form in which you push resources for the next page while the registration process is in progress.  However, let's agree: if you don‚Äôt know if you need to force resources for a page that visitors haven‚Äôt seen yet, don‚Äôt.  Some users may use a tariff with a limited amount of traffic, and your strategy may cost them real money. </p><br><h4 id="nastroyte-vash-http2-server-pravilno">  Configure your HTTP / 2 server correctly </h4><br><p>  Some servers have many configuration options associated with Server Push.  So, <code>mod_http2</code> in Apache has several parameters to configure pushing resources.  The <a href="http2.html"><code>H2PushPriority</code></a> parameter is of particular interest, although in the case of my server I left it by default.  Some experiments may give an additional performance gain.  Each web server has a whole set of switches and settings that you can experiment with, so read the manual carefully to find out what is available to you. </p><br><h4 id="protalkivaemye-resursy-mogut-ostatsya-bez-keshirovaniya">  Pushed resources can remain without caching </h4><br><p>     ,   Server Push     - ,           .     ,    .  <code>mod_http2</code>  Apache, ,     <a href="http2.html"><code>H2PushDiarySize</code></a> ,   H2O  <a href="http2_directives.html"> </a> ,    cookie     . </p><br><p>     H2O-,          -   -,       cookie.    ,   ,  <a href="https://css-tricks.com/cache-aware-server-push/">,       CSS-Tricks</a> .     ,      <code>RST_STREAM</code> ,   ,     .         . </p><br><h3 id="zaklyuchitelnye-mysli">   </h3><br><p>      HTTP/2?       ,    Server Push. </p><br><p>      -   ,   .    :  ,   -   .        CSS  .        ,   ,    .    ,  ,     . </p><br><p>      Server Push  ,  H2O,   ,      cookies.          ,     .         ,    ,      . </p><br><p>      Server Push ,    : </p><br><ul><li> <a href="https://tools.ietf.org/html/rfc7540">Server Push</a> , Hypertext Transfer Protocol Version 2 (HTTP/2), Internet Engineering Task Force </li><li> <a href="https://www.filamentgroup.com/lab/modernizing-delivery.html">Modernizing Our Progressive Enhancement Delivery</a> , Scott Jehl, Filament Group </li><li> <a href="http-2.0-server-push/">Innovating with HTTP 2.0 Server Push</a> , Ilya Grigorik </li></ul><br><p>  <em>From the translator.</em>  <a href="https://blog.yoav.ws/">Yoav Weiss</a>  ,   <code>as</code>  (  ,     ),       .   <a href="https://jakearchibald.com/"> </a>  ,    <code>preload</code> ‚Äì  ,   Server Push. </p><br><p>    HTTP/2   Server Push.           <a href="https://www.manning.com/books/web-performance-in-action%3Fa_aid%3Dwebopt%26a_bid%3D63c31090">¬´-  ¬ª</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329722/">https://habr.com/ru/post/329722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329710/index.html">CSS in JavaScript: the future of component styles</a></li>
<li><a href="../329714/index.html">About the intricacies of Windows 10 Creators Update and some features of Microsoft support.</a></li>
<li><a href="../329716/index.html">"Support," as much in this word ...</a></li>
<li><a href="../329718/index.html">How to choose the PHP-framework. Comparative Testing</a></li>
<li><a href="../329720/index.html">About circumventing access restrictions to postal services</a></li>
<li><a href="../329724/index.html">Another DoS vulnerability</a></li>
<li><a href="../329726/index.html">Educational online project: "Start in web development"</a></li>
<li><a href="../329728/index.html">Nikita Lipsky and Dmitry Chuiko on AOT in Java on jug.msk.ru</a></li>
<li><a href="../329730/index.html">"Confrontation" PHDays or what we were called the "All-seeing Eye"</a></li>
<li><a href="../329732/index.html">Innopolis and the slow pursuit of the silicon valleys</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>