<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Changes in Visual C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When you want to upgrade your version of the Visual C ++ compiler (for example, to switch from Visual Studio from 2013 to 2015), it will not be superf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Changes in Visual C ++</h1><div class="post__text post__text-html js-mediator-article">  When you want to upgrade your version of the Visual C ++ compiler (for example, to switch from Visual Studio from 2013 to 2015), it will not be superfluous to know why you may encounter that the code that was successfully compiled and executed before will now cause compilation errors and / or runtime errors. <br>  These problems can be caused by numerous compiler changes to conform to the C ++ standard, changes in function signatures, or changes in the location of objects in memory. <br><a name="habracut"></a><br>  In order to avoid runtime errors (which are known to be the most difficult to find), we recommend never doing static linking with binary files obtained by another version of the compiler.  Also when updating your program (EXE or DLL), make sure that the libraries used are also compiled with the new version of the compiler. <br>  If you use types from CRT (C Runtime) or STL (Standard Template Library), do not transfer them between binary files (including DLLs) that are compiled by different versions of the compiler.  This issue is discussed in more detail in <a href="https://msdn.microsoft.com/en-us/library/vstudio/ms235460(v%3Dvs.140).aspx">Potential Errors Passing CRT Objects Across DLL Boundaries</a> . <br>  And in the future, we recommend not to write code that depends on the specific location of objects in memory (if it is not a COM interface or a POD object).  If you now have such code, after updating the compiler you should make sure that everything works as it should.  More details can be found here: <a href="https://msdn.microsoft.com/en-us/library/vstudio/hh438475(v%3Dvs.140).aspx">Portability At ABI Boundaries (Modern C ++)</a> . <br><br>  The following article describes the changes in the Visual C ++ compiler (which comes with Visual Studio 2015 Preview).  In the article, the words ‚Äúnew behavior‚Äù and ‚Äúnow‚Äù refer specifically to this version, and ‚Äúold behavior‚Äù and ‚Äúearlier‚Äù refer to Visual Studio 2013 (and earlier versions). <br><br>  Summary: <br>  - Changes in the compiler <br>  - Changes in C Runtime Library (CRT) <br>  - STL changes <br>  - Changes in MFC and ATL 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>Compiler Changes</b> </h4><br><ul><li> <b>/ Zc: forScope</b> - The compiler flag <code>/Zc:forScope-</code> been deprecated and will be removed in the future.  Now the compiler using this flag will throw out the D9035 warning. <br>  This flag is used to use a non-standard C ++ extension ‚Äî using variables declared in the description of a <code>for</code> loop outside of this loop.  This flag is necessary only if another flag is set - <code>/Za</code> ( <a href="https://msdn.microsoft.com/en-us/library/0k0w269d.aspx">comply with the standard</a> ), because without <code>/Za</code> , the use of variables from the description of the loop is allowed by default.  If you do not need to worry about cross-platform (for example, you are not supposed to collect code from other compilers), you can turn off the <code>/Za</code> flag (set the ‚ÄúDisable Language Extensions‚Äù project property to ‚ÄúNo‚Äù).  If you care about cross-platform and standard compliance, then such parts of the code need to be rewritten by moving the variable declaration above the loop: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// zc_forScope.cpp // compile with: /Zc:forScope- /Za // C2065 expected int main() { //       // int i; for (int i =0; i &lt; 1; i++) ; i = 20; //   /Za  i      }</span></span></code> </pre><br></li><li>  <b>/ Zg</b> <br>  The <code>/Zg</code> compiler flag ( <a href="https://msdn.microsoft.com/en-us/library/y4s1adf3.aspx">prototyping functions</a> ) is no longer available for use (it used to have the deprecated attribute) <br><br></li><li>  Now you cannot run unit tests using C ++ / CLI from the command line using mstest.exe, instead you need to use vtest.console.exe.  You can learn more about this here: <a href="https://msdn.microsoft.com/en-us/library/vstudio/jj155796(v%3Dvs.140).aspx">VSTest.Console.exe command-line options</a> . <br><br></li><li>  <b>Keyword mutable</b> <br>  Now the use of <code>mutable</code> , in accordance with the standard, is allowed only applicable to the names of class members, and can not be applied to links, or names declared as <code>const</code> or <code>static</code> .  Example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;r; };</code> </pre><br>  Previously, this was compiled, now the compiler will generate error C2071.  To fix, you just need to remove the <code>mutable</code> . <br><br></li><li>  <b>char_16_t and char_32_t</b> <br>  Now you cannot use char_16_t and char_32_t as aliases for custom types, because now these types are defined as built-in.  It used to be quite common practice for library authors to define char_16_t and char_32_t as aliases for uint_16_t and uint_32_t, respectively. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; typedef uint16_t char16_t; //C2628 typedef uint32_t char32_t; //C2628 int main(int argc, char* argv[]) { uint16_t x = 1; uint32_t y = 2; char16_t a = x; char32_t b = y; return 0; }</span></span></span></span></code> </pre><br>  To fix it, remove the alias declaration and rename any other identifiers that conflict with the newly entered ones. <br><br></li><li>  <b>Non-type (non-type) template parameters</b> <br>  Code that includes atypical template parameters is now correctly checked for type compatibility.  For example, the following code was previously compiled without errors: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span>:*Function)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ S2 s2; s2.f&lt;S1, &amp;S1::f&gt;(); }</code> </pre><br>  Now the compiler will generate an error, since the type of the template parameter does not match the type of the argument passed (the type of the parameter is a pointer to a constant method, but f is not constant). <br> <code>error C2893: Failed to specialize function template 'void S2::f(void)'</code> <br> <code>note: With the following template arguments:</code> <br> <code>note: 'C=S1'</code> <br> <code>note: 'Function=S1::f' <br></code> <br>  To get rid of this error, make sure that the type of the template argument matches the type of the parameter. <br><br></li><li>  <b>__declspec (align)</b> <br>  The compiler no longer accepts <code>__declspec(align)</code> for functions.  In truth, he never accepted, but now he will give out an error C3323.  To get rid of it, simply remove this expression from the function declaration.  Since this has not had any effect before, it will not change anything in your program. <br><br></li><li>  <b>Exception Handling</b> <br>  There are several changes in exception handling.  The first is that exception objects must be copied and moved.  before this code was compiled, now there will be an error: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: S(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: S(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> S &amp;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> S(); <span class="hljs-comment"><span class="hljs-comment">// error }</span></span></code> </pre><br>  The problem here is that the copy constructor is declared private, so the object cannot be copied, which is usually required when processing an exception.  The same applies when the constructor is declared <code>explicit</code> . <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> S &amp;)</span></span></span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> S(); <span class="hljs-comment"><span class="hljs-comment">// error }</span></span></code> </pre><br>  To get rid of this problem, make sure that the constructor for the exception object is declared in a public zone and <code>explicit</code> . <br>  When catching an exception, the object is also required to be copied.  The following code will compile in earlier versions of Visual Studio, but now there will be an error: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: B(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> B &amp;); }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> B { }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (D d) <span class="hljs-comment"><span class="hljs-comment">// error { } }</span></span></code> </pre><br>  This error can be corrected by accepting the exception by reference: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(D&amp; d) { }</code> </pre><br></li><li>  <b>Strings and Macros</b> <br>  The compiler now supports user-defined literals (user defined literals - UDL).  As a consequence of this, strings (or more precisely string literals), followed by a macro without a space, are interpreted as UDL, which may cause an error or an unexpected result.  For example, before it was compiled without problems: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _x </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"there"</span></span></span><span class="hljs-meta"> char* func() { return </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello"</span></span></span><span class="hljs-meta">_x; } int main() { char * p = func(); return 0; }</span></span></code> </pre><br>  The compiler interpreted the value returned by the func function as the string "hello", and the macro that was expanded to "there" and then combined the two literals into one.  Now the compiler interprets this as a UDL, but since it cannot find the definition of _x among the UDLs known to it, it gives an error: <br> <code>error C3688: invalid literal suffix '_x'; literal operator or literal operator template 'operator ""_x' not found</code> <br> <code>note: Did you forget a space between the string literal and the prefix of the following string literal?</code> <br>  To solve this problem, you need to put a space between the line and the macro. <br><br></li><li>  <b>Rows next to each other</b> <br>  Just as in the previous case, due to changes in the parsing of lines, building string literals that are not separated by a space, were previously interpreted as one line, but now you need to add a space to correctly compile: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * str = <span class="hljs-string"><span class="hljs-string">"abc"</span></span><span class="hljs-string"><span class="hljs-string">"def"</span></span>;</code> </pre><br>  Just add a space between the lines: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * str = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> <span class="hljs-string"><span class="hljs-string">"def"</span></span>;</code> </pre><br></li><li>  <b>Hosting new and delete</b> <br>  To comply with the standard C ++ 14, the behavior of the <code>delete</code> operator has been changed.  Details can be found in <a href="http://isocpp.org/files/papers/n3778.html">C ++ Sized Deallocation</a> .  A form of the global operator <code>delete</code> been added, which takes the size of the object.  The importance of this change is that if your code contains a <code>delete</code> with the same signature (corresponding to the placing operator <code>new</code> ), you will receive a compilation error (C2956, which points to a string using the <code>new</code> operator, because it is in this place that the compiler tries to determine appropriate operator <code>delete</code> ). <br>  The function <code>void operator delete(void*, size_t)</code> was the <code>delete</code> operator, corresponding to the function of the location operator <code>new</code> - <code>void* operator new(size_t, size_t)</code> from C ++ 11.  In the new C ++ 14 standard, this <code>delete</code> become a normal function of allocation (that is, a global <code>delete</code> operator).  The standard requires the following: if the host <code>new</code> searches for the corresponding <code>delete</code> and finds a standard function, the program will not compile. <br>  For example, suppose your code defines a host for <code>new</code> and <code>delete</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre><br>  The problem here is the following: the coincidence of the description of the operator placing the <code>delete</code> and the description of the new global operator.  In order to avoid such a match, you can use a type other than size_t when describing the size in the <code>new</code> and <code>delete</code> positioning operators.  Here you need to take into account that size_t depends on the compiler, in Visual C ++ it is an alias for unsigned int.  A good solution here is to use the enumeration: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_type</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> {};</code> </pre><br>  Then, we need to change the declarations of the posting operators <code>new</code> and <code>delete</code> so that they use my_type as the second parameter instead of size_t.  You will also need to correct the transfer of the argument to the call to <code>new</code> (for example, using <code>static_cast&lt;my_type&gt;</code> to perform a conversion from an integer value to an enumeration) and change the definition of the host operators by performing conversions from an enum to an integer type.  In addition to the enumeration, you can use, for example, a class that has a field of type size_t. <br>  Alternatively, you can remove the posting <code>new</code> .  If your code uses placing <code>new</code> to implement a pool and the passed size is the size of the object to be placed or deleted, in this case, the new <code>delete</code> operator may well be suitable for deleting this pool. <br>  If you do not want to change the behavior of these operators in your code right now, you can still use the / Zc: sizedDealloc- flag, which will return the old behavior.  That is, a two-argument delete function will not be created, and thus there will be no conflict with the specific delete function you have. <br><br></li><li>  <b>Fields of unions (union data members)</b> <br>  Now links can not be a union field (union).  Previously, this code was compiled, now - no: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> U1 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> U2 { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;i; }; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> U3 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;i;}; };</code> </pre><br>  Now the following errors occur: <br> <code>test.cpp(67): error C2625: 'U2::i': illegal union member; type 'int &amp;' is reference type <br></code> <br> <code>test.cpp(70): error C2625: 'U3::i': illegal union member; type 'int &amp;' is reference type <br></code> <br>  To resolve this problem, you need to change the reference to the pointer or just the usual value.  Changing the type to a pointer will require changes in the code that accesses this field.  Changing the type to value will change the value in the union, which will affect other fields of the union.  Also in this case the size of the union may change. <br><br></li><li>  <b>Unnamed unification</b> <br>  Unnamed unions have become more standard.  Previously, an explicit constructor and destructor were generated for nameless unions.  They are now declared removed. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(); }; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> S s; }; } u; <span class="hljs-comment"><span class="hljs-comment">// C2280</span></span></code> </pre><br>  The following errors are generated in Visual Studio 2015 Preview: <br> <code>error C2280: '&lt;unnamed-type-u&gt;::&lt;unnamed-type-u&gt;(void)': attempting to reference a deleted function <br></code> <br> <code>note: compiler has generated '&lt;unnamed-type-u&gt;::&lt;unnamed-type-u&gt;' here <br></code> <br>  To solve this problem, you need to define your constructor and / or destructor. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ,    S() {} }; union { struct { S s; }; } u;</span></span></code> </pre><br></li><li>  <b>Associations with anonymous structures</b> <br>  In order to ensure compliance with the standard, the run-time behavior for members of anonymous structures in associations was changed.  The constructor of anonymous structures ‚Äî members of associations ‚Äî is no longer invoked implicitly when a union is created.  Also, the destructor of such fields is not invoked implicitly when the union exits from the visibility block.  Example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; struct S { S() { printf("Creating S\n"); } ~S(){ printf("Destroying S\n"); } }; union U { struct { S s; }; U() {} ~U(){} }; void f() { U u; //    } int main() { f(); char s[1024]; printf("Press any key.\n"); gets_s(s); return 0; }</span></span></span></span></code> </pre><br>  Previously, both the constructor and the destructor were called.  Now they are not called.  The compiler issues warnings: <br> <code>warning C4587: 'U::s': behavior change: constructor is no longer implicitly called <br></code> <br> <code>warning C4588: 'U::s': behavior change: destructor is no longer implicitly called <br></code> <br>  To restore the old behavior you need to give the name an anonymous structure.  The run-time behavior of non-anonymous structures remains independent of the compiler version. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; struct S { S() { printf("Creating S.\n"); } ~S() { printf("Destroying S\n"); } }; union U { struct { S s; } namedStruct; U() {} ~U() {} }; void f() { U u; } int main() { f(); char s[1024]; printf("Press any key.\n"); gets_s(s); return 0; }</span></span></span></span></code> </pre><br>  Alternatively, you can try to transfer the code of the constructor and the destructor structure to new methods and call them from the constructor and destructor of the union: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; struct S { void Create() { printf("Creating S.\n"); } void Destroy() { printf("Destroying S\n"); } }; union U { struct { S s; }; U() { s.Create(); } ~U() { s.Destroy(); } }; void f() { U u; } int main() { f(); char s[1024]; printf("Press any key.\n"); gets_s(s); return 0; }</span></span></span></span></code> </pre><br></li><li>  <b>Template resolution</b> <br>  Name resolution for templates has also been changed.  In C ++, when considering candidates when resolving names, it is quite possible that one or more names may be invalid instantiations of the template.  These incorrect implementations usually do not cause compilation errors (because the principle known as SFINAE is used). <br><br>  Now, if SFINAE requires the compiler to specify a class template, any errors during the execution of this instantiation will be considered compiler errors.  Previously, these errors were ignored.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template&lt;typename T&gt; struct S { S() = default; S(const S&amp;); S(S&amp;&amp;); template&lt;typename U, typename = typename std::enable_if&lt;std::is_base_of&lt;T, U&gt;::value&gt;::type&gt; S(S&lt;U&gt;&amp;&amp;); }; struct D; void f1() { S&lt;D&gt; s1; S&lt;D&gt; s2(s1); } struct B { }; struct D : public B { }; void f2() { S&lt;D&gt; s1; S&lt;D&gt; s2(s1); }</span></span></span></span></code> </pre><br>  The new compiler will display the following error message: <br> <code>type_traits(1110): error C2139: 'D': an undefined class is not allowed as an argument to compiler intrinsic type trait '__is_base_of' <br></code> <br> <code>..\t331.cpp(14): note: see declaration of 'D' <br></code> <br> <code>..\t331.cpp(10): note: see reference to class template instantiation 'std::is_base_of&lt;T,U&gt;' being compiled <br></code> <br><pre> with
 [
     T = d,
     U = D
 ]
</pre><br>  The reason for the error is that in the place of the first <code>is_base_of</code> call <code>is_base_of</code> class D has not yet been defined. <br>  In this case, the correction of the error will be as follows: you do not need to use such type checks before defining the classes, then you need to transfer the definition of B and D d to the beginning of the file.  If these definitions are in header files, you need to check the order of inclusion to ensure that class definitions are included before the problem pattern is used. <br><br></li><li>  <b>Copy Constructors</b> <br>  In both Visual Studio 2013 and Visual Studio 2015 RC, the compiler creates a copy constructor for a class if the class has a user-defined motion constructor, but no user-defined copy constructor.  In Dev14, this implicitly generated copy constructor is marked as "= delete". <br></li></ul><br><br><h4>  <b>Changes in the C Runtime Library (CRT)</b> </h4><br><h4>  General changes </h4><br><ul><li>  <b>Refactoring binary files</b> <br>  The CRT library was divided into two binary files ‚Äî the CRT shared library (Universal CRT - ucrtbase), which contains most of the standard functionality, and the VC Runtime library (vcruntime140), which contains compiler-dependent functionality (for example, exception handling and built-in functions ( intrinsics)).  If you use the standard settings of the project, then this change will not affect you in any way, since the linker will begin to use these new libraries.  If you set the <b>Ignore All Default Libraries</b> project's linker property to <b>Yes</b> , or you used the linker flag / NODEFAULTLIB, then you should update your list of libraries (the project property <b>Additional Dependencies</b> ), that is, include the new libraries yourself.  Or rather, replace the old CRT libraries (libcmt.lib, libcmtd.lib, msvcrt.lib, msvcrtd.lib) with new equivalents.  For each of the two new libraries, there is a static (.lib) and dynamic (.dll) version, as well as a release build (without a suffix) and a debug build (with the suffix "d").  More details here: <a href="">CRT Library Features</a> <br></li></ul><br><h4><pre>  &lt;locale.h&gt; </pre></h4><br><ul><li>  <b>localeconv</b> <br>  The <a href="">localeconv</a> function declared in locale.h now works correctly when the stream locale is enabled ( <a href="">per-thread locale</a> ).  Previously, this function returned Iconv to a global, rather than streaming, locale. <br>  If you are using a stream locale, you should check how the new behavior of localeconv will affect your program. <br></li></ul><br><h4><pre>  &lt;math.h&gt; </pre></h4><br><ul><li>  <b>C ++ library functions overload</b> <br>  Previously, <code>&lt;math.h&gt;</code> overloaded some, but not all, math library functions.  An <code><code>    .      ,    &lt;math.h&gt; .      <code>&lt;math.h&gt;</code>  <code>. <br> <br></code> <br> <b>       </b> <br>             IEEE-754   F  C11,       (NaN  ). ,      NaN    ,  -  .       : <a href="http://grouper.ieee.org/groups/754">IEEE 754 Standard</a> , Annex F of the <a href="http://www.iso-9899.info/wiki/The_Standard">C11 Standard</a> . <br>       ,         -   . <br> <br> <br> <b>FLT_ROUNDS</b> <br>       ,   ,            (,   fesetround).  FLT_ROUNDS  . <br> <br></code></code> <code><code>    .      ,    &lt;math.h&gt;</code> .      <code>&lt;math.h&gt;</code>  <code>. <br> <br></code> <br> <b>       </b> <br>             IEEE-754   F  C11,       (NaN  ). ,      NaN    ,  -  .       : <a href="http://grouper.ieee.org/groups/754">IEEE 754 Standard</a> , Annex F of the <a href="http://www.iso-9899.info/wiki/The_Standard">C11 Standard</a> . <br>       ,         -   . <br> <br> <br> <b>FLT_ROUNDS</b> <br>       ,   ,            (,   fesetround).  FLT_ROUNDS  . <br> <br></code> <br><h4><pre>  &lt;new&gt; and &lt;new.h&gt; </pre></h4><br><ul><li>  <b>new and delete</b> <br>  In the previous version of the library, the implementation-dependent new and delete operators were exported from a dynamic library (for example, msvcr120.dll).  These operators are now always linked statically with your binaries, even if dynamic libraries are used. <br>  This is not a very significant change for native or mixed code (/ clr), but if your code is compiled with the <a href="">/ clr: pure</a> flag, then after updating the code may stop compiling.  In this case, you need to make sure that the header files <code><code> &lt;new.h&gt; .    :  /clr:pure          . <br></code></code> connected in all the right places <code><code> &lt;new.h&gt;</code> .    :  /clr:pure          . <br></code> <code><code> &lt;new.h&gt;</code> .    :  /clr:pure          . <br></code> <br></li></ul></li></ul></div><p>Source: <a href="https://habr.com/ru/post/257509/">https://habr.com/ru/post/257509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257499/index.html">Notes on the fields of Big Data Week Moscow</a></li>
<li><a href="../257501/index.html">Cach√© 2015 Scalability with Ivy Bridge-EX</a></li>
<li><a href="../257503/index.html">Power profiling of microcontrollers (EFM32, SiLabs series)</a></li>
<li><a href="../257505/index.html">Responsive design + Icon fonts = Adaptive icons</a></li>
<li><a href="../257507/index.html">A new virus that disables the computer when it is detected</a></li>
<li><a href="../257511/index.html">ES6 and beyond. Chapter 2: Syntax. Part 1</a></li>
<li><a href="../257513/index.html">Not quite cool Ruby</a></li>
<li><a href="../257517/index.html">Databases honey systems based on HL7 RIM</a></li>
<li><a href="../257523/index.html">May 28 in Moscow, ‚ÄúThe Road to the Cloud‚Äù: discussion of cloud business strategies for software companies, all about new industry trends</a></li>
<li><a href="../257527/index.html">Photos from the opening of the Rostantskaya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>