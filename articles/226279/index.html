<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Under the hood at Stopwatch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Very often, we developers need to measure the execution time of their (and not only their) code. When I first started programming, I us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Under the hood at Stopwatch</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Very often, we developers need to measure the execution time of their (and not only their) code.  When I first started programming, I used the <b>DateTime</b> structure for this purpose.  Time passed, and I learned about the class <b>Stopwatch</b> and began to actively use it.  I think you had a similar situation.  It‚Äôs not that I hadn‚Äôt previously wondered how Stopwatch works, but at that time I‚Äôm aware that it allows me to measure elapsed time more accurately than DateTime was enough for me.  The time has come to explain to ourselves, as well as to readers, how the Stopwatch class actually works, as well as to find out its advantages and disadvantages compared to using DateTime. <br><a name="habracut"></a><br><h4>  Using DateTime </h4><br>  Using the DateTime structure to measure the execution time of a code is quite simple: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> before = DateTime.Now; SomeOperation(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spendTime = DateTime.Now - before;</code> </pre> <br>  Property DateTime.Now - returns the local current date and time.  Instead of the DateTime.Now property, you can use the DateTime.UtcNow property ‚Äî which returns the current date and time, but instead of the local time zone, it represents them as Utc time, that is, as coordinated universal time. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> before = DateTime.UtcNow; SomeOperation(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spendTime = DateTime.UtcNow - before;</code> </pre><br><h4>  A few words about the datetime structure </h4><br>  Perhaps few thought about what a DateTime structure is.  The value of the DateTime structure is measured in 100-nanosecond units, called ticks, and the exact date is represented by the number of ticks elapsed since 00:00 January 1, 0001 AD. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, the number 628539264000000000 represents October 6, 1992 00:00:00. <br><br>  The DateTime structure contains a single field that contains the number of cycles that have passed: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UInt64 dateData;</code> </pre><br>  It should also be said that starting with .NET 2.0, the 2 high-order bits of this field indicate the type of DateTime: Unspecfied ‚Äî not set, Utc ‚Äî coordinated time, Local ‚Äî local time, and the remaining 62 bits ‚Äî the number of ticks.  We can easily query these two bits using the Kind property. <br><br><h4>  What is wrong with using datetime? </h4><br>  Using the DateTime.Now property to measure time intervals is not a good idea, and here's why: <br><br><div class="spoiler">  <b class="spoiler_title">DateTime.Now</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DateTime Now { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { DateTime utc = DateTime.UtcNow; Boolean isAmbiguousLocalDst = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Int64 offset = TimeZoneInfo.GetDateTimeNowUtcOffsetFromUtc(utc, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> isAmbiguousLocalDst).Ticks; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> tick = utc.Ticks + offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tick &gt; DateTime.MaxTicks) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(DateTime.MaxTicks, DateTimeKind.Local); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tick &lt; DateTime.MinTicks) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(DateTime.MinTicks, DateTimeKind.Local); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(tick, DateTimeKind.Local, isAmbiguousLocalDst); } }</code> </pre><br></div></div><br>  The calculation of the DateTime.Now property is based on DateTime.UtcNow, that is, the coordinated time is first calculated and then the time zone offset is applied to it. <br><br>  That is why using the DateTime.UtcNow property will be more correct, it is calculated much faster: <br><br><div class="spoiler">  <b class="spoiler_title">DateTime.UtcNow</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DateTime UtcNow { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ticks = <span class="hljs-number"><span class="hljs-number">0</span></span>; ticks = GetSystemTimeAsFileTime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(((UInt64)(ticks + FileTimeOffset)) | KindUtc); } }</code> </pre><br></div></div><br>  The problem with using DateTime.Now or DateTime.UtcNow is that their accuracy is fixed.  As stated above <br><br>  <b>1 tick = 100 nanoseconds = 0.1 microseconds = 0.0001 milliseconds = 0.0000001 seconds</b> <br><br>  accordingly, it is simply impossible to measure the time interval whose length is less than the length of one measure.  Of course, it is unlikely that you will need it, but you need to know it. <br><br><h4>  Using the Stopwatch class </h4><br>  The Stopwatch class appeared in .NET 2.0 and has not undergone any changes since.  It provides a set of methods and tools that can be used to accurately measure elapsed time. <br><br>  The public API of the Stopwatch class looks like this: <br><br>  <b>Properties</b> <br><ol><li>  Elapsed - returns the total elapsed time; </li><li>  ElapsedMilliseconds - returns the total elapsed time in milliseconds; </li><li>  ElapsedTicks - returns the total elapsed time in timer ticks; </li><li>  IsRunning - returns a value indicating whether the Stopwatch timer is running. </li></ol><br>  <b>Methods</b> <br><ol><li>  Reset - stops the measurement of the time interval and resets the elapsed time; </li><li>  Restart - stops the measurement of the time interval, resets the elapsed time and starts measuring the elapsed time; </li><li>  Start - starts or continues measurement of the elapsed time for the interval; </li><li>  StartNew - initializes a new instance of Stopwatch, sets the elapsed time property to zero and starts the elapsed time measurement; </li><li>  Stop - stops the measurement of the elapsed time for the interval. </li></ol><br>  <b>Fields</b> <br><ol><li>  Frequency - returns the frequency of the timer, as the number of ticks per second; </li><li>  IsHighResolution - indicates whether the timer depends on the high-resolution performance counter. </li></ol><br>  Code that uses the Stopwatch class to measure the execution time of the SomeOperation method might look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); SomeOperation(); sw.Stop();</code> </pre><br>  The first two lines can be written more succinctly: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sw = Stopwatch.StartNew(); SomeOperation(); sw.Stop();</code> </pre><br><h4>  Stopwatch implementation </h4><br>  The Stopwatch class is based on HPET (High Precision Event Timer, High Precision Event Timer).  This timer was introduced by Microsoft to once and for all put an end to the problems of measuring time.  The frequency of this timer (minimum 10 MHz) does not change while the system is running.  For each system, Windows itself determines with what devices to implement this timer. <br><br>  The Stopwatch class contains the following fields: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> TicksPerMillisecond = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> TicksPerSecond = TicksPerMillisecond * <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRunning; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTimeStamp; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> elapsed; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tickFrequency;</code> </pre><br>  TicksPerMillisecond - determines the number of DateTime cycles in 1 millisecond; <br>  TicksPerSecond - determines the number of datetime times in 1 second; <br><br>  isRunning - determines whether the current instance is running (if the Start method was called); <br>  startTimeStamp - the number of cycles at the time of launch; <br>  elapsed - the total number of cycles spent; <br><br>  tickFrequency - simplifies the translation of Stopwatch clocks into DateTime clocks. <br><br>  The static constructor checks for the presence of the HPET timer and, if it is missing, the Stopwatch frequency is set equal to the DateTime frequency. <br><br><div class="spoiler">  <b class="spoiler_title">Static constructor Stopwatch</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stopwatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> succeeded = SafeNativeMethods.QueryPerformanceFrequency(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Frequency); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!succeeded) { IsHighResolution = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Frequency = TicksPerSecond; tickFrequency = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { IsHighResolution = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tickFrequency = TicksPerSecond; tickFrequency /= Frequency; } }</code> </pre><br></div></div><br>  The main scenario of the work of this class was shown above: a call to the Start method, a method whose time must be measured, and then a call to the Stop method. <br><br>  The implementation of the Start method is very simple - it remembers the initial number of measures: <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isRunning) { startTimeStamp = GetTimestamp(); isRunning = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre><br></div></div><br>  <i><b>It should be said that calling the Start method on an already measuring instance does not lead to anything.</b></i> <br><br>  The Stop method is just the same: <br><br><div class="spoiler">  <b class="spoiler_title">Stop</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> endTimeStamp = GetTimestamp(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> elapsedThisPeriod = endTimeStamp - startTimeStamp; elapsed += elapsedThisPeriod; isRunning = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// When measuring small time periods the StopWatch.Elapsed* // properties can return negative values. This is due to // bugs in the basic input/output system (BIOS) or the hardware // abstraction layer (HAL) on machines with variable-speed CPUs // (eg Intel SpeedStep). elapsed = 0; } } }</span></span></code> </pre><br></div></div><br>  <i><b>Calling the Stop method on a stopped instance also results in nothing.</b></i> <br><br>  Both methods use the GetTimestamp () call, which returns the number of ticks at the time of the call: <br><br><div class="spoiler">  <b class="spoiler_title">Gettimestamp</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTimestamp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsHighResolution) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timestamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; SafeNativeMethods.QueryPerformanceCounter(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> timestamp); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timestamp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DateTime.UtcNow.Ticks; } }</code> </pre><br></div></div><br>  With HPET (High Precision Event Timer), the Stopwatch beats are different from the DateTime beats. <br><br>  Following code <br><br><pre> <code class="cs hljs">Console.WriteLine(Stopwatch.GetTimestamp()); Console.WriteLine(DateTime.UtcNow.Ticks);</code> </pre><br>  on my computer displays <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">5201678165559</span></span> <span class="hljs-number"><span class="hljs-number">635382513439102209</span></span></code> </pre><br>  Using the Stopwatch measures to create a DateTime or TimeSpan is incorrect.  Record <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeSpan(sw.ElaspedTicks);</code> </pre><br>  for obvious reasons, will lead to incorrect results. <br><br>  To get the DateTime clock cycles, and not Stopwatch, you need to use the Elapsed and ElapsedMilliseconds properties or do the conversion manually.  To convert Stopwatch clocks to DateTime clocks in a class, use the following method: <br><br><div class="spoiler">  <b class="spoiler_title">GetElapsedDateTimeTicks</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElapsedDateTimeTicks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> rawTicks = GetRawElapsedTicks();<span class="hljs-comment"><span class="hljs-comment">// get Stopwatch ticks if (IsHighResolution) { // convert high resolution perf counter to DateTime ticks double dticks = rawTicks; dticks *= tickFrequency; return unchecked((long)dticks); } else { return rawTicks; } }</span></span></code> </pre><br></div></div><br>  The property code looks as expected: <br><br><div class="spoiler">  <b class="spoiler_title">Elapsed, ElapsedMilliseconds</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TimeSpan Elapsed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeSpan(GetElapsedDateTimeTicks()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ElapsedMilliseconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetElapsedDateTimeTicks() / TicksPerMillisecond; } }</code> </pre><br></div></div><br><h4>  What is wrong with using Stopwatch? </h4><br>  A note to this class with MSDN says: on a multiprocessor computer, it does not matter which of the processors is running.  However, due to errors in the BIOS or the abstracted hardware layer (HAL), you can get different results of calculating the time on different processors. <br><br>  In order to avoid this, the if (elapsed &lt;0) condition is in the Stop method. <br><br>  I found a lot of <a href="http://devdoc.web-ide.ru/index.php/content/view/queryPerformanceCounter.htm">articles</a> whose <a href="http://www.virtualdub.org/blog/pivot/entry.php%3Fid%3D106">authors</a> are faced with problems due to incorrect work of HPET. <br><br>  In the absence of HPET, Stopwatch uses DateTime bars, so its advantage over explicitly using DateTime is lost.  In addition, you need to take into account the time for method calls and checks performed by Stopwatch, especially if it happens in a loop. <br><br><h4>  Stopwatch in mono </h4><br>  I wondered how the Stopwatch class was implemented in mono, since it‚Äôs not necessary to rely on Windows native functions for working with HPET. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Frequency = <span class="hljs-number"><span class="hljs-number">10000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsHighResolution = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Stopwatch in mono always uses DateTime clocks, and therefore it has no advantages over explicitly using DateTime, except that the code is more readable. <br><br><h4>  Environment.TickCount </h4><br>  It should also be said about the Environment.TickCount property, which returns the time elapsed since the system was booted (in milliseconds). <br><br>  The value of this property is retrieved from the system timer and stored as a signed 32-bit integer.  Therefore, if the system is running continuously, the value of the TickCount property for about 24.9 days will increase, starting with zero and ending with the value Int32.MaxValue, after which it will be reset to the value Int32.MinValue, which is a negative number, and will begin to grow again zero in the next 24.9 days. <br><br>  Using this property corresponds to a call to the GetTickCount () system function, which is very fast, since it simply returns the value of the corresponding counter.  However, its accuracy is low (10 milliseconds), since the interrupts generated by the real-time clock of the computer are used to increase the counter. <br><br><h4>  Conclusion </h4><br>  The Windows operating system contains many timers (functions that allow to measure time intervals).  Some of them are accurate, but not fast (timeGetTime), others are fast, but not accurate (GetTickCount, GetSystemTime), and still others, according to Microsoft, are fast and accurate.  The latter include the HPET timer and functions that allow it to work with it: QueryPerformanceFrequency, QueryPerformanceCounter. <br><br>  The Stopwatch class is actually a managed wrapper over HPET.  The use of this class has both advantages (more accurate measurement of time intervals) and disadvantages (errors in the BIOS, HAL can lead to incorrect results), and in the absence of HPET, its advantages are completely lost. <br><br>  To use or not to use the Stopwatch class is up to you.  However, it seems to me that the advantages of this class are still more than disadvantages. </div><p>Source: <a href="https://habr.com/ru/post/226279/">https://habr.com/ru/post/226279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226263/index.html">CAELinux: Linux distribution for engineers</a></li>
<li><a href="../226267/index.html">Father's Day Gadget Discounts on Amazon</a></li>
<li><a href="../226269/index.html">Smooth transition to distributed Internet?</a></li>
<li><a href="../226275/index.html">Manufacturers reduce the cost of SSD configuration after launching the model on the market</a></li>
<li><a href="../226277/index.html">How to line up getting feedback if you have points from here to Yuzhno-Sakhalinsk</a></li>
<li><a href="../226289/index.html">Sample web performance</a></li>
<li><a href="../226291/index.html">My Kama holidays: as governor, Perm citizens and Skolkovo gathered to digitize their homeland</a></li>
<li><a href="../226293/index.html">Several useful features for the developer under Squarespace</a></li>
<li><a href="../226295/index.html">How to analyze skateboarding using PVDF film</a></li>
<li><a href="../226297/index.html">Navigation Editor - a new tool in Android Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>