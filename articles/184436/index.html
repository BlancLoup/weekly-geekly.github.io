<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Useful multithreading idioms C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction  This article is a continuation of a series of articles: Using the Singleton Pattern [1] , Singleton and Object Lifetime [2] , Dependency...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Useful multithreading idioms C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/588/bce/949/588bce9490c1398c43db7136213287d2.jpg"><br><h3>  Introduction </h3>  This article is a continuation of a series of articles: <a href="http://habrahabr.ru/post/116577/">Using the Singleton Pattern [1]</a> , <a href="http://habrahabr.ru/post/118368/">Singleton and Object Lifetime [2]</a> , <a href="http://habrahabr.ru/post/118550/">Dependency Relation and Generating Design Patterns [3]</a> , <a href="http://habrahabr.ru/post/150276/">Implementing Singleton in a Multi-threaded Application [4]</a> .  Now I would like to talk about multithreading.  This topic is so voluminous and multifaceted that it is not possible to cover it all.  Here I will focus on some practical things that will make it possible not to think about multithreading at all, or to think about it in an extremely minimal amount.  If to speak more precisely, then think about it only at the design stage, but not implementation.  Those.  questions about how to make correct constructions without headaches automatically will be considered.  This approach, in turn, can significantly reduce the problems caused by race conditions (race condition, see <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25BA%25D0%25B8">Race condition [5]</a> ) and interlocks (deadlock, see <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">Mutual lock [6]</a> ).  This fact in itself is of considerable value.  We will also consider an approach that allows you to have access to an object from several threads at the same time without using any locks and atomic operations! <br><a name="habracut"></a><br>  Most articles are limited to only a certain set of primitives, which, although it is convenient to use, but do not solve common problems that arise in a multithreaded environment.  The following is a list that is commonly used in these types of approaches.  At the same time, I will assume that the reader is already familiar with such approaches, so I will not focus on this. <br><br>  Entities to use: <br><table><tbody><tr><td>  Description of the mutex interface: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// OS specific ... };</span></span></code> </pre> </td></tr><tr><td>  RAII primitive (exception-safe): <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lock</span></span></span><span class="hljs-class"> {</span></span> Lock(Mutex&amp; mutex_) : mutex(mutex_) { mutex.lock(); } ~Lock() { mutex.unlock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Mutex&amp; mutex; };</code> </pre></td></tr><tr><td>  Class for bullying as a simple example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> Mutex m; };</code> </pre></td></tr></tbody></table>  Examples of using: <br><table><tbody><tr><td>  Example 1. Primitive approach: C-style <br><pre> <code class="cpp hljs">A a; amlock(); a.data = <span class="hljs-number"><span class="hljs-number">10</span></span>; amunlock();</code> </pre></td></tr><tr><td>  Example 2. Advanced approach: RAII-style <br><pre> <code class="cpp hljs">A a; { <span class="hljs-function"><span class="hljs-function">Lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(am)</span></span></span></span>; a.data = <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre></td></tr><tr><td>  Example 3. Almost ideal: lock encapsulation <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data_)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m)</span></span></span></span>; data = data_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> Mutex m; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data; }; B b; b.setData(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = b.getData();</code> </pre></td></tr></tbody></table>  It is worth noting that the latter is rarely seen in articles about multithreading, which is a very sad fact: <a href="http://habrahabr.ru/blogs/cpp/72929/">multithreading, general data and mutexes [9]</a> , <a href="http://habrahabr.ru/post/141744/">Cross-platform multithreaded applications [10]</a> , <a href="http://habrahabr.ru/post/182626/">Threads, locks and condition variables in C ++ 11 (Part 2) [11]</a> .  This article will address interesting questions that will help to significantly simplify working with multithreaded primitives (see <a href="http://habrahabr.ru/post/182610/">Threads, locks and conditional variables in C ++ 11 (Part 1) [12]</a> , <a href="http://habrahabr.ru/company/nordavind/blog/176541/">Two simple rules for preventing mutual locks on mutexes [13]</a> ).  In some ways, this article will be a development of ideas taken from the <a href="http://www.drdobbs.com/cpp/enforcing-correct-mutex-usage-with-synch/225200269">Enforcing Correct Mutex Usage with Synchronized Values ‚Äã‚Äã[14]</a> .  However, the ideas and implementation methods below were developed independently of the article. <br><br><h3>  Invariant </h3>  We begin the consideration of multithreaded questions, oddly enough, with the verification of the object invariant.  However, the developed mechanism for the invariant will be used in the future. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For those who are not familiar with the concept of "invariant", this paragraph is devoted.  The rest can safely skip it and go straight to the implementation.  So, in the PLO, we work, oddly enough, with objects.  Each object has its own state, which when calling non-constant functions changes it.  So, as a rule, for each class there is a certain invariant that must be satisfied with each change of state.  For example, if an object is a counter of elements, then it is obvious that for any moment of program execution time the value of this counter should not be negative, i.e.  in this case, the invariant is a non-negative counter value.  Thus, the preservation of the invariant gives some guarantee that the state of the object is consistent. <br><br>  Imagine that our class has an <code>isValid</code> method that returns <code>true</code> if the invariant is saved, and <code>false</code> if the invariant is broken.  Consider the following ‚Äúnon-negative‚Äù counter: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> {</span></span> Counter() : count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newCount)</span></span></span><span class="hljs-function"> </span></span>{ count = newCount; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++ count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ -- count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; };</code> </pre><br>  Using: <br><pre> <code class="cpp hljs">Counter c; c.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>); assert(c.isValid()); <span class="hljs-comment"><span class="hljs-comment">//  true c.set(-3); assert(c.isValid()); //  false   assert</span></span></code> </pre><br>  Now I want to somehow automate the invariant check, so as not to call the <code>isValid</code> method after each change of the value.  The obvious way to do this is to include this call in the <code>set</code> method.  However, in the case of the presence of a large number of non-constant class methods, it is necessary to insert this check inside each such method.  And you want to achieve automaticity, to write less, and get more.  So let's get started. <br><br>  Here we will use the tools developed in previous cycles of articles: <a href="http://habrahabr.ru/post/116577/">Singleton pattern usage [1]</a> , <a href="http://habrahabr.ru/post/118368/">Singleton and object lifetime [2]</a> , <a href="http://habrahabr.ru/post/118550/">Dependency handling and generating design patterns [3]</a> , <a href="http://habrahabr.ru/post/150276/">Singleton implementation in multi-threaded application [4]</a> .  Below is a reference for implementation that will be parted: <br><div class="spoiler">  <b class="spoiler_title">An.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> AN_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AN_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;stdexcept&gt; #include &lt;string&gt; //  , . [1] #define PROTO_IFACE(D_iface, D_an) \ template&lt;&gt; void anFill&lt;D_iface&gt;(An&lt;D_iface&gt;&amp; D_an) #define DECLARE_IMPL(D_iface) \ PROTO_IFACE(D_iface, a); #define BIND_TO_IMPL(D_iface, D_impl) \ PROTO_IFACE(D_iface, a) { a.create&lt;D_impl&gt;(); } #define BIND_TO_SELF(D_impl) \ BIND_TO_IMPL(D_impl, D_impl) //  ,   DIP - dependency inversion principle template&lt;typename T&gt; struct An { template&lt;typename U&gt; friend struct An; An() {} template&lt;typename U&gt; explicit An(const An&lt;U&gt;&amp; a) : data(a.data) {} template&lt;typename U&gt; explicit An(An&lt;U&gt;&amp;&amp; a) : data(std::move(a.data)) {} T* operator-&gt;() { return get0(); } const T* operator-&gt;() const { return get0(); } bool isEmpty() const { return !data; } void clear() { data.reset(); } void init() { if (!data) reinit(); } void reinit() { anFill(*this); } T&amp; create() { return create&lt;T&gt;(); } template&lt;typename U&gt; U&amp; create() { U* u = new U; data.reset(u); return *u; } private: //   //       //     anFill, //      //    T T* get0() const { //        const_cast&lt;An*&gt;(this)-&gt;init(); return data.get(); } std::shared_ptr&lt;T&gt; data; }; //  , . [1] //     //  ,    //     , //   . . [3] template&lt;typename T&gt; void anFill(An&lt;T&gt;&amp; a) { throw std::runtime_error(std::string("Cannot find implementation for interface: ") + typeid(T).name()); } #endif</span></span></span></span></code> </pre></div></div><br>  In order to be able to check consistency, modify access to the object (private method <code>get0</code> ) as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T* get0() const { const_cast&lt;An*&gt;(this)-&gt;init(); assert(data-&gt;isValid()); //  assert return data.get(); } // ... };</span></span></code> </pre><br>  All is well, check is in progress.  But the trouble is: it happens not after a change, but before.  Thus, an object can be in a non-consistent state, and only the next call will do its job: <br><br><pre> <code class="cpp hljs">c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  assert   c-&gt;set(1); //     ,    !</span></span></code> </pre><br>  It would be desirable, that check happened after change, but not before.  For this, we will use a proxy object, in the destructor of which the necessary check will occur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... struct Access { Access(T&amp; ref_) : ref(ref_) {} ~Access() { assert(ref.isValid()); } T* operator-&gt;() { return &amp;ref; } private: T&amp; ref; }; // ,  ( , ..     ): Access operator-&gt;() { return *get0(); } // ... };</span></span></code> </pre><br>  Using: <br><pre> <code class="cpp hljs">An&lt;Counter&gt; c; c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  assert   c-&gt;set(1);</span></span></code> </pre><br>  What was required. <br><br><h3>  Smart mutex </h3>  We now turn to our multithreaded problems.  We write a new implementation of the mutex and call it ‚Äúsmart‚Äù by analogy with a smart pointer.  The idea of ‚Äã‚Äãa smart mutext is that it takes on all the ‚Äúdirty‚Äù work on working with an object, and we only have the most delicious part. <br><br>  To make it, we need a ‚Äúregular‚Äù mutex (just as a smart pointer requires a regular pointer): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// noncopyable struct Mutex { //    void lock(); void unlock(); private: // ... };</span></span></code> </pre><br>  Now we will improve the practices used earlier when checking the invariant.  For this, we will use not only the destructor of the proxy class, but also the constructor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnLock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... template&lt;typename U&gt; struct Access { //     Access(const An&amp; ref_) : ref(ref_) { ref.mutex-&gt;lock(); } //      ~Access() { ref.mutex-&gt;unlock(); } U* operator-&gt;() const { return ref.get0(); } private: const An&amp; ref; }; //       Access&lt;T&gt; operator-&gt;() { return *this; } Access&lt;const T&gt; operator-&gt;() const { return *this; } //    template&lt;typename U&gt; U&amp; create() { U* u = new U; data.reset(u); mutex.reset(new Mutex); return *u; } private: // ... std::shared_ptr&lt;T&gt; data; std::shared_ptr&lt;Mutex&gt; mutex; };</span></span></code> </pre><br>  Using: <br><pre> <code class="cpp hljs">AnLock&lt;Counter&gt; c; c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   std::cout &lt;&lt; "Extracted value: " &lt;&lt; c-&gt;get() &lt;&lt; std::endl;</span></span></code> </pre><br>  It should be noted that when using a constant link, changing the value will result in a compilation error (as opposed to directly using <code>shared_ptr</code> ): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnLock&lt;Counter&gt;&amp; cc = c; cc-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br>  Consider what we did.  Adding screen output for the <code>Counter</code> and <code>Mutex</code> class methods, we get the following screen output when the value changes: <br><blockquote><pre> Mutex :: lock
 Counter :: set: 2
 Mutex :: unlock
</pre></blockquote><br>  Sequence of actions at display: <br><blockquote><pre> Mutex :: lock
 Counter :: get: 2
 Extracted value: 2
 Mutex :: unlock
</pre></blockquote><br>  The convenience is obvious: instead of explicitly calling a mutex, we simply work with the object as if there is no mutex, and everything that is needed is going on inside. <br><br>  You can ask: what to do if I need, for example, to call <code>inc</code> 2 times, and do it atomically?  No problems!  First we <code>AnLock</code> couple <code>typedef</code> to our <code>AnLock</code> class for convenience: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnLock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... typedef Access&lt;T&gt; WAccess; //    typedef Access&lt;const T&gt; RAccess; //    // ... };</span></span></code> </pre><br>  And then we use the following construction: <br><pre> <code class="cpp hljs">{ AnLock&lt;Counter&gt;::WAccess a = c; a-&gt;inc(); a-&gt;inc(); }</code> </pre><br>  Which, in turn, gives the following conclusion: <br><blockquote><pre> Mutex :: lock
 Counter :: inc: 1
 Counter :: inc: 2
 Mutex :: unlock
</pre></blockquote><br>  Something like a transaction, is not it? <br><br><h3>  Smart RW Mutex </h3>  So, now we can try to implement a somewhat more complex construction called read-write mutex (see <a href="http://en.wikipedia.org/wiki/Readers%25E2%2580%2593writer_lock">Readers ‚Äì writer lock [7]</a> ).  The essence of use is quite simple: to allow the ability to read object data from multiple threads, while simultaneous reading and writing or writing and writing should be prohibited. <br><br>  Suppose we already have an implementation of <code>RWMutex</code> with this interface: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// noncopyable struct RWMutex { //    //   void rlock(); void runlock(); //   void wlock(); void wunlock(); private: // ... };</span></span></code> </pre><br>  It would seem that all that needs to be done is to slightly change the implementation so that our proxy types <code>RAccess</code> and <code>WAccess</code> use different functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnRWLock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... //    struct RAccess { RAccess(const AnRWLock&amp; ref_) : ref(ref_) { ref.mutex-&gt;rlock(); } ~RAccess() { ref.mutex-&gt;runlock(); } const T* operator-&gt;() const { return ref.get0(); } private: const AnRWLock&amp; ref; }; //    struct WAccess { WAccess(const AnRWLock&amp; ref_) : ref(ref_) { ref.mutex-&gt;wlock(); } ~WAccess() { ref.mutex-&gt;wunlock(); } T* operator-&gt;() const { return ref.get0(); } private: const AnRWLock&amp; ref; }; WAccess operator-&gt;() { return *this; } RAccess operator-&gt;() const { return *this; } // ... //    template&lt;typename U&gt; U&amp; create() { U* u = new U; data.reset(u); mutex.reset(new RWMutex); return *u; } private: // ... std::shared_ptr&lt;T&gt; data; std::shared_ptr&lt;RWMutex&gt; mutex; };</span></span></code> </pre><br>  Using: <br><pre> <code class="cpp hljs">AnRWLock&lt;Counter&gt; c; c-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Result: <br><blockquote><pre> RWMutex :: wlock
 Counter :: set: 2
 RWMutex :: wunlock
</pre></blockquote><br>  So far so good!  But the following code: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Extracted value: "</span></span> &lt;&lt; c-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Gives: <br><blockquote><pre> RWMutex :: wlock
 Counter :: get: 2
 Extracted value: 2
 RWMutex :: wunlock
</pre></blockquote><br>  For some, this will not come as a surprise, and for the rest of it I will explain why it does not work here as expected.  After all, we used the constant method, so the idea was to use the constant <code>operator-&gt;</code> method.  However, the compiler does not think so.  And this is due to the fact that operations are applied sequentially: first, an operation <code>-&gt;</code> applied <code>-&gt;</code> to a non-constant object, and then the constant method <code>Counter::get</code> is called, but the train has left, because  non-constant <code>operator-&gt;</code> has already been called. <br><br>  As a trivial solution, you can offer a variant with type conversion to a constant one before accessing the object: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnRWLock&lt;Counter&gt;&amp; cc = c; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Extracted value: "</span></span> &lt;&lt; cc-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  With the result: <br><blockquote><pre> RWMutex :: rlock
 Counter :: get: 2
 Extracted value: 2
 RWMutex :: runlock
</pre></blockquote><br>  But this solution looks, to put it mildly, not very attractive.  I would like to write simply and briefly, and not to use bulky constructions with each reference to constant methods. <br><br>  To solve this problem, we introduce a new long arrow <code>---&gt;</code> operator that would write to the object, i.e.  access to non-constant methods, and the usual (short) arrow <code>-&gt;</code> leave for reading.  The reasons for using a short arrow for reading and long for writing, and not vice versa, are as follows: <br><ol><li>  <b>Visual</b> .  Immediately see where the operation is used. </li><li>  <b>Semantic</b> .  Reading is like a superficial use of an object: I touched and let go.  And the record is a deeper operation, a change, so to speak, of the entrails, therefore the arrow is longer. </li><li>  <b>Pragmatic</b> .  When replacing a regular mutex with an RW mutex, you just need to correct the compilation errors, replacing the short arrow with the long one in these places, and everything will work in the most optimal way. </li></ol><br>  Here, probably, the attentive reader wondered: where can we get the same weed as the author of the article?  After all <br><img src="https://habrastorage.org/storage2/e03/3dd/f17/e033ddf17a663560cde00f669486f5dc.jpg"><br><br>  Let's look at the implementation: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  , : WAccess operator--(int) { return *this; } //  , : RAccess operator-&gt;() const { return *this; }</span></span></code> </pre><br>  Using: <br><pre> <code class="cpp hljs">AnRWLock&lt;Counter&gt; c; <span class="hljs-comment"><span class="hljs-comment">//   : c-&gt;set(2) c---&gt;set(2);</span></span></code> </pre><br>  Sequencing: <br><blockquote><pre> RWMutex :: wlock
 Counter :: set: 2
 RWMutex :: wunlock
</pre></blockquote><br>  Everything is as before, except for the use of a long arrow.  Look further: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Extracted value: "</span></span> &lt;&lt; c-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><blockquote><pre> RWMutex :: rlock
 Counter :: get: 2
 Extracted value: 2
 RWMutex :: runlock
</pre></blockquote><br>  In my opinion, the use of a long arrow for a write operation is fully justified: our problem solves this, and in a very elegant way. <br><br><div class="spoiler">  <b class="spoiler_title">If the reader does not quite understand how it works</b> <div class="spoiler_text">  If the reader does not quite understand how it works, then I will give the following equivalent code for using the ‚Äúlong‚Äù arrow as a hint: <br><pre> <code class="cpp hljs">(c--)-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre></div></div><br><h3>  Copy-on-write </h3>  Next, consider the following interesting and useful idiom: copy-on-write ( <abbr title="Copy-on-write: copy on write">COW</abbr> ), or <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BF%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B8">Copy on write [8]</a> .  As the name implies, the basic idea is that immediately before changing the data of a certain object, it first copies to a new place in memory, and only then changes to the new address. <br><br>  Although the <abbr title="Copy-on-write: copy on write">COW</abbr> approach is not directly related to multithreading, however, using this approach in conjunction with others greatly improves usability and adds a number of irreplaceable elements.  That is why the implementation of <abbr title="Copy-on-write: copy on write">COW is</abbr> given below.  Moreover, the developed tricks are easily and naturally transferred to the implementation of this idiom. <br><br>  So, as with the RW mutex, we need to distinguish read operations from write operations.  When reading anything special should not happen, but when writing, if the object has more than one owner, then this object must first be copied. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnCow</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... //      T* operator--(int) { return getW0(); } //      const T* operator-&gt;() const { return getR0(); } //   (   !) void clone() { data.reset(new T(*data)); } // ... private: T* getR0() const { const_cast&lt;An*&gt;(this)-&gt;init(); return data.get(); } T* getW0() { init(); //    ‚Äú‚Äù  if (!data.unique()) clone(); return data.get(); }</span></span></code> </pre><br>  It should be noted that the use of polymorphic objects is not considered here (i.e., we never create heirs of the template class <code>T</code> ), since  this is beyond the scope of this article.  In the next article I will try to give a detailed solution to this issue, while the implementation will be quite unusual. <br><br>  We proceed to use: <br><table><tbody><tr><th>  Code </th><th>  Console output </th></tr><tr><td><pre> <code class="cpp hljs">AnCow&lt;Counter&gt; c; c---&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre></td><td><blockquote><pre> Counter :: set: 2
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Extracted value: "</span></span> &lt;&lt; c-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre></td><td><blockquote><pre> Counter :: get: 2
 Extracted value: 2
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">AnCow&lt;Counter&gt; d = c; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Extracted value: "</span></span> &lt;&lt; d-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre></td><td><blockquote><pre> Counter :: get: 2
 Extracted value: 2
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">d---&gt;inc();</code> </pre></td><td><blockquote><pre> Counter copy ctor: 2
 Counter :: inc: 3
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">c---&gt;dec();</code> </pre></td><td><blockquote><pre> Counter :: dec: 1
</pre></blockquote></td></tr></tbody></table>  At the very beginning, nothing interesting happens: setting the value and displaying the same value on the screen is <code>2</code> .  Next, the value of the new variable is assigned, and the object data is used the same.  When outputting <code>d-&gt;get()</code> , the same object is used. <br><br>  Then, when <code>d---&gt;inc()</code> is called, the most interesting thing happens: first the object is copied, and then the resulting value is increased to 3.  When you call <code>c---&gt;dec()</code> later, copying does not occur, because  the owner is now only one and we have two different copies of the object.  I think this example clearly illustrates the work of <abbr title="Copy-on-write: copy on write">COW</abbr> . <br><br><h3>  Key-value storage in memory </h3>  Finally, we consider some variations of the implementation of key-value storage in memory when working in a multi-threaded environment using the developed techniques. <br><br>  We will use the following implementation for our repositories: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_key, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_value&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueStorageImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     void set(T_key key, T_value value) { storage.emplace(std::move(key), std::move(value)); } //   T_value get(const T_key&amp; key) const { return storage.at(key); } //   void del(const T_key&amp; key) { storage.erase(key); } private: std::unordered_map&lt;T_key, T_value&gt; storage; };</span></span></code> </pre><br>  Let's tie the repository to a singleton to simplify further manipulations (see <a href="http://habrahabr.ru/post/116577/">Using the Singleton Pattern [1]</a> ): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_key, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_value&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anFill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AnRWLock&lt;KeyValueStorageImpl&lt;T_key, T_value&gt;&gt;&amp; D_an)</span></span></span><span class="hljs-function"> </span></span>{ D_an = anSingleRWLock&lt;KeyValueStorageImpl&lt;T_key, T_value&gt;&gt;(); }</code> </pre><br>  Thus, when creating an <code>AnRWLock&lt;KeyValueStorageImpl&lt;T,V&gt;&gt;</code> instance, the object retrieved from the singleton will be ‚Äúflooded‚Äù, i.e.  <code>AnRWLock&lt;KeyValueStorageImpl&lt;T,V&gt;&gt;</code> will always point to a single instance. <br><br>  For reference, I will give the used infrastructure: <br><div class="spoiler">  <b class="spoiler_title">AnRWLock.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> AN_RWLOCK_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AN_RWLOCK_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;stdexcept&gt; #include &lt;string&gt; #include "Mutex.hpp" // fill #define PROTO_IFACE_RWLOCK(D_iface, D_an) \ template&lt;&gt; void anFill&lt;D_iface&gt;(AnRWLock&lt;D_iface&gt;&amp; D_an) #define DECLARE_IMPL_RWLOCK(D_iface) \ PROTO_IFACE_RWLOCK(D_iface, a); #define BIND_TO_IMPL_RWLOCK(D_iface, D_impl) \ PROTO_IFACE_RWLOCK(D_iface, a) { a.create&lt;D_impl&gt;(); } #define BIND_TO_SELF_RWLOCK(D_impl) \ BIND_TO_IMPL_RWLOCK(D_impl, D_impl) #define BIND_TO_IMPL_SINGLE_RWLOCK(D_iface, D_impl) \ PROTO_IFACE_RWLOCK(D_iface, a) { a = anSingleRWLock&lt;D_impl&gt;(); } #define BIND_TO_SELF_SINGLE_RWLOCK(D_impl) \ BIND_TO_IMPL_SINGLE_RWLOCK(D_impl, D_impl) template&lt;typename T&gt; struct AnRWLock { template&lt;typename U&gt; friend struct AnRWLock; struct RAccess { RAccess(const AnRWLock&amp; ref_) : ref(ref_) { ref.mutex-&gt;rlock(); } ~RAccess() { ref.mutex-&gt;runlock(); } const T* operator-&gt;() const { return ref.get0(); } private: const AnRWLock&amp; ref; }; struct WAccess { WAccess(const AnRWLock&amp; ref_) : ref(ref_) { ref.mutex-&gt;wlock(); } ~WAccess() { ref.mutex-&gt;wunlock(); } T* operator-&gt;() const { return ref.get0(); } private: const AnRWLock&amp; ref; }; AnRWLock() {} template&lt;typename U&gt; explicit AnRWLock(const AnRWLock&lt;U&gt;&amp; a) : data(a.data) {} template&lt;typename U&gt; explicit AnRWLock(AnRWLock&lt;U&gt;&amp;&amp; a) : data(std::move(a.data)) {} WAccess operator--(int) { return *this; } RAccess operator-&gt;() const { return *this; } bool isEmpty() const { return !data; } void clear() { data.reset(); } void init() { if (!data) reinit(); } void reinit() { anFill(*this); } T&amp; create() { return create&lt;T&gt;(); } template&lt;typename U&gt; U&amp; create() { U* u = new U; data.reset(u); mutex.reset(new RWMutex); return *u; } private: T* get0() const { const_cast&lt;AnRWLock*&gt;(this)-&gt;init(); return data.get(); } std::shared_ptr&lt;T&gt; data; std::shared_ptr&lt;RWMutex&gt; mutex; }; template&lt;typename T&gt; void anFill(AnRWLock&lt;T&gt;&amp; a) { throw std::runtime_error(std::string("Cannot find implementation for interface: ") + typeid(T).name()); } template&lt;typename T&gt; struct AnRWLockAutoCreate : AnRWLock&lt;T&gt; { AnRWLockAutoCreate() { this-&gt;create(); } }; template&lt;typename T&gt; AnRWLock&lt;T&gt; anSingleRWLock() { return single&lt;AnRWLockAutoCreate&lt;T&gt;&gt;(); } #endif</span></span></span></span></code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">AnCow.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> AN_COW_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AN_COW_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;stdexcept&gt; #include &lt;string&gt; // fill #define PROTO_IFACE_COW(D_iface, D_an) \ template&lt;&gt; void anFill&lt;D_iface&gt;(AnCow&lt;D_iface&gt;&amp; D_an) #define DECLARE_IMPL_COW(D_iface) \ PROTO_IFACE_COW(D_iface, a); #define BIND_TO_IMPL_COW(D_iface, D_impl) \ PROTO_IFACE_COW(D_iface, a) { a.create&lt;D_impl&gt;(); } #define BIND_TO_SELF_COW(D_impl) \ BIND_TO_IMPL_COW(D_impl, D_impl) #define BIND_TO_IMPL_SINGLE_COW(D_iface, D_impl) \ PROTO_IFACE_COW(D_iface, a) { a = anSingleCow&lt;D_impl&gt;(); } #define BIND_TO_SELF_SINGLE_COW(D_impl) \ BIND_TO_IMPL_SINGLE_COW(D_impl, D_impl) template&lt;typename T&gt; struct AnCow { template&lt;typename U&gt; friend struct AnCow; AnCow() {} template&lt;typename U&gt; explicit AnCow(const AnCow&lt;U&gt;&amp; a) : data(a.data) {} template&lt;typename U&gt; explicit AnCow(AnCow&lt;U&gt;&amp;&amp; a) : data(std::move(a.data)) {} T* operator--(int) { return getW0(); } const T* operator-&gt;() const { return getR0(); } bool isEmpty() const { return !data; } void clear() { data.reset(); } void init() { if (!data) reinit(); } void reinit() { anFill(*this); } T&amp; create() { return create&lt;T&gt;(); } template&lt;typename U&gt; U&amp; create() { U* u = new U; data.reset(u); return *u; } // TODO: update clone functionality on creating derived instances void clone() { data.reset(new T(*data)); } private: T* getR0() const { const_cast&lt;AnCow*&gt;(this)-&gt;init(); return data.get(); } T* getW0() { init(); if (!data.unique()) clone(); return data.get(); } std::shared_ptr&lt;T&gt; data; }; template&lt;typename T&gt; void anFill(AnCow&lt;T&gt;&amp; a) { throw std::runtime_error(std::string("Cannot find implementation for interface: ") + typeid(T).name()); } template&lt;typename T&gt; struct AnCowAutoCreate : AnCow&lt;T&gt; { AnCowAutoCreate() { this-&gt;create(); } }; template&lt;typename T&gt; AnCow&lt;T&gt; anSingleCow() { return single&lt;AnCowAutoCreate&lt;T&gt;&gt;(); } #endif</span></span></span></span></code> </pre></div></div><br>  Further, various ways of using this repository, from simple to complex, will be discussed. <br><br><h4>  Example 1. The simplest use. </h4>  We will directly use the storage without additional frills: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        template&lt;typename T_key, typename T_value&gt; struct KeyValueStorage : AnRWLock&lt;KeyValueStorageImpl&lt;T_key, T_value&gt;&gt; { typedef T_value ValueType; };</span></span></code> </pre><br>  Usage example: <br><table><tbody><tr><th>  Code </th><th>  Console output </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -  //  -  KeyValueStorage&lt;std::string, int&gt; kv; kv---&gt;set("Peter", 28);</span></span></code> </pre></td><td><blockquote><pre> RWMutex :: wlock
 Key-value: inserting key: Peter
 RWMutex :: wunlock
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">kv---&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-string"><span class="hljs-string">"Nick"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre></td><td><blockquote><pre> RWMutex :: wlock
 Key-value: inserting key: Nick
 RWMutex :: wunlock
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Peter age: "</span></span> &lt;&lt; kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre></td><td><blockquote><pre> RWMutex :: rlock
 Key-value: extracting key: Peter
 Peter age: 28
 RWMutex :: runlock
</pre></blockquote></td></tr></tbody></table>  In the first line, we create a <code>kv</code> object, into which a single copy of the repository is poured, using a singleton (see the <code>anFill</code> function).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, the entries Peter and Nick are added, and then the age of Peter is displayed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think it‚Äôs clear from the output that write-lock is automatically taken when writing, and read-lock is taken automatically when reading.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example 2. Nested RW Mutexes. </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider a slightly more complex example. </font><font style="vertical-align: inherit;">Suppose now that we want to have named counters </font></font><code>Counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use them from several threads. </font><font style="vertical-align: inherit;">No problems:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,        AnRWLock template&lt;typename T_key, typename T_value&gt; struct KeyValueStorageRW : KeyValueStorage&lt;T_key, AnRWLock&lt;T_value&gt;&gt; { }; //      typedef KeyValueStorageRW&lt;std::string, Counter&gt; KVRWType;</span></span></code> </pre><br>  Usage example: <br><table><tbody><tr><th>  Code </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output </font></font></th></tr><tr><td><pre> <code class="cpp hljs">KVRWType kv; <span class="hljs-comment"><span class="hljs-comment">// AnRWLockAutoCreate -    kv---&gt;set("users", AnRWLockAutoCreate&lt;Counter&gt;());</span></span></code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: inserting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">kv---&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-string"><span class="hljs-string">"sessions"</span></span>, AnRWLockAutoCreate&lt;Counter&gt;());</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: inserting key: sessions</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"users"</span></span>)---&gt;inc();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: inc: 1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"sessions"</span></span>)---&gt;inc();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: sessions</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: inc: 1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"sessions"</span></span>)---&gt;dec();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: sessions</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: dec: 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As they say, voila! </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example 3. Access optimization. </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although I would like to talk about some optimizations in the next article, I will describe here, in my opinion, quite an important optimization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below are the different uses for comparison.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Option 1: normal </font></font></h5><table><tbody><tr><th>  Code </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output </font></font></th></tr><tr><td><pre> <code class="cpp hljs">kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"users"</span></span>)---&gt;inc();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: inc: 2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr></tbody></table><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Option 2: optimal </font></font></h5><table><tbody><tr><th>  Code </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output </font></font></th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> users = kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"users"</span></span>);</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">users---&gt;inc();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: inc: 3</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font>
</pre></blockquote></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second example, you can see that the second record mutex for the object </font></font><code>Counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is taken only after the first one, which controls the key-value storage, is released. </font><font style="vertical-align: inherit;">This implementation provides a more optimal use of mutexes, although we end up with a longer record. </font><font style="vertical-align: inherit;">This optimization is worth keeping in mind when using nested mutexes.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example 4. Support atomic changes. </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose that we need to atomically increase one of the counters by 100, for example, ‚Äúusers‚Äù. </font><font style="vertical-align: inherit;">Of course, for this you can call for 100 times the operation </font></font><code>inc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but you can do this:</font></font><br><br><table><tbody><tr><th>  Code </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output </font></font></th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"users"</span></span>);</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">KVRWType::ValueType::WAccess cw = c; cw-&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(cw-&gt;get() + <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: get: 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: set: 104</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font>
</pre></blockquote></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that when used </font></font><code>WAccess</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">further, all operations come with the usual ‚Äúshort‚Äù arrow, since </font><font style="vertical-align: inherit;">access to the object to write already received. </font><font style="vertical-align: inherit;">Also pay attention to the fact that the operations </font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are under the same mutex, which is what we wanted to achieve. </font><font style="vertical-align: inherit;">This is very similar to the fact that we seem to have opened a transaction when acting on an object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same trick can be used in conjunction with the optimization described above to access the counters directly.</font></font><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Option 1: normal </font></font></h5><table><tbody><tr><th>  Code </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output </font></font></th></tr><tr><td><pre> <code class="cpp hljs">kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"users"</span></span>)---&gt;inc();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: inc: 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">kv-&gt;get(<span class="hljs-string"><span class="hljs-string">"sessions"</span></span>)---&gt;dec();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: sessions</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: dec: -1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr></tbody></table><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Option 2: optimal </font></font></h5><table><tbody><tr><th>  Code </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Console output </font></font></th></tr><tr><td><pre> <code class="cpp hljs">AnRWLock&lt;Counter&gt; c1, c2; { KVRWType::RAccess r = kv; c1 = r-&gt;get(<span class="hljs-string"><span class="hljs-string">"users"</span></span>); c2 = r-&gt;get(<span class="hljs-string"><span class="hljs-string">"sessions"</span></span>); }</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: rlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: users</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key-value: extracting key: sessions</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: runlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">c1---&gt;inc();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: inc: 5</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font>
</pre></blockquote></td></tr><tr><td><pre> <code class="cpp hljs">c2---&gt;dec();</code> </pre></td><td><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RWMutex :: wlock</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Counter :: dec: -2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RWMutex :: wunlock</font></font><font></font>
</pre></blockquote></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Again, in the second example, mutexes are used more optimally: read lock is taken exactly once, write lock is taken outside of read-lock, which gives greater performance with concurrent access. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example 5. COW. </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppose we have employees with the following information: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> salary; <span class="hljs-comment"><span class="hljs-comment">//    ... };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our task: to conduct various operations on selected users, for example, to calculate the balance sheet. </font><font style="vertical-align: inherit;">The situation is complicated by the fact that the operation is long. </font><font style="vertical-align: inherit;">At the same time, when calculating, a change in employee information is unacceptable, since </font><font style="vertical-align: inherit;">different indicators should be consistent, and if any data changes, the balance may not converge. </font><font style="vertical-align: inherit;">At the same time, it would be desirable that during the operation, information about employees could be changed without waiting for the end of long-term operations. </font><font style="vertical-align: inherit;">To implement the calculation, it is necessary to </font></font><abbr title="static state slice"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snapshot the</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data for a certain point in time. </font><font style="vertical-align: inherit;">Of course, the data may become irrelevant, but for balance it is more important to have self-consistent results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how this can be done using </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Preparatory stage:</font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when creating an instance</font></font><code>User</code> <br><pre> <code class="cpp hljs">BIND_TO_SELF_COW(User)</code> </pre></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We declare a new class that can store objects with </font></font><code>AnCow</code> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_key, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_value&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueStorageCow</span></span></span><span class="hljs-class"> :</span></span> AnRWLock&lt;KeyValueStorageImpl&lt;T_key, AnCow&lt;T_value&gt;&gt;&gt; { };</code> </pre></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our storage ad: </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- user id, </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- user</font></font><br><pre> <code class="cpp hljs">KeyValueStorageCow&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, User&gt; kv;</code> </pre></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding information about the user Peter </font></font><br><pre> <code class="cpp hljs">AnCow&lt;User&gt; u; u---&gt;name = <span class="hljs-string"><span class="hljs-string">"Peter"</span></span>; u---&gt;age = <span class="hljs-number"><span class="hljs-number">35</span></span>; u---&gt;salary = <span class="hljs-number"><span class="hljs-number">12345</span></span>; kv---&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, u);</code> </pre></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding information about the user George </font></font><br><pre> <code class="cpp hljs">AnCow&lt;User&gt; u; u---&gt;name = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; u---&gt;age = <span class="hljs-number"><span class="hljs-number">31</span></span>; u---&gt;salary = <span class="hljs-number"><span class="hljs-number">54321</span></span>; kv---&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, u);</code> </pre></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changing employee age information </font></font><br><pre> <code class="cpp hljs">AnCow&lt;User&gt; u = kv-&gt;get(<span class="hljs-number"><span class="hljs-number">2</span></span>); ++ u---&gt;age; kv---&gt;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, u);</code> </pre></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balancing: </font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Getting the right users </font></font><br><pre> <code class="cpp hljs">AnCow&lt;User&gt; u1 = kv-&gt;get(<span class="hljs-number"><span class="hljs-number">1</span></span>); AnCow&lt;User&gt; u2 = kv-&gt;get(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculation of the required parameters. </font><font style="vertical-align: inherit;">All data will be self-consistent and will remain unchanged until the end of operations.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSalary = u1-&gt;salary + u2-&gt;salary; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> averageSalary = totalSalary/<span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> averageAge = (u1-&gt;age + u2-&gt;age)/<span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> averageSalaryPerAge = (u1-&gt;salary/u1-&gt;age + u2-&gt;salary/u2-&gt;age)/<span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, when conducting a lengthy operation, information about users is recorded at the time of its extraction. At any time, it is possible to change employee information, but this will not affect current calculations. And at the next balance sheet, the most recent data will be used. This approach ensures self-consistent calculations with the ability to change data at any time, without waiting for the end of long-term calculations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, one could of course use the copying of all elements before the calculation. However, if there is a sufficiently large amount of information, this will be a rather lengthy operation. Therefore, it is delayed in the indicated approach until it is really necessary to copy the data, i.e. only when used simultaneously in the calculations and changes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analysis and synthesis </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is an analysis of examples. </font><font style="vertical-align: inherit;">The most interesting, above all, is the last example from </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , since there are unexpected surprises.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Detail in </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the sequence of operations of the last example. </font><font style="vertical-align: inherit;">Below is a general scheme when retrieving a value from a container: </font></font><br><img src="https://habrastorage.org/storage2/8f7/a73/cc8/8f7a73cc81e955250418612a498f230c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here </font></font><code>Data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example described above, and </font></font><code>shared_ptr&lt;Data&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is the contents of the object </font></font><code>AnCow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sequence of operations:</font></font><br><table><tbody><tr><th>  N </th><th> <nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operation</font></font></nobr> </th><th>  Description </th></tr><tr><td>  one </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lock storage is done automatically when you call </font></font><code>operator-&gt;</code> </td></tr><tr><td>  2 </td><td>  copy </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy </font></font><code>shared_ptr&lt;Data&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, i.e. </font><font style="vertical-align: inherit;">in fact, there is a simple increase in counters ( </font></font><code>use_count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>weak_count</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside the object </font></font><code>shared_ptr&lt;Data&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></td></tr><tr><td>  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unlock </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unlocking a temporary object destructor storage </font></font></td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After these operations, you can do various actions on the object. </font><font style="vertical-align: inherit;">When reading, no additional action occurs: just take and read the object data directly from the occupied data area. </font><font style="vertical-align: inherit;">Here it is worth mentioning a very unexpected nuance: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reading the data of an object occurs without taking a lock! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an unexpected property that I wanted to emphasize when analyzing </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What happens when writing data to an object? </font><font style="vertical-align: inherit;">We look: </font></font><br><img src="https://habrastorage.org/storage2/1db/511/5fa/1db5115fa816564122ab76a6f00b2d48.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sequence of operations is as follows:</font></font><br><table><tbody><tr><th>  N </th><th> <nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operation</font></font></nobr> </th><th>  Description </th></tr><tr><td>  four </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clone </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Object cloning, the object's copy constructor is called </font></font><code>Data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, i.e. </font><font style="vertical-align: inherit;">copy all its fields to a new memory area. </font><font style="vertical-align: inherit;">After this operation </font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begins to look at the newly created object.</font></font></td></tr><tr><td>  five </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> modify </font></font></td><td>   .    , ..  . </td></tr><tr><td>  6 </td><td> lock </td><td>      . </td></tr><tr><td>  7 </td><td> replace </td><td>    <code>shared_ptr&lt;Data&gt;</code>  ,   5- . </td></tr><tr><td>  eight </td><td> unlock </td><td>   . </td></tr></tbody></table><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in the case of reading, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writing to an object occurs without the participation of locks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , since </font><font style="vertical-align: inherit;">we are the sole owner of the created object. </font><font style="vertical-align: inherit;">In principle, the same scheme of operations can be observed when manipulating an object of a simple type, for example, of a type </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The essential difference is that with </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW,</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data can be used from the same memory area in several threads simultaneously. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that most of the above operations occur automatically, i.e. </font><font style="vertical-align: inherit;">There is no need to perform all operations explicitly.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> COW number optimization </font></font></h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As shown above, when a </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object changes </font><font style="vertical-align: inherit;">, all its fields are copied. This is not a big problem with a small amount of data. But what to do if we have a large number of parameters in the class? In this case, you can use multi-level </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW-</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objects. For example, one could introduce the following class </font></font><code>UserInfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserInfo</span></span></span><span class="hljs-class"> {</span></span> AnCow&lt;AccountingInfo&gt; accounting; AnCow&lt;CommonInfo&gt; common; AnCow&lt;WorkInfo&gt; work; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountingInfo</span></span></span><span class="hljs-class"> {</span></span> AnCow&lt;IncomingInfo&gt; incoming; AnCow&lt;OutcomingInfo&gt; outcoming; AnCow&lt;BalanceInfo&gt; balance; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommonInfo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  .. }; //  ..</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By entering </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objects at each level </font><font style="vertical-align: inherit;">, you can significantly reduce the number of copies. </font><font style="vertical-align: inherit;">At the same time, the copy operation itself will consist only in the atomic increase of the counters. </font><font style="vertical-align: inherit;">And only the change object itself will be copied using the copy constructor. </font><font style="vertical-align: inherit;">It can easily be shown that the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum number of copies is achieved when the number of objects at each level is 3 m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generalized schema </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having considered in more detail the operations with </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , taking into account the nesting, we can now safely proceed to the generalization of the use of the considered idioms. But for this, we first consider the schemes used in the examples. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first example, the nested </font></font><code>AnRWLock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objects were used: The </font></font><br><img src="https://habrastorage.org/storage2/c78/771/780/c78771780b597434b44c9222c41a85aa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key-value storage in the specified example was put in a singleton and wrapped in a ‚Äúsmart‚Äù mutex from above. The values ‚Äã‚Äãwere also wrapped in a ‚Äúsmart‚Äù mutex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following diagram describes an example with </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><img src="https://habrastorage.org/storage2/1d1/ab9/2fa/1d1ab92fa25bb7776f41e8cc0c252315.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the value has been wrapped into an object </font></font><code>AnCow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to implement the </font></font><abbr title="Copy-on-write: copy on write"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COW</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> semantics </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, the generalized scheme can be represented as: </font></font><br><img src="https://habrastorage.org/storage2/a1e/ac0/f75/a1eac0f754b994cb6b049d8f9b770f75.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is clear that the objects </font></font><code>AnLock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>An(RW)Lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interchangeable: you can use one or the other. </font><font style="vertical-align: inherit;">You can also chain repeated several times as showily in the example below: </font></font><br><img src="https://habrastorage.org/storage2/8da/06c/f85/8da06cf85e0f8083e0ba9bf25c1a3cc9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it should be remembered that the semantics of the objects </font></font><code>An(RW)Lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>AnCow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is significantly different:</font></font><br><table><tbody><tr><th>  Property </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smart mutex </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cow </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to object fields </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blocked during read / write </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not blocked </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifying an object in a container </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In-place change </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After the change, you must put the new value back into the container. </font></font></td></tr></tbody></table><h3>  findings </h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the article examined some idioms that increase the efficiency of writing multi-threaded applications. </font><font style="vertical-align: inherit;">It is worth noting the following benefits:</font></font><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There is no need to explicitly use multi-thread primitives, everything happens automagically.</font></font></li><li> <b></b> .            .       ( )    . </li><li> <b></b> .        ,     (race condition)    (deadlock).         .        (fine-grained)      ,        . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a universal approach has become possible due to the fact that in the implementation of </font></font><code>An</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classes, there is full control over the use of stored objects. Therefore, it is possible to add the necessary functionality, automatically calling the necessary methods on the access boundaries. This approach will be significantly deepened and expanded in the next article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above material did not consider the use of polymorphic objects. In particular, the implementation </font></font><code>AnCow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works only with the same template class, since always call the copy constructor for the declared type </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The following article will provide an implementation for a more general case. There will also be a unification of objects and ways to use them, talked about various optimizations, multi-threaded links, and much more.</font></font><br><br><h3>  Literature </h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="http://habrahabr.ru/post/116577/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Singleton pattern usage</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [2] </font></font><a href="http://habrahabr.ru/post/118368/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Singleton and object lifetime</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [3] </font></font><a href="http://habrahabr.ru/post/118550/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Dependency treatment and generating design patterns</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [4] </font></font><a href="http://habrahabr.ru/post/150276/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Singleton implementation in multi-threaded application</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [5] </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25BA%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Race status</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia : interlocking</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [7] </font></font><a href="http://en.wikipedia.org/wiki/Readers%25E2%2580%2593writer_lock"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Readers-writer lock</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BF%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Copy-on-write</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [9] </font></font><a href="http://habrahabr.ru/blogs/cpp/72929/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: threading common data and mutexes</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font></font><a href="http://habrahabr.ru/post/141744/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Cross-platform multithreaded applications</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [11] </font></font><a href="http://habrahabr.ru/post/182626/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: flows lock and conditional variables in C ++ 11 [Part 2]</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] </font></font><a href="http://habrahabr.ru/post/182610/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Flows, locks and condition variables in C ++ 11 [Part 1]</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [13] </font></font><a href="http://habrahabr.ru/company/nordavind/blog/176541/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Two simple rules for preventing deadlocks on mutexes</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [14] </font></font><a href="http://www.drdobbs.com/cpp/enforcing-correct-mutex-usage-with-synch/225200269"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrDobbs: Enforcing Correct Mutex Usage with Synchronized Values</font></font></a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Solution of the problem about the number of copies</font></font></b> <div class="spoiler_text"> ,      <code>n</code> ,   ‚Äî <code>k</code> ,     ‚Äî <code>a</code> .    <code>a = n^k</code> ,  <code>k = ln a/ln n</code> . <s> <code>ln</code>  <code>k = a/n</code> .</s>   <code>= n*k</code> (         <code>n</code> ).  Those.   <code>= n*ln a/ln n</code>   <code>n/ln n</code> , .. <code>a</code> ‚Äî const.    ,   <a href="http://www.wolframalpha.com/input/%3Fi%3Dn%252Fln%2Bn"> <code>n = e</code></a> ,       3. <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally - a poll. </font><font style="vertical-align: inherit;">There are 2 issues on the agenda:</font></font></div><p>Source: <a href="https://habr.com/ru/post/184436/">https://habr.com/ru/post/184436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184422/index.html">Armikrog danger! Will the project on the kickstarter collect the required amount? Collected</a></li>
<li><a href="../184426/index.html">Playstation 4 will work on a modified version of FreeBSD 9.0</a></li>
<li><a href="../184428/index.html">EMET v4 Release</a></li>
<li><a href="../184430/index.html">Real sock_raw'thin</a></li>
<li><a href="../184432/index.html">Print history: matrix, inkjet, laser and LED technology (Part 2)</a></li>
<li><a href="../184442/index.html">Mega-data centers are the pioneers of innovation. Part 2</a></li>
<li><a href="../184444/index.html">Venus or the first 60 kpx from another planet</a></li>
<li><a href="../184446/index.html">A gentle introduction to Coq: data structures and higher order functions</a></li>
<li><a href="../184450/index.html">Passing the Competitive Intelligence Competition on PHDays III</a></li>
<li><a href="../184452/index.html">Munich authorities will hand out Linux disks to residents who use Windows XP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>