<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to the Car Tutorial (Unity3d) part 3 of 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Part 2 

 Before we begin, I want to suggest scripts rewritten in C #. because half of the JS scripts I decided to rewrite them under C # (C ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to the Car Tutorial (Unity3d) part 3 of 3</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/247667/">Part 1</a> <br>  <a href="http://habrahabr.ru/post/248185/">Part 2</a> <br><br>  Before we begin, I want to suggest scripts rewritten in C #.  because half of the JS scripts I decided to rewrite them under C # (C # is more native to me).  <a href="https://drive.google.com/file/d/0B0yoFhs5yYibV1h1eERuR2lTYm8/view%3Fusp%3Dsharing">Download</a> <br><br>  There is also an active ‚Äúdebriefing‚Äù of the project for beginners <a href="http://unity3d.com/learn/tutorials/projects/survival-shooter">‚ÄúProject: Survival shooter‚Äù</a> , video tutorials are presented in the next <a href="https://www.youtube.com/watch%3Fv%3D6_uaeDuzZFs%26list%3DPLaFq8TU0NWUEd5wjaRexgs8E17NrBeD1j">Playlist</a> , <a href="https://www.youtube.com/watch%3Fv%3DD67Wm6Ql9Ik%26list%3DPLaFq8TU0NWUFOdvUURoYnm0ESGm2LdKRw">additional video tutorials for Survival shooter</a> .  I personally thank this channel for their not easy work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ps at the end of this manual there is a video review in which examples show a comparison of two implemented methods of driving a car. <br><br>  So, we will start studying our leadership. <br><br><h1>  Part 3: Under the hood </h1><br>  We have already seen how to build a working machine from a 3D model, scripts and embedded components.  We also learned about public variables and how they can be used to fine tune a car. <br><a name="habracut"></a><br>  Now we will talk about studying the work of the script <b>Car</b> . <br><br>  ‚Ä¢ Double-click the <b>Car.js</b> script to open it in the code editor. <br><br>  At first glance, this script can be a bit intimidating, with more than 500 lines of code and comments and a lot of variables and functions.  Do not despair.  Our script is designed in such a way that we would have relatively small functions with meaningful names that indicate what is being performed in each function.  As well as in the code there are comments that explain a certain part of the code. <br><br>  So we suggest that you take a look at it, starting from the ‚Äúentry points‚Äù of studying the script and following further along the guide.  In this case, these entry points will be the <b>Start ()</b> , <b>Update ()</b> and <b>FixedUpdate ()</b> functions. <br><br>  Each of these ‚Äúcore‚Äù functions causes other functions.  Therefore, when we start with the <b>Start ()</b> function, we will see that the function first called the <b>SetupWheelColliders ()</b> function.  Find this function in code and examine what it does, and then go back to the <b>Start ()</b> function and go to the next <b>SetupCenterOfMass ()</b> function.  By studying this code you will understand how the car works.  In the future, we will consider all these functions.  We will not explain every line of code, but we will examine all the functions in order. <br><br><h1>  What things need to know? </h1><br>  Working in <b>Unity is</b> easy in many ways, thanks to such things: built-in components, editor, D &amp; D capabilities.  Setting up a car is half the job ‚Äî <b>Unity</b> takes care of importing <b>models</b> , <b>collision</b> components <b>(collision)</b> , <b>rendering (rendering)</b> and <b>physics (physics)</b> can be added to an object by clicking on the <b>‚Äúadd the components‚Äù</b> button <b>.</b> <br><br>  Inside our script, we will work mainly on manipulating these components.  Of course, you will stumble upon a multitude of calculations and formulas that we use to determine what happens to a car.  This is the inevitable part that makes games realistic: you have to set some logic, for example by writing scripts when you want to do more than just basic functions.  These formulas and calculations are used in our components. <br><br>  If you see that the code is not at all familiar and you do not know where to start, you can try our approach, which is to focus on the following points, as well as considering how and what works: <br><br>  ‚Ä¢ <b>rigidbody</b> <br>  ‚Ä¢ <b>Wheel Colliders</b> <br>  ‚Ä¢ Calculations and formulas that we make, as well as their order. <br><br>  Think of it like this: <br>  ‚Ä¢ When adding a <b>Rigidbody</b> to our car model, we have a way to control its physical abilities.  We can do this by calculating the forces that move it forward, which slow it down. <br>  ‚Ä¢ When adding <b>wheel colliders (Wheel Colliders),</b> we gain control over where the car collides with the road. <br><br><h1>  Start () - Installation </h1><br>  This is where we do the initialization necessary for the car.  The <b>Start ()</b> function is executed only once, at the beginning of the script, before the <b>Update</b> functions.  Therefore, <b>Start () is</b> often used to set the initial values ‚Äã‚Äãof the required components in the code. <br><br><h3>  SetupWheelColliders () </h3><br>  We have four wheels attached to our car, and we put them in the <b>FrontWheels</b> and <b>RearWheels</b> arrays in the inspector.  In this function, we create real <b>colliders (colliders)</b> , making it possible for the wheels to interact with the surface and the car.  We start with the <b>SetupWheelFrictionCurve ()</b> function <b>.</b> <br><br><h3>  SetupWheelFrictionCurve () </h3><br>  In <b>SetupWheelFrictionCurve (),</b> we simply create a new <b>WheelFrictionCurve</b> and assign it values ‚Äã‚Äãthat we consider appropriate for our car.  <b>WheelFrictionCurve</b> uses <b>WheelColliders</b> to describe the friction properties of tire tires.  If you want to learn the process of creating a car in <b>Unity</b> in more detail, built using <b>WheelColliders</b> , then read the documentation. <br><br><h3>  SetupWheel () </h3><br>  After setting the <b>curve (curve)</b> , we returned to the <b>SetupWheelColliders ()</b> script, now we are ready to create <b>colliders (colliders)</b> and <b>wheel</b> objects <b>(Wheel)</b> .  This is done by calling the <b>SetupWheel ()</b> function for each of our wheels.  If you look at this function, you will see that it has two parameters: <b>Transform</b> and <b>boolean</b> , and returns a <b>Wheel</b> object.  We need this in order to change the location of the wheels, as well as to indicate the wheel belongs to the front of the car or not.  The function then creates and returns the <b>Wheel</b> object, which we nest in the <b>wheels</b> array containing all our wheels for the rest of the script: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t : Transform <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> frontWheels) { wheels[wheelCount] = SetupWheel(t, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); wheelCount++; }</code> </pre> <br>  In this cycle, we create a new game object, and call the <b>SetupWheel ()</b> function, pass the coordinates of the object as the first argument, specify <b>TRUE</b> or <b>FALSE</b> as the second parameter, if <b>TRUE</b> , then the created wheel will be the front one, if <b>FALSE,</b> then the rear one.  Then we add the <b>WheelCollider</b> component to this game object.  We set the <b>WheelCollider</b> properties from the <b>suspension</b> variables <b>(suspension)</b> that we discussed when setting up the car <b>(suspension range, suspension spring and shock absorber) (suspension range, spring and damper).</b> <br><br>  Required properties: we‚Äôve already created a <b>collider (collider)</b> , <b>WheelFrictionCurve</b> is created in <b>WheelFrictionCurve ()</b> , wheel graphics ( <b>DiscBrake</b> object we dragged into the inspector when we created the car) and tire graphics (which is a child of <b>DiscBrake</b> ). <br><br>  We will set the wheel radius automatically, depending on the tire size: <br><br><pre> <code class="javascript hljs">wheel.collider.radius = wheel.tireGraphic.renderer.bounds.size.y / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Finally, we check the wheel we just created, whether it is the front wheel or the rear wheel, looking at the <b>TRUE</b> or <b>FALSE</b> value.  Later in the code, we have to check that the car touches the ground, at least with one front and one rear wheel. <br><br>  In addition, we make a small reception for the front wheel, creating an additional game object that we establish between the car body and the wheel.  This is the <b>Steer Column (front pillar)</b> , which we will use later to rotate the wheel when turning. Finally, we create a wheel, which we return to the <b>Wheel</b> array and when we have processed all the wheels, we return to the <b>Start ()</b> function. <br><br><h3>  SetupCenterOfMass () </h3><br>  This is the next function we will look at.  This is a very small function that will set the center of mass in the <b>Rigidbody</b> to <b>CenterOfMass</b> , which we created earlier.  If the <b>center of mass has</b> not been established, <b>Rigidbody</b> will use the <b>center of mass</b> by default, which <b>Unity</b> will automatically calculate.  Then we convert the maximum speed entered in the inspector using a small useful function: <br><br><pre> <code class="javascript hljs">topSpeed = Convert_Miles_Per_Hour_To_Meters_Per_Second(topSpeed);</code> </pre><br>  The function simply multiplies the <b>TopSpeed</b> variable by the number <b>0.44704,</b> which translates it into meters per second.  This is an installation, so we can enter the desired speed in the inspector in miles / hour.  When calculating physics, we work with m / s.  We also have a small function that does the inverse calculation, which is very useful if you want to display the vehicle speed in miles / hour. <br><br><h3>  SetupGears () </h3><br>  The transfer is automatically calculated in this function by assigning the maximum speed to each gear and calculating how much power is needed to accelerate the car to a given speed in each gear.  The power is calculated using the friction and resistance values ‚Äã‚Äãsupplied in some variables, which means basic calculations along the Z axis, the friction calculation takes place in the Update () function.  The coefficient is multiplied by the value of this power so that the car accelerates to high speed. <br><br><h3>  SetupSkidmarks () </h3><br>  This function finds the <b>Skidmark</b> game object on the scene and stores a link to it using <b>ParticleEmitter to</b> create smoke.  The code for skidmarks is not covered in this manual, but this should not stop you from opening the script and exploring it on your own.  At the end of <b>Start (),</b> we assign the <b>X</b> values ‚Äã‚Äãof our <b>dragMultiplier</b> array to a variable: <br><br><pre> <code class="javascript hljs">initialDragMultiplierX = dragMultiplier.x;</code> </pre><br>  It is saved because we change the <b>dragMultiplier</b> <b>X</b> variable when we use the <b>handbrake</b> , and then we need to return to the original value again when we do not use the <b>handbrake</b> . <br><br>  To set the initial values, use the <b>Start ()</b> function.  For regular changes to these values, use the <b>Update ()</b> function. <br><br><h1>  Update () </h1><br>  <b>Update ()</b> is called every frame of the game, if <b>MonoBehaviour is</b> on. <br>  <b>Update ()</b> is the most frequently used function for implementing gameplay. <br><br><h3>  GetInput () </h3><br>  The first thing we do in each frame is a different keyboard operation by calling the <b>GetInput ()</b> function.  The first two lines are read from <b>vertical (vertical) and horizontal (horizontal)</b> axes and stored in the <b>throttle</b> and <b>steer variables</b> : <br><br><pre> <code class="javascript hljs">throttle = Input.GetAxis(‚ÄúVertical‚Äù); steer = Input.GetAxis(‚ÄúHorizontal‚Äù);</code> </pre><br>  <b>Vertical (vertical) and horizontal (horizontal)</b> axes can be set in the <b>Unity Input Manager (Edit -&gt; Project Settings -&gt; Input)</b> .  By default, the <b>vertical (vertical)</b> axis is set to the ‚ÄúW‚Äù, ‚Äúup arrow‚Äù keys for forward movement and ‚ÄúS‚Äù keys, ‚Äúdown arrow‚Äù keys for backward movement and the value we use here is stored in the variable <b>throttle</b> .  The horizontal (horizontal) axis is set as the ‚ÄúA‚Äù and ‚ÄúLeft arrow‚Äù keys to turn left, as well as the ‚ÄúD‚Äù and ‚ÄúRight arrow‚Äù keys to turn right. <br><br><h3>  CheckHandbrake () </h3><br>  After learning to <b>getInput</b> to drive a car, we call the <b>CheckHandbrake ()</b> function.  This is a specific function that checks whether the <b>Space</b> key is pressed or not, and applies certain logic accordingly: <br><br>  When we first pressed <b>Space (space)</b> , we set the <b>handbrake</b> variable to <b>true</b> , it starts the <b>handbrake</b> mechanism and changes the value of <b>dragMultiplier.x</b> (it creates a vibration on the road, like a real handbrake). <br><br>  When <b>Space (space) is</b> not pressed, the code will be executed another, until the key is pressed.  This again means that the <b>handbrake</b> code will not work only when the user first releases the <b>Space (space)</b> , because we set the <b>handbrake</b> variable to <b>false</b> inside the block.  The <b>StopHandbraking ()</b> function will be activated: <br><br><pre> <code class="javascript hljs">StartCoroutine(StopHandbraking(Mathf.Min(<span class="hljs-number"><span class="hljs-number">5</span></span>, Time.time - handbrakeTime)));</code> </pre><br><br><h3>  StopHandbraking () </h3><br>  <b>StopHandbraking ()</b> takes an input variable that determines the number of seconds that will have to be spent returning <b>dragMultiplier.x</b> back to its original state.  This value must be at least <b>5</b> for the <b>handbrake</b> timer that we just started.  The function then counts down the specified number of seconds, after which it sets the default value of the <b>dragMultiplier.x</b> variable, this creates the vehicle‚Äôs normal movement again. <br><br><h3>  Check_If_Car_Is_Flipped () </h3><br>  Returning to the <b>Update ()</b> function, we now consider the <b>Check_If_Car_Is_Flipped ()</b> function to check if the machine has turned over.  Inside this function, we will check the inverted machine.  This is absolutely true for a car that will be turned over or turned for example on extreme turns, if we have an accident or do some tricks, but we want to exclude the possibility of a car turning over.  Therefore, we check if the car has turned over at a certain angle, at which the car is not on the move anymore, and if so, we add from the moment of the last frame to the <b>resetTimer</b> variable.  If this value ultimately boils down to exceeding the value we set for <b>resetTime</b> (5 seconds by default), we call the <b>FlipCar ()</b> function.  If the car is at an angle with which you can drive, we set the timer back to zero. <br><br><h3>  FlipCar () </h3><br>  In <b>FlipCar ()</b> we get the car back on the wheels and set its speed to 0, so we can start moving again from this point. <br><br><h3>  UpdateWheelGraphics () </h3><br>  This is the longest and most complex function that is called from <b>Update ()</b> .  Fortunately, there is this large section that deals only with the placement <b>of tire marks</b> .  In terms of wheels, an important role is played by updating their position and angle of rotation in this function. <br><br>  Each wheel we begin with checking whether it touches the ground or not.  If it touches the ground, then we set the <b>wheelGraphic</b> (wheel graphics) to the position in which it should be, it depends on the height and radius of the wheel.  This will move the center of the wheel to the correct position relative to the chassis of the car. <br><br><pre> <code class="javascript hljs">w.wheelGraphic.localPosition = wheel.transform.up * (wheelRadius + wheel.transform.InverseTransformPoint(wh.point).y);</code> </pre><br>  After installing the wheel, we get the RigidBody speed at the point of contact with the ground, in order to transfer it to the local space and store its coordinates in our object. <br><br><pre> <code class="javascript hljs">w.wheelVelo = rigidbody.GetPointVelocity(wh.point); w.groundSpeed = w.wheelGraphic.InverseTransformDirection(w.wheelVelo);</code> </pre><br>  If the wheel currently does not touch the ground, then we establish the position of the wheel on the basis of its <b>coordinates, the range of the suspension, and the suspension of the</b> ‚Äúparent wheels‚Äù itself. <br><br><h3>  UpdateGear () </h3><br>  The last function called in the <b>Update ()</b> function is <b>UpdateGear ()</b> , which calculates the current ‚Äútransfer‚Äù of the car, based on the set values ‚Äã‚Äãin <b>SetupGears ()</b> and the current speed.  In the last section of the tutorial, we should look at the rest of the main loop, namely the physical calculations that occur inside the <b>FixedUpdate ()</b> function. <br><br><h1>  FixedUpdate () - All of our physics </h1><br>  When dealing with physics, it is important that the calculations and actions are strictly controlled so that the result is good.  <b>FixedUpdate () is</b> created for this purpose.  This ensures the execution of the code with a fixed time interval.  The frequency of calling the <b>FixedUpdate ()</b> function: ‚ÄúIt can be called several times in a frame if the frame rate is low;  or may be called after several frames if the frame rate is high.  All physics calculations and updates are called immediately before <b>FixedUpdate ()</b> . ‚Äù  We have a number of functions performed inside <b>FixedUpdate ()</b> , and they all relate to computing and applying force to a car. <br><br><h3>  UpdateDrag () </h3><br>  This means that with increasing speed - resistance increases even more.  Squaring the velocity when calculating the resistance is based on the present formula of resistance used in physics. <br><br>  After <b>relativeDrag (Relative resistance)</b> and scalable <b>dragMultiplier (resistance factors)</b> we have already considered, it was taken into account that the car in profile is very different from the front, side and top views. <br><br>  If we apply additional forces to the side <b>brake</b> to the side and frontal resistance values, based on how fast the car travels.  Notice how we use the scalar product between the speed and the direction of the front of the car to calculate the additional resistance.  This equation leads to additional resistance at the front of the car when the car is driving forward without turning (braking is faster) and slower braking on skids and turns.  For the <b>X</b> value of resistance, the same: for a car while sliding sideways.  After that, we gradually increase the resistance value <b>X</b> to slow the car instead of letting it slide along the road at all times. <br><br>  If we do not use the <b>handbrake</b> , we will only update the value of <b>X</b> : <br><br><pre> <code class="javascript hljs">drag.x *= topSpeed / relativeVelocity.magnitude;</code> </pre><br>  This is done for a comfortable ride on the car - we increase the lateral resistance, it gradually slows down the car during a drift until the moment the car completes the drift. <br><br>  At the end of the function, we apply forces to <b>RigidBody</b> : <br><br><pre> <code class="javascript hljs">rigidbody.AddForce(transform.TransformDirection(drag) * rigidbody.mass * Time.deltaTime);</code> </pre><br>  The resistance force is opposite to the speed of the car, we apply it to the <b>RigidBody</b> , as a result of which the car slows down. <br><br><h3>  UpdateFriction () </h3><br>  This function monitors the friction that is created between the wheels of the car and the surface of our road.  This is very simple because we use the <b>WheelFrictionCurve</b> function that we set up at the very beginning.  Friction of the wheel gives the force at the ‚Äúexit‚Äù of the function, based on the tire slip measurements that we passed to the function.  This force is divided into two directions: frontal friction (responsible for acceleration and braking) and lateral friction (responsible for properly maintaining the vehicle on the ground).  Earlier, we assigned the value of friction wheels, now we need to take care of updating the friction between the wheel and the surface: <br><br><pre> <code class="javascript hljs">w.collider.sidewaysFriction = wfc; w.collider.forwardFriction = wfc;</code> </pre><br>  We perform one action - we change the friction value of the car based on the current speed of the vehicle and the direction of movement of the car (normal driving - <b>Forward Friction</b> , and based on the skidding of the car - <b>‚Äúdriving sideways‚Äù sideways friction</b> ). <br><br><h3>  CalculateEnginePower () </h3><br>  Calculation of engine power, which we later use to apply force to <b>RigidBody is</b> relatively simple, but has several ‚Äúquirks‚Äù. <br><br>  ‚Ä¢ If we do not <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D1%2580%25D0%25BE%25D1%2581%25D1%2581%25D0%25B5%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">throttle</a> , we simply reduce the engine power, thereby slowing down the car. <br>  ‚Ä¢ If we <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D1%2580%25D0%25BE%25D1%2581%25D1%2581%25D0%25B5%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">throttle</a> in the same direction in which the car is now moving (we check this with the <b>HaveSameSign ()</b> function) and calculate the value we add to the engine power.  What we see may seem a bit strange: we calculate the rate of force, which is the product of the current engine power divided by the maximum engine power (yielding a result between 0 and 1), and then multiplied by 2 times.  The result will be between 0 (when we stand still or eat very slowly) and 2 (when we eat at maximum power).  Then we call the helper function <b>EvaluateNormPower ()</b> .  This function looks at the transmitted value and returns a number between 1 and 0 if the power norm is from 0 to 1. If the power norm is from 1 to 2, the function returns a value between 0 and 1. Are you surprised?  The number used in the formula that adds strength to the engine: <br><br><pre> <code class="javascript hljs">currentEnginePower += Time.deltaTime * <span class="hljs-number"><span class="hljs-number">200</span></span> * EvaluateNormPower(normPower);</code> </pre><br>  The end result is that we add more power when we press the "gas" button and the car starts slowly from the beginning, gradually accelerating.  In the end, when the car reaches maximum speed, no additional force is used to add to <br>  engine power. <br><br>  ‚Ä¢ If you use throttling in the opposite direction, this is equivalent to braking.  In this case, we will subtract the engine power for some time. <br><br>  Finally, the engine power is calculated, between the current gear and the previous gear, to avoid the possibility of drastically changing the values ‚Äã‚Äãin the calculation formula. <br><br><h3>  CalculateState () </h3><br>  This is a small function that we will consider now, because we need to know which car wheels are on the ground.  She makes this check very simple: <br>  ‚Ä¢ We set the <b>canDrive</b> and <b>canSteer variables</b> to <b>False</b> by default. <br>  ‚Ä¢ Then we check each wheel in the Wheels array to check which wheel touches the ground and which one does not: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(w.collider.isGrounded)</code> </pre><br>  If the wheel is on the ground, we check what type of wheel it is.  If this is the front wheel, then <b>canDrive is</b> set to <b>True</b> .  If it's a rear wheel, then <b>steerWheel is</b> set to <b>True</b> .  This function has done its job, if at least one wheel (rear wheel) touches the ground, then we can drive our car.  If at least one wheel (front wheel) touches the ground, we can turn. <br><br>  It remains to consider the last two functions that actually relate to our calculations for the <b>RigidBody</b> car.  We will look at this in more detail here so that you understand the logic of the work and the formulas for the calculation that ultimately create the movement of the car. <br><br><h3>  ApplyThrottle () </h3><br>  This function will work if the <b>CalculateState ()</b> function sets the <b>canDrive</b> variable to <b>True</b> (this means that at least one drive wheel is on the road).  If we can control, we start by comparing the <b>throttle</b> variable (which is a keystroke from the keyboard) and the <b>relativeVelocity.z</b> variable in which the vehicle speed value.  If these values ‚Äã‚Äãhave the same sign ‚Äî defined in the <b>HaveSameSign ()</b> function ‚Äî this means that we are throttling in the same direction in which the car is traveling and in this case we add throttle force to <b>RigidBody</b> : <br><br><pre> <code class="javascript hljs">throttleForce = Mathf.Sign(throttle) * currentEnginePower * rigidbody.mass;</code> </pre><br>  If the throttle value is negative (the user presses the brake button), the sign will be -1 and we calculate the negative throttleForce (Throttle Force), which we add to the car, we also know that the throttle force has a negative speed.  Therefore, we will throttle back faster.  The opposite effect when the user presses the "gas" button.  Then we add a ‚Äúpositive‚Äù throttleForce to the car, which is already going forward. <br><br>  If relativeVelocity.z and throttle have different signs, then this should mean that we will add throttle force in the opposite direction from the direction in which the car is now driving.  In other words, the car slows down or slows down.  We do this by setting the variable Brakeforce based on the mass of the car and the force of the first gear of the engine: <br><br><pre> <code class="javascript hljs">brakeForce = Mathf.Sign(throttle) * engineForceValues[<span class="hljs-number"><span class="hljs-number">0</span></span>] * rigidbody.mass;</code> </pre><br>  Again we use <b>throttle</b> , because we know <b>throttle</b> in this case has the opposite sign of speed, as a result, we calculate the force opposite to the force that drives the car. <br><br>  When we finish defining whether the car needs acceleration or deceleration, we apply the calculated forces in the direction of the Rigidbody movement: <br><br><pre> <code class="javascript hljs">rigidbody.AddForce(transform.forward * Time.deltaTime * (throttleForce + brakeForce));</code> </pre><br><h3>  ApplySteering () </h3><br>  If you do not create a drag racing game where you are trying to set a world speed record on a straight line, steering control is as important as throttling, so let's explore this function.  We do not use any throttle force as long as the <b>drive wheels (drive wheels)</b> do not touch the ground, and the same for this function, where we can not drive the car as long as the <b>steer wheels</b> do not touch the ground. <br><br>  At the beginning of the function, we calculate the value of a variable named <b>turnRadius</b> , based on the input data.  The equation makes an increase in the <b>turnRadius</b> value when you turn to either side.  We calculate the <b>minMaxTurn</b> value by calling the <b>EvaluateSpeedToTurn ()</b> function. <br><br><h3>  EvaluateSpeedToTurn () </h3><br>  This function returns the <b>turn</b> value depending on how fast the car travels; this is described in more detail in the second chapter of our manual.  If the car is driving fast, this value will be closer to <b>minimumTurn</b> , which makes it more difficult for the car to turn during fast driving.  Returning to the <b>ApplySteering ()</b> function, there <b>turnSpeed</b> refers directly to the calculation of <b>turnRadius</b> in the car.  The larger the radius, the smaller the angle of rotation, because the rotation circle is larger. <br><br>  We turn the car according to the formula: <br><br><pre> <code class="javascript hljs">transform.RotateAround( transform.position + transform.right * turnRadius * steer, transform.up, turnSpeed * Mathf.Rad2Deg * Time.deltaTime * steer );</code> </pre><br>  The function <b>RotateAround ()</b> turns around the transformed axis at a given point and takes an angle, which is the sum of turns. <br><br>  ‚Ä¢ The pivot point is exactly in the middle of the car when we do not turn the car at all.      ,    ,      . ,   <b>Steer</b>     ,   ,      ,    . <b>TurnRadius</b>      ,       .  <b>TurnRadius</b>    <b>transform.right</b>  ,            ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1fb/848/f51/1fb848f51a11ee616ba6a730e2d9d6a8.jpg" alt="image"><br><br> ‚Ä¢     <b>Y (up)</b> ,  ,       <b>X</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- we will turn the car to the line shown in the image. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ The rotation angle is calculated on the basis of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turnSpeed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> multiplied by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to turn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left / right</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now consider the inside:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(initialDragMultiplierX &gt; dragMultiplier.x)</code> </pre><br>        (handbraking)            . <br><br>      ,          ,    <b>angularVelocity.y</b>  <b>RigidBody</b> .        ,         ,            .     ,    <b> </b> . <br><br>     ,   ,     angularVelocity.y   .       -1,       1. <br><br>      ,       : <br><br><pre> <code class="javascript hljs">frontWheels[<span class="hljs-number"><span class="hljs-number">0</span></span>].localPosition + frontWheels[<span class="hljs-number"><span class="hljs-number">1</span></span>].localPosition) * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre><br>       ,    ,   ,         ,       ‚Äî         <b> </b> . <br><br>      <b>Update ()</b>  <b>LateUpdate ()</b>   . ,     ,          . <br><br><h1>    </h1><br>  <b>  (Project view)</b>      <b>~ AlternatePhysicsModel</b> .        <b>Prefabs</b>       <b>Unity</b> .      <b>  (wheel colliders) Unity</b> ,      <b>  (wheel collider)</b>     <b>Physics.Raycast</b> .    <b>Pacejka ¬´ /Magic Formula¬ª</b> ‚Äî        ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most likely, you do not need to know about the inner workings of the physical model. </font><font style="vertical-align: inherit;">You can just experiment with the settings of the already created </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefabs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you open the scripts, you will see that all parameters are explained in the comments. </font><font style="vertical-align: inherit;">Try to change the settings slightly and drive a car.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Included Prefabs </font></font></h3><br>      <b>Prefabs</b>  <b>  (skidmarks)</b>  <b>Prefabs</b> .   ,       <b>  (Skidmarks Prefab)</b>   (, <b>Prefabs skidmarks</b>    ).                . <br><br>           ,              ¬´¬ª  (  ). <br><br>      ,    <b>TractionHelper</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which is designed to make cars more manageable with joysticks. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Included Scripts </font></font></h3><br>  <b>AerodynamicResistance.cs</b> : This script must be added to each car in order to calculate the aerodynamic friction of the car. <br><br>  <b>AntiRollBar.cs</b> : Add, if necessary, to mimic the anti-roll bar for better handling. <br><br>  <b>CarController.cs</b> : script to handle driving.  This script is required for each car.  You can edit this script if you want to change driving or implement AI.  Also sets some characteristics of the car body, such as the center of gravity and inertia. <br><br>  <b>Drivetrain.cs</b> : car engine and transmission.  This script contains the gearbox and engine.  One of the scripts needed in the car. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skidmarks.cs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Global </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brake </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Mark</font></b><font style="vertical-align: inherit;"> Manager </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Add a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skidmark Prefab</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the scene that uses this class to visualize and control </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brake marks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on all vehicles.</font></font><br><br>  <b>SoundController.cs</b> : A simple class to play car sounds and other sounds.  This script must be added to the car. <br><br>  <b>TractionHelper.cs</b> : If necessary, add this script to the car to make it more sustainable.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This script is designed to help customize the flexible control of the car. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wheel.cs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : This script simulates tire models and wheel suspension, and acts as a replacement in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity for the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> built-in component </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wheel Collider.</font></font></b> <br><br>  <b>Wing.cs</b> : Add one script or more than one if you want to simulate the downforce of aerodynamics for your car. <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analysis and conclusion from the translator </font></font></h1><br>  2   ,          ,      : <br> 1)   ,       70    . <br> 2)            ,     . <br> 3)  ¬´¬ª        . <br> 4)    Rigidbody   Drag  Angular Drag (      )       )). <br>         . (~ AlternatePhysicsModel). <br>   : Lambordgine ‚Äî  2,      1. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/7e_0FUxn0IA%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhh3xbAJQlbpte_vYtGdKQunJ30rlQ" frameborder="0" allowfullscreen=""></iframe><br><br> <b></b> :  ,   ¬´ ¬ª   1.  ,      ‚Äî  2. </div><p>Source: <a href="https://habr.com/ru/post/248995/">https://habr.com/ru/post/248995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248983/index.html">How-to: Automate accounting tasks hosting provider</a></li>
<li><a href="../248985/index.html">CSS Auditing: Style Sheets Shouldn't Be Horrible</a></li>
<li><a href="../248987/index.html">CTB-Locker - a new modification of the FileCoder cryptographer</a></li>
<li><a href="../248991/index.html">Automatic Age Assessment System for Face Images</a></li>
<li><a href="../248993/index.html">Map of the latest photos of all people from these cities VK using VKScript</a></li>
<li><a href="../248997/index.html">Details about the new Microsoft rendering engine for Project Spartan</a></li>
<li><a href="../248999/index.html">Generating fake data for your javascript application using faker</a></li>
<li><a href="../249001/index.html">New Flash Player vulnerabilities are exploited in-the-wild</a></li>
<li><a href="../249005/index.html">Attention, application ideas contest for Microsoft and Mojio</a></li>
<li><a href="../249007/index.html">Ghost - gethostbyname () vulnerability in glibc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>