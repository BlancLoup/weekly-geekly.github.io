<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Practical application of Fourier transform for signal processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Books and publications on digital signal processing are written by authors who often do not guess and do not understand the tasks faci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Practical application of Fourier transform for signal processing</h1><div class="post__text post__text-html js-mediator-article">  <b>Introduction</b> <br><br>  Books and publications on digital signal processing are written by authors who often do not guess and do not understand the tasks facing the developers.  This is especially true of real-time systems.  These authors devote themselves to the modest role of a god who exists outside of time and space, which causes some perplexity in readers of such literature.  This publication is intended to dispel the misunderstandings that arise among the majority of developers and help them overcome the ‚Äúthreshold of entry‚Äù; for these purposes, the text consciously uses analogies and terminology of the programming sphere. <br><br>  This opus does not claim completeness and coherence. <br><a name="habracut"></a><br>  <i>Added after reading the comments.</i> <i><br></i>  <i>Publications about how to do FFT nemeryannom, but about how to do FFT, transform the spectrum, and collect the signal again, and even in real time, is clearly not enough.</i>  <i>The author is trying to fill this gap.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Part one, overview</b> <br><br>  There are two main ways to build discrete linear dynamic systems.  In the literature, such systems are called digital filters, which are divided into two main types: filters with finite impulse response (FIR) and filters with infinite impulse response (IIR). <br><br>  The algorithm essence of the FIR filter is the discrete calculation of the convolution integral: <br><br><img src="https://habrastorage.org/files/534/cf0/401/534cf0401b254b56b590365565f86e31.gif"><br><br>  Where x (t) is the input signal <br>  y (t) - output signal <br>  h (t) is the filter impulse response or filter response to the delta function.  The impulse response is the inverse Fourier transform of the complex frequency response of the filter K (f). <br><br>  To form a clear picture with the reader, we give an example of a discrete calculation of the convolution integral in C in real time. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> L (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  int FIR(int a) { static int i=0; //  static int reg[L]; //   static const int h[L]={1,1,1,1};//  int b=0;//  reg[i]=a; //       for(int j=0;j&lt;L;j++)// { b=b+h[j]*reg[i]; i=(i-1)&amp;(L-1); } i=(i+1)&amp;(L-1);//     return b; }</span></span></span></span></code> </pre> <br><br>  Calling this function at certain time intervals T and passing the input signal as an argument to it, we will get an output signal corresponding to the filter response with an impulse response of the form: <br><br>  h (t) = 1 at 0 &lt;t &lt;4T, <br>  h (t) = 0 in other cases. <br><br>  The filter with such an impulse characteristic is better known to all those gathered under the name ‚Äúmoving average filter‚Äù, and, accordingly, it is implemented much easier.  In this case, this impulse response is used as an example. <br><br>  A lot of literature is devoted to the synthesis of pulse characteristics of FIR filters; there are also ready-made software products for obtaining filters with specified properties.  The author prefers the buggy Filter Design tool from the Matlab package, but this is a matter of taste. <br><br>  Using a filter with a finite impulse response, it is possible to soar a little over the usual reality, since, in nature, there are no dynamic systems that have a finite impulse response.  The FIR filter is an attempt to enter the time-frequency domain from the other end, not as nature walks, therefore the frequency characteristics of these filters often have unexpected properties. <br><br>  Much closer to nature are filters with infinite impulse response.  The algorithmic essence of filters with infinite impulse response is reduced to a recurrent (not to be confused with a recursive!) Solution of a differential equation describing a filter.  That is, each subsequent value of the output signal of the filter is calculated based on the previous value.  That is how the processes in the real world proceed.  The stone, falling from a skyscraper every second, increases its speed by 9.8m / s Speed ‚Äã‚Äã= Speed ‚Äã‚Äã+ 9.8, and the distance traveled every second increases Distance = Distance + Speed.  Who can say that this is not a recurrent algorithm, let the first one throw a stone at me.  Only in our <i>Matrix, the</i> time interval for calling the function returning the position of a stone is much less than the cost of dividing the means of measurement available to us. <br><br>  Separately, I would like to define the concept of "filter order".  This is the number of variables that undergo recurrent operations.  In the above example, the function that returns the speed of the stone is of the first order, the function that returns the distance traveled is of the second order. <br><br>  For the final clarification of the reader, we will give an example in the C language of the simplest low-pass filter, commonly known as the filter ‚Äúfilter of exponential smoothing‚Äù <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> alfa (2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  int filter(int a) { static int out_alfa=0; out_alfa=out_alfa - (out_alfa &gt;&gt;alfa) + a; return (out_alfa &gt;&gt; alfa); }</span></span></span></span></code> </pre> <br><br>  Calling this function with the frequency F and passing it the input signal as an argument, we will get the output signal corresponding to the response of the low-pass filter of the first order with the cutoff frequency: <br><br><img src="https://habrastorage.org/files/163/3ce/954/1633ce9541334004af2bdd38cb8300cf.gif"><br><br>  The given example of source code is completely indigestible from the point of view of understanding the essence of the algorithm.  From the point of view of the recurrent essence (see the ‚Äústone fall‚Äù) of the algorithm, more correctly y = y + ((xy) &gt;&gt; alfa); but in this case there is a loss of alfa of significant digits.  The recurrent expression of the filter, from the sample code, is constructed in such a way as to avoid the loss of significant digits.  It is the finite accuracy of calculations that can spoil the beauty of a digital filter with infinite impulse response.  This is especially noticeable on high-order filters characterized by high Q-factors.  In real dynamic systems, this problem does not arise, our <i>Matrix</i> performs calculations with incredible accuracy for us. <br><br>  A lot of literature is devoted to the synthesis of such filters, there are also ready-made software products (see above). <br><br>  <b>Part two.</b>  <b>Fourier filter</b> <br><br>  From university courses (for your humble servant, this was the OTETS course), many gathered remember two main approaches to the analysis of linear dynamic systems: analysis in the time domain and analysis in the frequency domain.  The analysis in the time domain is the solution of differential equations, convolution and Duhamel integrals.  These analysis methods are discretely embodied in IIR and KIH digital filters. <br><br>  But there is a frequency approach to the analysis of linear dynamic systems.  Sometimes it is called operator.  The operators used are Fourier transform, Laplace, etc.  Further we will talk only about the Fourier transform. <br><br>  This method of analysis is not widely used in the construction of digital filters.  The author could not find any sane practical recommendations for building such filters in Russian.  The only brief mention of such a filter in the practical literature [Rabiner L., Gould B., Theory and application of digital signal processing 1978], but in this book, the consideration of such a filter is very superficial.  In this book, this filter scheme is called: ‚Äúconvolution in real time by the FFT method‚Äù, which, in my humble opinion, does not reflect the essence, the name should be short, otherwise there will be no time to rest. <br><br>  The reaction of a linear dynamic system is the inverse Fourier transform of the product of the Fourier image of the input signal x (t) by the complex transfer coefficient K (f): <br><br><img src="https://habrastorage.org/files/37a/2a4/63c/37a2a463c4b9414a86e057fed9478320.gif"><br><br>  In practical terms, this analytical expression suggests the following procedure: take the Fourier transform from the input signal, multiply the result by the complex transfer coefficient, perform the inverse Fourier transform, which results in the output signal.  In real discrete time, this procedure cannot be performed.  How to take the integral in time from minus to plus infinity?  It can be taken only being out of time ... <br><br>  In the discrete world, there is a tool for performing the Fourier transform ‚Äî the Fast Fourier Transform Algorithm (FFT).  That is what we will use when implementing our Fourier filter.  The argument of the FFT function is an array of time samples of 2 ^ n elements, the result of two arrays of length 2 ^ n elements corresponding to the real and imaginary parts of the Fourier transform.  A discrete feature of the FFT algorithm is that the input signal is considered periodic with an interval of 2 ^ n.  This imposes some restrictions on the Fourier filter algorithm.  If you take a sequence of samples of the input signal, perform an FFT from them, multiply the result of the FFT by the complex filter transfer coefficient and perform the inverse transformation ... <b>nothing happens!</b>  The output signal will have huge non-linear distortions in the vicinity of the sample junctions. <br><br>  To solve this problem, you need to apply two techniques: <br><br><ul><li>  1. Samples must be processed by overlapping Fourier transform.  That is, each subsequent sample should contain a part of the previous one.  In the ideal case, the samples should overlap by (2 ^ n-1) samples, but this requires a huge computational cost.  In practice, more than three quarters (2 ^ n-2 ^ (n-2)), half (2 ^ (n-1)) and even a quarter overlap (2 ^ (n-2)) are sufficient. </li><li>  2. The results of the inverse Fourier transform, to obtain the output signal, it is necessary, before imposing on each other, multiplied by the weight function (an array of weights).  The weight function must satisfy the following conditions: </li><li>  2.1 Equal to zero everywhere except for the interval 2 ^ n. </li><li>  2.2 At the edges of the interval tends to zero. </li><li>  2.3 And, most importantly, the sum of the weight functions Fv (t) shifted by the overlap interval k should be constant: </li></ul><br><img src="https://habrastorage.org/files/de0/c6c/9f8/de0c6c9f88f24c078f8902e573175c3a.gif"><br><br>  Such functions are widely used in the technique of digital signal processing, and it is customary to call them windows.  According to the author‚Äôs humble opinion, the best, from a practical point of view, is the window of the Khan name: <br><br><img src="https://habrastorage.org/files/718/867/a39/718867a39afa4c1a83b237c08489005b.gif"><br><br>  The figure shows graphs illustrating the properties of a Han window with a length of 2 ^ n = 256.  Window instances are built with a half overlap of k = 128.  As you can see all the above properties are available. <br><br><img src="https://habrastorage.org/files/f7d/44b/1f2/f7d44b1f2e9942f8b9ed82ba821f376a.png"><br><br>  At the request of workers, the following figure shows the Fourier filter calculation scheme, with a sample length of 2 ^ n = 8, number of samples 3. In such figures it is very difficult to display the calculation process, it is especially hard to show its cyclicality, therefore we limited ourselves to the number of samples . <br><br><img src="https://habrastorage.org/files/b18/46f/13a/b1846f13a9434b99be4eea3d5e8a4ee9.png"><br><br>  The input signal is divided into blocks of length 2 ^ n = 8 with overlap of 50%, FFT is taken from each block, the FFT results undergo the required transformation, the inverse FFT is taken, the result of the inverse FFT is multiplied scalarly by the window, after multiplication, the blocks are added to overlap. <br><br>  When performing spectrum transformations, you should not forget about the main property of the FFT array of real signals, the first half of the FFT array is complexly conjugated with the second half, that is, Re [i] = Re [(1 &lt;&lt; n) -i]);  Im [i] = - Im [(1 &lt;&lt; n) -i]) ;.  If these requirements do not fulfill the output signal simply "does not meet." <br><br>  Now we know everything that is needed to write a Fourier filter algorithm.  We describe the algorithm in C. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; #define FSempl (8000)//   #define BufL (64) //   #define Perk (2) //  2-1/2, 4-3/4 // ,   #define FsrLow (300)//    #define FsrHi (3100)//    #define FsrLowN ((BufL*FsrLow+(FSempl/2))/FSempl)//    #define FsrHiN ((BufL*FsrHi +(FSempl/2))/FSempl)//    //  #define SdvigSp (0)//    +() -() 0( ) //   ,  #define FilterSpekrtaT_EN (1)//   1/0 #define FiltSpektrFsr (0.100025f) //    volatile unsigned short ShBuf;//   signed short BufIn[BufL*2];//  signed short BufOut[BufL*2];//  signed short BufInOut[BufL];//   float FurRe[BufL];//   float FurIm[BufL];//   #if (FilterSpekrtaT_EN!=0) float FStektr[BufL/2];//   #endif //   #if BufL==64 const float SinCosF[]= { 0.000000000 , 0.098017140 , 0.195090322 , 0.290284677 , 0.382683432 , 0.471396737 , 0.555570233 , 0.634393284 , 0.707106781 , 0.773010453 , 0.831469612 , 0.881921264 , 0.923879533 , 0.956940336 , 0.980785280 , 0.995184727 , 1.000000000 , 0.995184727 , 0.980785280 , 0.956940336 , 0.923879533 , 0.881921264 , 0.831469612 , 0.773010453 , 0.707106781 , 0.634393284 , 0.555570233 , 0.471396737 , 0.382683432 , 0.290284677 , 0.195090322 , 0.098017140 , 0.000000000 , -0.098017140, -0.195090322, -0.290284677, -0.382683432, -0.471396737, -0.555570233, -0.634393284, -0.707106781, -0.773010453, -0.831469612, -0.881921264, -0.923879533, -0.956940336, -0.980785280, -0.995184727, -1.000000000, -0.995184727, -0.980785280, -0.956940336, -0.923879533, -0.881921264, -0.831469612, -0.773010453, -0.707106781, -0.634393284, -0.555570233, -0.471396737, -0.382683432, -0.290284677, -0.195090322, -0.098017140, 0.000000000 , 0.098017140 , 0.195090322 , 0.290284677 , 0.382683432 , 0.471396737 , 0.555570233 , 0.634393284 , 0.707106781 , 0.773010453 , 0.831469612 , 0.881921264 , 0.923879533 , 0.956940336 , 0.980785280 , 0.995184727 }; #endif //   #if BufL==64 const unsigned short sortFFT[]= { 0x0000,0x0020,0x0010,0x0030,0x0008,0x0028,0x0018,0x0038, 0x0004,0x0024,0x0014,0x0034,0x000C,0x002C,0x001C,0x003C, 0x0002,0x0022,0x0012,0x0032,0x000A,0x002A,0x001A,0x003A, 0x0006,0x0026,0x0016,0x0036,0x000E,0x002E,0x001E,0x003E, 0x0001,0x0021,0x0011,0x0031,0x0009,0x0029,0x0019,0x0039, 0x0005,0x0025,0x0015,0x0035,0x000D,0x002D,0x001D,0x003D, 0x0003,0x0023,0x0013,0x0033,0x000B,0x002B,0x001B,0x003B, 0x0007,0x0027,0x0017,0x0037,0x000F,0x002F,0x001F,0x003F }; #endif //   #if BufL==64 const float WinHanF[]= { 0.0 , 0.002407637 , 0.00960736 , 0.021529832 , 0.038060234 , 0.059039368 , 0.084265194 , 0.113494773 , 0.146446609 , 0.182803358 , 0.222214883 , 0.264301632 , 0.308658284 , 0.354857661 , 0.402454839 , 0.45099143 , 0.5 , 0.54900857 , 0.597545161 , 0.645142339 , 0.691341716 , 0.735698368 , 0.777785117 , 0.817196642 , 0.853553391 , 0.886505227 , 0.915734806 , 0.940960632 , 0.961939766 , 0.978470168 , 0.99039264 , 0.997592363 , 1.0 , 0.997592363 , 0.99039264 , 0.978470168 , 0.961939766 , 0.940960632 , 0.915734806 , 0.886505227 , 0.853553391 , 0.817196642 , 0.777785117 , 0.735698368 , 0.691341716 , 0.645142339 , 0.597545161 , 0.54900857 , 0.5 , 0.45099143 , 0.402454839 , 0.354857661 , 0.308658284 , 0.264301632 , 0.222214883 , 0.182803358 , 0.146446609 , 0.113494773 , 0.084265194 , 0.059039368 , 0.038060234 , 0.021529832 , 0.00960736 , 0.002407637 }; #endif //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //     // //     ReFT    ImFT //    .     void FFTnoInv(float* ReFT,float* ImFT) { //   for(int i=0;i&lt;BufL;i++) { int j=sortFFT[i];//  if(i&lt;j)//    { //  float swp=ReFT[i]; ReFT[i]=ReFT[j]; ReFT[j]=swp; //     //swp=ImFT[i]; //ImFT[i]=ImFT[j]; //ImFT[j]=swp; } } // long darg=BufL; //   for(long LP2=1;LP2!=BufL;LP2=LP2&lt;&lt;1)// { darg=darg&gt;&gt;1; long arg=0; // ,  for(int j=0;j&lt;LP2;j++) //   { float c=(SinCosF[arg+(BufL/4)]);// float s=(SinCosF[arg]);// arg=(arg-darg)&amp;(BufL-1);//  for(int i=j;i&lt;BufL;i=(i+LP2+LP2)) //  { //!!! float wr=(c*ReFT[i+LP2])-(s*ImFT[i+LP2]); float wi=(s*ReFT[i+LP2])+(c*ImFT[i+LP2]); ReFT[i+LP2]=ReFT[i]-wr; ImFT[i+LP2]=ImFT[i]-wi; ReFT[ i ]=ReFT[i]+wr; ImFT[ i ]=ImFT[i]+wi; } } } // return; } //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //     // //     ReFT    ImFT //    .     //      0 void FFTInv(float* ReFT,float* ImFT) { //   for(int i=0;i&lt;BufL;i++) { int j=sortFFT[i];// if(i&lt;j)//    { //  float swp=ReFT[i]; ReFT[i]=ReFT[j]; ReFT[j]=swp; swp=ImFT[i]; ImFT[i]=ImFT[j]; ImFT[j]=swp; } } // long darg=BufL;//   for(long LP2=1;LP2!=BufL;LP2=LP2&lt;&lt;1)// { darg=darg&gt;&gt;1; long arg=0;//// ,  for(int j=0;j&lt;LP2;j++)//  { float c=(SinCosF[arg+(BufL/4)]);// float s=(SinCosF[arg]);// arg=arg+darg;//  for(int i=j;i&lt;BufL;i=(i+LP2+LP2))//  { //!!! float wr=(c*ReFT[i+LP2])-(s*ImFT[i+LP2]); float wi=(s*ReFT[i+LP2])+(c*ImFT[i+LP2]); ReFT[i+LP2]=ReFT[i]-wr; ImFT[i+LP2]=ImFT[i]-wi; ReFT[ i ]=ReFT[i]+wr; ImFT[ i ]=ImFT[i]+wi; } } } //,   for(int i=0;i&lt;BufL;i++) { ReFT[i]=ReFT[i] * WinHanF[i] * ( (1.0F/((float)BufL)) * (2.0F/((float)Perk)) ); } // return; } //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //  void ObrBuf(void) { //   for(int i=0;i&lt;(BufL);i++) { FurRe[i]=((float)BufInOut[i]); FurIm[i]=0.0F; } //   FFTnoInv(FurRe,FurIm); //  #if SdvigSp&gt;0 //  , - for(int i=1;i&lt;(BufL/2);i++) { if(i&gt;=(BufL/2-SdvigSp)) { FurRe[i]=FurIm[i]=0; FurRe[BufL-i]=FurIm[BufL-i]=0; continue; } FurRe[i]=FurRe[i+SdvigSp]; FurIm[i]=FurIm[i+SdvigSp]; FurRe[BufL-i]=FurRe[i]; FurIm[BufL-i]=-FurIm[i]; } #endif #if SdvigSp&lt;0 //  ,  for(int i=(BufL/2-1);i&gt;0;i--) { if(i&lt;=(-SdvigSp)) { FurRe[i]=FurIm[i]=0; FurRe[BufL-i]=FurIm[BufL-i]=0; continue; } FurRe[i]=FurRe[i-(-SdvigSp)]; FurIm[i]=FurIm[i-(-SdvigSp)]; FurRe[BufL-i]=FurRe[i]; FurIm[BufL-i]=-FurIm[i]; } #endif // ,   FurRe[0]=0.0F;FurIm[0]=0.0F; //  FurRe[(BufL/2)]=0.0F;FurIm[(BufL/2)]=0.0F;//  float ZnStektr[BufL/2];//   for(int i=1;i&lt;(BufL/2);i++) { if( ( i &lt; FsrLowN )//  || ( i &gt; FsrHiN )//  ) { // ,     FurRe[i]=0.0F;FurIm[i]=0.0F;//  FurRe[BufL-i]=0.0F;FurIm[BufL-i]=0.0F;//  } else //      { ZnStektr[i]=sqrtf(FurRe[i]*FurRe[i])+(FurIm[i]*FurIm[i]);//  } } //    ,  for(int i= FsrLowN;//  i&lt;=FsrHiN ;//  i++) { #if FilterSpekrtaT_EN!=0 //   ,  FStektr[i]=FStektr[i]+ FiltSpektrFsr*(ZnStektr[i]-FStektr[i]); #endif //      FurRe[i]=FurRe[BufL-i]=(FStektr[i]*FurRe[i])/ZnStektr[i]; FurIm[i]=(FStektr[i]*FurIm[i])/ZnStektr[i]; FurIm[BufL-i]=-FurIm[i]; } //   FFTInv(FurRe,FurIm); //  for(int i=0;i&lt;(BufL);i++) { BufInOut[i]=((signed short)(FurRe[i]+0.5f)); } } //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //  signed short FureFilter(signed short t1) { //    BufIn[ShBuf]=t1; //  signed short out=BufOut[ShBuf]; //   ShBuf=(ShBuf+1)&amp;((BufL*2)-1); //      if((ShBuf&amp;((BufL/Perk)-1))==0) { //      int ShTmpOut=ShBuf; int ShTmpIn=(ShBuf-BufL)&amp;((BufL*2)-1); for(int i=0;i&lt;(BufL);i++) { if(i&lt;(BufL-(BufL/Perk))) { //        BufOut[ShTmpOut]=BufOut[ShTmpOut]+BufInOut[i]; } else { //        BufOut[ShTmpOut]=BufInOut[i]; } //    ShTmpOut=(ShTmpOut+1)&amp;((BufL*2)-1); //      BufInOut[i]=BufIn[ShTmpIn]; //    ShTmpIn=(ShTmpIn+1)&amp;((BufL*2)-1); } }// if((ShBuf&amp;((BufL/Perk)-1))==0) //   //    ! if((ShBuf&amp;((BufL/Perk)-1))==0)ObrBuf(); return out; }</span></span></span></span></code> </pre> <br><br>  Calling the FureFilter () function with the FSempl frequency and passing it the input signal as an argument, we get the output signal.  In this example, the input signal is processed as follows: the signal is passed through a band-pass filter with cut-off frequencies FsrLow, FsrHi, all spectral components above and below the frequencies are suppressed, the signal spectrum is shifted (for sound signals this is perceived as the Buratino-Karabas effect), the amplitude spectrum of the signal it is smoothed by a low-pass filter (for sound, this is the effect of a booming room).  These actions with a signal are performed as an example in order to show technical methods of signal processing in the frequency domain, such as: observance of complex conjugacy of coefficients, reconstruction of the complex amplitude spectrum, without using trigonometric functions, etc. <br><br>  <b>Conclusion</b> <br><br>  It is worth noting that, most likely, this Fourier filter function, in practice, will be disabled.  By calling this function, even with a low frequency of 8000 Hz, it will not have time to be executed by the time of the next call, there is not enough speed.  <b>This program code of the Fourier filter is given as a description of the algorithm, without being tied to specific hardware resources, and has purely educational purposes</b> (see Introduction). <br><br>  In practical implementation, it is necessary to parallelize the execution of the function of filling-emptying the buffer BufInOut [] (it is better to immediately use the RAP, etc.) and the function of processing the buffer ObrBuf (), but this is a completely different story. </div><p>Source: <a href="https://habr.com/ru/post/324152/">https://habr.com/ru/post/324152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324142/index.html">Setting up automatic deployment of independent development environments on one machine (Docker, Ansible, TeamCity)</a></li>
<li><a href="../324144/index.html">Java memory leak diagnostics</a></li>
<li><a href="../324146/index.html">Top 3 NPS Survey Services (Consumer Loyalty Index)</a></li>
<li><a href="../324148/index.html">What is a ‚Äúmaster data management system‚Äù and why is it needed?</a></li>
<li><a href="../324150/index.html">How to increase production efficiency with augmented reality?</a></li>
<li><a href="../324156/index.html">Cisco Smart Install. We study technology, we look for attack vectors</a></li>
<li><a href="../324158/index.html">Harmonic Linearization with Python Tools</a></li>
<li><a href="../324160/index.html">Parametric modeling in CAD SolveSpace: Introduction</a></li>
<li><a href="../324162/index.html">Direct charity: children - toys, adults - the right to drawings</a></li>
<li><a href="../324164/index.html">Using scripts in Openvpn to integrate it with other system services (Firewall, DB, etc.)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>