<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in Swift 3?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As we all know for a long time, Apple has integrated Swift 3 into Xcode 8. This is the first version of the open source language that works on both ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in Swift 3?</h1><div class="post__text post__text-html js-mediator-article">  As we all know for a long time, Apple has integrated Swift 3 into Xcode 8. This is the first version of the open source language that works on both macOS and Linux.  If you followed the development of the language on Swift Evolution since December last year and managed to experiment with it at the IBM sandbox, you probably already understood that a lot of changes appeared in it.  I‚Äôm pretty sure that when compiling an existing project in Xcode 8, your code will surprise you with errors.  But it is fixable.  Let's get acquainted with some changes in the new versions of the language. <br><img src="https://habrastorage.org/getpro/habr/post_images/086/d90/ac0/086d90ac046707600137e897946714bf.png" alt="image"><br><a name="habracut"></a><br>  Changes in the new versions can be divided into two main categories: <br><br><ul><li>  Remote functions that are already deprecated with Swift 2.2 </li><li>  Language enhancements </li></ul><br>  Let's start with the category of remote functions, since it is easier to understand and you probably met with these functions when you received warnings in Xcode 7.3. <br><br><h3>  Operators ++ and - </h3><br>  The increment and decrement operators of the heritage of the C language and their functionality is simple - add one or subtract one to a specific variable: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="objectivec hljs">var i = <span class="hljs-number"><span class="hljs-number">0</span></span> i++ ++i i-- --i</code> </pre> <br>  However, things get more complicated when it comes to deciding which one to choose.  Each of them can be presented in two possible variants: prefix and postfix - they all function thanks to the engine and return values ‚Äã‚Äãthat you can use or reject due to operator reloading. <br><br>  This is more than enough for beginners, since they have been removed - use the assignment and addition operators <b>+ =</b> and subtraction <b>- =</b> instead of: <br><br><pre> <code class="objectivec hljs">var i = <span class="hljs-number"><span class="hljs-number">0</span></span> i += <span class="hljs-number"><span class="hljs-number">1</span></span> i -= <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Of course, you can use addition (+) and subtraction (-) operators, as well as share assignment operators, so you can save your time when writing code, though: <br><br><pre> <code class="objectivec hljs">i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> i = i - <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  <b>For your reference:</b> <i>If you want to know more about the reasons for this change, <a href="">see Chris Latner's suggestion</a> on this.</i> <br><br><h3>  C language style for writing cycles is history </h3><br>  The most common example of using increment and decrement operators is the C language style for writing a loop.  Removing operators means deleting everything connected with them, because you can‚Äôt do anything with it all, unlike what you did with expressions and the operator to specify a range. <br><br>  For example, if you have some knowledge, you will probably use a for loop to display a number from 1 to 10: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { print(i) }</code> </pre><br>  In Swift 3, this is not possible.  This is its prototype in Swift 3 - let's consider the closed-range operator (...) in action: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>.<span class="hljs-number"><span class="hljs-number">.10</span></span> { print(i) }</code> </pre><br>  Alternatively, you can also use for-each loop with closed expressions and abbreviated arguments ‚Äî you can find more detailed information <a href="https://cosminpupaza.wordpress.com/2015/12/04/for-vs-while-a-beginners-approach/">here</a> . <br><br><pre> <code class="objectivec hljs">(<span class="hljs-number"><span class="hljs-number">1.</span></span>.<span class="hljs-number"><span class="hljs-number">.10</span></span>).forEach {  print($<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  <b>For your reference:</b> <i>If you want to learn more about the motivation for this change, <a href="">see Erica Sadun's proposal</a> .</i> <br><br><h3>  Removed variable from function parameters </h3><br>  Function parameters are usually defined as constants since they do not need to be changed inside functions.  However, there are certain instances where declaring them as variables can be useful.  In Swift 2, you can mark a function parameter as a variable with the <b>var</b> keyword.  After the parameter is specified as <b>var</b> , it will create a local copy of the value, so you can change its value in the function body. <br><br>  As an example, the following function defines the greatest common factor of two given numbers ‚Äî if you missed a math course in high school, read more about it here: <br><br><pre> <code class="objectivec hljs">func gcd(var a: Int, var b: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a } repeat { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) { a = a - b } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b = b - a } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a != b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a }</code> </pre><br>  The algorithm is simple: if both numbers are already equal, one of them is returned.  Otherwise, compare them, subtract the smaller of the larger and assign the result to the larger until they are equal and return any of them.  As you can see, by marking a and b as variables, we can change their values ‚Äã‚Äãin the function. <br><br>  Swift 3 no longer allows developers to set function parameters as variables, because Swift developers can get confused between <b>var</b> and <b>inout</b> .  Thus, the latest version of Swift simply removes the <b>var</b> from the function parameters. <br><br>  Therefore, to write the same <b>gcd</b> function in Swift 3, a different approach is needed.  You need to save the values ‚Äã‚Äãof the function parameters for local variables: <br><br><pre> <code class="objectivec hljs">func gcd(a: Int, b: Int) -&gt; Int {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a  }  var c = a  var d = b  repeat {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; d) {      c = c - d    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      d = d - c    }  } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (c != d)  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c }</code> </pre><br>  If you want to know more about the reasons for this decision, you can <a href="">read the original sentence</a> . <br><br><h3>  Consistent labeling behavior for function parameters </h3><br>  Function parameter lists are tuples, so you can use them to call functions, as long as the structure of the tuple matches the function prototype.  Take gcd () as an example.  You can make a call like this: <br><br><pre> <code class="objectivec hljs">gcd(<span class="hljs-number"><span class="hljs-number">8</span></span>, b: <span class="hljs-number"><span class="hljs-number">12</span></span>)</code> </pre><br>  Or you can even call a function, as shown below: <br><br><pre> <code class="objectivec hljs">let number = (<span class="hljs-number"><span class="hljs-number">8</span></span>, b: <span class="hljs-number"><span class="hljs-number">12</span></span>) gcd(number)</code> </pre><br>  As you can see in Swift 2, you do not need to specify the label of the first parameter.  However, you must specify a label for the second (and other parameters) when calling the function. <br><br>  This syntax is confusing for novice developers, so it is intended to standardize the behavior of tags.  In the new versions of the Swift language, you can call a function as follows: <br><br><pre> <code class="objectivec hljs">gcd(a: <span class="hljs-number"><span class="hljs-number">8</span></span>, b: <span class="hljs-number"><span class="hljs-number">12</span></span>)</code> </pre><br>  You must explicitly specify a label for the first parameter.  If you do not do this, Xcode 8 will show you an error message. <br><br>  Your first reaction to this change might look like ‚ÄúOMG!  I have to make a lot of changes to the existing code. ‚Äù  You're right.  These are tons of changes.  Thus, Apple offers a way to suppress the first label of the parameter of the function call.  You can add an underscore to the first parameter, as shown below: <br><br><pre> <code class="objectivec hljs">func gcd(_ a: Int, b: Int) -&gt; Int { ... }</code> </pre><br>  By doing this, you can call a function using the old method - without specifying the first label.  This will help make code migration from Swift 2 to Swift 3 much easier. <br><br>  On the motivation and intent of this change, you can <a href="">read this sentence</a> . <br><br><h3>  Selectors as strings are no longer used. </h3><br>  Let's create a button and perform some action, when you click on it - use only the playground, not the storyboard: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 import UIKit import XCPlayground // 2 class Responder: NSObject { func tap() { print("Button pressed") } } let responder = Responder() // 3 let button = UIButton(type: .System) button.setTitle("Button", forState: .Normal) button.addTarget(responder, action: "tap", forControlEvents: .TouchUpInside) button.sizeToFit() button.center = CGPoint(x: 50, y: 25) // 4 let frame = CGRect(x: 0, y: 0, width: 100, height: 50) let view = UIView(frame: frame) view.addSubview(button) XCPlaygroundPage.currentPage.liveView = view</span></span></code> </pre><br>  There are quite a few events going on, so let's break them down into stages: <br><br><ol><li>  Import of UIKit and XCPlayground frameworks - you need to create a button and show it in the playground editor. </li><li>  Determine the click method that will be executed when the user clicks a button and create a target?  the button logical entity is its base class NSObject, since selectors work only with Objective-C methods. </li><li>  Button declaration and setting properties. </li><li>  Creating a view of a certain size, adding a button to the view and displaying it in the Playground assistant. </li></ol><br>  Look at the highlighted code.  The button selector is a string.  If you enter it incorrectly, the code will be compiled, but it will fail during its execution, since the corresponding method may not be found. <br><br>  To eliminate a potential compile-time problem, Swift 3 replaced the selector string with the #selector () keyword.  This allows the compiler to detect the problem earlier if you do not correctly specify the name of the method. <br><br><pre> <code class="objectivec hljs">button.addTarget(responder, action: <span class="hljs-meta"><span class="hljs-meta">#selector(Responder.tap), for: .touchUpInside)</span></span></code> </pre><br>  To understand the reasons for this change, you can <a href="">read Doug Gregor's proposal</a> . <br><br>  This is with regard to remote functions.  Now let's get to the main points of language modernization. <br><br><h3>  Key-paths as a string </h3><br>  This function is similar to the previous one, but it refers to <b>key value coding</b> (KVC) and key-value observing (KVO): <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> { var name: String = <span class="hljs-string"><span class="hljs-string">""</span></span> init(name: String) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name } } let me = Person(name: <span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>) me.valueForKeyPath(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)</code> </pre><br>  You create a <b>Person</b> class that matches the key-value of the encoding, create my identity with the class designated by the initializer, and use <b>KVC</b> to set the name. <br><br>  Again, if you make it wrong, everything will explode! <br><br>  Fortunately, this will not happen again in Swift 3. Key-path has been replaced by the #keyPath () expression: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> { var name: String = <span class="hljs-string"><span class="hljs-string">""</span></span> init(name: String) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name } } let me = Person(name: <span class="hljs-string"><span class="hljs-string">"Cosmin"</span></span>) me.value(forKeyPath: <span class="hljs-meta"><span class="hljs-meta">#keyPath(Person.name))</span></span></code> </pre><br>  To understand the reasons for this change, you can <a href="">read David Hearts‚Äôs suggestion</a> . <br><br><h3>  Removed <b>NS</b> base type prefix </h3><br>  Removed <b>NS</b> prefix for base types.  Let's see how it works.  A typical example is working with JSON: <br><br><pre> <code class="objectivec hljs">let file = <span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span>.mainBundle().pathForResource(<span class="hljs-string"><span class="hljs-string">"tutorials"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) let url = <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(fileURLWithPath: file!) let data = <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>(contentsOfURL: url) let json = try! <span class="hljs-built_in"><span class="hljs-built_in">NSJSONSerialization</span></span>.JSONObjectWithData(data!, options: []) print(json)</code> </pre><br>  You can use base classes to connect to a file and extract data in JSON format appropriately: <i>NSBundle -&gt; NSURL -&gt; NSData -&gt; NSJSONSerialization.</i> <br><br>  The <b>NS</b> prefix in Swift 3 is not used, so it all comes down to <i>Bundle -&gt; URL -&gt; Data -&gt; JSONSerialization ():</i> <br><br><pre> <code class="objectivec hljs">let file = Bundle.main().pathForResource(<span class="hljs-string"><span class="hljs-string">"tutorials"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) let url = URL(fileURLWithPath: file!) let data = try! Data(contentsOf: url) let json = try! JSONSerialization.jsonObject(with: data) print(json)</code> </pre><br>  For this procedure for changing the naming, you can check out this sentence <a href="">written by Tony Parker and Philip Hausler.</a> <br><br><h3>  M_PI vs .pi </h3><br>  Let's calculate the circles and the area of ‚Äã‚Äãa circle with a given radius: <br><br><pre> <code class="objectivec hljs">let r = <span class="hljs-number"><span class="hljs-number">3.0</span></span> let circumference = <span class="hljs-number"><span class="hljs-number">2</span></span> * M_PI * r let area = M_PI * r * r</code> </pre><br>  For older versions of Swift, you use <b>M_PI</b> to denote the constant <b>pi</b> .  Swift 3 integrates the constant <b>pi</b> into the type <b>Float</b> , <b>Double</b> and <b>CGFloat</b> : <br><br><pre> <code class="objectivec hljs">Float.pi Double.pi <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>.pi</code> </pre><br>  The above code snippet will be written like this in Swift 3: <br><br><pre> <code class="objectivec hljs">let r = <span class="hljs-number"><span class="hljs-number">3.0</span></span> let circumference = <span class="hljs-number"><span class="hljs-number">2</span></span> * Double.pi * r let area = Double.pi * r * r</code> </pre><br>  With the help of inference type, you can even omit the type.  Here is the short version: <br><br><pre> <code class="objectivec hljs">let r = <span class="hljs-number"><span class="hljs-number">3.0</span></span> let circumference = <span class="hljs-number"><span class="hljs-number">2</span></span> * .pi * r let area = .pi * r * r</code> </pre><br><h3>  Grand central dispatch </h3><br>  Grand Central Dispatch is used for network operations that do not block the user interface in the main thread.  It is written in C and its API is very complex for novice developers, even to perform simple tasks, such as creating an asynchronous queue and performing some operations: <br><br><pre> <code class="objectivec hljs">let queue = dispatch_queue_create(<span class="hljs-string"><span class="hljs-string">"Swift 2.2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(queue) { print(<span class="hljs-string"><span class="hljs-string">"Swift 2.2 queue"</span></span>) }</code> </pre><br>  Swift 3 eliminates all template code and redundant material by adopting an object-oriented approach: <br><br><pre> <code class="objectivec hljs">let queue = DispatchQueue(label: <span class="hljs-string"><span class="hljs-string">"Swift 3"</span></span>) queue.async { print(<span class="hljs-string"><span class="hljs-string">"Swift 3 queue"</span></span>) }</code> </pre><br>  For more information about this change, you can <a href="">read written by Matt Wright</a> . <br><br><h3>  Core Graphics now more Swifty </h3><br>  Core Graphics is a powerful graphical framework, but it uses a C-like interface similar to GCD: <br><br><pre> <code class="objectivec hljs">let frame = <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, width: <span class="hljs-number"><span class="hljs-number">100</span></span>, height: <span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> View: <span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> { override func drawRect(rect: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>) { let context = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>() let blue = <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>.blueColor().CGColor <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetFillColorWithColor</span></span>(context, blue) let red = <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>.redColor().CGColor <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetStrokeColorWithColor</span></span>(context, red) <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetLineWidth</span></span>(context, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CGContextAddRect</span></span>(context, frame) <span class="hljs-built_in"><span class="hljs-built_in">CGContextDrawPath</span></span>(context, .FillStroke) } } let aView = View(frame: frame)</code> </pre><br>  You create a view frame by extending the UIView class by overriding the DrawRect () method. <br><br>  Swift 3 takes a completely different approach - first it expands the current graphics context and performs all the drawing operations that are subsequently associated with it: <br><br><pre> <code class="objectivec hljs">let frame = <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, width: <span class="hljs-number"><span class="hljs-number">100</span></span>, height: <span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> View: <span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> { override func draw(_ rect: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>) { guard let context = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } let blue = <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>.blue().cgColor context.setFillColor(blue) let red = <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>.red().cgColor context.setStrokeColor(red) context.setLineWidth(<span class="hljs-number"><span class="hljs-number">10</span></span>) context.addRect(frame) context.drawPath(using: .fillStroke) } } let aView = View(frame: frame)</code> </pre><br>  <b>Note: The</b> <i>context will be null before calling the <b>DrawRect ()</b> method, so you need to expand it using the guard expression ‚Äî more on this <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html">here</a> .</i> <br><br><h3>  Convention on the naming of verbs and nouns </h3><br>  Time for grammar!  The groups of methods in Swift 3 fall into two categories: methods that return some meaning ‚Äî implied as nouns ‚Äî and methods that perform a certain kind of action ‚Äî implied as verbs. <br><br>  Here you can output from 10 to 1: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1.</span></span>.<span class="hljs-number"><span class="hljs-number">.10</span></span>).reverse() { print(i) }</code> </pre><br>  You use the <b>reverse ()</b> method to change the range.  Swift 3 treats this operation as a noun, as it returns the original range in reverse order.  It adds the ‚Äúed‚Äù suffix to the method: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1.</span></span>.<span class="hljs-number"><span class="hljs-number">.10</span></span>).reversed() { print(i) }</code> </pre><br>  The most common use of tuples is to output the contents of an array: <br><br><pre> <code class="objectivec hljs">var array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array.enumerate() { print(<span class="hljs-string"><span class="hljs-string">"\(index + 1) \(value)"</span></span>) }</code> </pre><br>  Swift 3 treats this method as a noun, since it returns a tuple containing the current index and value of this array, and adds the suffix ‚Äúed‚Äù to it: <br><br><pre> <code class="objectivec hljs">var array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array.enumerated() { print(<span class="hljs-string"><span class="hljs-string">"\(index + 1) \(value)"</span></span>) }</code> </pre><br>  Another example is array sorting.  Here is an example of how you can sort an array in ascending order: <br><br><pre> <code class="objectivec hljs">var array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] let sortedArray = array.sort() print(sortedArray)</code> </pre><br>  Swift 3 treats this operation as a noun, as it returns a sorted array.  The <b>sort</b> method is now called <b>sorted</b> : <br><br><pre> <code class="objectivec hljs">var array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] let sortedArray = array.sorted() print(sortedArray)</code> </pre><br>  Let's sort the array, without using an intermediate constant.  In Swift 2, you can call a function like this: <br><br><pre> <code class="objectivec hljs">var array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] array.sortInPlace() print(array)</code> </pre><br>  You use <b>sortInPlace ()</b> to sort the variable array.  Swift 3 treats this method as a verb, since it performs the actual sorting without returning values.  It uses only the base word that describes the action.  So <b>sortInPlace () is</b> now called <b>sort ()</b> : <br><br><pre> <code class="objectivec hljs">var array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] array.sort() print(array)</code> </pre><br>  For more information on the naming convention, you can check out the <a href="https://swift.org/documentation/api-design-guidelines/"><b>API Design Guidelines</b></a> . <br><br><h3>  API in Swift </h3><br>  Swift 3 adopts a simple philosophy for its APIs ‚Äî drop unnecessary words, so if something is superfluous or can be taken out of context, remove it: <br><br><ul><li>  XCPlaygroundPage.currentPage becomes PlaygroundPage.current </li><li>  button.setTitle (forState) becomes button.setTitle (for) </li><li>  button.addTarget (action, forControlEvents) becomes button.addTarget (action, for) </li><li>  NSBundle.mainBundle () becomes Bundle.main () </li><li>  NSData (contentsOfURL) becomes a URL (contentsOf) </li><li>  NSJSONSerialization.JSONObjectWithData () becomes JSONSerialization.jsonObject (with) </li><li>  UIColor.blueColor () becomes UIColor.blue () </li><li>  UIColor.redColor () becomes UIColor.red () </li></ul><br><h3>  Enum </h3><br>  Swift 3 treats the enumeration as a property, so use <b>lowerCamelCase</b> instead of <b>upperCamelCase</b> for them: <br><br><ul><li>  .System becomes .system </li><li>  .TouchUpInside becomes .touchUpInside </li><li>  .FillStroke becomes .fillStroke </li><li>  .CGColor becomes .cgColor </li></ul><br><h3>  @discardableResult </h3><br>  In Swift 3, Xcode will show you a warning if you are not using the return value of a function or method.  Here is an example: <br><br><img src="http://www.appcoda.com/wp-content/uploads/2016/06/discardable-result-1.png" alt="image"><br><br>  In the above code, the <b>printMessage</b> method returns the received message for the caller.  However, the return value is not used.  This can be a potential problem, so the compiler in Swift 3 will give you a warning. <br><br>  In this case, if it is not a processed return value.  You can suppress the warning by adding <b>@discardableResult</b> in the method declaration: <br><br><pre> <code class="objectivec hljs">override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() printMessage(message: <span class="hljs-string"><span class="hljs-string">"Hello Swift 3!"</span></span>) } @discardableResult func printMessage(message: String) -&gt; String { let outputMessage = <span class="hljs-string"><span class="hljs-string">"Output : \(message)"</span></span> print(outputMessage) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outputMessage }</code> </pre><br><h3>  Conclusion </h3><br>  It's all about Swift 3. The new version of Swift is one of the major releases, which makes the language even better.  It contains many fundamental changes that can certainly affect your existing code.  I hope that this article will help you better understand the changes, and hopefully will save you some time to transfer your project to Swift. </div><p>Source: <a href="https://habr.com/ru/post/312942/">https://habr.com/ru/post/312942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312930/index.html">What is new in licensing Windows Server 2016 and how can you avoid unnecessary expenses?</a></li>
<li><a href="../312932/index.html">Algorithm of reading books on programming</a></li>
<li><a href="../312934/index.html">Setting up a dedicated Source server for Linux, part 3</a></li>
<li><a href="../312936/index.html">Setting up a Source Source Server for Linux, Part 4</a></li>
<li><a href="../312940/index.html">Free courses, books and other development materials</a></li>
<li><a href="../312948/index.html">How I created seamless Wi-Fi</a></li>
<li><a href="../312950/index.html">Simplicity criteria</a></li>
<li><a href="../312952/index.html">Entertaining task ‚ÄúUnlucky Ticket‚Äù (Elixir edition)</a></li>
<li><a href="../312954/index.html">How to find subdomains in minutes?</a></li>
<li><a href="../312956/index.html">Use Veeam Cloud Connect. Store client backups and replicas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>