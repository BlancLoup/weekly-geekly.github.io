<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Template Metaprogramming for AVR Microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AVR 
 Atmel AVR microcontrollers are well known to developers and do not need any special introduction. These devices use a modified Harvard architect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Template Metaprogramming for AVR Microcontrollers</h1><div class="post__text post__text-html js-mediator-article"><h1>  AVR </h1><br>  Atmel AVR microcontrollers are well known to developers and do not need any special introduction.  These devices use a modified Harvard architecture and demonstrate decent performance with low power consumption.  Apparently it is no exaggeration to say that today's popularity of AVR is largely due to the Arduino project. <br><a name="habracut"></a><br><h1>  Arduino </h1><br>  Arduino is an open platform for prototyping.  Currently available in a rich variety of different Arduino boards and additional devices.  An easy-to-learn subset of the C programming language, along with a rich set of libraries created by enthusiasts from around the world, allow you to create any application to solve an almost unlimited number of tasks.  Both a professional and a beginner in programming have the ability to quickly test any idea or create a prototype of the future device in the shortest possible time.  However, it is unlikely that anyone will use the Arduino software for real projects.  The main reason is the inefficiency of the resulting code [8].  The desire for versatility and simplicity of the Arduino toolkit does not allow to fully use the potential of the AVR microcontroller, its performance and the natural possibilities of parallelism. <br><br><h1>  Embedded Software Development Approaches </h1><br><h1>  Old school </h1><br>  Representatives of the old school are experts in the field of both software and hardware.  Their tools are C language and assembler.  Their main goal is to squeeze everything from each byte, to achieve maximum code performance with minimal memory usage and power consumption.  At the same time, the code created by them is not always easy to understand, which can greatly complicate further support and development of the code. <br><br><h1>  New school </h1><br>  People brought up in the epoch of objects tend to see an object in every entity.  Classes are a great example of reusable code.  The use of classes encourages the developer to achieve a better code structure and thoughtful distribution of responsibilities between components.  Properly written object-oriented code is easy to understand and maintain.  The disadvantages of code written using C ++ are often its performance.  Object-oriented features of the language are its undoubted advantage, but it often has to be paid for.  Automatic generation of methods, the implicit creation of temporary objects can lead to a noticeable decrease in <strike>performance</strike> efficiency (thanks to <a href="https://geektimes.ru/users/prostotyoma/" class="user_link">ProstoTyoma</a> ) of the resulting code [7].  Developing effective C ++ code is a kind of art. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  C ++ Templates </h1><br>  One of the strengths of C ++ is the template engine.  The main idea is the possibility of a generalized definition of code behavior without explicitly specifying the entities used.  As an obvious example of using templates, you can cite a standard template library.  STL provides three basic types of entities ‚Äî containers, algorithms, and iterators.  Generic containers allow you to specify the required types of stored data at the point of use.  Algorithms do not know anything about containers;  communication algorithms and containers through the mechanism of iterators.  Thus, STL demonstrates amazing flexibility and allows you to solve an infinite number of practical problems. <br><br>  The undoubted advantage of template classes is that the compiler instantiates only those class methods that are actually used in the code.  The rest of the code passes only a syntax correctness check.  This eliminates unused code and thus reduces memory consumption.  The specialization mechanism allows you to fine-tune the behavior depending on the template parameters, which provides excellent opportunities for code optimization.  The disadvantage of templates is the complexity of development and the unfriendliness of the compiler to the template code. <br><br>  The idea of ‚Äã‚Äãtemplates is easiest to show by example: <br><br>  Suppose we need the min function to work with integers.  The obvious solution for a C programmer would be something like: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &lt; b) ? a : b; }</code> </pre> <br>  If a similar function is needed for working with a floating point, you will have to write another function: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &lt; b) ? a : b; }</code> </pre><br>  Each new type will require a new feature. <br>  For a C ++ programmer, the problem is solved by writing something like the following template: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a, T b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &lt; b) ? a : b; }</code> </pre><br><br>  In this case, the type of values ‚Äã‚Äãused is not explicitly indicated; instead, we use the notation T, which is present in the template definition with the keyword typename.  For template functions (as well as class methods), the compiler is able to independently deduce the required parameter type based on the types of values ‚Äã‚Äãpassed.  If a pair of parameters with different types is passed to this min function, the compiler will justifiably express its dissatisfaction.  Moreover, if the transfer of parameters of different types is done intentionally, it is possible to help the compiler by explicitly specifying the type of the template parameter when calling the function: <br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> float_variable = <span class="hljs-number"><span class="hljs-number">3.141</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> integer_variable = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(float_variable, integer_variable);</code> </pre><br>  or depending on what you need: <br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(float_variable, integer_variable);</code> </pre><br>  The function declared in this way can work with any data type, the only condition is the presence of the operation "&lt;" (less) defined for this type.  This is very similar to the behavior of languages ‚Äã‚Äãwith dynamic typing, but there is a fundamental difference.  In languages ‚Äã‚Äãlike Python, a function can exist in a single copy.  Being a language with <strike>strict</strike> static (thanks to <a href="https://geektimes.ru/users/0xd34df00d/" class="user_link">0xd34df00d</a> ) typing, C ++ will require a separate function instance for each type used with it.  Here we rely entirely on the compiler, which does all this work for us and creates the necessary object code for each type used. <br><br>  Very convenient, but it is this circumstance that can cause another problem of the templates - the code bloat.  This particular function is not a problem, since it is small in size and is an obvious candidate for inlining.  However, the presence in the code of many differently parameterized instances of template classes that have volumetric methods can actually lead to a significant increase in the code, thus creating a real problem.  Todd Veldhuzen makes recommendations [5] to avoid this. <br><br><h1>  Meta programming </h1><br>  In 1994, at a meeting of the C ++ Standardization Committee, Erwin Unruh for the first time demonstrated the ability to perform computations at the compilation stage.  During the compilation process, the code presented to them produced a series of diagnostic messages containing the values ‚Äã‚Äãof a series of prime numbers.  Further studies have shown that the possibilities of performing mathematical operations are computationally complete [6]: indeed, it is possible to use arithmetic operations, organize cycles through the use of recursion, and branching through the use of specializations. <br><br>  Some similarity between patterns and habitual execution time functions was noticed [3]. <br><br>  The template parameters play the role of the parameters of ordinary functions, and the nested types and constant values ‚Äã‚Äãof enumerated types are analogous to the returned values.  As parameters of metafunctions and return values, the same entities that can be template parameters can be used, these include: <br>  - constant values ‚Äã‚Äãof enumerated types, <br>  - types as well <br>  - pointers <br><br><h1>  1. The simplest and most understandable case is the use of enumerated types. </h1><br>  The following meta-function raises the value of BASE to the power of PWR. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> //   &lt; unsigned PWR, unsigned BASE = <span class="hljs-number"><span class="hljs-number">10</span></span> //    //      &gt; struct power { enum{<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = BASE * power&lt;PWR<span class="hljs-number"><span class="hljs-number">-1</span></span>,BASE&gt;::<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>}; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;unsigned BASE&gt; //   struct power&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>,BASE&gt; { enum{<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>}; };</code> </pre><br><br>  As you can see, to calculate the result, the power pattern calls itself recursively with a modified PWR value.  To prevent infinite recursion, specialization is needed, in this case for a zero PWR value. <br><br>  Usage example: <br><pre> <code class="hljs ruby">unsigned KILO = power&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:value</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  KILO    <span class="hljs-number"><span class="hljs-number">1000</span></span> unsigned MEGA = power&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:value</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  MEGA    <span class="hljs-number"><span class="hljs-number">1000000</span></span> unsigned kBytes = power&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:value</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  kBytes    <span class="hljs-number"><span class="hljs-number">1024</span></span></code> </pre><br><br><h1>  2. Calculations over types </h1><br>  Imagine that we need to pass an input parameter of type ValueType to the function.  We would like the optimal method for passing a parameter (by a constant link or by value) to be selected automatically, depending on the target platform and the size of a particular type of parameter. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PARAM</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type_selector&lt; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ValueType*) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ValueType)), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ValueType&amp;, ValueType &gt;::type type; };</code> </pre><br><br>  The type_selector template used inside our meta-function is described by many authors [for example 3, 4] and may look like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> //   &lt; <span class="hljs-type"><span class="hljs-type">bool</span></span> CONDITION, //   typename TYPE0, // ,     ,    typename TYPE1 // ,     ,    &gt; struct type_selector { typedef TYPE0 <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; }; //     CONDITION == <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename TYPE0,typename TYPE1&gt; struct type_selector&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>,TYPE0,TYPE1&gt; { typedef TYPE1 <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; };</code> </pre><br><br>  Depending on the value of the CONDITION condition, the type_selector template selects either TYPE0 (CONDITION == true) or TYPE1 (CONDITION == false).  As a condition in this case, we use the logical expression: sizeof (ValueType)&gt; sizeof (ValueType *).  For example, if the parameter is of type uint32_t, we use the following definition for our function: <br><br><pre> <code class="hljs actionscript"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typename PARAM&lt;uint32_t&gt;::type value)</span></span></span></span>{...}</code> </pre><br><br>  In this case, the compiler requires the typename keyword to be specified before referring to the template, since the type used to pass the parameter is nested.  Such a declaration / definition of a function looks somewhat cumbersome, however, the task is solved: - on 32 and 64-bit platforms the parameter will be passed by value, and for example, if compiled under an AVR microcontroller, where the address size is two bytes, the parameter will be transmitted by a constant link. <br><br><h1>  3. Pointers as template parameters </h1><br>  Suppose, inside some code, we need to make a callback call, a function whose type is defined as: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">CALLBACK_FUNCTION_TYPE</span></span>)(); <span class="hljs-comment"><span class="hljs-comment">//  callback </span></span></code> </pre><br><br>  Now, by defining our code as a template: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/       cb_func, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   CALLBACK_FUNCTION_TYPE template&lt;CALLBACK_FUNCTION_TYPE cb_func&gt; void some_code(...) { ... cb_func(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ... }</span></span></code> </pre><br><br>  we can pass the required function when calling our code as follows: <br><br><pre> <code class="hljs lisp"> some_code&lt;&amp;our_callback_function&gt;(...)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><br>  Since the address of our_callback_function is known at compile time, it can be successfully inlined by the compiler [5].  You can read about the impact of embedding functions on the size and efficiency of a code [7] - the three chapters of this book are entirely devoted to issues of embedding functions.  In his article [5], Todd Veldhusen demonstrates very interesting examples of using meta-functions, including loop unfolding using the example of the dotproduct function for matrix multiplication, the calculation of trigonometric constants for Fast Fourier Transform algorithms by summing a series.  Here it is important to understand that during execution all these actions have zero cost, since they are performed at the compilation stage. <br><br><h1>  Design </h1><br>  When it comes to code that is supposed to be used repeatedly, the question of the interface comes to the fore.  The importance of a well-defined interface has been repeatedly discussed on the Web.  The set of requirements traditionally imposed on a good interface includes correctly defined abstractions, hiding implementation details, minimality and sufficiency, ease of use, complexity or impossibility of improper use, and others [9].  When using metaprogramming, some of the requirements can be realized only by great efforts, and some may not be realized at all.  The fact that the language property used in our case was discovered by chance, explains the reason for the rather awkward syntax.  This does not add convenience when developing metaprogram code and using template-based interfaces.  The impossibility of specifying diagnostic messages during compilation makes control over the correct use of the code difficult to implement, although some attempts have been made in this direction, for example Static assertions in the boost library and new language standards. <br><br>  When developing code to control a hardware device, you must provide the user with full control over all of his (device) components.  At the same time the requirement of minimality in the interface remains.  A reasonable approach here seems to be the use of the correct order of parameters in the device interface.  The most frequently changed parameters should go first, for all others (parameters), you should determine the default values ‚Äã‚Äãcorresponding to the most typical use cases. <br><br>  A convenient approach to building an interface is design using classes of strategies, described in [1, 2].  The idea is very simple.  Part of the implemented functionality is delegated to external classes (strategies), which are used as template parameters.  If you need to change the behavior, just choose another strategy.  This is very similar to the use of parameters of ordinary (runtime) functions, where, thanks to parameters, we have the opportunity to get different results when passing various values ‚Äã‚Äãof arguments to a function.  A function with hard-coded argument values ‚Äã‚Äãwill always return the same result, which does not make much sense.  As template parameters (strategies) types (classes) with full functionality can be used.  This makes it possible to parameterize the algorithm at the point of use by specifying strategies with the required behavior as template arguments.  This gives a new level of flexibility and generalization. <br><br>  Consider an example implementation of a USART device interface (Universal Synchronous Asynchronous Transceiver) included in a typical AVR controller. <br><br><pre> <code class="hljs ruby">enum USART_ID /<span class="hljs-regexp"><span class="hljs-regexp">/   { USART0, USART1, USART2, USART3, }; enum BAUD_RATE /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   { BR_2400 = 2400, ... BR_921600 = 921600, BR_CUSTOM = CUSTOM_BAUD_RATE }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -   ( ) template &lt; BAUD_RATE baud = BR_9600, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    (enum) DATA_BITS data_bits = DATA_BITS_8, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      (enum) PARITY parity = NO_PARITY, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  (enum) STOP_BITS stop_bits = STOP_1, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (enum) ... &gt; struct FRAME_CONTROL;</span></span></code> </pre><br><br>  Strong C ++ typing will require as parameters the specification of values ‚Äã‚Äãthat exactly correspond to the declared data types.  For example, to indicate the rate of exchange, only those values ‚Äã‚Äãthat are declared in the BAUD_RATE enumeration can be selected.  If you need some special (non-standard) speed value, you can use the value BR_CUSTOM, after announcing the macro CUSTOM_BAUD_RATE with the desired value of the data transfer rate. <br><br>  The definition of the USART class is as follows: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">template</span></span> &lt; <span class="hljs-type"><span class="hljs-type">USART_ID</span></span> id, //   (enum) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> usart_ctrl = <span class="hljs-type"><span class="hljs-type">FRAME_CONTROL</span></span>&lt;&gt;, //   - () -  <span class="hljs-type"><span class="hljs-type">FRAME_CONTROL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> receiver = <span class="hljs-type"><span class="hljs-type">USART_RECEIVER</span></span>&lt;&gt;, //   - () -  <span class="hljs-type"><span class="hljs-type">USART_RECEIVER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> transmitter = <span class="hljs-type"><span class="hljs-type">USART_TRANSMITTER</span></span>&lt;&gt; //   - () -  <span class="hljs-type"><span class="hljs-type">USART_TRANSMITTER</span></span> &gt; struct <span class="hljs-type"><span class="hljs-type">USART</span></span> { static void inline init(){...} static size_type send(const uint8_t* <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, size_type data_size){...} static size_type print(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">, ...){...} static size_type _vprintf(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">va_list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ap</span></span></span><span class="hljs-class">){...} ... static void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">USART_UDRE_handler</span></span></span><span class="hljs-class">(){...} };</span></span></code> </pre><br><br>  Here for brevity, the definition of many enumerations and structures is omitted.  For use in real code, we include a header file with a description of all these structures using the include directive and determine the required parameters for our device: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#define SEND_BUFFER_SIZE 32 #define RECV_BUFFER_SIZE 16 typedef USART</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; USART0, FRAME_CONTROL&lt;BR_921600&gt;</span></span></span><span class="hljs-meta">, RECEIVER_DISABLED, USART_TRANSMITTER</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SEND_BUFFER_SIZE&gt;</span></span></span><span class="hljs-meta"> &gt; usart_0; //  USART0,  921600 , 8N1,   ,   32  typedef USART</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; USART1, FRAME_CONTROL&lt;BR_9600, DATA_BITS_7, EVEN_PARITY, STOP_2&gt;</span></span></span><span class="hljs-meta"> USART_RECEIVER</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;RECV_BUFFER_SIZE&gt;</span></span></span><span class="hljs-meta">, USART_TRANSMITTER</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SEND_BUFFER_SIZE&gt;</span></span></span><span class="hljs-meta"> &gt; usart_1; //  USART1, 9600-7E2,   16 ,   32  typedef TWI</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;400000&gt;</span></span></span><span class="hljs-meta"> I2C; // TWI -  400 kHz</span></span></code> </pre><br><br>  So, the USART structure accepts four template parameters: <br>  - device identifier - allows you to work with any of the four available devices (only Mega256, for lower chips you should use USART0) <br>  - usart_ctrl strategy with a single implementation - FRAME_CONTROL - for the specification of exchange parameters (see above). <br>  - receiver strategy - a receiver for which there are only two implementations - USART_RECEIVER, which allows you to set the required receiver parameters (specify the buffer size and control the interrupt) and RECEIVER_DISABLED, which allows you to disable the receiver if necessary <br>  - transmitter strategy ‚Äî transmitter parameters with implementations USART_TRANSMITTER (buffer size, interrupt control) and TRANSMITTER_DISABLED, which disables the transmitter and the corresponding interrupts. <br><br>  This set of strategies provides complete control over the device and, through the use of default values, simplifies the parameterization of the class for the most typical use cases. <br><br>  Next, we initialize the device: <br><br><pre> <code class="hljs swift"> usart_0::<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(); <span class="hljs-type"><span class="hljs-type">I2C</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>();</code> </pre><br><br>  Here you should pay attention to the unusual syntax of the method call.  Instead of the usual ‚Äú.‚Äù Operator, there is a reference to a member of the structure (structure reference), here the operator ‚Äú::‚Äù is used - the disclosure of scope.  The fact is that all the methods of the USART class (as well as TWI) are defined as static, and here we work not with objects, but with types.  This avoids the overhead of the construction and destruction of the object, and in addition, clearly reflects the singleton-like nature of the device.  This does not mean that we completely abandon normal objects in favor of using types and their static members.  Most likely, the code will contain many familiar objects, but if we talk about structures for controlling hardware components, this approach makes more sense. <br><br>  The assembler generated for this (for Mega256) looks something like this: <br><br><pre> <code class="hljs xml">000000ba <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">_Z10usart_initv</span></span></span><span class="hljs-tag">&gt;</span></span>: ba: 10 92 c4 00 sts 0x00C4, r1 be: 10 92 c5 00 sts 0x00C5, r1 c2: 10 92 c0 00 sts 0x00C0, r1 c6: 88 e2 ldi r24, 0x28 ; 40 c8: 80 93 c1 00 sts 0x00C1, r24 cc: 86 e0 ldi r24, 0x06 ; 6 ce: 80 93 c2 00 sts 0x00C2, r24 d2: 10 92 26 01 sts 0x0126, r1 d6: 08 95 ret 000000d8 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">_Z8twi_initv</span></span></span><span class="hljs-tag">&gt;</span></span>: d8: 8c e0 ldi r24, 0x0C ; 12 da: 80 93 b8 00 sts 0x00B8, r24 de: 10 92 b9 00 sts 0x00B9, r1 e2: 85 e4 ldi r24, 0x45 ; 69 e4: 80 93 bc 00 sts 0x00BC, r24 e8: 10 92 03 01 sts 0x0103, r1 ec: 08 95 ret</code> </pre><br><br>  From the above listing, it is clear that calculations of all the necessary constants for initializing devices are performed at the compilation stage. <br><br><h1>  One more example </h1><br>  If we develop our own exchange protocol, its announcement (using strategies) may look like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transport</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PROTO_PARAMETERS</span></span></span><span class="hljs-class">&lt;...&gt; // -    ... &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SUPER_DUPPER_EXCHANGE_PROTOCOL</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><br>  Here the following point is interesting: the transport for the protocol is specified as a template parameter.  This allows you to customize our protocol at the point of use, for example: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> SUPER_DUPPER_EXCHANGE_PROTOCOL&lt;usart_0, PROTO_PARAMETERS&lt;&gt;, ...&gt; PROTO_SERIAL;</code> </pre><br><br>  If you wish, we can use the same protocol with another device, such as SPI or TWI, that is: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">typedef SUPER_DUPPER_EXCHANGE_PROTOCOL</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TWI</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">200000</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">, PROTO_PARAMETERS</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">, ...&gt; PROTO_TWI;</span></span></code> </pre><br><br>  For strategy classes, there are no additional restrictions, such as the requirement to inherit from a common ancestor.  The only requirement for the type used as a transport is the presence of methods (for example, send and receive) with the required signature. <br><br>  Any necessary number of strategies can be defined, each of which should be responsible for a certain aspect of functionality, thus ensuring their orthogonality [2]. <br><br>  For each strategy, in turn, there may be many different implementations.  As a result, the number of different behaviors (many possible combinations of strategies) can be quite large.  This provides excellent code flexibility without introducing typical performance problems associated with inheritance and is an excellent example of static polymorphism. <br><br>  Having thus determined the types we need, we use them in the code as follows: <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">PROTO_SERIAL</span></span>::send(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, size); //   </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">   usart_0 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PROTO_TWI</span></span></span><span class="hljs-class">::send(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">); //   </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">  </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TWI</span></span></span><span class="hljs-class"> </span></span></code> </pre><br><br><h1>  Debugging </h1><br>  There is no need to repeat that debugging software code is not an easy task.  Debugging the template code presents even more difficulties for the developer due to the unfriendliness of the compiler.  Any typo in the text leads to the conclusion of long diagnostic listings, which are additionally doubled due to the two-pass compiler mode.  It is necessary to read these listings from the very beginning, making the minimum number of code modifications before another compilation attempt.  Some messages may be caused by induced errors and disappear when the error is corrected - the root causes. <br><br>  Pattern specializations are not related to the primary template by any kindred relationship.  In fact, the specialization can be considered as a separate independent class, which is substituted for the primary template in case of coincidence of specialized parameters.  Thus, in order to be at least somewhat confident in the performance of the template code, you need to at least once instantiate each template specialization.  All this makes the process of debugging template code quite a long process. <br><br>  Debugging embedded code, in turn, can be a nightmare for the developer, especially in the absence of special equipment.  In this case, the only way out is the brute force method - inserting debug messages. <br><br>  Suppose we are debugging the DEVICE class, which has the following interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DEVICE_SETTINGS</span></span></span><span class="hljs-class">&lt;...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbg</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NO_DEBUG</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DEVICE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parameter)</span></span></span><span class="hljs-function"> </span></span>{ dbg::print(<span class="hljs-string"><span class="hljs-string">"%s:%d\n"</span></span>, __FUNCTION__, parameter); .... dbg:: print(<span class="hljs-string"><span class="hljs-string">"retval:%d\n"</span></span>, retval); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; } };</code> </pre><br><br>  Here we are interested in the template parameter dbg, which by default is initialized with the value NO_DEBUG.       dbg::print. <br>         : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> DEVICE_SETTINGS&lt;...&gt; DEV_SETTINGS; <span class="hljs-comment"><span class="hljs-comment">//  typedef   typedef DEVICE&lt;DEV_SETTINGS, AVR_DEBUG&lt;usart_0&gt; &gt; device; //    </span></span></code> </pre><br><br> ,     dbg     AVR_DEBUG,   usart_0.     AVR_DEBUG,     : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SENDER</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVR_DEBUG</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* fmt, ...)</span></span></span><span class="hljs-function"> </span></span>{ va_list ap; va_start(ap, fmt); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> retval = SENDER::_vprintf(fmt, ap); va_end(ap); } };</code> </pre><br><br> ,  ,       dbg::print      print  AVR_DEBUG&lt;usart_0&gt;,       _vprintf  usart_0.  ,           ,   usart_0. <br><br>            : <br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> DEVICE&lt;DEV_SETTINGS, NO_DEBUG&gt; device;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or more simply, use the default value NO_DEBUG for the dbg parameter: </font></font><br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> DEVICE&lt;DEV_SETTINGS&gt; device;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The implementation of the print function of the NO_DEBUG class has an empty body and may look like this: </font></font><br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NO_DEBUG</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* , ...)</span></span></span></span>{} };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we again rely on a compiler that successfully performs inlining and removal of bodies of empty functions. </font><font style="vertical-align: inherit;">When assembling the release version of the code, all unused code will be deleted. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we have a mechanism to control the output of debug information.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmel recommends using the minimum data types for storing data in its documents. The recommendation is based on the analysis of the size of the resulting code, reduces the cost of memory used by the application and implies the use of types whose size does not depend on the platform. And this in turn contributes to the creation of a code that has better portability (portability). Ideally, we can get the opportunity to run our code on a PC, which during development allows us to use unit tests. Much of the code intended for the microcontroller can be tested on tests long before it is downloaded to the controller.</font></font><br><br>       ,          (mock/fake),        ,     . <br><br>    ,         PC. <br>   ,     ,      (TWI, SPI...)          .      ,   ,    ..              .     () . <br><br>    ,          .  ,         .                 (COM  USB),     .          ,        . ,         ,            .         ,      . <br><br>                .           SD card  SPI  (    serial to SPI),         ,  TWI  (    serial to TWI). <br><br>    [ <a href="https://github.com/FatherMcKenzie/avr_meta">avr_meta</a> ]       .     avr8-gnu-toolchain-3.4.5.1522-linux,   -   TUT (C++ Template Unit Test Framework).           .        ,   -    : <br><pre> <code class="hljs 1c">bin  ,  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  . avr_adc  <span class="hljs-keyword"><span class="hljs-keyword"></span></span> AVR ADC ‚Äì Analog to Digital Converter avr_debug <span class="hljs-built_in"><span class="hljs-built_in"></span></span> AVR_DEBUG avr_interrupt/ext_int_control  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    AVR avr_interrupt/pin_ch_int_control  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  Pin Change  AVR avr_misc   avr_pin  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   AVR avr_power_mgmt  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   AVR avr_spi  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  AVR SPI ‚Äì Serial Peripheral Interface avr_twi  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  AVR <span class="hljs-number"><span class="hljs-number">2</span></span>-wire Serial Interface (  ) avr_usart  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  AVR USART (  ) container/bit_field   bit field container/circular_buffer   event_driven  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    meta   misc   state/led_blinker    () state/state_machine     state/switch_case <span class="hljs-built_in"><span class="hljs-built_in"></span></span> switch case</code> </pre><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of object-oriented features of the C ++ language allows you to improve the structure, readability and clarity of the code. Classes are the perfect embodiment of code reuse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The flexibility inherent in templates allows the development of a generic and at the same time very efficient code. Independence of the code on the types of data used allows you to make many design decisions at the final stage of development or modify these solutions without significant alterations of the source code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of strategies can provide many variants of code behavior without the use of inheritance and typical performance problems inherent in dynamic polymorphism. Template specializations provide the developer with excellent opportunities to optimize and fine tune code behavior.</font></font><br><br>    C++,    1994   ,       ,      .                .        C++       , ,  Blitz++  boost::MPL. <br><br> ,               ,           .     (  )         ( ),      ( ).    C++   (two-level language). <br><br>             ,       .    ,        (   ) ‚Äî        .  ,       ,   ,   ,      .  ,      ,     .   [10]      ,   AVR          Atmel . <br><br>           -    . ,      ,    ,            [3]. <br><br>   (portability)               .      ,      .           .  ,   ,           ,  ,            . <br><br>     ,             ,         .      -       ,     C  ASM . <br><br><h1>  Literature </h1><br> 1. David Vandevoorde and Nicolai M. Josuttis. C++ Templates: The Complete Guide <br> 2. Andrei Alexandrescu. C++ Design: Generic Programming and Design Patterns Applied <br> 3. David Abrahams and Aleksey Gurtovoy, C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond <br> 4. Davide Di Gennaro. Advanced C++ metaprogramming <br> 5. Todd Veldhuizen. Techniques for Scientific C++. Indiana University Computer Science Technical Report #542 <br> 6. Todd L. Veldhuizen. C++ Templates are Turing Complete (2003). <br> 7. Dov Bulka and David Mayhew. Efficient C++. Performance Programming Techniques. Addison-Wesley 2000. <br> 8. Dale Wheat. Arduino Internals. Apress. <br> 9. Martin Reddy. API Design for C++. 2011 Morgan Kaufmann Publishers <br> 10. Christoph Steup, Michael Schulze, Jorg Kaiser. Exploiting Template-Metaprogramming for Highly Adaptable Device Drivers ‚Äì a Case Study on CANARY an AVR CAN-Driver. Department for Distributed Systems Universitat Magdeburg <br> 11.  XXIV  . ‚Äú        .      ‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/357910/">https://habr.com/ru/post/357910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357900/index.html">Dual axis solar tracker on Arduino</a></li>
<li><a href="../357902/index.html">The Real Truth About Arduino Hate Programmers</a></li>
<li><a href="../357904/index.html">Smart LED flashing in Arduino</a></li>
<li><a href="../357906/index.html">Arduino C ++ 11 library for managing LED arrays</a></li>
<li><a href="../357908/index.html">All lessons on Arduino</a></li>
<li><a href="../357912/index.html">We program Arduino using Sublime + Stino on MacOS</a></li>
<li><a href="../357914/index.html">Software graphic coprocessor on STM32</a></li>
<li><a href="../357916/index.html">Determining that you are at home using a WiFi router (to automate the smart home)</a></li>
<li><a href="../357918/index.html">I2C sniffer</a></li>
<li><a href="../357920/index.html">Arduino <-> STM32 HAL, or there and back</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>