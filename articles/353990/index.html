<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Walk through a fast, secure and almost complete web service on Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Original article 


 For years, I had persistent distrust of interpreted languages. They are fast and it is pleasant to work with them, but they are g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Walk through a fast, secure and almost complete web service on Rust</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://brandur.org/rust-web">Original article</a> </p><br><p>  For years, I had persistent distrust of interpreted languages.  They are fast and it is pleasant to work with them, but they are good only for work on small systems, if you have a fast-growing project their attractiveness quickly disappears.  Creating a large application in Ruby or JavaScript (or many other languages) is an endless Sisyphean task ‚Äî you solve one problem only so that the other immediately rolls down on you from the mountain.  And it does not matter how many tests you write or how good your team is; any new development will create a myriad of errors, the correction of which will take months or years. </p><br><p>  The main problem lies in the border conditions.  Programmers do their best to write and test the ‚Äúhappy path‚Äù, but the human factor prevents us from seeing the problem from all sides and especially the edges and corners that cause the greatest problems while the program is being used. </p><br><p>  Constraints, such as the compiler and the insightful type system, are the tools that help us define these conditions.  All languages ‚Äã‚Äãhave a range of solvability, and I am clearly convinced that the more time is spent writing an application according to the rules of the language, the less time will be spent on troubleshooting. </p><a name="habracut"></a><br><h2 id="rust">  Rusty </h2><br><p>  If it is possible to build reliable systems with programming languages ‚Äã‚Äãwith restrictions, then what about languages ‚Äã‚Äãwith the most stringent restrictions?  I headed to the farthest end of the spectrum and created a highly unpopular web service on Rust for its uncompromising compiler. </p><br><p>  Rust is still a new and relatively rarely used language.  Studying it was not easy - the set of rules of the type system, and the rules of ownership and borrowing, but despite the difficulties, the experience was interesting, the main thing Rust works.  I encounter fewer forgotten border conditions and runtime errors, and refactoring no longer causes horror. </p><br><p>  Next we look at some of the ideas, core libraries, and structures of Rust. </p><br><h2 id="osnovy">  The basics </h2><br><p>  I built my system on <a href="https://github.com/actix/actix-web">actix-web</a> , an <a href="https://github.com/actix/actix-web">actix-built web</a> framework, actor library for Rust.  <a href="https://github.com/actix/actix">Actix</a> is similar to what you might find in Erlang, for example, but it adds another level of reliability and speed using the Rust type and parallelism system.  For example, it is impossible for an actor to receive a message that it cannot process at runtime, because the compiler will check the correspondence of the message types. </p><br><p>  Perhaps you know the name actix - recently <a href="https://github.com/actix/actix-web">actix-web has</a> made its way to the top of <a href="https://www.techempower.com/benchmarks/">TechEmpower</a> tests.  Programs created for such tests are often artificially optimized, but now, among all optimized languages, Rust stands confidently, leaning as far as possible towards such giants as C ++ and Java.  Regardless of how you feel about the accuracy of benchmarks, <a href="https://github.com/actix/actix-web">actix-web</a> works quickly. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff3/5ba/60c/ff35ba60c2789fe59f23464ef0f7776d.png" alt="Rust in the top 10 with Java and C ++ in TechEmpower tests."><br>  <em>Rust in the top 10 with Java and C ++ in TechEmpower tests.</em> </p><br><p>  The author of actix-web (and actix) creates a huge amount of code - the project appeared about six months ago, and it is not only more functional, with better API interfaces than web frameworks in other open source languages, but moreover, more functional frameworks that are funded by large organizations with huge development teams.  Features such as HTTP / 2, WebSockets, streaming responses, graceful shutdown, HTTPS, cookie support, static files serving and a good testing infrastructure are available immediately.  The documentation is still a bit incomplete, but I have not yet encountered any errors. </p><br><h2 id="diesel-i-proverka-vo-vremya-kompilyacii">  Diesel and Compile Check </h2><br><p> I used <a href="http://diesel.rs/">diesel</a> as ORM to talk to Postgres.  ORM is written by a person with extensive experience who spent a lot of time on the front line working with Active Record.  Many of the errors inherent in earlier generations of ORM were eliminated - for example, <code>diesel</code> does not pretend that the SQL dialects in each database are the same, does not use specialized DSL for migration (instead, it uses normal SQL) and it does not manage connections to the database at the global level.  It provides powerful Postgres features such as <code>upsert</code> and <code>jsonb</code> right in the main library and provides, if possible, powerful security mechanisms. </p><br><p>  Most database queries are written using diesel DSL types.  If I use the field incorrectly, I try to insert a tuple into the wrong table or even create an impossible join, the compiler will immediately give an error message.  Here is a typical operation (in this case, Postgres <code>INSERT INTO ... ON CONFLICT</code> ... or "upsert"): </p><br><pre> <code class="rust hljs">time_helpers::log_timed(&amp;log.new(o!(<span class="hljs-string"><span class="hljs-string">"step"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"upsert_episodes"</span></span>)), |_log| { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(diesel::insert_into(schema::episode::table) .values(ins_episodes) .on_conflict((schema::episode::podcast_id, schema::episode::guid)) .do_update() .set(( schema::episode::description.eq(excluded(schema::episode::description)), schema::episode::explicit.eq(excluded(schema::episode::explicit)), schema::episode::link_url.eq(excluded(schema::episode::link_url)), schema::episode::media_type.eq(excluded(schema::episode::media_type)), schema::episode::media_url.eq(excluded(schema::episode::media_url)), schema::episode::podcast_id.eq(excluded(schema::episode::podcast_id)), schema::episode::published_at.eq(excluded(schema::episode::published_at)), schema::episode::title.eq(excluded(schema::episode::title)), )) .get_results(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.conn) .chain_err(|| <span class="hljs-string"><span class="hljs-string">"Error upserting podcast episodes"</span></span>)?) })</code> </pre> <br><p>  More complex SQL is difficult to create using DSL, but, fortunately, there is a great alternative to the built-in include_str!  macro.  It includes the contents of the file at compile time, and we can transfer them to diesel for binding and filling with parameters: </p><br><pre> <code class="rust hljs">diesel::sql_query(<span class="hljs-built_in"><span class="hljs-built_in">include_str!</span></span>(<span class="hljs-string"><span class="hljs-string">"../sql/cleaner_directory_search.sql"</span></span>)) .bind::&lt;Text, _&gt;(DIRECTORY_SEARCH_DELETE_HORIZON) .bind::&lt;BigInt, _&gt;(DELETE_LIMIT) .get_result::&lt;DeleteResults&gt;(conn) .chain_err(|| <span class="hljs-string"><span class="hljs-string">"Error deleting directory search content batch"</span></span>)</code> </pre> <br><p>  The request is in its own .sql file: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> expired <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> directory_search <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> retrieved_at &lt; <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>() - $<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> ), deleted_batch <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> directory_search <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> expired ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> deleted_batch;</code> </pre> <br><p>  We cannot do SQL validation at compile time with this approach, but on the other hand we have direct access to the original SQL syntax and excellent syntax highlighting in your favorite editor. </p><br><h2 id="bystraya-no-ne-samaya-bystraya-model-parallelizma">  Fast (but not the fastest) concurrency model </h2><br><p>  <code>actix-web</code> runs on top of <a href="https://github.com/tokio-rs/tokio">tokio</a> , a fast asynchronous event processing library that is the cornerstone of Rust's asynchronous operation.  When you start the HTTP server, <code>actix-web</code> creates a certain number of worker threads equal to the number of logical cores on the server, each in its own system thread and with its own <code>tokio</code> reactor. </p><br><p>  HTTP request handlers can be written in various ways.  For example, a handler synchronously returning data: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>(req: HttpRequest) -&gt; Bytes { ... }</code> </pre> <br><p>  This handler blocks the <code>tokio</code> reactor until it returns a result, which is suitable in situations where no additional blocking calls are required.  For example, rendering static content from memory or responding to an application status check. </p><br><p>  You can also write a handler that returns <code>future</code> .  This will allow us to combine a series of asynchronous calls to ensure that the reactor is never blocked. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>(req: HttpRequest) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Future&lt;Item=HttpResponse, Error=Error&gt;&gt; { ... }</code> </pre> <br><p>  Examples of this might be an operation with a file that we read from disk (blocking I / O, albeit minimally), or waiting for a response from our database.  Waiting for the future, the <code>tokio</code> reactor will handle other requests. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6ff/1a9/f13/6ff1a9f13d599c6236eaf88022e2ea6d.svg" alt="An example of a concurrency model with actix-web."><br>  <em>An example of a concurrency model with actix-web.</em> </p><br><h3 id="sinhronnye-aktory">  Synchronous actors </h3><br><p>  <code>futures</code> support in <code>Rust</code> is widespread, but not universal.  It is noteworthy that diesel does not support asynchronous operations, so all its operations will be blocked. </p><br><p>  When using <code>diesel</code> , directly from the <code>actix-web</code> processor, block the <code>tokio</code> reactor and stop processing requests until the blocking operation is completed. </p><br><p>  Fortunately, <code>actix</code> has an excellent solution to this problem in the form of synchronous actors.  Actors perform synchronous processing of messages during operation and therefore each is assigned its own dedicated OS thread.  <code>SyncArbiter</code> makes it easy to run multiple copies of an actor of the same type, each of which works with a common message queue, which makes it possible to work with all actors simultaneously (see below as <code>addr</code> ): </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Start 3 `DbExecutor` actors, each with its own database // connection, and each in its own thread let addr = SyncArbiter::start(3, || { DbExecutor(SqliteConnection::establish("test.db").unwrap()) });</span></span></code> </pre> <br><p>  Although operations inside the synchronous actor are blocked by other actors in the system, such as HTTP handlers, it is not necessary to wait for the completion of any of them ‚Äî they receive a <code>future</code> that represents the result of the message while they do other work. </p><br><p>  In my implementation, fast computations, such as processing request parameters and rendering content, are performed inside handlers, and synchronous actors are never activated unless they are needed.  When the response requires database operations, the message is sent to the synchronous actor, and the <code>tokio</code> reactor serves other traffic, waiting for the future to be completed.  When this happens, it creates an http response with the results and sends it back to the waiting client. </p><br><h3 id="upravlenie-podklyucheniem">  Connection management </h3><br><p>  At first glance, the introduction of synchronous actors into the system may seem a disadvantage, since they limit the parallelism of the system.  However, these limitations may also be an advantage.  One of the first scaling issues you are likely to encounter in Postgres is the limit on the maximum number of simultaneous connections.  Even the largest bases on Heroku or GCP (Cloud Cloud Platform) give a maximum of 500 connections, and in smaller bases the limitations are even lower (my small base on the GCP has restrictions of 25 connections).  Large systems using framework connection functions (for example, Rails and many others) use such solutions as PgBouncer to solve this problem. </p><br><p>  Specifying the number of synchronous actors by default also implies the maximum number of connections that the service will use, which leads to perfect control over the use of connections. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bb0/6f0/8e6/bb06f08e6ba2ab13bb1d61dcb7d476e2.svg" alt="Connections are used only if a synchronous actor is required."></p><br><p>  <em>Connections are used only if a synchronous actor is required.</em> </p><br><p>  I wrote my synchronous actors to use separate connections from the connection pool ( <a href="https://github.com/sfackler/r2d2">r2d2</a> ) only when the work begins and release them after completion.  When the service is in standby mode, starting or shutting down, it does not use connections.  Compare this with many web frameworks, where the system opens a connection to the database as soon as the workflow has started and keeps it open until the workflow stops.  This approach requires ~ 2x connections for elegant restarts, because all workflows establish a connection and keep it even during completion. </p><br><h3 id="ergonomichnoe-preimuschestvo-sinhronnogo-koda">  Ergonomic advantage of synchronous code </h3><br><p>  Synchronous operations are not performed as quickly as a purely asynchronous approach, but their advantage is ease of use.  It's nice that <code>futures</code> are fast, but writing them accordingly takes a lot of time, and the compiler errors they generate are a nightmare that takes a lot of time to set up and fix. </p><br><p>  Writing synchronous code is faster and easier, and I personally agree to put up with conditionally suboptimal execution speed, if this means that I can implement the basic business logic faster. </p><br><h3 id="medlenno-no-tolko-otnositelno-ochen-ochen-bystrogo">  Slowly, but only relatively ‚Äúvery, very fast‚Äù </h3><br><p>  It may sound a little disregard for the performance characteristics of this model, but keep in mind that it is only slow compared to a purely asynchronous stack (i.e., futures).  This is still a conceptually correct model with real parallelism and compared to any other frameworks and programming languages, it is very, very fast.  I work on Ruby at my main job and compared to a non-streaming model (common to Ruby, because GIL limits thread performance), this model is an order of magnitude better and more efficient in terms of memory usage. </p><br><p>  In the end, your database will be a bottleneck, and the synchronous model of actors supports just such parallelism, while at the same time ensuring maximum throughput for any actions that do not need access to the database. </p><br><h2 id="obrabotka-oshibok">  Error processing </h2><br><p>  Like any good Rust program, APIs almost everywhere return the <code>Result</code> type.  <code>Futures</code> use their version of <code>Result</code> containing either a successful result or an error. <br>  I use <a href="https://github.com/rust-lang-nursery/error-chain">error_chain</a> to determine my errors.  Most of them are internal, but I have defined a specific group with a direct goal: </p><br><pre> <code class="rust hljs">error_chain!{ errors { <span class="hljs-comment"><span class="hljs-comment">// // User errors // BadRequest(message: String) { description("Bad request"), display("Bad request: {}", message), } } }</span></span></code> </pre> <br><p>  When an error has to be passed to the user, I will necessarily associate it with one of my types of errors: </p><br><pre> <code class="rust hljs">Params::build(log, &amp;request).map_err(|e| ErrorKind::BadRequest(e.to_string()).into() )</code> </pre> <br><p>  After waiting for a response from a synchronous actor or after trying to create a successful HTTP response, I process errors and send a response to the user.  The implementation turned out to be quite elegant (note that in the composition <code>Future::then</code> differs from and_then in that it processes both success and failure, receiving a <code>Result</code> , unlike <code>and_then</code> which processes only a successful completion): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = server::Message::new(&amp;log, params); <span class="hljs-comment"><span class="hljs-comment">// Send message to synchronous actor sync_addr .send(message) .and_then(move |actor_response| { // Transform actor response to HTTP response } .then(|res: Result&lt;HttpResponse&gt;| server::transform_user_error(res, render_user_error) ) .responder()</span></span></code> </pre> <br><p>  Errors that are not intended for the user are logged, and <code>actix-web</code> returns them as <code>500 Internal server error</code> (although I probably will add my own visualizer to it at some point). </p><br><p>  Here is <code>transform_user_error</code> .  The <code>render</code> function abstracts error handling, so we can reuse this function in different APIs that display JSON responses, and a web server that displays HTML. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform_user_error</span></span></span></span>&lt;F&gt;(res: <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;HttpResponse&gt;, render: F) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;HttpResponse&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">FnOnce</span></span>(StatusCode, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;HttpResponse&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> res { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e @ Error(ErrorKind::BadRequest(_), _)) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// `format!` activates the `Display` traits and shows our error's `display` // definition render(StatusCode::BAD_REQUEST, format!("{}", e)) } r =&gt; r, } }</span></span></code> </pre> <br><h2 id="middleware">  Middleware </h2><br><p>  As web frameworks in many languages, <code>actix-web</code> supports <code>middleware</code> .  Here is a simple example that initializes the logger for each query and sets it to the query extension (a set of query states that will work as long as the query is executed): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> log_initializer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Middleware</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> Logger); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;S: server::State&gt; actix_web::middleware::Middleware&lt;S&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Middleware { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> HttpRequest&lt;S&gt;) -&gt; actix_web::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Started&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> log = req.state().log().clone(); req.extensions().insert(Extension(log)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Started::Done) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span></span>( &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, _req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> HttpRequest&lt;S&gt;, resp: HttpResponse, ) -&gt; actix_web::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::Done(resp)) } } <span class="hljs-comment"><span class="hljs-comment">/// Shorthand for getting a usable `Logger` out of a request. pub fn log&lt;S: server::State&gt;(req: &amp;mut HttpRequest&lt;S&gt;) -&gt; Logger { req.extensions().get::&lt;Extension&gt;().unwrap().0.clone() } }</span></span></code> </pre> <br><p>  The peculiarity is that <code>middleware</code> binds to a type instead of a string (as, for example, Rack in Ruby).  This not only helps to check the type during compilation in such a way that you can not mistakenly keep the key, but also gives the <code>middleware</code> ability to control its modularity.  If we wanted to hide the <code>middleware</code> , we could remove the <code>pub</code> from the Extension so that it becomes closed.  Any other modules would not be able to access this data due to the compiler checking the visibility. </p><br><h3 id="asinhronnost-do-samogo-konca">  Asynchrony to the very end </h3><br><p>  Like request handlers, <code>middleware</code> can be asynchronous, returning the future instead of Result.  This will allow, for example, to implement <code>middleware</code> , limiting the transfer rate, which Redis would use in such a way as not to block other handlers.  I have already mentioned that <code>actix-web</code> pretty fast? </p><br><h2 id="http-testirovanie">  HTTP testing </h2><br><p>  The <code>actix-web</code> documentation describes several guidelines for testing methodologies for your code.  I settled on a series of unit tests that use <code>TestServerBuilder</code> to create a small application containing a single handler, and then execute a query against it.  This is a good compromise, because, despite the minimal tests, they use the full HTTP stack, and because of what they become fast and complete: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_handler_graphql_get</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bootstrap = TestBootstrap::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> server = bootstrap.server_builder.start(|app| { app.middleware(middleware::log_initializer::Middleware) .handler(handler_graphql_get) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> req = server .client( Method::GET, <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"/?query={}"</span></span>, test_helpers::url_encode(<span class="hljs-string"><span class="hljs-string">b"{podcast{id}}"</span></span>)).as_str(), ) .finish() .unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> resp = server.execute(req.send()).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(StatusCode::OK, resp.status()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = test_helpers::read_body_json(resp); <span class="hljs-comment"><span class="hljs-comment">// The `json!` macro is really cool: assert_eq!(json!({"data": {"podcast": []}}), value); }</span></span></code> </pre> <br><p>  I actively use <code>serde_json</code> (standard Rust encoding and decoding library) <code>json!</code>  macro, used in the last line of the code above.  If you look carefully, you will notice that the embedded JSON is not a string - <code>json!</code>  Which allows me to write the actual JSON notation directly into my code, which will be tested and converted to a real Rust structure by the compiler.  This is the most elegant approach to testing HTTP JSON responses I've ever seen in other programming languages. </p><br><h2 id="rezyume-yavlyaetsya-li-rust-buduschim-nadezhnyh-sistem">  Summary: Is Rust a future reliable system? </h2><br><p>  It would be fair to say that I could write the same service in Ruby 10 times faster than Rust.  Part of this time was spent on training, part on taming the obstinate compiler, which sometimes turns into a long and frustrating process.  However, once again encountering this last obstacle, I launched my program, experiencing euphoria from the fact that it works exactly as I want.  Compare this with the interpreted languages, when you may be able to start the program with 15 attempts, but even then the boundary conditions will be almost one hundred percent incorrect.  Rust also allows you to make big changes - for me it is often necessary to reorganize a thousand lines at a time, and then again and even after that the program works fine.  Anyone who has seen a large program in an interpreted language in production knows that you can only make changes in small parts, otherwise you are at great risk.  Should you write your next web service on Rust?  I do not know yet, but you definitely should pay attention to him. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353990/">https://habr.com/ru/post/353990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353978/index.html">Redefining GPS: Developing a new generation positioning system in Uber</a></li>
<li><a href="../353982/index.html">Open broadcast of the main hall DotNext 2018 Piter</a></li>
<li><a href="../353984/index.html">Personal experience: speeches and webinars of VAS Experts on SCAT, CG-NAT and DPI systems</a></li>
<li><a href="../353986/index.html">We map the entire Internet using the Hilbert curves.</a></li>
<li><a href="../353988/index.html">Why Sweden refuses the idea of ‚Äã‚Äãfull transition to non-cash payments</a></li>
<li><a href="../353992/index.html">How IaaS helps freelance programmers: 1cloud experience</a></li>
<li><a href="../353994/index.html">Operating systems from scratch; level 3 (younger half)</a></li>
<li><a href="../353996/index.html">Export to Excel from JS</a></li>
<li><a href="../353998/index.html">Features of the analysis of CRM systems in the restaurant business</a></li>
<li><a href="../354002/index.html">Future single B2B market or technology game?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>