<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modeling the MUSIC algorithm for determining the direction of arrival of an electromagnetic wave</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 


 I will begin my entry from afar. Long ago, in the distant 2016-2017 years, your humble servant managed to go on a semi-annual training to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modeling the MUSIC algorithm for determining the direction of arrival of an electromagnetic wave</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/737/f34/fdd/737f34fdd1e91350efca1e2e8c72b673.jpg" alt="aaspcats"></p><br><h2 id="predislovie">  Foreword </h2><br><p>  I will begin my entry from afar.  Long ago, in the distant 2016-2017 years, your humble servant managed to go on a semi-annual training to the distant city of <a href="https://en.wikipedia.org/wiki/Technische_Universit%25C3%25A4t_Ilmenau">Ilmenau</a> (Germany), where he successfully (in general) finished the master program in <strong>Communications and Signal processing</strong> .  The program was not easy, but now it‚Äôs pleasant to remember about it.  Sometimes... </p><a name="habracut"></a><br><p>  So, at the end of this training, besides a diploma, I had quite a lot of different materials left on my hands, which seemed to me to be wrong not to share. </p><br><p>  One of these materials is in front of you. </p><br><p>  <strong>What goals did I pursue while I was preparing a seminar</strong> : </p><br><ol><li>  talk about some of the already well-established, ‚Äúsmart‚Äù approaches to the topic of antenna arrays most accessible and do it in Russian; </li><li>  conduct a small simulation in <strong><em>Python 3</em></strong> , in order to persuade fellow radio engineers to look at programming languages ‚Äã‚Äã(if you haven't looked closely); </li><li>  to give references to good English-language literature - without reading foreign sources, now, alas, nowhere. </li></ol><br><p>  <strong>What we consider</strong> : </p><br><ul><li>  The MUSIC (MUltiple SIgnal Classification) method is, in fact, a reference to the preview. </li></ul><br><blockquote>  An example of diagramming and the MVDR method can be found <a href="https://nbviewer.jupyter.org/gist/kirlf/1b70de0ef1b9cdf3c00c317920e8d252">by reference</a> (if there are questions or suggestions for additional material, then the discussion can be continued on Github.Gist). </blockquote><p>  As I said above, we will use Python, as follows: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Why not MATLAB, one of the most popular and convenient candidates for modeling using linear algebra, you ask?  Because, I want to show that this work can be done in Python, and the scope of Python is much broader than that of MATLAB.  Therefore, to be familiar with the Python syntax is a good thing, in my opinion. </p><br><p>  Let's start! </p><br><blockquote>  Formulas are prepared via <a href="https://upmath.me/">https://upmath.me/</a> .  Thanks to the creators for a great tool! </blockquote><br><h2 id="postanovka-zadachi">  Formulation of the problem </h2><br><p>  Suppose there is a linear antenna array consisting of a number of elements spaced apart from each other. <img src="https://habrastorage.org/getpro/habr/post_images/c49/da9/3f6/c49da93f689f17c27bbcc995d0cf0576.svg" alt="\ Delta = \ frac {\ lambda} {2}">  (antenna array pitch) where <img src="https://habrastorage.org/getpro/habr/post_images/737/77b/299/73777b29907648e5b08f01b47d9ec807.svg" alt="\ lambda">  - the length of the carrier electromagnetic (EM) wave. </p><br><p>  Electromagnetic waves fall on this antenna array from different directions. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Fig.  1. <a href="https://www.intechopen.com/books/advances-in-satellite-communications/new-antenna-array-architectures-for-satellite-communications">Adaptive antenna system.</a> </blockquote><p>  As can be seen from the figure, the antenna array is considered as an adaptive filter. </p><br><p>  In fact, finding the optimal vector of coefficients ( <img src="https://habrastorage.org/getpro/habr/post_images/a49/326/4d0/a493264d0b40f5c5b29b8b465244471d.svg" alt="\ mathbf {w} _ {opt}">  ) and is the main task of adaptive antenna arrays from a mathematical point of view. </p><br><p>  Initially, we do not know exactly from which directions the signals come and how many of them.  It is to resolve this contradiction that we will apply the MUSIC algorithm ‚Äî an algorithm for estimating spatial frequencies with high resolution. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Simulation of the received signal </h2><br><p>  The model of the received signal we can present through the formula: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/ebd/501/0c5ebd501ed7a573f33ad98b06a649b6.svg" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><br><p>  Where <img src="https://habrastorage.org/getpro/habr/post_images/00a/a3b/e4c/00aa3be4c55f47a8a5498dc0d64c08e2.svg" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - matrix of scanning vectors (steering vectors) of the antenna array ( <img src="https://habrastorage.org/getpro/habr/post_images/b26/823/49a/b2682349a75d3af2e1c094b2f1231cc2.svg" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://habrastorage.org/getpro/habr/post_images/299/9cb/d24/2999cbd24c6ac4ba1fd3a74fdd0f5635.svg" alt="m = 0, 1 ... (M-1)">  , <img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M">  - the number of elements of the antenna array, <img src="https://habrastorage.org/getpro/habr/post_images/804/c42/9d4/804c429d4bd8e4f2577d467481a193bd.svg" alt="d">  - the number of sources of EM waves, <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg" alt="\ theta">  - angle of arrival of the EM wave), <img src="https://habrastorage.org/getpro/habr/post_images/84e/029/611/84e02961182e87b0f26784540be45fae.svg" alt="\ mathbf {s}">  - matrix of transmitted characters, and <img src="https://habrastorage.org/getpro/habr/post_images/607/db5/b8b/607db5b8b4d1629cb1eabf52ca066ae7.svg" alt="\ mathbf {N}">  - matrix of additive noise. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/61a/9c2/da7/61a9c2da745081459f9001d0252936f1.png" alt="ULA" width="600"><br><blockquote>  Fig.  2. Non-directional linear antenna array (ULAA - uniform linear anntenna array) [1, p.  32]. </blockquote><p>  We rethink this formula in the ‚Äúeveryday‚Äù way: we get some ‚Äúporridge‚Äù from various signals on our lattice, which we denote by <img src="https://habrastorage.org/getpro/habr/post_images/7c0/22d/1bb/7c022d1bb9000420f4acc9478d045292.svg" alt="\ mathbf {X}">  .  We do not explicitly receive information on the number of sources and directions, however, information about this is still contained in the received signal. </p><br><p>  Begin to look! </p><br><p>  To do this, they usually proceed to manipulations not with the matrices of the complex amplitudes of the signals, but with their covariances (that is, with the powers): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/6e1/a47/1ed6e1a47a46230c0dbc67395e9a7ad8.svg" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><br><h2 id="usloviya">  Conditions </h2><br><p>  Let us introduce an important condition for consideration: Rayleigh angle resolution limit: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/042/842/6ac042842567ddd107e2056b855f4565.svg" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><br><p>  Where <img src="https://habrastorage.org/getpro/habr/post_images/a5f/cfa/1e7/a5fcfa1e76ea11b6567e466606486171.svg" alt="D = M \ Delta">  Is the length of the linear lattice. </p><br><p>  Let's redefine the angle of arrival of an electromagnetic wave through the concept of spatial frequency: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/349/a84/970349a84b6b3c1fb6dc0a15cae8380b.svg" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><br><p>  Where <img src="https://habrastorage.org/getpro/habr/post_images/9cc/664/d70/9cc664d700ffe1ad7170d270eece081e.svg" alt="\ mu_R">  - there is a standard width of the main lobe of the DN ( <a href="http://hyperphysics.phy-astr.gsu.edu/hbase/phyopt/Raylei.html">standard beam width</a> ). </p><br><p>  To check how effective our method is and under what conditions, we introduce some set values ‚Äã‚Äãfor the angular separation: </p><br><ol><li><p><img src="https://habrastorage.org/getpro/habr/post_images/4b9/c04/46e/4b9c0446ed6064c2172813706dede24e.svg" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - separation in one beam width; </p><br></li><li><p><img src="https://habrastorage.org/getpro/habr/post_images/c90/751/0fc/c907510fce1db24a3465947a7ae0d1e8.svg" alt="\ mu_1 = -0.5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0.5 \ mu_R \ quad">  - division into one second beam width; </p><br></li><li><p><img src="https://habrastorage.org/getpro/habr/post_images/e20/52a/05c/e2052a05ced682a377bdef9c5c06decd.svg" alt="\ mu_1 = -0.3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0.3 \ mu_R \ quad">  - separation of three tenths of the beam width. </p><br></li></ol><br><p>  Define input parameters: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  A bit of theory about the method itself. </h2><br><p>  First of all, we note that the progenitor of the MUSIC method is the <a href="http://www.mitp.ru/ru/persons/pisarenko.html">Pisarenko</a> method (1973).  The considered problem of the Pisarenko method was to estimate the frequencies of the sum of complex exponentials in white noise.  VF Pisarenko demonstrated that frequencies can be found from the eigenvectors corresponding to the minimum eigenvalue of the autocorrelation matrix.  Subsequently, this method became a special case of the MUSIC method.  [2, c.  459] </p><br><p>  Schmidt and his colleagues proposed the Multiple Signal Classification Algorithm (MUSIC) in 1979 [4].  The main approach of this algorithm is the decomposition of the covariance matrix of the received signal into eigenvalues.  Since this algorithm takes into account uncorrelated noise, the generated covariance matrix has a diagonal form.  Here, the signal and noise subspaces are calculated using linear algebra, and are orthogonal to each other.  Therefore, the algorithm uses the orthogonality property to separate signal and noise subspaces [5]. </p><br><p>  The generalized MUSIC algorithm can be defined as follows: </p><br><ul><li>  Find the covariance matrix <img src="https://habrastorage.org/getpro/habr/post_images/5a5/302/745/5a5302745bce01efed1c8c0b62eba6fd.svg" alt="\ mathbf {R} _ {xx}"></li><li>  Find eigenvectors via <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">EVD</a> or another suitable numerical algorithm: </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/2b4/45e/6d22b445ed2b9ca9c25943ed9c9c9c17.svg" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><br><ul><li>  Find the pseudospectrum (why with the pseudo prefix, we will discuss below) MUSIC using the following formula: </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06a/843/c19/06a843c19270524991e9ea1c90ab6e8b.svg" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limits_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><br><p>  Where <img src="https://habrastorage.org/getpro/habr/post_images/bb7/7ab/1aa/bb77ab1aa0a09b1807e947dcd80b40c8.svg" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T">  - vector of exponentials for the frequency œâ, lying in a certain specified range, and <img src="https://habrastorage.org/getpro/habr/post_images/85f/bc7/8d9/85fbc78d94c8315141e005f65b9d1b70.svg" alt="\ mathbf {u} _i">  - i-th eigenvector (eigen vector) of the covariance matrix (1), corresponding to the noise subspace of the matrix (1) - hence the indexation with <img src="https://habrastorage.org/getpro/habr/post_images/a38/b3e/c59/a38b3ec59d035936a2c47d16d3a23801.svg" alt="d + 1">  ( <img src="https://habrastorage.org/getpro/habr/post_images/804/c42/9d4/804c429d4bd8e4f2577d467481a193bd.svg" alt="d">  - rank of the matrix (1)). </p><br><blockquote>  For greater clarity, try to run the corresponding MATLAB script presented by <a href="https://www.mathworks.com/matlabcentral/fileexchange/2183-statistical-digital-signal-processing-and-modeling%3Ffocused%3D5042738%26tab%3Dfunction">reference</a> .  Pay attention to two main points: <br><ul><li>  instead of calculating the square of the second norm in the denominator (2), the authors apply the FFT algorithm to the eigenvectors, which facilitates modeling due to the use of built-in functions and, in general, does not contradict the theory from a mathematical point of view; </li><li>  the calculation of the covariance matrix is ‚Äã‚Äãperformed through convolutional matrices; a different approach was shown above for estimating spatial frequencies. </li></ul><br></blockquote><p>  As you might guess from the name, MUSIC is also a classic method for estimating the direction of reception with high resolution.  The algorithm for calculating pseudospectra in this context is given below: </p><br><ul><li><p>  find the covariance matrix of the received signal; </p><br></li><li><p>  find the zero subspace <img src="https://habrastorage.org/getpro/habr/post_images/498/8d0/1b7/4988d01b7e48a84b143144025702f72c.svg" alt="\ mathbf {U} _0">  : </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/550/352/94c/55035294cac1d8142a9f67852aa07992.svg" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><br><ul><li>  choose some search range: </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/ae3/aba/e71ae3aba29dabd6f85f61002311103c.svg" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><br><p>  Where <img src="https://habrastorage.org/getpro/habr/post_images/e5e/6d4/eba/e5e6d4eba9314857603ee3cf4b1d1072.svg" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  calculate the pseudospectrum: </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/a2a/79f/8b8a2a79fdf24e5fa2c9050b7b53e560.svg" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><br><p>  The relationship between spectral analysis and arrival angle analysis (DoA - direction of arriaval) of EM waves is described in Table 1. </p><br><p>  Table 1 <strong>Relationship between MUSIC applications</strong> : Signal array processing and Harmonic search [6]. </p><br><table><thead><tr><th>  Variable </th><th>  Signal array processing </th><th>  Harmonic search </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M"></div></td><td>  Number of sensors </td><td>  The number of time periods </td></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N"></div></td><td>  The number of time periods </td><td>  The number of experiments </td></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/c42/9d4/804c429d4bd8e4f2577d467481a193bd.svg" alt="d"></div></td><td>  The number of wave fronts </td><td>  The number of complex components </td></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/a42/16c/849a4216c1bc55877bc86f4a97513f7a.svg" alt="\ mu"></div></td><td>  Spatial frequencies </td><td>  Normalized frequencies </td></tr></tbody></table><br><p>  In general, the process of receiving through arrays (lattices) can be compared with the process of classical discretization, since  in essence, each sensor, taking a wave with a certain phase delay (i.e. with a certain time delay), performs the functions of a sampling delta pulse.  The number of realizations (experiments) of the classical spectral analysis will correspond to the number of time periods (snapshots).  Each source will have its own wavefront, which is equivalent to the number of unique sinusoids of the signal in the case of spectral analysis. </p><br><p>  Now back to the moment of calculating the eigenvectors.  We already mentioned above that the vectors <img src="https://habrastorage.org/getpro/habr/post_images/f74/947/8e3/f749478e3cce0c6f81d22a4afb1bde24.svg" alt="a (\ theta_i) \ epsilon A">  where <img src="https://habrastorage.org/getpro/habr/post_images/2fd/bae/265/2fdbae265cd1c32aaa06c1a438c0ccb6.svg" alt="i = 1,2, .., d">  orthogonal to the noise subspace of the covariance matrix, i.e .: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/5b0/dd0/6205b0dd057dd25898acadd9648847b5.svg" alt="a (\ theta_i) ^ TU_0 = 0 ^ T"></div><br><p>  As a matter of fact, we see a system of equations, solving which we can find the roots - eigenvectors.  Such a method, in contrast to numerical algorithms (to which, as we noted above, EVD applies), allows one to obtain real, rather than approximate, eigenvalues.  That is why this approach allows to obtain not a pseudospectrum, but a spectrum.  The same idea formed the basis of the <a href="https://www.mathworks.com/help/signal/ref/rootmusic.html%3FsearchHighlight%3Droot%2520music%26s_tid%3Ddoc_srchtitle">Root MUSIC</a> algorithm. </p><br><h2 id="modelirovanie">  Modeling </h2><br><p>  Phew!  Finally, all the formulas are described and explained to some extent.  We can start modeling. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles Œ∏ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  As we can see, MUSIC has a higher resolution and allows to achieve, in general, better results than, for example, MVDR allows - the same representative of parametric methods of spectral analysis. </p><br><p>  However, it should be borne in mind that when using MUSIC, we use more computationally more expensive algorithms, such as EVD or SVD, which is some price for greater accuracy. </p><br><p>  So it goes. </p><br><h2 id="spisok-ispolzovannoy-literatury">  References: </h2><br><ol><li>  Haykin, Simon, and KJ Ray Liu.  Handbook on array processing and sensor networks.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Statistical digital processing and modeling.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Adaptive filter theory.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. "Capon algorithm  IEEE Transactions on Signal Processing 53.8 (2005): 2748-2764. </li><li>  SKP Gupta, MUSIC and improved MUSIC algorithm to esimate dorection of arrival, IEEE, 2015. </li><li>  Professor Martin Haardt's lectures ( <a href="http://www5.tu-ilmenau.de/nt/en/">array array</a> ) </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/446674/">https://habr.com/ru/post/446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446658/index.html">Interview with Andrei Stankevich about sports programming</a></li>
<li><a href="../446660/index.html">AI, student and big prizes: how to do machine learning in 8th grade</a></li>
<li><a href="../446662/index.html">Transactions and their control mechanisms</a></li>
<li><a href="../446666/index.html">Squeezing the maximum out of graphing calculators: games on TI-83</a></li>
<li><a href="../446668/index.html">Python for the Web: what does a junior need to know in order to work and develop</a></li>
<li><a href="../446676/index.html">Making replicas of missing keys for a Commodore 116 rubber keyboard</a></li>
<li><a href="../446678/index.html">Live Battle: ICPC Finals in Porto</a></li>
<li><a href="../446680/index.html">The basic instinct of a coder is to eliminate inefficient solutions from everywhere.</a></li>
<li><a href="../446682/index.html">Accelerate WebGL / Three.js with OffscreenCanvas and Web Workers</a></li>
<li><a href="../446690/index.html">Electrolux has released a smart air cleaner for the most polluted cities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>