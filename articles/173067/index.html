<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Application security: it's almost simple</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Give me a certificate that my program is safe. 

 - No problems! And what did you do for this? 

 ‚ÄúUm ... Well ... This is ... Nothing ..." 

 ‚ÄúWhy ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Application security: it's almost simple</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/ea9/e36/5df/ea9e365dff166087191a3abdeb23d863.jpg" alt="simple science"><br><br>  - Give me a certificate that my program is safe. <br><br>  - No problems!  And what did you do for this? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚ÄúUm ... Well ... This is ... Nothing ..." <br><br>  ‚ÄúWhy do you think she is safe then?‚Äù <br><br>  - Well, you check! <br><br>  - No problems!  All the fun will cost X0000 dollars. <br><br>  -?! <br><br><h4>  About the article </h4><br>  In this article, I talk about some of the practices of creating secure software. <br><br>  The first part is dedicated to secure programming. <br><br>  On the one hand, secure programming techniques are well known.  Accumulated experience of their use, written a lot of literature. <br><br>  On the other hand, they are not used very often.  For many programmers and project managers, they remain not very clear exotic. <br><br>  The article, of course, does not claim to fully cover this issue.  But let it be a small step in the right direction.  And, I hope, you will be convinced that in safe programming there is nothing so unusual. <br><br>  In the second part, I talk about the less well-known aspects of application security.  But, in a sense, these aspects are even more important than the use of secure programming techniques. <br><br>  <strong>Attention!</strong>  The article is large and implies careful reading. <br><br><a name="habracut"></a><br><h2>  Part I. Safe Programming </h2><br><h4>  Know your technology </h4><br>  Each technology has two sides.  One side - the properties that are useful to our user, we use them in our products;  the second side is the properties that a hacker can use, the weaknesses of the technology.  Sometimes technology is so weak that its use cannot be justified under any circumstances.  For example, the gets function in a C program is almost always evil.  Other technologies can be used by taking the necessary measures to protect.  So using a SQL server could potentially open up the possibility for sql injection.  But we know how to deal with this and just have to take the necessary protection measures. <br><br>  We need to know both sides of our technology.  How to make a useful program is the main knowledge of any programmer, thanks to this knowledge we make money.  Therefore, it is completely understandable that we devote most of our time to studying this aspect. <br><br>  But a good specialist understands the other side.  We do not have to know how a hacker will attack us, we are not obliged to be able to create an exploit for this or that vulnerability.  But we need to understand what our actions can lead to the appearance of vulnerabilities, and how we can avoid it. <br><br>  On the Internet now there are several good resources devoted to this topic. <br><br>  One of these resources is <a href="https://www.owasp.org/">The Open Web Application Security Project</a> .  As the name implies, the project focuses on web application security, but the same information can also be used when programming in other areas.  The site is made in the now popular form of Wikipedia, and consists of separate articles;  There are lists of these articles, grouped according to different principles.  A pointer to articles grouped by technology can be found at the following <a href="https://www.owasp.org/index.php/Category:Technology">address</a> . <br><br>  I will continue to repeatedly refer to OWASP.  This project is a very valuable resource for application security professionals. <br><br>  A very good source of information is the <a href="http://cwe.mitre.org/">Common Weakness Enumeration</a> site.  The site contains information interesting to us in the form of a catalog that lists the causes of vulnerabilities in software.  It is perceived to be more complicated than OWASP, but it may be more convenient, for example, when generating checklists. <br><br>  Check with these sites regularly.  Information about security technology is constantly updated, here as in the looking-glass: to stay in place, you must run as fast as you can. <br><br><h4>  Use libraries </h4><br>  Do not reinvent the wheel!  Of course, we all are very interested to do something of our own.  But safe invention leads to very unpleasant consequences, so use proven tools. <br><br>  Now there is a large variety of libraries.  You can find ready-made solutions for almost any task, and you can find both paid libraries and open source libraries. <br><br>  For example, <a href="http://www.openssl.org/">openssl</a> can be recommended for implementing cryptographic methods.  The library is well known, tested to an extent sufficient for most of us, distributed under a free <a href="http://www.openssl.org/source/license.html">license</a> . <br><br>  Web developers using Java EE might like <a href="https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API">ESAPI</a> .  This library was created within the framework of the OWASP project already mentioned here; it implements many of the methods necessary to create secure web applications.  The library contains functions that filter input data, authenticate users, verify access rights, and much more.  The code is licensed under a BSD license that allows for very widespread use. <br><br>  Unfortunately, ESAPI is not developing now.  Nevertheless, this is a well-established library, and there is <a href="https://www.owasp.org/index.php/OWASP_ESAPI_Reboot2012">reason</a> to hope that its support will be resumed. <br><br>  Perhaps it makes sense to pay attention to another library for JAVA, the <a href="https://github.com/coverity/coverity-security-library">Coverity Security Library</a> .  The library was released at the end of last year and there are not so many reviews about it.  Nevertheless, it was created by a company known in the field of application security, and, one hopes, they understand what they are doing. <br><br>  These are just some of the features.  I mentioned them solely as an example; the list of libraries is far from being limited to them.  Moreover, many modern frameworks also contain the necessary functions.  Pay attention only to who developed this library, how well it is tested and tested. <br><br>  Sometimes in the project it is impossible to use other people's libraries.  In the extreme (very, very, very extreme!) Write your own, carefully check and test it, ask the experts to check and test, once again carefully check and test yourself.  Use functions from this library in your code, do not write new methods every time you need them. <br><br>  In general, safety is like this: fewer bikes - a better solution. <br><br><h4>  Do a self test </h4><br>  We are all in a hurry.  The code that we are writing now had to be handed over yesterday, therefore the only quality necessary for it is to compile.  Well, maybe he still has to do something useful, take some set of tests. <br><br>  Stop it.  When you have just written your code, before compiling it, take a short break, rest, forget about the code.  After the break, look at what is written from different angles: check the syntax, the compliance of the code with the corporate standard;  check the code logic;  check its compliance with safety requirements (‚Äúknow your technology‚Äù, remember?). <br><br>  You will save a lot of time.  Although it seems that time is wasted in vain, it will return due to a significant reduction in debugging the application. <br><br>  Self-testing is a recognized practice for creating quality software.  So it is included in the <a href="http://www.sei.cmu.edu/library/abstracts/reports/00tr022.cfm">PSP</a> (Personal Software Process), a process designed specifically to create a quality product in the face of tight time and financial constraints. <br><br>  Pay attention: vanity is the enemy of not only quality, but also speed. <br><br><h4>  Use code verification tools </h4><br>  It is human nature to make stupid mistakes.  In this case, all programmers know that precisely stupid errors are the hardest to detect: some undelivered semicolon can lead to the loss of a whole day (if not more). <br><br>  It's hard for a person to remember everything at once.  There are a huge number of reasons for vulnerabilities;  to avoid problems, we must remember them all, we must check the program for their presence.  Moreover, hackers do not stand still: what was considered safe yesterday may be vulnerable today. <br><br>  Partially reduce problems with stupid errors and rapidly changing world can <a href="https://www.owasp.org/index.php/Static_Code_Analysis">utilities of automated analysis</a> .  These programs scan the code and look for signs of potential security problems.  Automated utilities are good because they can quickly and almost without human intervention find many types of vulnerabilities, allowing the programmer to pay more attention to other problems.  Often, these utilities can carry out a rather complex analysis that would take a very long time for a person.  Some of these features are already built into modern compilers, you just need to know how to turn them on. <br><br>  Do not just rely too much on automated analysis.  Information issued by similar programs should be treated in the same way as we treat compiler warnings.  We all know that the absence of a warning does not mean the absence of an error;  such scanners do not detect all vulnerabilities, even of the type well known to them.  On the other hand, the presence of a warning is not yet evidence of a problem, and a thoughtless desire to get rid of all warnings can sometimes only lead to more serious vulnerabilities. <br><br>  Automation can free up our time for something more interesting.  If part of your work can be charged to a computer, then why not do it? <br><br><h4>  Test </h4><br>  To be safe, a program must exhibit certain behavior.  For example, if you try to enter too long a line, the program must either reject it or cut it;  when trying to enter special characters, the data must either be rejected or the characters must be encoded in a special way. <br><br>  This behavior can be tested.  And we get all the benefits of automated program testing: it can be done frequently, practically without human intervention. <br><br>  I will not give here any links.  There are no features in safe <em>behavior</em> testing compared to regular functional testing.  You can use all your work, including TDD, continuous integration, and everything else that you know better than me.  Of course, you should be able to describe safe behavior (again, ‚Äúknow your technology‚Äù). <br><br>  Not everything can be tested effectively.  For example, using the gets () function almost always causes a buffer overflow;  This problem can be detected by testing.  But it is more efficient to detect it with the help of an automated code scan: simple grep easily copes with it.  The example, of course, is highly exaggerated, but it can be a good starting point for considering security testing possibilities. <br><br>  Testing can not solve all security problems.  But if something is possible to test automatically, why not use it? <br><br><h4>  Do code review </h4><br>  Code revision is the most effective way to detect errors.  Moreover, it is most effective both in terms of the number of detected defects and in terms of the cost (time) of their detection.  So Steve McConnell in his book "Perfect Code" cites a link to IBM's research, in which they found that one hour invested in code revision stores up to 100 hours of testing and eliminating errors.  Although I think that the number 100 will be achieved very rarely, nevertheless, this is a very good reason to think. <br><br>  Code revision can be organized in different ways.  This role can be played by pair programming, and informal viewing of the code by fellow programmers, and by a very formal inspection involving a safe programming specialist.  Much depends on the goals: the higher the requirements for the program, the more people should be involved in the audit, the more formally it should be carried out. <br><br>  The organization of the audit depends on the qualifications of programmers.  Obviously, if they themselves are sufficiently familiar with the principles of secure programming, it does not make sense to involve an outside specialist, and an informal procedure may well be enough.  On the other hand, the involvement of an outside specialist to participate in highly formalized code inspection can be an important part of the programmer's training program. <br><br>  And again OWASP.  Of course, this project could not bypass such an important methodology side.  Therefore, if you are going to conduct a revision of the code in your project (I have not yet convinced you to do this?), The corresponding <a href="https://www.owasp.org/index.php/OWASP_Code_Review_Guide_Table_of_Contents">page of</a> this site is a good starting point. <br><br>  So you are not doing code review yet?  There is no forgiveness for you !!! <br><br><h4>  Use all measures in the complex </h4><br>  Uh ... Do you have to write something here? <br><br><h2>  Part II.  Security Design </h2><br><h4>  Motivating analogy </h4><br>  Let's take a break from security.  One of the most common tasks for programmers is to change an existing program.  We are not very often able to create a program from scratch, but to change (‚Äúsupport‚Äù) an existing one - as many as you like. <br><br>  So, we have to change the existing program.  And let it be a "significant" change, so that it does not mean, each programmer can easily think out the situation himself. <br><br>  There is one problem.  The program with its initial development was not intended to change.  I do not know why: either they didn‚Äôt think, or they were in a hurry - it doesn‚Äôt matter if there is a result.  The program consists of a large number of modules that are highly dependent on each other.  By making small changes in one module, we break the others.  Familiar? <br><br>  Is this a serious problem? <br><br>  Suppose we have a program in 100 lines.  I think that every more or less qualified programmer will easily make any change, even a very ‚Äúsignificant‚Äù one.  And it will take him, if not a day, then no more than two or three, it‚Äôs ridiculous to even discuss ‚Äúchange‚Äù. <br><br>  Program in 10 thousand lines.  The task will not be the easiest, but if you try, you can solve it. <br><br>  The program is 1 million lines.  Here everything is very difficult: you can strongly rest and solve the problem, but it may be faster and cheaper to throw out all the code and write again. <br><br>  Of course, I took the size of the programs from the ceiling.  It is clear that everything will depend on the "materiality" of the changes, and on the degree of neglect of the problem.  But we all encounter a similar situation, and each represents how quickly the complexity of modifying a program grows with its size. <br><br>  Therefore, we all know about SOLID and, possibly, about other similar principles.  If the program was designed and developed from the very beginning taking into account these principles, then it becomes much easier to maintain it.  For very large programs, designing with further support in general becomes a prerequisite for its capability. <br><br>  Now back to safety. <br><br><h4>  Principles of safe architecture and design </h4><br>  Safe has its own "solid".  I do not think that this statement will surprise anyone of you: everyone (or almost everyone) knows about the existence of these principles, they are regularly referred to in discussions on this site. <br><br>  Let me remind these principles: <br><br><ul><li>  simplicity of mechanisms (economy of mechanism); <br></li><li>  default security (fail-safe defaults); <br></li><li>  complete penetration of protection (complete mediation); <br></li><li>  open design; <br></li><li>  separation of privilege; <br></li><li>  minimum privileges (least privilege); <br></li><li>  minimization of resource sharing (least common mechanism); <br></li><li>  psychological acceptability. <br></li></ul><br>  These principles were formulated almost 40 years ago in the article ‚Äú <a href="http://www.cs.virginia.edu/~evans/cs551/saltzer/">The Protection of Information in Computer Systems</a> ‚Äù.  Now they like to add a few more rules ( <a href="https://buildsecurityin.us-cert.gov/bsi/articles/knowledge/principles/358-BSI.html">example</a> ), but the fact is that these principles have been known for a long time, and they remain true to the present.  There are examples of successful solutions built in accordance with these principles. <br><br>  It would seem, design your health, people safety. <br><br>  But principles alone are not enough.  Building a secure system, knowing only the general principles of security, is possible.  But it will resemble the solution of problems in geometry, based only on its axioms.  In order for design to be effective, it is very useful to know typical approaches, ready-made solutions. <br><br>  We have to use templates. <br><br><h4>  Secure Architecture and Design Templates </h4><br>  In our work there are constantly repetitive tasks.  Each system, each program is somewhat similar to many others.  And for standard tasks there are standard solutions - templates. <br><br>  Patterns are good for their verification.  Each template arose from experience, it is the result of trial, error, improvement, and removal of found problems.  By applying a pattern, we can fairly accurately predict what consequences this will lead to, what benefits it will have, what problems will have to be dealt with. <br><br>  In programming, well-known design patterns.  These are sample solutions to problems arising in the design of programs.  Their use greatly simplifies our life: we must bring the task before us to the standard one, and apply the existing, obviously working solution.  Therefore, the book "gang of four" - almost mandatory reading for any programmer. <br><br>  Patterns design business is not limited to: patterns exist at all levels.  There are architecture templates (remember, at least MVC), there are code writing templates, there are user interface templates, there are patterns of program behavior.  Almost every emerging problem has its own template solutions. <br><br>  Security also has its own templates.  Template solutions are for all levels of building an information system.  There are patterns of enterprise security in general, including organizational protection measures;  there are templates for building an information system as a purely technical entity;  and there are templates for secure applications. <br><br>  We are, of course, interested in application security patterns.  Here you can also talk about different levels: there are patterns of safe behavior, and patterns of the structure of a safe program. <br><br>  The security of a program is often associated precisely with its safe behavior.  It includes, for example, user authentication, authorization checking, input filtering.  Behavior is something that can be easily shown, tested;  this is why marketers usually ‚Äúsell‚Äù security features exclusively. <br><br>  But I want to draw the attention of readers to the structure of a safe program.  Yes, it is in the shadow: it is difficult to demonstrate, it is difficult to sell. <br><br>  But security depends on the structure of the program to a lesser extent than on its behavior.  From the structure of the program depends on the probability to make a mistake in it;  it depends on the structure of the program whether this error will become a vulnerability;  it depends on the structure of the program how severe this vulnerability will be.  For example, think about which error will lead to more serious consequences: in the code that has access to important data, or in the code that does not have such access? <br><br>  I think you understand the importance of the architecture and design of the program even without my explanations.  Therefore, I dare to recommend you two publications on structural patterns of secure programs. <br><br>  The first publication is Security Design Patterns ( <a href="http://www.opengroup.org/onlinepubs/9299969899/toc.pdf">pdf</a> ).  In my opinion, this is one of the most high-quality publications devoted to the structural patterns of safe programs.  It was published almost 10 years ago, in 2004, by the <a href="http://www.opengroup.org/aboutus">Open Group</a> consortium.  In this publication, you will find how to design security using templates, as well as a description of many of them. <br><br>  For example, the description of the ‚ÄúProtected System‚Äù template is very interesting.  In other sources, it is better known as the ‚ÄúReference Monitor,‚Äù and is very often mentioned in the literature.  But, most often, it is mentioned: in most other publications, half a page is dedicated to it.  In the Open Group, the use of the ‚ÄúProtected System‚Äù template is discussed in great detail, including the possible options for its use. <br><br>  The second publication is ‚ÄúSecure Design Patterns‚Äù ( <a href="http://www.cert.org/archive/pdf/09tr010.pdf">pdf</a> ).  This is more recent information, a report on the work done at the <a href="http://www.sei.cmu.edu/">Software Engineering Institute</a> and sponsored by the US Department of Defense. <br><br>  The SEI report is a catalog of security templates known at the time of publication.  And there are three different levels of patterns: architecture patterns, design patterns and implementation patterns.  Therefore, the work can be used as a very good source of information on this topic. <br><br>  There is another literature.  But, in my opinion, the two mentioned sources will be enough, at least for a start.  Having dealt with the information in them, you can already create significantly more secure programs. <br><br>  Read, think, apply. <br><br><h2>  Conclusion </h2><br>  A simple program to make safe is very easy.  To do this, you do not need to think a lot, plan: you only need to pay attention to security, apply the safe programming practices described in the first part of this article. <br><br>  Thinking about the design of the average complexity of the program, you will save yourself a lot of time, money and, possibly, save your reputation. <br><br>  Quality architecture and design of a complex program is the only way to make it safe. <br><br>  Remember this when you next plan a new program or refactor an existing one. <br><br>  <strong>PS The</strong> article turned out great.  I did not divide it into parts, I really wanted to preserve its integrity.  I hope it was interesting, and I didn‚Äôt download you too much. <br><br>  As a small bonus, I will add a micro-review of literature on the topic of the article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/047/d85/218/047d85218ea623d42ffbf184aa0bf85d.gif" alt="habr"><br><div class="spoiler">  <b class="spoiler_title">Literature (micro-review)</b> <div class="spoiler_text">  <strong><em>1. Steve McConnel, ‚ÄúRapid Development.</em></strong>  <strong><em>Taming Wild Software Schedulers ‚Äù, Microsoft Press 1996</em></strong> <br><br>  Very interesting book.  The author describes a variety of technical and management technologies to effectively develop high-quality software. <br><br>  An important thought from this book: rapid development does not mean chaotic.  Quickness is achieved not due to lack of planning, but, on the contrary, due to careful planning, prediction of possible problems. <br><br>  <strong><em>2. Steve McConnell, ‚ÄúCode Complete: A Practical Handbook of Software Construction‚Äù, Microsoft Press, Second Edition, 2004</em></strong> <br><br>  Probably one of the most necessary books for any programmer.  It is an encyclopedia of programming: describes both the styles of the code, and many practices of its development. <br><br>  From a security point of view: a poorly written program cannot be safe. <br><br>  <strong><em>3. Eric J. Braud ‚ÄúSoftware Engineering: An Object-Oriented Perspective,‚Äù Wiley Computer Publishing, 2001</em></strong> <br><br>  In our country, this book was published under the title "Technology of software development". <br><br>  The content of the book is fully consistent with its title.  The development technology is discussed, starting from gathering information about the user's needs and ending with maintenance. <br><br>  From a security point of view, the book is interesting for its attention to the quality, non-functional properties of software products, which is their security. <br><br>  <strong><em>4. Len Bass, Paul Clements, Rick Kazman, ‚ÄúSoftware Architecture in Practice‚Äù, Addison-Wesley Professional, Second Edition, 2003</em></strong> <br><br>  The book is the world's leading experts in the field of software architecture. <br><br>  It describes the relationship between the structure (architecture) of software and its non-functional properties: speed, modifiability, security, and others. <br><br>  The issues of architecture design are discussed, as a compromise solution that best meets the needs of the client. <br><br>  <strong><em>5. Paul Clements, Felix Bachmann, Len Bass, David Garlan, James Ivers, Reed Little, Robert Nord, Judith Safford ‚ÄúDocumenting Software Architectures.</em></strong>  <strong><em>Views and Beyond ‚ÄùAddison-Wesley Publishing 2008</em></strong> <br><br>  Another book of the world's leading experts in the field of software architecture. <br><br>  An important idea of ‚Äã‚Äãthe book is the absence of one that is suitable for describing all the properties of a software product "architecture".  A complete description of the architecture is the union of different "points of view". <br><br>  It is important for us to understand how the program architecture should be described for analyzing its security.  The description offered by other designers may not always be used by a security specialist, then he must create his own. <br><br>  <strong><em>6. Richard N. Tailor, Nenad Medvidovic, Eric M. Dashfy, ‚ÄúSoftware Architecture.</em></strong>  <strong><em>Foundations, Theory, and Practice ‚Äù, Wiley, 2010</em></strong> <br><br>  Tutorial on software architecture.  The book is interesting description of the history of the issue;  contains a lot of information about the methods of design, description and analysis of the architecture. <br><br>  In contrast to the two previous books, is more academic, fundamental. <br><br>  <strong><em>7. Matt Bishop ‚ÄúComputer security.</em></strong>  <strong><em>Art and science ‚Äù, Pearson education, 2003</em></strong> <br><br>  If you were to ask me which <em>one</em> security book to read, I would call this one.  Required to read any security specialist, but requires some mathematical knowledge. <br><br>  Good fundamental book. <br><br>  <strong><em>8. Jonh Viega, Gary McGraw ‚ÄúBuilding secure software.</em></strong>  <strong><em>How to Avoid Security Problems the Right Way, ‚ÄùAddison-Wesley Publishing Company, 2005</em></strong> <br><br>  <strong><em>9. Gary McGraw ‚ÄúSoftware Security.</em></strong>  <strong><em>Building Security in ‚Äù, Addison-Wesley Publishing Company, 2006</em></strong> <br><br>  <strong><em>10. Greg Hoglund, Gary McGraw ‚ÄúExploiting Software.</em></strong>  <strong><em>How to Break Code ‚Äù, Addison-Wesley Publishing Company, 2004</em></strong> <br><br>  Three books combined by one author (Gary McGraw).  Approaches to the development and testing of software security are described from various angles. <br><br>  Here you can find a description of Touch Points - a technique for integrating security requirements into almost any software development process. <br><br>  Another important technique - Attack Patterns - can be used both in analyzing a software project and in developing a testing program. <br><br>  <strong><em>11. Julia H. Allen, Sean Barnum, Robert J. Ellison, Gary McGraw, Nancy R. Mead, ‚ÄúSoftware Security Engineering.</em></strong>  <strong><em>A Guide for Project Managers ‚Äù, Addison-Wesley Publishing Company, 2008</em></strong> <br><br>  Very not a bad book, in the writing of which Garry McGraw also participated.  Contains links to a large number of different methods and methodologies that can be used when developing a program. <br><br>  Unfortunately, it is not always obvious from the description how this or that method can be used for designing or analyzing safety. <br><br>  The book can be used as a reference book, as a pointer to possible solutions.  But it is better to look for descriptions of solutions in the sources to which the book refers. <br><br>  <strong><em>12. Mark S. Merkov, Lakshmikanth Raghavan, ‚ÄúSecure and Resilient Software Development‚Äù, Auerbach Publications, 2010</em></strong> <br><br>  The book of two practitioners.  Both of them work (at least as of this writing) with PayPal Inc.  As you might guess, they have a lot of work with security. <br><br>  The authors seem to describe the techniques that they themselves used and that worked for them.  The book covers the entire life cycle of software, from design to release. <br><br>  <strong><em>13. Michael Howard, David LeBlanc, ‚ÄúWriting Secure Code‚Äù, Microsoft Press, Second Edition, 2003</em></strong> <br><br>  <strong><em>14. Frank Swiderski, Window Snyder, ‚ÄúThreat Modeling‚Äù, Microsoft Press, 2004</em></strong> <br><br>  <strong><em>15. Michael Howard, Steve Lipner, ‚ÄúThe Security Development Life Cycle,‚Äù Microsoft Press, 2006</em></strong> <br><br>  The famous three books by Microsoft.  I think a lot of talk about them does not make sense. <br><br>  The first book focuses (to a greater extent) on programmers, the second - on designers, the third - on project managers. <br><br>  <strong><em>16. Michael Howard, David LeBlanc, Jonh Viega, ‚Äú24 Deadly Sins of Software Security.</em></strong>  <strong><em>Programming Flaws and How to Fix Them ‚Äù, McGraw-Hill / Osborne, 2009</em></strong> <br><br>  This book is the development of the successful publication of the same authors ‚Äú19 Deadly Sins of Software Security. Programming Flaws and How to Fix Them‚Äù. <br><br>          ,        . <br><br>       :  ,          . <br><br>              . <br><br> <strong><em>17. Mark Down, John McDonald, Justin Schun, ‚ÄúThe Art of Software Security Assessement. Identifying and Preventing Software Vulnerabilities‚Äù, Addison-Wesley, 2007</em></strong> <br><br>  (1048 ) ,  ,    .   ,    ;    ;     . <br><br>         . <br><br>               . <br><br> <strong><em>18. Karl E. Wiegers, ‚ÄúPeer Reviews in Software. A Practical Guide‚Äù, Addison-Wesley Publishing Company, 2010</em></strong> <br><br>   ,   .        ,     .        . <br><br>  ,           ,       . <br><br>      ‚Äî     ,     . <br><br> <strong><em>19. Paul C. Jorgensen ‚ÄúSoftware Testing. A Craftman's Approach‚Äù, Auerbach Publications, Third Edition, 2008</em></strong> <br><br>   .        ,    , -  . <br><br>     ¬´¬ª,          . <br><br> , ,     . <br><br> <strong><em>20. Cem Kaner, ‚ÄúA Tutorial in Exploratory Testing‚Äù, 2008</em></strong> <br><br>   ,       ¬´ ¬ª.     ,     ,    . <br><br>         ,   . ,  ,   ,     ,        . <br><br>     . <br><br> <strong><em>21. James A. Whittaker, ‚ÄúHow to Break Software: A Practical Guide to Testing‚Äù, Addison-Wesley, 2002</em></strong> <br><br> <strong><em>22. James A. Whittaker, ‚ÄúHow to Break Software Security‚Äù, Addison-Wesley, 2003</em></strong> <br><br> <strong><em>23. Mike Andrews, James A. Whittaker ‚ÄúHow to Break Web Software: Functional and Security Testing of Web Applications and Web Services‚Äù, Addison-Wesley Professional, 2006</em></strong> <br><br> <strong><em>24. James A. Whittaker, ‚ÄúExploratory Software Testing: Tips, Tricks, Tours, and Techniques to Guide Test Design‚Äù, Addison-Wesley Professional, 2009</em></strong> <br><br>    ,          .        ,   ‚Äî   . <br><br> Whittaker     ,       . <br><br> ,  ,  -   Attack Patterns (  ).  ,  -   ¬´¬ª, ,  ,         . <br><br> <strong><em>25. Christoper Steel, Ramesh Nagappan, Ray Lai, ‚ÄúCore Security Patterns. Best Pracices and Strategies fo J2EE, Web Services, and Identity Management‚Äù, Prentice Hall, 2005</em></strong> <br><br>   (1088 ).            J2EE.      ,     . <br><br>     J2EE     ,   Java.  ,               . <br><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/173067/">https://habr.com/ru/post/173067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173045/index.html">So what is this ‚Äúterrible‚Äù point at the end of the domain name?</a></li>
<li><a href="../173049/index.html">Data preprocessing and model analysis</a></li>
<li><a href="../173059/index.html">Oracle ADF. Business Components</a></li>
<li><a href="../173063/index.html">Moving and renaming files in GitHub</a></li>
<li><a href="../173065/index.html">The digest of news from the world of mobile development for the last week ‚Ññ6 (March 11 - 17, 2013)</a></li>
<li><a href="../173071/index.html">Why study Clojure?</a></li>
<li><a href="../173073/index.html">Is the interface evil?</a></li>
<li><a href="../173075/index.html">Chromebook Pixel: it's easy to disassemble, it's impossible to upgrade</a></li>
<li><a href="../173079/index.html">Google Glass has already received official opponents</a></li>
<li><a href="../173081/index.html">More than 500,000 Google Reader users switched to Feedly in two days</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>