<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a Qt interface style using a table as an example.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, Qt offers developers virtually unlimited possibilities for creating interfaces. In most cases, if you use standard widgets, the appearanc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a Qt interface style using a table as an example.</h1><div class="post__text post__text-html js-mediator-article">  As you know, Qt offers developers virtually unlimited possibilities for creating interfaces.  In most cases, if you use standard widgets, the appearance of your application (and its interface elements) will match the appearance of your operating system.  To this end, Qt has a system of so-called styles - classes responsible for drawing standard interface elements.  In this article we will try to create your own style and apply it to the simplest application in order to get a beautiful table based on the <i>QTableWidget</i> widget. <br><a name="habracut"></a><br><h4>  Theoretical part </h4><br>  So let's start with the theory.  In Qt, there is an abstract class <i>called QStyle</i> , which is responsible, as it is not difficult to guess, for styling the application.  It inherits a number of classes ( <i>QWindowStyle</i> , <i>QMacStyle</i> , etc.), which are styles that emulate the standard appearance of the operating system.  We will make our own style for the application in their image and likeness.  Qt requires that custom styles be inherited not directly from <i>QStyle</i> , but from one of its successor classes.  Documentation recommends choosing the closest to the desired system style, and changing it ‚Äúby itself‚Äù.  We will inherit our class from no less abstract than <i>QStyle</i> , the <i>QCommonStyle</i> class. <br><br>  How is the drawing of elements inside the style?  The <i>QStyle</i> class has a set of functions whose names begin with the word <i>draw</i> : <br><br><ul><li>  drawComplexControl () </li><li>  drawControl () </li><li>  drawItemPixmap () </li><li>  drawItemText () </li><li>  drawPrimitive () </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each of them does its own small part of the work on drawing elements. <br><br>  <i>drawComplexControl () is</i> used to draw composite widgets, that is, those that contain several other widgets in themselves. <br>  As an example, <i>QSpinBox</i> , which, as it is easy to guess, implements the usual SpinBox and consists of an input field and two small buttons: <br><img src="https://habrastorage.org/storage2/a08/507/c39/a08507c39f6f942b351d4290bab0b7c2.png"><br><br>  <i>drawControl ()</i> draws standard widgets like buttons and input fields. <br><br>  <i>drawPrimitive ()</i> draws so-called primitive elements, such as frames. <br><br>  <i>drawItemPixmap ()</i> and <i>drawItemText ()</i> have completely speaking names and do exactly what you would expect from them.  Detailed descriptions of all functions, as well as their arguments, can be very easily found in the Qt documentation, so I will not dwell on this. <br><br>  In our example, we will create a style for the <i>QTableWidget</i> element, which is an ordinary table.  Styles for the remaining elements are made absolutely similar. <br><br><h4>  Getting started </h4><br>  First of all, create a new C ++ class.  When creating a class, Qt helpfully offers us to write its name, as well as the name of the class from which we want to inherit.  For simplicity, <i>let's</i> call it <i>myStyle</i> , and specify the inheritance from <i>QCommonStyle</i> .  After that, Qt will create us a couple of files (.h and .cpp), in which, for a start, we want to get something like this: <br><br><div class="spoiler">  <b class="spoiler_title">myStyle.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QCommonStyle&gt; class myStyle : public QCommonStyle { Q_OBJECT public: explicit myStyle(); signals: public slots: };</span></span></span></span></code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">myStyle.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mystyle.h"</span></span></span><span class="hljs-meta"> myStyle::myStyle() : QCommonStyle() { }</span></span></code> </pre><br></div></div><br><br>  Our <i>main ()</i> function will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ QApplication::setStyle( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myStyle ); <span class="hljs-function"><span class="hljs-function">QApplication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argc, argv)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">QTableWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.setGeometry(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span>,<span class="hljs-number"><span class="hljs-number">250</span></span>)); w.show(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.exec(); }</code> </pre><br><br>  As you can see, all we do is set up our style, create a widget and display it.  At this stage, we only have an empty style inherited from <i>QCommonStyle</i> , so our table will look like ... well, let's say, not very attractive: <br><br><img src="https://habrastorage.org/storage2/7bb/3a3/b12/7bb3a3b129035890074469f47ecc4051.png"><br><br>  Let us consider in more detail what the table consists of. <br><img src="https://habrastorage.org/storage2/8ce/0ed/c0d/8ce0edc0d47433fbdb2fa10ddea43e14.png"><br><br>  The structure is, in general, fairly simple and straightforward.  It is worth what to stop for a second on headlines.  In Qt, there are two kinds of headers: horizontal (the one on top) and vertical (the one on the left).  By ‚ÄúTitle Area‚Äù I mean the entire area on which the title will later be displayed.  A section is each specific cell in the header.  The unoccupied area is the part of the header where there are no sections (this happens when the total size of all sections is smaller than the size of the table). <br><br>  So, armed with this knowledge, you can stylize each element.  Start by adding functions to our class. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ControlElement element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QStyleOption *opt, QPainter *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QWidget *w)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawItemText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QPainter *painter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QRect &amp;rect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QPalette &amp;pal, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> enabled, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;text, QPalette::ColorRole textRole)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPrimitive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrimitiveElement pe, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QStyleOption *opt, QPainter *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QWidget *w)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>;</code> </pre><br><br>  Let's start with the <i>drawControl ()</i> function.  Add to the implementation code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: QCommonStyle::drawControl(element, opt, p, w); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br><br>  The key attribute of this function is <i>element</i> , which indicates the type of what we are going to draw.  Inside the <i>switch</i> 'a, we will add a <i>case</i> ' for each of those elements that we will draw ourselves.  All the rest will be processed in the <i>default</i> section using a similar function of the parent class. <br><br>  Let's start with the frame that surrounds our entire table.  I will make a gradient frame.  The upper and lower borders will be white, and the vertical borders will be drawn with a gradient: they will be white at the edges and light gray in the middle. <br><br>  To do this, add the following code to the <i>drawControl ()</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CE_ShapedFrame: { <span class="hljs-comment"><span class="hljs-comment">//  QLinearGradient gradient(0, 0, 0, opt-&gt;rect.height()); gradient.setColorAt(0, QColor(255,255,255)); gradient.setColorAt(0.5, QColor(225,225,225)); gradient.setColorAt(1, QColor(255,255,255)); QPen pen; pen.setBrush( gradient ); p-&gt;setPen(pen); //  p-&gt;drawRect( 0,0,opt-&gt;rect.width()-1, opt-&gt;rect.height()-1); } break;</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">comment</b> <div class="spoiler_text">  So, what is happening here.  First we create a linear gradient from top to bottom.  Then we set the colors for the key points, which we have three: the beginning, the end and the middle.  As I already said, we make the beginning and the end white, and the middle is a little grayish. <br><br>  After that we create a feather and set our gradient in it.  The pen in Qt draws with a brush ( <i>QBrush</i> ), which will be a gradient.  Finally, <i>using the drawRect ()</i> function, we draw our frame. <br></div></div><br><br>  Now proceed to the headlines.  The header area itself ( <i>CE_Header</i> ) does not need to be processed.  We will deal with sections and empty area.  With an empty area, everything is very simple, we will paint it with a monochromatic gray: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CE_HeaderEmptyArea: p-&gt;fillRect( opt-&gt;rect, QBrush( QColor( <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span> ) ) ); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  With sections it is necessary a little more difficult.  As we know, if you click on the table header, either the entire row or the entire column is highlighted (depending on where you clicked).  In this case, the header changes its appearance so that the user can see the change in its state.  Usually the heading is either ‚Äúpressed‚Äù or tinted.  We want to keep this functionality.  Moreover, it would be desirable that when selecting a cell or cells, the corresponding headers are also colored. <br><br>  So, add the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CE_HeaderSection: { <span class="hljs-comment"><span class="hljs-comment">//  if( opt-&gt;state &amp; State_Sunken || opt-&gt;state &amp; State_On ) { //    p-&gt;fillRect(opt-&gt;rect, QBrush( QColor(255,170,80) )); p-&gt;setPen( QPen( QColor( 170,170,170) ) ); //   p-&gt;drawRect(opt-&gt;rect.x(), opt-&gt;rect.y(),opt-&gt;rect.width()-1,opt-&gt;rect.height()-1); } else//  { //    QLinearGradient gradient(0, 0, 0, opt-&gt;rect.height()); gradient.setSpread(QGradient::PadSpread); gradient.setColorAt(0, QColor(255,255,255)); gradient.setColorAt(1, QColor(220,220,220)); //  p-&gt;fillRect(opt-&gt;rect, QBrush( gradient )); //     gradient.setColorAt(0, QColor(230,230,230)); gradient.setColorAt(0.5, QColor(175,175,175)); gradient.setColorAt(1, QColor(230,230,230)); QPen pen; pen.setStyle(Qt::SolidLine); pen.setBrush(gradient); p-&gt;setPen(pen); //   p-&gt;drawLine( opt-&gt;rect.width() + opt-&gt;rect.x() - 1, opt-&gt;rect.y() + 3, opt-&gt;rect.width() + opt-&gt;rect.x() - 1, opt-&gt;rect.height() + opt-&gt;rect.y() - 3 ); } }</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">comment</b> <div class="spoiler_text">  So, the section can be in two states: active and inactive.  In order to determine this, we check its flags.  The <i>State_Sunken</i> flag indicates that the section is pressed, and the <i>State_On</i> flag indicates that the cell belonging to the column (or row) of this section is selected.  If at least one of them is set, we paint over the section with an even orange color, and also draw a whole border for it so that the orange section does not look rough against the other (not selected) light gray parts of the header. <br><br>  If the section is inactive, we paint over it with a gradient from white to light gray and draw a border.  I decided to draw only the vertical borders of the sections, so all I need is to draw a vertical strip to the right of each section.  To make the strips not look coarse, we will draw them with a gradient almost the same as the frame of the entire table: the ends of the strips will be lighter and the middle will be darker.  To do this, we reconfigure the gradient and set it in the pen that will draw the strip. <br></div></div><br><br>  At this stage, we got a pretty nice headline.  However, when selected, our cells are still painted over with a rather ugly default color.  In addition, the standard focal frame also does not look very nice. <br><br>  The <i>CE_ItemViewItem</i> attribute is responsible for drawing the cells.  Add the following code to it: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CE_ItemViewItem: { <span class="hljs-comment"><span class="hljs-comment">//  ,       drawPrimitive(PE_PanelItemViewItem, opt, p, w); //       //    ,      . const QStyleOptionViewItemV4 * option = qstyleoption_cast&lt;const QStyleOptionViewItemV4 *&gt;(opt); if( !option ) { //  -    ,     QCommonStyle::drawControl(element, opt, p, w); return; } //       . if (option-&gt;state &amp; QStyle::State_HasFocus) { QPen pen(QColor( 170,170,170 )); p-&gt;save(); p-&gt;setPen(pen); p-&gt;drawRect(opt-&gt;rect.x(), opt-&gt;rect.y(), opt-&gt;rect.width()-1, opt-&gt;rect.height()-1); p-&gt;restore(); } //  ,      QRect textRect = subElementRect(SE_ItemViewItemText, option, w); // ,    ""    textRect.setX( textRect.x() + 5 ); textRect.setY( textRect.y() + 5 ); if( !option-&gt;text.isEmpty() ) { // . p-&gt;drawText(textRect, option-&gt;text); } }</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">comment</b> <div class="spoiler_text">  Here we had to do much more.  First, the <i>PE_PanelItemViewItem</i> element is responsible for coloring the selected cells with a different color, which is drawn in the <i>drawPrimitive ()</i> function.  Therefore, we must call this function by passing the parameters we have there.  After that, we convert the pointer to the options from the <i>QStyleOption</i> base class to the <i>QStyleOptionViewItemV4</i> class we need.  This is needed, among other things, to get the text and drawing area of ‚Äã‚Äãthis text. <br><br>  If the cell we are drawing is selected <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (option-&gt;state &amp; QStyle::State_HasFocus)</code> </pre>  then we draw a small gray frame around the whole cell. <br><br>  After that we get the size of the area where the text should have been displayed, and we indent a little so that the text does not appear close to the upper left edge.  Finally, we draw the text with the <i>drawText ()</i> function. <br></div></div><br><br>  Since, when processing cells, we call the drawPrimitive function for the PE_PanelItemViewItem element, we implement the drawing of this element so that the selected cells are painted in some more pleasant color. <br><br>  By analogy with <i>drawControl ()</i> , we add exactly the same <i>switch</i> to <i>drawPrimitive ()</i> , and immediately implement the needed cell highlighting: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( pe ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PE_PanelItemViewItem: <span class="hljs-comment"><span class="hljs-comment">//  ,    ,   . if (const QStyleOptionViewItemV4 *option = qstyleoption_cast&lt;const QStyleOptionViewItemV4 *&gt;(opt)) if (option-&gt;state &amp; QStyle::State_Selected) { p-&gt;fillRect(option-&gt;rect, QBrush( QColor( 220,220,220,100 ))); } break; default: QCommonStyle::drawPrimitive( pe, opt, p, w); break; }</span></span></code> </pre><br><br>  Finally, change the font that will display the text.  Add the following code to the <i>drawItemText ()</i> function: <br><pre> <code class="cpp hljs">painter-&gt;setPen( QPen( QColor( <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span> ))); painter-&gt;setFont(QFont(<span class="hljs-string"><span class="hljs-string">"Consolas"</span></span>)); painter-&gt;drawText(rect, text);</code> </pre><br><br>  So, we have transformed the nondescript tablet, and now it looks like this: <br><br><img src="https://habrastorage.org/storage2/03a/135/b66/03a135b66a21dcb45c6ee5c199c8bb14.png"><br><br>  which in my opinion is much better than what was originally. <br><br><h4>  The advantages of this approach </h4><br><br>  Of course, creating styles for the <i>entire</i> application in this way is a very time consuming task.  The style for one element (as in this article) can be done very quickly, but if you want to take care of all the widgets (for example, if you want to distribute your style so that other people can use it), this can take a lot of time.  The description of the elements that should be drawn for each individual widget, I, for example, did not find, and I had to determine them by the method of "scientific poking".  However, styling thus has a number of significant advantages. <br><br>  First, these styles apply to all elements.  If you have 300 tables, then you do not need to configure each one manually, the style is applied to the application in one line. <br><br>  Secondly, it is convenient to change the styles created in this way.  This is perhaps the best way to give the user the opportunity to change the style of the application through the settings.  In addition, you can be sure that your style will look the same every time. <br><br>  Sources entirely: <br><br><div class="spoiler">  <b class="spoiler_title">myStyle.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MYSTYLE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MYSTYLE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QCommonStyle&gt; #include &lt;QtGui&gt; class myStyle : public QCommonStyle { Q_OBJECT public: explicit myStyle(); void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p, const QWidget *w) const; void drawItemText(QPainter *painter, const QRect &amp;rect, int flags, const QPalette &amp;pal, bool enabled, const QString &amp;text, QPalette::ColorRole textRole) const; void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p, const QWidget *w) const; signals: public slots: }; #endif // MYSTYLE_H</span></span></span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">myStyle.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mystyle.h"</span></span></span><span class="hljs-meta"> myStyle::myStyle() : QCommonStyle() { } void myStyle::drawControl(QStyle::ControlElement element, const QStyleOption *opt, QPainter *p, const QWidget *w) const { switch( element ) { case CE_ShapedFrame: { QLinearGradient gradient(0, 0, 0, opt-&gt;rect.height()); gradient.setColorAt(0, QColor(255,255,255)); gradient.setColorAt(0.5, QColor(225,225,225)); gradient.setColorAt(1, QColor(255,255,255)); QPen pen; pen.setBrush( gradient ); p-&gt;setPen(pen); p-&gt;drawRect( 0,0,opt-&gt;rect.width()-1, opt-&gt;rect.height()-1); } break; case CE_ItemViewItem: { drawPrimitive(PE_PanelItemViewItem, opt, p, w); const QStyleOptionViewItemV4 * option = qstyleoption_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const QStyleOptionViewItemV4 *&gt;(opt); if( !option ) { QCommonStyle::drawControl(element, opt, p, w); return; } if (option-&gt;state &amp; QStyle::State_HasFocus) { QPen pen(QColor( 170,170,170 )); p-&gt;save(); p-&gt;setPen(pen); p-&gt;drawRect(opt-&gt;rect.x(), opt-&gt;rect.y(), opt-&gt;rect.width()-1, opt-&gt;rect.height()-1); p-&gt;restore(); } QRect textRect = subElementRect(SE_ItemViewItemText, option, w); textRect.setX( textRect.x() + 5 ); textRect.setY( textRect.y() + 5 ); if( !option-&gt;text.isEmpty() ) { p-&gt;drawText(textRect, option-&gt;text); } } break; case CE_Header: QCommonStyle::drawControl(element, opt, p, w); break; case CE_HeaderEmptyArea: p-&gt;fillRect( opt-&gt;rect, QBrush( QColor( 233, 233, 233 ) ) ); break; case CE_HeaderSection: { if( opt-&gt;state &amp; State_Sunken || opt-&gt;state &amp; State_On ) { p-&gt;fillRect(opt-&gt;rect, QBrush( QColor(255,170,80) )); p-&gt;save(); p-&gt;setPen( QPen( QColor( 170,170,170) ) ); p-&gt;drawRect(opt-&gt;rect.x(), opt-&gt;rect.y(),opt-&gt;rect.width()-1,opt-&gt;rect.height()-1); p-&gt;restore(); } else { QLinearGradient gradient(0, 0, 0, opt-&gt;rect.height()); gradient.setSpread(QGradient::PadSpread); gradient.setColorAt(0, QColor(255,255,255)); gradient.setColorAt(1, QColor(220,220,220)); p-&gt;fillRect(opt-&gt;rect, QBrush( gradient )); gradient.setColorAt(0, QColor(230,230,230)); gradient.setColorAt(0.5, QColor(175,175,175)); gradient.setColorAt(1, QColor(230,230,230)); QPen pen; pen.setStyle(Qt::SolidLine); pen.setBrush(gradient); p-&gt;setPen(pen); p-&gt;drawLine( opt-&gt;rect.width() + opt-&gt;rect.x() - 1, opt-&gt;rect.y() + 3, opt-&gt;rect.width() + opt-&gt;rect.x() - 1, opt-&gt;rect.height() + opt-&gt;rect.y() - 3 ); } } break; default: QCommonStyle::drawControl(element, opt, p, w); break; } } void myStyle::drawItemText(QPainter *painter, const QRect &amp;rect, int flags, const QPalette &amp;pal, bool enabled, const QString &amp;text, QPalette::ColorRole textRole) const { painter-&gt;setPen( QPen( QColor( 30, 30, 30 ))); painter-&gt;setFont(QFont("Consolas")); painter-&gt;drawText(rect, text); } void myStyle::drawPrimitive(QStyle::PrimitiveElement pe, const QStyleOption *opt, QPainter *p, const QWidget *w) const { switch( pe ) { case PE_PanelItemViewItem: if (const QStyleOptionViewItemV4 *option = qstyleoption_cast&lt;const QStyleOptionViewItemV4 *&gt;(opt)) if ((option-&gt;state &amp; QStyle::State_Selected)) p-&gt;fillRect(option-&gt;rect, QBrush( QColor( 220,220,220,100 ))); break; default: QCommonStyle::drawPrimitive( pe, opt, p, w); break; } }</span></span></span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/149687/">https://habr.com/ru/post/149687/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149684/index.html">Review of Content Designers (Content Construction Kit) for CMS Joomla</a></li>
<li><a href="../149685/index.html">Black color - taboo, myth or necessity?</a></li>
<li><a href="../149686/index.html">Forth processor on VHDL</a></li>
<li><a href="../149691/index.html">Pleasant trifle in the "Express Office" - comfortable keyboard</a></li>
<li><a href="../149693/index.html">KNN classifier</a></li>
<li><a href="../149694/index.html">RabbitMQ tutorial 1 - Hello World</a></li>
<li><a href="../149695/index.html">Monitoring PHP Code Performance with Pinba</a></li>
<li><a href="../149696/index.html">CERN - what is the organization for $ 900 million</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>