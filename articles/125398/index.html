<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenCL: universality and high performance or is it not so simple?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, there were already articles about OpenCL, CUDA and GPGPU with performance comparisons, basic concepts and examples, so I‚Äôm not going to talk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenCL: universality and high performance or is it not so simple?</h1><div class="post__text post__text-html js-mediator-article">  On Habr√©, there were already articles about OpenCL, CUDA and GPGPU with performance comparisons, basic concepts and examples, so I‚Äôm not going to talk about the basics and principles of operation here, even the code will not show.  But I want to describe what are the real difficulties in using the GPU (about the limitations and their consequences), why it is impossible to compare the performance of the CPU and the GPU, and also about how ‚Äúuniversal‚Äù OpenCL really is. <br><a name="habracut"></a><br><h4>  Foreword </h4><br>  My acquaintance with GPGPU began 1.5 years ago and is still ongoing as an active research project.  Then I had a choice: OpenCL or CUDA, there was no difference in the choice, at that time, but the university began to teach a course about OpenCL, so I chose it.  I‚Äôll just say that I wrote only for cards with NVidia architecture, so I‚Äôll talk about it (most often about Fermi). <br><br>  <i>At this point there was a big paragraph about the history and state of affairs in the area of ‚Äã‚Äãcalculations on the GPU, but after describing the problems, the post was too long and the paragraph was severely curtailed (there is hope that he will return in the next part).</i>  <i>Therefore, let us proceed immediately to why the algorithms ported to the GPU do not always work quickly, i.e.</i>  <i>give in practice 0.5X-10X performance gains instead of the promised 20X-100X relative to the CPU (otherwise every application would have already used it).</i> <br><br><h4>  How slow is it? </h4><br>  So, we all know that the GPU architecture differs significantly from the CPU, but few people think about how much this difference is and how much it affects the development of algorithms for the GPU.  Man, although it is a rather parallel system, is used to thinking about algorithms consistently.  For the past XX years, processors have indulged us in this and we are all accustomed to the fact that one command is executed after the other.  And we are accustomed to the fact that the resources available to the program are practically unlimited (we don‚Äôt remember about microcontrollers), and the data can be obtained almost immediately.  Almost all programming and optimization techniques are based on this.  Only here with the GPU it does not work and I want to try to describe the consequences of our habits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Restriction one: <b>32 threads (warp) always execute ONE command</b> </h5><br>  If somewhere before this command there was a branch and the threads went in different ways, then the GPU will execute both branches sequentially. <br>  Thus, an attempt to simplify the calculations for a particular case (if the general and short solution of the problem is known) can lead not to an acceleration of the calculations (which always happens on the CPU), but to the addition of the calculation time for the general and particular cases. <br>  Another example: each core chooses a different algorithm depending on the type of data, for example, it is necessary to calculate the distance from a point to a geometric shape and each core gets a different shape and, accordingly, a different algorithm.  As a result, the total time will be the sum of the execution time of the algorithm for each object. <br>  And it turns out that we consider everything exactly as consistently as the CPU (and with many nested branches, we consider the GPU much more than the CPU), but with a consistent calculation of the GPU will be ten times slower.  Pay attention to how many if-s in your programs, although if all 32 threads follow one path, then everything is ok, but does this often happen in all branches? <br><br><h5>  The second limitation: <b>128 bytes are always read sequentially with each memory access, even if we only need 1 byte.</b> </h5><br>  And one more stream can access only 16 bytes from the 128 bytes at a time. <br>  The result is that the memory bandwidth is more than 150Gb / s, but only if all 128 bytes are used constantly.  If each stream must read one large structure that weighs 40 bytes, then each stream must make 3 memory requests and download 3 * 128 bytes.  And if the data for each stream is located in different places (and the stream receives a pointer to them and then loads, the situation is quite normal for the CPU when the memory is spent rationally), then the useful memory bandwidth is 40 * 32 / (128 * 3 * 32) , that is, about 10% of the real. <br>  And again, we are closer to the available memory bandwidth CPU.  You can certainly remember about the fact that there is a cache, but it appeared only at Fermi and it is not so big, although it helps significantly.  On the other hand, we can recall that in the first versions of the GPU, even when sequentially reading 128 bytes, if they are not read sequentially and / or shifted by at least one byte, a separate memory request is made for each stream. <br><br><h5>  The third limitation: <b>memory latency is approximately 800 cycles for each request</b> </h5><br>  And in the last example, to obtain data by all processes, it is necessary to make 3 * 32 requests ... almost 80 thousand cycles ... What should be done at this time?  Execute other threads and new restrictions appear here. <br><br><h5>  Fourth restriction: <b>32k registers are allocated to all active threads of the multiprocessor</b> </h5><br>  At first it seems that a lot, but they are allocated to all active threads, and not just running ones (and they are allocated statically to the maximum, as much as is necessary in the worst branching, so much will be allocated).  And the active threads should be 1536 to hide the memory latency (try to calculate whether it is easy to hide 80 thousand cycles from the last example), that is, there are 21 registers per stream.  Try to implement a complex algorithm and fit into 21 registers (these are not only variables, but also intermediate results of operations, cycle counters, etc., etc.).  On the other hand, you can try to use less than fifteen hundred active threads and then the following limitation appears. <br><br><h5>  The fifth limitation: the <b>Fermi flow scheduler can start threads only in groups of 512 pieces (it was easier before Fermi, around 128)</b> </h5><br>  That is, only 3 options are available: 1536 flows if each uses less than 21 registers, 1024 flows if less than 32 registers are used or 512 flows, there is less in any way.  At the same time, a smaller number of threads means serious problems with an attempt to hide the memory latency and downtime of the whole multiprocessor for thousands of cycles. <br>  And this is much worse than the CPU.  And the worst happens if each thread uses more than 64 registers. <br><br><h5>  Restriction sixth: <b>if the stream uses more than 64 registers, then they are stored in global memory</b> </h5><br>  I still can not believe that in the global memory, and not in the local, but the documentation says so.  That is, there are additional requests to the memory.  By the way, to call functions, the stack is used, which also occupies registers (yes, functions are bad). <br><br>  To combat the use of registers and load optimization, there is also a shared memory (shared, which I don‚Äôt remember correctly in Russian).  But its only 16 / 48Kb and it is divided between all active groups, that is, if each group eats 25kb of memory, then more than one group will not work with all the ensuing consequences. <br><br><h5>  Seventh restriction: the <b>launch of each core is accompanied by a slight delay</b> </h5><br>  In fact, everything is not so terrible here, this delay is measured in tens of microseconds.  But if you run the kernel 1000 times, then it is already tens of milliseconds, which in the case of real-time calculations (for example, rendering) immediately creates a 15FPS limit, even without taking into account the time of the calculations themselves. <br><br><h5>  There should have been a conclusion, but it will be next time. </h5><br>  Once I sold, but already got too long list.  But you still need to remember about synchronization, atomic operations, copying data to a device, load balancing for each card (SLI does not work here), accuracy, special functions, driver curves, debugging, and much more.  Yes, and about the real universality of OpenCL, I have to say a lot.  Well, okay, let's postpone it until the following parts. <br><br>  And, in general, the developers certainly know (with the advent of experience after much agony) about many (but not all) constraints and try to optimize the code so that they can get around it, but imagine how much time it takes to remake the algorithms that were developed without thinking on the GPU, and not all algorithms can be altered in principle.  But I slowly ‚Äúcomprehend Zen‚Äù and understand that not everything is so bad and you can get the promised teraflops, and I also promise to write about this in the following parts of the OpenCL story. </div><p>Source: <a href="https://habr.com/ru/post/125398/">https://habr.com/ru/post/125398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125384/index.html">Adobe Edge: HTML5 / JavaScript Animation Editor</a></li>
<li><a href="../125394/index.html">On high</a></li>
<li><a href="../125395/index.html">Salaries and cost of living in Silicon Valley</a></li>
<li><a href="../125396/index.html">CSS hacks</a></li>
<li><a href="../125397/index.html">Beautiful parsing email alerts from the bank</a></li>
<li><a href="../125399/index.html">Museum of video cards. Mindfulness first</a></li>
<li><a href="../125400/index.html">Seismic monitoring systems: overview, installation, configuration</a></li>
<li><a href="../125401/index.html">What to do with the huge old topics on the forums?</a></li>
<li><a href="../125402/index.html">ASUS Pro P31 / 41: Everest Testing</a></li>
<li><a href="../125403/index.html">The third largest Bitcoin exchange lost the file wallet.dat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>