<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Integrating the equations of motion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A physics simulation makes small predictions based on the laws of physics. These predictions are actually quite simple, something like ‚Äúif an object i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Integrating the equations of motion</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a96/83d/23e/a9683d23e95d2687fb5a96edf1a11206.png" alt="image"><br><br>  A physics simulation makes small predictions based on the laws of physics.  These predictions are actually quite simple, something like ‚Äúif an object is right here and it moves with such speed in this direction, then in a short period of time it will be right here.‚Äù  We create such predictions using a mathematical technique called integration. <br><br>  The topic of this article will be the implementation of such integration. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Integrating the equations of motion </h2><br>  You may remember from a high school or university course that force is equal to the product of mass and acceleration. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>F</mi><mo>=</mo><mi>m</mi><mi>a</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.109ex" height="2.057ex" viewBox="0 -780.1 3491.6 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-46" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-3D" x="1027" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-6D" x="2083" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-61" x="2962" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>F</mi><mo>=</mo><mi>m</mi><mi>a</mi></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> F = ma </script></p><br>  Let us transform this equation and see that the acceleration is equal to the force divided by the mass.  This is in line with our intuitive expectations, because heavy objects are harder to throw. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>a</mi><mo>=</mo><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>m</mi><mi>a</mi><mo>=</mo><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>m</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.619ex" height="2.66ex" viewBox="0 -832 7586.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-61" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-3D" x="807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-66" x="1863" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-2F" x="2414" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-6D" x="2914" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-61" x="3793" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-3D" x="4600" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-66" x="5656" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-2F" x="6207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-6D" x="6707" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>a</mi><mo>=</mo><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>m</mi><mi>a</mi><mo>=</mo><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>m</mi></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> a = f / ma = f / m </script></p><br>  Acceleration is the rate of change of speed over time: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>d</mi><mi>v</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>d</mi><mi>t</mi><mo>=</mo><mi>a</mi><mo>=</mo><mi>F</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>m</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.932ex" height="2.66ex" viewBox="0 -832 7720.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-64" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-76" x="523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-2F" x="1009" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-64" x="1509" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-74" x="2033" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-3D" x="2672" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-61" x="3728" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-3D" x="4535" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-46" x="5592" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-2F" x="6341" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-6D" x="6842" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mi>v</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>d</mi><mi>t</mi><mo>=</mo><mi>a</mi><mo>=</mo><mi>F</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>m</mi></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> dv / dt = a = F / m </script></p><br><br>  Similarly, speed is the rate of change of position over time: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>d</mi><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>d</mi><mi>t</mi><mo>=</mo><mi>v</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.99ex" height="2.66ex" viewBox="0 -832 4301.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-64" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-78" x="523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-2F" x="1096" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-64" x="1596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-74" x="2120" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMAIN-3D" x="2759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/341986/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi7mIeqi4NRPxkhFqQdt8L9IuduhA#MJMATHI-76" x="3815" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>d</mi><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>d</mi><mi>t</mi><mo>=</mo><mi>v</mi></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> dx / dt = v </script></p><br>  This means that if we know the current position and speed of the object, as well as the forces applied to it, we can integrate to find its position and speed at a certain point in time. <br><a name="habracut"></a><br><h2>  Numerical integration </h2><br>  If you have not studied the differential equations at the university, then you can breathe easy - you are almost in the same situation as those who studied them, because we will not solve differential equations analytically.  Instead, we will seek a solution by <strong>numerical integration</strong> . <br><br>  Here's how numerical integration works: first, let's start from the starting position and speed, then take a small step forward to find the speed and position in the future.  Then we repeat this, moving forward in small steps, using the result of previous calculations as the starting point of the following. <br><br>  But how do we find the change in speed and position at each step? <br><br>  The answer lies in the <strong>equations of motion</strong> . <br><br>  Let's call our current time <strong>t</strong> , and the time step <strong>dt</strong> or "delta time". <br><br>  Now we can present the equations of motion in a form that everyone understands: <br><br><pre>  acceleration = force / mass
     position change = speed * dt
     speed change = acceleration * dt </pre><br>  Intuitively, this is understandable: if you are in a car moving at a speed of 60 km / h, then in one hour you will drive 60 km.  Similarly, a car accelerating at 10 km / h per second, after 10 seconds, will move 100 km / h faster. <br><br>  Of course, this logic is preserved only when the acceleration and speed are constant.  But even if they change, then this is a good approximation to begin with. <br><br>  Let's present it in the code.  We start with a stationary object weighing one kilogram and apply a constant force of 10 kN (kilonewtons) to it and take a step forward, assuming that one time step is equal to one second: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> t = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> force = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mass = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( t &lt;= <span class="hljs-number"><span class="hljs-number">10.0</span></span> ) { position = position + velocity * dt; velocity = velocity + ( force / mass ) * dt; t += dt; }</code> </pre> <br>  Here is the result: <br><br><pre> <code class="cpp hljs"> t=<span class="hljs-number"><span class="hljs-number">0</span></span>: position = <span class="hljs-number"><span class="hljs-number">0</span></span> velocity = <span class="hljs-number"><span class="hljs-number">0</span></span> t=<span class="hljs-number"><span class="hljs-number">1</span></span>: position = <span class="hljs-number"><span class="hljs-number">0</span></span> velocity = <span class="hljs-number"><span class="hljs-number">10</span></span> t=<span class="hljs-number"><span class="hljs-number">2</span></span>: position = <span class="hljs-number"><span class="hljs-number">10</span></span> velocity = <span class="hljs-number"><span class="hljs-number">20</span></span> t=<span class="hljs-number"><span class="hljs-number">3</span></span>: position = <span class="hljs-number"><span class="hljs-number">30</span></span> velocity = <span class="hljs-number"><span class="hljs-number">30</span></span> t=<span class="hljs-number"><span class="hljs-number">4</span></span>: position = <span class="hljs-number"><span class="hljs-number">60</span></span> velocity = <span class="hljs-number"><span class="hljs-number">40</span></span> t=<span class="hljs-number"><span class="hljs-number">5</span></span>: position = <span class="hljs-number"><span class="hljs-number">100</span></span> velocity = <span class="hljs-number"><span class="hljs-number">50</span></span> t=<span class="hljs-number"><span class="hljs-number">6</span></span>: position = <span class="hljs-number"><span class="hljs-number">150</span></span> velocity = <span class="hljs-number"><span class="hljs-number">60</span></span> t=<span class="hljs-number"><span class="hljs-number">7</span></span>: position = <span class="hljs-number"><span class="hljs-number">210</span></span> velocity = <span class="hljs-number"><span class="hljs-number">70</span></span> t=<span class="hljs-number"><span class="hljs-number">8</span></span>: position = <span class="hljs-number"><span class="hljs-number">280</span></span> velocity = <span class="hljs-number"><span class="hljs-number">80</span></span> t=<span class="hljs-number"><span class="hljs-number">9</span></span>: position = <span class="hljs-number"><span class="hljs-number">360</span></span> velocity = <span class="hljs-number"><span class="hljs-number">90</span></span> t=<span class="hljs-number"><span class="hljs-number">10</span></span>: position = <span class="hljs-number"><span class="hljs-number">450</span></span> velocity = <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br>  As you can see, at every step we know both the position and the speed of the object.  This is numerical integration. <br><br><h2>  Explicit Euler Method </h2><br>  The kind of integration that we just used is called the <strong>explicit Euler method</strong> . <br><br>  It is named after the Swiss mathematician <a href="https://en.wikipedia.org/wiki/Leonhard_Euler">Leonard Euler</a> , who first discovered this technique. <br><br>  Euler integration is the simplest numerical integration technique.  It is 100% accurate only when the rate of change during the time step is constant. <br><br>  Since in the example above the acceleration is constant, the integration of speed is performed without errors.  However, we also integrate the speed to obtain the position, and the speed increases due to acceleration.  This means that an error occurs in the integrated position. <br><br>  But how big is this mistake?  Let's find out! <br><br>  There is an analytical solution to the movement of an object with constant acceleration.  We can use it to compare a numerically integrated position with the exact result: <br><br><pre>  s = ut + 0.5at ^ 2
     s = 0.0 * t + 0.5at ^ 2
     s = 0.5 (10) (10 ^ 2)
     s = 0.5 (10) (100)
     s = 500 meters </pre><br>  After 10 seconds, the object should have moved 500 meters, but the apparent Euler method gives us a result of 450. That is, an error of as much as 50 meters in just 10 seconds! <br><br>  It seems that this is incredibly bad, but in games, usually for a physics step, not such a large time interval is taken.  In fact, physics is usually calculated with a frequency approximately equal to the frame rate of the display. <br><br>  If you set the step <strong>dt</strong> = <sup>1</sup> ‚ÅÑ <sub>100</sub> , then we get a much better result: <br><br><pre> <code class="cpp hljs"> t=<span class="hljs-number"><span class="hljs-number">9.90</span></span>: position = <span class="hljs-number"><span class="hljs-number">489.552155</span></span> velocity = <span class="hljs-number"><span class="hljs-number">98.999062</span></span> t=<span class="hljs-number"><span class="hljs-number">9.91</span></span>: position = <span class="hljs-number"><span class="hljs-number">490.542145</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.099060</span></span> t=<span class="hljs-number"><span class="hljs-number">9.92</span></span>: position = <span class="hljs-number"><span class="hljs-number">491.533142</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.199059</span></span> t=<span class="hljs-number"><span class="hljs-number">9.93</span></span>: position = <span class="hljs-number"><span class="hljs-number">492.525146</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.299057</span></span> t=<span class="hljs-number"><span class="hljs-number">9.94</span></span>: position = <span class="hljs-number"><span class="hljs-number">493.518127</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.399055</span></span> t=<span class="hljs-number"><span class="hljs-number">9.95</span></span>: position = <span class="hljs-number"><span class="hljs-number">494.512115</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.499054</span></span> t=<span class="hljs-number"><span class="hljs-number">9.96</span></span>: position = <span class="hljs-number"><span class="hljs-number">495.507111</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.599052</span></span> t=<span class="hljs-number"><span class="hljs-number">9.97</span></span>: position = <span class="hljs-number"><span class="hljs-number">496.503113</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.699051</span></span> t=<span class="hljs-number"><span class="hljs-number">9.98</span></span>: position = <span class="hljs-number"><span class="hljs-number">497.500092</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.799049</span></span> t=<span class="hljs-number"><span class="hljs-number">9.99</span></span>: position = <span class="hljs-number"><span class="hljs-number">498.498077</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.899048</span></span> t=<span class="hljs-number"><span class="hljs-number">10.00</span></span>: position = <span class="hljs-number"><span class="hljs-number">499.497070</span></span> velocity = <span class="hljs-number"><span class="hljs-number">99.999046</span></span></code> </pre> <br>  As you can see, this is a fairly good result, definitely enough to play. <br><br><h2>  Why Euler's explicit method is not (always) good </h2><br>  With a sufficiently small time step, the explicit Euler method with constant acceleration gives quite decent results, but what happens if the acceleration is not constant? <br><br>  A good example of variable acceleration is <a href="https://ccrma.stanford.edu/CCRMA/Courses/152/vibrating_systems.html">the spring shock absorber system</a> . <br><br>  In this system, the mass is attached to the spring, and its movement is extinguished by something like friction.  There is a force proportional to the distance to the object, which attracts it to the starting point, and a force proportional to the speed of the object, but directed in the opposite direction, which slows it down. <br><br>  Here, the acceleration during a time step changes absolutely exactly, but this ever-changing function is a combination of position and speed, which themselves constantly change in a time step. <br><br>  Here is an example of a <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2580%25D0%25BC%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BE%25D1%2581%25D1%2586%25D0%25B8%25D0%25BB%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580">harmonic oscillator with attenuation</a> .  This is a well-studied problem, and for it there is an analytical solution that can be used to verify the result of numerical integration. <br><br>  Let's start with a weakly damped system, in which the mass oscillates near the starting point, gradually slowing down. <br><br>  Here are the input parameters of the mass-spring system: <br><br><ul><li>  Weight: 1 kilogram </li><li>  Starting position: 1000 meters from the starting point </li><li>  Coefficient of elasticity according to Hooke's law: k = 15 </li><li>  Hooke's damping coefficient: b = 0.1 </li></ul><br>  And here is the exact solution graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/0f6/030/6e10f60309f445526109e02f3a313dfa.png"></div><br><br>  If for the integration of this system we apply the explicit Euler method, then we obtain the following result, which I scaled vertically: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b67/0b1/a89/b670b1a892c3664f9654a53e3a293dfd.png"></div><br><br>  Instead of attenuation and convergence with the starting point, the system gains energy over time! <br><br>  When integrating by the explicit Euler method and with <strong>dt</strong> = <sup>1</sup> ‚ÅÑ <sub>100,</sub> this system is unstable. <br><br>  Unfortunately, since we are already integrating with a small time step, we do not have practical ways to increase accuracy.  Even if we reduce the time step, there will always be a coefficient of elasticity k, at which we get this behavior. <br><br><h2>  Euler's Symplectic Method </h2><br>  We can consider another integrator, <a href="https://en.wikipedia.org/wiki/Semi-implicit_Euler_method">the Euler symplectic method</a> . <br><br>  Most commercial gaming physics engines use this integrator. <br><br>  The transition from the explicit to the symplectic method of Euler consists only in the replacement of: <br><br><pre> <code class="cpp hljs"> position += velocity * dt; velocity += acceleration * dt;</code> </pre> <br>  on: <br><br><pre> <code class="cpp hljs"> velocity += acceleration * dt; position += velocity * dt;</code> </pre> <br>  Using the Euler symplectic integrator with <strong>dt</strong> = <sup>1</sup> ‚ÅÑ <sub>100</sub> for the spring shock absorber system gives a stable result, very close to the exact solution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/0f6/030/6e10f60309f445526109e02f3a313dfa.png"></div><br><br>  Even though the Euler symplectic method has the same degree of accuracy as the explicit method (degree 1), we get a much better result when integrating the equations of motion, because it is <a href="https://en.wikipedia.org/wiki/Symplectic_integrator">symplectic</a> . <br><br><h2>  There are many other integration methods. </h2><br>  And now for something completely different. <br><br>  <a href="http://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node3.html">The implicit Euler method</a> is an integration method that is well suited for integrating rigid equations that become unstable with other methods.  Its disadvantage is that it requires solving a system of equations at each time step. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%2592%25D0%25B5%25D1%2580%25D0%25BB%25D0%25B5">Integration Verlet</a> provides greater accuracy than the implicit Euler method, and requires less memory when simulating a large number of particles.  This is a second degree integrator, which is also symplectic. <br><br>  There is a whole family of integrators, called <strong>Runge-Kutta methods</strong> .  In fact, the explicit Euler method is considered part of this family, but it includes integrators of higher order, the most classic of which is the Runge-Kutta method of order 4 (Runge Kutta order 4) or simply <strong>RK4</strong> . <br><br>  This family of integrators is named after the German physicists who discovered them: <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D1%2583%25D0%25BD%25D0%25B3%25D0%25B5,_%25D0%259A%25D0%25B0%25D1%2580%25D0%25BB">Karl Runge</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2580%25D1%2582%25D0%25B8%25D0%25BD_%25D0%2592%25D0%25B8%25D0%25BB%25D1%258C%25D0%25B3%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BC_%25D0%259A%25D1%2583%25D1%2582%25D1%2582%25D0%25B0">Martin Kutta</a> . <br><br>  RK4 is a fourth-order integrator, that is, the accumulated error is of the order of the fourth derivative.  This makes the method very accurate, much more accurate than the explicit and implicit Euler methods that have only the first order. <br><br>  But although it is more accurate, one cannot say that RK4 automatically becomes the ‚Äúbest‚Äù integrator, or even that it is better than Euler‚Äôs symplectic method.  Everything is much more complicated.  However, this is a rather interesting integrator and is worth exploring. <br><br><h2>  RK4 implementation </h2><br>  There are already many explanations for the mathematics used in RK4.  For example: <a href="https://en.wikipedia.org/wiki/Runge%25E2%2580%2593Kutta_methods">here</a> , <a href="http://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node5.html">here</a> and <a href="https://www.researchgate.net/publication/49587610_A_Simplified_Derivation_and_Analysis_of_Fourth_Order_Runge_Kutta_Method">here</a> .  I strongly recommend studying its derivation and understand how and why it works at the mathematical level.  But I understand that the target audience of this article is programmers, not mathematicians, therefore we will consider only implementation here.  So let's get started. <br><br>  Before we begin, let's set the state of an object as a struct in C ++ so that it is convenient to store the position and speed in one place: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//  float v; //  };</span></span></code> </pre> <br>  We also need a structure to store the derived state values: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derivative</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx; <span class="hljs-comment"><span class="hljs-comment">// dx/dt =  float dv; // dv/dt =  };</span></span></code> </pre> <br>  Now we need a function to calculate the state of physics from t to t + dt using one set of derivatives, and then to calculate the derivatives in the new state: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">Derivative </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> State &amp; initial, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Derivative &amp; d )</span></span></span><span class="hljs-function"> </span></span>{ State state; state.x = initial.x + d.dx*dt; state.v = initial.v + d.dv*dt; Derivative output; output.dx = state.v; output.dv = acceleration( state, t+dt ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br>  The acceleration function controls the entire simulation.  Let's use it in the spring shock absorber system and return the acceleration for a unit mass: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceleration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> State &amp; state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> k = <span class="hljs-number"><span class="hljs-number">15.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -k * state.x - b * state.v; }</code> </pre> <br>  What needs to be written here, of course, depends on the simulation, but it is necessary to structure the simulation so that it is possible to calculate the acceleration inside this method for a given state and time, otherwise it will not work for the integrator RK4. <br><br>  Finally, we get the integration procedure itself: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">integrate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( State &amp; state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt )</span></span></span><span class="hljs-function"> </span></span>{ Derivative a,b,c,d; a = evaluate( state, t, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, Derivative() ); b = evaluate( state, t, dt*<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, a ); c = evaluate( state, t, dt*<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, b ); d = evaluate( state, t, dt, c ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dxdt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">6.0f</span></span> * ( a.dx + <span class="hljs-number"><span class="hljs-number">2.0f</span></span> * ( b.dx + c.dx ) + d.dx ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dvdt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">6.0f</span></span> * ( a.dv + <span class="hljs-number"><span class="hljs-number">2.0f</span></span> * ( b.dv + c.dv ) + d.dv ); state.x = state.x + dxdt * dt; state.v = state.v + dvdt * dt; }</code> </pre> <br>  The RK4 integrator samples the derivative at four points to determine the curvature.  Notice how the derivative a is used in calculating b, b is used in calculating c, and c for d.  This transfer of the current derivative to the next calculation gives the integrator RK4 its accuracy. <br><br>  It is important that each of these derivatives a, b, c and d will be <em>different</em> when the rate of change in these quantities is a function of time or a function of the state itself.  For example, in our spring damper system, acceleration is a function of the current position and speed, which vary in time steps. <br><br>  After calculating the four derivatives, the best total derivative is calculated as a weighted sum obtained from the expansion in <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D1%258F%25D0%25B4_%25D0%25A2%25D0%25B5%25D0%25B9%25D0%25BB%25D0%25BE%25D1%2580%25D0%25B0">a Taylor series</a> .  This combined derivative is used to move the position and speed forward in time, just as we did in the explicit Euler integrator. <br><br><h2>  Comparison of the symplectic method of Euler and RK4 </h2><br>  Let's test the integrator RK4. <br><br>  Obviously, since he is a higher-order integrator (fourth versus the first), he will be visually more accurate than Euler‚Äôs symplectic method, right? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/24f/777/c7224f7771ab7bc288bea553c9cc7c2d.png"></div><br><br>  <strong>It is not true</strong> .  Both integrators are so close to the exact result that with such a scale it is almost impossible to find a difference between them.  Both integrators are stable and repeat the exact solution very well with <strong>dt</strong> = <sup>1</sup> <sub>100</sub> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/83d/23e/a9683d23e95d2687fb5a96edf1a11206.png"></div><br>  With the increase it can be seen that RK4 is <em>indeed</em> more accurate than the symplectic method of Euler, but is this precision worth the complexity and extra runtime of RK4?  It's hard to judge. <br><br>  Let's try and see if we can find a significant difference between the two integrators.  Unfortunately, we will not be able to observe this system for a long time, because it quickly decays to zero, so let's move on to a <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D1%2580%25D0%25BC%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BE%25D1%2581%25D1%2586%25D0%25B8%25D0%25BB%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580">simple harmonic oscillator</a> that oscillates infinitely and without attenuation. <br><br>  Here is the exact result to which we will strive: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/810/352/d94/810352d94534f71ae77a588e0cdd9502.png"></div><br><br>  To complicate the task of integrators, let's increase the time step to 0.1 seconds. <br><br>  Now let's launch integrators for 90 seconds and zoom in: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/352/cf2/8a8/352cf28a81fcbb61410c796f366efbdc.png"></div><br><br>  After 90 seconds, Euler's symplectic method (the orange curve) shifted in phase with respect to the exact solution, because its frequency was slightly different, while the green RK4 curve corresponds to the frequency, but it loses energy! <br><br>  We can clearly notice this by increasing the time step to 0.25 seconds. <br><br>  RK4 retains the correct frequency, but loses energy: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/609/1ac/3d4/6091ac3d45bac91d517ef3d1e08aa0fb.png"></div><br><br>  And the Euler symplectic method on average saves energy much better: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/a66/2a0/48ca662a0e2a2510e7d8ea6ad358e87b.png"></div><br><br>  But from shifts from phase.  What an interesting result!  As you can see, if the RK4 has a higher order of accuracy, then it is not necessarily "better."  There are many nuances in this matter. <br><br><h2>  Conclusion </h2><br>  We implemented three different integrators and compared the results. <br><br><ol><li>  Explicit Euler Method </li><li>  Euler's Symplectic Method </li><li>  Runge-Kutta method of order 4 (RK4) </li></ol><br>  So which integrator should be used in the game? <br><br>  I recommend <strong>the Euler symplectic method</strong> .  It is ‚Äúcheap‚Äù and simple to implement, much more stable than the explicit Euler method and, on average, tends to conserve energy even under close to extreme conditions. <br><br>  If you really need greater accuracy than the Euler symplectic method, I recommend looking at higher order <a href="https://en.wikipedia.org/wiki/Symplectic_integrator">symplectic integrators</a> designed for <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D0%25BC%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25B0_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0">Hamiltonian systems</a> .  In this way, you will learn more advanced high order integration techniques that are better suited for simulations than RK4. <br><br>  Finally, if you still write this in the game: <br><br><pre>  position + = velocity * dt;
     velocity + = acceleration * dt; </pre><br>  Then take a second and replace these lines with: <br><br><pre>  velocity + = acceleration * dt;
     position + = velocity * dt; </pre><br>  Believe me, you'll be glad of it. </div><p>Source: <a href="https://habr.com/ru/post/341986/">https://habr.com/ru/post/341986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341976/index.html">Hackathon for all from GDG & WTM Moscow</a></li>
<li><a href="../341978/index.html">How to search for IT jobs in the EU</a></li>
<li><a href="../341980/index.html">We do well with Swift 4, Perfect, Protobuf and MySQL on a Linux server</a></li>
<li><a href="../341982/index.html">Laboratory: welcome to C ++ User Group Meetup</a></li>
<li><a href="../341984/index.html">Olympiad tasks in industrial programming. Part 1</a></li>
<li><a href="../341988/index.html">Model-Update-View pattern and dependent types</a></li>
<li><a href="../341990/index.html">How Badoo is gaining developers</a></li>
<li><a href="../341992/index.html">Optimization of securities portfolio using Python</a></li>
<li><a href="../341996/index.html">Installing SSL certificate on Zimbra</a></li>
<li><a href="../341998/index.html">Board game design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>