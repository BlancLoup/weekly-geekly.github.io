<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Just about lists, dictionaries and sets or TOP 5 data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. Her! Do not say ‚ÄúDamn it! I know the difference between the list and the vector; I don‚Äôt need this article. ‚Äù Please look under the cut and refre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Just about lists, dictionaries and sets or TOP 5 data structures</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/692/2e6/b3c/6922e6b3c5f24194a962b949f995f121.jpg"><br><br>  Hey.  Her!  Do not say ‚ÄúDamn it!  I know the difference between the list and the vector; I don‚Äôt need this article. ‚Äù  Please look under the cut and refresh your knowledge.  I hope, however, that you can learn a lot more from this article, and some may finally figure out why there are so many types of data for collections of objects. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  It just so happens that in the programming of the collection there are many, there are not very many different entities - lists, arrays, vectors, sets, stacks, queues, associative arrays, and most of these data structures have several more subspecies. <br><br>  There must be reasons why there are so many different variations for a simple representation of any set of objects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Should there be a difference between a list and an array?  Between an associative array and a hash table? <br><br><h4>  Collection </h4><br>  For starters, the most boring (yes, I love that).  What is a collection in general? <br><br>  A collection is a data structure (type, class, or even better, an interface) that is designed to contain a number of objects (depending on the language and terminology, they must be of the same type or may be of different types). <br><br>  Different types of collections can be static or dynamic, i.e.  change their size or remain constant, can be ordered (more precisely taking into account the order of the elements) and unordered (respectively not taking into account). <br><br>  Several standard operations are provided above the collections (now we‚Äôll talk about mutable, i.e. changeable collections), such as: getting the size, adding an element, deleting an element, searching (there is any element in the collection or not), there are a lot of them. <br><br>  Okay, I did my secret duty, now let's go! <br><br><h2>  1 Vector (Vector, Array) </h2><br><img src="https://habrastorage.org/files/3ac/4b7/b9d/3ac4b7b9d84f451dbac797de874962f3.jpg"><br>  <i>And what were you waiting for?</i> <br><br>  A vector (also known as a one-dimensional array) is an ordered set of elements with random access by numeric index.  What is important to us in this definition?  Never mind.  Just kidding, in fact, almost every word is important to us: <br><br>  Elements are accessed by a numeric index (usually starting with the 0th index, although there are exceptions), usually accessing an element of the collection by index is written as myFavoriteCats [i] or blackKitties [5].  Moreover, to denote this very number - the index, use the letter i. <br><br>  And when one letter is not enough, they drag j and k here. <br><br>  So, further we understand that access is arbitrary - it means we can refer to the elements under the indices 0, 42, 2014 and generally expect that the operation will be O (1) complexity, i.e.  constant, and no matter which element we request, it will immediately return to us at the speed of light. <br><br>  Next - the vector is an ordered collection, which is actually understandable - we have such concepts as the first, last element, for each specific element we can also name the previous and the next. <br><br><h4>  Release </h4><br>  Typically, a vector (as a low-level structure) will be a descriptor containing various information, inseparable from the structure itself (the only thing that is best to keep there is a vector size) and a pointer to the first element. <br><br>  Such an implementation will allow for constant time to get access to an arbitrary element of the vector by its index, as well as allow copying, concatenation and other simple operations at a low level. <br><br>  And indeed, it is very easy to get access to a certain element - we add an index to the pointer to the first item (with some corrections for the size of the data type) and we get a pointer to the desired item!  It remains to dereference and we have the necessary kitty in the variable! <br><br>  Okay, a vector is a cool structure, but it also has flaws (and who doesn‚Äôt have them?), For example, you can't just take a new element and add it to the vector!  Especially cram it in the middle.  It is also impossible to say that we have cats with numbers 0, 1 and 4, but not with numbers 2 and 3 (they used to be, but it turned out that they were dogs). <br><br>  One can imagine a vector as a bookshelf with compartments, in each of which exactly one book fits.  To shove a new novel by Dontsova between the 10th and 11th volume of the Great Sovetskaya Encyclopedia, you need to try hard and shift all volumes from the 11th to the 65th volume (you can cheat and put the 11th volume in the end, but I don‚Äôt he said, and in that case we will lose orderliness). <br><br><img src="https://habrastorage.org/files/24b/734/065/24b734065c3d4060a917106fdfce6ef7.png"><br>  <i>In my memory, everything is exactly that</i> <br><br><h4>  Application </h4><br>  In our case, the vector would be perfect for the top 10 cutest kittens, because  There is no need to add and delete elements (only change), there should be no gaps between the 1st and the 5th place, and it‚Äôs convenient to call the number. <br><br>  Okay.  In any case, the vector is cool, we just see what other collections are there. <br><br><h2>  2 List </h2><br><img src="https://habrastorage.org/files/0d4/f23/10a/0d4f2310aa454b39836e85b46f0ffa2b.jpg"><br>  <i>First volume</i> <br><br>  Wow!  Task list for today, shopping list in the store.  Wedding guest list ... So.  Get to the point. <br><br>  We already know that the elements of the vector lie neatly one after another, beautifully and evenly.  This gives us both advantages and disadvantages. <br><br>  The list in this respect is the completely opposite thing - its elements can be scattered in memory as you please!  Because of this, we lose the ability to quickly get an item on the index, and we can not quickly copy the entire list, but we get a pretty nice thing - we can insert items in constant time to any place!  According to rumors, elements from the list are also deleted for O (1). <br><br><h4>  Implementation </h4><br>  Hm  And what about the formal definition? <br><br>  A list is an ordered set of elements, for each of which a pointer to the next one is stored (or for a doubly linked list and the next and previous one) list items. <br><br>  For the last item in the list, we store a null pointer (in the diagrams I‚Äôll use a null cat pointer, don't be intimidated). <br><br>  Attention!  In a canon list implementation, in order to get the size of the list, it is necessary to bypass the entire list ‚Äî reaching the null pointer (linear time is O (n) complexity) and although in some implementations the size is cached in the list descriptor (or in the first element), not worth relying on it. <br><br><img src="https://habrastorage.org/files/273/b3a/00b/273b3a00b840451e95d7eb7d41c37a2f.png"><br>  <i>If I could, I would place one list item at the north pole, and the other somewhere in the area of ‚Äã‚ÄãBetelgeuse</i> <br><br><h4>  Application </h4><br>  The list would be suitable for (attention!) List of homeless kittens, sorted by age (ascending).  We just need to add and remove items from the list often (you don‚Äôt think anything like that - kittens are taken away), and the first elements of the list are more often needed - I would take myself a little fluffy kitten, rather than an 8-year-old mana. <br><br>  Okay.  Lists are kind of a simple structure.  What else is there? <br><br><h2>  3 Set </h2><br><img src="https://habrastorage.org/files/7dd/7c5/623/7dd7c56239994943bdd2013505a5b580.jpg"><br>  <i>This is Seth</i> <br><br>  A similar concept is in mathematics, and more precisely in set theory.  The set is different from both the vector and the list, although their implementation may be similar. <br><br>  A set is an unordered set of elements, without repetitions.  Wow  And all?  No you random access, nothing!  Why is this necessary? <br><br>  As we know in the vector, you can quickly get an element by index, in the list you can quickly add or remove an element, and what about the set? <br><br>  In the set, you can quickly check whether there is any element inside, or it is not.  Let's say if I wanted to find out if a particular cat is on my favorite list, then for the list and for the vector I would have to go through (in the worst case) all the elements! <br><br><h4>  Implementation </h4><br>  In the set, because  it is out of order, you can sort the elements when adding and in which case arrange a binary search.  Hm  This is a paradox, a collection is unordered, but inside everything will be in order.  Here it is important to understand that if you add a new element to the set, it is not a fact that it will go to the end. <br><br>  In fact, when working with a set, one cannot rely on any order of elements at all, it can be any - that is why it is a set and an unordered collection. <br><br>  It should be noted that the set can be implemented in many different ways, for example, you can use hashing to search for items even faster, so I‚Äôll not consider the implementation in detail.  Let me just say that you can cheat and use our knowledge on the lists. <br><br>  In general, there are also ordered sets, sets with repetitions (multiset), and probably there should be an ordered multiset. <br><br><img src="https://habrastorage.org/files/2cb/c3d/aa7/2cbc3daa736842c996d044097ff28dd0.png"><br>  <i>Set theory is easier if you take a lot of kittens</i> <br><br><h4>  Application </h4><br>  A lot of ideal for a list of your favorite kittens, because they are many.  Ha!  Just kidding <br><br>  But it really does, because such a collection does not need to be sorted (orderliness is not important) and we can easily check if any particular cat is in this set (let's say I have 100 kittens and loved ones I feed with shrimps). <br><br>  Okay.  The sets are good too, but is there really something else? <br><br><h2>  4 Vocabulary (Associative Array, Map, Dictionary) </h2><br><img src="https://habrastorage.org/files/17e/60d/900/17e60d90088145c98c98063acaa66aae.jpg"><br>  <i>Admit it is better than just a dictionary</i> <br><br>  A dictionary (it is an associative array) is the same vector, but with slight differences.  Not only numbers, but also any other data types (even other collections!) Can act as an index (which will be called in the dictionary).  Gaps are also allowed if we still use an integer as a key, for example, we may have an element associated with key 5, but there is no element associated with key 4. <br><br>  What does all this mean in practice?  The only thing is that in square brackets for the image to the element on the ‚Äúindex‚Äù we can indicate an arbitrary type, for example allMyCats [‚ÄúMurka‚Äù]. <br><br><h4>  Implementation </h4><br>  Naked it is clear that you can simply start an array (or list) of pairs (Key, Value) and add a special function that will run through this list and return a specific value by the key associated with it. <br><br>  We also cannot say which pair is the first, which is the last, and that it used to be ‚ÄúMurka‚Äù or ‚ÄúBorka‚Äù, therefore the dictionary is considered an unordered structure. <br><br>  Again, only one value can be associated with each key, so for the given example the dictionary doesn‚Äôt fit the dictionary in its purest form. <br><br>  The implementation, as is the case with the set, can be completely different, you can arrange pairs by key and use binary search to get the element (in this case, the elements must be ordered).  Again, you can implement a dictionary using key hashing, which is quite often used with strings. <br><br><h4>  Application </h4><br>  The most plausible and competent way is to use a dictionary along with a list, where the dictionary key is a string ‚Äî the name of the cat, and the value ‚Äî a list of cats with that name.  This will allow you to quickly find all the cats named Murka and select the one that is currently needed. <br><br><img src="https://habrastorage.org/files/e19/518/f35/e19518f359c8491385bf185c322b7e3e.png"><br>  <i>It looks like this in memory std :: map &lt;std :: color, std :: list &lt;std :: cat &gt;&gt;</i> <br><br>  And I have news for you - the types of collections are over.  Well, that's it.  Generally no more.  Totally. <br><br><h2>  5 Stack </h2><br><img src="https://habrastorage.org/files/5e7/7b4/e0a/5e77b4e0afe34006b43092355795816c.jpg"><br>  <i>Another cat will be Stack Overflow</i> <br><br>  Ha!  I deceived you (I am joking)  There are also a couple of data structures that represent collections. <br><br>  So a stack is a collection with unusual access, more precisely with unusual rules regarding how elements can be added and removed. <br><br>  It's simple - the added item, called the ‚Äúlast‚Äù, is the first to leave the stack. <br><br>  The stack is very necessary and useful in programming.  For example, using the stack, a nested procedure call is performed ‚Äî the return address and the arguments of the function being called are saved to the stack. <br><br><h4>  Implementation </h4><br>  In the high-level implementation, there is nothing particularly interesting - a pointer to the list and elements are added to the beginning of this list, and removed from it. <br><br>  In the low-level implementation (more precisely, how it is implemented in modern architectures) there are interesting moments. <br><br>  The stack there is a small reserved area of ‚Äã‚Äãmemory and two pointers are stored together with it - at the beginning of the stack (where the first added element is) and at the end of the stack - where the last added one lies. <br><br>  If you put too much data on the stack, the program will end with a familiar error ‚Äî Stack Overflow, which means that the pointer to the end of the stack has exceeded the upper allowable limit. <br><br>  The reverse situation can also happen (Stack Underflow), if you try to pick up more from the stack than it does, but it does not occur in high-level languages ‚Äã‚Äã(understand why - we are not allowed to directly work with the stack). <br><br>  If anyone is interested in how it all works - studying assembler for some popular architecture, like i386, can help you. <br><br><h4>  Application </h4><br>  One could describe in this place a stack of poor kittens as high as a mountain, but in fact in high-level languages ‚Äã‚Äãthe stack is rarely needed, often there is enough recursion, which uses the stack implicitly.  I didn‚Äôt use a contrived example (and couldn‚Äôt think of a normal one, I'm sorry), so let's go on to the next item. <br><br><h2>  miscellanea </h2><br>  In fact, there are a lot of collections, such as a queue, a two-way queue (decks), a two-linked list, a ring set, and priority queues. <br><br>  There are trees (yes their whole forest!) And graphs. <br><br>  There are probabilistic data structures, such as a probabilistic set and a list with gaps. <br><br>  I really want to write about all this, but time and space in the habr is not always enough. <br><br>  However, there are many (or vector) things related to the topic, which I would like to mention at least in passing, let the curious reader ask me to go read a smart book. <br><br><h4>  Strings </h4><br>  First of all, how strings are implemented in some languages ‚Äã‚Äãmay seem strange.  The simplest and most effective solution is probably the solution. C - a string is a character set, with a null character at the end, which allows you to do without a descriptor. <br><br>  In C ++, std :: string is already more like a vector. <br><br>  Well, in the old Pascal descriptor (most precisely, only the length) is stored in the zero element of the array. <br><br>  In Haskell, a String is a list of characters ([Char]), which means that obtaining the length of a string has complexity O (n).  But they are very convenient to run around recursively. <br><br>  In general, a string is an ordered set of characters and no more.  Which type of collection will be used is not important (well, I would not advise using a lot, ha!). <br><br><h4>  Queue </h4><br>  The queue is very similar to the stack and at the same time is its opposite - the first we get back is not the element that we added last, but the one that ‚Äústands in line‚Äù the longest.  The queue is a very convenient structure, but despite the fact that the principle of its work is similar to the stack, there is a slight difference in the effective implementation. <br><br>  For the stack, we could cheat and allocate an acceptable size of memory, in which case expanding it, because the stack either decreases or increases, because  elements and are added and removed ‚Äúfrom one end‚Äù.  If we present the work of the queue, it will ‚Äúcrawl in memory‚Äù - the beginning will constantly move upwards, so the trick that is applicable to the stack will work worse and there will be much better to use a doubly linked list (and do not forget to store pointers to the first and the last items). <br><br>  You can also try to implement the queue on two stacks, but this is also less effective. <br><br>  There is also a deck (two-way queue - deque).  It is possible to add elements both at the end and at the beginning.  And take them, too, and from the end and from the beginning. <br><br><h2>  Conclusion </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/004/284/bc4/004284bc4cf13b1e61e733b674640960.jpg"><br>  <i>Wow</i>  <i>I'm starting to repeat</i> <br><br>  I did not mention at all about the combination of various collections, thanks to which matrices and tables are formed.  Also, I did not touch the trees, the ring set, wrote almost nothing about the queue, very little information on hashing (I did get away with a couple of words from this topic) and other optimization methods. <br><br>  However, I think the article will fulfill its role - it will simply and clearly state the basics of data structures for readers of varying degrees of preparedness.  And I will be happy to continue and highlight many (or all, ha!) Other topics in the same vein. <br><br>  Thanks to those who were able to read this up to these lines (how did they endure it?). <br><br>  Bye and good luck! </div><p>Source: <a href="https://habr.com/ru/post/232009/">https://habr.com/ru/post/232009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231989/index.html">AppVeyor</a></li>
<li><a href="../231991/index.html">Flight to the moon landing on the lunar base</a></li>
<li><a href="../231997/index.html">How we ‚Äútrained the fire monkey‚Äù or our experience with FMX</a></li>
<li><a href="../232005/index.html">The Role of Elon Mask in PayPal History</a></li>
<li><a href="../232007/index.html">Math, STA? !! 1</a></li>
<li><a href="../232011/index.html">Potato Salad Gathered $ 55,500 on Kickstarter</a></li>
<li><a href="../232013/index.html">Cocos2d-x: Writing on Lua</a></li>
<li><a href="../232015/index.html">Javascript to typeScript - translation difficulties</a></li>
<li><a href="../232017/index.html">Useful materials for mobile developer # 64 (June 28-August 3)</a></li>
<li><a href="../232019/index.html">Krita: Four-Point Perspective Transformations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>