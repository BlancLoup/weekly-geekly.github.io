<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Atomic processing of data blocks without blocking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Using non-blocking algorithms has always been frightening for the developer. It is very difficult to imagine the organization of data access without b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Atomic processing of data blocks without blocking</h1><div class="post__text post__text-html js-mediator-article">  Using non-blocking algorithms has always been frightening for the developer.  It is very difficult to imagine the organization of data access without blocking, so that two or more streams could not simultaneously process the same data block.  Most developers use standard containers such as stacks or linked lists without blocking, but no more.  In this article, I would like to tell you how to organize data access in a multi-threaded environment without blocking. <br><br>  The main idea of ‚Äã‚Äãthis method is that each stream uses a separate buffer, into which it copies data from the main buffer, processes it, and then swaps the pointer to its buffer with the pointer to the main buffer. <a name="habracut"></a>  Consider the following code: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; struct data_s { int a; int b; }; struct data_s reader_tmp, writer_tmp, data; struct data_s *reader_tmp_ptr, *writer_tmp_ptr, *data_ptr; int done = 0; void process(struct data_s *data) { data-&gt;a++; data-&gt;b++; } void* writer(void* p) { struct data_s *tmp_ptr; int i; for(i = 0; i &lt; 1000000; i++) { do { tmp_ptr = data_ptr; writer_tmp_ptr-&gt;a = tmp_ptr-&gt;a; writer_tmp_ptr-&gt;b = tmp_ptr-&gt;b; process(writer_tmp_ptr); } while(!__sync_compare_and_swap(&amp;data_ptr, tmp_ptr, writer_tmp_ptr)); writer_tmp_ptr = tmp_ptr; } } void* reader(void *p) { struct data_s *tmp_ptr; int a, b; while(!done) { do { tmp_ptr = data_ptr; reader_ptr-&gt;a = tmp_ptr-&gt;a; reader_ptr-&gt;b = tmp_ptr-&gt;b; a = tmp_ptr-&gt;a; b = tmp_ptr-&gt;b; } while(!__sync_bool_compare_and_swap(&amp;data_ptr, tmp_ptr, reader_tmp_ptr)); reader_tmp_ptr = tmp_ptr; printf(‚Äúdata = {%d, %d}\n‚Äù, a, b); } } int main() { pthread_t reader_thread, writer_thread; data.a = 0; data.b = 0; data_ptr = &amp;data; writer_tmp_ptr = &amp;writer_tmp; reader_tmp_ptr = &amp;reader_tmp; pthread_create(&amp;read_thread, NULL, reader, NULL); pthread_create(&amp;write_thread, NULL, writer, NULL); pthread_join(write_thread, NULL); done = 1; pthread_join(read_thread, NULL); return 0; }</span></span></span></span></code> </pre> <br>  In the above code, the data before processing is copied from the buffer pointed by data_ptr to the buffer pointed to by writer_tmp_ptr.  And then these pointers are swapped.  Moreover, in data_ptr, a writer_tmp_ptr is written using the atomic operation compare_and_swap, which compares the first argument with the second, and if they match, writes the third argument to the first and returns true.  Otherwise, it returns false.  What is it for?  Consider the example of the reader function.  Let a thread performing this function pause after the line a = tmp_ptr-&gt; a;  At this moment, tmp_ptr points to data.  Immediately began to work the stream that performs the function writer.  Having performed the first iteration, he reversed the writer_tmp_ptr and data_ptr and started the next iteration, stopping after the line data-&gt; b ++;  In this situation, writer_tmp_ptr points to data and tmp_ptr in the reader function points to data.  It turns out simultaneous reading and modification of the same buffer.  But since the data_ptr and tmp_ptr pointers no longer match, the compare_and_swap operation will detect the collision and perform the read operation again.  Why does the assignment of reader_tmp_ptr = tmp_ptr fail this check? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It's simple.  The variable reader_tmp_ptr is a specific variable for the stream in which it runs.  In this example, I made it global, which is not entirely correct, because  in the case of several reading streams, one would have to set another global variable for the second stream, and determine which thread is currently running in the function to use one or another variable as a unique pointer to the buffer.  The best option is to use a so-called.  flow-specific variables.  For example, the pthread library has such great features as pthread_getspecific / pthread_setspecific.  The purpose of writing this code was to show the reader how the algorithm works.  Without optimizations that can only confuse the idea of ‚Äã‚Äãthe essence. <br><br>  It would seem that everything is perfect, the program should display a pair of identical values, but everything is not so simple.  Imagine also that the thread performing the reader function stopped after the line a = tmp_ptr-&gt; a;  whereupon, the thread performing the writer function has completed 2 iterations and executes the third.  Stopping after the completion of the process function.  Next, the thread performing the reader function resumes its work.  In this situation, the values ‚Äã‚Äãof the variables a and b do not match, but the operation compare_and_swap returns true, since  data_ptr points to data again, in other words data_ptr and tmp_ptr match again.  This is called an <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_ABA">ABA problem</a> .  One way to solve this problem is to add a counter to the index, which is incremented every time a new value is assigned to it.  In the following example, there is no such problem. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;pthread.h&gt; struct data_s { int a; int b; }; struct data_pointer_s { union { uint64_t qw[2]; struct { struct data_s *data_ptr; uint64_t aba_counter; }; }; }; static inline char cas128bit(volatile struct data_pointer_s *a, struct data_pointer_s b, struct data_pointer_s c) { char result; __asm__ __volatile__( "lock cmpxchg16b %1\n\t" "setz %0\n" : "=q" (result) , "+m" (a-&gt;qw) : "a" (b.data_ptr), "d" (b.aba_counter) , "b" (c.data_ptr), "c" (c.aba_counter) : "cc" ); return result; } struct data_s reader_tmp, writer_tmp, data; struct data_pointer_s reader_tmp_ptr, writer_tmp_ptr, data_ptr; int done = 0; void process(struct data_s *data) { data-&gt;a++; data-&gt;b++; } void* writer(void* p) { struct data_pointer_s tmp_ptr; int i; for(i = 0; i &lt; 1000000; i++) { do { tmp_ptr = data_ptr; writer_tmp_ptr.data_ptr-&gt;a = tmp_ptr.data_ptr-&gt;a; writer_tmp_ptr.data_ptr-&gt;b = tmp_ptr.data_ptr-&gt;b; process(writer_tmp_ptr.data_ptr); writer_tmp_ptr.aba_counter = tmp_ptr.aba_counter + 1; } while(!cas128bit(&amp;data_ptr, tmp_ptr, writer_tmp_ptr)); writer_tmp_ptr = tmp_ptr; } } void* reader(void *p) { struct data_pointer_s tmp_ptr; int a, b; while(!done) { do { tmp_ptr = data_ptr; reader_tmp_ptr.data_ptr-&gt;a = tmp_ptr.data_ptr-&gt;a; reader_tmp_ptr.data_ptr-&gt;b = tmp_ptr.data_ptr-&gt;b; a = tmp_ptr.data_ptr-&gt;a; b = tmp_ptr.data_ptr-&gt;b; reader_tmp_ptr.aba_counter = tmp_ptr.aba_counter + 1; } while(!cas128bit(&amp;data_ptr, tmp_ptr, reader_tmp_ptr)); reader_tmp_ptr = tmp_ptr; printf("data = {%d, %d}\n", a, b); } } int main() { pthread_t reader_thread, writer_thread; data.a = 0; data.b = 0; data_ptr.data_ptr = &amp;data; data_ptr.aba_counter = 0; writer_tmp_ptr.data_ptr = &amp;writer_tmp; writer_tmp_ptr.aba_counter = 0; reader_tmp_ptr.data_ptr = &amp;reader_tmp; reader_tmp_ptr.aba_counter = 0; pthread_create(&amp;reader_thread, NULL, reader, NULL); pthread_create(&amp;writer_thread, NULL, writer, NULL); pthread_join(writer_thread, NULL); done = 1; pthread_join(reader_thread, NULL); return 0; }</span></span></span></span></code> </pre><br>  It should be noted that the effectiveness of this code depends on the volume of copied data and on the complexity of the process function.  If atomic processing of data blocks of several tens of megabytes is required, then using mutexes would be much more efficient.  It would also be nice to consider adding a small delay (on the order of a few microseconds) every time after compare_and_swap returns false, to allow another thread to complete the operation.  Again, the presence of delay and time will directly depend on the specifics of the task being performed. <br><br>  Separately, I would like to thank <a href="http://habrahabr.ru/users/vladvic/" class="user_link">vladvic</a> for helping to understand and understand how this algorithm works. </div><p>Source: <a href="https://habr.com/ru/post/271583/">https://habr.com/ru/post/271583/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271571/index.html">Introduction to AutoCAD Architecture</a></li>
<li><a href="../271573/index.html">First February - International Aid Day</a></li>
<li><a href="../271575/index.html">Improving network security with Content Security Policy</a></li>
<li><a href="../271577/index.html">We will load everything: demonstration of the –ÜXIA solution for load tests</a></li>
<li><a href="../271581/index.html">How to master PowerShell professionally in 5 days and become a ‚Äúlazy‚Äù administrator?</a></li>
<li><a href="../271585/index.html">We need less powerful programming languages.</a></li>
<li><a href="../271587/index.html">Microsoft has withdrawn the updated Windows 10 from the download portal</a></li>
<li><a href="../271589/index.html">IBM Watson taught to discuss world-class problems</a></li>
<li><a href="../271591/index.html">Centralized Email Alerts</a></li>
<li><a href="../271593/index.html">Micro-conference UX-Environment ‚Ññ26: Design Education in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>