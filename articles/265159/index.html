<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Our Service is both dangerous and difficult or some aspects of the survival of services in Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instead of introducing 
 Many practical tasks require the execution of various background actions, whether it be playing music, exchanging data with t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Our Service is both dangerous and difficult or some aspects of the survival of services in Android</h1><div class="post__text post__text-html js-mediator-article"><h3>  Instead of introducing </h3><br>  Many practical tasks require the execution of various background actions, whether it be playing music, exchanging data with the server, or simply tracking the actions of the user in order to steal credit card details from him.  Well, if it does not work out, then at least fill it with targeted advertising, using the information received.  As everyone knows long ago, in Android such things are made out in the form of a service (Service). <br><br>  Official documentation states that Android OS stops the service only in case of insufficient memory.  However, there are other cases.  The user can stop the service himself using the tools provided by the Settings / Apps menu, in the same place he can make a complete stop of the application.  But for this he needs to strain and, in general, be aware of his actions and their consequences.  Unfortunately, for the destruction of the service he has other opportunities that he can use unconsciously.  In particular, if at least one Activity that was visible in history was previously launched in our application, the user will be able to handle the corresponding task with just one finger movement.  Paradoxically, along the way, Android will knock out the whole process along with the service. <br><br>  Personally, this behavior of Android does not seem logical to me.  A user often simply cleans Recent Apps from a long-forgotten stuff, it is not at all necessary that he wants to give up the benefits that the running service provides him.  However, Google developers thought a little differently.  In a different way, in a different way, their right, but in the end, we too must somehow live. <br><a name="habracut"></a><br>  So, the framework of the simplest application for working out methods of struggle. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SomeActivity.java: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Activity: onCreate"</span></span>); Intent serviceIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, MyService.class); startService(serviceIntent); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Activity: onDestroy"</span></span>); } }</code> </pre> <br>  KamikadzeService.java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KamikadzeService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IBinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Service: onCreate"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startId)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Service: onStartCommand"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> START_STICKY; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Service: onDestroy"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTaskRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent rootIntent)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Service: onTaskRemoved"</span></span>); } }</code> </pre><br>  Everything is elementary here.  SomeActivity at creation starts the KamikadzeService service, which, in turn, starts as sticky or sticky.  For agents of hostile platforms, I will explain that the service at start gives an indication to the operating system in case of an unexpected termination of the service, restart it at the first opportunity.  It does this by returning the START_STICKY from the onStartCommand method.  If the service is not sticky, then after the user deletes the task, she will not have a chance of rebirth after death. <br><br>  The onTaskRemoved method is called by the system just as the user deletes the task.  Here it is absolutely necessary to mention the android: stopWithTask service attribute, which can be set in the manifest.  As you can guess by its name (or simply by reading the documentation), if android: stopWithTask = ‚Äùtrue‚Äù, then the voluntary movement of the user's finger on the desired square in the Recent Tasks List, along with deleting the task, will also stop the service.  Since in this case the service will be considered as agreeing to stop, no one will restart automatically - she died, she died. <br><br>  At the very beginning of my struggle for the relative stability of services, having discovered the presence of this flag, I was naive to assume that the problem will be solved by installing android: stopWithTask = ‚Äùfalse‚Äù and the service will no longer die with the task.  Alas, reality and dreams had a number of significant differences.  Indeed, in this case, the system will not stop the service.  She will just beat her without a warning.  By the way, by default this attribute is ‚Äúfalse‚Äù, from which it was already possible to guess that its explicit installation will lead to nothing <br><br>  For equally ingenious developers, to summarize: the value of the service attribute android: stopWithTask does not affect its chances of remaining alive after the task is deleted by the user, the service is doomed in any case.  This attribute only determines which method the service will be called before it is destroyed.  If it is ‚Äútrue‚Äù, then the onDestroy method will be called for the service (not in all cases, to put it mildly, but more on that later).  And if the attribute is ‚Äúfalse‚Äù, then the last breath of the service, noticeable to the developer, will be the launch of the onTaskRemoved method. <br><br>  After examining all this and experimenting thoroughly with the above program, we can draw the following conclusion: we cannot avoid the death of the background service when deleting a task.  Well, it will not work and will not work, in the end, no one promised an easy life.  Since the system can restart our sticky service, let it do it.  And we will simply keep her condition from time to time, restoring it when the service is revived from the ashes.  Alas, not so simple. <br><br><h3>  KitKat.  No rest for the wicked </h3><br>  Back in the USSR at the end of the 80s, in the framework of the program ‚ÄúHow many nights there with Thames Television‚Äù showed an advertisement for KitKat chocolate.  At that time, no one heard KitKat, but the advertisement was new and viewed it with interest.  And I perfectly remembered the slogan, which now and stuck in the name of the section.  For it reflects. <br><br>  As a preface.  It was mentioned above that when android: stopWithTask = ‚Äùtrue‚Äù, the service stops, that is, before death it receives its soothing onDestroy.  So it was before the advent of Android KitKat, with the advent of which everything has changed subtly.  When a user deletes a task in this and later versions of Android, the service will move to another world ... without a trace.  In the vast majority of cases.  Unless of course, do not count the possible onDestroy call from the Activity, which fell under the finger of the user.  Obviously, all this makes android: stopWithTask completely useless for our purposes. <br><br>  But the release of Android KitKat is well remembered by the developers of background services for no reason at all.  The fact is that in the original versions of this version there was one entertaining detail, which at one time personally drove me into a state of deep depression.  KitKat never restarted sticky services. <br><br>  And then there were the cries of shower programmers on stackoverflow, a bunch of tickets to Google, fixes, updates, etc.  How many of these firmware are still alive on the devices, no one knows.  But the fact that they still come across is for sure.  Solution to the forehead with an attempt to restart the service <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTaskRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent rootIntent)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Service: onTaskRemoved"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT == <span class="hljs-number"><span class="hljs-number">19</span></span>) { Intent restartIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, getClass()); startService(restartIntent); } }</code> </pre><br>  It does not give anything, since Android will first work off the start, and only then, with a calm conscience, will destroy the service.  Here you have to add a crutch in the form of AlarmManager: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTaskRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent rootIntent)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"Service: onTaskRemoved"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT == <span class="hljs-number"><span class="hljs-number">19</span></span>) { Intent restartIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, getClass()); AlarmManager am = (AlarmManager) getSystemService(ALARM_SERVICE); PendingIntent pi = PendingIntent.getService(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, restartIntent, PendingIntent.FLAG_ONE_SHOT); restartIntent.putExtra(‚ÄúRESTART‚Äù am.setExact(AlarmManager.RTC, System.currentTimeMillis() + <span class="hljs-number"><span class="hljs-number">3000</span></span>, pi); } }</code> </pre><br><br>  That is, we plan to restart the service manually three seconds after deleting the task.  Time taken from the ceiling. <br><br><h3>  Cutting edge groping intelligence </h3><br>  The one who read this article first remembers my statement about the inevitability of the death of background service when deleting a task.  I admit, I manipulated terms here a little.  In fact, the service has a way to remain safe and sound, but in the form of foreground service.  For example: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KamikadzeService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Override public void onCreate() { Log.i("Test", "Service: onCreate"); Notification.Builder builder = new Notification.Builder(this) .setSmallIcon(R.drawable.ic_launcher); Notification notification; if (Build.VERSION.SDK_INT &lt; 16) notification = builder.getNotification(); else notification = builder.build(); startForeground(777, notification); } // ... }</span></span></code> </pre><br>  When creating the service creates a notification, in our case it is just an application icon.  The created notification is transmitted to the startForeground method and - voila - the service becomes almost immortal.  Deleting a task will not affect it in any way, and even if there is a shortage of memory, it will stop only as a last resort.  Almost the only way to stop it is to press the corresponding buttons in Settings / Apps, which, in general, was required.  So why should I have a garden before this?  And the point is this very notice that Google has long demanded to bring the service to the fore.  It is noticeable to the user, noticeable even if it is created with a transparent icon.  And for a number of applications this is not always good.  I‚Äôm not talking about Trojans and other malicious programs now, their creators are hardly concerned about the problem being described in general, since, by definition, they don‚Äôt have to show the user something they can pull.  Just showing notifications, not due to a real need, looks, in my opinion, silly.  The user also feels this and often it even annoys him, as can be seen from the comments to some applications on Google Play. <br><br>  But against the notifications, we found methods, though it is no longer a crutch, but rather, a hack.  Add another service to the project: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HideNotificationService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IBinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Notification.Builder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Notification.Builder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setSmallIcon(R.drawable.ic_launcher); Notification notification; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) notification = builder.getNotification(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> notification = builder.build(); startForeground(<span class="hljs-number"><span class="hljs-number">777</span></span>, notification); stopForeground(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } }</code> </pre><br>  And onCreate in KamikadzeService rewrite so: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KamikadzeService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Override public void onCreate() { Log.i("Test", "Service: onCreate"); Notification.Builder builder = new Notification.Builder(this) .setSmallIcon(R.drawable.ic_launcher); Notification notification; if (Build.VERSION.SDK_INT &lt; 16) notification = builder.getNotification(); else notification = builder.build(); startForeground(777, notification); Intent hideIntent = new Intent(this, HideNotificationService.class); startService(hideIntent); } // ... }</span></span></code> </pre><br>  The essence of the approach is that the HideNotificationService service, having come out not foreground with the same identifier 777, goes back to the back with the removal of its notification.  At the same time, the KamikadzeService notification is also destroyed, but the latter remains in the foreground, and already "at first glance, as if it is not visible."  After that, the HideNotificationService service stops working.  It should be clarified that the order of launching services, as well as their coming to the forefront, does not matter here, the main thing is to ensure that stopForeground second (HideNotificationService) is called later than startForeground first (KamikadzeService).  And the equality of the identifiers transmitted in startForeground is necessary. <br><br>  And here again a reasonable question arises - if all this works fine, why did I chew about the habits of ‚Äúpurely‚Äù background services earlier for a long time and tediously?  Yes, because the described technique is hack and hack is dirty enough to be used for a long time.  Although in the emulator with the recently arrived Android 6.0 it still works.  Hope or not hope - the reader decides. </div><p>Source: <a href="https://habr.com/ru/post/265159/">https://habr.com/ru/post/265159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265143/index.html">Testing flash storage. Huawei Dorado 2100 G2</a></li>
<li><a href="../265149/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 8. ‚ÄúWelcome to America‚Äù</a></li>
<li><a href="../265153/index.html">Preview of the first updates of the Microsoft Edge web platform</a></li>
<li><a href="../265155/index.html">Stabilization of time-lapse video on a calculator (IPython + OpenCV)</a></li>
<li><a href="../265157/index.html">About false posts in the VC or how many operations per second the human brain performs</a></li>
<li><a href="../265161/index.html">Another serious Android vulnerability found</a></li>
<li><a href="../265163/index.html">Google does not forgive mistakes: confrontation with Google Play</a></li>
<li><a href="../265165/index.html">Writing a webpack plugin</a></li>
<li><a href="../265167/index.html">Deep Learning Hardware</a></li>
<li><a href="../265169/index.html">Hekslet: new courses + webinars about VIM, programming, English</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>