<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recipes for ELFs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is quite a bit of information in Russian about how to work with ELF files (Executable and Linkable Format is the main format of Linux executable...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recipes for ELFs</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/xk/e_/v6/xke_v6gzyavn2y7zh5skzlm3op0.jpeg" alt="image"></p><br><p>  There is quite a bit of information in Russian about how to work with ELF files (Executable and Linkable Format is the main format of Linux executable files and many Unix systems).  We do not claim full coverage of all possible scenarios of working with elves, but we hope that the information will be useful in the form of a reference book and a collection of recipes for programmers and reverse engineers. </p><br><p>  It is understood that the reader is familiar with the ELF format at the basic level (otherwise we recommend the cycle of articles <a href="http://www.intezer.com/executable-linkable-format-101-part1-sections-segments/">Executable and Linkable Format 101</a> ). </p><br><p>  Under the cat will be listed the tools for the work, described techniques for reading meta-information, modifications, checks and <del>  breeding </del>  creating elves, as well as links to useful materials. </p><a name="habracut"></a><br><blockquote>  - I am also an elf ... Blue to red ... Elves are very patient ... Blue to red ... And we are elves! .. Blue to red ... Magic is the only trouble ... <br>  (c) The small kingdom of Ben and Holly </blockquote><br><h1 id="instrumenty">  Instruments </h1><br><p>  In most cases, examples can be run on both Linux and Windows. </p><br><p>  In the recipes we will use the following tools: </p><br><ul><li>  binutils utilities (objcopy, objdump, readelf, strip); </li><li>  framework <a href="https://www.radare.org/r/">radare2</a> ; </li><li>  hex editor with support for file templates (in the examples <a href="https://www.sweetscape.com/010editor/">010Editor is</a> shown, but you can use, for example, free <a href="https://codisec.com/veles/">Veles</a> ); </li><li>  Python and <a href="https://lief.quarkslab.com/">LIEF</a> library; </li><li>  other utilities (links are listed in the recipe). </li></ul><br><h1 id="testovye-elfy">  Test Elves </h1><br><p>  We will use the <em>simple</em> ELF file from nutcake <a href="https://crackmes.one/crackme/5c11e1f333c5d41e58e00579">'s PieIsMyFav</a> on crackmes.one as the ‚Äútest subject,‚Äù but any member of the ‚Äúelven‚Äù family will do.  If the finished file with the required characteristics was not found in the public domain, then a way to create such an elf will be given. </p><br><p>  "Free" elves can also be found on the links: </p><br><ul><li>  <a href="https://github.com/JonathanSalwan/binary-samples">Examples of elves for different platforms</a> ; </li><li>  <a href="https://github.com/radare/radare2-regressions/tree/master/bins/elf">Test elves for radare2</a> ; </li><li>  <a href="https://github.com/MaskRay/ElfHacks/">Project ElfHacks on Github</a> - a selection of small elves with different settings; </li><li>  <a href="https://crackmes.one/">Crackme for Unix / Linux</a> - but it is worth considering that there can be tricky samples. </li></ul><br><h1 id="chtenie-poluchenie-informacii">  Reading, receiving information </h1><br><h2 id="tip-fayla-zagolovok-sekcii">  File type, title, sections </h2><br><p>  Depending on the task of interest may be: </p><br><ul><li>  file type (DYN - library, EXEC - executable, RELOC - linkable); </li><li>  target architecture (E_MACHINE - x86_64, x86, ARM, etc.); </li><li>  entry point to the application (Entry Point); </li><li>  section information. </li></ul><br><h3 id="010editor">  010Editor </h3><br><p>  HEX-editor 010Editor provides a template system.  For ELF files, the template is called, oddly enough, <em>ELF.bt</em> and is in the <em>Executable</em> category (menu Templates - Executable). <br>  Of interest may be, for example, the entry point to the executable file (entry point) (recorded in the file header). </p><br><p><img src="https://habrastorage.org/webt/uz/f4/i6/uzf4i6yhfy9epat61pd4uolvegw.png" alt="image"></p><br><h3 id="readelf">  readelf </h3><br><p>  The readelf utility can be considered a de facto standard for obtaining information about the ELF file. </p><br><ul><li>  Read file header: <br><pre><code class="bash hljs">$ readelf -h simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><pre> <code class="markdown hljs">ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1070 Start of program headers: 64 (bytes into file) Start of section headers: 14800 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29</code> </pre> </div></div><br><ul><li>  Read information about segments and sections: <br><pre> <code class="bash hljs">$ readelf -l -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><p>  For readability, the addresses are given in 32-bit format: </p><br><pre> <code class="markdown hljs">Elf file type is DYN (Shared object file) Entry point 0x1070 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x00000040 0x00000040 0x000268 0x000268 R 0x8 INTERP 0x0002a8 0x000002a8 0x000002a8 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x00000000 0x00000000 0x0005f8 0x0005f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x00026d 0x00026d RE 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x0001b8 0x0001b8 R 0x1000 LOAD 0x002de8 0x00003de8 0x00003de8 0x000258 0x000260 RW 0x1000 DYNAMIC 0x002df8 0x00003df8 0x00003df8 0x0001e0 0x0001e0 RW 0x8 NOTE 0x0002c4 0x000002c4 0x000002c4 0x000044 0x000044 R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_EH_</span></span>FRAME 0x002070 0x00002070 0x00002070 0x00003c 0x00003c R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_STACK 0x000000 0x00000000 0x00000000 0x000000 0x000000 RW 0x10 GNU_</span></span>RELRO 0x002de8 0x00003de8 0x00003de8 0x000218 0x000218 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version<span class="hljs-emphasis"><span class="hljs-emphasis">_r .rela.dyn .rela.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_</span></span>frame<span class="hljs-emphasis"><span class="hljs-emphasis">_hdr .eh_</span></span>frame 05 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr 09 10 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got</code> </pre> </div></div><br><ul><li>  Read section information: <br><pre> <code class="bash hljs">$ readelf -S -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><p>  For readability, the addresses are given in 32-bit format: </p><br><pre> <code class="markdown hljs">There are 30 section headers, starting at offset 0x39d0: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000002a8 0002a8 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 000002c4 0002c4 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 000002e4 0002e4 000024 00 A 0 0 4 [ 4] .gnu.hash GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_HASH 00000308 000308 000024 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000330 000330 0000d8 18 A 6 1 8 [ 6] .dynstr STRTAB 00000408 000408 0000a2 00 A 0 0 1 [ 7] .gnu.version VERSYM 000004aa 0004aa 000012 02 A 5 0 2 [ 8] .gnu.version_</span></span>r VERNEED 000004c0 0004c0 000030 00 A 6 1 8 [ 9] .rela.dyn RELA 000004f0 0004f0 0000c0 18 A 5 0 8 [10] .rela.plt RELA 000005b0 0005b0 000048 18 AI 5 23 8 [11] .init PROGBITS 00001000 001000 000017 00 AX 0 0 4 [12] .plt PROGBITS 00001020 001020 000040 10 AX 0 0 16 [13] .plt.got PROGBITS 00001060 001060 000008 08 AX 0 0 8 [14] .text PROGBITS 00001070 001070 0001f2 00 AX 0 0 16 [15] .fini PROGBITS 00001264 001264 000009 00 AX 0 0 4 [16] .rodata PROGBITS 00002000 002000 000070 00 A 0 0 8 [17] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr PROGBITS 00002070 002070 00003c 00 A 0 0 4 [18] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame PROGBITS 000020b0 0020b0 000108 00 A 0 0 8 [19] .init_</span></span>array INIT<span class="hljs-emphasis"><span class="hljs-emphasis">_ARRAY 00003de8 002de8 000008 08 WA 0 0 8 [20] .fini_</span></span>array FINI_ARRAY 00003df0 002df0 000008 08 WA 0 0 8 [21] .dynamic DYNAMIC 00003df8 002df8 0001e0 10 WA 6 0 8 [22] .got PROGBITS 00003fd8 002fd8 000028 08 WA 0 0 8 [23] .got.plt PROGBITS 00004000 003000 000030 08 WA 0 0 8 [24] .data PROGBITS 00004030 003030 000010 00 WA 0 0 8 [25] .bss NOBITS 00004040 003040 000008 00 WA 0 0 1 [26] .comment PROGBITS 00000000 003040 00001c 01 MS 0 0 1 [27] .symtab SYMTAB 00000000 003060 000630 18 28 44 8 [28] .strtab STRTAB 00000000 003690 000232 00 0 0 1 [29] .shstrtab STRTAB 00000000 0038c2 000107 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)</code> </pre> </div></div><br><ul><li>  Read symbol information: <br><pre> <code class="bash hljs">$ readelf -s -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><p>  The output is shortened for readability: </p><br><pre> <code class="markdown hljs">Symbol table '.dynsym' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 NOTYPE WEAK DEFAULT UND <span class="hljs-emphasis"><span class="hljs-emphasis">_ITM_</span></span>deregisterTMCloneTable 2: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_</span></span>2.2.5 (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND <span class="hljs-strong"><span class="hljs-strong">__libc_start_main@GLIBC_2.2.5 (2) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __</span></span>gmon<span class="hljs-emphasis"><span class="hljs-emphasis">_start_</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_ 6: 00000000 0 FUNC GLOBAL DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_isoc99_</span></span>scanf@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.7 (3) 7: 00000000 0 NOTYPE WEAK DEFAULT UND _</span></span>ITM<span class="hljs-emphasis"><span class="hljs-emphasis">_registerTMCloneTable 8: 00000000 0 FUNC WEAK DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_cxa_</span></span>finalize@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) Symbol table '.symtab' contains 66 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 000002a8 0 SECTION LOCAL DEFAULT 1 2: 000002c4 0 SECTION LOCAL DEFAULT 2 3: 000002e4 0 SECTION LOCAL DEFAULT 3 4: 00000308 0 SECTION LOCAL DEFAULT 4 5: 00000330 0 SECTION LOCAL DEFAULT 5 6: 00000408 0 SECTION LOCAL DEFAULT 6 7: 000004aa 0 SECTION LOCAL DEFAULT 7 .... 26: 00000000 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 28: 000010a0 0 FUNC LOCAL DEFAULT 14 deregister_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 29: 000010d0 0 FUNC LOCAL DEFAULT 14 register_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 30: 00001110 0 FUNC LOCAL DEFAULT 14 _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_do_</span></span>global<span class="hljs-emphasis"><span class="hljs-emphasis">_dtors_</span></span>aux 31: 00004040 1 OBJECT LOCAL DEFAULT 25 completed.7389 ....</code> </pre> </div></div><br><p>  The <code>-W</code> option is needed to increase the width of console output (by default, 80 characters). </p><br><h3 id="lief">  LIEF </h3><br><p>  You can read the header and section information using the Python code and the LIEF library (it provides APIs not only for Python): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.elf"</span></span>) header = binary.header print(<span class="hljs-string"><span class="hljs-string">"Entry point: %08x"</span></span> % header.entrypoint) print(<span class="hljs-string"><span class="hljs-string">"Architecture: "</span></span>, header.machine_type) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.sections: print(<span class="hljs-string"><span class="hljs-string">"Section %s - size: %s bytes"</span></span> % (section.name, section.size)</code> </pre> <br><h2 id="informaciya-o-kompilyatore">  Compiler info </h2><br><p>  For information on the compiler and build, see the <code>.comment</code> and <code>.note</code> . </p><br><h3 id="objdump">  objdump </h3><br><pre> <code class="bash hljs">$ objdump -s --section .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><pre> <code class="markdown hljs">simple: file format elf64-x86-64 Contents of section .comment: 0000 4743433a 20284465 6269616e 20382e32 GCC: (Debian 8.2 0010 2e302d39 2920382e 322e3000 .0-9) 8.2.0.</code> </pre> </div></div><br><h3 id="readelf-1">  readelf </h3><br><pre> <code class="bash hljs">$ readelf -p .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><pre> <code class="markdown hljs">String dump of section '.comment': [ 0] GCC: (Debian 8.2.0-9) 8.2.0</code> </pre> </div></div><br><pre> <code class="bash hljs">$ readelf -n simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><pre> <code class="markdown hljs">Displaying notes found at file offset 0x000002c4 with length 0x00000020: Owner Data size Description GNU 0x00000010 NT<span class="hljs-emphasis"><span class="hljs-emphasis">_GNU_</span></span>ABI<span class="hljs-emphasis"><span class="hljs-emphasis">_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found at file offset 0x000002e4 with length 0x00000024: Owner Data size Description GNU 0x00000014 NT_</span></span>GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_BUILD_</span></span>ID (unique build ID bitstring) Build ID: dae0509e4edb79719a65af37962b74e4cf2a8c2e</code> </pre> </div></div><br><h3 id="lief-1">  LIEF </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) comment = binary.get_section(<span class="hljs-string"><span class="hljs-string">".comment"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Comment: "</span></span>, bytes(comment.content))</code> </pre><br><h2 id="ya-vychislyu-tebya-po-rpath">  I will calculate you by ... RPATH </h2><br><p>  Elves can save paths to search for dynamically linked libraries.  In order not to set the <code>LD_LIBRARY_PATH</code> system variable before starting the application, you can simply ‚Äúsew‚Äù this path into the ELF file. </p><br><p>  To do this, use the entry in the <code>.dynamic</code> section with the <code>DT_RPATH</code> or <code>DT_RUNPATH</code> type (see the <a href="https://docs.oracle.com/cd/E26505_01/html/E26506/chapter6-63352.html">Directories</a> section <code>.dynamic</code> <a href="https://docs.oracle.com/cd/E26505_01/html/E26506/chapter6-63352.html">Searched by the Runtime Linker</a> in the documentation). </p><br><p>  <strong>And be careful, young developer, do not ‚Äúsleep‚Äù your project directory!</strong> </p><br><h3 id="kak-poyavlyaetsya-rpath">  How does RPATH appear? </h3><br><p>  The main reason for the appearance of RPATH records in an elf is the <code>-rpath</code> linker option for searching for a dynamic library.  Like that: </p><br><pre> <code class="bash hljs">$ gcc -L./lib -Wall -Wl,-rpath=/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/ -o test_rpath.elf bubble_main.c -lbubble</code> </pre> <br><p>  Such a command will create in the <code>.dynamic</code> section a <code>.dynamic</code> record with the value <code>/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/</code> . </p><br><h3 id="readelf-2">  readelf </h3><br><p>  View elements from the <code>.dynamic</code> section ( <code>.dynamic</code> is one of them) like this: </p><br><pre> <code class="bash hljs">$ readelf -d test_rpath.elf</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Team Result</b> <div class="spoiler_text"><p>  For readability, the result of the command is abbreviated: </p><br><pre> <code class="markdown hljs">Dynamic section at offset 0x2dd8 contains 28 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libbubble.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x11c8 ....</code> </pre> </div></div><br><h3 id="lief-2">  LIEF </h3><br><p>  With the help of the LIEF library, you can also read the RPATH entry in the elf: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS elf = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> elf.has(DYNAMIC_TAGS.RPATH): rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == DYNAMIC_TAGS.RPATH, elf.dynamic_entries)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rpath.paths: print(path) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No RPATH in ELF"</span></span>)</code> </pre> <br><p>  <a href="https://docs.oracle.com/cd/E26505_01/html/E26506/chapter6-42444.html">Read about the .dynamic section</a> </p><br><h2 id="proverka-elfa-na-bezopasnost">  Check Elf for security </h2><br><p>  The security check script <a href="https://www.trapkit.de/tools/checksec.html">checksec.sh</a> from researcher Tobias Klein (author of <a href="https://nostarch.com/bughunter">A Bug Hunter's Diary</a> ) has not been updated since 2011.  This script for ELF files checks for the presence of the options RelRO (Read Only Relocations), NX (Non-Executable Stack), Stack Canaries, PIE (Position Independent Re- ferent Executables) and uses the readelf utility for its work. </p><br><p>  You can make your analog on the Python and LIEF knee (slightly shorter than the progenitor and with the additional check of the <a href="https://habr.com/ru/company/dsec/blog/433108/">separate-code</a> option): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS, SEGMENT_TYPES <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filecheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> binary = lief.parse(filename) <span class="hljs-comment"><span class="hljs-comment"># check RELRO if binary.has(SEGMENT_TYPES.GNU_RELRO): print("+ Full RELRO") if binary.has(DYNAMIC_TAGS.BIND_NOW) else print("~ Partial RELRO") else: print("- No RELRO") # check for stack canary support print("+ Canary found") if binary.has_symbol("__stack_chk_fail") else print("- No canary found") # check for NX support (check X-flag for GNU_STACK-segment) print("+ NX enabled") if binary.has_nx else print("- NX disabled") # check for PIE support print("+ PIE enabled") if binary.is_pie else print("- No PIE") # check for rpath / run path print("+ RPATH") if binary.has(DYNAMIC_TAGS.RPATH) else print("- No RPATH") print("+ RUNPATH")if binary.has(DYNAMIC_TAGS.RUNPATH) else print("- No RUNPATH") # check separate-code option if set(binary.get_section('.text').segments) == set(binary.get_section('.rodata').segments): print("- Not Separated Code Sections") else: print("+ Separated Code Sections") filecheck('test_rpath.elf')</span></span></code> </pre> <br><h2 id="syroy-kod-iz-elfa-binary-from-elf">  "Crude code" from elf (binary from ELF) </h2><br><p>  There are situations when ‚Äúelf clothes‚Äù in the form of an ELF structure are not needed, and only the ‚Äúbare‚Äù executable code of the application is needed. </p><br><h3 id="objcopy">  objcopy </h3><br><p>  Using <em>objcopy is</em> probably familiar to those who write firmware: </p><br><pre> <code class="bash hljs">$ objcopy -O binary -S -g simple.elf simple.bin</code> </pre> <br><ul><li>  <code>-S</code> - to remove character information; </li><li>  <code>-g</code> - to remove debug information. </li></ul><br><h3 id="lief-3">  LIEF </h3><br><p>  No magic  Just take the contents of the loaded sections and blind them binary: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SECTION_FLAGS, SECTION_TYPES binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) end_addr = <span class="hljs-number"><span class="hljs-number">0</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.has(SECTION_FLAGS.ALLOC) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.type != SECTION_TYPES.NOBITS, binary.sections): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; end_addr &lt; section.virtual_address: align_bytes = <span class="hljs-string"><span class="hljs-string">b'\x00'</span></span> * (section.virtual_address - end_addr) data.append(align_bytes) data.append(bytes(section.content)) end_addr = section.virtual_address + section.size <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test.lief.bin'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d_bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: f.write(d_bytes)</code> </pre> <br><h2 id="mangled---demangled-imena-funkciy">  Mangled - demangled function names </h2><br><p>  In ELFs created from C ++ code, the function names are decorated (mangled) to simplify the search for the corresponding class function.  However, reading such names in the analysis is not very convenient. </p><br><p>  <a href="https://github.com/radare/radare2-regressions/blob/master/bins/elf/demangle-test-cpp">Test elf</a> </p><br><h3 id="nm">  nm </h3><br><p>  You can use the <a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm</a> utility from the binutils suite to present names in a readable form: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        $ nm -D demangle-test-cpp ... U _Unwind_Resume U _ZdlPv U _Znwm U _ZSt17__throw_bad_allocv U _ZSt20__throw_length_errorPKc #        $ nm -D --demangle demangle-test-cpp ... U _Unwind_Resume U operator delete(void*) U operator new(unsigned long) U std::__throw_bad_alloc() U std::__throw_length_error(char const*)</span></span></code> </pre> <br><h3 id="lief-4">  LIEF </h3><br><p>  The output of the names of characters in demanganized form using the library LIEF: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"demangle-test-cpp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.symbols: print(symb.name, symb.demangled_name)</code> </pre> <br><h1 id="sborka-zapis-modifikaciya-elfa">  Assembling, recording, modifying an elf </h1><br><h2 id="elf-bez-metainformacii">  Elf without metainformation </h2><br><p>  After the application is debugged and released into the wild world, it makes sense to remove the meta-information: </p><br><ul><li>  debug sections are useless in most cases; </li><li>  names of variables and functions - absolutely do not affect anything for the end user (slightly complicates the reverse); </li><li>  the section table is completely unnecessary for launching an application (its lack will slightly complicate the reverse). </li></ul><br><h2 id="udalenie-simvolnoy-informacii">  Removing character information </h2><br><p>  Symbolic information is the names of objects and functions.  Without it, the reverse of the application is a bit more complicated. </p><br><h3 id="strip">  strip </h3><br><p>  In the simplest case, you can use the <a href="https://www.sourceware.org/binutils/docs/binutils/strip.html">strip</a> utility from the binutils suite.  To delete all symbolic information, just run the command: </p><br><ul><li>  for executable file: <br><pre> <code class="bash hljs">$ strip -s simple</code> </pre> </li><li>  for dynamic library: <br><pre> <code class="bash hljs">$ strip --strip-unneeded libsimple.so</code> </pre> </li></ul><br><h3 id="sstrip">  sstrip </h3><br><p>  To carefully remove character information (including unnecessary zero bytes at the end of the file), you can use the sstrip utility from the <a href="https://github.com/BR903/ELFkickers">ELFkickers suite</a> .  To delete all symbolic information, just run the command: </p><br><pre> <code class="bash hljs">$ sstrip -z simple</code> </pre> <br><h3 id="lief-5">  LIEF </h3><br><p>  Using the LIEF library you can also make a quick strip (the symbol table is deleted - the <code>.symtab</code> section): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.strip() binary.write(<span class="hljs-string"><span class="hljs-string">"simple.stripped"</span></span>)</code> </pre> <br><h2 id="udalenie-tablicy-sekciy">  Deleting a section table </h2><br><p>  As mentioned above, the presence / absence of a partition table does not affect the operation of the application.  But at the same time, without the section table, the reverse of the application becomes a bit more complicated. <br>  Let's use the LIEF library under Python and <a href="https://github.com/lief-project/LIEF/blob/master/examples/python/elf_remove_section_table.py">an example of deleting a partition table</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.header.numberof_sections = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.header.section_header_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"simple.modified"</span></span>)</code> </pre> <br><h2 id="izmenenie-i-udalenie-rpath">  Modifying and deleting RPATH </h2><br><h3 id="chrpath-patchelf">  chrpath, PatchELF </h3><br><p>  To change RPATH under Linux you can use the <em>chrpath</em> utilities (available on most distributions) or <a href="https://nixos.org/patchelf.html">PatchELF</a> . </p><br><ul><li><p>  Change RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -r /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br><p>  or </p><br><pre> <code class="bash hljs">$ patchelf --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-rpath /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br></li><li><p>  Remove RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -d test_rpath.elf</code> </pre> <br><p>  or </p><br><pre> <code class="bash hljs">$ patchelf --shrink-rpath test_rpath.elf</code> </pre> <br></li></ul><br><h3 id="lief-6">  LIEF </h3><br><p>  The LIEF library also allows you to both change and delete the RPATH record. </p><br><ul><li><p>  Change RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == lief.ELF.DYNAMIC_TAGS.RPATH, binary.dynamic_entries)) rpath.paths = [<span class="hljs-string"><span class="hljs-string">"/opt/my-lib/here"</span></span>] binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li><li><p>  Remove RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) binary.remove(lief.ELF.DYNAMIC_TAGS.RPATH) binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li></ul><br><h2 id="obfuskaciya-simvolnoy-informacii">  Obfuscation of character information </h2><br><p>  To complicate the reverse of the application, you can save symbolic information, but confuse the names of the objects.  We use the elf <em>crackme01_32bit</em> from <a href="https://crackmes.one/crackme/5ab77f5e33c5d40ad448c78b">crackme01 by seveb</a> as the test <a href="https://crackmes.one/crackme/5ab77f5e33c5d40ad448c78b">subject</a> . </p><br><p>  A simplified version of an <a href="https://github.com/lief-project/LIEF/blob/master/examples/python/elf_symbol_obfuscation.py">example</a> from the LIEF library might look like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binary.static_symbols): symb.name = <span class="hljs-string"><span class="hljs-string">"zzz_%d"</span></span> % i binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.obfuscated"</span></span>)</code> </pre> <br><p>  As a result, we get: </p><br><pre> <code class="bash hljs">$ readelf -s crackme01_32bit.obfuscated ... Symbol table <span class="hljs-string"><span class="hljs-string">'.symtab'</span></span> contains 78 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND zzz_0 1: 08048154 0 SECTION LOCAL DEFAULT 1 zzz_1 2: 08048168 0 SECTION LOCAL DEFAULT 2 zzz_2 3: 08048188 0 SECTION LOCAL DEFAULT 3 zzz_3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 zzz_4 5: 080481d0 0 SECTION LOCAL DEFAULT 5 zzz_5 6: 080482b0 0 SECTION LOCAL DEFAULT 6 zzz_6 7: 0804835a 0 SECTION LOCAL DEFAULT 7 zzz_7 8: 08048378 0 SECTION LOCAL DEFAULT 8 zzz_8 9: 080483b8 0 SECTION LOCAL DEFAULT 9 zzz_9 10: 080483c8 0 SECTION LOCAL DEFAULT 10 zzz_10 ...</code> </pre> <br><h2 id="podmena-funkciy-cherez-pltgot">  Function substitution via PLT / GOT </h2><br><p>  Also known as <a href="http://phrack.org/issues/56/7.html">ELF PLT INFECTION</a> . </p><br><p>  In order not to copy-paste, just leave links on the topic: </p><br><ul><li>  <a href="https://habr.com/ru/post/106107/">Redirecting Functions in Shared ELF Libraries</a> </li><li>  <a href="https://lief.quarkslab.com/doc/latest/tutorials/05_elf_infect_plt_got.html">Infecting the plt / got with LIEF</a> </li></ul><br><h2 id="izmenit-tochku-vhoda">  Change entry point </h2><br><p>  It can be useful when creating patches, installing hooks and other dynamic instrumentation, or for invoking hidden functions.  We use crackme01_32bit from <a href="https://crackmes.one/crackme/5ab77f5e33c5d40ad448c78b">crackme01 by seveb</a> as a test subject <a href="https://crackmes.one/crackme/5ab77f5e33c5d40ad448c78b">.</a> </p><br><h3 id="radare2">  radare2 </h3><br><p>  radare2 starts in recording mode ( <code>-w</code> option) - the changes will be made to the original file: </p><br><pre> <code class="bash hljs">$ ./crackme01_32bit Please enter the secret number: ^C $ r2 -w -nn crackme01_32bit [0x00000000]&gt; .pf.elf_header.entry=0x0804860D [0x00000000]&gt; q $ ./crackme01_32bit Nope.</code> </pre> <br><h3 id="lief-7">  LIEF </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) header = binary.header header.entrypoint = <span class="hljs-number"><span class="hljs-number">0x0804860D</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.patched"</span></span>)</code> </pre> <br><h2 id="patching-koda">  Code patching </h2><br><p>  <a href="https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3">Let's</a> take <a href="https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3">novn91's crackmepal</a> as a simple test <a href="https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3">subject</a> .  When run without parameters, the program displays: </p><br><pre> <code class="bash hljs">$ ./crackmeMario usage &lt;password&gt;</code> </pre> <br><p>  When starting with the parameter-arbitrary string, it is issued: </p><br><pre> <code class="bash hljs">./crackmeMario qwerty try again pal.</code> </pre> <br><p>  Let's make a patch so that the program displays the message ‚Äúgood job!  now keygen me! ‚Äù </p><br><h3 id="radare2-1">  radare2 </h3><br><p>  radare2 can patch any formats it supports.  At the same time, it is possible to describe patches in text format: </p><br><pre> <code class="plaintext hljs"># Rapatch for https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3 !echo Patching crackme 0x115D : jmp 0x1226</code> </pre> <br><p>  Apply this patch can command: </p><br><pre> <code class="bash hljs">$ r2 -P patch.txt crackmeMario</code> </pre> <br><p>  Read about patching code via radare2: </p><br><ul><li>  <a href="https://rayoflightz.github.io/linux/assembly/2019/03/26/Binary-patching-using-radare2.html">Binary Patching Using Radare2 by wolfshirtz</a> </li><li>  <a href="https://monosource.gitbooks.io/radare2-explorations/content/tut1/tut1_-_simple_patch.html">Radare2 Explorations.</a>  <a href="https://monosource.gitbooks.io/radare2-explorations/content/tut1/tut1_-_simple_patch.html">Tutorial 1 - Simple Patch</a> </li><li>  <a href="https://scriptdotsh.com/index.php/2018/08/13/reverse-engineering-patching-binaries-with-radare2-arm-aarch64/">Ground Zero: Part 3-2 - Reverse Engineering - Patching Binaries with Radare2 - ARM64</a> </li></ul><br><h3 id="lief-8">  LIEF </h3><br><p>  LIEF allows you to patch an elf (rewrite bytes) to the specified virtual address.  A patch can be in the form of an array of bytes or in the form of an integer value: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackmeMario"</span></span>) binary.patch_address(<span class="hljs-number"><span class="hljs-number">0x115D</span></span>, bytearray(<span class="hljs-string"><span class="hljs-string">b"\xe9\xc4\x00\x00\x00"</span></span>)) binary.write(<span class="hljs-string"><span class="hljs-string">"crackmeMario.patched"</span></span>)</code> </pre> <br><p>  After applying the patch, the program will display: </p><br><pre> <code class="bash hljs">$ ./crackmeMario.patched good job! now keygen me!</code> </pre> <br><h2 id="dobavit-sekciyu-v-elf">  Add section to ELF </h2><br><h3 id="objcopy-1">  objcopy </h3><br><p>  <em>objcopy</em> allows you to add a section, but this section will not belong to any segment and will not load into RAM when the application starts: </p><br><pre> <code class="bash hljs">$ objcopy --add-section .testme=data.zip \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-section-flags .testme=alloc,contents,load,<span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> \ --change-section-address .testme=0x08777777 \ simple simple.patched.elf</code> </pre> <br><h3 id="lief-9">  LIEF </h3><br><p>  The LIEF library allows you to add a new section and its corresponding segment ( <strong><code>loaded=True</code></strong> flag) to the existing ELF: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) section = lief.ELF.Section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>, lief.ELF.SECTION_TYPES.PROGBITS) section += lief.ELF.SECTION_FLAGS.EXECINSTR section += lief.ELF.SECTION_FLAGS.ALLOC section.content = data binary.add(section, loaded=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.testme.lief"</span></span>)</code> </pre> <br><h2 id="izmenit-sekciyu">  Edit section </h2><br><h3 id="objcopy-2">  objcopy </h3><br><p>  <em>objcopy</em> allows <em>you</em> to replace the contents of the section with data from a file, as well as change the virtual address of the section and flags: </p><br><pre> <code class="bash hljs">$ objcopy --update-section .testme=patch.bin \ --change-section-address .testme=0x08999999 simple simple.testme.elf</code> </pre> <br><h3 id="lief-10">  LIEF </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">17</span></span>) section = binary.get_section(<span class="hljs-string"><span class="hljs-string">".text"</span></span>) section.content = data binary.write(<span class="hljs-string"><span class="hljs-string">"simple.patched"</span></span>)</code> </pre> <br><h2 id="udalit-sekciyu">  Delete section </h2><br><h3 id="objcopy-3">  objcopy </h3><br><p>  <em>objcopy</em> allows <em>you</em> to delete a specific section by name: </p><br><pre> <code class="bash hljs">$ objcopy --remove-section .testme simple.testme.elf simple.no_testme.elf</code> </pre> <br><h3 id="lief-11">  LIEF </h3><br><p>  Deleting a partition using the LIEF library looks like this: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.testme.elf"</span></span>) binary.remove_section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.no_testme"</span></span>)</code> </pre> <br><h2 id="elf-konteyner">  Elf container </h2><br><p>  The recipe is inspired by the <a href="https://habr.com/ru/company/neobit/blog/332918/">Gremlins</a> article <a href="https://habr.com/ru/company/neobit/blog/332918/">and ELF magic: what if the ELF file is a container?</a>  .  There are also man's about the elfwrap utility from Solaris, which allows you to create an ELF file from arbitrary data, and the ELF format is used simply as a container. </p><br><p>  Let's try to do the same in Python and LIEF. <br>  Unfortunately, at the moment the LIEF library does not know how to create an elf file from scratch, so you need to help her ‚Äî create an empty ELF template: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> | gcc -m32 -fpic -o empty.o -c -xc - $ gcc -m32 -shared -o libempty.so empty.o</code> </pre> <br><p>  Now you can use this template for filling data: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"libempty.so"</span></span>) filename = <span class="hljs-string"><span class="hljs-string">"crackme.zip"</span></span> data = open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() <span class="hljs-comment"><span class="hljs-comment"># Add section with zip-archive as content section = lief.ELF.Section() section.content = data section.name = ".%s"%filename binary.add(section, loaded=True) # Add symbol as a reference to zip-archive symb = lief.ELF.Symbol() symb.type = lief.ELF.SYMBOL_TYPES.OBJECT symb.binding = lief.ELF.SYMBOL_BINDINGS.GLOBAL symb.size = len(data) symb.name = filename symb.value = section.virtual_address binary.add_static_symbol(symb) binary.write("libdata.crackme.container")</span></span></code> </pre> <br><h2 id="elf-s-pricepom">  Elf "with a trailer" </h2><br><p>  ELF-format does not impose restrictions on data that is in the file, but does not belong to any segment.  Thus, you can create an executable file that will <em>have something</em> stored after the ELF structure.  This <em>something</em> will not be loaded into RAM during execution, but it will be written to disk, and at any moment it can be read from the disk. </p><br><ul><li>  <em>IDA Pro will not take this data into account when analyzing</em> </li></ul><br><p>  <em>An example of the structure of the file "with a trailer"</em> <br><img src="https://habrastorage.org/webt/rr/br/sk/rrbrsktjs_p8l7fmdfq7t4mejns.jpeg" alt="image"></p><br><h3 id="radare2-2">  radare2 </h3><br><p>  The presence of a "trailer" can be established by comparing the actual and calculated file size: </p><br><pre> <code class="bash hljs">$ radare2 test.elf [0x00001040]&gt; ?v <span class="hljs-variable"><span class="hljs-variable">$s</span></span> 0x40c1 [0x00001040]&gt; iZ 14699</code> </pre> <br><h3 id="readelf-3">  readelf </h3><br><p>  <em>readelf</em> does not show information about the presence of a "trailer", but can be calculated manually: </p><br><pre> <code class="bash hljs">$ ls -l test.elf <span class="hljs-comment"><span class="hljs-comment">#   16577  $ readelf -h test.elf Start of section headers e_shoff 14704 Size of section headers e_shentsize 64 Number of section headers e_shnum 29 #  ELF-: e_shoff + ( e_shentsize * e_shnum ) = 16560</span></span></code> </pre> <br><h3 id="lief-12">  LIEF </h3><br><p>  The LIEF library allows you to both check for the presence of a ‚Äútrailer‚Äù and add it.  With LIEF, everything looks quite concise: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># check if overlay exists print('ELF has overlay data') if binary.has_overlay else print("No overlay data") # add overlay data to ELF data = bytearray(b'\xFF'*17) binary.overlay = data binary.write('test.overlay')</span></span></code> </pre> <br><h2 id="elf-iz-pustoty-elf-from-scratch">  ELF from scratch </h2><br><p>  On the Internet, you can find projects to create an ELF file "manually" - without using a compiler and linker under the general title "ELF from scratch": </p><br><ul><li>  <a href="https://github.com/statusfailed/elf-from-scratch">Project on Github</a> </li><li>  Article <a href="https://www.conradk.com/codebase/2017/05/28/elf-from-scratch/">Elf from scratch</a> </li><li>  The <a href="https://github.com/lief-project/LIEF/tree/elf_from_scratch">elf_from_scratch</a> branch in the LIEF library repository </li></ul><br><p>  Familiarity with these projects has a beneficial effect on the absorption of the ELF format. </p><br><h2 id="samyy-malenkiy-elf">  Smallest elf </h2><br><p>  Interesting experiments with minimizing the size of an elf are described in the articles: </p><br><ul><li>  <a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">A Whirlwind Tutorial on Teensy ELF Executables for Linux</a> </li><li>  <a href="http://www.muppetlabs.com/~breadbox/software/tiny/somewhat.html">A Whirlwind Tutorial on Creating Something Teensy ELF Executables for Linux</a> </li><li>  <a href="https://habr.com/ru/post/137706/">Minimal program in ELF format</a> </li></ul><br><p>  In short, the OS loader elf uses far from all the header fields and tables of segments, with some minimal executable code can be placed directly into the ELF header structure (the code is taken from the first article): </p><br><pre> <code class="plaintext hljs">; tiny.asm BITS 32 org 0x00010000 db 0x7F, "ELF" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _start: mov bl, 42 ; e_shoff ; p_align xor eax, eax inc eax ; e_flags int 0x80 db 0 dw 0x34 ; e_ehsize dw 0x20 ; e_phentsize db 1 ; e_phnum ; e_shentsize ; e_shnum ; e_shstrndx filesize equ $ - $$</code> </pre> <br><p>  Assemble and get ELF size ... <strong>45 bytes</strong> : </p><br><pre> <code class="bash hljs"> $ nasm -f bin -o a.out tiny.asm $ chmod +x a.out $ ./a.out ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 42 $ wc -c a.out 45 a.out</code> </pre> <br><h2 id="elf-po-shablonu">  Elf by pattern </h2><br><p>  To create an elf using the LIEF library, you can take the following steps (see the recipe "Elf container"): </p><br><ul><li>  take a simple ELF file as a template; </li><li>  replace the contents of sections, add new sections; </li><li>  configure the necessary parameters (entry point, flags). </li></ul><br><h1 id="vmesto-zaklyucheniya">  Instead of conclusion </h1><br><p>  While writing the article, we found out that something like Ode to the LIEF library turned out.  But it was not so planned - I wanted to show ways to work with ELF files using different tools. </p><br><p>  Surely there are or need scripts that were not mentioned here - write about it in the comments. </p><br><h1 id="ssylki-i-literatura">  References and literature </h1><br><ul><li>  <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">ELF format specification</a> </li><li>  <a href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-46512.html">More format specification in Oracle library</a> </li><li>  <a href="https://www.radare.org/doc/elf-tutorial">Working with ELFs using radare2</a> </li><li>  <a href="https://lief.quarkslab.com/doc/latest/index.html">LIEF Library Documentation</a> </li><li>  <a href="https://github.com/lief-project/LIEF/tree/master/examples">LIEF Library Examples</a> </li><li>  The book "PRACTICAL BINARY ANALYSIS", Dennis Andriesse </li><li>  Learning Linux Binary Analysis, Ryan "elfmaster" O'Neill </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460247/">https://habr.com/ru/post/460247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460231/index.html">OpenGear - reducing business downtime using console server with Out-of-Band control</a></li>
<li><a href="../460233/index.html">Game Cities: Skylines was Turing-complete: create a 4-bit adder</a></li>
<li><a href="../460237/index.html">Scammers on eBay (the story of one deception)</a></li>
<li><a href="../460239/index.html">How to get NextGen Firewall to your home absolutely free</a></li>
<li><a href="../46024/index.html">Firefox Addon: Google Reader-style page navigation for any site.</a></li>
<li><a href="../460249/index.html">The solution to the task with pwnable.kr 07 - input. Understanding pwntools</a></li>
<li><a href="../46025/index.html">Revival of the legend: we put the OS on Libretto 50 CT</a></li>
<li><a href="../460251/index.html">Artificial Stupidity: the bot that did not help me</a></li>
<li><a href="../460253/index.html">10 reasons to make your skill for voice assistant</a></li>
<li><a href="../460255/index.html">Backdoor on Node.js: why, why, and how it works</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>