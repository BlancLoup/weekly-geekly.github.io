<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hypermedia - without which your API is not quite REST</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Dmitry Pavlov, at Align Technology, my colleagues and I are developing a Web API for interfacing internal systems and integrating ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hypermedia - without which your API is not quite REST</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello!  My name is Dmitry Pavlov, at Align Technology, my colleagues and I are developing a Web API for interfacing internal systems and integrating our company with third-party vendors.  I would like to tell you about the ideas of creating an API for the web, or rather the RESTful API, in this article. </p><br><p>  In recent years, the topic of Web API has become very popular, many companies are engaged in the creation of similar interfaces, both open and for internal use.  In the description of the Web API, one can almost always come across the acronym REST, but what does this term mean and is it used correctly? </p><a name="habracut"></a><br><h1>  REST or not REST? </h1><br><p>  Most developers, especially in Russia, understand REST as a program interface that works using the HTTP [S] protocol, subject to the following properties: </p><br><ul><li><p>  The server does not store the state of the client: no sessions, all that is required to fulfill the request, the client sends with the request itself. </p><br></li><li><p> Human readable URLs in which resources are identified separately.  No more <code>/index.php?productId=1</code> , instead use <code>/products/1</code> </p><br></li><li><p>  More extensive use of HTTP methods: not limited to GET and POST, add PUT and DELETE.  In some APIs, PATCH can also be found. </p><br></li><li>  JSON is used as the data transfer format. </li></ul><br><p>  The algorithm by which this API is used is usually standard.  First you need to go to the site with the documentation, find a page with a list of URL-templates for access to resources.  Usually it looks like this: </p><br><pre> <code class="hljs javascript">   API <span class="hljs-string"><span class="hljs-string">" "</span></span> --- <span class="hljs-regexp"><span class="hljs-regexp">/recipes/</span></span>cookies -   , GET   URL     [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"   "</span></span>, <span class="hljs-string"><span class="hljs-string">"rating"</span></span> : <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"shortDescription"</span></span> : <span class="hljs-string"><span class="hljs-string">"...."</span></span> } ] POST   URL     .      json   { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"shortDescription"</span></span> : <span class="hljs-string"><span class="hljs-string">"...."</span></span> ...... } --- <span class="hljs-regexp"><span class="hljs-regexp">/recipes/</span></span>cookies/:name -     ${name} { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"   "</span></span>, <span class="hljs-string"><span class="hljs-string">"rating"</span></span> : <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"shortDescription"</span></span> : <span class="hljs-string"><span class="hljs-string">"...."</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span> : <span class="hljs-string"><span class="hljs-string">"...."</span></span> <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, ..... }, { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, ..... }, { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, ..... } ], <span class="hljs-string"><span class="hljs-string">"cookingSteps"</span></span> : [ .... ] } <span class="hljs-comment"><span class="hljs-comment">//    API   HTTP   URL </span></span></code> </pre><br><p>  and having studied it to fulfill requests to resources (which is usually expressed in writing a client, which, according to specified URL formats, substitutes the parameters and processes the answers). </p><br><p>  There are plenty of examples of such APIs on the network, until recently, Yandex has many APIs ( <a href="https://tech.yandex.ru/pdd/doc/about-docpage/">one</a> , <a href="https://tech.yandex.ru/rasp/doc/concepts/about-docpage/">two</a> ) declared as REST worked according to this scheme. </p><br><p>  If we turn to primary sources, i.e.  to Roy Fielding‚Äôs thesis (which is often referred to, but read less often), we‚Äôll see that APIs created in this way cannot be called REST, because they violate some of the principles described in the thesis, the most important of which is the use of hypermedia as state control tools (Hypermedia As The Engine Of Application State, HATEOAS), indirectly affecting the issues of self-descriptive messages. </p><br><h1>  Hypermedia in messages </h1><br><p>  The essence of HATEOAS is the approach to describing the resources of our API.  Instead of simply listing a set of resources, with a list of all possible operations that a client can invoke, guided by some internal logic, we perform an inversion of control - now the server is responsible for the state of the resource and it dictates to the client what operations can be performed on the resource at the moment.  This information must be present in the actual representation of the resource that the client receives.  Thus, the representation of a resource describes itself sufficiently so that the client understands what can be done with it. </p><br><p>  Applying this approach usually means that the client knows a certain final set of "entry points" (you can think of them as analogous to the start pages on websites), from which he begins his interaction with the API using the information provided in the resource view to navigate to other resources and perform actions . </p><br><p>  Hyperlinks are used to achieve this task: </p><br><ul><li>  All resources are addressable by reference, with links to other resources present within the messages themselves for their communication with each other.  The client, instead of targeting the URI format, is guided by identifiers by which it selects links that are located directly in the resource view.  If earlier we indicated in the documentation that we need to take some ID and, on its basis, build a special URL, thereby making URL sets a part of our API, then now the details of URL formation are just the implementation features of the server and the client do not care.  After all, it is important for the client to access the resource, and not to generate URLs from templates from the documentation. </li><li>  Available operations on a resource are also representable as links. </li></ul><br><p>  The absence of a link to both related resources and available actions means that this operation is not available in the current state of the resource. </p><br><h2>  An example of the processing of the Cookie Recipes API in Hypermedia View </h2><br><p>  Returning to the example of our API about the catalog of recipes for cookies, we transform it into a Hypermedia-view. </p><br><p>  As you remember, we had a list of recipes and a resource detailing a specific recipe with a list of ingredients and cooking steps.  Here is what they will look like using the hypermedia approach: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  { "links": { "self" "/recipes/cookies" } "items": [ { "name": "   ", "rating": 5, "shortDescription": "...." "links": { "self": "/recipes/cookies/   " } } ] } //  { "links": { "self": "/recipes/cookies/   " } "name": "   ", "rating": 5, "shortDescription": "....", "description": "...." "ingredients": [ { "name": "", ..... }, { "name": "", ..... }, { "name": "", ..... } ], "cookingSteps": [ .... ] }</span></span></code> </pre> <br><p>  A significant difference from the original version is the appearance of the <code>links</code> object inside each resource.  The keys of this object are relations (they are identifiers), and the values ‚Äã‚Äãare references.  As a result, our resources do not require additional information (outside the resource itself) about how to go from the recipe catalog to a detailed description, the link is embedded in the resource representation. </p><br><p>  This approach allows you to easily extend the functionality of our API.  Suppose that for each recipe we want to provide the client with a set of recommendations that can be represented as a list of recipes.  This is very easy to do, just add a new key to our links object: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"links"</span></span> : { <span class="hljs-string"><span class="hljs-string">"self"</span></span> : <span class="hljs-string"><span class="hljs-string">"/recipes/cookies/   "</span></span>, <span class="hljs-string"><span class="hljs-string">"http://acme.com/recipes/rels/you-can-also-like"</span></span> : <span class="hljs-string"><span class="hljs-string">"/recipes/cookies?related_to=+++"</span></span> }</code> </pre> <br><p>  Likewise, it‚Äôs not at all difficult to add the identification of ingredients as separate resources if the need arises. </p><br><p>  The content of the URI does not matter, because now the element of the API is a relation, and we can change the link to <code>/recipes/related-to/   </code> or <code>/recipes/234892skfj45sdlkfjdsa12</code> without any changes on the client </p><br><h2>  Hypermedia in the service of change </h2><br><p>  Hypermedia is used not only to navigate, but also to perform actions, it is enough only to determine that some relation are responsible for performing certain operations on resources, and also to identify the semantics and details of these operations. </p><br><p>  For clarity, consider an example with our API, adding hypermedia controls to create a new recipe. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  { "links" : { "self" : "/recipes/cookies", "http://acme.com/recipes/rels/add-recipe" : "/recipes/cookies" } "items" : [ ..... ] }</span></span></code> </pre> <br><p>  We just added a link with a special relation.  The basic rule is that the client ignores unknown relationships: the "old" customers who do not know how to add a new recipe will work as before, and for those who support the creation, this will be a signal that it is possible to add a new recipe by sending a request on the URI that is specified in <code>http://acme.com/recipes/rels/add-recipe</code> . </p><br><p>  This approach allows us not to describe a static set of operations and conditions for their execution in the documentation, but directly to the server to control which operations a client can perform on a resource at a given time, and which cannot.  Adding new actions is also not difficult: we simply declare a new relation, and begin to include it in the resource representation that the server forms. </p><br><p>  Of course, providing links does not remove responsibility from the server for correctly handling HTTP methods and observing their semantics :). </p><br><h2>  What about relation? </h2><br><p>  At this moment, you probably have a question: what is the point of plotting all this, if the client still needs to understand the meaning of relationals for effective work?  For him, the documentation should be available. </p><br><p>  In fact, to work effectively, the client really needs to understand what each relationship means.  The main idea behind the replacement of the interpretation of URIs for working with relationes is the greater durability of the latter.  The URI is an implementation detail and can change over time or from server to server.  Relation is a semantic description of the connection and is not tied to the details of storage. </p><br><p>  Suppose I want to make a compatible API for storing recipes, but because of the storage characteristics I want to identify each recipe by its UUID, and not by its name.  In the case of the original API, this is not possible, and for the hypermedia API it is completely transparent to the client. </p><br><p>  As a result, it becomes possible to create more universal clients that are less susceptible to changes in the event of modifications on the server. </p><br><h2>  Hypermedia types or why application / json does not suit us </h2><br><p>  Deciding to take advantage of the Hypermedia approach, we modified our API in the manner indicated above, and now we have resources linked to each other by reference.  At first glance, it may seem that our API is fine, but before declaring that we have the Hypermedia API, we will look at the Content-Type header that we return in the responses.  If there is <code>application/json</code> or even <code>text/plain</code> , then we still have to work hard. </p><br><h3>  Resources through the eyes of the machine </h3><br><p>  Looking at the resources we got, a person immediately allocates links, which creates the impression of the correct format of our message.  We conclude this by analyzing the content of the message, then the standard prescribes to look at the Content-Type response header. </p><br><p>  Consider the following server response: </p><br><pre> <code class="xml hljs">200 OK Content-Type: text/plain <span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hello</span></span></span><span class="hljs-tag">&gt;</span></span>world<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hello</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  It is obvious to us that the answer contains an xml-document, but the Content-Type prescribes to perceive the content as plain text, so that it looks like an xml-document can be just a coincidence or a special case.  That is why the true Content-Type is so important. </p><br><p>  Let's figure out what the <code>application/json</code> n't right for our task?  The fact is that the standard describing this type does not provide any place or mechanism for defining the links in it.  And even if the message generated by us contains links, the machine cannot distinguish them from the line containing the text in the format resembling a link.  We need to unambiguously determine where the link is in the message, and where not, so we need a different type. </p><br><h3>  Vendor specific types </h3><br><p>  One way to solve the Content-Type correctness problem is to use your own.  In the documentation we will clearly indicate where we have links in the message.  If the client received a response from the server with our personal Content-Type, he will not need to dynamically guess what the link is and what not, unless of course he understands our Content-Type.  It is worth noting that often the documentation describing the type contains not only the details of the format itself (that is, where the links are located and where the properties are located), but also other information: </p><br><ul><li>  semantic description of properties, i.e.  what they mean in terms of business logic; </li><li>  details of the client's interaction with the server, such as the HTTP methods required to send the request. </li></ul><br><p>  These types are called vendor specific, as they are often created for a specific task and specific organization.  They do not need to be registered with IANA.  It is recommended to give them the name of the type <code>application/vnd.${vendor}+${base_format}</code> , where <code>${vendor}</code> is the company's inverted domain, <code>${base_format}</code> is the type we took as the basis.  If the company has an acme.com domain and we use json to represent our resources, then for our recipe API the type name will look like <code>application/vnd.com.acme.recipes+json</code> . </p><br><h3>  Hypermedia general purpose types </h3><br><p>  At first glance, vendor specific types solve the problem with links, but they have their own problems: </p><br><ul><li>  types are not compatible with each other, so customers have to support many different implementations, if they interact with more than one API, i.e.  support of a separate library is required to parse the format of each type, select properties, references and other things in it; </li><li>  Creating a vendor specific type for each task leads to a very noticeable increase in their total number. </li></ul><br><p>  Alternatively, I did not keep myself waiting for the new approach, which brought the types of general purpose.  If you think about it, all we need from the message format is a specification that answers the questions: </p><br><ul><li>  how to find the properties of our resources, </li><li>  how to find hypermedia controls inside the resource. </li></ul><br><p>  It is this problem that is being solved: the general-purpose type does not try to adapt to a specific domain domain, they can describe most of the resources we are dealing with. </p><br><p>  An important feature of all types of general purpose is that they do not set the task of a semantic description of a document, i.e.  they do not say what kind of resource this is - a description of the recipe or a blog comment is not their task.  They are responsible more for the details of the format, leaving the semantic specification beyond the scope.  It is assumed that the semantics will be contained in the so-called profile - a separate document describing the semantics of properties and relations (relations). </p><br><p>  At the moment there are already quite a large number of such formats, so we list only some of them: </p><br><ul><li>  <code>application/hal+json</code> - one of the first to emerge and the most popular format in our days; </li><li>  <code>application/vnd.siren+json</code> ; </li><li>  <code>application/mason+json</code> . </li></ul><br><p>  In the description of all such formats you will find how and where to place the properties of the resource, in what form to make links to other resources. </p><br><p>  They differ in format and capabilities that are contained in the type itself. </p><br><h4>  The difference in formats or principled creators </h4><br><p>  Most general purpose types are distinguished by minor details, such as how to format links.  So, in the HAL, the links look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"_links"</span></span> : { <span class="hljs-string"><span class="hljs-string">"self"</span></span> : .... <span class="hljs-string"><span class="hljs-string">"relToResource"</span></span>: ..... }</code> </pre> <br><p>  Whereas Siren presents them like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"links"</span></span> : [ {<span class="hljs-string"><span class="hljs-string">"rel"</span></span> : [<span class="hljs-string"><span class="hljs-string">"self"</span></span>], <span class="hljs-string"><span class="hljs-string">"href"</span></span> : <span class="hljs-string"><span class="hljs-string">"...."</span></span>}, {<span class="hljs-string"><span class="hljs-string">"rel"</span></span> : [<span class="hljs-string"><span class="hljs-string">"relToResource"</span></span>], <span class="hljs-string"><span class="hljs-string">"href"</span></span> : <span class="hljs-string"><span class="hljs-string">"...."</span></span>} ]</code> </pre> <br><p>  The main difference here is in the representation of relation values.  The creator of HAL wanted to make the format more concise, while the creator of Siren did it more completely: the relation at the link can be really complicated (therefore, in Siren it is an array of values), but this is not always used (therefore, in HAL it is a scalar and also the key in the object). </p><br><p>  Such different views led to the creation of different formats, but could not agree on one format. </p><br><h4>  Difference in possibilities </h4><br><p>  We will not list here all the differences in the formats, we denote only the main ones, by the example of the types already mentioned: </p><br><ul><li>  In HAL, there is no concept of actions as a separate entity, only the links and the method that should be used to send a request is also not included in the message.  In Siren and Mason, there are tools for describing forms: the message contains the parameters that are required for input by the client, the method to which all this needs to be sent and the Content-Type. </li><li>  HAL has a separate concept of a search form - a safe, idempotent action for obtaining information from the server.  Siren and Mason, as mentioned above, has the ability to describe any action. </li><li>  HAL and Siren do not contain details on the error description in the specification, it remains at the discretion of the user of the format ( <code>application/vnd.error+json</code> can be used), whereas in Mason this aspect is included in the format. </li></ul><br><h3>  Generic vs vendor specific </h3><br><p>  What option is preferable: a specially created type or one of the existing options?  As is usually the case with such questions, there is no definite answer to it, it all depends on the circumstances of use, so we will try to highlight the advantages and disadvantages of each of them. </p><br><p>  One of the main advantages of a general purpose hypermedia-type is the time savings for you and your API customers.  That is why it is achieved: </p><br><ul><li>  The message format is already invented for you.  You can focus on solving your problem by creating an API in the already established restrictions of the chosen format. </li><li>  To create and parse messages, libraries have already been written for different programming languages.  Agree, it is convenient to connect a ready-made library and work with high-level concepts like link, action, object properties, and not with details of the paths in JSON. </li><li>  For many generic types, there are so-called browsers.  These are simple clients who understand elements of a certain type and dynamically form a web interface, allowing you to immediately demonstrate the created API without spending a minute to create a client. </li><li>  Your clients will only need to study the documentation for your API, i.e.  they can only focus on the business sense, without wasting time reading the details of the format. </li></ul><br><p>  At the same time, some of the advantages of this approach may look like disadvantages for someone.  Due to the fact that the type is not tied up under any domain area and task, the representation of resources is more ‚Äúbloated‚Äù compared to the special type that we could create. </p><br><p>  As a result, for most tasks, we can recommend to use one of the existing general-purpose Hypermedia-formats and choose vendor-formats in complex or specific cases (unless of course you aim at vendor lock-in). </p><br><h1>  How much do I need all this? </h1><br><p>  The described approach is not another silver bullet, designed to solve all the problems in the development of the API. </p><br><p>  It can be noted that the concept of entry points can lead to an increase in the number of requests to ‚Äúget‚Äù to the desired resource and that, including links, we make the message more voluminous compared to bare data. </p><br><p>  These shortcomings can be objected that these problems are solved by a well-thought-out resource structure (who prevents to perform resource search operations at the entry point for fast navigation?), Caching, which Fielding also noted as an important component of this architectural approach, and the banal compression on web servers. </p><br><p>  The main advantage of the REST approach (here I mean the full REST) ‚Äã‚Äãis in the flexibility and extensibility that it provides, allowing us to add new features or simply change the organization of resources on our server without disrupting existing clients. </p><br><p>  Even if you decide not to use hypermedia in your API, now you know that without it, REST is not REST, but just a Web API.  This does not make the API bad or good, I just state a fact.   ,  API      API,    ,    :). </p><br><h2>     </h2><br><ul><li> <a href="https://tech.yandex.ru/disk/">API  </a> ‚Äî  hypermedia API,  HAL. </li><li> <a href="https://developer.github.com/v3/">Github</a> ‚Äî    (  JSON),      hypermedia. </li><li> <a href="https://developer.paypal.com/docs/api/">Paypal</a>     . </li><li> <a href="http://api.foxycart.com/docs">Foxycart</a> ‚Äî  API      ‚Äî HAL  Siren.    <br> <a href="https://api.foxycart.com/hal-browser/index.html"> </a> ( ,      opensource) </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/281206/">https://habr.com/ru/post/281206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281194/index.html">A variety of versions of Microsoft SQL Server and which one is the latest?</a></li>
<li><a href="../281196/index.html">Data Lake - from theory to practice. Hadoop and Enterprise DWH data integration methods</a></li>
<li><a href="../281198/index.html">Oracle Database 12c Cloud World</a></li>
<li><a href="../281200/index.html">Simultaneous analysis of power consumption / performance of Android devices using Intel VTune Amplifier and SoC Watch</a></li>
<li><a href="../281202/index.html">The essence and advantages of software-defined storage systems</a></li>
<li><a href="../281212/index.html">Updates in the web client and ViaLatM service applications</a></li>
<li><a href="../281216/index.html">Lambdify - a new look at working with AWS Lambda</a></li>
<li><a href="../281218/index.html">To solder or not to solder? Internet of things for beginners</a></li>
<li><a href="../281220/index.html">Microsoft is going to get rid of Flash Player in the Edge web browser</a></li>
<li><a href="../281222/index.html">Overload standard DataAnnotation attributes for use with custom resource provider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>