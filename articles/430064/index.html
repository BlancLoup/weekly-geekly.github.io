<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++: a session of spontaneous archeology and why you should not use variable functions in the style of C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all began, as usual, with an error. The first time I worked with the Java Native Interface and in C ++ parts I wrapped a function that created a Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++: a session of spontaneous archeology and why you should not use variable functions in the style of C</h1><div class="post__text post__text-html js-mediator-article"> It all began, as usual, with an error.  The first time I worked with the <a href="https://ru.wikipedia.org/wiki/Java_Native_Interface">Java Native Interface</a> and in C ++ parts I wrapped a function that created a Java object.  This function - <code>CallVoidMethod</code> - is variable, i.e.  in addition to the pointer to the <abbr title="Java Native Interface">JNI</abbr> environment, the pointer to the type of the object being created, and the identifier of the method being called (in this case, the constructor), it takes an arbitrary number of other arguments.  Which is logical, because  these other arguments are passed to the called method on the Java side, and the methods may be different, with different numbers of arguments of any type. <br><br>  Accordingly, I also made my wrapper variable.  To pass an arbitrary number of arguments to <code>CallVoidMethod</code> used <code>va_list</code> , because there is no other way.  Yes, and sent <code>va_list</code> to <code>CallVoidMethod</code> .  And dropped the JVM with the commonplace segmentation fault. <br><br>  In 2 hours I managed to try several versions of the JVM, from the 8th to the 11th, because: firstly, this is my first experience with the <a href="https://ru.wikipedia.org/wiki/Java_Virtual_Machine" title="Java Virtual Machine">JVM</a> , and in this matter I trusted StackOverflow more than myself, and secondly, someone then on StackOverflow I advised in this case not to use OpenJDK, but OracleJDK, and not 8, but 10. And only then I finally noticed that besides the variable <code>CallVoidMethod</code> there is <code>CallVoidMethodV</code> , which takes an arbitrary number of arguments via <code>va_list</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What I didn‚Äôt like most about this story is that I didn‚Äôt immediately notice the difference between the ellipsis (ellipsis) and <code>va_list</code> .  But noticing, I could not explain to myself what the fundamental difference is.  This means that it is necessary to deal with both ellipse, and <code>va_list</code> , and (since it‚Äôs still C ++) with variable patterns. <br><a name="habracut"></a><br><h3>  What about ellipse and va_list is stated in the Standard </h3><br>  The C ++ standard describes only the differences between its requirements and those of the Standard C. About the differences themselves later, but for now I will briefly retell what Standard C says (starting with C89). <br><br><ul><li>  You can declare a function that takes an arbitrary number of arguments.  Those.  function arguments can have more than parameters.  For this, the list of its parameters must end with an ellipsis, but at least one fixed parameter must also be present <i>[C11 6.9.1 / 8]</i> : <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  Information on the number and types of arguments corresponding to the ellipsis is not transferred to the function itself.  Those.  after the last named parameter ( <code>parm2</code> in the example above) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  To access these arguments, use the <code>va_list</code> type and 4 (3 to C11 standard) macros in the <code>&lt;stdarg.h&gt;</code> header: <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> and <code>va_copy</code> (starting with C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">for example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  Yes, the function does not know how many arguments it has.  She needs to somehow pass this number.  In this case, through a single named argument (another common option is to pass <code>NULL</code> as the last argument, as in <code>execl</code> , or 0). </div></div></li><li>  The last named argument cannot have a <code>register</code> storage class, cannot be a function or an array.  Otherwise, the behavior is undefined <i>[C11 7.16.1.4/4]</i> . </li><li>  Moreover, the last named argument and all the nameless ones are given a ‚Äú <i>default argument</i> type increase‚Äù ( <i>default argument promotion</i> ; if there is a good translation of this concept into Russian, I will gladly use it).  This means that if an argument has the type <code>char</code> , <code>short</code> (with or without a sign) or <code>float</code> , then the corresponding parameters should be treated as <code>int</code> , <code>int</code> (with or without a sign) or <code>double</code> .  Otherwise, the behavior is undefined <i>[C11 7.16.1.1/2]</i> . </li><li>  The type <code>va_list</code> says only that it is declared in <code>&lt;stdarg.h&gt;</code> and is complete (that is, the size of an object of this type is known) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Why?  But because! </h3><br>  There are not many types in C.  Why is <code>va_list</code> declared in the Standard, but nothing is said about its internal structure? <br><br>  Why do we need an ellipsis, if an arbitrary number of arguments to the function can be passed via <code>va_list</code> ?  It could be said now: ‚Äúas syntactic sugar,‚Äù but 40 years ago, I am sure, it was not up to sugar. <br><br>  Philip James Plauger ( <i>Phillip James Plauger</i> ) in his book <i>The Standard C library</i> - The Year 1992 - says that C was originally created exclusively for PDP-11 computers.  And there it was possible to go through all the function arguments using simple pointer arithmetic.  The problem appeared with the growing popularity of C and moving the compiler to other architectures.  The first edition of <i>C Programming Language</i> ( <i>The C Programming Language</i> ) by Brian Kernighan and Dennis Ritchie (1978) - explicitly states: <blockquote>  By the way, there is no acceptable way to write a portable function of an arbitrary number of arguments, since  There is no portable way for the called function to find out how many arguments were passed to it when it was called.  ... <code>printf</code> , the most typical C language function of an arbitrary number of arguments ... is not portable and must be implemented for each system. </blockquote>  This book describes <code>printf</code> , but no <code>vprintf</code> yet, and does not mention the type and macros <code>va_*</code> .  They appear in the second edition of the C Programming Language (1988), and this is the merit of the committee to develop the first C Standard (C89, aka ANSI C).  The committee added the heading <code>&lt;stdarg.h&gt;</code> to the Standard, based on <code>&lt;varargs.h&gt;</code> , created by Andrew Koenig ( <i>Andrew Koenig</i> ) in order to increase the portability of the UNIX OS.  <code>va_*</code> was decided to leave the <code>va_*</code> macros as macros to make it easier for existing compilers to support the new Standard. <br><br>  Now, with the advent of C89 and the <code>va_*</code> family, it has become possible to create portable variable functions.  And although the internal structure of this family is still not described in any way, and there are no requirements for it, it is already clear why. <br><br>  From pure curiosity, you can find examples of the implementation of <code>&lt;stdarg.h&gt;</code> .  For example, in the same Standard Library C, an example is given for <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; from Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  A much newer <a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">SystemV ABI for AMD64</a> uses this type for <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list of SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  In general, it can be said that the type and macros <code>va_*</code> provide a standard interface for traversing the arguments of a variable function, and their implementation for historical reasons depends on the compiler, the target platform and the architecture.  Moreover, an ellipse (i.e., variable functions in general) appeared in C earlier than <code>va_list</code> (i.e., the header <code>&lt;stdarg.h&gt;</code> ).  And <code>va_list</code> was created not to replace the ellipsis, but to allow developers to write their own portable variable functions. <br><br>  C ++ largely maintains backward compatibility with C, so all of the above applies to it.  But there are some peculiarities. <br><br><h3>  Variable functions in C ++ </h3><br>  The development of the C ++ Standard was carried out by the <a href="http://www.open-std.org/jtc1/sc22/wg21/">WG21</a> working group.  Back in 1989, the newly created Standard C89 was taken, which gradually changed to describe C ++ itself.  In 1995, the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1995/N0695.pdf">N0695</a> from John Micco ( <i>John Micco</i> ) was received, in which the author proposed to change the restrictions for macros <code>va_*</code> : <br><br><ul><li>  Since  C ++, in contrast to C, allows you to get the address of a <code>register</code> variable, then the last named argument of a variable function can have this storage class. <br></li><li>  Since  references appearing in C ++ violate the unspoken rule of C variable functions ‚Äî the size of the parameter must match the size of its declared type ‚Äî the last named argument cannot be a link.  Otherwise - indefinite behavior. <br></li><li>  Since  in C ++ there is no concept of ‚Äú <i>increasing the type of argument by default</i> ‚Äù, then the phrase <br><blockquote>  <code>parmN</code> is not the case. </blockquote>  need to be replaced by <blockquote>  <code>parmN</code> is not the case of the parameter. </blockquote></li></ul>  I didn‚Äôt even translate the last point to share my pain.  First, the ‚Äú <i>default argument type boost</i> ‚Äù in the C ++ Standard remains <i>[C ++ 17 8.2.2 / 9]</i> .  And secondly, I was puzzled for a long time over the meaning of this phrase, compared with Standard C, where everything is clear.  Only after reading N0695 did I finally understand: the same is meant here. <br><br>  However, all 3 changes were accepted <i>[C ++ 98 18.7 / 3]</i> .  Even in C ++, the variable function‚Äôs requirement to have at least one named parameter disappeared (in this case, the rest cannot be accessed, but more on that later), and the list of valid types of unnamed arguments was supplemented with pointers to class members and <abbr title="Plain old data">POD</abbr> types. <br><br>  The C ++ 03 standard did not bring any changes to the variable functions.  C ++ 11 began to convert an unnamed argument of type <code>std::nullptr_t</code> to <code>void*</code> and allowed compilers to support types with non-trivial constructors and destructors at their discretion <i>[C ++ 11 5.2.2 / 7]</i> .  C ++ 14 allowed to use functions and arrays as <i>[C ++ 14 18.10 / 3]</i> as the last named parameter, and C ++ 17 forbade disclosing of package of parameters ( <i>pack expansion</i> ) and variables captured by lambda <i>[C ++ 17 21.10.1 / 1]</i> . <br><br>  As a result, C ++ added the variable functions of its pitfalls.  Only one unspecified ( <i>unspecified</i> ) type support with non-trivial constructors / destructors is worth something.  Below, I will try to reduce all non-obvious features of variable functions into one list and supplement it with concrete examples. <br><br><h3>  How easy and wrong to use variable functions </h3><br><ol><li>  It is wrong to declare the last named argument with the type being raised, i.e.  <code>char</code> , <code>signed char</code> , <code>unsigned char</code> , <code>singed short</code> , <code>unsigned short</code> or <code>float</code> .  The result according to the Standard will be undefined behavior. <br><br><div class="spoiler">  <b class="spoiler_title">Wrong code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  Of all the compilers that I had on hand (gcc, clang, MSVC), only <b>clang</b> issued a warning. <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  And although in all cases the compiled code behaved correctly, you should not count on it. <br><br><div class="spoiler">  <b class="spoiler_title">It will be right</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  It is wrong to declare the last named argument by reference.  Any reference.  The standard in this case also promises undefined behavior. <br><br><div class="spoiler">  <b class="spoiler_title">Wrong code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> compiled this code without a single comment.  <b>clang 6.0.0</b> issued a warning, but nevertheless compiled it. <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  In both cases, the program worked correctly (lucky, you can not rely on it).  But <b>MSVC 19.15.26730</b> distinguished itself - he refused to compile the code, because  The <code>va_start</code> argument <code>va_start</code> not be a link. <br><br><div class="spoiler">  <b class="spoiler_title">MSVC Error</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Well, the correct version looks like this, for example.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  It is wrong to query the <code>va_arg</code> type to be <code>va_arg</code> - <code>char</code> , <code>short</code> or <code>float</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Wrong code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  Here is more interesting.  <b>gcc</b> when compiling produces a warning that you need to use <code>double</code> instead of <code>float</code> , and if this code is still executed, the program will end with an error. <br><br><div class="spoiler">  <b class="spoiler_title">Gcc warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  And indeed, the program crashes with a complaint about an invalid instruction. <br>  Dump analysis shows that the program received a SIGILL signal.  And also shows the structure of <code>va_list</code> .  For 32 bits this <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  those.  <code>va_list</code> is just <code>char*</code> .  For 64 bits: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  those.  exactly what is described in SystemV ABI AMD64. <br><br>  <b>clang</b> when compiling warns about undefined behavior and also suggests replacing <code>float</code> with <code>double</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  But the program does not fall, the 32-bit version gives: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64-bit: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b> produces exactly the same results, but without warning, even with <code>/Wall</code> . <br><br>  Here one could assume that the difference between 32 and 64 bits is due to the fact that in the first case ABI passes the called function all the arguments through the stack, and in the second the first four (Windows) or six (Linux) arguments through the processor registers, the rest through stack [ <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">wiki</a> ].  But no, if you call <code>foo</code> not with 4 arguments, but from 19, and also output them, the result will be the same: full mash in the 32-bit version, and zeros for all <code>float</code> in the 64-bit.  Those.  It's a matter of course in ABI, but not in the use of registers for passing arguments. <br><br><div class="spoiler">  <b class="spoiler_title">Well, correctly, of course, do so</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  It is wrong to pass as an unnamed argument an instance of a class with a non-trivial constructor or destructor.  If, of course, the fate of this code worries you a little more than ‚Äúcompile and run here and now.‚Äù <br><br><div class="spoiler">  <b class="spoiler_title">Wrong code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Stricter of all again <b>clang</b> .  He simply refuses to compile this code due to the fact that the second argument <code>va_arg</code> not a POD type, and warns that the program will <code>va_arg</code> when launched. <br><br><div class="spoiler">  <b class="spoiler_title">Clang warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  So it will be, if you still compile with the <code>-Wno-non-pod-varargs</code> flag. <br><br>  <b>MSVC</b> warns that the use in this case of types with non-trivial constructors is intolerable. <br><br><div class="spoiler">  <b class="spoiler_title">MSVC warning</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  But the code is compiled and executed correctly.  The following is obtained in the console: <br><br><div class="spoiler">  <b class="spoiler_title">Startup Result</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Those.  a copy is created only at the moment of calling <code>va_arg</code> , and the argument, it turns out, is passed by reference.  Somehow not obvious, but the Standard allows. <br><br>  <b>gcc 6.3.0</b> compiles without a single comment.  At the output we have the same thing: <br><br><div class="spoiler">  <b class="spoiler_title">Startup Result</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> doesn't warn about anything either, but the behavior changes: <br><br><div class="spoiler">  <b class="spoiler_title">Startup Result</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Those.  this version of the compiler passes arguments by value, and when you call <code>va_arg</code> it makes another copy.  It would be fun to look for this difference when switching from the 6th to the 7th version of gcc, if designers / destructors have side effects. <br><br>  By the way, if you explicitly transmit and request a reference to the class: <br><br><div class="spoiler">  <b class="spoiler_title">Another wrong code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  then all compilers will give an error.  As required by the Standard. <br><br>  In general, if you really want to, it is better to pass arguments by pointer. <br><br><div class="spoiler">  <b class="spoiler_title">Like this</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  Overload Resolution and Variable Functions </h3><br>  On the one hand, everything is simple: a comparison with an ellipsis loses to a comparison with a normal named argument, even in the case of a standard or user-defined type cast. <br><br><div class="spoiler">  <b class="spoiler_title">Overload example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Startup Result</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  But this only works as long as the call to <code>foo</code> without arguments is not considered separately. <br><br><div class="spoiler">  <b class="spoiler_title">Call foo with no arguments</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Compiler output</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Everything is in accordance with the Standard: there are no arguments - there is no comparison with the ellipsis, and when overload is resolved, the variable function becomes no worse than usual. <br><br><h3>  When is it still worth using variable functions </h3><br>  Well, the variable functions in some places do not behave very obviously and in the context of C ++ can easily turn out to be poorly portable.  On the Internet, there are many tips like ‚ÄúDo not create or use optional C functions,‚Äù but they are not going to remove their support from the C ++ Standard.  So, is there any benefit from these functions?  Well, there is. <br><br><ul><li>  The most frequent and obvious case is backward compatibility.  Here I will take both the use of third-party C libraries (my case with JNI) and the provision of the C API to a C ++ implementation. <br></li><li>  <a href="https://ru.wikipedia.org/wiki/SFINAE" title="Substitution Failure Is Not An Error">SFINAE</a> .  Here it is very opportune that in C ++ the variable function does not have to have named arguments, and that when resolving overloaded functions the variable function is considered the last (if there is at least one argument).  And like any other function, the variable function can only be declared, but never called. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Although in C ++ 14 you can do a little differently. <br><br><div class="spoiler">  <b class="spoiler_title">Another example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  And in this case it is already necessary to keep track of which arguments can be called by <code>detect(...)</code> .  I would prefer to change a couple of lines and use a modern alternative to variable functions, devoid of all their flaws. <br></li></ul><br><h3>  Variable templates or how to create functions from an arbitrary number of arguments in modern C ++ </h3><br>  The idea of ‚Äã‚Äãvariable patterns was proposed by Douglas Gregor, Jaakko J√§rvi and Gary Powell back in 2004, i.e.  7 years before the adoption of the C ++ 11 standard, in which these variable patterns were officially supported.  The Standard entered the third revision of their proposal numbered <a href="http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2006/n2080.pdf">N2080</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the very beginning, variable templates were created to enable programmers to create type-safe (and portable!) Functions from an arbitrary number of arguments. </font><font style="vertical-align: inherit;">Another goal is to simplify support for class templates with a variable number of parameters, but now we are talking only about variable functions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable templates brought in C ++ three new concepts </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">template parameter pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a template parameter, instead of which you can pass any number of template arguments (including 0);</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function parameter pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">function parameter pack</font></i><font style="vertical-align: inherit;"> ) - accordingly, this is a function parameter that accepts any (including 0) number of function arguments;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and packet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expansion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">pack expansion</font></i><font style="vertical-align: inherit;"> ) is the only thing that can be done with a package of parameters.</font></font><br></li></ul><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> ‚Äî   , <code>Args ... args</code> ‚Äî   ,  <code>args...</code> ‚Äî    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A complete list of where and how to disclose parameter packages can be found in the Standard itself </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And in the context of the discussion of variable functions, suffice it to say that:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the function parameter package can be expanded into another function's argument list.</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or in the initialization list</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or in the lambda capture list</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another batch of function parameters can be expanded in a convolution expression</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convolutions appeared in C ++ 14 and can be unary and binary, right and left. </font><font style="vertical-align: inherit;">The most complete description, as always, in the Standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both types of parameter packages can be expanded in the sizeof operator ...</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In disclosing the explicit ellipsis package is needed to support the various templates ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patterns</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) disclosure and to avoid this ambiguity.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">for example</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> ‚Äî      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> ‚Äî ,     ‚Äî   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example of implementing printf using variable patterns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I already mentioned, variable templates were created, including as a direct replacement for the variable functions of C. The authors of these templates themselves offered their own, very simple, but type-safe version </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- one of the first variable functions in C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf on templates</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I suspect, then this pattern of iterating variable arguments appeared - through a recursive call to overloaded functions. </font><font style="vertical-align: inherit;">But I still like the non-recursion option.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf on templates and without recursion</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Overload Resolution and Variable Template Functions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When resolved, these variable functions are considered after the others - as template and as least specialized. </font><font style="vertical-align: inherit;">But there are no problems in the case of a call without arguments.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overload example</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup Result</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When overload is enabled, the variable template function can bypass only the variable C function (although why mix them?). </font><font style="vertical-align: inherit;">Except - of course! </font><font style="vertical-align: inherit;">- call without arguments.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call without arguments</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup Result</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a comparison with an ellipsis - the corresponding function loses, there is no comparison with an ellipsis - and the template function is inferior to the non-sample. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A quick note on the speed of variable template functions. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In 2008, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo√Øc Joly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> submitted to the C ++ Standardization Committee his proposal </font></font><a href="http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2008/n2772.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which he showed in practice that variable template functions work slower than similar functions, the argument of which is the initialization list ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). And although this contradicted the theoretical rationale of the author himself, Joly proposed to implement it </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it was with the help of initialization lists, and not variable templates. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But already in 2009, a denial appeared. In the tests of Joly, a ‚Äúserious error‚Äù was discovered (it seems, even by him). New tests (see </font></font><a href="https://nd.home.xs4all.nl/dekkerware/issues/n2772_fix/draft_november_2009.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://nd.home.xs4all.nl/dekkerware/issues/n2772_fix/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) showed that variable template functions are still faster, and sometimes significantly. </font><font style="vertical-align: inherit;">What is not surprising, since </font><font style="vertical-align: inherit;">The initialization list makes copies of its elements, and for variable templates you can count a lot more at the compilation stage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, in C ++ 11 and subsequent standards </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are the usual template functions, an arbitrary number of arguments are passed through the initialization list.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Short summary and conclusion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, variable functions in the style of C: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They do not know the number of their arguments or their types. </font><font style="vertical-align: inherit;">The developer must use part of the function arguments in order to pass information about the rest.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implicitly raise the types of unnamed arguments (and the last named one). </font><font style="vertical-align: inherit;">If you forget about it, you get an undefined behavior.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retain backward compatibility with pure C and therefore do not support passing arguments by reference. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prior to C ++ 11, arguments of non- </font></font><abbr title="Plain Old Data"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> types were </font><font style="vertical-align: inherit;">not supported </font><font style="vertical-align: inherit;">, but starting from C ++ 11, support for non-trivial types was left to the discretion of the compiler.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The behavior of the code depends on the compiler and its version. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only allowable use of variable functions is interaction with the C API in C ++ code. </font><font style="vertical-align: inherit;">For everything else, including </font></font><abbr title="Substitution Failure Is Not An Error"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , there are variable template functions that:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Know the number and types of all their arguments. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type safe, do not change the types of their arguments. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Support the transfer of arguments in any form - by value, by pointer, by reference, by universal reference. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Like any other C ++ functions, there are no restrictions on the types of arguments. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable template functions can be more verbose than their C-like counterparts and sometimes even require their overloaded non-template version (recursive argument traversal). </font><font style="vertical-align: inherit;">They are harder to read and write. </font><font style="vertical-align: inherit;">But all this is more than compensated by the absence of the listed disadvantages and the presence of the listed advantages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the conclusion is simple: the variable functions in the C style remain in C ++ only because of backward compatibility, and they offer a wide choice of possibilities to shoot yourself a leg. </font><font style="vertical-align: inherit;">In modern C ++, it is highly desirable not to write new ones and, if possible, not to use already existing variable C functions. </font><font style="vertical-align: inherit;">Variable template functions belong to the world of modern C ++ and are much more secure. </font><font style="vertical-align: inherit;">Use them.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literature and sources </font></font></h3><br><ul><li> <a href="https://www.amazon.com/Standard-C-Library-P-J-Plauger/dp/0131315099"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, The Standard C Library</font></font></a> <br></li><li> <a href="https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131101633"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan and Dennis M. Ritchie, The C Programming Language, 1st Edition</font></font></a> <br></li><li> <a href="https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan and Dennis M. Ritchie, The C Programming Language, 2nd Edition</font></font></a> <br></li><li> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C11, draft N1570</font></font></a> <br></li><li> <a href="http://www.lirmm.fr/~ducour/Doc-objets/ISO%2BIEC%2B14882-1998.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 98 standard</font></font></a> <br></li><li> <a href="https://cs.nyu.edu/courses/fall11/CSCI-GA.2110-003/documents/c%2B%2B2003std.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03 standard</font></font></a> <br></li><li> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C ++ 11, draft N3337</font></font></a> <br></li><li> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C ++ 14, draft N4296</font></font></a> <br></li><li> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C ++ 17, draft N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is easy to find and download electronic versions of the books mentioned on the net. </font><font style="vertical-align: inherit;">But I am not sure that it will be legal, therefore I do not give references.</font></font></div><p>Source: <a href="https://habr.com/ru/post/430064/">https://habr.com/ru/post/430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430054/index.html">HolyJS 2018 Moscow: free online broadcast, party and science and technology rap</a></li>
<li><a href="../430056/index.html">Aging is not a wear process (translation)</a></li>
<li><a href="../430058/index.html">Wave processes in hydraulic lines. The basics</a></li>
<li><a href="../430060/index.html">Hakspeys, Denis Perevalov, Anastasia Krokhaleva - the magic of programming</a></li>
<li><a href="../430062/index.html">Microservices. Development and refactoring patterns with Java examples</a></li>
<li><a href="../430068/index.html">Pupa order</a></li>
<li><a href="../430072/index.html">"Server-side Swift is underestimated": interview with Paul Hudson</a></li>
<li><a href="../430074/index.html">How I almost caught a virus trying to sell my boots</a></li>
<li><a href="../430076/index.html">Free broadcast DotNext 2018 Moscow</a></li>
<li><a href="../430078/index.html">How to control electrical appliances, radio-controlled models, motorized sidecar using a glance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>