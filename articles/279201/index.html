<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Alternative Website Localization: CDN Mutating Content</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Most web developers faced the task of translating a website into several languages. The mission is quite simple, and the solution, as a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Alternative Website Localization: CDN Mutating Content</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Most web developers faced the task of translating a website into several languages.  The mission is quite simple, and the solution, as a rule, refers to the routine.  I am sure that many will agree with the statement that localization is a boring, non-creative part of the project. <br><br>  In this article, I would like to discuss an alternative website translation model.  If you try to describe the principle in one sentence, then it is: CDN, which translates the content between the user and the original source. <br><a name="habracut"></a><br><h2>  The need for translations </h2><br>  I doubt that the usefulness of the multi-lingual resource is worth proving, but, nevertheless, I devote to this one small paragraph. <br><br>  Any Internet site is accessible to three billion users on the planet by default - simply because your site is online.  If you sell something on the site, then simply adding a language will actually lead you into a new market.  At a minimum, you want to have a version in the local language (the language of the territory where you do business) and the English version, because English is half of the Internet content according to <a href="http://w3techs.com/technologies/overview/content_language/all">W3Techs</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Existing methods </h2><br><h3>  Translation files </h3><br>  The options are different - from special formats like GNU gettext, to simple text files that your current framework can use.  The result is approximately the same: at the moment of the text output, a function is called that checks the presence of the translation in the dictionary. <br><br>  PHP example: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// gettext: echo _(", !"); //  Laravel 5 echo trans('common.hello_world');</span></span></code> </pre> <br>  Advantages of the method: <br><br><ul><li>  The method proven by decades (read habitual); </li><li>  The ability to simply give individual files to third-party translators; </li><li>  Small effect on the code. </li></ul><br>  Cons of the way: <br><br><ul><li>  As a rule, there is no possibility of making immediate changes; </li><li>  gettext dictionaries need to be compiled and final files committed to the repository; </li><li>  Relatively inconvenient and slow text management, the larger the project - the larger the files and the more complicated the hierarchy; </li><li>  There are no standard mechanisms for translation work by a team of translators; </li><li>  As a rule, two schemes are used in parallel - translations for backend and translations for frontend (JavaScript); </li><li>  From time to time HTML tags appear in the texts for translations because it was inconvenient for programmers to pull them out. </li></ul><br><h3>  Translations in the database </h3><br>  Unlike the first method, translations are stored in the project database, which allows you to make adjustments on the go.  As a rule, project developers make a translation control panel for administrators, which takes additional time. <br><br>  Advantages of the method: <br><br><ul><li>  Easier to organize the work of teams; </li><li>  The ability to make immediate changes. </li></ul><br>  Cons of the way: <br><br><ul><li>  It is more difficult to give sections for translation to third-party translators; </li><li>  Frontend texts are still translated separately from the backend texts; </li><li>  From time to time HTML tags appear in the texts for translations because it was inconvenient for programmers to pull them out. </li></ul><br><h3>  Translation by the user through JavaScript </h3><br>  A relatively new way is being proposed by several Western startups.  All you need to do is add a link to an external JavaScript file that will begin to replace texts in the DOM based on the provided (or approved) pre-translation. <br><br>  Advantages of the method: <br><br><ul><li>  Easy installation with almost no programming required; </li><li>  Frontend and backend are translated simultaneously from the same translation repository; </li><li>  There will be no HTML tags in the text repository, because all texts were processed post factum from the DOM. </li></ul><br>  Cons of the way: <br><br><ul><li>  Search engines will not see additional languages; </li><li>  Share the link in social networks will also be impossible; </li><li>  Additional network load (read the risks of delays) when opening the site. </li></ul><br><h3>  CDN Translator </h3><br>  Actually, what is submitted for discussion in this article.  And what if between the user and the sites insert a ‚Äúlayer‚Äù - an edge server capable of translating web content?  Services like CloudFlare already know how to minimally mutate client pages ‚Äî add Google Analytics code, for example.  What if you go a step further and allow the user to replace texts and links? <br><br>  Traditional CDN Behavior: <br><br><ol><li>  Customer requests address X; </li><li>  If X is in the cache, it is immediately returned from the cache; </li><li>  If the X address is not in the cache, then the Edge Server makes a request to the original site, and then returns the response to the client.  Depending on the headers in the response of the original site and the rules established on the site, resource X can now be placed in the cache. </li></ol><br><img src="https://habrastorage.org/files/157/6c0/cac/1576c0cacd7a4dc99dfb83d31802f0aa.jpg"><br><br>  CDN Translator Behavior: <br><br><ol><li>  Customer requests address X; </li><li>  If the X address is in the cache, then it is immediately returned from the cache as is; </li><li>  If the X address is not in the cache, the edge server makes a request to the original site, and then applies the rules of mutation - replaces the links, replaces the translated texts.  Depending on the headers in the response of the original site and the rules established on the site, resource X may be placed in the cache. </li></ol><br><h4>  Step 2b in detail </h4><br>  Having received a response from the original site, the Edge Server has the task of how to translate it.  Suggested tactics: <br><br><ol><li>  Pay attention to the Content-type header.  If the value is not included in the list of supported, then do not try to transform the content; </li><li>  Pay attention to the size of the response.  If the size is above the established border - do not try to transform the content; </li><li>  Start parsing and editing content.  An example for an HTML page: walk through all the DOM nodes that have a descendant text node.  Request translated text in the repository, passing the source text and context as parameters. <br></li><li>  Replacing the necessary pieces of content, return the result to the user.  If the headers and rules allow, then we cache the result. </li></ol><br>  The repository would be logical to implement as a stand-alone RESTful API, and the context would be conveniently set like a URL: selector.  For example, we want to translate the word ‚ÄúMain page‚Äù as ‚ÄúHome‚Äù in any block of any page starting with / news, we get the context ‚Äú/ news *: head‚Äù.  The world is so used to CSS / jQuery style selectors that virtually any developer can start working with this syntax right away. <br><br>  Since the border server is requesting translation into the repository API, the implementation of the SDK and packages for popular languages ‚Äã‚Äãand frameworks becomes quite logical.  Website owners are given a choice - you can translate content through a CDN, or through our class in existing code. <br><br>  Suppose we have a PHP application and use the Laravel framework.  Implementing legacy support is trivial - we re-declare the trans () helper function, replace it with our own implementation, where the search is not in local text files, but in the remote API.  To avoid delays with each request, use a cache or a separate proxy process. <br><br>  Similarly, we can change the contents of JavaScript objects, graphics, and so on. <br><br>  Advantages of the method: <br><br><ul><li>  Full abstraction of the application and translations - the application does not know at all about the presence of other language versions.  Programmers are quietly working on the main product; </li><li>  Backend and frontend-content is translated simultaneously using one translation repository; </li><li>  You can simply transfer graphic images; </li><li>  It is very easy to run translated versions of the site on other (separate) domains; </li><li>  Compatible with any existing CDN service.  You can build in a chain; </li><li>  Compatible with search engines and social networks; </li><li>  There will be no HTML tags in the text repository, because all texts were processed post factum from the DOM; </li><li>  Easy to organize teams work. </li></ul><br>  Cons of the way: <br><br><ul><li>  I could not find it, but I will be very happy to help in this! </li></ul><br><h2>  YouTube video </h2><br>  In order to clearly explain the concept, I shot a very short video clip that shows my prototype of such a translation system.  The narrative is in English, but I added Russian subtitles. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/b37HynAXXf4%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi853xOv6lk-YbiKTUfk5JQhenreg" frameborder="0" allowfullscreen=""></iframe><br><br><h2>  Implementation </h2><br>  I have already checked the feasibility and practicality of the proposed method - I wrote a primitive version of the boundary application in PHP and Lumen. <br><br>  My method that receives a request from the user and returns the translated answer: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> Request $request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> WebClientInterface $crawler * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> MutatorInterface $mutator * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> TranslatorInterface $translator * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> Response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request $request, WebClientInterface $crawler, MutatorInterface $mutator, TranslatorInterface $translator)</span></span></span><span class="hljs-function"> </span></span>{ $url = $request-&gt;client[<span class="hljs-string"><span class="hljs-string">'origin'</span></span>] . parse_url($request-&gt;url(), PHP_URL_PATH); $response = $crawler-&gt;makeRequest($request-&gt;getMethod(), $url); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) abort(<span class="hljs-number"><span class="hljs-number">502</span></span>); $mutator-&gt;initWithWebRequest($response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;isTranslatable()) $mutator-&gt;translateText($translator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;isCacheable()) $mutator-&gt;cache(<span class="hljs-number"><span class="hljs-number">60</span></span>); $mutator-&gt;replaceLinks($request-&gt;client[<span class="hljs-string"><span class="hljs-string">'origin'</span></span>], $request-&gt;getSchemeAndHttpHost()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response($mutator-&gt;getBody(), $mutator-&gt;getStatusCode())) -&gt;withHeaders($mutator-&gt;getHeaders()); }</code> </pre><br>  I am sure that many will begin to doubt the paradigm because of the load on the processor - because the same nginx therefore does not want to mutate the contents of the answers in any way, as this would have a very negative impact on performance.  In general, translating like this, post factum, is certainly more expensive in terms of resources. <br><br>  My arguments here are as follows.  We are seeing a constant reduction in the cost of IT resources over the past 5-10 years, the era of servers for $ 5 has come - for many sites it is not that scary to increase the load a little.  Secondly, if I do this project after all, optimization of productivity will be one of the priorities.  Surely, you can find a lot of room for improvement! <br><br><h2>  Conclusion </h2><br>  The industry is always moving in the direction of optimization, increased comfort and cost savings.  I believe that the proposed method of localization of web applications is likely to become the main in 5-10 years. <br><br>  Moreover, a CDN, like a structure, may have more and more new applications.  CloudFlare offered DDoS protection to the world, Imgix makes responsive images on the fly. </div><p>Source: <a href="https://habr.com/ru/post/279201/">https://habr.com/ru/post/279201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279189/index.html">Do I need a microscope when connecting ‚Äúpatchcords‚Äù?</a></li>
<li><a href="../279193/index.html">What to read about promising programming languages</a></li>
<li><a href="../279195/index.html">How easy and natural to write a game in 2 years</a></li>
<li><a href="../279197/index.html">GF (256) final field and some magic</a></li>
<li><a href="../279199/index.html">Jigsaw puzzle with regular expressions from LinkedIn</a></li>
<li><a href="../279203/index.html">SonataAdminBundle: Creating an Object from a List View (Part 2)</a></li>
<li><a href="../279205/index.html">Militiamen took up whatsapp</a></li>
<li><a href="../279207/index.html">Installing applications in Cach√© using projections</a></li>
<li><a href="../279209/index.html">Big survey on algorithms</a></li>
<li><a href="../279211/index.html">9 secrets of online payments. Part 3: Payment Method Selection Page</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>