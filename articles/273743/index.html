<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QThread + QtSql the right way</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today's article inspired me to share my way of putting databases into a separate thread. The method is suitable not only for the database, but also fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QThread + QtSql the right way</h1><div class="post__text post__text-html js-mediator-article"> Today's <a href="http://habrahabr.ru/post/273647/">article</a> inspired me to share my way of putting databases into a separate thread.  The method is suitable not only for the database, but also for any interactions described by the pattern ‚Äúsome object lives in a separate thread, it is necessary to ask something from it and do something with it‚Äù.  In addition, the method is good in that it tries to be type-safe and extensible: no stringly-typed <code>QMetaObject::invokeMethod()</code> , no transmission of the results of an object <code>QMetaObject::invokeMethod()</code> in the stream through signals.  Only direct function call, only <code>QFuture</code> ! <br><a name="habracut"></a><br>  Disclaimer: The code here is a piece of one of my large projects, so it will use some auxiliary library functions from this project.  I, however, will try not to miss cases of such use and describe their semantics. <br><br>  So, let's start with the most important thing: how would we like to work with an object in a separate thread?  Ideally, we simply pull some methods from some object, the methods return <code>QFuture&lt;T&gt;</code> , the readiness of which will mean that the corresponding asynchronous method has finished executing, and it has results like <code>T</code> <br><br>  Recall that decomposition is our friend, so let's take our original task ‚Äúwe have to pull something in a separate thread‚Äù and consider its piece ‚Äúwe need to keep a separate thread and provide a thread-safe call <em>for something</em> in it with a return <code>QFuture</code> ‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's solve this problem in the following way: a <code>QThread</code> object responsible for managing the flow has a <code>ScheduleImpl()</code> method, called from the main thread (and from others too), accepting some functor that wraps this functor in <code>QFuture</code> and saves everything that is needed, into a special queue, which is then processed inside <code>QThread::run()</code> . <br><br>  It turns out something like this: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerThreadBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QThread { Q_OBJECT QMutex FunctionsMutex_; QList&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ()&gt;&gt; Functions_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> QThread::QThread; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cleanup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; QFuture&lt;ResultOf_t&lt;F ()&gt;&gt; ScheduleImpl (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> F&amp; func) { QFutureInterface&lt;ResultOf_t&lt;F ()&gt;&gt; iface; iface.reportStarted (); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> reporting = [func, iface] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ReportFutureResult (iface, func); }; { QMutexLocker locker { &amp;FunctionsMutex_ }; Functions_ &lt;&lt; reporting; } <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateFuncs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iface.future (); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateFuncs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateFuncs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Explanations for all ReportFutureResult and ResultOf_t</b> <div class="spoiler_text">  <code>ResultOf_t</code> is a direct analogue of <code>std::result_of_t</code> from C ++ 14.  My project, unfortunately, still has to support C ++ 11 compilers. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ResultOf_t = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::result_of&lt;T&gt;::type;</code> </pre><br><br>  <code>ReportFutureResult</code> takes the functor, its arguments, executes the functor and marks the corresponding <code>QFutureInterface</code> as ready, at the same time passing it the result of the execution of the functor, or wraps <code>QFutureInterface</code> exception in <code>QFutureInterface</code> if the execution of the functor ends with this exception.  Unfortunately, the case is somewhat complicated by returning void functors: for them, you have to write a separate function, because in C ++ you cannot declare a <code>void</code> variable.  We have such a type system, oh, the type is, the value is in it, but it is impossible to declare it. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; EnableIf_t&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;R, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::value&gt; ReportFutureResult (QFutureInterface&lt;R&gt;&amp; iface, F&amp;&amp; f, Args... args) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = f (args...); iface.reportFinished (&amp;result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QtException_t&amp; e) { iface.reportException (e); iface.reportFinished (); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { iface.reportException (ConcurrentStdException { e }); iface.reportFinished (); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReportFutureResult</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QFutureInterface&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; iface, F&amp;&amp; f, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { f (args...); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QtException_t&amp; e) { iface.reportException (e); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) { iface.reportException (ConcurrentStdException { e }); } iface.reportFinished (); }</code> </pre><br><br>  <code>QtException_t</code> needed to support building with Qt4: <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> QT_VERSION &lt; 0x050000 using QtException_t = QtConcurrent::Exception; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> using QtException_t = QException; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  <code>ConcurrentStdException</code> wraps the standard exception into one that Qt understands the QFuture mechanism, but its implementation is a bit more complicated and not so important here. <br></div></div><br><br>  That is, <code>ScheduleImpl()</code> takes a certain functor with a signature of type <code>T ()</code> , returns <code>QFuture&lt;T&gt;</code> , wraps the functor in a special function, now with the signature <code>void ()</code> associated with the returned <code>QFuture&lt;T&gt;</code> , and which, when executed by the functor, <code>QFuture&lt;T&gt;</code> marks ready, and adds this wrapper to the queue <br><br>  After that, the signal <code>rotateFuncs()</code> emitted, which inside <code>run()</code> connected to the <code>RotateFuncs()</code> method, which is responsible for processing the queue of saved functor wrappers. <br><br>  Now let's look at the implementation of the <code>run()</code> and <code>RotateFuncs()</code> methods: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorkerThreadBase::run () { SlotClosure&lt;NoDeletePolicy&gt; rotator { [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] { RotateFuncs (); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SIGNAL (rotateFuncs ()), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> }; Initialize (); QThread::run (); Cleanup (); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorkerThreadBase::RotateFuncs () { <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (Functions_) funcs; { QMutexLocker locker { &amp;FunctionsMutex_ }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap (funcs, Functions_); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; func : funcs) func (); }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">A bit about SlotClosure</b> <div class="spoiler_text">  <code>SlotClosure</code> is a helper class that helps attach signals to lambdas, not slots.  In Qt5, there is a more adequate syntax for this, but unfortunately, I also still need to support the Qt4 build. <br><br>  <code>SlotClosure</code> is simple; it calls its first argument each time an object, which is the second argument, emits a signal ‚Äî the third argument.  The fourth argument is the parent object.  Here we have <code>SlotClosure</code> set on the stack, so parents are not needed. <br><br>  The template argument <code>NoDeletePolicy</code> means that the object should not commit suicide after the first signal.  Other deletion policies include, for example, <code>DeleteLaterPolicy</code> , which <code>DeleteLaterPolicy</code> connection object after the first triggering of a signal, which is convenient for various tasks that are performed once. <br></div></div><br><br>  With these functions, everything is simple: connect the <code>rotateFuncs()</code> signal to the <code>rotateFuncs()</code> function (hmm, I wonder how many comments will be on the naming style?), Call the initialization function of stream objects defined somewhere in the heir, and start spinning the stream.  When the stream owner makes the <code>quit()</code> <code>QThread::run()</code> , <code>QThread::run()</code> will return control, and the heir will be able to clean up after itself in <code>Cleanup()</code> . <br><br>  Note that it is Qt's slot-signal mechanism that is responsible for <code>rotateFuncs()</code> emitted from the main thread to cause <code>RotateFuncs()</code> in our <code>WorkerThreadBase</code> . <br><br>  <code>RotateFuncs()</code> however, briefly blocks the main queue, moving it to itself, and then begins to execute it sequentially. <br><br>  Actually, this is all.  As an example of use, for example, a piece of the storage system of avatars on a disk in the IM client can be given: <br><div class="spoiler">  <b class="spoiler_title">avatarsstoragethread.h</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AvatarsStorageThread</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Util::WorkerThreadBase { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;AvatarsStorageOnDisk&gt; Storage_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Util::WorkerThreadBase::WorkerThreadBase; QFuture&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; SetAvatar (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; entryId, IHaveAvatars::Size size, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray&amp; imageData); QFuture&lt;boost::optional&lt;QByteArray&gt;&gt; GetAvatar (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; entryId, IHaveAvatars::Size size); QFuture&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; DeleteAvatars (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; entryId); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cleanup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">avatarsstoragethread.cpp</b> <div class="spoiler_text"><pre> <code class="hljs php">QFuture&lt;void&gt; AvatarsStorageThread::SetAvatar (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; entryId, IHaveAvatars::Size size, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray&amp; imageData) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ScheduleImpl ([=] { Storage_-&gt;SetAvatar (entryId, size, imageData); }); } QFuture&lt;boost::optional&lt;QByteArray&gt;&gt; AvatarsStorageThread::GetAvatar (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; entryId, IHaveAvatars::Size size) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ScheduleImpl ([=] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Storage_-&gt;GetAvatar (entryId, size); }); } QFuture&lt;void&gt; AvatarsStorageThread::DeleteAvatars (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; entryId) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ScheduleImpl ([=] { Storage_-&gt;DeleteAvatars (entryId); }); } void AvatarsStorageThread::Initialize () { Storage_.reset (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AvatarsStorageOnDisk); } void AvatarsStorageThread::Cleanup () { Storage_.reset (); }</code> </pre><br></div></div><br><br>  But the implementation of <code>AvatarsStorageOnDisk</code> is a separate interesting topic related to my homegrown under-ORM framework, which allows generating labels, SQL queries and the corresponding functions for insertion / deletion / update by describing the structure with data via Boost.Fusion.  However, this implementation is in no way related to the issue of multithreading, which, in general, is good, especially from the point of view of the decomposition of the original problem. <br><br>  And finally, we note the shortcomings of the proposed solution: <br><ol><li>  In the public API of the class <code>WorkerThreadBase</code> , you need to duplicate all the methods that you want to call the object that is being carried to a separate stream.  How to effectively solve this problem, I did not think out right away. </li><li>  <code>Initialize()</code> and <code>Cleanup()</code> directly asked to turn into some RAII.  It is worth coming up with something on this topic. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/273743/">https://habr.com/ru/post/273743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273727/index.html">Swift. Functional programming</a></li>
<li><a href="../273731/index.html">SWAT - DSL for rapid development of automated web application tests</a></li>
<li><a href="../273733/index.html">‚ÄúWings, paws and tails‚Äù of our Linux hosting, part 1: how we automated the deployment of infrastructure</a></li>
<li><a href="../273737/index.html">What year 2015 brought us?</a></li>
<li><a href="../273741/index.html">Adobe Playpanel project closes January 31, 2016</a></li>
<li><a href="../273745/index.html">History of the 5th place in the Russian AI Cup 2015</a></li>
<li><a href="../273747/index.html">IBM is working on a project to create an open-source blockchain for business representatives.</a></li>
<li><a href="../273749/index.html">Weather Station on Arduino with data visualization</a></li>
<li><a href="../273751/index.html">bala.js - jQuery killer in less than 400 characters of code *</a></li>
<li><a href="../273753/index.html">ASP.NET 5 Identity 3 and new authentication / authorization toolkit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>