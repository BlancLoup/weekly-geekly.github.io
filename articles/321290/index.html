<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The brilliance and poverty of test automation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is believed that the presence of automatic tests - this is an absolute good. If developers write tests, that's good; the more tests, the better. At...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The brilliance and poverty of test automation</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/136/6fd/060/1366fd060ca707d9e1b25f372e359db5.png" alt="image"></div><br>  It is believed that the presence of automatic tests - this is an absolute good.  If developers write tests, that's good; the more tests, the better.  At the same time, in reality they are not often written, and all testing is done manually. <br><br>  Do not blame this state of affairs on incompetence, stupidity, or a banal laziness of developers.  Compared to manual testing, automated has both advantages and obvious disadvantages.  If there were only advantages, and there would be nothing to talk about. <br><a name="habracut"></a><br><br><h4>  Benefits of Auto Tests </h4><br>  Automated testing has several significant advantages compared with manual testing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Cheapness</b> - <i>running</i> automatic tests is always cheaper than manual testing by several orders of magnitude.  <i>Development of</i> automatic tests is certainly more expensive than <i>one</i> - <i>time</i> manual testing. <br><br>  <b>Indefatigability</b> - automatic tests can be run again and again, they have an unlimited working day, they do not get tired, and do not get sick. <br><br>  <b>Speed</b> - automatic tests run orders of magnitude faster than the same manual checks.  Of course, there are relatively slow tests, but this is rather an exception, confirming the rule. <br><br>  <b>Accuracy</b> - automated tests check exactly what is described in the script, in all its details and trivia.  They are not distracted, not confused and not forgotten. <br><br>  <b>Comprehensive</b> - automated tests can cover a huge number of scenarios and find induced errors in such far corners of the application that the manual tester would never have reached except by chance. <br><br><h4>  Benefits of manual testing </h4><br>  Manual testing, however, is superior to automated in many aspects. <br><br>  <b>Agility</b> - check something manually for the first time easily and quickly.  An automatic test must first be developed.  Almost always it is much slower than manual checking. <br><br>  <b>Flexibility</b> - manual testing can be carried out much more diversely, and changing the testing method costs almost nothing.  Let's test in Safari - please, on a Chromebook - no problem, IE6 - you have to start the virtual machine, but you can, too. <br><br>  <b>Adaptability</b> - the ability to quickly adapt to change.  When a product changes dramatically, and things start to work at all differently from before, manual testers can easily forget how they tested before.  They will simply test what is now.  Automatic tests in the same situation will give out thousands of errors, and they will have to be corrected before moving on. <br><br>  <b>Creativity</b> - manual testing allows you to find problems that were not known in advance, moreover, they were not even implied. <br><br>  <b>Meaningfulness</b> - although every single thing can be absolutely correct, people understand much more easily that together these things have no meaning. <br><br>  <b>Expressiveness</b> - it‚Äôs not enough to find a problem at the ‚Äúnothing works!‚Äù Level, it is important to correctly explain what it is and be able to answer additional questions from the developer.  And in this, people are also better than automatic tests. <br><br>  <b>Authenticity</b> - most of the applications we write for people, and that is why people are best suited to test them. <br><br><h4>  Brilliance of testing paradoxes </h4><br>  Speaking about testing, and even more about full testing, we are a little cunning.  Obviously, it <b>'s impossible to verify everything</b> . <br><br>  All we can do in practice is to carry out some <i>sufficient testing</i> .  As a result, we can with a certain degree of probability say that the majority of users will not encounter problems. <br><br>  Having spent for testing 1 day, we will achieve 90% of satisfied users.  Testing the week - 99%, testing the month 99.5%.  We are spending more and more time to achieve less and less results.  This is impractical. <br><br>  <b>By correcting problems quickly, you can achieve a much higher quality product</b> than by investing all available resources in achieving full test coverage.  Salt is to find a balance in the application of forces. <br><br>  <b>Manual testing gives much more return if it is necessary to develop quickly</b> , especially if the application changes incrementally, in local predictable parts.  The reason is that it‚Äôs much faster to test the change than to automate the same test. <br><br>  <b>Automatic testing gives very little return at short distances</b> .  At every single moment, deciding what is more profitable, whether to write tests or not to write, the second is always preferable. <br><br>  The situation is fundamentally changing in the long term.  The application code must be refactored so that it does not die.  When programmers have redone everything - testers should check everything.  Full cycle of regression tests.  A week?  Two?  Month?  Or worse: programmers have updated the version of the key library.  The day of work, everything seems to be compiled - great!  Still, testers should check everything.  Madness.  After going through this a few times, anyone will be ready to go for anything, just to avoid such situations in the future.  <b>To ensure a stable base level of quality, it is necessary to invest in test automation.</b> <br><br>  Unfortunately, automated tests are not always the solution, sometimes they themselves become a problem. <br><br><h4>  Poverty testing automation </h4><br>  <b>Problem</b> : you need to be able to check the application completely and quickly, without losing anything, many times in a row. <br><br>  <b>Solution</b> : write automatic tests that do all this. <br><br>  But not everything is so simple. <br><br>  <b>Writing tests is a development</b> that is exactly the same as developing a core business logic.  It requires resources and qualifications.  Providing a high-quality coverage of the application code with tests, we simultaneously slow down the development as such.  And we slow down not by 10%, but twice, three times or even more. <br><br>  <b>Speed ‚Äã‚Äãis a relative concept</b> .  Each particular test is, of course, performed very quickly, especially pure unit tests, when all checks are performed locally.  Integration tests, REST tests are also relatively fast.  What is 100 milliseconds, well, even if 1 second, even tens of seconds for selenium tests, is nonsense compared to manual testing.  But when the number of tests in any significant way, the fast tests turn out to be very slow.  Run tests in 5 minutes?  Half an hour?  Three hours, three o'clock?  Two days?  Even without having achieved a complete coverage of business logic, there is a serious question about how not to run all the tests, or not to run the tests every time - otherwise automatic tests start to slow down the development. <br><br>  <i>Note</i> : Tests can be significantly accelerated by investing in hardware ‚Äî allocating a separate server for them, 10 servers, 50, etc. Some companies can afford 1000 test servers, but not all. <br><br>  <b>The toolkit is bad</b> .  None of the mainstream programming platforms was designed to provide the ability to easily and fully develop tests.  In Java, all test frameworks are third-party libraries.  Running tests, performing checks, creating mock objects - all this is there, but in parts and outside the platform.  In Go, the test framework has already been added to the language ecosystem initially, but this is only the start of tests.  Choosing the right toolkit for writing tests is a separate problem that needs to be solved. <br><br>  <b>They are not so good</b> .  Tests - the same code written by the same developers.  They also contain errors and all the same problems as any other code.  It happens that the test does not check anything.  It happens that the tests also need to refactor.  It happens that in a fallen test it is very difficult to understand what the problem is.  It happens that tests fall just like that, when there really is no error. <br><br>  <b>Block changes</b> .  By their nature, tests are designed to verify that nothing has changed.  If something starts to work wrong - this is a bug.  But when business logic changes, even if the change correctly and fully meets the new requirements, the tests know nothing about it.  Changes to several rules can lead to the need to correct dozens, if not hundreds of tests, especially if the coverage is really good. <br><br>  <b>Limit refactoring</b> .  Tests also need to be refactored, even if the business logic does not change, and only cosmetic changes occur in the code.  This may lead to the fact that you need to fix 5 places in the main code and another 80 in the tests.  Everyone in this situation will think: is it worth doing something more than renaming the method. <br><br>  <b>Sisyphean work</b> - this is what development through testing turns into, when tests are written before writing code, or at least along the way.  Any competent developer refactor code in the process of writing it as he more and more deeply understands the problem and understands how to implement the solution in the best way.  But if he writes tests at the same time as the code, in addition to changes in the code, he also has to change the tests.  And unlike the refactoring of the finished code, the refactoring of the code in the work is usually much larger, which means that the required changes in the tests will be appropriate.  And so - many times before the code goes to the review.  Half the time in the garbage is easy. <br><br>  <b>The number of tests is deceptive</b> : 3,000 tests in total ‚Äî for the web interface, REST API, business logic, and unit tests ‚Äî can be tested with a stretch of 1000 situations.  All the rest is duplication. <br><br>  <b>Automatic regression does not cancel the manual</b> contrary to the main idea.  All because automatic tests check a lot of things, but not all.  But no one knows what exactly they are testing and what is not.  We need to check the registration.  And we have 18 927 tests.  If one of them is red - ‚Äúeverything is fine‚Äù, you can return the task to the developers - let them understand.  If all tests are green - it does not mean anything until the person responsible for manual testing is sure that the registration logic is checked automatically, and that it still needs to be checked manually.  And almost twenty thousand tests are impossible to understand.  The result - you need to check everything manually. <br><br>  It is not surprising that some people leave the development to sell plastic windows, train billiards or make coffee (and these are all real cases). <br><br>  What conclusions we made in <a href="https://wrike.com/ru/">Wrike</a> from our own and others' mistakes will be discussed in the next post. <br><br>  <i>Dmitry Mamonov</i> <i><br><br></i>  <i>Development department,</i> <i><br></i>  <i>Merge's division into master,</i> <i><br></i>  <i>Department of work with git,</i> <i><br></i>  <i>Leading operator bash console 1 discharge</i> </div><p>Source: <a href="https://habr.com/ru/post/321290/">https://habr.com/ru/post/321290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321278/index.html">Local multiplayer in Unity using Unet</a></li>
<li><a href="../321280/index.html">The history of the development of TWIME - the new high-speed interface of the Moscow Exchange</a></li>
<li><a href="../321282/index.html">Riot loafers, or again about the accounting of working time</a></li>
<li><a href="../321286/index.html">Password recovery D-Link DPH-400S or the story of a small hack</a></li>
<li><a href="../321288/index.html">Undocumented features of Windows: breakpoints for registry keys</a></li>
<li><a href="../321292/index.html">There are two functions</a></li>
<li><a href="../321294/index.html">Browser Fingerprint - anonymous browser identification</a></li>
<li><a href="../321298/index.html">Free IOT & GPS service VIALATM</a></li>
<li><a href="../321302/index.html">How to remotely and centrally manage patches and software updates in the company</a></li>
<li><a href="../321304/index.html">Neurostream - a new chip for deep learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>