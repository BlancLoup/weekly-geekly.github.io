<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Russian Code Cup 2012: Analysis of the tasks of the third qualifying round</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The last qualifying round of the Russian Code Cup is over . In the semi-finals, in the qualifying round, passed the best 600 participants. On June 16t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Russian Code Cup 2012: Analysis of the tasks of the third qualifying round</h1><div class="post__text post__text-html js-mediator-article">  The last qualifying round of the <a href="http://russiancodecup.ru/">Russian Code Cup is over</a> .  In the semi-finals, in the qualifying round, passed the best 600 participants.  <nobr>On</nobr> June <nobr>16th</nobr> we will watch the battle of the minds, fifty winners will go to the final, where 18 thousand dollars will be played. <br><br> <a href="http://russiancodecup.ru/round/8/"><img src="http://russiancodecup.ru/images/RCC_logo_blue.jpg"></a> <br><br>  In this article I will examine in detail the tasks that were proposed for the <a href="http://russiancodecup.ru/round/8/tasks/">third qualification</a> .  This material should be useful both for those who make the first steps in sports programming, and for participants who could not solve all five problems.  Also welcome to the previous two tests: from the <a href="http://habrahabr.ru/company/mailru/blog/144793/">first</a> and <a href="http://habrahabr.ru/company/mailru/blog/145262/">second</a> qualifications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A great problem with counting the minimum amount of negativity per employee from visitors in the queue, about watches filled with paint, about a chocolate bar that was not eaten by someone - I will try to share with you the pleasure of analyzing these wonderful tasks. <br><br>  The tasks of the qualifying round will be much more complicated and even more interesting.  Come "cheer" <nobr>on</nobr> June <nobr>16</nobr> at 11:00 on the site RussianCodeCup.Ru. <br><br><a name="habracut"></a><br><br><h1>  "Chocolate" </h1>  In the Chocolate task, it was necessary to determine whether it was possible to assemble a whole from the two halves of a square chocolate.  A progressive ‚Äúsweep‚Äù is applied to the entrance - the width in segments alternately of the left half and the right half of each ‚Äúline‚Äù.  It is necessary to give an answer whether there are any missing segments: ‚Äúyes‚Äù means that such a thing was discovered, and ‚Äúno‚Äù if everything is in order.  Detailed statement of the problem, see the official site of <a href="http://russiancodecup.ru/round/8/">RussianCodeCup.ru</a> <br><br>  It is obvious that if any pair of ‚Äúwidth of the left half‚Äù - ‚Äúwidth of the right half‚Äù together does not give n - the width of the chocolate bar, we write ‚Äúyes‚Äù. <br><br>  As in the first two qualifications, the first task was the simplest one and it needed to be done as quickly as possible and on the first attempt.  The best result for Gennady Korotkevich - 1 minute 40 seconds since the start of the tour.  This time was enough to grasp the task, write and test the program and send it to the server. <br><br><h1>  "A game" </h1>  According to the condition of the problem, it is necessary to find a winner in a simple game in which players alternately move one piece along an infinite field.  It is necessary, according to the known coordinates of the initial position and the target where the figure is to be brought, as well as a numerical parameter relating to the range of the figure, to report the outcome of the game and the number of the course at which the game ends and whose turn was last, or to bring Infinity, Players can play indefinitely ... For a detailed task, see the official site of <a href="http://russiancodecup.ru/round/8/">RussianCodeCup.ru</a> <br><br>  Obviously, the easiest option is when the game ends in one move of the first player - when the goal and the starting position are at a distance less than or equal to the specified stroke range. <br><br>  The key solution to this problem is to prove that in all other cases, players can play indefinitely if none of them makes the wrong moves.  Otherwise, the first move cannot win the first move, because on every move of the first the second can return a piece back so as not to lose.  The second cannot win either, because for every move of the second, the first one can return the second in place so as not to lose. <br><br><br>  As a result, the solution of the problem turns out to be extremely simple - to display the victory of the first player in one move, if the distance between the points is less than or equal to the specified stroke range, and to output ‚ÄúInfinity‚Äù in other cases. <br><br><h1>  "Clock" </h1>  In the task it is necessary to find the number of different positions of the hands at the time of stopping the clock.  According to the condition, the dial can be opened only partially, and if one of the hands or both hands hit the open sector at the time of stopping, their position becomes known, but the number of possible options is narrowed.  It is also known that the positions of the hour and minute hands, as in the real clock, are directly dependent on each other.  Required to find the number of options arrows.  Full formulation of the problem with all the details is available on the site <a href="http://russiancodecup.ru/round/8/tasks">RussianCodeCup.ru</a> <br><br>  To begin, prepare a set of values ‚Äã‚Äãof the positions of the minute hand. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { //     , //       mins = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[<span class="hljs-number"><span class="hljs-number">60</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">60</span></span>; i++) mins[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,       () mins = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[]{m}; }</code> </pre> <br>  Similarly, we do with the clock hand: <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h == <span class="hljs-number"><span class="hljs-number">-1</span></span>) {//     , //       hours = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[<span class="hljs-number"><span class="hljs-number">12</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; i++) hours[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,       () hours = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[]{h}; }</code> </pre><br><br>  Next we go through the whole product of these sets and check the correctness of the position of the arrows relative to each other. <br><br><table><tbody><tr><td>  Minute hand </td><td>  0-11 </td><td>  12-23 </td><td>  24-35 </td><td>  36-47 </td><td>  48-59 </td></tr><tr><td>  Hour hand <br>  (in min. divisions) </td><td>  5 * h + 1 </td><td>  5 * h + 2 </td><td>  5 * h + 3 </td><td>  5 * h + 4 </td><td>  5 * h + 5 </td></tr><tr><td></td><td colspan="5" align="center">  5 * h + int (m / 12) </td></tr></tbody></table><br><br><br>  The formula for checking the correctness of the situation is simple - 5 * h + mm / 12. <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int hh : hours) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int mm : mins) {<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       int hhh = hh; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> hhh ‚Äì       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hours.length != <span class="hljs-number"><span class="hljs-number">1</span></span>) hhh = hhh * <span class="hljs-number"><span class="hljs-number">5</span></span> + mm / <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         /<span class="hljs-regexp"><span class="hljs-regexp">/  check .  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ a =      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ b =      ans += check(a, b, hhh, mm, h == -1, m == -1) ? 1 : 0; } }</span></span></code> </pre><br><br>  The auxiliary check function checks whether the mutual position of the minute and hour hands can exist and whether the positions of the arrows correspond to their visibility. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> a, <span class="hljs-type"><span class="hljs-type">int</span></span> b, <span class="hljs-type"><span class="hljs-type">int</span></span> hh, <span class="hljs-type"><span class="hljs-type">int</span></span> mm, <span class="hljs-type"><span class="hljs-type">boolean</span></span> hInside, <span class="hljs-type"><span class="hljs-type">boolean</span></span> mInside) { // a =      // b =      // hh =       // mm =    // hInside =     // mInside =     <span class="hljs-type"><span class="hljs-type">boolean</span></span> hOk = inside(a, b, hh) ^ hInside; <span class="hljs-type"><span class="hljs-type">boolean</span></span> mOk = inside(a, b, mm) ^ mInside; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hOk &amp;&amp; mOk &amp;&amp; (hh % <span class="hljs-number"><span class="hljs-number">5</span></span> == mm / <span class="hljs-number"><span class="hljs-number">12</span></span>); } // ,    m   a,b <span class="hljs-type"><span class="hljs-type">boolean</span></span> inside(<span class="hljs-type"><span class="hljs-type">int</span></span> a, <span class="hljs-type"><span class="hljs-type">int</span></span> b, <span class="hljs-type"><span class="hljs-type">int</span></span> m) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt;= b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt;= m &amp;&amp; m &lt;= b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inside(a, <span class="hljs-number"><span class="hljs-number">59</span></span>, m) || inside(<span class="hljs-number"><span class="hljs-number">0</span></span>, b, m); }</code> </pre><br><br><h1>  GAS "Queue" </h1>  The condition of this task is to bring it here in full: <br><br><blockquote>  <i>‚ÄúOver the past few years, electronic queues have become part of everyday life.</i>  <i>In many public institutions you can find a terminal printing a piece of paper with a number, and without asking the usual question ‚ÄúWho is the last?‚Äù, Visitors will use the electronic scoreboard to find out how long they will have to wait and when their turn will come.</i> <br><br>  <i>However, while such systems are far from perfect.</i>  <i>For example, the standard principle of any queue raises questions: "The one who first arrived is served first."</i>  <i>In the development of innovative GAS "Queue", it was decided to make it such that the implementation of this principle is not required.</i>  <i>Instead, the new system is designed to minimize the amount of negative attributable to the official, at the reception to which people stand in line.</i> <br><br>  <i>It is known that every person has such a criterion as irritability.</i>  <i>If this parameter is equal to w, then after t hours of waiting in the queue this person will bring down on the head of the official exactly wt units of anger and abuse.</i>  <i>So, if a visitor is served immediately after his arrival, the official will not suffer, and if the visitor arrives at the beginning of the third hour, and his service started only at the beginning of the fifth hour, the amount of anger will be 2w.</i> <br><br>  <i>It is also known that the service of each visitor takes exactly one hour, and each visitor comes at the beginning of an hour.</i>  <i>Your task is to determine, according to the indices of irritability and the arrival times of visitors, how much negativity the official will receive in the optimal order of customer service.</i> <br><br>  <i>The first line contains a single integer t - the number of cases that you have to handle.</i>  <i>Further t descriptions of cases follow.</i> <br><br>  <i>The description of each case consists of: the number n in the first line - the number of visitors, and n descriptions of the visitors themselves.</i>  <i>For each visitor there are two integers ri and wi (1 ‚â§ ri, wi ‚â§ 106) in the separate line - the number of the hour at the beginning of which the visitor came, and his irritability coefficient, respectively.</i> <br><br>  <i>The total number of visitors in all cases of a single test does not exceed 1,000,000.</i> <br></blockquote><br><br>  For each case, in a separate line, you should output the answer - the minimum total amount of negative that the official will receive. " <br><br>  One of the examples to the problem demonstrates the described principle.  In the example three officials came to the official.  Two of them - at the beginning of the first hour with irritability "3" and "4", respectively.  And one more - at the beginning of the second hour with irritability "5."  It takes an hour to serve everyone, therefore at the beginning of the first hour there are two options - to let the visitor forward with irritability ‚Äú4‚Äù or visitor with irritability ‚Äú3‚Äù.  Those who are not missed, go to the next hour, where another ‚Äú5‚Äù visitor is added, and there appear two more options - to skip the beginner, or who is standing in line. <br><br><table><tbody><tr><td></td><td>  Annoyance <br>  comers </td><td>  Option 1 </td><td>  Option 2 </td><td>  Option 3 </td><td>  Option 4 </td></tr><tr><td>  Beginning <nobr>of the 1st</nobr> hour </td><td>  3, 4 </td><td>  P (3), RF = 0 </td><td>  P (3), RF = 0 </td><td>  P (4), RF = 0 </td><td>  P (4), RF = 0 </td></tr><tr><td>  Beginning <nobr>of the 2nd</nobr> hour </td><td>  five </td><td>  P (4), RF = 4 √ó 1 = 4 </td><td>  P (5), RF = 4 √ó 1 = 4 </td><td>  P (3), RF = 3 √ó 1 = 3 </td><td>  P (5), RF = 3 √ó 1 = 3 </td></tr><tr><td>  Beginning <nobr>of the 3rd</nobr> hour </td><td>  - </td><td>  P (5), RF = 4 + 5 = 9 </td><td>  P (4), RF = 4 √ó 2 = 8 </td><td>  P (5), RF = 3 + 5 = 8 </td><td>  P (3), RF = 3 √ó 2 = 6 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>  MINIMUM </td></tr></tbody></table><br><br>  For two hours, the official receives minimal irritability 6. <br><br>  The algorithm that solves this problem is quite simple, if one guesses the fact that at each moment in time it is most advantageous to serve a person who has already arrived at this point, not yet served, and the irritability of which is no less than that of the rest of the same people. <br><br>  We prove this statement.  Suppose we have a schedule, built on this rule and some optimal schedule.  Consider the first time instant t <sub>1</sub> , in which they differ.  Let the person, who at this moment is served in the optimal schedule, has irritability w <sub>1</sub> , and the person who is served at this moment in the second - irritability w <sub>2</sub> .  In the optimal schedule, this person is served at some time point t <sub>2</sub> , and t <sub>2</sub> &gt; t <sub>1</sub> (after all, before the time t <sub>1, the</sub> schedules were the same).  So, if in the optimal schedule you swap these two people, which can obviously be done, as at the time t <sub>1</sub> and at the time t <sub>2</sub> they are both available (since both schedules are valid), then the total anger in the optimal schedule changes to (t <sub>2</sub> - t <sub>1</sub> ) √ó w <sub>1</sub> + (t <sub>1</sub> - t <sub>2</sub> ) √ó w <sub>2</sub> , which is equal to (t <sub>2</sub> - t <sub>1</sub> ) √ó (w <sub>1</sub> - w <sub>2</sub> ). <br><br>  Since t <sub>2</sub> &gt; t <sub>1</sub> (as mentioned above), and w <sub>2</sub> &gt; w <sub>1</sub> (by building the study schedule), the indicated amount of anger change will be negative, which means that the optimal schedule has improved.  Obviously, such reasoning for all other discrepancies will lead to the fact that the queue algorithm described above is correct. <br><br>  Now you can think about the implementation of the solution described.  We need a data structure in which all people who have already arrived, but not yet served, will be stored, and from which it would be possible to extract the maximum element in a small amount of time (a person whose irritability is no less than the rest).  This structure is a priority queue.  When implementing it, for example, using a binary heap, operations will be performed in O (log n), and the total asymptotic operating time of the solution will be O (n log n). <br><br>  In Java and C ++, for example, the priority queue is implemented as the PriorityQueue and priority_queue classes, respectively.  But for completeness, you should tell what it is for those who do not know. <br>  The priority queue allows you to store pairs (key, value) and supports operations to add a pair, quickly find a pair with a minimum or maximum key, and retrieve such a pair.  The binary heap is an effective and optimal way to implement this structure. <br><br>  Binary heap with maximum accumulation is realized through a binary tree, in which any descendant node cannot be larger than its ancestor node, that is, the root is always the maximum, therefore getting it very quickly.  Adding a new pair is made to any free end node (sheet), after which it moves towards the root, while the value of the ancestor is less than the value of the newly added key. <br><br>  You can get acquainted with this algorithm in details here: <a href="">http://www.rsdn.ru/article/submit/heap/heaps.xml#EKLAC</a> <br><br><h1>  "Interference" </h1>  In this task, it was necessary to write an algorithm for recovering corrupted data (a set of messages of 34 bits) using known polynomial hashes.  You must restore the message that is different from the original in the least number of bits that have the same hash. <br><br>  For a detailed statement of the problem, see <a href="http://russiancodecup.ru/round/8/tasks">RussianCodeCup.ru.</a> <br><br>  It will take too much time to iterate through all the <nobr>34-bit</nobr> numbers - which is 17 billion values.  To optimize the brute force, they use a method called meeting in the middle (meet-in-the-middle). <br><br>  The concept of meet-in-the-middle involves splitting the task in half and solving the ‚Äúbig task‚Äù through partial calculation for the halves.  The classic problem solved by such an approach is the problem of the most efficient packing of a backpack.  Each item is characterized by weight and value, you need to pack things with a maximum total value in a backpack with a weight limit.  To solve it, a large set of things N is divided into two equal (or approximately equal) subsets, for which you can go through all the options in a reasonable time, and calculate the total weight and value for each, and then for each group from the first subset, find the group from the second maximum value at which the total weight will fit into the restrictions. <br><br>  In our case, you need to calculate the hashes for the first n / 2 bits and separately for all possible options for nn / 2 bits.  In each half, a maximum of 2 <sup>17</sup> = 131072 options is obtained. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> m = (len + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; //  √≥  Pair[] h1 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Pair[<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; m]; //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; h1.length; i++) { h1[i] = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Pair(i, countHash(i)); //     } Pair[] h2 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Pair[<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (len ‚Äì m)]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; h2.length; i++) { h2[i] = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Pair(i, countHash(((<span class="hljs-number"><span class="hljs-number">0</span></span>L + i) &lt;&lt; m))); //   }</code> </pre><br><br>  Since we need to get a message with a fixed known hash h, then each variant of the hash value for the first half of the bits h <sub>1</sub> matches not more than one hash value for the second half of the bits h <sub>2</sub> such that h = (h <sub>1</sub> + h <sub>2</sub> ) mod M . <br><br>  It remains to learn for each variant h <sub>1 to</sub> quickly find the corresponding value of h <sub>2</sub> .  To do this, you can use data structures such as set in C ++ or TreeSet and HashSet in Java. <br><br>  You can also sort all possible hash values ‚Äã‚Äãfor the first and second half in ascending order and use the idea of ‚Äã‚Äã‚Äútwo pointers‚Äù. <br><br>  We will move the first pointer i through the hashes for the first half in ascending order of values.  In the second half, we will search for the corresponding hash, starting from the previous suitable value, moving the second pointer j along the hashes for the second half in descending order of values.  At that moment, when the pointer j reaches the minimum value, it will need to be moved to the maximum value.  But, this will happen no more than once, therefore, the total pointer j will pass no more than two times over all values. <br><br>  And, finally, it is necessary to choose from all the found pairs of suitable values ‚Äã‚Äãof h <sub>1</sub> and h <sub>2 the</sub> one in which the minimum number of bits has changed compared with the received message m. <br><br><ul><li>  <a href="http://habrahabr.ru/company/mailru/blog/144793/">Analysis of tasks from the first qualification</a> </li><li>  <a href="http://habrahabr.ru/company/mailru/blog/145262/">Analysis of tasks from the second qualification</a> </li></ul><br><br>  <i>Aliyev Rauf,</i> <i><br></i>  <i>Director of Research and Education</i> <i><br></i>  <i>Mail.Ru Group</i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/145735/">https://habr.com/ru/post/145735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145729/index.html">How to save on printing costs automatically</a></li>
<li><a href="../145730/index.html">Retina MacBook Pro: First Analysis</a></li>
<li><a href="../145732/index.html">Science</a></li>
<li><a href="../145733/index.html">About the stupidity of smart people</a></li>
<li><a href="../145734/index.html">Replication from OLTP to OLAP database</a></li>
<li><a href="../145737/index.html">Why information technology needs linguists?</a></li>
<li><a href="../145738/index.html">1930 applications for new top-level domains have been submitted - a full list has been published on ICANN</a></li>
<li><a href="../145740/index.html">UniSender launched the functionality of split-testing mailings</a></li>
<li><a href="../145741/index.html">Sasha will help American users</a></li>
<li><a href="../145742/index.html">Hadron Collider, ten-point wind and switches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>