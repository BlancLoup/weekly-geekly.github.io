<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microsoft opened the source Xamarin.Forms. We could not miss the chance to check them with PVS-Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, as you probably know, Microsoft bought Xamarin. Even though Microsoft recently began to gradually open the source codes of its produc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microsoft opened the source Xamarin.Forms. We could not miss the chance to check them with PVS-Studio</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/fed/94d/6fd/fed94d6fd1754fef85e19a2871ddc6bf.png"></div><br>  Not so long ago, as you probably know, Microsoft bought Xamarin.  Even though Microsoft recently began to gradually open the source codes of its products, the opening of the Xamarin.Forms code was a big surprise.  I could not get past such an event, and decided to check the source code of this project using a static code analyzer. <br><br><a name="habracut"></a><br><h2>  Analyzed project </h2><br>  <a href="https://www.xamarin.com/forms">Xamarin.Forms</a> is a cross-platform toolkit that allows you to create user interfaces that are common to different platforms: Windows, Windows Phone, iOS, Android.  User interfaces are drawn using the native components of the target platform, which allows applications created using Xamarin.Forms to save the overall look for each platform.  To create user interfaces with data bindings and different styles, you can use C # or XAML markup. <br><br><p><img src="https://habrastorage.org/files/d33/3db/b37/d333dbb370334b92915258fb798144b1.png"></p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The code for the framework itself is also written in C # and is available in the <a href="https://github.com/xamarin/Xamarin.Forms">repository on GitHub</a> . <br><br><h2>  Analysis tool </h2><br>  The project was tested with the help of the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static code analyzer, in the development of which I take an active part.  We are constantly working to improve it, including modifying the existing ones and adding new diagnostic rules.  Therefore, with each test of a new project, we manage to identify more and more varieties of errors. <br><br><p><img src="https://habrastorage.org/files/7e2/e99/bf0/7e2e99bf0efc413c920532889fc87d79.png"></p><br><br>  Each diagnostic rule contains <a href="http://www.viva64.com/ru/d/0368/">documentation</a> that includes a description of the error, as well as examples of incorrect and correct code.  You can download a trial version of the analyzer by the <a href="http://www.viva64.com/ru/pvs-studio-download/">link</a> .  I also suggest to get acquainted with the <a href="http://www.viva64.com/ru/b/0395/">note</a> that my colleague recently wrote.  She explains why these are just the limitations of the demo version and what should be done to try all the functionality.  For those who are too lazy to read, I will prompt you right away - just <a href="http://www.viva64.com/ru/about-feedback/">write to</a> us. <br><br>  <b>PS</b> In addition, the site has a <a href="http://www.viva64.com/ru/examples/">database of errors</a> found in open source projects, and a <a href="http://www.viva64.com/ru/b/">catalog of articles</a> (on checking open source projects, technical issues, and others).  I recommend to get acquainted. <br><br><h2>  Suspicious code snippets </h2><br>  Let's start with the "classic" errors detected by the diagnostic rule V3001: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RwWait = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RwWrite = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RwRead = <span class="hljs-number"><span class="hljs-number">4</span></span>; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Interlocked.Add(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _rwlock, RwRead) &amp; (RwWait | RwWait)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0381/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions "RwWait"  operator.  SplitOrderedList.cs 458 <br><br>  As can be seen from the code, the value of an expression is calculated using bit operations.  In this case, in one of the subexpressions - <i>RwWait |</i>  <i>RwWait</i> share the same constant fields.  This makes no sense.  At the same time, it is clear that the set of constants declared above has values ‚Äã‚Äãequal to powers of two, therefore, they were meant to be used as flags (which we see in the example of using bit operations).  I think it would be more practical to put them in the enumeration marked with the attribute [Flags], which would give a number of advantages when working with this enumeration (see <a href="http://www.viva64.com/ru/d/0467/">documentation V3059</a> ). <br><br>  As for the current example, the use of the <i>RwWrite</i> constant was most likely implied.  This can be attributed to one of the cons of IntelliSense - despite the fact that this tool helps a lot in writing code, it can sometimes ‚Äúprompt‚Äù the wrong variable, which can make a mistake by inattention. <br><br>  The following code example where a similar error was made: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Left { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Top { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Bottom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsDefault { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Left == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Top == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Right == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Left == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0381/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are the "Left &amp; Down" operator.  Thickness.cs 29 <br><br>  In the expression 2 times the subexpression <i>Left == 0 is found</i> .  Obviously, this is a mistake.  In place of the last subexpression, the following code should be placed - <i>Bottom == 0</i> , since this is the only property (following logic and based on a set of properties) that is not checked in this expression. <br><br>  The following error is interesting in that it is in two files with the same name and partially similar code.  And so it turns out that errors multiply - made a mistake in one place, copied this code to another - op!  - here is another wrong place for you. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> SizeRequest </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDesiredSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthConstraint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightConstraint</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = widthConstraint; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widthConstraint &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) width = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Context.GetThemeAttributeDp(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::Android .Resource .Attribute .SwitchMinWidth); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widthConstraint &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) width = <span class="hljs-number"><span class="hljs-number">100</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0382/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0382/">V3003</a> The use of if (A) {...} else if (A) {...} 'pattern was detected.  There is a possibility of logical error presence.  Check lines: 28, 30. Xamarin.Forms.Platform.Android SwitchRenderer.cs 28 <br><br>  In this code snippet, there is strange logic in the <i>if statement</i> .  Some condition is checked ( <i>widthConstraint &lt;= 0</i> ) and, if it is not met, the same condition is checked again.  Mistake?  Mistake.  But how to fix, is more difficult to say.  This task already falls on the shoulders of the programmer who wrote the code. <br><br>  As I said, there was exactly the same error in the file with the same name.  Here is the corresponding analyzer message: V3003 The use of if (A) {...} else if (A) {...} 'pattern was detected.  There is a possibility of logical error presence.  Check lines: 26, 28. Xamarin.Forms.Platform.Android SwitchRenderer.cs 26 <br><br>  Thanks to the mechanism of <a href="http://www.viva64.com/ru/b/0394/">virtual values,</a> it was possible to significantly improve a number of diagnostic rules, including the diagnosis <a href="http://www.viva64.com/ru/d/0391/">V3022</a> , which determines that the expression is always <i>true</i> or <i>false</i> .  I propose to look at a few examples that were found with its help: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TypeReference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolveWithContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TypeReference type</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (genericParameter.Owner.GenericParameterType == GenericParameterType.Type) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TypeArguments[genericParameter.Position]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> genericParameter.Owner.GenericParameterType == GenericParameterType.Type ? UnresolvedGenericTypeParameter : UnresolvedGenericMethodParameter; .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0391/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression 'genericParameter.Owner.GenericParameterType == GenericParameterType.Type' is always false.  ICSharpCode.Decompiler TypesHierarchyHelpers.cs 441 <br><br>  Despite the fact that I deleted that part of the method that does not interest us, even now the error may not be too noticeable.  To remedy this situation, I propose to simplify the code a little more by rewriting it with shorter variable names: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == enVal) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a == enVal ? c : d;</code> </pre> <br>  Now everything has become somewhat clearer.  The source of the problem is the second check <i>a == enVal (genericParameter.Owner.GenericParameterType == GenericParameterType.Type)</i> located in the ternary operator.  The ternary operator in the <i>else-</i> branch of the <i>if</i> operator is meaningless - in this case, the method will always return the value <i>d</i> ( <i>UnresolvedGenericMethodParameter</i> ). <br><br>  If you have not guessed what the problem is - I explain.  If the program reaches the calculation of the value of the ternary operator, it is already known that the expression <i>a == enVal</i> is <i>false</i> , therefore, in the ternary operator it will have the same value.  The bottom line: the result of the ternary operator is always the same.  A mistake. <br><br>  Immediately it is difficult to detect such defects, because even cutting out the extra code from the method, the error is cleverly concealed in the rest.  I had to resort to additional simplifications in order to reveal this ‚Äúpitfall‚Äù.  However, there is no such problem for the analyzer, and he easily coped with the task. <br><br>  Of course, this is not the only such case.  Here is another one: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TypeReference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoInferTypeForExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ILExpression expr, TypeReference expectedType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forceInferChildren = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forceInferChildren) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forceInferChildren) { InferTypeForExpression(expr.Arguments.Single(), lengthType); } } .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0391/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression 'forceInferChildren' is always true.  ICSharpCode.Decompiler TypeAnalysis.cs 632 <br><br>  Again, in order to more easily notice the catch, cut out all the extra code.  And here it is - the <i>forceInferChildren</i> condition is checked 2 times, while this variable is not used between <i>if statements</i> .  If we consider that this is a parameter of the method, we can conclude that neither other threads nor any methods can change it without direct reference.  Therefore, if the first <i>if statement</i> is executed, the second one will always be executed.  Strange logic. <br><br>  There is a diagnosis similar to the V3022 - V3063.  This diagnostic rule determines that a part of a conditional expression is always true or false.  Thanks to her, she managed to find some interesting code fragments: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BindableProperty </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBindableProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type elementType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> localName, IXmlLineInfo lineInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> throwOnError = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { .... Exception exception = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; bindableFieldInfo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XamlParseException( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"BindableProperty {0} not found on {1}"</span></span>, localName + <span class="hljs-string"><span class="hljs-string">"Property"</span></span>, elementType.Name), lineInfo); } .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0461/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0461/">V3063</a> A part of conditional expression is always true: exception == null.  Xamarin.Forms.Xaml ApplyPropertiesVisitor.cs 280 <br><br>  We are interested in the subexpression <i>exception == null</i> .  Obviously, it will always be <i>true</i> .  Why then this check?  It is not clear.  By the way, there are no comments that signal in some way that the value can be changed during the debugging process (like <i>// new Exception ();</i> ). <br><br>  These are not the only suspicious sites found by diagnostic rules V3022 and V3063.  But let's not dwell on them, but let's see what else we managed to find interesting. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteSecurityDeclarationArgument</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CustomAttributeNamedArgument na</span></span></span><span class="hljs-function">)</span></span> { .... output.Write(<span class="hljs-string"><span class="hljs-string">"string('{0}')"</span></span>, NRefactory.CSharp .TextWriterTokenWriter .ConvertString( (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)na.Argument.Value).Replace(<span class="hljs-string"><span class="hljs-string">"'"</span></span>, <span class="hljs-string"><span class="hljs-string">"\'"</span></span>)); .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0423/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0423/">V3038</a> The first argument of 'Replace' function is equal to the second argument.  ICSharpCode.Decompiler ReflectionDisassembler.cs 349 <br><br>  From this code, we are interested in the <i>Replace</i> method, called for some string.  Apparently, the programmer wanted to replace all <i>single quote</i> characters with the <i>slash and quotation marks</i> .  But the fact is that in the second case, the slash character is escaped, so the call to this method replaces the single quote with it.  Do not believe?  <i>Equals ("'", "\'")</i> to help.  For some, this may not be obvious, but not for the analyzer.  To avoid escaping, you can use the <i>@</i> character in front of a string literal.  Then the correct call to the <i>Replace</i> method would look like this: <br><pre> <code class="cs hljs">Replace(<span class="hljs-string"><span class="hljs-string">"'"</span></span>, <span class="hljs-string"><span class="hljs-string">@"\'"</span></span>)</code> </pre> <br>  There were methods that always return the same value.  For example: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unprocessed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; extra, Option def, OptionContext c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (def == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/ru/d/0387/">V3009</a> This is the same as the value of 'false'.  Xamarin.Forms.UITest.TestCloud OptionSet.cs 239 <br><br>  No matter what arguments come in and what is executed in this method, it always returns <i>false.</i>  Agree, it looks like something strange. <br><br>  By the way, this code met again - the method was copied completely and moved to another place.  Analyzer Message: V3009 This is the same as the value of 'false'.  Xamarin.Forms.Xaml.Xamlg Options.cs 1020 <br><br>  We met several code fragments with the repeated generation of an exception, potentially containing errors. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Stream&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStreamAsync</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Uri uri, CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay (<span class="hljs-number"><span class="hljs-number">5000</span></span>, cancellationToken); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException ex) { cancelled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; } .... }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0456/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0456/">V3052</a> The original exception object 'ex' was swallowed.  Stack of original exception could be lost.  Xamarin.Forms.Core.UnitTests ImageTests.cs 221 <br><br>  It would seem the logic is simple.  In case of an exception, we perform some actions and re-generate it.  But the devil is in the details.  In this case, when re-generating an exception, the original exception stack is completely ‚Äúoverwritten‚Äù.  To avoid this, you do not need to re-generate the same exception; it is enough to ‚Äúflip‚Äù an existing one by calling the <i>throw</i> operator.  Then the <i>catch</i> block code might look like this: <br><pre> <code class="cs hljs">cancelled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>;</code> </pre><br>  A similar example: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ValueNode node, INode parentNode</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ArgumentException ae) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ae.ParamName != <span class="hljs-string"><span class="hljs-string">"name"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ae; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XamlParseException( <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"An element with the name \"{0}\" already exists in this NameScope"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)node.Value), node); } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0456/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0456/">V3052</a> The original exception object 'ae' was swallowed.  Stack of original exception could be lost.  Xamarin.Forms.Xaml RegisterXNamesVisitor.cs 38 <br><br>  In both cases, information about the previous exception is lost.  And if in the second case, it can still be assumed that this information will not be relevant (although it is still strange), then in the first case it is unlikely that they most likely wanted to throw the exception up, but instead generated a new one.  The solution is the same as in the previous example - calling the <i>throw</i> operator without any arguments. <br><br>  At the expense of the next fragment - I will not undertake to say for sure whether it is a mistake or not, but it looks strange. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTitle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Element?.Detail == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; ((ITitleProvider)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).Title = (Element.Detail <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavigationPage) ?.CurrentPage?.Title ?? Element.Title ?? Element?.Title; }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/ru/d/0427/">warning</a> <b>:</b> <a href="http://www.viva64.com/ru/d/0427/">V3042</a> Possible NullReferenceException.  The '?.'  and '.'  Xamarin.Forms.Platform.WinRT MasterDetailPageRenderer.cs 288 <br><br>  The analyzer was alarmed by the fact that the <i>Title</i> property is accessed in several ways - <i>Element.Title</i> and <i>Element? .Title</i> , and first are accessed directly and then using a null-conditional operator.  But everything is not so simple. <br><br>  As you can see, at the beginning of the method, the <i>Element</i> is checked <i>? .Detail == null</i> , assuming that if <i>Element == null</i> , then the output will be realized here and it will not get to further operations. <br><br>  At the same time, the expression <i>Element? .Title</i> assumes that at the time of its execution the <i>Element</i> may be <i>null</i> .  If this is the case, then at the previous stage, when the <i>Title</i> property is directly <i>accessed</i> , an exception of the <i>NullReferenceException</i> type will be generated, and therefore there is no point in using the null-conditional operator. <br><br>  In any case, this code looks very strange and needs to be fixed. <br><br>  It looked weird when the object was cast to its own type.  Here is an example of such a code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FormsPivot Control { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } Brush ITitleProvider.BarBackgroundBrush { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { (Control <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FormsPivot).ToolbarBackground = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br>  <b>PVS-Studio</b> <a href="http://www.viva64.com/en/d/0455/">warning</a> <b>:</b> <a href="http://www.viva64.com/en/d/0455/">V3051</a> An type cast.  The object is already of the 'FormsPivot' type.  Xamarin.Forms.Platform.UAP TabbedPageRenderer.cs 73 <br><br>  In this case, this is not an error, but the code looks at least suspicious, given that the <i>Control</i> object already has the type <i>FormsPivot.</i>  By the way, this is not the only warning of this kind; others have also met: <ul><li>  V3051 An excessive type cast.  The object is already of the 'FormsPivot' type.  Xamarin.Forms.Platform.UAP TabbedPageRenderer.cs 78 </li><li>  V3051 An excessive type cast.  The object is already of the 'FormsPivot' type.  Xamarin.Forms.Platform.UAP TabbedPageRenderer.cs 282 </li><li>  V3051 An excessive type cast.  The object is already of the 'FormsPivot' type.  Xamarin.Forms.Platform.WinRT.Phone TabbedPageRenderer.cs 175 </li><li>  V3051 An excessive type cast.  The object is already of the 'FormsPivot' type.  Xamarin.Forms.Platform.WinRT.Phone TabbedPageRenderer.cs 197 </li><li>  V3051 An excessive type cast.  The object is already of the 'FormsPivot' type.  Xamarin.Forms.Platform.WinRT.Phone TabbedPageRenderer.cs 205 </li></ul><br>  There are conditions that could be simplified.  An example of one of them: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LayoutSubviews</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_scroller == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || (_scroller != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; _scroller.Frame == Bounds)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio Warning:</b> <a href="http://www.viva64.com/en/d/0416/">V3031 Alert</a> can be simplified.  The '||'  operator is surrounded by opposite expressions.  Xamarin.Forms.Platform.iOS.Classic ContextActionCell.cs 102 <br><br>  This expression can be simplified by removing the <i>_scroller! = Null</i> subexpression.  It will be calculated only in the case when the expression to the left of the operator '||' is false.  - <i>_scroller == null</i> , therefore - <i>_scroller is</i> not <i>null</i> and you can be <i>safe</i> from <i>getting a NullReferenceException</i> exception.  Then the simplified code will look like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_scroller == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || _scroller.Frame == Bounds))</code> </pre> <br><h2>  A spoon of tar </h2><br>  Unfortunately, it was not possible to assemble the solution completely - about 6 projects remained untested, and those places where classes of them were somehow used were not subjected to such careful analysis as they could.  Perhaps they could have found something else interesting, but, alas. <br><br>  By the way, you can learn about the problems with the analysis of the message <a href="http://www.viva64.com/ru/d/0476/">V051</a> , located at level 3.  The presence of such warnings, as a rule, is a signal that the C # project contains some kind of compilation errors, which is why the analyzer cannot get all the information necessary for conducting a complex analysis.  However, he will try to perform checks for which detailed information on types and objects is not needed. <br><br>  When checking the project, it is advisable to make sure that you do not have warnings V051.  And if they are still there - try to get rid of them (check that the project is compiled, make sure that all dependencies are loaded). <br><br><h2>  Conclusion </h2><br><p><img src="https://habrastorage.org/files/77e/955/805/77e955805f254cf7854b248e6b204a97.png"></p><br><br>  Checking Xamarin.Forms proved itself - there were various interesting places, both clearly erroneous, and very suspicious or strange.  I hope the developers will not bypass the article and correct the fragments of code written here.  All suspicious places that could be detected can be viewed by downloading a trial <a href="http://www.viva64.com/ru/pvs-studio-download/">version of the analyzer</a> .  The introduction of PVS-Studio on an ongoing basis will be even better and more correct, which will allow detecting and correcting errors immediately after they appear. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0400/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev.  <a href="http://www.viva64.com/en/b/0400/">Microsoft opened the source code of Xamarin.Forms.</a>  <a href="http://www.viva64.com/en/b/0400/">We couldn‚Äôt miss a chance to check it with PVS-Studio</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/301606/">https://habr.com/ru/post/301606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301594/index.html">Lint CSS using stylelint</a></li>
<li><a href="../301598/index.html">TV countdown timer on AVR microcontroller</a></li>
<li><a href="../301600/index.html">Swift present and future: questions for adults</a></li>
<li><a href="../301602/index.html">Expensive futility of ‚Äúloyalty programs‚Äù</a></li>
<li><a href="../301604/index.html">5 mistakes to be avoided when creating micro-interactions</a></li>
<li><a href="../301610/index.html">VectorDrawable - Part Two</a></li>
<li><a href="../301614/index.html">Blockchain-based decentralized control</a></li>
<li><a href="../301616/index.html">Email marketing for cloud service</a></li>
<li><a href="../301618/index.html">Lean is a real topic, a buzzword or a natural opportunity to make money. Or at least not lose</a></li>
<li><a href="../301620/index.html">Optical Networks: A New Stage of Internet Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>