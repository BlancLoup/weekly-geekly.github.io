<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous ping with Boost.Asio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the steps to scan a node for vulnerabilities is to determine its network availability. As you know, this can be done in several ways, including...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous ping with Boost.Asio</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/pt/blog/156795/"><img src="https://habrastorage.org/storage2/3ae/9a5/cea/3ae9a5cea5218e7d5df657b27609377c.png" align="left"></a>  One of the steps to scan a node for vulnerabilities is to determine its network availability.  As you know, this can be done in several ways, including through the ping command. <br><br>  For one of the security analysis projects in an organization with a large number of workstations, we needed to develop our own pinger. <a name="habracut"></a><br><br>  The requirements of the technical specifications were as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  The number of simultaneously ping nodes should be large (several subnets). </li><li>  The number of ports is set by the user (maybe 65535). </li><li>  Pinger should not ‚Äúeat‚Äù all the time of the processor. </li><li>  Pinger must have high speed. </li></ol><br>  The ping method is set by the user, various methods are available (ICMP ping, TCP port ping and Resolve name).  Naturally, the first thought was to use a ready-made solution, for example, nmap, but it is heavy and unproductive on such ranges of nodes (ports). <br><br>  In order for the result to correspond to the TOR, all performed operations must be asynchronous and use a single pool of threads. <br><br>  The latter circumstance prompted us to choose the Boost.Asio library as a development tool, since it contains all the necessary asynchronous primitives. <br><br><h4>  Pinger implementation </h4><br>  The following hierarchy is implemented in the pinger‚Äôs work: <br>  The Ping class performs ping operations, getting a name, after the execution of tasks, a callback is initiated, to which the result is sent.  The Pinger class creates ping operations, initializes, places new requests in a queue, controls the number of threads and the number of simultaneously opened sockets, determines the availability of local ports. <br><br>  It is necessary to take into account the fact that the number of waiting sockets, and therefore simultaneously pinged ports, can go up to several thousand, while the processor load may be minimal if unavailable nodes (ports) are pinged. <br><br>  On the other hand, if available nodes (ports) are pinged, then several hundred active sockets significantly increase the load on the processor.  It turns out that the dependence of the processor load on the number of active sockets is nonlinear. <br><br>  For a balance between CPU resources and ping time, CPU utilization is used, based on which the number of active sockets is controlled. <br><br><h5>  Port Availability </h5><br>  On a machine that performs ping, the ports can be blocked by a firewall, so our pinger needed to implement a mechanism for determining the availability of local ports.  To determine the availability of the port, we are trying to connect to an invalid address: if successful, the port is emulated by a firewall. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PortState::<span class="hljs-function"><span class="hljs-function">Enum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ports::value_type port)</span></span></span><span class="hljs-function"> </span></span>{ boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_PortsMutex)</span></span></span></span>; PortState::Enum&amp; state = m_EnabledPorts[port]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == PortState::Unknown) { state = PortState::Pending; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> service = GetNextService(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SocketPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TCPSocket(GetService(service)))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TimerPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Timer(GetService(service)))</span></span></span></span>; socket-&gt;async_connect( Tcp::endpoint(Address(INVALID_IP), port), boost::bind( &amp;PingerImpl::GetPortStateCallback, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ba::placeholders::error, port, socket, timer ) ); timer-&gt;expires_from_now(boost::posix_time::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); timer-&gt;async_wait(boost::bind(&amp;PingerImpl::CancelConnect, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, socket)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortStateCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code&amp; e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ports::value_type port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SocketPtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TimerPtr)</span></span></span><span class="hljs-function"> </span></span>{ boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_PortsMutex)</span></span></span></span>; m_EnabledPorts[port] = e ? PortState::Enabled : PortState::Disabled; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CancelConnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SocketPtr socket)</span></span></span><span class="hljs-function"> </span></span>{ boost::system::error_code e; socket-&gt;close(e); }</code> </pre> <br>  During the ping process, it is often necessary to get the network host name, but unfortunately, the asynchronous version of <b>getnameinfo is</b> missing as such. <br><br>  In Boost.Asio, asynchronous name retrieval takes place in a background thread that is bound to the object <b>boost :: asio :: io_service</b> .  Thus, the number of background operations to get the name is equal to the number of objects <b>boost :: asio_io_service</b> .  To increase the speed of receiving names and ping as a whole, we create objects <b>boost :: asio :: io_service</b> by the number of threads in the pool, with each ping operation processed by its object. <br><br><h4>  Ping operation </h4><br><h5>  ICMP ping </h5><br>  It's pretty simple: raw sockets are used.  Based on the implementation of examples <a href="">boost.org</a> .  The code is quite simple and does not require special explanation. <br><br><h5>  TCP ping </h5><br>  It is an attempt to establish a TCP connection with a remote node for each port in the range.  If the connection attempt with at least one port of the remote node is successful, the node is considered available.  If it is not possible to establish a connection with any port, the number of asynchronous operations becomes zero and the ping object is destroyed.  In this case, the callback is executed in the ping destructor based on the results of the ping. <br><br>  The ping operation object exists as long as at least one asynchronous operation is performed, since the pointer <b>shared_from_this ()</b> is passed to each of them. <br><br>  The code that starts the TCP ping process: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTCPPing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span><span class="hljs-function"> override </span></span>{ boost::mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_DataMutex)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PingerLogic::IsCompleted() || m_Ports2Ping.empty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; Ports::const_iterator it = m_Ports2Ping.begin(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ports::const_iterator itEnd = m_Ports2Ping.end(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; it != itEnd; ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PortState::Enum state = m_Owner.GetPortState(*it); <span class="hljs-comment"><span class="hljs-comment">//      ‚Äî  if (state == PortState::Disabled) { it = m_Ports2Ping.erase(it); continue; } else if (state == PortState::Pending) //  ,      { ++it; continue; } if (m_Owner.CanAddSocket()) // ,        { PingPort(*it); it = m_Ports2Ping.erase(it); if (m_Ports2Ping.empty()) break; } else { break; } } if (!m_Ports2Ping.empty()) { //   ,     m_RestartPingTimer.expires_from_now(boost::posix_time::milliseconds(DELAY_IF_MAX_SOCKETS_REACHED)); m_RestartPingTimer.async_wait(boost::bind( &amp;Ping::StartTCPPing, shared_from_this(), timeout )); } //           m_StartTime = boost::posix_time::microsec_clock().local_time(); m_PingTimer.expires_from_now(boost::posix_time::seconds(timeout)); m_PingTimer.async_wait(boost::bind(&amp;Ping::OnTimeout, shared_from_this(), ba::placeholders::error, timeout)); }</span></span></code> </pre><br>  The code that starts the asynchronous connection: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PingPort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ports::value_type port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_Address, port)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SocketPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TCPSocket(m_Owner.GetService(m_ServiceIndex)))</span></span></span></span>; m_Sockets.push_back(socket); m_Owner.OnSocketCreated(); <span class="hljs-comment"><span class="hljs-comment">//     socket-&gt;async_connect(ep, boost::bind( &amp;Ping::TCPConnectCallback, shared_from_this(), boost::asio::placeholders::error, socket )); }</span></span></code> </pre> <br>  Callback: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCPConnectCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code&amp; e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SocketPtr socket)</span></span></span><span class="hljs-function"> </span></span>{ m_Owner.OnSocketClosed(); <span class="hljs-comment"><span class="hljs-comment">//     if (!e) TCPPingSucceeded(socket); else TCPPingFailed(socket); }</span></span></code> </pre><br>  Relevant Handlers: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCPPingSucceeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SocketPtr socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boost::posix_time::<span class="hljs-function"><span class="hljs-function">time_duration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">td</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boost::posix_time::microsec_clock::local_time() - m_StartTime)</span></span></span></span>; boost::system::error_code error; socket-&gt;shutdown(TCPSocket::shutdown_both, error); <span class="hljs-comment"><span class="hljs-comment">// pinged successfully, close all opened sockets boost::mutex::scoped_lock lock(m_DataMutex); CloseSockets(); PingerLogic::OnTcpSucceeded(static_cast&lt;std::size_t&gt;(td.total_milliseconds())); } void TCPPingFailed(const SocketPtr socket) { // ping on this port fails, close this socket boost::system::error_code error; socket-&gt;close(error); boost::mutex::scoped_lock lock(m_DataMutex); const std::vector&lt;SocketPtr&gt;::const_iterator it = std::remove( m_Sockets.begin(), m_Sockets.end(), socket ); m_Sockets.erase(it, m_Sockets.end()); if (m_Sockets.empty()) m_PingTimer.cancel(); // all ports failed, cancel timer }</span></span></code> </pre><br><h5>  Name resolving </h5><br>  The boost resolver, depending on the type of argument passed, performs the functions <b>getaddrinfo</b> or <b>getnameinfo</b> (the first and second code examples below, respectively). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartResolveIpByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Resolver::<span class="hljs-function"><span class="hljs-function">query </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tcp::v4(), name, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; m_Resolver.async_resolve(query, boost::bind( &amp;Ping::ResolveIpCallback, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::iterator )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartResolveNameByIp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Address(ip), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; m_Resolver.async_resolve(ep, boost::bind( &amp;Ping::ResolveFQDNCallback, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::iterator )); }</code> </pre><br>  The first code example is used to get the IP address;  similar code is used to verify the NetBIOS name.  The code from the second example is used to get the host's FQDN, in case its IP is already known. <br><br><h5>  Pinger logic </h5><br>  Actually, it is in a separate abstraction.  And we have several reasons for this. <br><br><ol><li>  It is necessary to separate the execution of operations with sockets from the pinger logic. </li><li>  It is necessary to provide for the possibility of using several strategies in the course of the pinger‚Äôs work in the future. </li><li>  The implementation of the conditions for the unit tests to cover the entire logic of the pinger's work as a separate entity. </li></ol><br>  The class that implements the ping operation is inherited from the class that implements the logic: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ping</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;Ping&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PingerLogic</code> </pre><br>  At the same time, the corresponding virtual methods are redefined in the Ping class: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//! Init ports virtual void InitPorts(const std::string&amp; ports) = 0; //! Resolve ip virtual bool ResolveIP(const std::string&amp; name) = 0; //! Start resolve callback virtual void StartResolveNameByIp(unsigned long ip) = 0; //! Start resolve callback virtual void StartResolveIpByName(const std::string&amp; name) = 0; //! Start TCP ping callback virtual void StartTCPPing(std::size_t timeout) = 0; //! Start ICMP ping virtual void StartICMPPing(std::size_t timeout) = 0; //! Start get NetBios name virtual void StartGetNetBiosName(const std::string&amp; name) = 0; //! Cancel all pending operations virtual void Cancel() = 0;</span></span></code> </pre><br>  We will not describe the implementation of the <b>PingerLogic</b> class <b>in</b> detail; we will only give examples of code that speak for themselves. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//! On ping start void OnStart() { InitPorts(m_Request.m_Ports); const bool ipResolved = ResolveIP(m_Request.m_HostName); if (!ipResolved) StartResolveIpByName(m_Request.m_HostName); } //! On ip resolved void OnIpResolved(const unsigned long ip) { boost::recursive_mutex::scoped_lock lock(m_Mutex); m_Result.m_ResolvedIP = ip; if (m_Request.m_Flags &amp; SCANMGR_PING_RESOLVE_HOSTNAME) { m_HasPendingResolve = true; StartResolveNameByIp(ip); } if (m_Request.m_Flags &amp; SCANMGR_PING_ICMP) { // if tcp ping needed it will be invoked after icmp completes StartICMPPing(m_Request.m_TimeoutSec); return; } if (m_Request.m_Flags &amp; SCANMGR_PING_TCP) { // in case of tcp ping only StartTCPPing(m_Request.m_TimeoutSec); } }</span></span></code> </pre><br>  That's all for today.  Thanks for attention!  In the next article we will talk about the coverage of the network ping process and the logic of our pinger with unit testing.  Keep for updates. <br><br>  Author: Sergey Karnaukhov, Senior Programmer, Positive Technologies ( <a href="https://habrahabr.ru/users/clrn/" class="user_link">CLRN</a> ). </div><p>Source: <a href="https://habr.com/ru/post/156795/">https://habr.com/ru/post/156795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../156781/index.html">Compact Java servlet for mobile web</a></li>
<li><a href="../156783/index.html">Google Play caught up with Apple App Store</a></li>
<li><a href="../156787/index.html">Windows 8 Summit through the eyes of a Delphi programmer</a></li>
<li><a href="../156789/index.html">Free WiFi traffic</a></li>
<li><a href="../156791/index.html">The possibility of buying Windows 8 for $ 15</a></li>
<li><a href="../156797/index.html">SEO apology</a></li>
<li><a href="../156801/index.html">ARM ChrUbuntu 12.04 Alpha - Porting Ubuntu to Samsung Chromebook</a></li>
<li><a href="../156803/index.html">The most popular programming languages</a></li>
<li><a href="../156805/index.html">A simple way to prepare reports based on rtf forms</a></li>
<li><a href="../156807/index.html">Easy copying of paper documents in Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>