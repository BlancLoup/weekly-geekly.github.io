<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Handling annotations during compilation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Metaprogramming is a type of programming associated with the creation of programs that generate other programs as a result of their work (in particula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Handling annotations during compilation</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/e-Legion/blog/206208/"><img src="https://habrastorage.org/files/525/2b3/35e/5252b335ec97422aba615f934944b0c2.jpg" alt="magic" align="left"></a>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25B0%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Metaprogramming</a> is a type of programming associated with the creation of programs that generate other programs as a result of their work (in particular, at the stage of compiling their source code), or programs that change themselves during execution. <br><br>  Annotations as a metaprogramming tool appeared along with the release of Java 5 back in 2004.  Together with them appeared the <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/">Annotation Processing Tool</a> , which was replaced by the JSR 269 specification or the <a href="https://www.jcp.org/en/jsr/detail%3Fid%3D269">Pluggable Annotation Processing API</a> .  What is interesting, this specification is almost 10 years old, but it began to acquire its popularity in Android development just now. <br><br>  We will talk about the possibilities that this specification opens a bit later (there will be a lot of code), but first, would you like to talk about compiling Java code? <br><a name="habracut"></a><br><h4>  Couple of words about javac </h4><br>  The whole compilation process is controlled by the tools from the <u>com.sun.tools.javac</u> package and, according to the OpenJDK specifications, in general, looks like this: <br><ul><li>  <b>Parse</b> - the compiler parses the input stream into a sequence of tokens and forms an abstract syntax tree (AST) using the tools from the <u>com.sun.tools.javac.parser. *</u> Package </li><li>  <b>Enter</b> - at this stage, a pass through the syntactic tree is performed and a symbol table is created.  It is worth noting that this process consists of two phases: the first is the passage through the AST from the Parse phase, the second pass through all dependencies (interfaces, supertypes, parameters). </li><li>  <b>Annotation processing</b> - this phase, in fact, will be discussed later. </li><li>  <b>Attribute</b> - most context-sensitive operations are performed during this phase: name resolution, type checking, constant computation. </li><li>  <b>Flow</b> - at this stage there is a check of the data flow, the reachability of all parts of the code, that all intercepted exceptions are processed, that final variables are set once, and so on. </li><li>  <b>Desugar</b> - removing syntactic sugar, replacing inner classes, expanding foreach cycles. </li><li>  <b>Generate</b> - generation of .class files </li></ul><br><h4>  Metaprogramming in Android </h4><br>  Where does metaprogramming help us in Android development?  Many of you already know the answer to this question - it is a considerable number of libraries that somehow offer solutions for injecting components, installing listeners and much more. <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bind</span></span>(R.id.fab) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FloatingActionButton mFab; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.ac_main); mFab.setOnClickListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View.OnClickListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v)</span></span></span><span class="hljs-function"> </span></span>{ } }); ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  What problems does this code have?  First, he will not meet!  The compilation process will be interrupted by an error. <br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">Error</span></span>:(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: @Bind fields must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> static. (moscow.droidcon2015.activity.MainActivity.mFab)</code> </pre><br>  Great, remove <i>private</i> and everything is going to code.  But, by doing so, we are violating one of the fundamental principles of <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">OOP</a> - <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D0%25BA%25D0%25B0%25D0%25BF%25D1%2581%25D1%2583%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">encapsulation</a> .  Secondly, at startup, the application will <i>crash</i> with <i>NPE</i> , because the <i>mFab</i> field <i>is</i> initialized at the time of the call to <i>ButterKnife.bind (this)</i> .  Third, Proguard can cut classes generated by the ButterKnife library.  You can say that these are all far-fetched problems and they are all solved within five minutes.  Of course, this is true, but it would be great to save yourself from having to think about these possible problems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Forward!  To heavy substances! </h4><br>  So let's start reinventing the wheel!  The first thing we need, oddly enough, is the annotation itself, which we will subsequently process: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.FIELD}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> BindView { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  <i>RetentionPolicy.SOURCE</i> means that this annotation is available only in source codes (which completely suits us) and it will not be possible to reach it through reflection.  <i>ElementType.FIELD</i> says that the annotation applies only to class fields. <br><br>  Next, we need to create the processor itself and register it in a special file: <br><pre> <code class="hljs kotlin">src/main/resources/META-INF.services/javax.<span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span>.processing.Processor</code> </pre>  The content of this file is a single line containing the full class name of the connected processor: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">moscow</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.droidcon2015</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.processor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.DroidConProcessor</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">DroidConProcessor.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"moscow.droidcon2015.processor.BindView"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DroidConProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;TypeElement, BindViewVisitor&gt; mVisitors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (annotations.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(BindView.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Element element : elements) { <span class="hljs-comment"><span class="hljs-comment">// element == MainActivity.mFab final TypeElement object = (TypeElement) element.getEnclosingElement(); // object == MainActivity BindViewVisitor visitor = mVisitors.get(object); if (visitor == null) { visitor = new BindViewVisitor(processingEnv, object); mVisitors.put(object, visitor); } element.accept(visitor, null); } for (final BindViewVisitor visitor : mVisitors.values()) { visitor.brewJava(); } return true; } @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } }</span></span></code> </pre><br></div></div><br>  No matter how paradoxical it may be, we mark the processor itself with an annotation, which indicates what kind of annotations the processor can handle.  It is not difficult to guess that the main method is the <i>process</i> method.  The first parameter is the set of annotations from the list supported by our processor, which were discovered during the first two phases of the compilation.  The second parameter is the compiler environment.  In an amicable way, in the implementation of the method we have to go through the entire set of annotations found and process them all, but in this case, the processor supports only one single annotation, so we will process it head-on.  Consider the <i>process</i> method in steps: <br><ul><li>  We check that at least the summary of the supported </li><li>  We get from the environment the set of all elements marked with the annotation @BindView </li><li>  We pass on the given set.  As we remember, annotation can only be applied to a class field; accordingly, the <i>element.getEnclosingElement ()</i> method returns an object of the class in which the field is contained. </li><li>  Create a class visitor for each object containing marked fields. </li><li>  We apply our visitor to each field </li><li>  After all visitors have worked, we generate the final classes of source code </li></ul><br><div class="spoiler">  <b class="spoiler_title">BindViewVisitor.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindViewVisitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElementScanner7</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Void</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Void</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CodeBlock.Builder mFindViewById = CodeBlock.builder(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Trees mTrees; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Messager mLogger; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Filer mFiler; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TypeElement mOriginElement; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TreeMaker mTreeMaker; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Names mNames; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindViewVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment env, TypeElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); mTrees = Trees.instance(env); mLogger = env.getMessager(); mFiler = env.getFiler(); mOriginElement = element; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JavacProcessingEnvironment javacEnv = (JavacProcessingEnvironment) env; mTreeMaker = TreeMaker.instance(javacEnv.getContext()); mNames = Names.instance(javacEnv.getContext()); } }</code> </pre><br></div></div><br>  Now let's look at the class in which all the main work is done.  The first thing that the eye clings to is <a href="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/util/ElementScanner7.html">ElementScanner7</a> .  This is an implementation of the <a href="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/ElementVisitor.html">ElementVisitor</a> interface, and 7 is the minimum version of the JDK we want to use.  Let's walk through the fields (more precisely, according to their types): <br><ul><li>  <b>CodeBlock.Builder</b> is part of the <a href="https://github.com/square/javapoet">javapoet</a> library from the guys from Square, which is designed to simplify code generation. </li><li>  <b>Trees</b> is a class from the <u>com.sun.source.util</u> package that allows access to the AST. </li><li>  <b>Messager</b> - logger.  You can display messages during the compilation process or interrupt the process if you send a message with an ERROR priority. </li><li>  <b>Filer</b> is a class that allows you to create source code files in the current compiler sandbox.  Knows exactly where to place the file in the file system.  For example, for gradle this is build / intermediates / classes. </li><li>  <b>TreeMaker</b> is a class from the <u>com.sun.tools.javac.tree</u> package, which is absolutely responsible for all the magic that will happen next!  It is used in the first phase of compilation to build AST. </li><li>  <b>Names</b> is a class from the <u>com.sun.tools.javac.util</u> package that converts the element names into AST constructs. </li></ul><br>  As you remember, we applied the <i>ElementVisitor</i> to the class field, so the method that interests us is <div class="spoiler">  <b class="spoiler_title">visitVariable</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Void </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitVariable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VariableElement field, Void aVoid)</span></span></span><span class="hljs-function"> </span></span>{ ((JCTree) mTrees.getTree(field)).accept(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeTranslator() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitVarDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JCTree.JCVariableDecl jcVariableDecl)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitVarDef(jcVariableDecl); jcVariableDecl.mods.flags &amp;= ~Flags.PRIVATE; } }); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BindView bindView = field.getAnnotation(BindView.class); mFindViewById.addStatement(<span class="hljs-string"><span class="hljs-string">"(($T) this).$L = ($T) findViewById($L)"</span></span>, ClassName.get(mOriginElement), field.getSimpleName(), ClassName.get(field.asType()), bindView.value()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitVariable(field, aVoid); }</code> </pre><br></div></div><br>  A small digression to understand what will happen next: the classes from <u>javax.lang.model.element</u> (VariableElement, TypeElement, etc.) are, let's say, a high-level abstraction over AST.  With the help of the <i>Trees</i> class, we get a low-level abstraction, set the <a href="https://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/TreeVisitor.html">TreeVisitor</a> 's implementation on it and get into the <i>visitVarDef</i> method in whose parameters the AST representation of our field is located ( <i>JCTree.JCVariableDecl</i> ).  Next dirty hack - remove the <i>private</i> flag from the field.  Yes, yes, we violate the principle of encapsulation, but we do it at the level of the compiler (where we are, in principle, because what is happening).  At the source code level, the encapsulation is preserved: IDE will not allow access to the field from the outside, and the static analyzer will quietly report that there are no problems with this field.  Add an expression to CodeBlock.Builder to initialize the field and that's it. <br><br><h4>  Generating the source file </h4><br>  After we have visited all the fields of our class, it is necessary to generate the source code file. <br><div class="spoiler">  <b class="spoiler_title">brewJava</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brewJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TypeSpec typeSpec = TypeSpec.classBuilder(mOriginElement.getSimpleName() + <span class="hljs-string"><span class="hljs-string">"$$Proxy"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// MainActivity$$Proxy .addModifiers(Modifier.ABSTRACT) .superclass(ClassName.get(mOriginElement.getSuperclass())) // extends AppCompatActivity .addOriginatingElement(mOriginElement) .addMethod(MethodSpec.methodBuilder("setContentView") .addAnnotation(Override.class) .addModifiers(Modifier.PUBLIC) .addParameter(TypeName.INT, "layoutResId") .addStatement("super.setContentView(layoutResId)") .addCode(mFindViewById.build()) // findViewById... .build()) .build(); final JavaFile javaFile = JavaFile.builder(mOriginElement.getEnclosingElement().toString(), typeSpec) .addFileComment("Generated by DroidCon processor, do not modify") .build(); try { final JavaFileObject sourceFile = mFiler.createSourceFile( javaFile.packageName + "." + typeSpec.name, mOriginElement); try (final Writer writer = new BufferedWriter(sourceFile.openWriter())) { javaFile.writeTo(writer); } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> MAGIC } catch (IOException e) { mLogger.printMessage(Diagnostic.Kind.ERROR, e.getMessage(), mOriginElement); } }</span></span></code> </pre><br></div></div><br>  All work on generating the source code was taken over by the <i>javapoet</i> library.  Of course, it would have been possible to do without it, but then the whole source would have to be generated manually using string concatenation, which, you see, is not very convenient.  At this stage, all the creators of libraries like <i>ButterKnife finish</i> .  We received a class file, which we then find with the help of reflection and, with its help, we pull the corresponding method, which performs useful work.  But I promised that we will get rid of this need! <br><br><h4>  We need to go deeper! </h4><br><div class="spoiler">  <b class="spoiler_title">TODO: MAGIC</b> <div class="spoiler_text"><pre> <code class="java hljs">JCTree.JCExpression selector = mTreeMaker.Ident(mNames.fromString(javaFile.packageName)); selector = mTreeMaker.Select(selector, mNames.fromString(typeSpec.name)); ((JCTree.JCClassDecl) mTrees.getTree(mOriginElement)).extending = selector;</code> </pre><br></div></div><br>  Yes!  Three lines.  What happens in them: <br><ul><li>  Choose one of the AST nodes.  In our case, the package in which the generated class lies. </li><li>  Go deep into the tree and select the next node - the generated class itself. </li><li>  At the source element (MainActivity) we change the extending property, which, in fact, means from which this class is inherited. </li></ul><br>  In an even simpler language, we embed the generated class in the inheritance hierarchy: <br><pre> <code class="hljs scala"><span class="hljs-type"><span class="hljs-type">MainActivity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">MainActivity</span></span>$$<span class="hljs-type"><span class="hljs-type">Proxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">AppCompatActivity</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">MainActivity $$ Proxy.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Generated by DroidCon processor, do not modify package moscow.droidcon2015.activity; import android.support.design.widget.FloatingActionButton; import android.support.v7.app.AppCompatActivity; import java.lang.Override; abstract class MainActivity$$Proxy extends AppCompatActivity { @Override public void setContentView(int layoutResId) { super.setContentView(layoutResId); ((MainActivity) this).mFab = (FloatingActionButton) findViewById(2131492965); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">MainActivity.class (decompiled)</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package moscow.droidcon2015.activity; import android.os.Bundle; import android.support.design.widget.FloatingActionButton; import android.view.View; import android.view.View.OnClickListener; import moscow.droidcon2015.activity.MainActivity$$Proxy; public class MainActivity extends MainActivity$$Proxy { FloatingActionButton mFab; public MainActivity() { } protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); this.setContentView(2130968600); this.mFab.setOnClickListener(new OnClickListener() { public void onClick(View v) { } }); } }</span></span></code> </pre><br></div></div><br><br><h4>  Conclusion </h4><br>  Unfortunately, within the framework of a single article it is impossible to tell about all the intricacies of Annotation processing and the treasures that lie inside <u>com.sun.tools.javac. *</u> .  What is even more distressing is the complete lack of any documentation on these treasures and the lack of compatibility between releases.  Then scary words will sound: to provide support for the java7 and java8 compilers, you will need to use reflection in the compilation process!  From this turn!  True?  But I repeat once again - this only applies to <u>com.sun.tools.javac</u> . <br><br><h4>  <a href="https://www.youtube.com/watch%3Fv%3Dnuz9WfbxTUA">Based on DroidCon</a> </h4><br>  It is more convenient to read the article while flipping through the <a href="https://docs.google.com/presentation/d/1zamMD_7LeGItOYFUPoYYjKb8hFl243krqZgPKwVgvr0/edit%3Fusp%3Dsharing">presentation</a> . <br>  Project repository <a href="https://github.com/DanielSerdyukov/droidcon2015">here</a> . <br><br>  Answers on questions: <br><ul><li>  This is not a research task.  All this is already actively working in a number of projects. </li><li>  The advantage of this approach over the modification of bytecode by libraries like ASM is that annotation processing is performed at the time of compilation and not after, and the ability to grab a compilation error and not runtime, IMHO, is much better. </li><li>  You can see it in the <a href="https://github.com/DanielSerdyukov/droidkit">DroidKit</a> library.  <a href="https://habrahabr.ru/users/andkulikov/" class="user_link">andkulikov</a> , the documentation will undoubtedly appear.  When?  When is done.  =) </li></ul><br><br><h4>  More hardcore! </h4><br><div class="spoiler">  <b class="spoiler_title">visitMethodDef</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitMethodDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JCTree.JCMethodDecl methodDecl)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitMethodDef(methodDecl); methodDecl.body.stats = com.sun.tools.javac.util.List.&lt;JCTree.JCStatement&gt;of( mTreeMaker.Try( mTreeMaker.Block(<span class="hljs-number"><span class="hljs-number">0</span></span>, methodDecl.body.stats), com.sun.tools.javac.util.List.&lt;JCTree.JCCatch&gt;nil(), mTreeMaker.Block(<span class="hljs-number"><span class="hljs-number">0</span></span>, com.sun.tools.javac.util.List.&lt;JCTree.JCStatement&gt;of( mTreeMaker.Exec(mTreeMaker.Apply( com.sun.tools.javac.util.List.&lt;JCTree.JCExpression&gt;nil(), ident(mPackageName, mHelperClassName, <span class="hljs-string"><span class="hljs-string">"update"</span></span>), com.sun.tools.javac.util.List.of( mTreeMaker.Literal(TypeTag.CLASS, mColumnName), mTreeMaker.Select(mTreeMaker.Ident(mNames._this), mNames.fromString(mFieldName)), mTreeMaker.Select(mTreeMaker.Ident(mNames._this), mNames.fromString(mPrimaryKey.call())) ) )) )) ) ); }</code> </pre><br></div></div><br>  Here is such a scary at first glance code that only modifies the code of the setter method so that the changes are written directly to the database. <br><br><div class="spoiler">  <b class="spoiler_title">pants are turning smoothly ...</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public void setText(String text) { mText = text; } //  public void setText(String text) { try { this.mText = text; } finally { Foo$$SQLiteHelper.update("text", this.mText, this.mId); } }</span></span></code> </pre><br></div></div><br><br><h4>  Sources </h4><br><ul><li>  <a href="http://docs.oracle.com/javase/specs/jls/se7/html/index.html">The Java¬Æ Language Specification</a> </li><li>  <a href="http://scg.unibe.ch/archive/projects/Erni08b.pdf">The Hacker's Guide to Javac</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DtRmJm2_qytM">Droidcon NYC 2014 - Annotation Processing Boilerplate Destruction</a> </li><li>  <a href="http://www.youtube.com/watch%3Fv%3DdBUAqPs0TB0">Droidcon NYC 2015 - @AnnotationProcessors ("ByExample")</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/206208/">https://habr.com/ru/post/206208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206198/index.html">A passion for programming. Chapter 10. Fall in Love or Throw It</a></li>
<li><a href="../206200/index.html">Video calls through the browser - how to make technology work for your company</a></li>
<li><a href="../206202/index.html">Skeptics list</a></li>
<li><a href="../206204/index.html">How we created the single on Ubuntu Studio 13.10</a></li>
<li><a href="../206206/index.html">One day from the life of Moscow in geotagging of Vkontakte</a></li>
<li><a href="../206210/index.html">Synchronization in Android applications. Part one</a></li>
<li><a href="../206212/index.html">LG A290 TriSim. One year later</a></li>
<li><a href="../206216/index.html">$ 7M investment in symfony and sensiolabs</a></li>
<li><a href="../206218/index.html">We build in polls for users of Android applications</a></li>
<li><a href="../206220/index.html">Designing a notification system for web applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>