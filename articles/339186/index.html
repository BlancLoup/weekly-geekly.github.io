<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[CppCon 2017] Herb Sutter: Metaprogramming and Code Generation in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the series of Fil publications on CppCon 2017. The report presents early developments on adding reflection and code generation in C ++, as ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[CppCon 2017] Herb Sutter: Metaprogramming and Code Generation in C ++</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://www.youtube.com/embed/4AfRAVcThyA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  I continue the series of <a href="https://habrahabr.ru/users/fil/" class="user_link">Fil</a> publications on CppCon 2017. The report presents early developments on adding reflection and code generation in C ++, as well as on metaclasses that will allow to generate parts of C ++ classes.  These innovations will get to the standard not earlier than in C ++ 23. </p><a name="habracut"></a><br><h2 id="predislovie-operatory-sravneniya">  Preface: Comparison Operators </h2><br><p> Suppose we want to write a class whose objects can be compared, for example, a non-case-sensitive string class - <code>CIString</code> (Case-Insensitive String).  To do this, at a minimum, we need to write 6 comparison operators: <code>==</code> , <code>&lt;</code> <code>!=</code> , <code>&gt;</code> , <code>&gt;=</code> , <code>&lt;=</code> .  And all the code, except for the first two, will be absolutely standard.  If you need to be able to compare our string with <code>const char*</code> without copying, then add 12 more statements. </p><br><p>  The problem of duplication of code in comparison operators was so acute that a <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0515r0.pdf">sentence</a> was written to the C ++ standard, which adds the so-called "spaceship operator" to the language: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ...   ... std::weak_ordering operator&lt;=&gt;(const CIString&amp; b) const { ... } std::weak_ordering operator&lt;=&gt;(const char* b) const { ... } };</span></span></code> </pre> <br><p>  We write one function <code>&lt;=&gt;</code> , where we return <code>std::weak_ordering::less</code> , <code>::equivalent</code> or <code>::greater</code> , and the compiler generates implementations of all comparison functions.  5 main types of comparison are supported, including <code>std::strong_ordering</code> and generation of functions only <code>==</code> / <code>!=</code> . </p><br><p>  The ‚Äúspaceship operator‚Äù proposal has value by itself, but, as will be shown later, using metaclasses you can implement it, and many other code generation scenarios, moreover, in pure C ++, without the need to embed them in a compiler or a language standard. </p><br><h2 id="refleksiya">  Reflection </h2><br><p>  For any type, function, or other entity, <code>$T</code> is the <code>constexpr</code> expression that returns the value of the meta type.  You can invoke methods on it to get various meta-information related to <code>T</code> </p><br><p>  Note: this is a very early version of the standard clause, and <code>$expr</code> can be replaced with <code>reflect(T)</code> , or something like that. </p><br><p>  For example, you can get the names of variables of an arbitrary <code>enum</code> using the <code>variables()</code> method: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> E&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_strings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> o : $E.variables()) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; o.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state</span></span></span><span class="hljs-class"> {</span></span> started = <span class="hljs-number"><span class="hljs-number">1</span></span>, waiting, stopped }; print_strings&lt;state&gt;(); <span class="hljs-comment"><span class="hljs-comment">//=&gt; started waiting stopped</span></span></code> </pre> <br><p>  Since templates are instantiated only when used, variable names and other meta-information will be in a binary only if we use it in the program. </p><br><h2 id="kodogeneraciya-injection">  Coding generation (injection) </h2><br><p>  <code>constexpr</code> block can be anywhere in a program: in a function, in a class, etc.  Here's what it looks like: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   constexpr { // ,    } //  </span></span></code> </pre> <br><p>  The construction <code>-&gt; { ... }</code> used inside the <code>constexpr</code> block to insert ordinary code in its place: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... -&gt; { //   } // ... }</span></span></code> </pre> <br><p>  Example: printing the name of a specific enumeration variable </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Enum E&gt; <span class="hljs-comment"><span class="hljs-comment">//       ? auto to_string(E value) { switch (value) { constexpr { for (auto o : $E.variables()) -&gt; { case o.value(): return o.name(); } } } } enum class state { started = 1, waiting, stopped }; cout &lt;&lt; to_string(state::stopped); //=&gt; stopped</span></span></code> </pre> <br><p>  After preprocessing, the compiler will receive a code equivalent to a hand-painted <code>switch</code> . </p><br><p>  Good question - how to debug such code?  Without special support from the debugger, which allows you to look at the generated code, it will be difficult to debug such programs.  Nevertheless, the debugging function of the code that is executed at the compilation stage would be useful in any case, just like the debugging of the code generated by the compiler (many would like to see the default constructors and copy statements when debugging). </p><br><h2 id="metaklassy">  Metaclasses </h2><br><p>  The definition of a metaclass (not to be confused with a metatype) begins with the keyword <code>$class</code> , inside it is possible to define the generated functions and conditions imposed on the class.  When defining a regular class, instead of <code>class</code> you can specify the name of the metaclass to convert the class code with it.  It looks like this: </p><br><pre> <code class="cpp hljs">$<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//      //   ,     //   }; interface Shape { int area() const; void scale_by(double factor); };</span></span></code> </pre> <br><p>  This definition of <code>Shape</code> equivalent to the following: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale_by</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> factor)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Shape() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { }; };</code> </pre> <br><p>  In the definition of <code>interface</code> you can use <code>constexpr</code> -blocks and reflection, as well as receive and modify "your" metatype: </p><br><pre> <code class="cpp hljs">$<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> {</span></span> ~interface() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> { compiler.require($interface.variables().empty(), <span class="hljs-string"><span class="hljs-string">"interfaces may not contain data members"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f : $interface.functions()) { compiler.require(!f.is_copy() &amp;&amp; !f.is_move(), <span class="hljs-string"><span class="hljs-string">"interfaces may not copy or move; consider a virtual clone()"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f.has_access()) f.make_public(); compiler.require(f.is_public(), <span class="hljs-string"><span class="hljs-string">"interface functions must be public"</span></span>); f.make_pure_virtual(); } } };</code> </pre> <br><p>  It is impossible to change an arbitrary class after the declaration, that is, the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">ODR</a> remains in effect. </p><br><h2 id="nekotorye-razmyshleniya-o-metaklassah">  Some thoughts on metaclasses </h2><br><p>  Metaclass can be understood as a subtype of a class.  C ++ classes have so many properties and types of redefinable behavior that it is often convenient to limit their capabilities in order to reduce confusion. </p><br><p>  It is important that metaclasses are defined in C ++ code, and not in the compiler.  The C ++ Standardization Committee is slow, and it would take years before the approval of specific metaclasses in the C ++ standard could be achieved. </p><br><h2 id="primery-metaklassov">  Metaclass examples </h2><br><h3 id="value"> <code>value</code> </h3> <br><pre> <code class="cpp hljs">value Point { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; Point(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); }</code> </pre> <br><p>  The fact that <code>Point</code> is a <code>value</code> means that it has a default constructor, copy / move and compare operations;  guaranteed no virtual functions. </p><br><p>  On the example of <code>value</code> , the composition ("inheritance") of the metaclasses was shown: </p><br><pre> <code class="cpp hljs">$<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_value</span></span></span><span class="hljs-class"> {</span></span> ... } $<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ordered</span></span></span><span class="hljs-class"> {</span></span> ... } $<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class"> :</span></span> basic_value, ordered { }</code> </pre> <br><p>  It is clear that no <code>operator&lt;=&gt;</code> is needed to use <code>ordered</code> and generate comparison operators based on class fields. </p><br><h3 id="literal_value"> <code>literal_value</code> </h3> <br><p>  It is planned that with the help of metaclasses it will be possible to generate auxiliary classes / functions, like <code>swap</code> and the specialization <code>std::hash</code> .  Then, using the hypothetical metaclass <code>literal_value</code> you can write a simple and beautiful definition of <code>std::pair</code> , which this class deserves: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">literal_value</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> T1 first; T2 second; };</code> </pre> <br><h3 id="enum_class"> <code>enum_class</code> </h3> <br><p>  The fact that in C ++ there is no division into classes, interfaces, etc., as in Java, this is an advantage, so now all user types can be defined using the <code>class</code> keyword ... In addition to enumerations!  Fortunately, metaclasses are powerful enough to define the <code>enum class</code> .  As a result, you can write: </p><br><pre> <code class="cpp hljs">enum_class state { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> started = <span class="hljs-number"><span class="hljs-number">1</span></span>, waiting, stopped; }; state s = state::started; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s != state::waiting) { ... }</code> </pre> <br><p>  These <code>enum_class</code> can be even better than the existing ones, due to additional automatically generated functions and informative error messages. </p><br><h3 id="flag_enum"> <code>flag_enum</code> </h3> <br><p>  <code>flag_enum</code> values ‚Äã‚Äãcan be used as sets of flags, with operations <code>|</code>  , <code>&amp;</code> , <code>^</code> : </p><br><pre> <code class="cpp hljs">flag_enum openmode { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> in, out, binary, ate, app, trunc; <span class="hljs-comment"><span class="hljs-comment">// 1, 2, 4, 8, 16, 32 }; openmode mode = openmode::in | openmode::out; assert(mode != openmode::none); assert(mode &amp; openmode::out);</span></span></code> </pre> <br><h3 id="property-svoystva">  <code>property</code> </h3><br><pre> <code class="cpp hljs">classx MyClass { property&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; value { }; <span class="hljs-comment"><span class="hljs-comment">// get/set   // ... };</span></span></code> </pre> <br><p>  The <code>property&lt;&gt;</code> token is used by the <code>classx</code> metaclass to generate the property: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ value = v; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } };</code> </pre> <br><p>  Also, when defining a <code>property</code> you can set your own <code>get</code> / <code>set</code> functions. </p><br><h3 id="qclass"> <code>QClass</code> </h3> <br><p>  Qt uses the moc utility, which, by class definition, generates data for reflection on the execution time, properties, and so on.  The metaclass <code>QClass</code> could handle all this, allowing you to build using Qt only with the help of the C ++ compiler: </p><br><pre> <code class="cpp hljs">QClass MyClass { property&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; value { }; <span class="hljs-function"><span class="hljs-function">signal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mySignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">slot </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mySlot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br><p>  In addition to Qt moc, metaclasses will get rid of the clutter of macros and proprietary language extensions, like WinRT and C ++ / CX. </p><br><h3 id="podio"> <code>podio</code> </h3> <br><p>  The particle physics library <code>podio</code> uses special types of YAML files to define data structures: </p><br><pre> <code class="hljs objectivec">ExampleHit: Description: <span class="hljs-string"><span class="hljs-string">"Example Hit"</span></span> Author: <span class="hljs-string"><span class="hljs-string">"B. Heigner"</span></span> Members: - <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x - <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y - <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> z - <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> energy</code> </pre> <br><p>  At the same time, 5 classes are generated at once: <code>X</code> , <code>XCollection</code> , <code>XConst</code> , <code>XData</code> , <code>XObj</code> .  It is argued that with the help of metaclass it will turn out to do the same. </p><br><h3 id="crtp">  CRTP </h3><br><p>  <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> is a technique in which the derived class is passed as a generic parameter to the base class: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityComparable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> !=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Derived&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Derived&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EqualityComparable&lt;X&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; b) { ... } };</code> </pre> <br><p>  In fact, we already use some semblance of metaclasses in our projects.  Only here in a fairly complex code with error reporting patterns leave much to be desired.  With the advent of metaclass, CRTP is gone. </p><br><h2 id="demonstraciya">  Demonstration </h2><br><p>  Herb demonstrated a Clang modification that supports everything that was shown above, except for the generation of several classes / functions from one class.  The code obtained after applying the metaclass can be viewed and debugged. </p><br><h2 id="voprosy">  Questions </h2><br><p>  <strong>What if N companies define an <code>interface</code> ?</strong> </p><br><p>  With classes of strings this is already happening, but this does not mean that ordinary classes should be abandoned.  Basic metaclasses, like <code>interface</code> , can be added to <code>std</code> . </p><br><p>  <strong>What is the benefit of being able to define an <code>interface</code> in C ++ code if you still want to standardize some popular metaclasses?</strong> </p><br><p>  In order to make an <code>interface</code> standard now, it will take an enormous amount of time, and the problem associated with its absence in the language is not so great that anyone becomes involved in it.  If the <code>interface</code> can be implemented in 10 C ++ lines, it will fly through the standardization committee "with a whistle". </p><br><p>  <strong>You said that metaclasses that define C ++ entities in C ++ itself are better than defining them in a standard.</strong>  <strong>You also said that the C ++ standard language is very complex.</strong>  <strong>Isn't it possible that C ++ will become more complicated up to the level of the C ++ standard language?</strong> </p><br><p>  We are not trying to define meta-C ++.  Metaclasses perform a specific function of generating class elements, and this can be implemented without excessively complicating the language. </p><br><p>  <strong>Metaclasses modify their class "in place".</strong>  <strong>Wouldn't it be better if the metaclass had an "input class" and it would generate code in the "output class"?</strong> </p><br><p>  Yes, we are going to change the syntax so that everything works that way.  The output class will be called <code>$prototype</code> .  At first it will be empty, and the metaclass will insert the strings one by one into its definition. </p><br><p>  <strong>You said that several classes could be generated from one metaclass.</strong>  <strong>Does this mean that all classes will be nested in the main one, or will they be separate classes?</strong> </p><br><p>  These will be separate classes.  The current version of our compiler does not support this function, but we are working on it.  Without generating auxiliary external functions, for example, it is not possible to define a <code>literal_value</code> . </p><br><p>  <strong>If the <code>literal_value</code> is in the standard, will the std :: pair class really be changed as shown?</strong> </p><br><p>  If it is possible to determine <code>literal_value</code> so that it exactly matches the current behavior of std :: pair, then yes. </p><br><p>  <strong>Will it be possible to completely get rid of all techniques with templates when generating C ++ code?</strong> </p><br><p>  Templates <em>will be</em> used with metaclasses.  See an example with <code>property&lt;&gt;</code> . </p><br><p>  <strong>Does it not turn out that each company will have its own "mandatory" basic metaclass from which all classes must inherit, which will lead to the fragmentation of the language?</strong> </p><br><p>  This is already happening, and it is called "corporate code style".  The difference is that it is described in words and, possibly, verified by various tools.  Now it will be observed more strictly, predictably and correctly.  When we tested the usability of metaclasses on real projects, we found that they found different uses for each project.  For example, one of the projects included a robot control library that required all your classes to follow a specific pattern.  Now they monitor the observance of these rules manually.  From time to time they are forgotten, hard-to-find errors, etc. appear.  With just one metaclass of 20-30 lines of code, they could fix this problem once and for all. </p><br><p>  <strong>CRTP is a great metaclass-like technique that works now.</strong>  <strong>If it is supplemented with reflection and <code>constexpr</code> -blocks, then they will have as many opportunities as the metaclasses.</strong>  <strong>Why then are they needed?</strong> </p><br><p>  Metaclasses have more options.  CRTP is a great hack, but the templates were not originally designed for this, it is not a sufficiently accurate and functional tool.  For example, CRTP allows you to mistakenly override the generated methods in a derived class.  Using CRTP, it will not be possible to define helper global functions and classes. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339186/">https://habr.com/ru/post/339186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339174/index.html">GitLab 10.0 released: Auto-DevOps and group task boards</a></li>
<li><a href="../339176/index.html">Node.js and transition from PHP to JavaScript</a></li>
<li><a href="../339178/index.html">How to permanently delete 100,000 users and stay alive?</a></li>
<li><a href="../339180/index.html">[CppCon 2017] Lars Knoll: C ++ Qt framework: History, Present and Future</a></li>
<li><a href="../339184/index.html">Ivan Ponomarev and Nikolai Potashnikov on the display of tabular data, Celesta and Flute on jug.msk.ru</a></li>
<li><a href="../339190/index.html">Obvious non-obviousness in assembly using a webpack</a></li>
<li><a href="../339192/index.html">Why in Go ampersand and asterisk (& and *)?</a></li>
<li><a href="../339194/index.html">Next billion users: who these people are and how they will affect the global economy</a></li>
<li><a href="../339196/index.html">Dirty place provider: the project blondemine</a></li>
<li><a href="../339198/index.html">Hacktoberfest Open Hack Day at Avito - October 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>