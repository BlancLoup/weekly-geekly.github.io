<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Acceleration build C and C ++ projects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many programmers know firsthand that a program in C and C ++ is going to be very long. Someone solves this problem by fighting with swords during asse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Acceleration build C and C ++ projects</h1><div class="post__text post__text-html js-mediator-article">  Many programmers know firsthand that a program in C and C ++ is going to be very long.  Someone solves this problem by fighting with swords during assembly, someone with a trip to the kitchen to "drink coffee."  This article is for those who are tired of it, and he decided it was time to do something.  This article discusses various ways to speed up the project build, as well as the treatment of the disease "corrected one header file - half of the project was reassembled." <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/465/ac9/c0e465ac93e5cbc5b4b4debd0b519493.png" alt="Picture 1"></div><a name="habracut"></a><br><h2>  General principles </h2><br>  Before we begin, let's find out / recall the main phases of translation of C / C ++ code into an executable program. <br><br>  According to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">clause 5.1.1.2 of the</a> draft N1548 ‚ÄúProgramming languages ‚Äã‚Äã- C‚Äù and clause <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">5.2 of the</a> draft N4659 ‚ÄúWorking Draft Standard for Programming Language C ++‚Äù (published versions of the standards can be purchased <a href="https://www.iso.org/standard/57853.html">here</a> and <a href="https://www.iso.org/standard/68564.html">here</a> ), 8 and 9 translation phases are defined, respectively.  Let's omit the details and take an abstract look at the translation process: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/436/953/f75/436953f7570a714f6ea26fed59c5066d.png" alt="Picture 4"></div><br><ul><li>  Phase I - the source file is input to the preprocessor.  The preprocessor makes the substitution of the contents of the files specified in #include and opens macros.  Corresponds to phases 1 - 4 of the C11 and C ++ 17 draft. </li><li>  Phase II - the preprocessed file enters the input of the compiler and is converted to an object.  Corresponds to phases 5 - 7 Draft C11 and 5 - 8 Draft C ++ 17. </li><li>  Phase III ‚Äî the linker links the object files and the provided static libraries to form an executable program.  Corresponds to phase 8 and 9 of the draft of C11 and C ++ 17, respectively. </li></ul><br>  The program is composed of translation units (* .c, * .cc, * .cpp, * .cxx), each is self-sufficient and can be preprocessing / compiled independently of the other.  It also follows from this that each translation unit has no information about the other units.  If two translation units need to exchange any information (for example, a function), then this is solved by linking by name: the external entity is declared with the keyword <i>extern</i> , and in phase III the linker links them.  A simple example. <br><br>  TU1.cpp file: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// TU1.cpp #include &lt;cstdint&gt; int64_t abs(int64_t num) { return num &gt;= 0 ? num : -num; }</span></span></code> </pre> <br>  TU2.cpp file: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// TU2.cpp #include &lt;cstdint&gt; extern int64_t abs(int64_t num); int main() { return abs(0); }</span></span></code> </pre> <br>  To simplify the negotiation of different translation units, a header file mechanism was invented, which consists in declaring a clear interface.  Subsequently, each translation unit, if necessary, includes a header file through the preprocessor directive <i>#include</i> . <br><br>  Next, we consider how to speed up the assembly at different phases.  In addition to the principle itself, it will also be useful to describe how to implement this or that method into the assembly system.  Examples will be given for the following build systems: <i>MSBuild</i> , <i>Make</i> , <i>CMake</i> . <br><br><h3>  Compile dependencies </h3><br>  Dependencies when compiling is what most influences the speed of building C / C ++ projects.  They occur whenever you include a header file through the preprocessor directive <i>#include</i> .  This gives the impression that there is only one source of ad for an entity.  The reality is far from ideal - the compiler has to repeatedly process the same ads in different translation units.  Macros spoil the picture even more: it is necessary to add a macro declaration before including the title, how its contents can change radically. <br><br>  Consider a couple of ways to reduce the number of dependencies. <br><br>  Method N1: remove unused inclusions.  No need to pay for what you do not use.  So you reduce the work of both the preprocessor and the compiler.  You can manually crack the headers / source files or use the utilities: <a href="https://include-what-you-use.org/">include-what-you-use</a> , <a href="https://www.jetbrains.com/resharper-cpp/">ReSharper C ++</a> , <a href="https://code.google.com/archive/p/cppclean/">CppClean</a> , <a href="https://www.stack.nl/~dimitri/doxygen/manual/diagrams.html">Doxygen + Graphviz</a> (for visualizing the diagram of inclusions), etc. <br><br>  Method N2: Use ad dependency, not definition.  We highlight 2 main aspects: <br><br>  1) In header files do not use objects where you can use links or pointers.  For references and pointers, a forward declaration is sufficient, since the compiler knows the size of the link / pointer (4 or 8 bytes depending on the platform), and the size of the transmitted objects does not matter.  A simple example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Foo.h #pragma once class Foo { .... }; // Bar.h #pragma once #include "Foo.h" class Bar { void foo(Foo obj); // &lt;=    .... };</span></span></code> </pre> <br>  Now, when changing the first header, the compiler will have to recompile the translation units dependent on both <i>Foo.h</i> and <i>Bar.h.</i> <br><br>  To break such a link, it is enough to refuse to transfer the <i>obj</i> object by value in favor of passing by a pointer or a link in the <i>Bar.h</i> header: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Bar.h #pragma once class Foo; // &lt;=    Foo class Bar { void foo(const Foo &amp;obj); // &lt;=     .... };</span></span></code> </pre> <br>  As for the standard headers, here you can worry less and just include them in the header file, if necessary.  The only exception is <i>iostream</i> .  This header file has grown so much in size that it additionally comes with an <a href="http://en.cppreference.com/w/cpp/header/iosfwd"><i>iosfwd</i></a> header, containing only the leading declarations of the necessary entities.  This is what should be included in your header files. <br><br>  2) Use <a href="http://en.cppreference.com/w/cpp/language/pimpl">Pimpl</a> or Interface Class idioms.  Pimpl removes implementation details by placing them in a separate class whose object is accessible through a pointer.  The second approach is based on the creation of an abstract base class, the implementation details of which are transferred to a derived class that overrides pure virtual functions.  Both options eliminate dependencies at the compilation stage, but also introduce their overhead during the program operation, namely: creating and deleting a dynamic object, adding an indirect addressing level (due to the pointer);  and separately in the case of the interface class, the cost of calling virtual functions. <br><br>  Method N3 (optional): in addition, you can create headlines containing only leading ads (similar to <a href="http://en.cppreference.com/w/cpp/header/iosfwd"><i>iosfwd</i></a> ).  These "leading" headers can then be included in other regular headers. <br><br><h3>  Parallel compilation </h3><br>  With the standard approach, the compiler will receive a new file for preprocessing and compiling time after time.  Since each translation unit is self-sufficient, a good way to accelerate is to parallelize phases I-II of the broadcast, processing N files at a time. <br><br>  In Visual Studio, the mode is enabled with the <i>/ MP [processMax]</i> flag at the project level, where <i>processMax</i> is an optional argument that is responsible for the maximum number of compilation processes. <br><br>  The make mode is enabled with the <i>-jN</i> flag, where <i>N</i> is the number of compilation processes. <br><br>  If you use CMake (besides in cross-platform development), then they can generate files for <a href="https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html%3Fhighlight%3Dgenerators">an extensive list of build systems</a> via the <i>-G</i> flag.  For example, CMake generates a solution for Visual Studio under Windows and Unix Makefiles under Linux for the C ++ analyzer PVS-Studio.  In order for CMake to generate projects in the Visual Studio solution with the <i>/ MP</i> flag, add the following lines to your <i>CMakeLists.txt</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MSVC) target_compile_options(target_name /MP ...) endif()</code> </pre> <br>  Also via CMake (from version 2.8.0) you can call the assembly system with parallelization flags.  For MSVC ( <i>/ MP</i> is listed in CMakeLists.txt) and Ninja (concurrency is already enabled): <br><br><pre> <code class="cpp hljs">cmake --build /path/to/build-dir</code> </pre> <br>  For makefiles: <br><br><pre> <code class="cpp hljs">cmake --build /path/to/build-dir -- -jN</code> </pre> <br><h3>  Distributed compilation </h3><br>  Using the previous advice, you can significantly reduce the assembly time.  However, when the project is huge, and this may not be enough.  Increasing the number of compilation processes, you run across the barrier in the form of the maximum number of simultaneously compiled files due to processor / RAM / disk operations.  This is where distributed compilation comes to the rescue, using the free resources of a friend behind his back.  The idea is simple: <br><br>  1) preprocessing source files on one local machine or on all available machines; <br><br>  2) compile preprocessed files on local and remote machines; <br><br>  3) expect results from other machines in the form of object files; <br><br>  4) compose object files; <br><br>  five) ???? <br><br>  6) PROFIT! <br><br>  Highlight the main features of distributed compilation: <br><br><ul><li>  Scalability - we hook up the car, and now it can help in the assembly. </li><li>  The effectiveness of distributed compilation depends on the performance of the network and each machine.  It is highly recommended that similar performance of each machine. </li><li>  The need for the identity of the environment on all machines (versions of compilers, libraries, etc.).  This is especially necessary if preprocessing occurs on all machines. </li></ul><br>  The most famous representatives are: <br><br><ul><li>  <a href="https://www.incredibuild.com/">IncrediBuild</a> </li><li>  <a href="https://github.com/distcc/distcc">distcc</a> </li><li>  <a href="https://github.com/icecc/icecream">Icecream</a> </li></ul><br>  Distcc and Icecream can be fairly easily integrated into Linux in several ways: <br><br>  1) Universal, through a symbolic link (symlink) <br><br><pre> <code class="cpp hljs">mkdir -p /opt/distcc/bin #  /opt/icecc/bin ln -s /usr/bin/distcc /opt/distcc/bin/gcc ln -s /usr/bin/distcc /opt/distcc/bin/g++ <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> PATH=/opt/distcc/bin:$PATH</code> </pre> <br>  2) For CMake, starting with version 3.4 <br><br><pre> <code class="cpp hljs">cmake -DCMAKE_CXX_COMPILER_LAUNCHER=/usr/bin/distcc /path/to/CMakeDir</code> </pre> <br><h3>  Compiler cache </h3><br>  Another way to reduce build time is to use the compiler cache.  Let's slightly change the phase II of the code translation: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/bf8/c55/61ebf8c554c062e0f17b8b8f1b8644d3.png" alt="Picture 6"></div><br>  Now when compiling a preprocessed file based on its contents, compilation flags, compiler output, a hash value is calculated (it takes into account compilation flags).  Subsequently, the hash value and the corresponding object file are registered in the compiler cache.  When recompiling with the same flags of an unmodified file, the already prepared object file will be taken from the cache and fed to the linker's input. <br><br>  What can be used: <br><br><ul><li>  For Unix-like: <a href="https://ccache.samba.org/">ccache</a> (GCC, Clang), <a href="http://cachecc1.sourceforge.net/">cachecc1</a> (GCC). </li><li>  For Windows: <a href="https://github.com/frerich/clcache">clcache</a> (MSVC), <a href="https://github.com/inorton/cclash">cclash</a> (MSVC). </li></ul><br>  Registering ccache for later use can be done in several ways: <br><br>  1) Universal, through a symbolic link <br><br><pre> <code class="cpp hljs">mkdir -p /opt/ccache/bin ln -s /usr/bin/ccache /opt/ccache/bin/gcc ln -s /usr/bin/ccache /opt/ccache/bin/g++ <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> PATH=/opt/ccache/bin:$PATH</code> </pre> <br>  2) For CMake, starting with version 3.4 <br><br><pre> <code class="cpp hljs">cmake -DCMAKE_CXX_COMPILER_LAUNCHER=/usr/bin/ccache /path/to/CMakeDir</code> </pre> <br>  The compiler cache can also be integrated into a distributed compilation.  For example, to use ccache with distcc / Icecream, follow these steps: <br><br>  1) Set the <i>CCACHE_PREFIX</i> variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> CCACHE_PREFIX=distcc #  icecc</code> </pre> <br>  2) Use one of points 1 - 2 of the ccache registration. <br><br><h3>  Precompiled header files </h3><br>  When compiling a large number of source files, the compiler, in fact, performs many times the same job of parsing heavy headers (for example, <i>iostream</i> ).  The basic idea is to put these heavy headers into a separate file (usually referred to as a prefix header), which is compiled once and then included in all translation units the <b>very first</b> . <br><br>  In MSVC, to create a precompiled header, 2 files are generated by default: <i>stdafx.h</i> and <i>stdafx.cpp</i> (other names can also be used).  The first step is to compile <i>stdafx.cpp</i> with the flag of / <i>Yc73p "</i> .  By default, a file with a <i>.pch</i> extension is <i>created</i> .  To use a precompiled header when compiling a source file, use the / <i>Yu</i> file <i>synpath-to-stdafx.h</i> flag <i>. ‚Äù</i>  Together with the <i>/ Yc</i> and <i>/ Yu</i> flags, you can also use <i>/ Fp "path-to-pch"</i> to specify the path to the <i>.pch</i> file.  Now it is necessary to connect the first prefix header in each translation unit: either directly via <i>#include "path-to-stdafx.h"</i> , or by force via the / <i>FI holypath</i> <i>-to-stdafx.h</i> flag. <br><br>  The approach to GCC / Clang differs little: you must pass the prefix header itself to the compiler itself instead of the usual compiled file.  The compiler will automatically generate a precompiled header with the default <i>.gch</i> extension.  With the -x option, you can optionally specify whether to treat it as <i>c-header</i> or <i>c ++ - header</i> .  Now include the prefix header manually via <i>#include</i> or through the <i>-include</i> flag. <br><br>  You can read <a href="https://www.viva64.com/ru/b/0265/">more</a> about precompiled headers <a href="https://www.viva64.com/ru/b/0265/">here</a> . <br><br>  If you use CMake, we recommend that you try the <a href="">cotire</a> module: it can automatically analyze the source files, generate prefix and precompiled headers and connect them to translation units.  It is also possible to specify your prefix header (for example, <i>stdafx.h</i> ). <br><br><h3>  Single Compilation Unit </h3><br>  The essence of this method is to create a single compiled file (translation block), which includes other translation units: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SCU.cpp #include "translation_unit1.cpp" .... #include "translation_unitN.cpp"</span></span></code> </pre> <br>  If all translation units are included in a single compiled file, then this method is otherwise called Unity build.  We single out the main features of the Single Compilation Unit: <br><br><ul><li>  The number of compiled files is noticeably reduced, and hence the number of disk operations.  The compiler processes the same files much less and instantiates templates.  This is noticeably reflected in the build time. </li><li>  The compiler can now perform optimizations that are available to the linker (Link time optimization / Whole program optimization). </li><li>  The incremental build deteriorates somewhat, since modifying one file as part of the Single Compilation Unit causes it to be recompiled. </li><li>  When using Unity Build, it becomes impossible to use a distributed build. </li></ul><br>  Note possible problems when applying the approach: <br><br><ul><li>  Violation of ODR (match of macro names, local static functions, global static variables, variables in anonymous namespaces). </li><li>  Name collisions due to <i>using namespace</i> . </li></ul><br>  The maximum benefit on multi-core systems will be given by the schemes: <br><br><ul><li>  parallel compilation of several Single Compilation Unit using a precompiled header; </li><li>  distributed compilation of multiple single compilation unit using compiler cache. </li></ul><br>  If you use CMake, you can automate the generation of SCUs using <a href="https://github.com/dava/dava.engine/blob/development/Sources/CMake/Modules/UnityBuild.cmake">this</a> module. <br><br><h3>  Replacing translation components </h3><br>  Replacing one of the translation components with a faster analog can also increase the assembly speed.  However, it is worth doing at your own risk. <br><br>  As a faster compiler, you can use <a href="https://www.zapcc.com/">Zapcc</a> .  The authors promise to repeatedly accelerate the recompilation of projects.  This can be seen in the example of recompiling <i>Boost.Math</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bf/a70/439/3bfa70439211b363e151b000beb38cad.gif" alt="Picture 9"></div><br>  Zapcc does not sacrifice program performance, is based on Clang and is fully compatible with it.  <a href="http://lists.llvm.org/pipermail/cfe-dev/2015-May/043155.html">Here</a> you can learn how Zapcc works.  If your project is based on CMake, then replacing the compiler is very easy: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> CC=/path/to/zapcc <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> CXX=/path/to/zapcc++ cmake /path/to/CMakeDir</code> </pre> <br>  or so: <br><br><pre> <code class="cpp hljs">cmake -DCMAKE_C_COMPILER=/path/to/zapcc \ -DCMAKE_CXX_COMPILER=/path/to/zapcc++ \ /path/to/CMakeDir</code> </pre> <br>  If your OS uses the ELF format of object files (Unix-like systems), then you can replace the GNU ld linker with GNU gold.  GNU gold comes as part of binutils, starting with version 2.19, and is activated with the <i>-fuse-ld = gold</i> flag.  In CMake, you can activate it, for example, with the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UNIX AND NOT APPLE) execute_process(COMMAND ${CMAKE_CXX_COMPILER} -fuse-ld=gold -Wl,--version ERROR_QUIET OUTPUT_VARIABLE ld_version) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"${ld_version}"</span></span> MATCHES <span class="hljs-string"><span class="hljs-string">"GNU gold"</span></span>) message(STATUS <span class="hljs-string"><span class="hljs-string">"Found Gold linker, use faster linker"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CMAKE_EXE_LINKER_FLAGS <span class="hljs-string"><span class="hljs-string">"${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=gold"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CMAKE_SHARED_LINKER_FLAGS <span class="hljs-string"><span class="hljs-string">"${CMAKE_SHARED_LINKER_FLAGS} -fuse-ld=gold "</span></span>) endif() endif()</code> </pre> <br><h3>  Using SSD / RAMDisk </h3><br>  The obvious bottleneck in the assembly is the speed of disk operations (especially random access).  Transferring temporary files of a project or oneself to faster memory (HDD with increased random access speed, SSD, RAID from HDD / SSD, RAMDisk) can help a lot in some situations. <br><br><h3>  Modular system in C ++ </h3><br>  Most of the above methods have historically arisen due to the choice of the principle of translation of C / C ++ languages.  The mechanism of header files, despite its apparent simplicity, causes a lot of trouble for C / C ++ programmers. <br><br>  For quite a long time there has been a discussion about the inclusion of modules in the C ++ standard (and, possibly, will appear in C ++ 20).  <i>A module</i> will be considered an associated set of translation units ( <i>modular unit</i> ) with a specific set of external (exported) names, called <i>module interfaces</i> .  The module will be available to all translation units importing it <b>only</b> through its interface.  Non-exported names are placed in the <i>implementation of the module</i> . <br><br>  Another important advantage of modules is that they are not subject to change through macros and preprocessor directives, unlike header files.  The reverse is also true: macros and preprocessor directives inside a module do not affect translation units that import it.  Semantically, modules are independent, fully compiled translation units. <br><br>  This article will not consider in detail the device of future modules.  If you want to know more about them, then we recommend viewing Boris Kolpakov‚Äôs <i>speech</i> at <i>CppCon 2017</i> on C ++ modules (the difference in <i>build</i> time is also shown there): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E8EbDcLQAoc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  At present, <a href="https://blogs.msdn.microsoft.com/vcblog/2017/05/05/cpp-modules-in-visual-studio-2017/">MSVC</a> , <a href="https://gcc.gnu.org/wiki/cxx-modules">GCC</a> , <a href="https://clang.llvm.org/docs/Modules.html">Clang compilers</a> offer experimental support for modules. <br><br><h2>  And will there be anything about the build of PVS-Studio? </h2><br>  In this section, let's look at how effective and useful the approaches described are. <br><br>  Take the core of the PVS-Studio analyzer for analyzing C and C ++ code.  It is, of course, written in C ++ and is a console application.  The kernel is a small project compared to such giants as LLVM / Clang, GCC, Chromium, etc.  Here, for example, that produces CLOC on our code base: <br><br><pre> <code class="cpp hljs">---------------------------------------------------------------- Language files blank comment code ---------------------------------------------------------------- C++ <span class="hljs-number"><span class="hljs-number">380</span></span> <span class="hljs-number"><span class="hljs-number">28556</span></span> <span class="hljs-number"><span class="hljs-number">17574</span></span> <span class="hljs-number"><span class="hljs-number">150222</span></span> C/C++ Header <span class="hljs-number"><span class="hljs-number">221</span></span> <span class="hljs-number"><span class="hljs-number">9049</span></span> <span class="hljs-number"><span class="hljs-number">9847</span></span> <span class="hljs-number"><span class="hljs-number">46360</span></span> Assembly <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">298</span></span> ---------------------------------------------------------------- SUM: <span class="hljs-number"><span class="hljs-number">602</span></span> <span class="hljs-number"><span class="hljs-number">37618</span></span> <span class="hljs-number"><span class="hljs-number">27443</span></span> <span class="hljs-number"><span class="hljs-number">196880</span></span> ----------------------------------------------------------------</code> </pre> <br>  Note that before doing any work, our project was going in 1.5 minutes (parallel compilation and one precompiled header were used) on the following configuration of the working machine: <br><br><ul><li>  Intel Core i7-4770 3.4 GHz processor (8 CPU). </li><li>  RAM 16 Gb RAM DDR3-1333 MHz. </li><li>  Samsung SSD 840 EVO 250 Gb as a system drive. </li><li>  WDC WD20EZRX-00D8PB0 2 Tb for work needs. </li></ul><br>  We take as a starting point the assembly of the project on the HDD, turning off all the optimization of the build time.  Further we will designate the first stage of measurements: <br><br><ul><li>  assembly on HDD, compilation in 1 stream, without optimizations; </li><li>  assembly on SSD, compilation in 1 stream, without optimizations; </li><li>  assembly on RAMDisk, compilation in 1 stream, without optimizations. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/708/f09/beb/708f09beb1e2c29328569cbb6621e8bf.png" alt="Figure 1. Assembly of the PVS-Studio analyzer, 1 stream, without optimizations.  Above - build Debug version, below - Release."></div><br>  <font color="#999999"><i>Figure 1. Assembly of the PVS-Studio analyzer, 1 stream, without optimizations.</i></font> <font color="#999999"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above - build Debug version, below - Release. </font></font></i></font> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the diagram, due to the higher speed of random access, a project on RAMDisk without optimizations gathers in 1 stream faster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second stage of measurements - we modify the source code with a file: remove unnecessary inclusions of headers, eliminate dependencies on the definition, improve the precompiled header (remove frequently changed headers from it) - and gradually fasten the optimization:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compilation in 1 stream, project on HDD, SSD and RAMDisk: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> single compilation units (SCU); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precompiled header (PCH); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> single compilation units + precompiled header (SCU + PCH). </font></font></li></ul><br></li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42e/125/416/42e1254163c8e84510220a68e176eef4.png" alt="Figure 2. Compilation in 1 stream after optimizations."></div><br> <font color="#999999"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2. Compilation in 1 stream after optimizations.</font></font></i></font> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compilation in 4 streams, project on HDD, SSD, RAMDisk: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> single compilation units; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precompiled header; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> single compilation units + precompiled header </font></font></li></ul></li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/bcc/4e9/952bcc4e9bd58cd49f16c271e9b3702f.png" alt="Figure 3. Compilation in 4 threads after optimizations."></div><br> <font color="#999999"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3. Compilation in 4 threads after optimizations.</font></font></i></font> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8 streams compilation, HDD, SSD, RAMDisk project: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> single compilation units; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> precompiled header; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> single compilation units + precompiled header </font></font></li></ul><br></li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/721/38a/d6072138ab0c9589142812cbd700954f.png" alt="Figure 4. Compilation in 8 threads after optimizations."></div><br> <font color="#999999"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 4. Compilation in 8 threads after optimizations. </font></font></i></font> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We make brief conclusions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The benefits of using SSD / RAMDisk can vary depending on their model, random access speed, launch conditions, moon phases, etc. </font><font style="vertical-align: inherit;">Although they are faster analogues HDD, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specifically in our case,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> they do not give a significant gain.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precompiled headers are a very effective tool. </font><font style="vertical-align: inherit;">This method was previously used in our analyzer, and its use, even when compiled into 1 stream, gave 7-8 times the acceleration.</font></font></li><li>       (SCU)     .   ,        (&gt; 10). </li></ul><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For many programmers, C / C ++ languages ‚Äã‚Äãare associated as something ‚Äúlong compiled.‚Äù And there are some reasons for this: the broadcast method chosen at one time, metaprogramming (for C ++), thousands of them. Thanks to the described optimization methods, you can deprive yourself of such prejudices about excessively long compilation. In particular, the build time of our PVS-Studio analyzer core for analyzing C and C ++ code was reduced from 1 minute 30 seconds to 40 seconds by integrating Single Compilation Units and processing header and source files. Moreover, if parallel compilation and precompiled headers were not used before the start of optimizations, we would have received a sevenfold reduction in build time!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the end, I would like to add that this problem is well remembered in the standardization committee and the solution to this problem is in full swing: we are all waiting for the C ++ 20 standard, which may be one of the innovations that will bring modules into many people‚Äôs favorite language and make life C ++ programmers are much simpler. </font></font></div><p>Source: <a href="https://habr.com/ru/post/344534/">https://habr.com/ru/post/344534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344522/index.html">Tutorial on the Unreal Engine. Part 3: materials</a></li>
<li><a href="../344524/index.html">Case analysis about backup verification (SureBackup) and using vSAN</a></li>
<li><a href="../344526/index.html">C / C ++ application development using Tcl / Tk</a></li>
<li><a href="../344528/index.html">How to segment users for different verticals</a></li>
<li><a href="../344530/index.html">cBackup - backup network equipment configurations</a></li>
<li><a href="../344536/index.html">Designing a site that is protected from blocking</a></li>
<li><a href="../344538/index.html">How I realized what distributed systems are</a></li>
<li><a href="../344540/index.html">Are you still Java code? It's time to change</a></li>
<li><a href="../344542/index.html">The human factor in information security</a></li>
<li><a href="../344546/index.html">What hurts a business?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>