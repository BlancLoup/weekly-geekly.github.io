<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code Generation in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Rob Pike from the official Go blog on automatic code generation using go generate. The article is a bit outdated (it was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code Generation in Go</h1><div class="post__text post__text-html js-mediator-article">  Translation of the article by Rob Pike from the official Go blog on automatic code generation using go generate.  The article is a bit outdated (it was written before the release of Go 1.4, in which go generate appeared), but it explains go generate well. <br><a name="habracut"></a><br>  One of the properties of the theory of computability - Turing completeness - is that a program can write another program.  This is a powerful idea that is not as appreciated as it deserves, although it occurs quite often.  This is quite a significant part of the definition of what compilers do, for example.  Also, the <b>go test</b> command also works on the same principle: it scans the packages that need to be tested, creates a new Go program in which the necessary body kit for the tests is added, then compiles and runs it.  Modern computers are so fast that such a seemingly expensive sequence of actions is executed in a split second. <br><br>  There are plenty of other examples where programs write programs.  <a href="http://golang.org/cmd/yacc/">Yacc</a> , for example, reads a grammar description and produces a program that parses this grammar.  The ‚Äúcompiler‚Äù Protocol Buffers reads the interface description and provides definitions for structures, methods, and other code.  A variety of configuration utilities work in a similar way, extracting metadata from the environment and creating custom launch commands. <br><br>  Thus, programs that write programs are an important element in software development, but programs like Yacc that create source code must be integrated into the build process so that their output can be passed to the compiler.  When an external build system is used, like Make, this is usually easy to do.  But in Go, in which the go utility gets all the necessary information about the build from the source code, this is a problem.  It simply has no mechanism to start Yacc with the go tool. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Up to this point, in a sense. <br><br>  The latest release of Go, 1.4, includes a new command, go generate, which allows you to run these utilities.  It's called <b>go generate</b> , and when it starts, it scans the code for special comments that indicate which commands to run.  It is important to understand that <i>go generate is</i> not part of <i>go build</i> .  It does not analyze dependencies and must be run before go build.  It is intended for the author of the Go package, and not for its users. <br><br>  The go generate command is very easy to use.  To warm up, here‚Äôs how to use it to generate a Yacc grammar.  Let's say you have an input Yacc file, called gopher.y, that defines the grammar of your new language.  To generate Go code to parse this grammar, you would usually run the standard go version of yacc, like this: <br><pre><code class="bash hljs">go tool yacc -o gopher.go -p parser gopher.y</code> </pre> <br>  The -o option here specifies the name of the resulting file, and -p - the name of the package. <br><br>  To shift this process to go generate, you need to add a comment in any ordinary (non-autogenerated) .go file in this directory: <br> <code>//go:generate go tool yacc -o gopher.go -p parser gopher.y</code> <br> <br>  This text is the same command, but with a comment added at the beginning that go generate recognizes.  The comment should begin at the beginning of the line and have no spaces between // and go: generate.  After this marker, the remainder indicates which go generate command should run. <br><br>  Now run it.  Go to the source directory and run go generate, then go build and so on: <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/myrepo/gopher $ go generate $ go build $ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  And that's all you need.  If there are no errors, then go generate will call yacc, which will create gopher.go, at this point the directory will contain all the necessary go-files that we can collect, test and work with them normally.  Every time gopher.y changes, just restart go generate to re-create the parser. <br><br>  If you are interested in more details on how go generate works inside, including parameters, environment variables, and so on, see the <a href="http://golang.org/s/go1.4-generate">design document</a> . <br><br>  Go generate does nothing that could not be done using Make or another build mechanism, but it comes out of the box in the go command ‚Äî you don‚Äôt need to install anything further ‚Äî and it fits well with the Go ecosystem.  Most importantly, remember that this is for the authors of the package, not for users, at least for the reason that the program that will be called may be absent on the user's machine.  Also, if the package is supposed to be used with go get, do not forget to transfer the generated files to the version control system, making them available to users. <br><br>  Now, let's see how you can use this for something new.  As a radically different example where go generate can help, there is a new stringer program in golang.org/x/tools repository.  It automatically generates String () string methods for sets of numeric constants.  It is not included in the standard Go set, but it is easy to install: <br><pre> <code class="bash hljs">$ go get golang.org/x/tools/cmd/stringer</code> </pre> <br>  Here is an example from the <a href="http://godoc.org/golang.org/x/tools/cmd/stringer">stringer</a> documentation.  Imagine that we have some code, with a set of numeric constants defining different types of drugs: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> painkiller <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Pill <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Placebo Pill = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> Aspirin Ibuprofen Paracetamol Acetaminophen = Paracetamol )</code> </pre> <br>  For debugging purposes, we would like these constants to give their name nicely, in other words, we want a method with the following signature: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p Pill)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span></code> </pre> <br>  It is easy to write it manually, for example, something like this: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p Pill)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> p { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Placebo: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Placebo"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Aspirin: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Aspirin"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Ibuprofen: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ibuprofen"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Paracetamol: <span class="hljs-comment"><span class="hljs-comment">// == Acetaminophen return "Paracetamol" } return fmt.Sprintf("Pill(%d)", p) }</span></span></code> </pre> <br>  There are several ways to write this function, of course.  We can use a slice of lines indexed by Pill, or a map, or some other technique.  One way or another, we must maintain it every time we change a set of medications, and we must verify that the code is correct.  (Two different names for paracetamol, for example, make this code a bit more tricky than it could be).  Plus, the very question of choosing a method of implementation depends on the types of values: signed or unsigned, dense and scattered, starting from zero or not, and so on. <br><br>  The stringer program takes care of this.  Although it can be started manually, it is intended to run through go generate.  To use it, add a comment to the source, most likely in code with a type definition: <br> <code>//go:generate stringer -type=Pill</code> <br>  This rule indicates that go generate must run the stringer command to generate the String method for the Pill type.  The output will automatically be written to the pill_string.go file (the output can be redefined using the -output flag). <br><br>  Let's run it: <br><pre> <code class="bash hljs">$ go generate $ cat pill_string.go // generated by stringer -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pill pill.go; DO NOT EDIT package pill import <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> const _Pill_name = <span class="hljs-string"><span class="hljs-string">"PlaceboAspirinIbuprofenParacetamol"</span></span> var _Pill_index = [...]uint8{0, 7, 14, 23, 34} func (i Pill) String() string { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; 0 || i+1 &gt;= Pill(len(_Pill_index)) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Pill(%d)"</span></span>, i) } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> _Pill_name[_Pill_index[i]:_Pill_index[i+1]] } $</code> </pre> <br>  Every time we change the definition of Pill or constants, all we have to do is run <br><pre> <code class="bash hljs">$ go generate</code> </pre> <br>  to update the String method.  And of course, if we have several types in one package that need to be updated, go generate will update them all. <br><br>  It goes without saying that the generated code is ugly.  This is OK, however, since people will not work with this code;  auto-generated code is often ugly.  He tries to be as effective as possible.  All names are combined together in one line, which saves memory (just one line for all names, even there are a myriad of them).  Then the array, _Pill_index, finds a type matching with the name using a simple and very efficient technique.  Notice that _Pill_index is an array (not a slice; one header is smaller) of values ‚Äã‚Äãof type uint8, the smallest possible integer type capable of containing the desired values.  If there are more values, or are negative, the type of the generated _Pill_index array may change to uint16 or int8, depending on what works best. <br><br>  The approach used in the methods generated by the stringer varies, depending on the properties of the set of constants.  For example, if the constants are discharged, it can use map.  Here is a simple example based on a set of constants representing powers of two: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _Power_name = <span class="hljs-string"><span class="hljs-string">"p0p1p2p3p4p5..."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _Power_map = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[Power]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span>: _Power_name[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>: _Power_name[<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>: _Power_name[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>], <span class="hljs-number"><span class="hljs-number">8</span></span>: _Power_name[<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>: _Power_name[<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>], <span class="hljs-number"><span class="hljs-number">32</span></span>: _Power_name[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>], ..., } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i Power)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> str, ok := _Power_map[i]; ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Power(%d)"</span></span>, i) }</code> </pre> <br>  In summary, the automatic generation of the method allows us to solve the problem better than a human would. <br><br>  Go source has a ton of other examples of using go generate.  This includes generating Unicode tables in the unicode package, creating efficient methods for encoding and decoding arrays in encoding / gob, creating a timezone data set in the time package, and the like. <br><br>  Please use go generate creatively.  He is here to encourage experimentation. <br><br>  And even if not, use stringer to add String methods to your numeric constants.  Let the computer do the work for you. </div><p>Source: <a href="https://habr.com/ru/post/269887/">https://habr.com/ru/post/269887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269873/index.html">Digest: What we taught the search for this summer</a></li>
<li><a href="../269875/index.html">Sort without if</a></li>
<li><a href="../269879/index.html">The future of the Web is very much like Bitcoin</a></li>
<li><a href="../269883/index.html">User Documentation and GitHub</a></li>
<li><a href="../269885/index.html">Pony is a killer ...?</a></li>
<li><a href="../269889/index.html">PostgreSQL Evangelist Memo: Replicants vs. Replication</a></li>
<li><a href="../269893/index.html">Pure architecture in a go app. Part 1</a></li>
<li><a href="../269895/index.html">How I did the web version of KeePass</a></li>
<li><a href="../269897/index.html">Automatic generation of microcontroller software code based on event-oriented model</a></li>
<li><a href="../269899/index.html">Lua 5.3 Reference Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>