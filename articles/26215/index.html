<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript Task Scheduler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 

 Sometimes on the client side, you need to perform background tasks. The main requirement is that they do not interrupt the work of the entir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript Task Scheduler</h1><div class="post__text post__text-html js-mediator-article">  Hello. <br><br>  Sometimes on the client side, you need to perform background tasks.  The main requirement is that they do not interrupt the work of the entire web application, but quietly in the background communicated with each other, ended and added.  The goal of the proposed scheduler is to remove from the developer a headache about such tasks and reduce to a common interface, with which you can gradually expand the range of tasks to be solved. <br><a name="habracut"></a><br>  You can ask, what are the tasks and what for?  There are actually a lot of tasks on the client: this is a periodic change of the session identifier (for example, an email client updating the identifier in the background), and automatic scrolling (for example, scrolling the card), moving an object in the graphical interface, and processing multiple requests from the client to the server (for example, information is requested from the server via XHR, many such requests, hence many XHR objects, and this is already a heavy load on the browser), this is a sample of data from the iframe in the case of JSRS based on it.  The basis of the proposed scheduler is the setInterval and clearInterval functions.  It is around them that everything will spin.  But simply the functions themselves are not enough, it is necessary to abstract the very concept of the task and propose an interface.  And make a scheduler who will manage tasks. <br><br>  To implement a class of tasks, we need to introduce the concept of flags, in which we will store the task states. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  <font color="black">HClass.Define ( <font color="#A31515">"HFlag"</font> , {extend: HCore.Object, <font color="#0000ff">static</font> : {</font> <font color="black"><br><br></font>  <font color="black">MAX_FLAG_VALUE: 65535</font> <font color="black"><br><br></font>  <font color="black">}, props: {</font> <font color="black"><br><br></font>  <font color="black">dwFlag: <font color="#0000ff">null</font> ,</font> <font color="black"><br><br></font>  <font color="black">construct: function (dwFlag) { <font color="#0000ff">this</font> .Add (dwFlag);</font>  <font color="black"><font color="#0000ff">return</font> <font color="#0000ff">this</font> ;</font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">Set: function (dwFlag) { <font color="#0000ff">this</font> .dwFlag = dwFlag;</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Get: function () { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .dwFlag;</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Add: function (dwFlag) { <font color="#0000ff">this</font> .dwFlag | = dwFlag;</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Zero: function (dwFlag) { <font color="#0000ff">this</font> .dwFlag &amp; = (HFlag.MAX_FLAG_VALUE - dwFlag);</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Check: function (dwFlag) { <font color="#0000ff">return</font> !! ( <font color="#0000ff">this</font> .dwFlag &amp; dwFlag);</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Swap: function (dwNew, dwOld) { <font color="#0000ff">this</font> .Zero (dwOld);</font>  <font color="black"><font color="#0000ff">this</font> .Add (dwNew);</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Clear: function () { <font color="#0000ff">this</font> .Set (0);</font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black">}});</font>  <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  In this class, a standard set of methods for working with flags. <br><br>  Next comes excerpts from the HSheduler class, namely the methods of adding a task and deleting RunTask ‚Äî launching the task via setInterval, RemoveTask ‚Äî deleting via clearInterval: <br><br><blockquote>  <font color="black">RunTask: function (pTask) {</font> <font color="black"><br></font>  <font color="black">pTask.nTaskId = <font color="#0000ff">this</font> .nTotalTasks;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .aTaskHeap [ <font color="#0000ff">this</font> .nTotalTasks ++] = pTask;</font> <font color="black"><br></font>  <font color="black">pTask.nTimerId = setInterval ( <font color="#A31515">"HSheduler.aTaskHeap ["</font> + pTask.nTaskId + <font color="#A31515">"] .Cycle ()"</font> , pTask.nCycleTimeout);</font> <font color="black"><br></font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">RemoveTask: function (pTask) {</font> <font color="black"><br></font>  <font color="black">clearInterval (pTask.nTimerId);</font> <font color="black"><br></font>  <font color="black">delete <font color="#0000ff">this</font> .aTaskHeap [pTask.nTaskId];</font> <font color="black"><br></font>  <font color="black">}</font> <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  The main thing here is working with the setInterval and clearInterval functions. <br>  The RunTask function has the string <b>setInterval ("HSheduler.aTaskHeap [" + pTask.nTaskId + "] .Cycle ()", pTask.nCycleTimeout);</b>  where we establish that the task will be called (more precisely the Cycle method, the current task) with its identifier from the heap of tasks, with the interval specified in the task.  These are the basic scheduler methods.  Let us turn to the task and see what the task should do in general: <br><br>  1. It must have some kind of input data. <br>  2. Tasks have solution algorithms. <br>  3. Tasks produce a result (it is also possible to realize the possibility of obtaining intermediate results). <br><br>  Additionally, you must add task states.  The task can be: <br><br>  1. Initialize (preliminary calculation of derived parameters, create objects if needed) - state <b>SF_Ready</b> . <br>  2. To execute (calculation of the result according to the specified input and derived parameters) - the state <b>SF_Process</b> . <br>  3. End (by the condition of obtaining or the impossibility of obtaining a result) - the state <b>SF_Remove</b> . <br>  4. Suspend - <b>SF_Wait</b> (you can use if intermediate results are not needed and there is an event from the outside that will reset this state, for example, waiting for a response from the server). <br>  5. Skip one cycle - <b>SF_SkipCycle</b> (analog SF_Wait, but the state is reset automatically). <br><br>  Using this set of states, you can implement many tasks, and which you can not, then no one bothers to add additional new states.  Below are excerpts from the HBaseTask class.  The main method from this class is Cycle, it is called via setInterval: <br><br><blockquote>  <font color="black">Cycle: function () {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (! <font color="#0000ff">this</font> .pStaticAddress) <font color="#0000ff">return</font> ;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> ( <font color="#0000ff">this</font> .oStateFlags.Check (HBaseTask.SF_Remove)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .Remove ();</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">return</font> ;</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (! <font color="#0000ff">this</font> .oStateFlags.Check (HBaseTask.SF_Wait)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (! <font color="#0000ff">this</font> .oStateFlags.Check (HBaseTask.SF_SkipCycle)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .pStaticAddress.apply ( <font color="#0000ff">this</font> , <font color="#0000ff">this</font> .oTaskParams);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .nCyclesCount ++;</font> <font color="black"><br></font>  <font color="black">} <font color="#0000ff">else</font> <font color="#0000ff">this</font> .oStateFlags.Zero (HBaseTask.SF_SkipCycle);</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .oStateFlags.Zero (HBaseTask.SF_SetParams);</font> <font color="black"><br></font>  <font color="black">}</font> <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  The variable this.pStaticAddress contains the algorithm of the problem, a trite function, it is called every new cycle.  The most important thing here is that the algorithm must be executed in the context of the task object so that from it there is access to the methods of the HBaseTask class: <br>  <b>this.pStaticAddress.apply (this, this.oTaskParams);</b> <br>  Now, from the task algorithm, you can access the task states (write, read, and check states).  In addition, the parameters of the task are passed through apply to the algorithm.  Parameters are set via the Params method.  Below is the full implementation of the HSheduler scheduler and the HBaseTask base task class: <br><br><blockquote>  <font color="black"><font color="#008000">//</font></font> <font color="black"><br></font>  <font color="black"><font color="#008000">// Sheduler.</font></font> <font color="black"><br></font>  <font color="black"><font color="#008000">//</font></font> <font color="black"><br><br></font>  <font color="black">HClass.Define ( <font color="#A31515">"HSheduler"</font> , { <font color="#0000ff">static</font> : {</font> <font color="black"><br><br></font>  <font color="black">nTotalTasks: 0,</font> <font color="black"><br></font>  <font color="black">aTaskHeap: [],</font> <font color="black"><br><br></font>  <font color="black">RunTask: function (pTask) {</font> <font color="black"><br></font>  <font color="black">pTask.nTaskId = <font color="#0000ff">this</font> .nTotalTasks;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .aTaskHeap [ <font color="#0000ff">this</font> .nTotalTasks ++] = pTask;</font> <font color="black"><br></font>  <font color="black">pTask.nTimerId = setInterval ( <font color="#A31515">"HSheduler.aTaskHeap ["</font> + pTask.nTaskId + <font color="#A31515">"] .Cycle ()"</font> , pTask.nCycleTimeout);</font> <font color="black"><br></font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">RemoveTask: function (pTask) {</font> <font color="black"><br></font>  <font color="black">clearInterval (pTask.nTimerId);</font> <font color="black"><br></font>  <font color="black">delete <font color="#0000ff">this</font> .aTaskHeap [pTask.nTaskId];</font> <font color="black"><br></font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">//</font></font> <font color="black"><br></font>  <font color="black"><font color="#008000">// Base Task.</font></font> <font color="black"><br></font>  <font color="black"><font color="#008000">//</font></font> <font color="black"><br><br></font>  <font color="black">HBaseTask: HClass.Define ( <font color="#A31515">"HBaseTask"</font> , {extend: HProcess, <font color="#0000ff">static</font> : {</font> <font color="black"><br><br></font>  <font color="black">TF_Nothing: 0,</font> <font color="black"><br></font>  <font color="black">TF_FireRun: 1,</font> <font color="black"><br><br></font>  <font color="black">SF_Null: 0,</font> <font color="black"><br></font>  <font color="black">SF_Ready: 1,</font> <font color="black"><br></font>  <font color="black">SF_Process: 2,</font> <font color="black"><br></font>  <font color="black">SF_SetParams: 4,</font> <font color="black"><br></font>  <font color="black">SF_SkipCycle: 8,</font> <font color="black"><br></font>  <font color="black">SF_Remove: 16,</font> <font color="black"><br></font>  <font color="black">SF_Wait: 32</font> <font color="black"><br><br></font>  <font color="black">}, props: {</font> <font color="black"><br><br></font>  <font color="black">oTaskFlags: <font color="#0000ff">null</font> ,</font> <font color="black"><br></font>  <font color="black">oStateFlags: <font color="#0000ff">null</font> ,</font> <font color="black"><br></font>  <font color="black">oTaskParams: <font color="#0000ff">null</font> ,</font> <font color="black"><br></font>  <font color="black">nTaskId: <font color="#0000ff">null</font> ,</font> <font color="black"><br></font>  <font color="black">nTimerId: <font color="#0000ff">null</font> ,</font> <font color="black"><br></font>  <font color="black">nCycleTimeout: 1000,</font> <font color="black"><br></font>  <font color="black">nCyclesCount: 0,</font> <font color="black"><br></font>  <font color="black">nCyclesLimit: 0,</font> <font color="black"><br><br></font>  <font color="black">construct: function (fCode) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .oTaskFlags = <font color="#0000ff">new</font> HFlag (HBaseTask.TF_Nothing);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .oStateFlags = <font color="#0000ff">new</font> HFlag (HBaseTask.SF_Ready);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .nCycleTimeout = 1000;</font>  <font color="black"><font color="#008000">// ms.</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .nCyclesCount = 0;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .nCyclesLimit = 0;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (fCode) <font color="#0000ff">this</font> .Create (fCode);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">return</font> <font color="#0000ff">this</font> ;</font> <font color="black"><br></font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">Run: function () {HSheduler.RunTask ( <font color="#0000ff">this</font> );</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">Remove: function () {HSheduler.RemoveTask ( <font color="#0000ff">this</font> );</font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">Params: function () {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .oTaskParams = arguments;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .oStateFlags.Add (HBaseTask.SF_SetParams);</font> <font color="black"><br></font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">CycleTimeout: function (nCycleTimeout) { <font color="#0000ff">this</font> .nCycleTimeout = nCycleTimeout;</font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">Cycle: function () {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (! <font color="#0000ff">this</font> .pStaticAddress) <font color="#0000ff">return</font> ;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> ( <font color="#0000ff">this</font> .oStateFlags.Check (HBaseTask.SF_Remove)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .Remove ();</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">return</font> ;</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (! <font color="#0000ff">this</font> .oStateFlags.Check (HBaseTask.SF_Wait)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (! <font color="#0000ff">this</font> .oStateFlags.Check (HBaseTask.SF_SkipCycle)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .pStaticAddress.apply ( <font color="#0000ff">this</font> , <font color="#0000ff">this</font> .oTaskParams);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .nCyclesCount ++;</font> <font color="black"><br></font>  <font color="black">} <font color="#0000ff">else</font> <font color="#0000ff">this</font> .oStateFlags.Zero (HBaseTask.SF_SkipCycle);</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .oStateFlags.Zero (HBaseTask.SF_SetParams);</font> <font color="black"><br></font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">AddState: function (dwFlag) { <font color="#0000ff">this</font> .oStateFlags.Add (dwFlag);</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">SwapState: function (dwNew, dwOld) { <font color="#0000ff">this</font> .oStateFlags.Swap (dwNew, dwOld);</font>  <font color="black">},</font> <font color="black"><br></font>  <font color="black">GetState: function () { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .oStateFlags;</font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black">}})</font> <font color="black"><br></font>  <font color="black">}});</font>  <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  With this class, you can very easily create tasks running in the background and doing something.  Here are some simple examples: <br><br><blockquote>  <font color="black"><font color="#008000">// Example of a simple task, it will work in a loop.</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">var</font> pTask = HBaseTask (function () {alert ( <font color="#A31515">"Hello world!"</font> )}};</font> <font color="black"><br></font>  <font color="black">pTask.Run ();</font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// Example of a task receiving parameters.</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">var</font> pTask = HBaseTask (function (a, b) {alert (a + <font color="#A31515">""</font> + b);});</font> <font color="black"><br></font>  <font color="black">pTask.Params (32, 128);</font> <font color="black"><br></font>  <font color="black">pTask.Run ();</font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// Example of the task managing states.</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">var</font> pTask = HBaseTask (function () {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">var</font> oState = <font color="#0000ff">this</font> .GetState ();</font>  <font color="black"><font color="#008000">// Take the current state.</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (oState.Check (HBaseTask.SF_Ready)) {</font> <font color="black"><br></font>  <font color="black"><font color="#008000">// Here we prepare derived variables or create the necessary objects, for example XHR.</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .SwapState (HBaseTask.SF_Process, HBaseTask.SF_Ready);</font> <font color="black"><br></font>  <font color="black">} <font color="#0000ff">else</font> <font color="#0000ff">if</font> (oState.Check (HBaseTask.SF_Process)) {</font> <font color="black"><br></font>  <font color="black"><font color="#008000">// Here we consider something, and if we get the result, go to the end state</font></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .SwapState (HBaseTask.SF_Remove, HBaseTask.SF_Process);</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black">});</font> <font color="black"><br></font>  <font color="black">pTask.Run ();</font>  <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  But the most important thing is that an abstract concept of a problem has appeared, and it is possible to make derivative, highly specialized tasks.  Below is an example of implementing a linear interpolation calculation (can be used to move along the line of an object, for example, to scroll a map from point A to point B).  The formula for calculating F (t) = t1 + t * (t2 - t1).  For scrolling, it is necessary to obtain an intermediate result, so you will need to add a callback function.  Here is the class itself, it is inherited from HBaseTask: <br><br><blockquote>  <font color="black">HClass.Define ( <font color="#A31515">"HLerpTask"</font> , {extend: HBaseTask, props: {</font> <font color="black"><br><br></font>  <font color="black">fStart: 0, fEnd: 0,</font> <font color="black"><br></font>  <font color="black">fStep: 0, fT: 0,</font> <font color="black"><br></font>  <font color="black">fRange: 0,</font> <font color="black"><br></font>  <font color="black">fCallback: <font color="#0000ff">null</font> ,</font> <font color="black"><br><br></font>  <font color="black">EvalLerp: function () { <font color="#0000ff">return</font> <font color="#0000ff">this</font> .fStart + <font color="#0000ff">this</font> .fT * <font color="#0000ff">this</font> .fRange;</font>  <font color="black">},</font> <font color="black"><br><br></font>  <font color="black">construct: function (fStart, fEnd, fStep, fCallback) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fStart = fStart;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fEnd = fEnd;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fStep = fStep;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fCallback = fCallback;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .CycleTimeout (10);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .Create (function () {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">var</font> oState = <font color="#0000ff">this</font> .GetState ();</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> (oState.Check (HBaseTask.SF_Ready)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fT = 0;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fRange = <font color="#0000ff">this</font> .fEnd - <font color="#0000ff">this</font> .fStart;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .SwapState (HBaseTask.SF_Process, HBaseTask.SF_Ready);</font> <font color="black"><br></font>  <font color="black">} <font color="#0000ff">else</font> <font color="#0000ff">if</font> (oState.Check (HBaseTask.SF_Process)) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fT + = <font color="#0000ff">this</font> .fStep;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> ( <font color="#0000ff">this</font> .fT&gt; = 1.0) {</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .fT = 1.0;</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">this</font> .SwapState (HBaseTask.SF_Remove, HBaseTask.SF_Process);</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if</font> ( <font color="#0000ff">this</font> .fCallback) <font color="#0000ff">this</font> .fCallback ( <font color="#0000ff">this</font> .EvalLerp ());</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black">});</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br></font>  <font color="black">}});</font>  <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  Here is an example of use, two calculators are created and intermediate results are written to divs, while the application itself is available ie.  user can interact with other functionality: <br><br><blockquote>  <font color="black">function GE (sId) { <font color="#0000ff">return</font> document.getElementById (sId);</font>  <font color="black">}</font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">var</font> pTask = <font color="#0000ff">new</font> HLerpTask (0, 100, 0.001, function (fRet) {GE ( <font color="#A31515">"counter1"</font> ) .innerHTML = fRet;});</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">var</font> pTask2 = <font color="#0000ff">new</font> HLerpTask (0, 1000, 0.0005, function (fRet) {GE ( <font color="#A31515">"counter2"</font> ) .innerHTML = fRet;});</font> <font color="black"><br><br></font>  <font color="black">pTask.Run ();</font> <font color="black"><br></font>  <font color="black">pTask2.Run ();</font>  <font color="gray">* This source code was highlighted with <a href="http://poison.qsh.ru/"><font color="gray">Source Code Highlighter</font></a> .</font> </blockquote><br>  You can also do other types of tasks, implementing unique logic necessary for the work of a specialized task in derived classes, but at the same time without departing from the interface of the basic task, which is very important when another developer starts working with your module, he is essentially aware of everything, only need to know what input and output parameters. <br><br>  Nestoit neglect seemingly inconspicuous at first glance functions like setInterval and clearInterval, because on their basis you can make really interesting decisions. <br><br>  PS The solutions proposed in this article and in the previous one concerning the dynamic loading of scripts are implemented in the project <a href="http://www.okarta.ru/">www.okarta.ru</a> , this is essentially an experimental project, all logic has been moved to the client, the server does not generate anything from the interface, there are only data requests from the client to the server (SOAP), by the way, the scheduler is great for requests.  To download maps and blogs, use the application builder. <br><br>  PPS If it doesn‚Äôt work somewhere, then this is not a problem in the proposed implementations, my task is to suggest entities, they are not at the browser level, if where errors occur, it‚Äôs only where native functions are called to work with XML or document elements, styles, etc.  All the same, it is necessary to understand that there are different levels of abstraction the lower the level (ie, closer to the native functions), the higher the probability of error due to the fact that nobody likes standards, and vice versa the higher the level of abstraction the lower the probability of errors associated with native functions excluded. </div><p>Source: <a href="https://habr.com/ru/post/26215/">https://habr.com/ru/post/26215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262139/index.html">Stream API: universal intermediate operation</a></li>
<li><a href="../262141/index.html">Watson went to Wimbledon</a></li>
<li><a href="../262143/index.html">DevDay - open meetings for sociable IT people</a></li>
<li><a href="../262145/index.html">The rapid development of mobile advertising, Fallout Shelter for Android, CSR2 - and other news of the week for a mobile developer</a></li>
<li><a href="../262149/index.html">IT infrastructure of one state budget educational organization</a></li>
<li><a href="../262151/index.html">Compact installation of FreeBSD 10 for a certification authority</a></li>
<li><a href="../262155/index.html">Top 10 data mining algorithms in simple language</a></li>
<li><a href="../262163/index.html">Reliable storage and update of data in flash memory of STM32 and MSP430 microcontrollers</a></li>
<li><a href="../262167/index.html">Android WebView: actual problems and their solutions</a></li>
<li><a href="../262169/index.html">Consulo: Running Java code on the .NET platform using IKVM.NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>