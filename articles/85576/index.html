<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sort images by resolution ... on PowerShell scene</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once again, looking at the interestingness, curiosity and other things on Habr√©, I came across an article about how to use Python to clean up the orde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sort images by resolution ... on PowerShell scene</h1><div class="post__text post__text-html js-mediator-article"> Once again, looking at the interestingness, curiosity and other things on Habr√©, I came across an <a href="http://habrahabr.ru/blogs/python/85306">article</a> about how to use Python to clean up the order among the illustrations, which have a digital cemetery in almost all of us.  Since not so long ago, I had a share in image processing using PowerShell, I decided to make an illustrative comparison.  Indicative from the point of view to demonstrate some of the characteristic features of PowerShell to those who are not yet familiar with it or are only superficially familiar. <br><br>  Unfortunately, there is a strange situation with PowerShell, when a very powerful tool turns out to be overlooked by the public and definitely needs some popularization.  Especially since recently it has been included in Windows 7 and will soon be in workplaces with a considerable number of users.  And then there is such an excuse in the form of a laconic one, on the one hand, but interesting, on the other hand, of an administrative task to restore order in the information repositories.  So let's get started. <br><br><a name="habracut"></a>  I'll start with a small lyrical digression.  Even when you talk about such seemingly simple tools as command processors, you want something sublime.  And I think I found it.  You will laugh, but I have defined for myself the development under command processors as multi-paradigm.  The first paradigm is imperative.  We see it in almost all batch files and saw it in the example of the original Python problem.  Another paradigm is functional.  I called it that because of its similarity to the approach used in functional programming languages.  In everyday life, we know it as a command pipe, just a pipe and many other gentle terms :) In short, let me remind you how it looks, in a simple example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>X:\&gt; (dir /b folder1\*.txt &amp;&amp; dir /b folder2\*.txt) | find "text" | sort</code> <br> <br>  Here we see three instructions, separated by a vertical bar.  Each subsequent takes the results of the previous one, performs on them certain operations and sends the next command in the queue pipe.  In our example, the standard cmd.exe collects a list of text files from two folders using the first instruction.  This list is passed to the find command, which leaves only those strings that contain the substring "text" and are already sent to the sort command, which sorts them.  In functional programming languages, this might look like this: <br><br> <code>sort(find((dir /b folder1\*.txt &amp;&amp; dir /b folder2\*.txt), "text"))</code> <br> <br>  Is there any similarities?  In essence, every element of the pipe is akin to a function.  Just to the existing types of function entries (such as postfix, prefix and infix entries) was added one more - pipe record :) <br><br>  Despite the fact that the command pipes, as can be seen from the example, have been since the days of MS-DOS, I would like to separately thank the UNIX-community, which sounds strange, considering the origin of PowerShell in the Microsoft hubs.  But there is a simple explanation.  It is in UNIX-like systems that these mechanisms were elevated to the rank of art, allowing you to combine different teams into the most unusual and very useful combinations. <br><br>  It so happened that PowerShell got this one, in my opinion, a very good feature and combined it with another equally successful solution.  Unlike the transfer of strings in the command pipe of the same Linux, PowerShell operates with objects.  To make everything clearer, I propose to proceed with the implementation of the task.  We will do this, of course, using the "functional" approach through the pipe, for the imperative approach would differ little from what we already have in the case of implementation on Python.  And you want to compare not only the tools, but also paradigms. <br><br>  By virtue of the functionality of our approach, we divide the solution of the problem into some similarity of these very functions, and in our case, instructions, each of which performs some strictly defined role.  Separately, I‚Äôll note that I‚Äôll intentionally complicate the implementation a bit to show more PowerShell features.  In reality, something can be simplified, but something to get rid of. <br><br>  <b>Step 0</b> .  To begin, we describe some of the conditions of execution in general.  First of all, we are interested in input parameters and this is a good reason to consider working with variables in PowerShell. <br><br> <code>PS X:\&gt; $source="x:\folder\source" <br> PS X:\&gt; $target="x:\folder\target" <br> PS X:\&gt; $source, $target <br> x:\folder\source <br> x:\folder\target</code> <br> <br>  In the first line of the $ source variable, we defined as the value the source folder in which the pictures are located for further sorting.  We will place the sorted images in the destination folder $ target.  The third line simply says that it is necessary to output the values ‚Äã‚Äãof these variables to the console, which we see below.  Note that values ‚Äã‚Äãare not just quoted.  The fact is that the values ‚Äã‚Äãof variables are typed and so we defined them as strings.  In the absence of quotes, the processor will treat the text as a command and assign the variable the results of its execution.  For example: <br><br> <code>PS X:\&gt; $test=dir x:\folder\source <br> PS X:\&gt; $test.Length <br> <br> 10 <br> <br> PS X:\&gt; $test[0].GetType() <br> <br> IsPublic IsSerial Name BaseType <br> -------- -------- ---- -------- <br> True True DirectoryInfo System.IO.FileSystemInfo</code> <br> <br>  As a result of this command, the variable $ test will be a collection of objects in the specified folder.  The Length property that we used in the $ test.Length statement is the number of elements in the collection.  But $ test [0]. GetType () displays information about the type of the first element of the collection.  As you can see, this is not a simple string, but a certain DirectoryInfo.  Be the first to file a file - it would be FileInfo.  This is a very important illustration of what I said earlier and the fact that we will actively use it later - PowerShell does not send strings on a pipe, but objects of quite specific types. <br><br>  The next preparatory step is related to the fact that we will use the type of illustration, which is located in the System.Windows.Forms library, which is not loaded by default.  We need to give the PowerShell instruction to load it.  For example: <br><br> <code>PS X:\&gt; [void][reflection.assembly]::LoadWithPartialName("System.Windows.Forms")</code> <br> <br>  In general, there is another significant feature of PowerShell here that is the creation of any objects offered by .NET or COM.  Their name is legion, but this is a separate topic.  In this case, just take this string as given.  For this, we assume that the execution environment is ready. <br><br>  <b>Step 1.</b> After the conditions for the execution of the task are ready, we will begin by forming a list of files that pretend to be pictures.  The formulation of the problem is precisely this, for we proceed from the assumption that the file extension is useful information, but does not guarantee that the file is a picture.  In most cases, you will not need it, but as I said earlier - the decision is intentionally complicated.  So, we select all the files of the specified extensions in the specified folder and all its subfolders.  Our first step of the pipe will look like this: <br><br> <code>PS X:\&gt; dir $source -r -include *.jpg, *.png, *.gif</code> <br> <br>  The option "-r" means recursive directory traversal, in "-include" you can list the masks of the included files (or enumerate maxi excluded in the option "-exclude").  In response to this command, we will get a list of files. <br><br>  <b>Step 2.</b> The next element of the pipe we are trying to create for each file received from the previous instruction, is a raster image object.  This manual serves as an illustration to several PowerShell capabilities at once, but for clarity, let's begin with an example: <br><br> <code>PS X:\&gt; dir $source -r -include *.jpg, *.png, *.gif | select FullName, @{Name="Image"; Expression={New-Object System.Drawing.Bitmap $_.FullName}} -ErrorAction SilentlyContinue</code> <br> <br>  The first thing we see in the second instruction of the pipe is the select command.  Its purpose is to form new objects and pass them on.  To do this, select a comma-separated list of all the properties of the new object that interest us.  The first is FullName.  The property specified in this form means that we take it from the object that we got on the pipe and with the same name and value are transferred to the new object.  In our case, we are talking about the FullName property of the FileInfo class, which returns the full path to the file. <br><br>  The following construction is a bit more complicated.  It creates a new property, whose name is passed in Name, and the value in Expression.  As a value, we create an instance of the class describing the illustration (System.Drawing.Bitmap), passing it to the constructor the same FullName value with the location of the illustration file.  Separately note for yourself the difference in the syntax of accessing the FullName property.  The select statement does this in a simplified form.  In most other cases, the variable $ _ means an object passed to us by pipe, the property of which we can access through the dot and the name of the property. <br><br>  If the file we are going to work with is not a raster illustration, then an attempt to create a System.Drawing.Bitmap object would result in an error.  In order to ignore these errors, we added the ErrorAction option, which allows them to be ignored.  Note that this option is not unique to the select command, but refers to the category of so-called Common Parameters, which you can use in almost any other instructions. <br><br>  <b>Step 3.</b> Following the results of the previous step, we will get a list of objects, each about two properties: FullName with the full path to the file name and Image with an illustration of the Bitmap class instance.  If for any of the files it was not possible to create a class of the raster image, then the Image property will be empty.  So we need a step that allows us to filter all objects that are not illustrations.  The result of the addition of the new instruction will be as follows: <br><br> <code>PS X:\&gt; dir $source -r -include *.jpg, *.png, *.gif | select FullName, @{Name="Image"; Expression={New-Object System.Drawing.Bitmap $_.FullName}} -ErrorAction SilentlyContinue | where { $_.Image }</code> <br> <br>  Everything is quite simple and concise.  We encounter a familiar reference to a property.  In this case, the Image property.  We meet the new where clause, which allows us to transmit further on the pipe only those objects that satisfy the given condition in it.  At the same time we get acquainted with a simple check for empty values.  Non-empty we would control the condition! $ _. Image, and to more complex conditions we would attract comparison operations, logical operations, etc.  For example - where {$ _. Image.Width -gt 1000 -and $ _. Image.Height -gt 1000} to get all the illustrations whose width and height are greater than 1000. <br><br>  <b>Step 4.</b> After we have received a list of illustrations, we will create for each of them the name of the folder in which the illustration should be saved.  We do it like this: <br><br> <code>PS X:\&gt; dir $source -r -include *.jpg, *.png, *.gif | select FullName, @{Name="Image"; Expression={New-Object System.Drawing.Bitmap $_.FullName}} -ErrorAction SilentlyContinue | where { $_.Image } | select FullName, @{Name="ImageFolder"; Expression={"{0}\{1}x{2}" -f $target, $_.Image.Width, $_.Image.Height}}</code> <br> <br>  You are already familiar with the select command and the formation of a new object; formatting strings is of greater interest here.  As you can see from the example, everything starts with the format string, and then the values ‚Äã‚Äãthat will be used during formatting are listed.  Increasingly corresponds to the string.Format method from .NET and formatting rules can be found in <a href="http://msdn.microsoft.com/en-us/library/b1csw23d.aspx">MSDN</a> . <br><br>  <b>Step 5.</b> Looking at the result of the execution of this function, you will see that we already have almost everything we need.  Namely, we have the full path to the original illustration all in the same FullName property and the destination path with folders according to the sizes in the new ImageFolder property.  There remains a continuous imperative to create a folder and copy / move a file there.  To do this, we will use the foreach instruction, which allows you to perform other instructions for each object received in the pipe.  It will all look like this together: <br><br> <code>PS X:\&gt; dir $source -r -include *.jpg, *.png, *.gif | select FullName, @{Name="Image"; Expression={New-Object System.Drawing.Bitmap $_.FullName}} -ErrorAction SilentlyContinue | where { $_.Image } | select FullName, @{Name="ImageFolder"; Expression={"{0}\{1}x{2}" -f $target, $_.Image.Width, $_.Image.Height}} | foreach {if (-not (test-path $_.ImageFolder)) {md $_.ImageFolder}; copy $_.FullName -destination $_.ImageFolder; $_}</code> <br> <br>  As you can see, there are three instructions in the foreach, separated by a semicolon.  The second definitely does not need any lengthy comments, for it is a simple copy.  Which, by the way, can be replaced with the move command to move the illustration file.  The first instruction is slightly longer, but not much more complicated.  In the if conditional construct, we check the absence of a folder with the help of logical negation and the test-path construct.  If the folder is missing, then only in this case we create it.  The third instruction could have been avoided altogether, but I wanted to show her that foreach is not a terminal instruction in the pipe and after it the processing can be continued.  Remember how at the very first step we output the values ‚Äã‚Äãof variables to the console?  So here, the instruction $ _ prints the object that we received on the pipe further into the pipe.  Instead, you can output something else.  For example, to define some variable and display it, say foreach {... .;  $ result = ...;  $ result}. <br><br>  Summing up, these few short lines - there is a little more piled up solution to the problem.  Is it good, is it bad - it's hard for me to judge.  I guess I'm here and then, including what to add to your piggy bank a bit of your collective wisdom :) <br><br>  <b>UPD</b> : Thank you so much <b>amirul</b> for the example in the imperative style, which I was too lazy to do.  I hope this will remove some problems with the readability of the code.  Although, I will not hide, I want to be understood and functional approach.  It is no more difficult, because the intricate-looking line passes elementary decomposition into primitive atoms.  It‚Äôs just unusual, like LISP‚Äôs syntax, for example, is unusual for many of us. <br><br> <code><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> <font color="black">Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> <ol> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li></li><li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li></li><li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li></li><li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/5544/s"></a> <a href="http://s-c.me/5544/h"></a> Copy Source | Copy HTML [void][reflection.assembly]::LoadWithPartialName( <font color="#008000">"System.Windows.Forms"</font> ) <font color="#cc6633">$source</font> = <font color="#008000">"x:\source"</font> <font color="#cc6633">$target</font> = <font color="#008000">"x:\target"</font> <font color="#0000ff">foreach</font> ( <font color="#cc6633">$file</font> in dir <font color="#cc6633">$source</font> -r -inc *.jpg, *.gif, *.png) { <font color="#0000ff">try</font> { <font color="#cc6633">$image</font> = <font color="#0000ff">new</font> -object System.Drawing.Bitmap <font color="#cc6633">$file</font> .FullName <font color="#cc6633">$targetdir</font> = <font color="#008000">"{0}\{1}x{2}"</font> -f <font color="#cc6633">$target</font> , <font color="#cc6633">$image</font> .Width, <font color="#cc6633">$image</font> .Height <font color="#0000ff">if</font> (!(test-path <font color="#cc6633">$targetdir</font> )) { md <font color="#cc6633">$targetdir</font> } copy <font color="#cc6633">$file $targetdir</font> Write-Host <font color="#cc6633">$file</font> -&gt; <font color="#cc6633">$targetdir</font> } <font color="#0000ff">catch</font> { Write-Host <font color="#cc6633">$file</font> <font color="#008000">" **IS NOT COPIED**"</font> } }</font></code> </li> <li></li></ol></div><p>Source: <a href="https://habr.com/ru/post/85576/">https://habr.com/ru/post/85576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../85565/index.html">What are you using?</a></li>
<li><a href="../85566/index.html">Postmorthem iPhone Games Finger Physics</a></li>
<li><a href="../85567/index.html">Free last.fm radio "Freelast radio"</a></li>
<li><a href="../85568/index.html">FineReader 10 released!</a></li>
<li><a href="../85569/index.html">Firefox and arbitrary selection of columns in tables</a></li>
<li><a href="../85577/index.html">PHP - framework with plugin support in 5 minutes</a></li>
<li><a href="../85578/index.html">The Dark Side of Ruby, Proc and Lambda</a></li>
<li><a href="../85579/index.html">Update news for HTC Hero on Android 2.1</a></li>
<li><a href="../85581/index.html">Yandex and Google home page widgets</a></li>
<li><a href="../85584/index.html">Yandex Tour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>