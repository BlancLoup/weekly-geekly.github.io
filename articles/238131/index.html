<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>folly :: fbvector - improved std :: vector from Facebook</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Folly is an open C ++ library developed by Facebook and used by it in internal projects. In order to optimize memory and processor resources, the libr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>folly :: fbvector - improved std :: vector from Facebook</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://github.com/facebook/folly">Folly</a> is an open C ++ library developed by Facebook and used by it in internal projects.  In order to optimize memory and processor resources, the library includes its own implementations of some standard containers and algorithms.  One of them is <a href="">folly :: fbvector</a> - replacing the standard vector (std :: vector).  The Facebook implementation is fully compatible with the original std :: vector interface, the changes are always non-negative, almost always measurable, often significant, and sometimes even enormously affect performance and / or memory consumption.  Just include the folly / FBVector.h header file and replace std :: vector with folly :: fbvector to use it in your code. <br><br><h4>  Example </h4><br><pre><code class="cpp hljs">folly::fbvector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers({<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); numbers.reserve(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">4</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { numbers.push_back(i * <span class="hljs-number"><span class="hljs-number">2</span></span>); } assert(numbers[<span class="hljs-number"><span class="hljs-number">6</span></span>] == <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br><br><h4>  Motivation </h4><br>  std :: vector is a well-established abstraction that many use for dynamically allocated arrays in C ++.  It is also the most famous and most used container.  The big surprise is that its standard implementation leaves quite a lot of opportunities to improve the efficiency of vector use.  This document explains how the folly :: fbvector implementation improves on some aspects of std :: vector.  You can use the tests from <a href="">folly / test / FBVectorTest.cpp</a> to compare the performance of std :: vector and folly :: fbvector. <br><a name="habracut"></a><br><h4>  Memory management </h4><br>  It is known that std :: vector grows exponentially (with a constant growth rate).  An important nuance in the correct choice of this constant.  Too small a number will result in frequent reallocations, too large a number will consume more memory than is really necessary.  The initial implementation of Stepanova used the constant 2 (i.e., each time the push_back call required an expansion of the vector, its capacity doubled). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Over time, some compilers have reduced this constant to 1.5, but gcc stubbornly uses 2. In fact, you can mathematically prove that constant 2 is strictly the worst of all possible values, because it never allows you to reuse the previously allocated memory. <br><br>  To understand why this is so, imagine a vector of size n bytes, already completely filled, into which one more element is being tried.  This leads, according to the implementation of std :: vector, to the following steps: <br><ol><li>  Memory allocated, the size of 2 * n bytes.  Most likely, it will be allocated in the address space for the current vector (maybe directly beyond, maybe after some interval). </li><li>  The old vector is copied to the beginning of the new one. </li><li>  A new element is added to the new vector. </li><li>  The old vector is removed. </li></ol><br><br>  When it comes to increasing this new vector - it will be increased to 4 * n, then - to 8 * n, etc.  Each new memory allocation will require more of it than for all previous vectors combined, because at each step k we need (2 ^ k) * n bytes of memory, and this is always more than the sum (2 ^ (k - 1)) * n + (2 ^ (k - 2)) * n ... + ((2 ^ 0)) * n <br><br>  Those.  the memory manager will never be able to reuse the previously allocated memory for the vector and will always be forced to allocate a ‚Äúnew‚Äù memory.  This is hardly what we really want.  So, any number less than 2 guarantees that at some step of increasing the capacity of the vector, we can not allocate memory in the new address space, but re-use the memory previously allocated to this vector. <br><br>  The graph shows that with a constant increase in capacity equal to 1.5 (blue line), the memory can be reused after the 4th step of increasing the vector, at 1.45 (red line) - after the third, and at 1.3 (black line) - after the second. <br><br><img src="https://github.com/facebook/folly/raw/master/folly/docs/Fbvector--graphical_solutions.png" alt="image"><br><br>  Of course, the graph above makes several simplifications about how memory allocators work in the real world, but the fact that the gcc constant 2 chosen is theoretically the worst case does not change.  fbvector uses the constant 1.5.  And it does not hit on the performance of small-sized vectors, due to the way fbvector interacts with jemalloc. <br><br><h4>  Interaction with jemalloc </h4><br>  Virtually all modern memory allocators allocate memory with certain quanta chosen to minimize the overhead of memory management and at the same time give good performance on the small sizes of allocated blocks.  For example, the allocator can choose blocks like this: 32, 64, 128, ... 4096, then in proportion to the page size up to 1 MB, then increments of 512 KB, and so on. <br><br>  As discussed above, std :: vector also requires quantized memory.  The size of the next quantum is determined on the basis of the current capacity of the vector and the growth constant.  Thus, at almost every moment in time, we have a certain amount of unused memory at the current time at the end of the vector, and right after it is a certain amount of unused memory at the end of the memory block allocated by the allocator.  The conclusion itself suggests that the union of the vector allocator and shared memory allocator can provide optimization of the RAM consumption - the vector can ask the allocator for an ‚Äúideal‚Äù size block, eliminating unused memory in the block allocated by the allocator.  Well, in general, the general strategy of allocating memory with a vector and an allocator can be sharpened better if you know the exact implementation of both.  This is exactly what fbvector does - it automatically detects the use of jemalloc and adjusts to its memory allocation algorithms. <br><br>  Some memory allocators do not support in-place reallocation (although most modern ones still support).  This is the result of the not too successful design of the realloc () function, which itself decides whether to reuse its previously allocated memory, or allocate a new one, copy the data there and release the old one.  This lack of memory allocation controls affects the new operator in C ++ and the behavior of std: allocator.  This is a serious blow to performance, since in-place reallocation, being very cheap, leads to a significantly less aggressive strategy of memory consumption growth. <br><br><h4>  Reallocation of objects </h4><br>  One of the important issues of placing C ++ objects in memory is that, by default, they are considered to be unmovable.  A relocatable object is considered to be a type that can be copied to another place in memory by bit-wise copying and at the same time, the object retains its validity and integrity in a new place.  For example, int32 is relocatable, because 4 bytes completely describe the state of a 32-bit signed number, if you copy these 4 bytes to another place in memory - this block of memory can be completely unambiguously interpreted as the same number. <br><br>  The assumption of C ++ that objects are unmovable harms everyone and does this only for the sake of a few controversial points of architecture.  Moving an object involves allocating memory for the new object, calling its copy constructor, and destroying the old object.  This is not very pleasant and generally against common sense.  Imagine the theoretical conversation of Captain Picard and the Skeptical Alien: <br><br>  <b>Skeptical Alien</b> : So, this teleport of yours - how does it work? <br>  <b>Picard</b> : He takes a man, dematerializes him in one place and materializes him in another <br>  <b>Skeptical Alien</b> : Hmm ... is it safe? <br>  <b>Picard</b> : Yes, the truth in the first models were minor flaws.  At first, a person was simply cloned, created in a new place.  After that, the teleport operator had to manually shoot the original.  Ask O'Brian, he worked as an intern just in this position.  The implementation was not very elegant. <br><br>  ( <b>comment of the translator</b> : apparently, this was written before the introduction of motion constructors in the latest C ++ standards). <br><br>  In fact, only a part of the objects are really unmovable: <br><ul><li>  Those that have pointers to external objects </li><li>  Pointers from other objects </li></ul><br><br>  Objects of the first type can always be remade with minimal cost.  Objects of the second type should not be created by the operator new and deleted by the operator delete - they must be managed by smart pointers and there will be no problems. <br><br>  Movable objects are very interesting for std :: vector, because knowing how to move objects inside a vector significantly affects the efficiency of reallocating the vector of these objects.  Instead of the above described Picard move cycle, objects can be moved with simple memcpy or memmove.  For example, working with types like vector &lt;vector&gt; or vector &lt;hash_map &lt;int, string &gt;&gt; can be much faster. <br><br>  In order to support the safe movement of objects, fbvector uses the type (trait) of folly :: IsRelocatable, defined in ‚Äúfolly / Traits.h‚Äù.  By default, folly :: IsRelocatable :: value conservatively returns false.  If you know for sure that your Widget type is relocatable, you can immediately add this type of declaration after this type of declaration: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> folly { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRelocatable</span></span></span><span class="hljs-class">&lt;Widget&gt; :</span></span> boost::true_type {}; }</code> </pre><br><br>  If you do not do this, fbvector will not compile with BOOST_STATIC_ASSERT. <br><br><h4>  Additional restrictions </h4><br>  Some improvements are also possible for ‚Äúsimple‚Äù types (more precisely, for those that have a trivial assignment operation) or for those types that have a constructor that does not throw exceptions (nothrow default constructor).  Fortunately, these types are already present in the C ++ standard (well, or in Boost).  To summarize, to work with fbvector, the Widget type must satisfy the following condition: <br><br><pre> <code class="cpp hljs">BOOST_STATIC_ASSERT( IsRelocatable::value &amp;&amp; (boost::has_trivial_assign::value || boost::has_nothrow_constructor::value));</code> </pre><br><br>  These types are in fact very close - it is quite difficult to construct a class that will satisfy one part of the condition and break the other (unless it is specifically trying very hard).  fbvector uses these simple conditions to minimize copy operations for basic vector operations (push_back, insert, resize). <br><br>  To simplify type checking for compatibility with fbvector, Traits.h has the FOLLY_ASSUME_FBVECTOR_COMPATIBLE macro. <br><br><h4>  miscellanea </h4><br>  The fbvector implementation focuses on memory efficiency.  In the future, the implementation of copying may be improved due to the fact that memcpy is not an intrinsic function in gcc and does not work perfectly for large data blocks.  Improvement is also possible in the area of ‚Äã‚Äãinteraction with jemalloc. <br><br>  Good luck using fbvector. </div><p>Source: <a href="https://habr.com/ru/post/238131/">https://habr.com/ru/post/238131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238121/index.html">Windows Identity Foundation - for ASP.NET MVC projects</a></li>
<li><a href="../238123/index.html">Do it yourself! Kite Aerial Kite Aerial Photography</a></li>
<li><a href="../238125/index.html">The Martian orbital satellites MAVEN and Mangalyaan transmitted the first photos of Mars</a></li>
<li><a href="../238127/index.html">Controlled Internet: is the devil so scary how it is painted?</a></li>
<li><a href="../238129/index.html">Analysis of existing approaches to face recognition</a></li>
<li><a href="../238133/index.html">Is it possible to improve contextual search in the browser?</a></li>
<li><a href="../238135/index.html">Exclusively under your ears: print headphones on a 3D printer</a></li>
<li><a href="../238137/index.html">Meet the Intel RealSense SDK Beta, participate in the competition and get a 3D camera</a></li>
<li><a href="../238139/index.html">Web development with comfort: Parallels Desktop 10 + Vagrant</a></li>
<li><a href="../238141/index.html">Business "know-alls" - how big data changes the face of companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>