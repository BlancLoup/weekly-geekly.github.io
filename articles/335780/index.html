<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rethinking PID 1. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 

- Rethinking PID 1. Part 1 
- Rethinking PID 1. Part 2 
- Rethinking PID 1. Part 3 
- Rethinking PID 1. Part 4 
- Part 5 


 Paral...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rethinking PID 1. Part 3</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/d93/180/250/d93180250c0d43869a9632dc847179bd.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/334828/">Rethinking PID 1. Part 1</a> </li><li>  <a href="https://habrahabr.ru/post/335488/">Rethinking PID 1. Part 2</a> </li><li>  <a href="https://habrahabr.ru/post/335780/">Rethinking PID 1. Part 3</a> </li><li>  <a href="https://habrahabr.ru/post/336834/">Rethinking PID 1. Part 4</a> </li><li>  Part 5 </li></ul><br></div></div><br><br><h3>  Parallel file system jobs </h3><br>  If you look at the download <a href="">schedule for</a> current distributions, you will see more synchronization points than just daemon launches: the tasks associated with file systems take the most time: mounting, checking files for errors (fsck), quoting.  Now, during loading, a lot of time is spent waiting until all the disks specified in <i>/ etc / fstab</i> appear in the device tree, and then checked for errors, quotas are mounted and applied (unless of course they are included).  Only after all this will we be able to go further and <b>actually</b> start loading services. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Can we improve this process?  It turns out that we can.  Harold Heuer came up with the idea of ‚Äã‚Äãusing the honorable <i>autofs</i> to improve the process. <br><a name="habracut"></a><br>  Just like the <i>connect ()</i> call ‚Äúdeclares‚Äù that he is interested in another service, the <i>open ()</i> call (or other similar call) ‚Äúdeclares‚Äù that he is interested in some file or some file system.  So, in order to make paralleling possible, we need to make sure that these applications are waiting only when the file system they are looking for is not mounted yet, but it will be very soon.  To do this, we connect the <i>autofs</i> mount <i>point</i> (fake mount point), and when our real file system passes the integrity check with the <i>fsck</i> utility during normal OS loading, we will replace it with a real monitor point.  While the real file system is not yet mounted, an attempt to access the file system will be queued by the kernel and the access attempt will be blocked, but only for the only daemon that has addressed.  Thus, we can run our demons long before all filesystems become available and without losing any access to files and parallelizing the OS boot process as much as possible. <br><br>  Parallelization of FS tasks makes no sense for the mount point - / (root root), where all services (demons) and all binaries are located.  However, due to the mount point <i>/ home</i> , which is usually larger and can even be encrypted, and maybe even mounted from a remote machine and which is rarely accessed by the daemons during the OS boot, we can significantly increase the OS boot speed.  It is probably not necessary to remind you that virtual files such as <i>procfs</i> or <i>sysfs</i> should never be mounted via <i>autofs</i> . <br><br>  It will not be a surprise for me if some readers find the solution to integrating <i>autofs</i> into the <i>init</i> process slightly "fragile" or even strange, and maybe attributed to the more "hacker" side of things.  However, to a large extent, having played with him, I can say that <i>autofs</i> in its present place feels quite well even.  Using autofs means that we can create a monitoring point without immediately providing a real file system.  In fact, we get deferred access.  If an application tries to access the <i>autofs</i> file <i>system</i> and it takes us a lot of time to replace it with a real file system, then the application will hang up in an interrupted sleep, meaning that you can easily cancel it, for example, using <b>Ctrl + C.</b>  Also note that at any point of the application‚Äôs execution, if a real file system can‚Äôt be correctly mounted (as a result of a <i>fsck</i> failure), then we can simply ask <i>autofs</i> to return a real error code (say <i>ENOENT</i> ).  So, I think that ... I want to say that even if the integration of <i>autofs</i> into the initialization system may seem reckless at first, our experimental code showed that the idea in practice, not surprisingly, behaves very well even if of course the idea is implemented correctly and for the right reasons. <br><br>  Also note that the autofs monitoring <i>points</i> should be so-called <i>direct mappings</i> (note the translator: information on display types <a href="https://www.ibm.com/support/knowledgecenter/ru/ssw_aix_71/com.ibm.aix.networkcomm/nfs_automounting.htm">here</a> ), meaning that from the point of view of the application there are only minor differences between the classical (real) mount point and those based on <i>autofs</i> . <br><br><h3>  Keep the first user PID small </h3><br>  Another good thing we can learn from the MacOS boot logic is that shell scripts are evil.  The shell is as ‚Äúfast‚Äù as the shell is slow.  In shell scripts, you can quickly figure out what's what, but the speed of execution leaves much to be desired!  The classic <i>sysvinit</i> boot system is modeled around shell scripts.  Whether <i>/ bin / bash</i> or any other shell (which was most likely written to speed up the execution of shell scripts) is ultimately doomed to be slow.  On my machine, the scripts in <i>/etc/init.d</i> call <i>grep</i> 77 times.  <i>awk</i> is called 92 times, <i>cut</i> - 23 and <i>sed</i> - 74. Every time these commands (or others) are called, a new process is generated, then any related libraries are searched for, such things as <i>i18n are</i> configured, and so on.  Even if operations are rarely performed, a little more complicated than trivial operations with strings, the loading process is still interrupted.  Of course, this is all done incredibly slowly.  But no language other than the shell could do something like that.  Moreover, shell scripts are very ‚Äúfragile‚Äù, as I said above: they change their behavior from environment variables and other similar things that are difficult to track and somehow control. <br><br>  So let's get rid of the burden of shell scripts during the OS boot process.  Before we can do this, we must first understand what they are actually used for: dachshunds, if viewed from a high level, most of the time they do very boring things.  Most of the scripts spend time on trivial start and stop services, and must be rewritten to C, and either in the form of separate executable files, or transferred inside the services (daemons) themselves or implemented in the boot system itself. <br><br>  It does not seem like we can completely get rid of the burden of shell scripts in the near future.  Rewriting them in C will take time, in some cases this occupation does not make any sense at all, and sometimes shell scripts are very handy.  But in general, we can make them less necessary and ubiquitous than before. <br><br>  A good metric for measuring the invasiveness of shell scripts in the OS boot process is the PID number of the first process that you can run after the OS is fully loaded.  Log in and log in, open a terminal and type <i>echo $$</i> .  Try it on your Linux machine, and then compare the result with MacOS!  (Hint, the result might be something like the following: Linux PID - 1823; MacOS PID - 154. Measured on our test machines.) <br><br><h3>  Process tracking </h3><br>  The main component of the system that starts and manages the services should be the ‚Äúcarer‚Äù process: it should monitor the services.  Restart services when they stop.  When the service ‚Äúfalls,‚Äù it must collect all the necessary information about the collapse and keep them somewhere nearby so that the administrator can view them further, and also build cross-links with the information that is present in crash dump systems such as <i>abrt</i> , as well as in a log service such as <i>syslog</i> or in an audit system. <br><br>  The process observer (‚Äúnurse‚Äù) should also be able to completely stop the service (note the translator: I mean the process of the service and all its child processes).  This may seem like a trivial task, but in fact it is even more difficult than it seems.  Traditionally, in Unix, a process that forks itself twice can get rid of self-observation by its parent process, and the very first parent will not know about the connection with the new process that his descendant actually created.  For example: in the current state of affairs, a ‚Äúprancing‚Äù (badly behaved) CGI script that forked itself two times will not be stopped when the Apache service is stopped.  Moreover, you do not even have the opportunity to establish a connection between the CGI script ‚Äúnaughty‚Äù and Apache, until you know its name and purpose. <br><br>  So how can we track the processes so that they cannot get rid of the ‚Äúsitter‚Äù and so that we can control them as one entity if they fork a gazillion times? <br><br>  Different people offer different solutions for this problem.  I'm not going to go into details in this article, but let me at least say that solutions are based on a <i>ptrace</i> or <i>netlink</i> connector (a kernel interface that allows you to get a <i>netlink</i> message every time a process in the system calls <i>fork ()</i> or <i>exit</i> ) that some people have devoted time to and have implemented are criticized by many for ugly and non-scalable solutions. <br><br>  So what can we do about it?  Well, recently <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/cgroups.txt%3Fid%3DHEAD">Control Groups</a> (aka "cgroups") have appeared in the core.  In general, they allow you to create a hierarchy of process groups.  The hierarchy is directly projected into the virtual file system, and therefore easily accessible.  The names of the groups are the names of the directories in the virtual filesystem.  If a process belongs to any of the groups, all its descendants (child processes) created via the <i>fork ()</i> call will also belong to the same group.  If a process does not have the privileges (say root), but has access to the cgroup file system, it cannot leave its group.  Initially, <i>cgroups</i> were added to the kernel for container purposes: certain kernel subsystems can put limits on resources or on certain groups, such as limits on CPU or memory usage.  Traditionally, limits on limits (as implemented in <i>setrlimit ()</i> ) are set for each process (mostly).  <i>cgroups</i> , on the other hand, allow you to set limits on the entire group of processes.  <i>cgroups are</i> also used to set limits, outside the area of ‚Äã‚Äãtheir direct responsibility - containers.  For example, you can use <i>cgroups</i> to set the maximum amount of memory or CPU used by Apache, as well as all its child processes.  Then, a badly behaved CGI script, can no longer leave its group exposed via <i>setrlimit ()</i> simply by calling <i>fork ()</i> again. <br><br>  In addition to containers and setting resource limits, <i>cgroups are</i> also very useful as a tracking tool for processes (services): cgroup membership is safely inherited by all child processes from which they cannot escape.  There is also an alert system and the parent process will be notified if the running cgroup is empty.  You can find out the <i>cgroups of the</i> process by reading the file <i>/ proc / $ PID / cgroup</i> .  Consequently, <i>cgroups are</i> very well suited for the role of "nurse" behind the processes, i.e.  their direct tracking. <br><br><h3>  We control the process environment </h3><br>  A good carer should not only monitor and control when and how services are started or stopped, or when they suddenly fall, but it should also provide a minimum, good, and safer environment for their implementation. <br><br>  Securing software means setting obvious process parameters such as resource limits ‚Äî <i>setrlimit</i> , user / group ID, or a block of environment variables, and that's not all.  The Linux kernel provides users and administrators with a good level of control over the processes.  For each process, you can set the parameters of the scheduler CPU and IO, attraction to the CPU and of course the environment cgroup with additional limits and much more. <br><br>  As an example, calling <i>ioprio_set ()</i> with <i>IOPRIO_CLASS_IDLE</i> is a great way to minimize the impact of the <i>updatedb</i> function of the <i>locate</i> utility on the interactivity of the system. <br><br>  On top of this, certain high-level monitoring tools can be very useful, such as mounting an additional read-only file layer based on bind mounts.  Thus, we can start certain daemons (services) so that all (or some) of the filesystems will appear to them in read-only mode and, therefore, an <i>EROFS</i> error will be returned for each write attempt.  In this way, we can isolate the demons in what they can do, in the same manner as the poor SELinux does (but this method is definitely not a substitute for SELinux, and please do not use bad ideas like SELi ....). <br><br>  And lastly.  Logging is an important part of service execution: ideally, every output bit generated by the service should be logged.  Therefore, the boot system must provide logging services to the daemons it starts up from the very start of the boot and attach the standard output and error output to the <i>syslog</i> or in some cases to <i>/ dev / kmsg</i> , which in many cases is a very good replacement for <i>syslog</i> ( involved in embedded systems, listen!), especially in those cases when out of the box the kernel log buffer is terribly large. <br><br>  To be continued‚Ä¶ </div><p>Source: <a href="https://habr.com/ru/post/335780/">https://habr.com/ru/post/335780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335768/index.html">As we struggle with dynamic libraries in Swift. Yandex experience</a></li>
<li><a href="../335770/index.html">Webcam, Node.js and OpenCV: make a face recognition system</a></li>
<li><a href="../335772/index.html">Installing and configuring MongoDB on Debian, as well as ReplicaSet and a couple of other little things</a></li>
<li><a href="../335776/index.html">UI tests - are they always needed?</a></li>
<li><a href="../335778/index.html">Report on the hackathon of the Navalny team</a></li>
<li><a href="../335782/index.html">3 controversial ideas of the support manager</a></li>
<li><a href="../335784/index.html">The last frontier: how the second line of technical support in retail works</a></li>
<li><a href="../335786/index.html">Kaggle: Amazon's Terrain Analysis from Satellite Images</a></li>
<li><a href="../335788/index.html">XBRL: just about the complex - Chapter 6. Immersion in the XBRL - Part 2. Improving the result</a></li>
<li><a href="../335790/index.html">10 free and cool fonts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>