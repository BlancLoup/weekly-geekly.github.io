<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compare Swift and Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The reason for writing the article was the publication of the source code of the Swift language - it became interesting to me to get acquainted with i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compare Swift and Rust</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/01e/b90/7e1/01eb907e1a0345b096f1aab0e7070ca6.png" align="left"><br>  The reason for writing the article was the publication of the source code of the Swift language - it became interesting to me to get acquainted with it.  Immediately, the similarity of syntax with another young programming language called Rust caught my eye, and similar syntax constructions also looked at a similar field of application of these languages.  Both languages ‚Äã‚Äãhave strong static typing with local type inference, both are compiled directly into machine code.  Both languages ‚Äã‚Äãabsorbed many tricks from the world of functional programming.  Both Swift and Rust have the means to run code written in C, which makes it easy to write wrappers over a huge number of libraries.  Both languages ‚Äã‚Äãare considered as a replacement for existing system languages ‚Äã‚Äãsuch as C, C ++, ObjectiveC.  So what they have in common, and what is different? <br><a name="habracut"></a><br><br><h4>  Basic syntax </h4><br><br>  Immediately, I‚Äôll make a reservation that I‚Äôm not trying to tell readers the basics of two programming languages ‚Äã‚Äãat once, and if something is unclear, I recommend turning to <a href="http://kgv.github.io/rust_book_ru/">Rustbook</a> or <a href="http://swiftbook.ru/">Swiftbook</a> for help. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, let's try to compare the simplest programs: <br><br>  <b>Rusty</b> <br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i:<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> f = <span class="hljs-number"><span class="hljs-number">8.0</span></span>; f *= <span class="hljs-number"><span class="hljs-number">2.0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello Rust! within vars {} and {}"</span></span>, i, f); }</code> </pre> <br><br>  <b>Swift</b> <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i:<span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-number"><span class="hljs-number">15.0</span></span> f /= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello Swift within vars \(i) \(f)"</span></span>)</code> </pre><br><br>  You can see that let means the same thing here and there, and the var keyword in Swift is similar to the combination of let mut in Rust.  But there are differences: in Rust in all numeric types the size is unambiguously indicated, and Swift follows the traditions of C.  In this matter, Rust looks lower level. <br>  Interpolation of strings in Rust is done using the format! Macro, which is called in the bowels of println !, and in Swift, this is a feature of the language itself, but I did not find in the documentation how to set the formatting options. <br>  There is an interesting difference in the interpretation of ";": for Rust, this is a sign of the end of the expression, which allows you to do some elegant things, for example, the last expression inside the function automatically becomes the return value.  Swift simply follows the traditions of pascal, where the semicolon simply separates the operators on the same line. <br><br>  Now let's try to create a function that takes a function from two arguments and converts it to a function from one: <br><br>  <b>Rusty</b> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>&lt;F: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(f: F, v1: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; ()&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; () { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |v2| f(v1, v2)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_sum</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; () { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Rust: sum a and b is {}"</span></span>, a + b); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">5</span></span>; print_sum(a, b); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = print_sum; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f2 = apply(f, b); f2(a); }</code> </pre><br><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">: Int, </span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">: Int)</span></span></span></span></span></span> -&gt; (), <span class="hljs-number"><span class="hljs-number">_</span></span> v1: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-number"><span class="hljs-number">_</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; () <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(v1, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, second b: Int)</span></span></span></span> -&gt; () { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Swift: sum a and b is \(a+b)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">5</span></span>; print_sum(a, second:b) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f2 = apply(print_sum, b) f2(a)</code> </pre><br><br>  There are already clearly noticeable differences, I will leave behind the purely syntactic differences of the type of external names of named parameters in Swift or generalizations in Rust, and proceed to consider a more significant difference.  The Swift approach is noticeably higher-level: the compiler itself decides how to store our result function, but for Rust, we had to explicitly pack it into a box, because the moved closures are a dimensionless type. <br>  Let's check whose functions lambda work faster: <br><br><div class="spoiler">  <b class="spoiler_title">Benchmark code</b> <div class="spoiler_text">  <b>Rusty</b> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>&lt;F: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(f: F, v1: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |v2| f(v1, v2)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_sum</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = make_sum(a, b); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Rust: c is {}"</span></span>, c); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f2 = apply(make_sum, b); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000000</span></span> { d = f2(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Rust: d is {}"</span></span>, d); }</code> </pre><br><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">: Int, </span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">: Int)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> v1: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-number"><span class="hljs-number">_</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(v1, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, second b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = make_sum(a, second:b) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Swift: c is \(c)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f2 = apply(make_sum, b) f2(a) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">1000000000</span></span> { d = f2(i); } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Swift: d is \(d)"</span></span>);</code> </pre><br><br></div></div><br><br>  Final result: 4.0 seconds for Rust versus 1.17 for Swift.  It turns out that in the case of a more abstract code, the compiler has more opportunities for optimization, but on the ruRust / general channel I was prompted by a method that may or may not look so beautiful, but it allows the optimizer to give everything in full.  Ultimately, Rust considered the whole cycle right at compile time, which is very cool. <br>  In the able hands of Rust allows you to work wonders. <br><br><div class="spoiler">  <b class="spoiler_title">Quick version code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Curry</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { f: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, v1: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Curry&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;F: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(f: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> F, v1: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; Curry&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { Curry { f: f, v1: v1 } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, v2: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { (*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.f)(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.v1, v2) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_sum</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = make_sum(a, b); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Rust: c is {}"</span></span>, c); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> borrow = &amp;make_sum; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f2 = Curry::new(borrow, b); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000000</span></span> { d = f2.call(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Rust: d is {}"</span></span>, d); }</code> </pre><br></div></div><br><br><h4>  Enumerations and pattern matching: </h4><br><br>  Both languages ‚Äã‚Äãhave great possibilities for pattern matching, in both languages ‚Äã‚Äãthere are algebraic data types.  Let's try to write a simple example using these features: we will try to implement mathematical operations.  To do this, we will need to make our transfers recursive.  As a bonus, we will try to print the names of our operations on the screen using protocols (types). <br>  <b>Rusty</b> <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MathOperation</span></span></span></span> { Value(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Sum(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MathOperation&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MathOperation&gt;), Mul(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MathOperation&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MathOperation&gt;) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasName</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> HasName <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MathOperation { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { MathOperation::Value(..) =&gt; <span class="hljs-string"><span class="hljs-string">"Value"</span></span>, MathOperation::Sum(..) =&gt; <span class="hljs-string"><span class="hljs-string">"Sum"</span></span>, MathOperation::Mul(..) =&gt; <span class="hljs-string"><span class="hljs-string">"Mul"</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MathOperation { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { MathOperation::Value(i) =&gt; i, MathOperation::Sum(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> left, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> right) =&gt; left.solve() + right.solve(), MathOperation::Mul(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> left, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> right) =&gt; left.solve() * right.solve() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op = MathOperation::Sum(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(MathOperation::Value(<span class="hljs-number"><span class="hljs-number">10</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(MathOperation::Mul(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(MathOperation::Value(<span class="hljs-number"><span class="hljs-number">20</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(MathOperation::Value(<span class="hljs-number"><span class="hljs-number">2</span></span>))))); ; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Rust: op is {} solved {}"</span></span>, op.name(), op.solve()); }</code> </pre><br><br>  <b>Swift</b> <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MathOperation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Value</span></span>(<span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">indirect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Sum</span></span>(<span class="hljs-type"><span class="hljs-type">MathOperation</span></span>, <span class="hljs-type"><span class="hljs-type">MathOperation</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">indirect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Mul</span></span>(<span class="hljs-type"><span class="hljs-type">MathOperation</span></span>, <span class="hljs-type"><span class="hljs-type">MathOperation</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Value</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>.solve() + <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>.solve() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Mul</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>.solve() * <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>.solve() } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasName</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MathOperation</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasName</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Value</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Value"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Sum</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Sum"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Mul</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Mul"</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> op = <span class="hljs-type"><span class="hljs-type">MathOperation</span></span>.<span class="hljs-type"><span class="hljs-type">Sum</span></span>(<span class="hljs-type"><span class="hljs-type">MathOperation</span></span>.<span class="hljs-type"><span class="hljs-type">Value</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-type"><span class="hljs-type">MathOperation</span></span>.<span class="hljs-type"><span class="hljs-type">Mul</span></span>(<span class="hljs-type"><span class="hljs-type">MathOperation</span></span>.<span class="hljs-type"><span class="hljs-type">Value</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>), <span class="hljs-type"><span class="hljs-type">MathOperation</span></span>.<span class="hljs-type"><span class="hljs-type">Value</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Swift: op is \(op.name()) solved \(op.solve())"</span></span>);</code> </pre><br><br>  We can note that in Rust, in order to organize recursive transfers, it was necessary to pack them into a Box container, because their size can be arbitrary and we cannot know at the compilation stage how much memory we need for this.  In Swift, the word indirect is used to refer to recursive enumerations, but given its memory model, the question arises, is the compiler itself unable to figure out how to allocate memory?  Apparently this keyword is introduced rather for a person. <br>  We can also see that impl and extension, in principle, perform approximately similar work, and types are similar to protocols.  But in Swift the approach is more compromise: it is not necessary to add methods as extensions, you can specify them directly in the declaration of the enumeration. <br><br>  Now let's just look at a couple of examples of pattern matching: <br><br>  <b>Rust</b> (examples taken from Rust by example) <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> some_value { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(value) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"got a value: {}"</span></span>, value), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"an error occurred"</span></span>), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OptionalTuple</span></span></span></span> { Value(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Missing, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = OptionalTuple::Value(<span class="hljs-number"><span class="hljs-number">5</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> x { OptionalTuple::Value(..) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Got a tuple!"</span></span>), OptionalTuple::Missing =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"No such luck."</span></span>), } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> x { <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-number"><span class="hljs-number">5</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"one through five"</span></span>), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"anything"</span></span>), } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> x { e @ <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-number"><span class="hljs-number">5</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"got a range element {}"</span></span>, e), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"anything"</span></span>), }</code> </pre><br>  <b>Swift</b> (sample code taken from Swiftbook) <br><pre> <code class="hljs pgsql">let count = <span class="hljs-number"><span class="hljs-number">3000000000000</span></span> let countedThings = "stars in the Milky Way" var naturalCount: String switch count { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: naturalCount = "no" <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>.<span class="hljs-number"><span class="hljs-number">.3</span></span>: naturalCount = "a few" <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4.</span></span>.<span class="hljs-number"><span class="hljs-number">.9</span></span>: naturalCount = "several" <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10.</span></span>.<span class="hljs-number"><span class="hljs-number">.99</span></span>: naturalCount = "tens of" <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">100.</span></span>.<span class="hljs-number"><span class="hljs-number">.999</span></span>: naturalCount = "hundreds of" <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1000.</span></span>.<span class="hljs-number"><span class="hljs-number">.999999</span></span>: naturalCount = "thousands of" <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: naturalCount = "millions and millions of" } print("There are \(naturalCount) \(countedThings).") //  "There are millions and millions of stars in the Milky Way." let somePoint = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) switch somePoint { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>): print("(0, 0) is at the origin") <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, <span class="hljs-number"><span class="hljs-number">0</span></span>): print("(\(somePoint.0), 0) is on the x-axis") <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, _): print("(0, \(somePoint.1)) is on the y-axis") <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">-2.</span></span>.<span class="hljs-number"><span class="hljs-number">.2</span></span>, <span class="hljs-number"><span class="hljs-number">-2.</span></span>.<span class="hljs-number"><span class="hljs-number">.2</span></span>): print("(\(somePoint.0), \(somePoint.1)) is inside the box") <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: print("(\(somePoint.0), \(somePoint.1)) is outside of the box") }//  "(1, 1) is inside the box let anotherPoint = (2, 0) switch anotherPoint { case (let x, 0): print("<span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the x-axis <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> an x <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> \(x)") case (0, let y): print("<span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the y-axis <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ay <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> \(y)") case let (x, y): print("somewhere <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> at (\(x), \(y))") } //  "<span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the x-axis <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> an x <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  Here, in general, everything is very similar.  There should be no dips in the mapping, you can specify ranges of values, there is the possibility of binding values, you can use tuples in the mapping.  Although Rust also allows the use of whole structures for matching.  You can set additional conditions through if and where, respectively.  But at the same time there are additional flow control statements in Swift.  Although I'm not sure that using them is a good idea. <br><br><h4>  A more realistic example </h4><br><br>  Let's try to write a Bresenham rasterization <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25B5%25D0%25B7%25D0%25B5%25D0%25BD%25D1%2585%25D1%258D%25D0%25BC%25D0%25B0">algorithm</a> .  Only not in the usual form, but in the form for n-dimensional vectors and without the use of real numbers.  This can all be useful when studying a <a href="http://habrahabr.ru/post/248159/">short course in computer graphics</a> . <br><br>  To begin, just try to create a 3-dimensional vector and define for it the operation of taking the index and comparison: <br>  <b>Rusty</b> <br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, PartialEq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec3</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, z: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Index&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vec3 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Self::Output { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> i { <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x, <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y, <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z, _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Wrong index"</span></span>), } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> IndexMut&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Vec3 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index_mut</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Self::Output { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> i { <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x, <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y, <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z, _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Wrong index"</span></span>), } } }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: <span class="hljs-type"><span class="hljs-type">Int</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y: <span class="hljs-type"><span class="hljs-type">Int</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z: <span class="hljs-type"><span class="hljs-type">Int</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Index out-of-bounds"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> i { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Index out-of-bounds"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> i { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x = newValue <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y = newValue <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.z = newValue <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> == </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">left</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Vector3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">right</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Vector3)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>.x == <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>.x) &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>.y == <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>.y) &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>.z == <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>.z) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> != </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">left</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Vector3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">right</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Vector3)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>) }</code> </pre><br>  In Rust, in fact, operators are implemented through types, if the structure implements the Index type, then the operator [] can be used for it, in Swift, index taking operators are written using the subscript keyword and allow you to add special preconditions.  Rust relies on ordinary asserts.  In the case of other operators, Swift allows you to both redefine existing ones and define your own, and with an indication of priorities, associativity.  All of this can be a great help when writing math libraries, making the code more similar to the original math expressions.  Rust is able to automatically create implementations of certain types through the derive attribute, which makes it possible not to write the code itself in many trivial cases. <br><br>  Let's now try to create a convenient buffer for storing the image so that the color of any pixel can be accessed through index operators.  In this case, we make the requirement that the pixel map be able to different color depth, so we will make it generalized: <br><br>  <b>rust</b> <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericPixmap</span></span></span></span>&lt;T&gt; { w: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, h: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; GenericPixmap&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(w: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, h: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, fill_value: T) -&gt; GenericPixmap&lt;T&gt; { GenericPixmap { w: w, h: h, data: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[fill_value; w*h] } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Index&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GenericPixmap&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = [T]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Self::Output { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> from = i*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.w; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> to = from+<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.w; &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[from..to] } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; IndexMut&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GenericPixmap&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index_mut</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Self::Output { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> from = i*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.w; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> to = from+<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.w; &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[from..to] } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pixmap</span></span></span></span> = GenericPixmap&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt;;</code> </pre><br><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericPixmap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> w: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data: [<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(width: <span class="hljs-type"><span class="hljs-type">Int</span></span>, height: <span class="hljs-type"><span class="hljs-type">Int</span></span>, fillValue: <span class="hljs-type"><span class="hljs-type">T</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.w = width <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.h = height <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data = [<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: w*h, repeatedValue: fillValue) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; w &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; h } <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, y: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(indexIsValid(x, y), <span class="hljs-string"><span class="hljs-string">"Index out-of-bounds"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[x * y + y] } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">precondition</span></span>(indexIsValid(x,y), <span class="hljs-string"><span class="hljs-string">"Index out-of-bounds"</span></span>) data[x * y + y] = newValue } } } <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Pixmap</span></span> = <span class="hljs-type"><span class="hljs-type">GenericPixmap</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UInt32</span></span>&gt;</code> </pre><br><br>  The rules for generalizations in Rust are stricter and we need to explicitly state that the template type should be able to copy and create its own copy.  In Swift, however, for the structure fields, their variability can be explicitly set.  You can also notice the init keyword.  This is a class or structure constructor, there may be several of them, they can delegate their powers to each other.  As a result, this results in a rather complex and multi-step process, which, nevertheless, precisely guarantees that each member will be initialized.  In Rust, there is a termwise initialization and an agreement that the object should be created by the static new function.  If the process promises to be difficult, then it is recommended to use factories.  As for static functions, Rust's syntax in this sense follows the traditions of python, while Swift follows C ++. <br>  I want to note that the index operator in Swift can take any number of arguments of any type, so there you can write an operator that immediately receives a specific array element, in Rust you need to create a slice. <br><br>  Now let's create a type of Canvas, which allows us to draw without thinking about the implementation of the process itself. <br>  <b>rust</b> <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_pixel</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y:<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color:<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Canvas <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Pixmap { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_pixel</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y:<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color:<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[x][y] = color; } }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y: Int, color: UInt32)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCanvas</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixmap: <span class="hljs-type"><span class="hljs-type">Pixmap</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(width: <span class="hljs-type"><span class="hljs-type">Int</span></span>, height: <span class="hljs-type"><span class="hljs-type">Int</span></span>, fillValue: <span class="hljs-type"><span class="hljs-type">UInt32</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixmap = <span class="hljs-type"><span class="hljs-type">Pixmap</span></span>(width:width, height:height, fillValue:fillValue) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPixel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y: Int, color: UInt32)</span></span></span></span> { pixmap[x, y] = color } }</code> </pre><br><br>  Unfortunately, I could not quickly figure out how to implement an extension for the GenericPixmap type, so I decided to create a new class called MyCanvas that would implement the Canvas protocol, unlike Rust in Swift, you can inherit from the protocols and not only. <br><br>  Now we come to the most interesting - the implementation of the Brezenham algorithm.  We want to draw a line from the point (x1, y1, z1) to the point (x2, y2, z2), for this we need to take (| x2-x1 |, | y2-y1 |, | z2-z1 |) steps in the direction , which depends on the signs of the expression (x2-x1, y2-y1, z2-z1). <br>  So, we need to go (rx, ry, rz) steps in the directions (sx, sy, sz), for this we find the axis along which we need to perform the greatest number of steps.  The movement at each step will be equal to (rx / r [max, ry / r [max], rz / r [max]), and the step will occur only if the total movement d has become more than one, then the axis makes a step, and from total displacement is subtracted one.  I.e: <br><pre> <code class="cpp hljs">d[i] += r[i] / r[max] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d[i] &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { r[i] -= s[i]; d[i] -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  It is easy to see that if you multiply the condition by rmax, then you can do without the division operation. <br><pre> <code class="cpp hljs">d[i] += r[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d[i] &gt;= r[max] { r[i] -= s[i]; d[i] -= r[max]; }</code> </pre><br>  As a result, this variant of the algorithm works for any number of coordinates and avoids floating-point operations, which are almost always more expensive than operations with integers. <br><br>  Let's try to write a generator that creates a sequence of points between end nodes a and b.  The point a will be included in the sequence. <br><br>  <b>rust</b> <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RasterState</span></span></span></span> { step: Vec3, d: Vec3, major_axis: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineRasterizer</span></span></span></span> { from: Vec3, to: Vec3, state: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;RasterState&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> LineRasterizer { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(from: Vec3, to: Vec3) -&gt; LineRasterizer { LineRasterizer { from: from, to: to, state: <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next_point</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Vec3&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> state = RasterState { step: Vec3 { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, z: <span class="hljs-number"><span class="hljs-number">0</span></span> }, d: Vec3 { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, z: <span class="hljs-number"><span class="hljs-number">0</span></span> }, major_axis: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to[i] - <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[i]; state.step[i] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { -<span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d = d.abs(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d &gt; max { max = d; state.major_axis = i <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(state); <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from) }, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> state) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> from = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calc_residual_steps = |axis| { (to[axis] - from[axis]).abs() }; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[state.major_axis] += state.step[state.major_axis]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rs_base = calc_residual_steps(state.major_axis); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rs = calc_residual_steps(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i != state.major_axis { state.d[i] += rs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.d[i] &gt;= rs_base { state.d[i] -= rs_base; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[i] += state.step[i]; } } } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from) } }, } } }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineRaster</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step: <span class="hljs-type"><span class="hljs-type">Vector3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d: <span class="hljs-type"><span class="hljs-type">Vector3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> majorAxis: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.step = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, z: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.d = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, z: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.majorAxis = <span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from: <span class="hljs-type"><span class="hljs-type">Vector3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> to: <span class="hljs-type"><span class="hljs-type">Vector3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: <span class="hljs-type"><span class="hljs-type">State?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from: <span class="hljs-type"><span class="hljs-type">Vector3</span></span>, to: <span class="hljs-type"><span class="hljs-type">Vector3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from = from <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to = to } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next_point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector3?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calsResidualSteps = {axis <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to[axis] - <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[axis])} <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[state.majorAxis] += state.step[state.majorAxis]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rsBase = calsResidualSteps(state.majorAxis); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rs = calsResidualSteps(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i != state.majorAxis { state.d[i] += rs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.d[i] &gt;= rsBase { state.d[i] -= rsBase; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[i] += state.step[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-type"><span class="hljs-type">State</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.to[i] - <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from[i]; state.step[i] = d &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> da = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> da &gt; <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = da; state.majorAxis = i; }; } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state = state <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.from } } }</code> </pre><br><br>  I decided to make the state of the generator as an optional value, this allows us to easily and immediately return the starting point from from the generator without the need for additional flags.  In Rust, optional values ‚Äã‚Äãare made simply through the enum Option, while in Swift they are part of the language, which makes it easy to describe optional call chains without too much syntactic noise. <br>  In Rust, an advanced possession system is used to tell it that we are borrowing a State from the listing by reference, you need to write the keyword ref.  In Swift, State is by default the reference data type, and move semantics in the language is not yet observed, so we can just take and unpack the state without worrying about anything. <br><br>  Write type code: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">while</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point</span></span></span><span class="hljs-function">)</span></span> = rasterizer.next_point() { ... }</code> </pre><br>  It seems to me not too elegant, much more logical for this looks. <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> generator { ... }</code> </pre><br>  Fortunately, in order to be able to use a for loop, it is enough just to implement several types for our generator. <br>  <b>rust</b> <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> LineRasterizer { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = Vec3; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.next_point() } }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineRaster</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeneratorType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector3?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.next_point() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineRaster</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SequenceType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LineRaster</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } }</code> </pre><br><br>  And for Swift, you need to implement as many as two protocols, while for Rust only one is enough, but it makes no fundamental difference. <br><br><h4>  Let's measure performance a little </h4><br><br>  The speed of code execution is one of the important factors when comparing different programming languages ‚Äã‚Äãand it would be foolish to write an article without measuring performance. <br><br>  Naive comparison: <br><br>  <b>rust</b> <br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_code</span></span></span></span>(canvas: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Canvas) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Vec3 { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, z:<span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = Vec3 { x: <span class="hljs-number"><span class="hljs-number">50</span></span>, y: <span class="hljs-number"><span class="hljs-number">55</span></span>, z: -<span class="hljs-number"><span class="hljs-number">20</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rasterizer = LineRasterizer::new(a, b); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = std::<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>::MAX; canvas.set_pixel(point.x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, point.y <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000</span></span> { test_code(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> canvas) }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: Canvas)</span></span></span></span> -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, z:<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">50</span></span>, y:<span class="hljs-number"><span class="hljs-number">55</span></span>, z:-<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> raster = <span class="hljs-type"><span class="hljs-type">LineRaster</span></span>(from: a, to: b) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> raster { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = <span class="hljs-type"><span class="hljs-type">UInt32</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> canvas.setPixel(point.x, point.y, color: color) } } ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myCanvas: <span class="hljs-type"><span class="hljs-type">Canvas</span></span> = canvas <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">1000000</span></span> { testCode(myCanvas) }</code> </pre><br><br>  We simply pass the link to the Canvas to the function under test and measure the time. <br>  It turned out 0.86 for Rust versus 5.3 for Swift.  It is likely that Rust somehow zainlaynil calls, while Swift remained at the level of dynamic dispatch.  To verify this, try writing a generic function. <br>  <b>rust</b> <br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_code_generic</span></span></span></span>&lt;T: Canvas&gt;(canvas: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Vec3 { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, z:<span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = Vec3 { x: <span class="hljs-number"><span class="hljs-number">50</span></span>, y: <span class="hljs-number"><span class="hljs-number">55</span></span>, z: -<span class="hljs-number"><span class="hljs-number">20</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rasterizer = LineRasterizer::new(a, b); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = std::<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>::MAX; canvas.set_pixel(point.x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, point.y <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color); } }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCodeGeneric</span></span></span><span class="hljs-function">&lt;T:Canvas&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: T)</span></span></span></span> -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, z:<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">50</span></span>, y:<span class="hljs-number"><span class="hljs-number">55</span></span>, z:-<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> raster = <span class="hljs-type"><span class="hljs-type">LineRaster</span></span>(from: a, to: b) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> raster { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = <span class="hljs-type"><span class="hljs-type">UInt32</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> canvas.setPixel(point.x, point.y, color: color) } }</code> </pre><br>  The results are 0.83 for Rust, against 4.94 for Swift, which tells us that after all, Swift managed to better optimize the code, but somewhere else there were still bottlenecks that he could not figure out. <br><br>  Now we will try to pack the Canvas into the box, and for Swift to use the inout modifier, which is similar to &amp; mut in its action. <br>  <b>rust</b> <br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_code_boxed</span></span></span></span>(canvas: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Canvas&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Vec3 { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, z:<span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = Vec3 { x: <span class="hljs-number"><span class="hljs-number">50</span></span>, y: <span class="hljs-number"><span class="hljs-number">55</span></span>, z: -<span class="hljs-number"><span class="hljs-number">20</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rasterizer = LineRasterizer::new(a, b); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = std::<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>::MAX; canvas.set_pixel(point.x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, point.y <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color); } }</code> </pre><br>  <b>swift</b> <br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCodeInout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> canvas: Canvas)</span></span></span></span> -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y:<span class="hljs-number"><span class="hljs-number">0</span></span>, z:<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-type"><span class="hljs-type">Vector3</span></span>(x: <span class="hljs-number"><span class="hljs-number">50</span></span>, y:<span class="hljs-number"><span class="hljs-number">55</span></span>, z:-<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> raster = <span class="hljs-type"><span class="hljs-type">LineRaster</span></span>(from: a, to: b) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> raster { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = <span class="hljs-type"><span class="hljs-type">UInt32</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> canvas.setPixel(point.x, point.y, color: color) } }</code> </pre><br><br>  Results 0.91 for Rust, against 6.44 for Swift. <br><br>  Boxing slowed down the execution of the code, but not so much, but the addition of inout had a significant impact on Swift.  Apparently the opportunity to change the link to canvas binds the optimizer hands. <br><br>  In general, Rust turns out to be more productive with a similar style of writing code.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The concept of ownership allows the compiler not only to check the correctness of the program at the compilation stage, but also to avoid using the reference counter in cases where it is not needed; on the contrary, you obviously must use it if you need it. </font><font style="vertical-align: inherit;">Swift, by default, uses reference counts everywhere for classes, which in many cases leads to poor performance, and even if the compiler can remove reference counting in some trivial cases, it will not guarantee that in slightly more complicated cases it will be able to do this, Rust just won't let the code compile. </font><font style="vertical-align: inherit;">This indicates both the greater maturity of the compiler, and the effectiveness of the concepts embodied in it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I would like to compare how Rust and Swift look like an old C ++ background.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Completely ordinary benchmark code</font></font></b> <div class="spoiler_text"><pre> <code class="hljs kotlin">#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cassert&gt; #include &lt;memory&gt; #include &lt;cstdlib&gt; template &lt;typename T&gt; struct GenericPixmap { size_t w, h; std::vector&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; GenericPixmap(size_t w_, size_t h_, T fill_data = T()) : w(w_), h(h_), <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>(w_*h_, fill_data) { } T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (size_t i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[i*w]; } }; struct Vec3 { int x, y, z; int&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (size_t i) { assert(i &gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); switch (i) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; case <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; case <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; } }; bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3 &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3 &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ax == bx &amp;&amp; ay == <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> &amp;&amp; az &amp;&amp; bz; } bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3 &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3 &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } struct RasterState { Vec3 step; Vec3 d; size_t majorAxis; }; struct LineRaster { Vec3 from; Vec3 to; bool firstStep; RasterState state; LineRaster(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3 &amp;f, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3 &amp;t) : from(f), to(t), firstStep(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), state{} {} bool next_point() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstStep) { size_t max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { auto d = to[i] - from[i]; state.step[i] = d &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : -<span class="hljs-number"><span class="hljs-number">1</span></span>; d = std::abs(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &gt; max) { max = d; state.majorAxis = i; } } firstStep = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == to) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { auto calc_rs = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](auto axis) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::abs(to[axis] - from[axis]); }; from[state.majorAxis] += state.step[state.majorAxis]; auto rs_base = calc_rs(state.majorAxis); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { auto rs = calc_rs(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i != state.majorAxis) { state.d[i] += rs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.d[i] &gt;= rs_base) { state.d[i] -= rs_base; from[i] += state.step[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } }; using Pixmap = GenericPixmap&lt;uint32_t&gt;; void test_code(Pixmap &amp;pixmap) { Vec3 a { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; Vec3 b { <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, -<span class="hljs-number"><span class="hljs-number">20</span></span> }; LineRaster raster(a, b); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (raster.next_point()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> auto &amp;p = raster.from; pixmap[px][py] = <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; } } int main(int, char **) { Pixmap pixmap(<span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Vec3 a { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; Vec3 b { <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, -<span class="hljs-number"><span class="hljs-number">4</span></span> }; LineRaster raster(a, b); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (raster.next_point()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> auto &amp;p = raster.from; uint32_t color = <span class="hljs-number"><span class="hljs-number">0xffffff</span></span>; pixmap[px][py] = color; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"C++: point x:"</span></span> &lt;&lt; px &lt;&lt; <span class="hljs-string"><span class="hljs-string">" y:"</span></span> &lt;&lt; py &lt;&lt; <span class="hljs-string"><span class="hljs-string">" z:"</span></span> &lt;&lt; pz &lt;&lt; <span class="hljs-string"><span class="hljs-string">" color:"</span></span> &lt;&lt; color &lt;&lt; std::endl; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++i) test_code(pixmap); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of writing, I ran into several segmentation errors and even had to work it out in lldb before getting the result. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.79 for Rust, against 0.31 for gcc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result is very interesting: on the one hand Rust shows almost identical speed with clang, but on the other hand gcc simply surpassed everyone. That is, in general, the llvm platform is much sought after, but within it, Rust is already breathing clang in the back, which means that you can already safely begin to write sections that are critical for performance requirements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full benchmark code is on </font></font><a href="https://github.com/alekseysidorov/playground/tree/master/swift_vs_rust"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Suggestions for improving performance are accepted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, it‚Äôs difficult to consider everything in one article, such interesting things as error handling, infrastructure, connection with C or ObjectiveC code, properties, and much more, and I hope that I can touch these things in the future.</font></font><br><br><h4>  findings </h4><br><br>  Swift'      ,      . Rust           . ,           .    zero cost    Rust'   ,       . Swift          ,        ,       Rust'. <br><br>   ,   Swift'   IDE XCode,     OS X,    Cocoa          iOS  OS X. Rust     argo  crates.io,         ,        IDE   GUI . <br><br>         ,   Swift'    ,   Grand Central Dispatch,   Rust'       .        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are more vacancies at Swift now, and it is easier to teach him, but this does not mean that Rust specialists will not be in demand in the near future. </font><font style="vertical-align: inherit;">I think there will be a lot of tasks in the world in which both of these languages ‚Äã‚Äãwill mercilessly compete with each other and, I hope, this will benefit them.</font></font><br><br><h4>  Afterword </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uncompromising and austere Rust, He is favorable to the Bright side, Swift with the same syntactic sugar on the Dark side can start. </font></font><br><br>  <b>Update</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The user </font></font><a href="https://github.com/yarry"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yarry</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sent me a pull request, which managed to speed up the Swift version by half by replacing classes with a structure. </font><font style="vertical-align: inherit;">Structures in Swift behave like their counterparts from the world of C, they stand out on the stack, and for them there is no need to count references because they are copied when passed to a function. </font><font style="vertical-align: inherit;">But at the same time, Swift documentation asserts that in reality copying takes place only when required. </font><font style="vertical-align: inherit;">Thus, with the knowledge of such subtleties, you can significantly speed up the code. </font><font style="vertical-align: inherit;">On the other hand, in Rust you have to think about it explicitly, which, although it makes the learning curve more steep, but then you have to spend less time with profiling and all sorts of experiments to optimize the code.</font></font></div><p>Source: <a href="https://habr.com/ru/post/272681/">https://habr.com/ru/post/272681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272671/index.html">ICQ mobile application design contest</a></li>
<li><a href="../272673/index.html">Shadows of the characters in the video The Blacksmith</a></li>
<li><a href="../272675/index.html">PostgreSQL Designing a Document-Oriented API: Comprehensive Queries (Part 4)</a></li>
<li><a href="../272677/index.html">Perl5 plugin for IntelliJ IDEA v1.2: Moose and Signatures</a></li>
<li><a href="../272679/index.html">Neural network in Python, part 2: gradient descent</a></li>
<li><a href="../272689/index.html">Own index types in Cach√© DBMS</a></li>
<li><a href="../272693/index.html">Microsoft fixed a dangerous vulnerability in Windows Server</a></li>
<li><a href="../272695/index.html">As I have been rewriting my cryptocurrency with PHP for Go for 8 months. Part 1</a></li>
<li><a href="../272697/index.html">Optimizing hyperparameters in Vowpal Wabbit with the new vw-hyperopt module</a></li>
<li><a href="../272701/index.html">How to graze cats. The history of building a system of control and accounting of working time for an IT company</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>