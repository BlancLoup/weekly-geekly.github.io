<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some of the simplest principles of auto-vectorization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My previous post was devoted to cyclic permutation optimizations, loop recognition problems, ambiguity resolution when working with memory, definition...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some of the simplest principles of auto-vectorization</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/14f/cc8/6b0/14fcc86b04cf4790322ca963d13f7c7e.png">  <a href="http://habrahabr.ru/company/intel/blog/162831/">My previous post</a> was devoted to cyclic permutation optimizations, loop recognition problems, ambiguity resolution when working with memory, definition and importance of dependencies.  Now I want to review one of the most efficient loop optimizations - auto-vectorization.  I would like to discuss the issues of optimization efficiency, as well as try to understand what factors determine this efficiency.  Anyone who is interested is welcome.  When discussing, I will focus on Intel's auto vectorizer and auto vectorizer gcc 4.7.2.  I will investigate gcc to confirm that the vectorization principles that I am trying to formulate here are of a rather general nature.  At the same time, of course, I want to understand the level of auto-vectorization in gcc.  Here, of course, there is a certain element of inequality, since I use the latest Intel compiler, but not the most top-notch version of gcc, but basically I will be guided when comparing SSE instructions.  (By the way, Intel is actively involved in the development of the gcc auto vectorizer).  Since Intel and Intel compiler are closer to me, I will pay more attention to it in some places.  I do not pretend to be a vector guru and will be glad if someone sees my mistakes and corrects me.  Letters will be many. <br><a name="habracut"></a><br><br><h4>  Where there is vectorization </h4><br>  Since the very first supercomputers, attempts have been made to implement architectural mechanisms for using data parallelism <a href="http://en.wikipedia.org/wiki/Data_parallelism">(data parallelism)</a> to speed up computations.  In many computing programs, the same operation is applied to a whole data set, usually an array section or array.  In this case, there is some repetitive data access model, as well as operations that can be performed in parallel on elements from this data set.  The first pipelined vector processors supported instruction sets that ran on data vectors.  This data is located directly in memory.  In the <a href="http://ru.wikipedia.org/wiki/Cray-1">Cray-1</a> processor, vector registers were introduced, which greatly accelerated the execution of instructions, since vector registers could save intermediate results of calculations.  The use of vector architectural mechanisms can be programmed directly.  Well, if there is already a program written using sequentially running calculations, it is necessary to modify the program to use data parallelism.  This modification of the sequential algorithm in parallel using data parallelism is called <a href="http://en.wikipedia.org/wiki/Vectorization_(parallel_computing)">vectorization</a> . <br><br>  The history of vectorization and authorization for Intel64 and IA32 Intel architectures in the presentation for dummies looks probably so.  In the glorious good times of the 8086 microprocessor, the venerable father of the entire x86 processor family, this processor worked closely with the math coprocessor, which was designed to support calculations for floating-point numbers, was a separate chip and was installed in a special socket on the motherboard.  Many old-timers remember that when buying personal computers, it was necessary to solve a dilemma, to buy a computer system with a coprocessor (more expensive) or without (cheaper, but slower with real calculations).  The coprocessor supported the <a href="http://ru.wikipedia.org/wiki/X87">x87</a> instruction set and worked with the register stack.  Starting with the Intel486DX processor, the coprocessor was integrated into the processor as an <a href="http://en.wikipedia.org/wiki/Floating-point_unit">FPU</a> floating point <a href="http://en.wikipedia.org/wiki/Floating-point_unit">unit</a> .  This integration added new registers to the microprocessor, namely 8 80-bit data registers for storing floating-point numbers.  But with integer calculations, these resources were not used in any way.  It was decided to process integer vectors on the basis of FPU and the <a href="http://ru.wikipedia.org/wiki/MMX">MMX</a> extension, which first appeared in the Pentium MMX processor, was proposed.  New registers were added to the MPs (8 64 bit MM0-MM7), which were addressed (aliased) to the FPU registers, and the microprocessor instruction set was supplemented with a number of instructions <a href="http://ru.wikipedia.org/wiki/SIMD">(SIMD Single Instruction, Multiple Data)</a> working with these registers and performing integral operations on them.  The concept of packages was introduced, i.e.  each of these registers could store <br>  2 - 32 bit integers <br>  4 - 16 bit <br>  8 - 8 bit <br>  The disadvantage was the inability to simultaneously work with integer packets and real numbers.  It was necessary to switch the processor to a special mode and this switching was carried out for a long time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The next step was the development of the <a href="http://ru.wikipedia.org/wiki/SSE">SSE</a> extension, which was first implemented in Pentium3.  The size of vector registers has been increased to 128 bits.  The appearance of this set of instructions allowed us to solve the problem of simultaneous work with packed whole and real data.  Now the packed integers were processed with the help of MMX, at the same time real calculations are performed using SSE and vector registers.  In addition to vector registers, SSE added a 32-bit flag register and operations with this register to the computing system and expanded the set of SIMD operations on integers.  Instructions were added to explicitly prefetch data, monitor data caching, and monitor the order of save operations, extend CPUID instructions to get information about the processor. <br>  The SSE was followed by an extension of <a href="http://ru.wikipedia.org/wiki/SSE2">SSE2</a> , which added new instructions to SSE to completely overwhelm the MMX and to process packed double-point floating-point data. <br>  <a href="http://ru.wikipedia.org/wiki/SSE3">SSE3</a> , <a href="http://ru.wikipedia.org/wiki/SSSE3">SSEE3</a> , <a href="http://ru.wikipedia.org/wiki/SSE4">SSE4</a> - subsequent SSE extensions. <br>  <a href="http://ru.wikipedia.org/wiki/AVX">AVX is a</a> new expansion of the command system, increasing the size of vector registers to 256 bits. <br>  AVX2 is the new announced expansion of the AVX command system.  <a href="http://news.softpedia.com/news/Intel-2013-Haswell-CPUs-Will-Support-the-AVX2-Instruction-Set-205605.shtml">It is already here</a> . <br><br><h4>  Auto vectorizers </h4><br>  In the modern competitive world, the term ‚Äúeconomic efficiency‚Äù often rules.  Therefore, new teams appear in processors for a reason, and to make the product being produced more attractive to buyers and motivate them to replace old computing architectures with newer, more efficient, energy efficient, <s>cool and trendy ones</s> .  There is even a <a href="http://www.spec.org/">special independent platform</a> , where a methodology has been developed for how to measure the slope and performance correctly.  And if modifying and optimizing existing instructions and improving the architecture can immediately have a positive impact on performance, then you need to work with new instructions.  For example, to persuade manufacturers of compilers to include their support in their products and to track the simultaneous appearance of these products on the market along with new architectures.  It is clear that this situation looks slightly optimistic, so Intel has long enough tried to take the fate of promoting their computing systems in their own hands and in fact offers along with the computing system all the necessary components for its maximum success, such as compilers and performance analyzers.  Therefore, new versions of compilers are released simultaneously with the appearance on the market of iconic new architectures. <br><br>  In order to show the gain from the appearance of new vector instructions, an auto vectorizer is needed in the compiler, i.e.  the compiler must be able to convert the scalar code into a vector itself.  Comparison of the performance of computing systems is performed on representative samples of programs (such as suites CPU2000, CPU2006, CPUV6, and so on).  The ability to vectorize something using assembler inserts or calls to built-in vector intrinsics is not part of the competition condition.  When preparing a competitor (compiling a program before measuring its performance), it is only possible to transfer a set of different compiler options to the compiler.  Therefore, the presence of a high-quality auto vectorizer is an important condition for the promotion of new computing systems in the market, both for Intel‚Äôs and competitors ‚Äôcomputing systems.  It is not surprising that the development of the principles of automatic vectorization is one of the drivers of the development of all computer science. <br><br>  The auto vectorizer is also of great independent value, as an important component of the optimizing compiler, which makes it relatively easy to improve the performance of computational programs.  Vectorization can be performed in various ways.  You can use assembler inserts, you can use the call built-in intrinsikov.  In any case, this approach to vectorization has several disadvantages.  It is rather laborious, it is necessary to port the code for new computing systems when new vector extensions appear, etc.  Although in this case, you can achieve better results than using the auto vectorizer, but this is not an easy job.  It is much more promising, from the manufacturer‚Äôs point of view, to use the auto vectorizer. <br><br>  The advantage of the auto vectorizer is that it is enough to add options when compiling, and the compiler itself will vectorize those cycles that are profitable to vectorize.  Intel's auto vectorizer now works by default, since the default optimization level is O2.  The gcc auto vectorizer works starting with the ‚ÄìO3 option.  Both the one and the other auto vectorizers can be turned on / off with special options.  The auto vectorizer allows you to create applications that are focused on execution on a specific computer system that supports a specific vector extension.  In the Intel compiler, there are several different possibilities for choosing an architecture.  The normal mode, when the vector extension used is chosen, is no different from how the vector extension is selected in gcc.  But for Intel's architectures, you can enable runtime checks and create, for example, multivariate applications with different vectorization options, choosing the best option depending on the architecture on which the program runs.  You can automatically perform optimal vectorization for the machine you are compiling.  Those.  For the icc compiler, there are Intel architectures and all the rest.  I am afraid that fine tuning vectorization for the second type of architecture is not provided.  I can assume that the gcc auto vectorizer is a greater proponent of equality. <br><br>  For better use avtevtorizator desirable to have feedback with him.  If the auto vectorizer reports the results of its work, i.e.  reports what decision he made when vectoring in a particular case, then you can try to deal with problems that interfere with vectorization.  Both icc and gcc have this functionality.  icc has the option ‚Äìvec_report, and gcc reports on the operation of the auto vectorizer using the option ‚Äìftree-vectorizer-verbose.  It is clear that the icc report is focused on users, while the gcc report is on developers.  Increasing the level of accountability in gcc, you can get a lot of interesting details about the ‚Äúthinking process‚Äù of the auto-vectorizer, which is quite interesting, since the commercial icc reluctantly shares its secrets.  On the other hand, if the important details of gcc need to be caught in a pile of other information, then icc is sufficiently concise. <br><br><h4>  An example of using an auto vectorizer </h4><br>  Let's take a simple function and try to look at the diagnostics of vectorizers. <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * a,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * c , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { a[i] = a[i]+b[i]+c[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><pre> <code class="hljs pgsql">gcc -c -O3 -march=native -std=c99 -mfpmath=sse -ftree-vectorizer-<span class="hljs-keyword"><span class="hljs-keyword">verbose</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span> vector.c Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">2</span></span> Vectorizing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: created <span class="hljs-number"><span class="hljs-number">2</span></span> versioning <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> checks. <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> VECTORIZED. vector.c:<span class="hljs-number"><span class="hljs-number">1</span></span>: note: vectorized <span class="hljs-number"><span class="hljs-number">1</span></span> loops <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>.</code> </pre><br>  Do not forget when working with real add for gcc ‚Äìmfpmath = sse, otherwise the vectorizer does not work. <br>  Well, and similarly for icc: <br><pre> <code class="hljs swift">icc -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> -vec_report3 -xhost -std=c99 vector.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> vector.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: <span class="hljs-type"><span class="hljs-type">LOOP</span></span> <span class="hljs-type"><span class="hljs-type">WAS</span></span> <span class="hljs-type"><span class="hljs-type">VECTORIZED</span></span> vector.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: loop skipped: multiversioned</code> </pre><br><br><h4>  An approximate scheme of vectorization of the simplest cycle </h4><br>  Basically, vectorization is performed for loops, in which case it is a cyclic permutation optimization.  It is this vectorization that I would like to consider.  Here I tried to draw a certain vectorization scheme.  Before vectorization, we have some kind of data of the same type and we perform operations of the same type over the elements of these sets and save the result of the calculations.  When vectoring this sequential code, it is necessary to form vector scalar data (write data to vector registers), apply the vector operation to these vectors and then save the result from the vector register to memory.  If a simple loop with a single statement inside is vectorized, then the unrolling of this cycle can be represented as the first stage of vectorization by the number N, which is equal to the number of elements of the type used in the vector register.  As a result of loop vectoring, one vector iteration replaces N scalar iterations.  In the general case, we can assume that during vectorization, the data must be ‚Äúpacked‚Äù into vector registers.  Although the operands of vector instructions can be memory addresses, but these addresses must be aligned in memory and in most cases the vectorizer needs to work to ensure that this condition is met. <br><br><img src="http://habrastorage.org/storage2/1e4/a1b/a1b/1e4a1ba1b58d77139f1b22da83c45727.png"><br><br><h4>  The admissibility of vectorization </h4><br>  Since we consider vectorization as a cycle optimization, it is performed only for ‚Äúgood‚Äù cycles, i.e.  cycles with a certain number of iterations and sequentially changing iteration variables.  That is, in order for the auto vectorizer to vectorize cycles, they must first be recognized.  What difficulties the compiler has to overcome when recognizing loops, I described in a <a href="http://habrahabr.ru/company/intel/blog/162831/">previous post</a> . <br>  Cycle vectoring changes the order of operations in the loop.  If the loop body contains several statements for evaluating (statements), then the order of execution of these statements changes as shown in the diagram: <br><br><img src="http://habrastorage.org/storage2/b47/735/557/b47735557608627c932910df2d1050e3.png"><br><br>  According to the criterion for the permissibility of permutation optimizations, vectorization is admissible if the order of dependent computations does not change.  Due to the peculiarities of vectorization, it does not change the order of lexical dependencies for data forward (lexically forward data dependencies), but can break the self-dependency introduced by the loop and inverse dependencies (self and backward dependencies).  Whether such dependencies will be violated depends on the distance between the dependent statements.  If this distance is more than N (the number of elements of this type in the vector register), then the dependencies will not be broken.  It is also interesting that the so-called ‚Äúoutput dependencies‚Äù may not be violated during vectorization, if saving to vector registers and unloading from them are performed sequentially, i.e.  in the same order as in the program. <br><br>  In order to understand whether vectorization is permissible, it is necessary to perform a dependency analysis.  The worst case is that there are different objects in the loop that can refer to the same memory.  And if we go back to our first example, then this is exactly the situation we have here.  If the Calculate function is compiled separately, then in general, the pointers a, b, c can refer to the same or intersecting memory.  As can be seen from the reports, both vectorizers coped with this work by adding checks on the execution time and the multi-version code (although they say this in a different language).  As a result, additional instructions were added to the code.  Now, if certain memory segments that start with the pointers a, b, c and have a size of n * sizeof (float) do not overlap, then a vectorized cycle is called, and in the opposite case a scalar cycle.  Function code has increased significantly, execution time checks reduce performance. <br><br>  It is possible to make auto-vectoring more optimal in several ways, namely: either transmitting the information to the compiler itself that the objects do not overlap in memory, or adding interprocedural analysis, in the hope that the compiler will be able to prove it.  Interprocedural analysis is another large separate topic.  But it is clear that, theoretically, we can check whether the actual arguments of all the Calculate function calls out from memory, and if not, then extend this knowledge to the formal arguments of the Calculate function.  Let's expand the very first test a bit and see if the compilers know how to draw such information. <br><br><pre> <code class="hljs mel">#include &lt;stdlib.h&gt; #define N <span class="hljs-number"><span class="hljs-number">2000</span></span> static void Calculate(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * a,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * c , <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { a[i] = a[i]+b[i]+c[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> test() { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *x,*y,*z,ret; x=(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)malloc(N*sizeof(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)); y=(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)malloc(N*sizeof(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)); z=(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)malloc(N*sizeof(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;N;i++) { x[i] = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;y[i] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; z[i] = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; } Calculate(x,y,z,N); ret=x[<span class="hljs-number"><span class="hljs-number">1</span></span>]; free(x); free(y);free(z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  When compiling, we prohibit inline in order to save the Calculate function.  Here, interprocedural analysis is used only for functions from the vector.c source file and the static attribute allows the compiler to understand that there are no calls to this function somewhere in other source files and the function can be modified according to the detected properties of its actual arguments. <br><pre> <code class="hljs cpp">gcc -c -O3 -fno-<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> -fipa-pta -march=native -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 -mfpmath=sse -ftree-vectorizer-verbose=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c ... Vectorizing loop at <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: LOOP VECTORIZED. ... icc -c -ip -ip-no-inlining -vec_report3 -xhost -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">5</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">5</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: REMAINDER LOOP WAS VECTORIZED</code> </pre><br>  For gcc, you must add the -fipa-pta option (Perform interprocedural pointer analysis and interprocedural modification and reference analysis), since this option is not included in the default optimization options.  In this case, gcc and icc successfully coped with the task of pulling the properties of actual arguments. <br><br>  In order not to strain the compiler once again with the analysis of the program, it is simpler to add a restrict qualifier to the pointer descriptions to indicate to the compiler that the data referenced by the pointer can be addressed only with its help.  If there are no objects in the cycle that can be aliased, then the analysis of dependencies should be able to find dependencies (for example, referring to the same array element at different iterations of the cycle), determine their type, distance between dependent iterations, chronological order and determine the validity of .  Work is not easy at all. <br>  Let's see how the auto vectorizers work, informing the user about the problems.  Consider a few typical cases where dependencies can affect vectorization: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n<span class="hljs-number"><span class="hljs-number">-3</span></span>;i++) <span class="hljs-comment"><span class="hljs-comment">//3 a[i+3] = a[i]+1; for(int i=0;i&lt;n-5;i++) //5 a[i+5] = a[i]+1; for(int i=3;i&lt;n;i++) //7 a[i-3]=a[i]+1; for(int i=0;i&lt;n;i++) //9 b[i]=a[vec[i]]; for(int i=0;i&lt;n;i++) //11 a[vec[i]] = b[i]*vec[i]; for(int i=1;i&lt;n;i++) { //13 a[i]=c[i]+1; b[i]=a[i-1]; } for(int i=0;i&lt;n-1;i++) { //17 a[i]=c[i]+1; b[i]=a[i+1]; } for(int i=0;i&lt;n-5;i++) { //21 a[i]=c[i]+1; b[i]=a[i+5]; } return; }</span></span></code> </pre><br>  In the first two cycles, we have lexically inverse dependencies (backward dependencies) and the distance between dependencies 3 and 5. When working with 128 bit registers (SSE), this makes it difficult to vectorize the entire width of the vector register for the first cycle.  When working with 256 bit registers (AVX), vectorization over the entire width of the vector register is also impossible in the second case.  In the third cycle, there is a forward dependence (forward dependence), which does not prevent vectorization.  The fourth and fifth cycles are cases of vector indexing.  In the fifth case, there is an output relation (output dependence), i.e.  the order of writing to memory matters.  This dependence does not interfere with vectorization, since, although vector operations are performed, the results from vector registers are retrieved sequentially in memory, and this, ultimately, helps to maintain the correct result.  In the sixth cycle, there is a forward relationship between the two statements of the cycle.  The seventh and eighth case - inverse dependencies. <br><pre> <code class="hljs pgsql">gcc -c -O3 -fno-<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> -march=corei7-avx -std=c99 -mfpmath=sse -ftree-<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>-distribution -ftree-vectorizer-<span class="hljs-keyword"><span class="hljs-keyword">verbose</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> vector.c Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">21</span></span> Vectorizing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> VECTORIZED. Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">17</span></span> Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">13</span></span> Vectorizing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> VECTORIZED. Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">11</span></span> Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">9</span></span> Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">7</span></span> Vectorizing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> VECTORIZED. Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">5</span></span> Vectorizing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> VECTORIZED. Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">3</span></span> vector.c:<span class="hljs-number"><span class="hljs-number">1</span></span>: note: vectorized <span class="hljs-number"><span class="hljs-number">4</span></span> loops <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>.</code> </pre><br>  Gcc did not want to consider cycles with vector indexing.  In cycles with inverse dependencies, I calculated the distances and vectorized them, where possible.  At the same time, he lowered the vectorization base for cycles // 5 and // 21, i.e.  made vectorization for 128 bit registers.  You can find out about this by increasing the value for ‚Äìfree-vectorizer-verbose. <br><pre> <code class="hljs swift">‚Ä¶ <span class="hljs-number"><span class="hljs-number">21</span></span>: === vect_analyze_dependences === <span class="hljs-number"><span class="hljs-number">21</span></span>: dependence <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>. <span class="hljs-number"><span class="hljs-number">21</span></span>: adjusting maximal vectorization factor to <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>: dependence <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span> &gt;= <span class="hljs-type"><span class="hljs-type">VF</span></span>. <span class="hljs-number"><span class="hljs-number">21</span></span>: bad data dependence. <span class="hljs-number"><span class="hljs-number">21</span></span>: ***** <span class="hljs-type"><span class="hljs-type">Re</span></span>-trying analysis with vector size <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br>  Similarly for icc we get. <br><pre> <code class="hljs cpp">icc -c -ip -vec_report3 -xAVX -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">3</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: loop was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vectorized: existence of <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> dependence <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">4</span></span>): (col. <span class="hljs-number"><span class="hljs-number">7</span></span>) remark: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> dependence: assumed FLOW dependence between a line <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a line <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">5</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">7</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">9</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">9</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: REMAINDER LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">11</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">13</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">17</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: PARTIAL LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">17</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: PARTIAL LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">21</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: PARTIAL LOOP WAS VECTORIZED <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c(<span class="hljs-number"><span class="hljs-number">21</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: PARTIAL LOOP WAS VECTORIZED</code> </pre><br>  icc did not vectorize only cycle // 3.  Interestingly, the // 17 cycle was previously divided into two, and then both were vectorized.  The same was done for the cycle // 21, although this was not necessary. <br>  ftree-loop-distribution could help gcc vectorize the // 17 cycle by first breaking it into two, but for some reason did not. <br><br>  Another interesting example looks like this.  Actually, this is the simplest work with square matrices. <br><pre> <code class="hljs matlab">void ttt(int *restrict a, int * restrict b, int n) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;n;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>&lt;n;<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) a[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>+n*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = a[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>+n*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + b[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+n*<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  icc vectorizes the inner loop successfully, and gcc writes ‚Äúnot suitable for gather‚Äù (?). <br><pre> <code class="hljs pgsql">gcc -c -fno-<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> -O3 -march=corei7 -std=c99 -mfpmath=sse -ftree-vectorizer-<span class="hljs-keyword"><span class="hljs-keyword">verbose</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> vector.c Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vectorized: data <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> analysis failed D<span class="hljs-number"><span class="hljs-number">.2238</span></span>_18 = *D<span class="hljs-number"><span class="hljs-number">.2237</span></span>_17; Analyzing <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> at vector.c:<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vectorized: <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> suitable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> gather D<span class="hljs-number"><span class="hljs-number">.2238</span></span>_18 = *D<span class="hljs-number"><span class="hljs-number">.2237</span></span>_17; vector.c:<span class="hljs-number"><span class="hljs-number">6</span></span>: note: vectorized <span class="hljs-number"><span class="hljs-number">0</span></span> loops <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>.</code> </pre><br>  When I talked about the acceptance criterion for permutation optimizations, I already mentioned that there are directives that can be used to convey to the auto vectorizer the intimate knowledge about the program.  For example, you use vector indexing and know that each vector index is unique.  Then the dependencies caused by the use of such indexing can not be.  For example: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) a[vec[i]] += b[i]*c[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  Those.  there may be a dependency if there are identical vec [i] and vec [j].  As I found out, gcc does not understand vector indexing.  icc issues the following diagnostics: <br><pre> <code class="hljs pgsql">icc -c -vec_report3 -xSSE4<span class="hljs-number"><span class="hljs-number">.2</span></span> -std=c99 vector.c ector.c(<span class="hljs-number"><span class="hljs-number">3</span></span>): (col. <span class="hljs-number"><span class="hljs-number">3</span></span>) remark: <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vectorized: existence <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> vector dependence vector.c(<span class="hljs-number"><span class="hljs-number">4</span></span>): (col. <span class="hljs-number"><span class="hljs-number">7</span></span>) remark: vector dependence: assumed ANTI dependence <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> vector.c(<span class="hljs-number"><span class="hljs-number">4</span></span>): (col. <span class="hljs-number"><span class="hljs-number">7</span></span>) remark: vector dependence: assumed FLOW dependence <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> vector.c(<span class="hljs-number"><span class="hljs-number">4</span></span>): (col. <span class="hljs-number"><span class="hljs-number">7</span></span>) remark: vector dependence: assumed FLOW dependence <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> vector.c(<span class="hljs-number"><span class="hljs-number">4</span></span>): (col. <span class="hljs-number"><span class="hljs-number">7</span></span>) remark: vector dependence: assumed ANTI dependence <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  This problem can be solved by placing #pragma ivdep in front of the loop.  This pragma states that there are no supposed dependencies in the loop.  After substituting this pragma, the compiler successfully vectorizes this loop. <br><br>  In cases of more complex cycles, the report of the vectorizer can give an idea of ‚Äã‚Äãthe dependencies that impede vectorization.  Having studied these problems, one can assess whether they are caused by real-life dependencies or simply the compiler is unable to prove the absence of dependencies.  In the second case, the auto vectorizer can be improved with #pragma ivdep. <br>  I was surprised to find that the gcc compiler does not support this pragma and the corresponding tracker exists since 2007. <br><br><h4>  Factors determining the effectiveness of vectorization: Sequential access </h4><br><br>  It can be seen from the diagram that as a result of vectorization, the number of arithmetic operations performed is reduced, but it also becomes necessary to ‚Äúpackage‚Äù the data into vector registers.  The data can be placed in vector registers elementwise or using a single copy from memory.  If the elements are not located in memory continuously, then loading into registers can be done only elementwise.  If the vectorized read / write statements are the main operations, then the benefit from vectorization becomes doubtful - with vectorization, the number of operations performed varies slightly.  But at the same time, in the vector case, the amount of code increases significantly (as with the sweep by N), which can also have a bad effect on performance. <br><br>  If, for example, consider the simplest loop in which access to the arrays is carried out in step 2 <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i=i+<span class="hljs-number"><span class="hljs-number">2</span></span>) { b[i] = a[i]+<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  then, with vectorization, you can get about such an assembler for the vectorized part of the cycle (using the Intel auto vectorizer for your examples): <br><pre> <code class="hljs mel">icc -S -xSSE4<span class="hljs-number"><span class="hljs-number">.2</span></span> -std=c99 <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>.c ..B1<span class="hljs-number"><span class="hljs-number">.8</span></span>: # Preds ..B1<span class="hljs-number"><span class="hljs-number">.8</span></span> ..B1<span class="hljs-number"><span class="hljs-number">.7</span></span> movd <span class="hljs-number"><span class="hljs-number">24</span></span>(%edi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>), %xmm1 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> movd <span class="hljs-number"><span class="hljs-number">8</span></span>(%edi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>), %xmm3 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> movd <span class="hljs-number"><span class="hljs-number">16</span></span>(%edi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>), %xmm2 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> movd (%edi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>), %xmm4 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> punpckldq %xmm1, %xmm3 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> punpckldq %xmm2, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> punpckldq %xmm3, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> paddd %xmm0, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> movd %xmm4, (%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> psrldq $4, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> movd %xmm4, <span class="hljs-number"><span class="hljs-number">8</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> psrldq $4, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> movd %xmm4, <span class="hljs-number"><span class="hljs-number">16</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> psrldq $4, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> movd %xmm4, <span class="hljs-number"><span class="hljs-number">24</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> addl $4, %eax #<span class="hljs-number"><span class="hljs-number">3.4</span></span> cmpl %edx, %eax #<span class="hljs-number"><span class="hljs-number">3.4</span></span> jb ..B1<span class="hljs-number"><span class="hljs-number">.8</span></span> # Prob <span class="hljs-number"><span class="hljs-number">82</span></span>%</code> </pre><br>  This example speaks for itself.  Several vector registers are used to form the vector a [i: i + N].  The body of the cycle grows significantly and it is probably difficult to expect an improvement in productivity from such vectorization. <br><br>  Advanced vectorizers may ask, what about scatter / gathering?  At the moment, the implementation of the gather is done for computers that support AVX2.  At least, the gather reduces the number of instructions.  In this case: <br><pre> <code class="hljs mel">icc -S -xCORE-AVX2 -std=c99 <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>.c .B1<span class="hljs-number"><span class="hljs-number">.8</span></span>: # Preds ..B1<span class="hljs-number"><span class="hljs-number">.8</span></span> ..B1<span class="hljs-number"><span class="hljs-number">.7</span></span> lea (%edi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>), %ebx #<span class="hljs-number"><span class="hljs-number">4.14</span></span> vpxor %ymm3, %ymm3, %ymm3 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> vpcmpeqd %ymm2, %ymm2, %ymm2 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> vpgatherdd %ymm2, (%ebx,%ymm0,<span class="hljs-number"><span class="hljs-number">8</span></span>), %ymm3 #<span class="hljs-number"><span class="hljs-number">4.14</span></span> vpaddd %ymm1, %ymm3, %ymm4 #<span class="hljs-number"><span class="hljs-number">4.19</span></span> vextracti128 $1, %ymm4, %xmm2 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vpsrldq $4, %xmm4, %xmm5 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm4, (%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vpsrldq $4, %xmm2, %xmm3 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vpsrldq $4, %xmm5, %xmm6 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vpsrldq $4, %xmm3, %xmm4 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm5, <span class="hljs-number"><span class="hljs-number">8</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vpsrldq $4, %xmm6, %xmm7 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vpsrldq $4, %xmm4, %xmm5 #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm6, <span class="hljs-number"><span class="hljs-number">16</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm7, <span class="hljs-number"><span class="hljs-number">24</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm2, <span class="hljs-number"><span class="hljs-number">32</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm3, <span class="hljs-number"><span class="hljs-number">40</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm4, <span class="hljs-number"><span class="hljs-number">48</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> vmovd %xmm5, <span class="hljs-number"><span class="hljs-number">56</span></span>(%esi,%eax,<span class="hljs-number"><span class="hljs-number">8</span></span>) #<span class="hljs-number"><span class="hljs-number">4.7</span></span> addl $8, %eax #<span class="hljs-number"><span class="hljs-number">3.4</span></span> cmpl %edx, %eax #<span class="hljs-number"><span class="hljs-number">3.4</span></span> jb ..B1<span class="hljs-number"><span class="hljs-number">.8</span></span></code> </pre><br><br>  Sequential access allows you to simplify the procedure for loading memory into registers, so vectorization will be all the more efficient than sequential access to more objects in a loop.  On the other hand, if the vectorized code contains a lot of computations and their reuse, then the vectorization can be quite effective even with inconsistent access to objects. <br><br><h4>  Factors determining the efficiency of vectorization: Alignment </h4><br>  The speed of copying from memory also depends on how the memory block to be written into the vector register is aligned.  If there is a work with aligned addresses, then these addresses can be used in the instructions as operands, and due to this a more optimal allocation of registers can be made.  Reading to aligned addresses is faster.  For SSE instructions, addresses aligned at 16 are required; for AVX, at 32. <br><br>  Due to the effect of alignment on performance, the overall loop vectorization scheme looks like this: <br><br><img src="http://habrastorage.org/storage2/ed4/577/648/ed45776480c5bf216da4ceb68e56b8f0.png"><br><br>  In general, the cycle vectorization generates three cycles: a cycle to achieve elements of some processed object aligned with memory, a vectorized part and a scalar tail cycle.  If several objects are processed within the loop, then all of them cannot be aligned and it is necessary to select the ‚Äúlead‚Äù object and adjust to it. <br><br>  To evaluate the effect of alignment, let's invent a simple test that will work with both aligned and unaligned memory.  With the PERF macro, we create two program variants.  In one, the arguments that are aligned in different ways will be passed to the ttt function, in the other - in the same way.  Studying assembler files leads to the idea that both icc and gcc chose array ‚Äúa‚Äù as the ‚Äúleading‚Äù array.  Therefore, several scalar iterations will be inserted in front of the vector cycle to align it.  And the array ‚Äúb‚Äù will be equalized in one version of the program, but not in the other.  Well, suppress the substitution so that the function body is the same for both executable files.  Align the memory for the processed arrays select using memalign. <br><br><pre> <code class="hljs mel">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;malloc.h&gt; #define N <span class="hljs-number"><span class="hljs-number">1000</span></span> void ttt(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * restrict a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * restrict b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { a[i] = a[i]+b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *a,*b; a = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)memalign(<span class="hljs-number"><span class="hljs-number">32</span></span>,N*sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); b = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)memalign(<span class="hljs-number"><span class="hljs-number">32</span></span>,N*sizeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;N;i++) { a[i]=i; b[i]=i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rep=<span class="hljs-number"><span class="hljs-number">0</span></span>; rep&lt;<span class="hljs-number"><span class="hljs-number">10000000</span></span>; rep++) { #ifndef PERF ttt(&amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>],&amp;b[<span class="hljs-number"><span class="hljs-number">1</span></span>],N<span class="hljs-number"><span class="hljs-number">-3</span></span>); ttt(&amp;a[<span class="hljs-number"><span class="hljs-number">1</span></span>],&amp;b[<span class="hljs-number"><span class="hljs-number">2</span></span>],N<span class="hljs-number"><span class="hljs-number">-4</span></span>); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ttt(&amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>],&amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>],N<span class="hljs-number"><span class="hljs-number">-3</span></span>); ttt(&amp;a[<span class="hljs-number"><span class="hljs-number">1</span></span>],&amp;b[<span class="hljs-number"><span class="hljs-number">1</span></span>],N<span class="hljs-number"><span class="hljs-number">-4</span></span>); #endif } printf(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>,a[<span class="hljs-number"><span class="hljs-number">100</span></span>]); free(a); free(b); }</code> </pre><br><pre> <code class="hljs cpp">icc -ip-no-inlining -vec_report3 -xSSE4<span class="hljs-number"><span class="hljs-number">.2</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c -o vector_sse icc -DPERF -ip-no-inlining -vec_report3 -xSSE4<span class="hljs-number"><span class="hljs-number">.2</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c -o vector_sse_perf</code> </pre><br>  On my laboratory machine I get these tsiferki: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">time</span></span> ./vector_sse : <span class="hljs-number"><span class="hljs-number">6.36</span></span>s <span class="hljs-type"><span class="hljs-type">time</span></span> ./vector_sse_perf : <span class="hljs-number"><span class="hljs-number">3.46</span></span>s</code> </pre><br>  I did not expect such a difference.  It is clear that all data is located in the cache.  In a real program, this difference is probably more difficult to obtain due to alignment. <br>  We look, and what gcc will show in this situation: <br><pre> <code class="hljs cpp">gcc -fno-<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> -O3 -march=corei7 -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 -mfpmath=sse -ftree-vectorizer-verbose=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c -o <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> gcc -fno-<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> -DPERF -O3 -march=corei7 -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>=c99 -mfpmath=sse -ftree-vectorizer-verbose=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.c -o vector_perf time ./<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> : <span class="hljs-number"><span class="hljs-number">6.49</span></span>s time ./vector_perf : <span class="hljs-number"><span class="hljs-number">3.61</span></span>s</code> </pre><br>  Those.  it can be concluded that alignment has a very positive effect on performance if there are a lot of iterations in the loop. <br><br>  Since alignment has such a strong effect on performance, I would like to have the tools to manipulate this characteristic.  Such tools are.  If memory for the array is allocated on the stack, then you can use the __attribute __ ((aligned (N))) construct. For example, like this: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[N] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">32</span></span>)));</code> </pre><br>  Using this attribute, you can align arrays located inside a class or structure.  I already use in my program an analogue of the malloc function, namely memalign, a function that returns aligned memory.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have taken care of alignment and want the auto vectorizer to create code for memory-aligned objects, but program analysis does not allow using this object property correctly, then you can use the built-in __builtin_assume_aligned function, for example:</font></font><br><pre> <code class="hljs lisp">int * aa =__builtin_assume_aligned(<span class="hljs-name"><span class="hljs-name">a</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, this will lead to the fact that the auto vectorizer will generate code without an alignment loop, it will be possible to use instructions for working with aligned memory, and it will be possible to use memory addresses as operands for vector instructions. </font><font style="vertical-align: inherit;">(If the first item can simply affect the performance, then the subsequent ones will lead to disastrous consequences for the program if the real object is not aligned.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also #pragma vector aligned. </font><font style="vertical-align: inherit;">As I understand it, if it is used, all objects involved in vectorization will be considered aligned.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evaluation of auto-vectoring utility </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since there are vectorization efficiency factors associated with the operation of the computing system itself, it would be logical to somehow take these factors into account when performing the vectorization in order not to vectorize deliberately failures and not degrade application performance. </font><font style="vertical-align: inherit;">It is logical to have a heuristic mechanism that weighs all the factors for and against vectorization and issues its conclusion. </font><font style="vertical-align: inherit;">For the icc compiler, the conclusion looks like this:</font></font><br><pre> <code class="hljs pgsql">vector.c(<span class="hljs-number"><span class="hljs-number">3</span></span>): (col. <span class="hljs-number"><span class="hljs-number">4</span></span>) remark: <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vectorized: vectorization possible but seems inefficient</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gcc with the option -ftree-vectorizer-verbose = 3 talks about the course of its reasoning (for example, it refuses to vectorize a short cycle): </font></font><br><pre> <code class="hljs sql">8: cost model: prologue peel iters <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> vf/<span class="hljs-number"><span class="hljs-number">2.</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span> <span class="hljs-keyword"><span class="hljs-keyword">model</span></span>: epilogue peel iters <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> vf/<span class="hljs-number"><span class="hljs-number">2</span></span> because peeling <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alignment <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">unknown</span></span> . <span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span> <span class="hljs-keyword"><span class="hljs-keyword">model</span></span> analysis: Vector inside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> Vector outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> Scalar iteration <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> Scalar outside <span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> prologue iterations: <span class="hljs-number"><span class="hljs-number">2</span></span> epilogue iterations: <span class="hljs-number"><span class="hljs-number">2</span></span> Calculated <span class="hljs-keyword"><span class="hljs-keyword">minimum</span></span> iters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> profitability: <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: Profitability threshold = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> vectorized: vectorization <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> profitable.</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in general, since gcc showed problems with vectorization of objects that are accessed inconsistently, I could not find more complex examples when gcc refuses to vectorize the cycle due to the inefficiency of vectorization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are evaluation mechanisms for deciding on the vectorization and the user believes that the heuristic mechanism has made the wrong conclusion about the benefits of vectorization, then the decision of the vectorizer can be changed, for example, using various pragmas. For example, #pragma vector always recommends that you always vectorize the loop below. In turn, #pragma novector allows you to abandon the vectorization of the cycle.</font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The quality of the auto vectorizer is not limited to all the considerations that were discussed here. </font><font style="vertical-align: inherit;">To obtain an optimal code, the vectorizer needs to cooperate with other cyclic optimizations, use the results of interprocedural analysis, be able to recognize various idioms, be able to reuse vector calculations that have already been done, and much more. </font><font style="vertical-align: inherit;">But I hope that my brief introduction to the topic of auto-vectorization was useful. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, I was not able to notice any errors of the icc auto-vectorizer on the simplest examples. </font><font style="vertical-align: inherit;">The auto vectorizer gcc showed a number of flaws (it refused to vectorize arrays with vector indexing and the case with non-sequential access for a square matrix).</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some useful literature on the subject. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have a great book, Optimizing compilers for modern architectures. </font><font style="vertical-align: inherit;">Authors Randy Allen and Ken Kennedy. </font><font style="vertical-align: inherit;">This book introduces all major aspects of the work of the optimizing compiler. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also ‚ÄúThe software Vectorization Handbook‚Äù. </font><font style="vertical-align: inherit;">The book of engineers for engineers, written by Aart JC Bik and devoted directly to the theory of autor vectorization. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many interesting articles can be found on Intel's sites. </font><font style="vertical-align: inherit;">Read, for example, </font></font><a href="http://software.intel.com/en-us/articles/a-guide-to-auto-vectorization-with-intel-c-compilers"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Guide to Auto-vectorization with Intel C ++ Compilers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/171439/">https://habr.com/ru/post/171439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171429/index.html">MyIDkey USB flash drive</a></li>
<li><a href="../171431/index.html">Simple-Science - Simple experiences for children (digest # 18)</a></li>
<li><a href="../171433/index.html">Designing high-performance systems: what is not told in the books</a></li>
<li><a href="../171435/index.html">Logic - the most interesting news gaming and IT-industry ‚Ññ16</a></li>
<li><a href="../171437/index.html">Object Oriented Design ... in CSS</a></li>
<li><a href="../171441/index.html">Review of the mechanical mechanical keyboard Neo Zelia KB-87</a></li>
<li><a href="../171443/index.html">Using Qt Models</a></li>
<li><a href="../171447/index.html">The fastest SAX parser for python</a></li>
<li><a href="../171449/index.html">Chrome Super Sync Sports Browser Game</a></li>
<li><a href="../171455/index.html">Europeans and European languages: translate or not translate?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>