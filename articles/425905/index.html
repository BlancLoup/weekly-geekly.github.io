<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write an assembler program with overlapping instructions (another bytecode obfuscation technique)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We present to your attention the technique of creating assembler programs with overlapping instructions, - to protect the compiled byte-code from disa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write an assembler program with overlapping instructions (another bytecode obfuscation technique)</h1><div class="post__text post__text-html js-mediator-article"><p>  We present to your attention the technique of creating assembler programs with overlapping instructions, - to protect the compiled byte-code from disassembling.  This technique is able to withstand both static and dynamic analysis of bytecode.  The idea is to pick up such a stream of bytes, when disassembling which starting from two different offsets, two different chains of instructions were obtained, that is, two different ways of executing the program.  To do this, we take multibyte assembler instructions, and hide the protected code in the variable parts of the byte code of these instructions.  In order to deceive the disassembler, setting it on the wrong track (by disguising the chain of instructions), and protecting the hidden chain of instructions from its gaze. </p><br><p><img src="https://habrastorage.org/webt/iu/f0/nj/iuf0njjfado7wk-bt05rlxz5l2w.png"></p><a name="habracut"></a><br><h2 id="tri-neobhodimyh-usloviya-dlya-sozdaniya-effektivnogo-perekrytiya">  Three necessary conditions for creating an effective "overlap" </h2><br><p>  In order to deceive the disassembler, the overlapping code must satisfy the following three conditions: 1) The instructions from the masking chain and the hidden chain must always intersect with each other, i.e.  Must not be aligned relative to each other (their first and last bytes should not be the same).  Otherwise, part of the hidden code will be visible in the masking chain.  2) Both chains should consist of plausible assembler instructions.  Otherwise, the masking will be detected already at the stage of static analysis (having encountered an unsuitable code, the disassembler will correct the command pointer and expose the masking).  3) All instructions of both chains must not only be plausible, but also correctly executable (to avoid this, the program crashed when you try to execute them).  Otherwise, during the dynamic analysis, the failures will attract the close attention of the reverseserver, and the disguise will be revealed. </p><br><h2 id="opisanie-tehniki-perekrytiya-assemblernyh-instrukciy">  Description of the technique of "overlapping" assembly instructions </h2><br><p>  In order for the process of creating an overlapping code to be as flexible as possible, it is necessary to select only such multibyte instructions, in which as many as possible bytes can take an arbitrary value.  These multibyte instructions will make up a masking instruction chain. </p><br><p>  Pursuing the goal of creating an overlapping code that will satisfy the three conditions listed above, we consider each masking instruction as a sequence of bytes of the form: XX YY ZZ. </p><br><p>  Here XX is the instruction prefix (instruction code and other static bytes, which cannot be changed). </p><br><p>  YY are bytes that can be changed arbitrarily (as a rule, these bytes store the immediate numeric value transmitted in the instruction; or the address stored in the operand's memory).  YY bytes should be as large as possible - so that they contain more hidden instructions. </p><br><p>  ZZ are also bytes that can be changed arbitrarily, with the only difference that the combination of ZZ bytes with the following bytes XX (ZZ XX) should form a valid instruction that satisfies the three conditions formulated at the beginning of the article.  Ideally, ZZ should occupy only one byte, so that on YY (this is in fact the most important part - here our hidden code is located) there are as many bytes as possible.  The last hidden instruction must end in ZZ, - creating a convergence point for two chains of execution. </p><br><h2 id="skleivayuschie-instrukcii">  Gluing instructions </h2><br><p>  The combination of ZZ XX - we will call the gluing instruction.  Gluing instruction is necessary, firstly, for joining hidden instructions, which are located in adjacent masking instructions and, secondly, to fulfill the first necessary condition voiced at the beginning of the article: the instructions of both chains must always intersect with each other (therefore, the gluing instruction always is located at the intersection of two masking instructions). </p><br><p>  The gluing instruction is executed in a hidden chain of commands, and therefore must be chosen in such a way as to impose as few restrictions on the hidden code.  Suppose if, when it is executed, the general-purpose registers and the EFLAGS register change, then the hidden code will not be able to effectively use the corresponding registers and conditional commands (for example, if there is a comparison operator before the gluing instruction, and the gluing instruction itself changes the value of the EFLAGS register, which is after the gluing instructions - it will work incorrectly). </p><br><p>  The above description of the overlapping technique is illustrated in the following figure.  If execution begins with the initial bytes (XX), then the masking chain of instructions is activated.  And if from YY bytes, the hidden chain of instructions is activated. </p><br><p><img src="https://habrastorage.org/webt/a8/yq/f-/a8yqf-uukfw3fgzvlkqmmjjxiao.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-maskiruyuschih-instrukciy">  Assembly instructions suitable for the role of "masking instructions" </h2><br><p>  The longest of the instructions, which at first glance suits us best, is the 10-byte version of MOV, where the first operand is the offset specified by the register and the 32-bit address, and the second operand is the 32-bit number.  In this manual, the most bytes that can be changed arbitrarily (as many as 8 pieces). </p><br><p><img src="https://habrastorage.org/webt/0k/8b/ph/0k8bphb01jec2f1t7dy1bupi_c0.png"></p><br><p>  However, although this instruction looks plausible (theoretically, it can be executed correctly), it still does not suit us, because its first operand will usually indicate an unavailable address, and therefore when trying to perform such a MOV, the program will collapse.  So  This 10-byte MOV does not satisfy the third necessary condition: all instructions of both chains must be correctly executed. </p><br><p>  Therefore, we will choose only those applicants for the role of masking instructions that do not create the risk of a program crash.  This condition significantly narrows the range of instructions suitable for creating an overlapping code, but there are still suitable ones.  Below are four of them.  Each of these four instructions has five bytes, which can be changed arbitrarily, without the risk of a program crash. </p><br><ul><li>  <strong>LEA.</strong>  This instruction calculates the memory address specified by the expression in the second operand, and stores the result in the first operand.  Since we can refer to memory without actually accessing it (and, accordingly, without the risk of a program crashing), the last five bytes of this instruction can take arbitrary values. </li></ul><br><p><img src="https://habrastorage.org/webt/nt/j4/qt/ntj4qtax25h_ztuizjq-aokjpbu.png"></p><br><ul><li>  <strong>CMOVcc.</strong>  This instruction performs the MOV operation if the condition "ss" is fulfilled.  In order for this instruction to satisfy the third requirement, the condition must be chosen in such a way that under any circumstances it will be FALSE.  Otherwise, this instruction may attempt to access an unavailable memory address, and so on.  bring down the program. </li></ul><br><p><img src="https://habrastorage.org/webt/np/me/fn/npmefnc43igcj9aqvw9omgyofae.png"></p><br><ul><li>  <strong>SETcc.</strong>  Acts on the same principle as CMOVcc: sets a byte to one if the "cc" condition is met.  This instruction has the same problem as CMOVcc: accessing an invalid address will result in a program crash.  Therefore, the choice of the condition "cc" must be approached very carefully. </li></ul><br><p><img src="https://habrastorage.org/webt/sn/yc/xt/snycxte6lqjzorjwdqcvsppfdri.png"></p><br><ul><li>  <strong>Nop.</strong>  NOPs can be of different lengths (from 2 to 15 bytes), depending on which operands are indicated in them.  In this case, there will be no risk of collapsing the program (due to accessing an invalid memory address).  Because the only thing that NOPs do is increase the instruction counter, (they do not perform any operations on the operands).  Therefore, the NOP bytes, in which the operands are specified, can take an arbitrary value.  A 9-byte NOP is best for our purposes. </li></ul><br><p><img src="https://habrastorage.org/webt/_i/sh/8k/_ish8ks2qosezlkfzpgzx43jk2k.png"></p><br><p>  For reference, here are a few other options for NOP. </p><br><p><img src="https://habrastorage.org/webt/0k/iq/n7/0kiqn7dtu1yzrrmawbtw8yfwep0.png"></p><br><h2 id="assemblernye-instrukcii-podhodyaschie-na-rol-skleivayuschih-instrukciy">  Assembly instructions suitable for the role of "gluing instructions" </h2><br><p>  The list of instructions suitable for the role of the gluing instruction is unique for each specific masking instruction.  Below is a list (generated by the algorithm shown in the following figure) using the example of a 9-byte NOP. </p><br><p><img src="https://habrastorage.org/webt/zh/9o/ja/zh9ojaw9sezcyr9milmugd3pihm.png"></p><br><p>  In forming this list, we took into account only those variants in which ZZ takes 1 byte (otherwise there will be little space left for the hidden code).  Here is a list of suitable gluing instructions for a 9-byte NOP. </p><br><p><img src="https://habrastorage.org/webt/wm/kv/uj/wmkvujcabiyqgy-ysdg1750mp7k.png"></p><br><p>  Among this list of instructions there is no one that would be free from side effects.  Each of them changes either EFLAGS or general registers, or both.  This list is divided into 4 categories, - according to the side effect the instruction has. </p><br><p> <strong>The first category</strong> includes instructions that change the EFLAGS register, but do not change the general purpose registers.  Instructions from this category can be used when there are no conditional jumps in the chain of hidden instructions and any instructions that are based on the evaluation of information from the EFLAGS register.  This category in this case (for 9-byte NOP'a) includes only two instructions: TEST and CMP. </p><br><p><img src="https://habrastorage.org/webt/vx/6k/nz/vx6knzdkeafykou6rrga4kjtjrc.png"></p><br><p>  Below is a simple example of hidden code that uses TEST as the gluing instruction.  This example makes the exit system call, which for any Linux OS version returns 1. To correctly form the TEST instruction for our needs, we will have to set the last byte of the first NOP, the value 0xA9.  This byte, when concatenated with the first four bytes of the next NOP (66 0F 1F 84), turns into a TEST EAX instruction, 0x841F0F66.  The following two figures show the corresponding assembler code (for a masking chain and a hidden chain).  The hidden chain is activated when control is transferred to the 4th byte of the first NOP. </p><br><p><img src="https://habrastorage.org/webt/sv/ok/v9/svokv9pvujkp3sz1mzgcpfumlx4.png"></p><br><p><img src="https://habrastorage.org/webt/ky/bd/-b/kybd-bm02hdj6lka_rnkemfrnj8.png"></p><br><p>  <strong>The second category</strong> includes instructions that change the values ‚Äã‚Äãof general-purpose registers or available memory (stack, for example), but do not change the EFLAGS register.  When executing the PUSH instruction or any variant of MOV, where the immediate operand is specified as the second operand, the EFLAGS register remains unchanged.  So  The gluing instructions of the second category can be placed even between the comparison instruction (TEST, for example) and the instruction evaluating the EFLAGS register.  However, instructions in this category limit the use of the register, which appears in the corresponding gluing instructions.  For example, if MOV EBP, 0x841F0F66 is used as a gluing instruction, then the possibilities of using the EBP register (from the rest of the hidden code) are significantly limited. </p><br><p>  <strong>The third category</strong> includes instructions that change the EFLAGS register and change the general purpose registers (or memory).  These instructions have no clear advantages compared with the instructions from the first two categories.  However, they can also be used, because they do not conflict with the three conditions formulated at the beginning of the article.  The fourth category includes instructions, under which there is no guarantee that the program will not collapse - there is a risk of improper access to memory.  They are extremely undesirable.  they do not satisfy the third condition. </p><br><h2 id="assemblernye-instrukcii-kotorye-mozhno-ispolzovat-v-skrytoy-cepochke">  Assembly instructions that can be used in a hidden chain </h2><br><p>  In our case (when 9-byte NOPs are used as masking instructions), the length of each instruction from the hidden chain does not exceed four bytes (this restriction does not apply to gluing instructions that take 5 bytes).  However, this is not a very critical limitation, because most instructions that have more than four bytes in length can be decomposed into somewhat shorter instructions.  Below is an example of a 5-byte MOV'a, which is too large to be placed in a hidden chain. </p><br><p><img src="https://habrastorage.org/webt/oo/97/yx/oo97yx0fsovio-agsdn-spiejre.png"></p><br><p>  However, this five-byte MOV can be decomposed into three instructions, the length of which does not exceed four bytes. </p><br><p><img src="https://habrastorage.org/webt/yx/zd/oc/yxzdocctpxhzvy13td7fpkqnwi0.png"></p><br><h2 id="usilenie-maskirovki-putyom-rasseivaniya-maskiruyuschih-nopov-po-vsey-programme">  Masking enhancement by scattering masking NOPs throughout the program </h2><br><p>  A large number of consecutive NOP'ov looks, from the point of view of the reverse, very suspicious.  Sharpening his interest in these suspicious NOPs, an experienced reverser can get to the code hidden in them.  To avoid such exposure, you can disperse masking NOPs - throughout the program. </p><br><p>  The correct chain of execution of the hidden code in this case can be supported by two-byte unconditional branch instructions.  In this case, the last two bytes of each NOP will occupy a 2-byte JMP. </p><br><p>  This trick allows you to break one long sequence of NOPs into several short ones (or even use one NOP at all).  In the last NOP of such a short sequence, only 3 bytes of the payload can be placed (the 4th byte will be taken by the unconditional branch instruction).  So  here there is an additional limit on the size of valid instructions.  However, as mentioned above, long instructions can be laid out on a chain of shorter instructions.  Below is an example of the same 5-byte MOV, which we have already laid out in order to meet the limit of 4 bytes.  However, now we will decompose this MOV so that it is within the limit of 3 bytes. </p><br><p><img src="https://habrastorage.org/webt/lr/6g/bz/lr6gbzoo5qnjgocu3zzkoblxqsc.png"></p><br><p>  Having put all the long instructions into shorter ones on the same principle, we can, for the purpose of greater masking, - in general only single NOPs, scattered throughout the program, to use.  Double-byte JMP instructions can jump forward and back 127 bytes, which means that two consecutive NOPs (consecutive, in terms of a chain of hidden instructions) must be within 127 bytes. </p><br><p>  Such a trick has another significant advantage (besides enhanced masking): it can be used to place hidden code in already existing NOP'ah compiled binary file (i.e. insert the payload into the binary after compiling it).  At the same time, it is not necessary that these abandoned NOPs be 9-byte.  For example, if there are several single-byte NOPs in a row in a binary, they can be converted to multibyte NOPs without disrupting the functionality of the program.  Below is an example of the NOP'ov technique of dispersion (this code is functionally equivalent to the example discussed just above). </p><br><p><img src="https://habrastorage.org/webt/t6/cj/fn/t6cjfn6ctjsqubp6setuf324nui.png"></p><br><p>  Such hidden code hidden in the NOPs scattered throughout the program is much harder to detect. </p><br><p>  The attentive reader probably noticed that the first byte of the first NOP is not claimed.  However, there is nothing wrong with that.  Because this unclaimed byte is preceded by an unconditional jump.  So  control will never be transferred to it.  So everything is fine. </p><br><p>  This is the technique for creating overlapping code.  Use on health.  Hide your precious code from prying eyes.  But only adopt some other instruction, and not a 9-byte NOP.  Because reversers will probably also read this article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425905/">https://habr.com/ru/post/425905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425893/index.html">‚ÄúFlutter starts to like the community, but so far not customers‚Äù: interview with Paulina Szklarska</a></li>
<li><a href="../425897/index.html">Features of using the RxJs library in the online banking system</a></li>
<li><a href="../425899/index.html">An anthill or a fortress? Building a house for the price of an apartment. 1 part</a></li>
<li><a href="../425901/index.html">Weather Station on Arduino from A to Z. Part 1</a></li>
<li><a href="../425903/index.html">Holiday comes to us: SCR has expanded the ISM-range of 868 MHz twice</a></li>
<li><a href="../425907/index.html">Making a machine learning project in Python. Part 2</a></li>
<li><a href="../425911/index.html">Moving cloud CRM to boxed version</a></li>
<li><a href="../425915/index.html">How inter-transport communication can replace traffic lights and shorten the way to work</a></li>
<li><a href="../425917/index.html">The fighter for justice did not give Waymo to patent the key technology of lidar</a></li>
<li><a href="../425919/index.html">Hexagon maps in Unity: save and load, textures, distances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>