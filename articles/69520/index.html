<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Call price</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is believed that the overhead of calling methods and organizing the execution process should not exceed 15% of the execution time of an application...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Call price</h1><div class="post__text post__text-html js-mediator-article"> It is believed that the overhead of calling methods and organizing the execution process should not exceed 15% of the execution time of an application, otherwise you should seriously think about the question of refactoring an application and optimizing its logic.  Armed with such thoughts, I came across the <code>QuickSort</code> method from the standard <code>ArraySortHelper&lt;T&gt;</code> class used to sort arrays in .Net. <br><br>  An interesting point here is the comparison of elements - in order to provide flexibility, it was carried out in a separate class that implements the <code>IComparer&lt;T&gt;</code> interface.  Armed with a variety of thoughts and the studio, it was decided to estimate how much such flexibility is and what could be done with it - under the cut, an analysis of the costs of comparing elements during QuickSort work. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, we have a standard implementation of Hoare's quick sort, which uses the <code>Compare(T x, T y)</code> method from an object that implements the <code>IComparer&lt;T&gt;</code> interface to compare array elements.  For our experiments, using a reflector, we get the code of the sorting method in the following form: <br><br><blockquote> <code><a href="http://s-c.me/2979/s"></a> <a href="http://s-c.me/2979/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static public void</font> Sort &lt;T, TValue&gt; (T [] keys, TValue [] values, <font color="#0000ff">int</font> left, <font color="#0000ff">int</font> right, IComparer &lt;T&gt; comparer) </li><li>  { </li><li>  <font color="#0000ff">do</font> </li><li>  { </li><li>  <font color="#0000ff">int</font> index = left; </li><li>  <font color="#0000ff">int</font> num2 = right; </li><li>  T y = keys [index + ((num2 - index) &gt;&gt; <font color="#A31515">1</font> )]; </li><li>  <font color="#0000ff">do</font> </li><li>  { </li><li>  <font color="#0000ff">try</font> </li><li>  { </li><li>  <font color="#008000">/ * Cmp 1 * /</font> <font color="#0000ff">while</font> (comparer.Compare (keys [index], y) &lt; <font color="#A31515">0</font> ) </li><li>  { </li><li>  index ++; </li><li>  } </li><li>  <font color="#008000">/ * Cmp 2 * /</font> <font color="#0000ff">while</font> (comparer.Compare (y, keys [num2]) &lt; <font color="#A31515">0</font> ) </li><li>  { </li><li>  num2--; </li><li>  } </li><li>  } </li><li>  <font color="#0000ff">catch</font> ( <font color="#2b91af">IndexOutOfRangeException</font> ) </li><li>  { </li><li>  <font color="#0000ff">throw new</font> <font color="#2b91af">ArgumentException</font> ( <font color="#0000ff">null</font> , <font color="#A31515">"keys"</font> ); </li><li>  } </li><li>  <font color="#0000ff">catch</font> ( <font color="#2b91af">Exception</font> ) </li><li>  { </li><li>  <font color="#0000ff">throw new</font> <font color="#2b91af">InvalidOperationException</font> (); </li><li>  } </li><li>  <font color="#0000ff">if</font> (index&gt; num2) </li><li>  { </li><li>  <font color="#0000ff">break</font> ; </li><li>  } </li><li>  <font color="#0000ff">if</font> (index &lt;num2) </li><li>  { </li><li>  T local2 = keys [index]; </li><li>  keys [index] = keys [num2]; </li><li>  keys [num2] = local2; </li><li>  <font color="#0000ff">if</font> (values! = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  TValue local3 = values ‚Äã‚Äã[index]; </li><li>  values ‚Äã‚Äã[index] = values ‚Äã‚Äã[num2]; </li><li>  values ‚Äã‚Äã[num2] = local3; </li><li>  } </li><li>  } </li><li>  index ++; </li><li>  num2--; </li><li>  } </li><li>  <font color="#0000ff">while</font> (index &lt;= num2); </li><li>  <font color="#0000ff">if</font> ((num2 - left) &lt;= (right - index)) </li><li>  { </li><li>  <font color="#0000ff">if</font> (left &lt;num2) </li><li>  { </li><li>  <font color="#008000">/ * Call 1 * /</font> Sort &lt;T, TValue&gt; (keys, values, left, num2, comparer); </li><li>  } </li><li>  left = index; </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  <font color="#0000ff">if</font> (index &lt;right) </li><li>  { </li><li>  <font color="#008000">/ * Call 2 * /</font> Sort &lt;T, TValue&gt; (keys, values, index, right, comparer); </li><li>  } </li><li>  right = num2; </li><li>  } </li><li>  } </li><li>  <font color="#0000ff">while</font> (left &lt;right); </li><li>  } </li></ol></blockquote><br>  Since we will investigate exclusively the call to the operation of comparison, all changes to this function will be made only in lines 1, 12, 16, 53 and 61, which are marked in the listing with authentication comments. <br><br><h3>  Part one.  Experiments with arrays of numbers (int) </h3><br>  To begin, let us estimate the contribution of the overhead of a call to the operation of comparing two numbers in the duration of the sorting process.  To do this, in the above function, we change the ‚Äú <code>comparer.Compare(a, b)</code> ‚Äù calls to an expression of the form ‚Äú <code>a - b</code> ‚Äù.  We measure the operating time of both versions and see ... We see a terrible picture - almost two thirds of the time is spent on organizing a call to the comparison number predicate: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e42/983/553/e4298355389fcb786e8809af6a71aec7.png"><br><br>  What could so slow down the work?  Obviously, the point is the excessive complexity of the comparison process (and this despite the fact that the operation itself boils down to subtracting two numbers!): <br><br><ol><li>  Checking the <code>comparer</code> object for <code>null</code> </li><li>  Finding the <code>Compare</code> method in the object's virtual table </li><li>  Calling the <code>Compare</code> method on the <code>comparer</code> object </li><li>  Calling the <code>CompareTo</code> Method </li><li>  Actually a comparison of numbers </li></ol><br>  In this case, the first two points are the difference CIL-instruction <code>callvirt</code> from <code>call</code> .  I recall that <code>callvirt</code> , due to the presence of a check for <code>null</code> , is generated to call <i>all</i> non-static class methods, regardless of their virtuality. <br><br>  Well, the fourth item is caused by the standard implementation of comparer (all checks for <code>null</code> naturally cleaned by the JIT compiler when substituting <code>int</code> instead of <code>T</code> ): <br><br><blockquote> <code><a href="http://s-c.me/3068/s"></a> <a href="http://s-c.me/3068/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">class</font> <font color="#2b91af">GenericComparer</font> &lt; <font color="#2b91af">T</font> &gt;: IComparer &lt; <font color="#2b91af">T</font> &gt; <font color="#0000ff">where</font> <font color="#2b91af">T</font> : <font color="#2b91af">IComparable</font> &lt; <font color="#2b91af">T</font> &gt; </li><li>  { </li><li>  <font color="#0000ff">public int</font> Compare ( <font color="#2b91af">T</font> x, <font color="#2b91af">T</font> y) </li><li>  { </li><li>  <font color="#0000ff">if</font> (x! = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">if</font> (y! = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">return</font> x.CompareTo (y); </li><li>  } </li><li>  <font color="#0000ff">return</font> <font color="#A31515">1</font> ; </li><li>  } </li><li>  <font color="#0000ff">if</font> (y! = <font color="#0000ff">null</font> ) </li><li>  { </li><li>  <font color="#0000ff">return</font> - <font color="#A31515">1</font> ; </li><li>  } </li><li>  <font color="#0000ff">return</font> <font color="#A31515">0</font> ; </li><li>  } </li><li>  } </li></ol></blockquote><br>  We will remove the layers one by one, let's start with a call to <code>CompareTo</code> , since this is done simply by writing our own comparer of the following form: <br><br><blockquote> <code><a href="http://s-c.me/2980/s"></a> <a href="http://s-c.me/2980/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">class</font> <font color="#2b91af">IntComparer</font> : <font color="#2b91af">IComparer</font> &lt; <font color="#0000ff">int</font> &gt; </li><li>  { </li><li>  <font color="#0000ff">public int</font> Compare ( <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y) </li><li>  { </li><li>  <font color="#0000ff">return</font> x - y; </li><li>  } </li><li>  } </li></ol></blockquote><br>  Measurements show winning 15% of the time.  And this is despite the fact that we consider an array of integers and calling <code>CompareTo</code> for them, as for all methods for all structures, is non-virtual.  The next layer, the difference between <code>callvirt</code> and <code>call</code> when calling, is harder to check, especially with the same flexibility requirements for the sorting function.  But nothing is impossible - when working through an instance of a structure, all methods of all structures are invoked using the <code>call</code> operation, including the implementation of the methods inherited from interfaces.  Due to this we can do the following optimization: <br><br><blockquote> <code><a href="http://s-c.me/2982/s"></a> <a href="http://s-c.me/2982/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">static public void</font> SortNoVirt &lt;T, TValue, TCmp&gt; (T [] keys, TValue [] values, <font color="#0000ff">int</font> left, <font color="#0000ff">int</font> right, TCmp comparer) <font color="#0000ff">where</font> TCmp: <font color="#2b91af">IComparer</font> &lt;T&gt; </li><li>  { </li><li>  <font color="#008000">// ...</font> </li><li>  } </li><li></li><li>  <font color="#0000ff">struct</font> <font color="#2b91af">IntComparerNoVirt</font> : <font color="#2b91af">IComparer</font> &lt; <font color="#0000ff">int</font> &gt; </li><li>  { </li><li>  <font color="#0000ff">public int</font> Compare ( <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y) </li><li>  { </li><li>  <font color="#0000ff">return</font> x - y; </li><li>  } </li><li>  } </li></ol></blockquote><br>  Due to the transfer of the actual type to the sort function, when expanding the generic parameters, the actual type of comparer will be taken into account and a more efficient <code>call</code> instruction will be used to invoke the compare operation.  Measurements of time show an increase in productivity of about 35% of the execution time of the ‚Äústandard‚Äù call, while the increase from the subsequent replacement of the call <code>Compare</code> to subtract is 18%. <br><br>  <i>To the note:</i> In the STL library from C ++ all predicates are transmitted in this way - the type goes through the template parameter.  Additionally, thanks to this trick, the C ++ compiler obtains complete information about types and, as a rule, performs inlining of the predicate code, thereby completely eliminating the costs of a method call.  My experiments with disassembling the results of .Net JIT showed that, contrary to all tricks, there is no unfolding here.  Apparently this is either associated with generics, or it works exclusively for static methods. <br><br>  <i>Note # 2: It was</i> not possible to save on the transfer of comparer with the help of an empty structure - the size ( <code>sizeof</code> ) of the borderless structure in C # turned out to be one (and not zero, as desired).  In VC ++, the size of the empty structure is also equal to one, while the standard states that the size of the empty class (structure) must be greater than zero.  This is done because of the popular construction for calculating the length of the array " <code>sizeof(array) / sizeof(array[0])</code> ".  In C # /. Net, this is apparently done for binary compatibility when interacting with code written in C ++. <br><br>  If we consolidate the data into a single diagram, we obtain the following distribution of the sorting runtime by the standard method: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84f/8fa/122/84f8fa122625d13197645f59f5d8fc76.png"><br><br>  The obvious conclusion that is clear is that when developing computationally heavy biblicals, it makes sense to partly invoke predicates by passing structures and their type through generic parameters. <br><br><h3>  Part two.  And what about objects? </h3><br>  But our applications do not live together in numbers :) There was a question of influence in the context of working with arrays of objects, will we check?  Easy!  As a prototype take here such a simple class: <br><br><blockquote> <code><a href="http://s-c.me/3069/s"></a> <a href="http://s-c.me/3069/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#0000ff">class</font> <font color="#2b91af">IntObj</font> : <font color="#2b91af">IComparable</font> &lt; <font color="#2b91af">IntObj</font> &gt; </li><li>  { </li><li>  <font color="#0000ff">public int value</font> ; </li><li></li><li>  <font color="#0000ff">public int</font> CompareTo ( <font color="#2b91af">IntObj</font> other) </li><li>  { </li><li>  <font color="#0000ff">return value</font> - other.  <font color="#0000ff">value</font> ; </li><li>  } </li><li>  } </li></ol></blockquote><br>  And we carry out similar simple experiments, but already with an array of objects, as a result we get a slightly different situation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/def/47b/ceadef47bad5a5fe1db71865df7e9599.png"><br><br>  And if the ratio between the parts of the comparison process remained unchanged, then their contribution to the total time has noticeably decreased.  It is quite a questioning question: what's the matter, what is slowing down?  A quick glance at the code of the sort function is enough to understand: the work of the only different piece of code, the exchange of values ‚Äã‚Äãbetween array elements, has slowed down.  But we are working with the reference type, only the pointers are swapped, and they are ‚Äúin the soul‚Äù of the number!  If it‚Äôs interesting, then we‚Äôll see that it slows down so much, reading CIL doesn‚Äôt give much benefit - the exchange code is asbestomatically identical except for using the <code>*.i4</code> instructions for numbers and <code>*.ref</code> for objects. <br><br>  If CIL did not help, then it‚Äôs a matter of quitting the JIT, then we‚Äôll watch the assembler :) Here we have a weekly nuisance - regardless of configuration (Debug / Release), the JIT compiler looks at its environment and, depending on the presence of a debugger attached to the process generates different code.  Therefore, to access the real code through the Disassembly window, we will start the application without debugging and set breakpoints in the form of calls to <code>Debugger.Break();</code>  .  The following are listings with the code that is generated to exchange places in two cells of the array: <br><br><table><tbody><tr><td> <code><a href="http://s-c.me/3070/s"></a> <a href="http://s-c.me/3070/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#008000">;</font>  <font color="#008000">==============================================</font> </li><li>  <font color="#008000">;</font>  <font color="#008000">swap in int array</font> </li><li>  <font color="#008000">;</font>  <font color="#008000">124: T local2 = keys [index];</font> </li></ol><br></td><td> <code><a href="http://s-c.me/3070/s"></a> <a href="http://s-c.me/3070/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#008000">;</font>  <font color="#008000">==============================================</font> </li><li>  <font color="#008000">;</font>  <font color="#008000">swap in IntObj array</font> </li><li>  <font color="#008000">;</font>  <font color="#008000">124: T local2 = keys [index];</font> </li></ol><br></td></tr><tr><td><ol><li>  00000142 movsxd rcx, ebx </li><li>  00000145 mov rsi, qword ptr [rbp + 68h] </li><li>  00000149 mov rax, qword ptr [rsi + 8] </li><li>  0000014d cmp rcx, rax </li><li>  00000150 jae 0000000000000275 </li><li>  00000156 mov edx, dword ptr [rsi + rcx * 4 + 10h] </li><li>  <font color="#008000">;</font>  <font color="#008000">125: keys [index] = keys [num2];</font> </li><li>  0000015a movsxd r8, edi </li><li>  0000015d cmp r8, rax </li><li>  00000160 jae 0000000000000275 </li><li>  00000166 mov eax, dword ptr [rsi + r8 * 4 + 10h] </li><li>  <font color="#ff0000"><b>0000016b mov dword ptr [rsi + rcx * 4 + 10h], eax</b></font> </li><li>  <font color="#008000">;</font>  <font color="#008000">126: keys [num2] = local2;</font> </li><li>  <font color="#ff0000"><b>0000016f mov dword ptr [rsi + r8 * 4 + 10h], edx</b></font> </li></ol><br></td><td><ol><li>  00000146 movsxd r12, ebx </li><li>  00000149 mov rsi, qword ptr [rbp + 68h] </li><li>  0000014d mov rax, qword ptr [rsi + 8] </li><li>  00000151 cmp r12, rax </li><li>  00000154 jae 0000000000000285 </li><li>  0000015a mov r14, qword ptr [rsi + r12 * 8 + 18h] </li><li>  <font color="#008000">;</font>  <font color="#008000">125: keys [index] = keys [num2];</font> </li><li>  0000015f movsxd r13, edi </li><li>  00000162 cmp r13, rax </li><li>  00000165 jae 0000000000000285 </li><li>  0000016b mov r8, qword ptr [rsi + r13 * 8 + 18h] </li><li>  00000170 mov edx, ebx </li><li>  00000172 mov rcx, rsi </li><li>  <font color="#ff0000"><b>00000175 call FFFFFFFFEF5F7CB0</b></font> </li><li>  <font color="#008000">;</font>  <font color="#008000">126: keys [num2] = local2;</font> </li><li>  0000017a mov r8, r14 </li><li>  0000017d mov edx, edi </li><li>  0000017f mov rcx, rsi </li><li>  <font color="#ff0000"><b>00000182 call FFFFFFFFEF5F7CB0</b></font> </li></ol><br></td></tr></tbody></table><br><br>  In the listings, one immediately catches the call of a certain function for writing to an array of objects, and this call was absent while we were watching CIL.  Obviously, this function does something more than just copying the address, and in addition to the costs of organizing this call, we get something else, which means the details lie in the implementation of the CLR.  Indeed, after reading the source code of the public version of CLR 2.0 (SSCLI 2.0 package), we find the following code: <br><br><blockquote> <code><a href="http://s-c.me/3073/s"></a> <a href="http://s-c.me/3073/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#008000">/ ************************************************* **************************** /</font> </li><li>  <font color="#008000">/ * assigns 'val to' array [idx], after doing all the proper checks * /</font> </li><li></li><li>  HCIMPL3 ( <font color="#0000ff">void</font> , JIT_Stelem_Ref_Portable, PtrArray * array, unsigned idx, <font color="#2b91af">Object</font> * val) </li><li>  { </li><li>  <font color="#0000ff">if</font> (! array) </li><li>  { </li><li>  FCThrowVoid (kNullReferenceException); </li><li>  } </li><li>  <font color="#0000ff">if</font> (idx&gt; = array-&gt; GetNumComponents ()) </li><li>  { </li><li>  FCThrowVoid (kIndexOutOfRangeException); </li><li>  } </li><li></li><li>  <font color="#0000ff">if</font> (val) </li><li>  { </li><li>  MethodTable * valMT = val-&gt; GetMethodTable (); </li><li>  TypeHandle arrayElemTH = array-&gt; GetArrayElementTypeHandle (); </li><li></li><li>  <font color="#0000ff">if</font> (arrayElemTH! = TypeHandle (valMT) &amp;&amp; arrayElemTH! = TypeHandle (g_pObjectClass)) </li><li>  { </li><li>  TypeHandle :: CastResult result = ObjIsInstanceOfNoGC (val, arrayElemTH); </li><li>  <font color="#0000ff">if</font> (result! = TypeHandle :: CanCast) </li><li>  { </li><li>  HELPER_METHOD_FRAME_BEGIN_2 (val, array); </li><li></li><li>  <font color="#008000">// This is equivalent to ArrayStoreCheck (&amp; ‚Äã‚Äãval, &amp; array);</font> </li><li>  <font color="#cc6633">#ifdef</font> STRESS_HEAP </li><li>  <font color="#008000">// Force a GC on every jit if the stress level is high enough</font> </li><li>  <font color="#0000ff">if</font> (g_pConfig-&gt; GetGCStressLevel ()! = <font color="#A31515">0</font> </li><li>  <font color="#cc6633">#ifdef</font> _DEBUG </li><li>  &amp;&amp;! g_pConfig-&gt; FastGCStressLevel () </li><li>  <font color="#cc6633">#endif</font> </li><li>  ) </li><li>  GCHeap :: GetGCHeap () -&gt; StressHeap (); </li><li>  <font color="#cc6633">#endif</font> </li><li></li><li>  <font color="#cc6633">#if</font> CHECK_APP_DOMAIN_LEAKS </li><li>  <font color="#008000">// If the instance is agile or check agile</font> </li><li>  <font color="#0000ff">if</font> (! arrayElemTH.IsAppDomainAgile () &amp;&amp;! arrayElemTH.IsCheckAppDomainAgile () &amp;&amp; g_pConfig-&gt; AppDomainLeaks ()) </li><li>  { </li><li>  val-&gt; AssignAppDomain (array-&gt; GetAppDomain ()); </li><li>  } </li><li>  <font color="#cc6633">#endif</font> </li><li>  <font color="#0000ff">if</font> (! ObjIsInstanceOf (val, arrayElemTH)) </li><li>  { </li><li>  COMPlusThrow (kArrayTypeMismatchException); </li><li>  } </li><li></li><li>  HELPER_METHOD_FRAME_END (); </li><li>  } </li><li>  } </li><li></li><li>  <font color="#008000">// The performance gain of the optimized JIT_Stelem_Ref in</font> </li><li>  <font color="#008000">// jitinterfacex86.cpp is mainly due to calling JIT_WriteBarrierReg_Buf.</font> </li><li>  <font color="#008000">// By calling write barrier directly here,</font> </li><li>  <font color="#008000">// we can avoid translating in-line assembly from MSVC to gcc</font> </li><li>  <font color="#008000">// while keeping most of the performance gain.</font> </li><li>  HCCALL2 (JIT_WriteBarrier, ( <font color="#2b91af">Object</font> **) &amp; array-&gt; m_Array [idx], val); </li><li></li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  <font color="#008000">// no need to go through write-barrier for NULL</font> </li><li>  ClearObjectReference (&amp; array-&gt; m_Array [idx]); </li><li>  } </li><li>  } </li><li>  HCIMPLEND </li></ol></blockquote><br>  As can be seen from here, when writing an element to an array of objects, in addition to the standard checking of array boundaries, type compatibility is also checked and, if necessary, the appropriate conversions are performed.  It is worth noting that, being string-typed, C # itself also contains type control, but since the CIL instruction information already comes in the form <code>System.Object</code> , the CLR checks for reliability once again. <br><br><h3>  Part Three  Similarity of conclusions </h3><br>  What conclusions can be drawn from this?  I will not offer hardcore optimizations, but it makes sense to avoid virtual calls inside large cycles, especially in miniature predicate functions.  In practice, for example: <br><br><ul><li>  Realization of predicates in the form of structures, and not classes with the subsequent transfer of type information through generic parameters </li><li>  replacement of small utilitarian class methods with static extension methods, which, due to their static nature, will be called to bypass the virtual table </li></ul><br>  Of course, these are not the only possible conclusions, but you have to leave the reader open space for thoughts :) </div><p>Source: <a href="https://habr.com/ru/post/69520/">https://habr.com/ru/post/69520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../69505/index.html">Reception of citizens: the experience of implementing the "electronic queue" in a state organization</a></li>
<li><a href="../69509/index.html">Nginx: just in time</a></li>
<li><a href="../69515/index.html">Bug Driven Development</a></li>
<li><a href="../69518/index.html">Scope of discussion topics on Habr√©</a></li>
<li><a href="../69519/index.html">How would you recommend saying ‚Äúserver‚Äù if you recorded ‚Äúserver‚Äù and met it in Russian?</a></li>
<li><a href="../69521/index.html">released boost 1.40.0</a></li>
<li><a href="../69522/index.html">Brakes in Snow Leopard</a></li>
<li><a href="../69528/index.html">Data URI [CSS] Sprites 1.5 - a unique automatic CSS sprite generator</a></li>
<li><a href="../69529/index.html">Slightly late congratulations on the day of the programmer from the leader of the Yabloko party</a></li>
<li><a href="../69530/index.html">Javascript: Good code style is usually</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>