<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Framework for event-driven programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some lyrics 

 The longer I program, the more I like loosely coupled systems, which consist of a large number of disparate units (modules) that know n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Framework for event-driven programming</h1><div class="post__text post__text-html js-mediator-article"><h4>  Some lyrics </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/253/f0a/88b/253f0a88b9456c0c5612f66459172058.jpg" alt="image"><br>  The longer I program, the more I like loosely coupled systems, which consist of a large number of disparate units (modules) that know nothing about each other, but assume the existence of others.  Such systems should ideally be assembled like a constructor, without dependencies and without adapting to each other.  Ideally, in the process of operating such a system, all the necessary tasks should be performed without stopping the system, simply introducing a new module into the world (for example, by stuffing a jar'nik in the classpath), and the system will immediately begin to interact with the new module. <br>  In this connection, the paradigm of event-driven (or <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">event-oriented</a> ) programming looks very attractive. <br><a name="habracut"></a><br>  Its indisputable advantage is that you do not need to edit the existing code when adding or removing a module, the system continues to work non-stop, we will simply gain or lose some of the functionality. <br>  It is necessary to make a reservation, the minus is its plus - unpredictable behavior during changes, as well as weakening of control over the system as a whole (who is to blame, why does it work wrong?) - unlike traditional programming, where the system reacts to such anomalies immediately and firmly indication of the reasons (the required module was not found). <br><br><h4>  Why change traditions </h4><br>  To some extent, event-oriented programming manifests itself everywhere - from modern multi-tasking operating systems to all kinds of frameworks.  Instead of each participant (module) listening to all events, he subscribes only to those that he is interested in, thereby consuming less machine resources.  In fact, even a method call on an object can be perceived as a synchronous sending-receiving of messages with a guarantee of delivery and receipt.  So why extra complexity? <br>  The answer is that everything works for any outcome.  We are not interested in who received our message, how many recipients, and whether it will respond at all.  We just gently notify.  No one is interested - and all right.  Interesting - that's fine, work further. <br><br><h4>  Realities </h4><br>  For example, the same event system in Java Swing.  To listen to some events, for each component there are methods addXXXListener, removeXXXListener.  For sending such messages there is a fireXXXEvent method.  Everything is fine.  But, let's say, we are writing our component in the same philosophy.  And we want to send a variety of events or respond to them, with the preservation of encapsulation.  Consequently, it is necessary every time to implement these methods for each XXX event, for each component ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Decision </h4><br>  The code is always similar to disgust, so I would like to replace it with a few lines.  I thought, and as a result, not one day I implemented a helper for such tasks.  This will be a class with static methods that can be called from anywhere in the program.  So what do we need? <br>  First, we want to respond to any events.  Let, for definiteness, our events will implement the standard java.util.EventObject interface, and listeners will implement the java.util.EventListener interface.  So, on the one hand, we are not limited by anything, but on the other, as simple as possible is to link this with the AWT \ Swing event paradigm.  Then, perhaps, the event subscription should look like this: <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;? extends EventObject&gt; event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventListener listener)</span></span></span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">A naive implementation looks like this:</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Events.listeners.containsKey(event)) { Events.listeners.put(event, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;EventListener&gt;()); } <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;EventListener&gt; list = (List&lt;EventListener&gt;) Events.listeners.get(event); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.contains(listener)) { list.add(listener); }</code> </pre><br></div></div><br>  So we expressed our desire to be aware of the events of a subclass of EventObject, promising that we will implement the EventListener interface (it does not define methods, more on this later).  But we will be notified accurately if a specific event occurs. <br><br>  Further, for a clean exit, we need the ability to unsubscribe from the event, suitable <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;? extends EventObject&gt; event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventListener listener)</span></span></span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">And the trivial code:</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;? extends EventObject&gt; event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventListener listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Events.listeners.containsKey(event)) { Events.listeners.get(event).remove(listener); } }</code> </pre><br></div></div><br>  And also for a completely clean exit (although there is a controversial point here): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> &lt;E extends EventObject&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;? extends EventObject&gt; event)</span></span></span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">And the natural code is:</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> &lt;E extends EventObject&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;? extends EventObject&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Events.listeners.containsKey(event)) { Events.listeners.get(event).clear(); Events.listeners.remove(event); } }</code> </pre><br></div></div><br>  Good for quitting.  It seems to be all.  And, no, not everything - still it is necessary to notify one-time in many places about any particular events, it looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventObject event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String method)</span></span></span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">The code is single-threaded:</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventObject event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Class&lt;? extends EventObject&gt; eventClass = event.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Events.listeners.containsKey(eventClass)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> EventListener listener : Events.listeners.get(eventClass)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { listener.getClass().getMethod(method, eventClass).invoke(listener, event); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Throwable e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } } } }</code> </pre><br>  The lack of implementation, of course, is that the processing is performed sequentially, and in the calling thread.  For most applications, this approach should be enough, but, apparently, it is worthwhile to organize processing via AWTsh EventQueue or something similar.  In the next versions I will fix it. <br>  Another disadvantage is that throwing an exception in the handler throws an exception into the method call, and informing the listeners stops (because of one ‚Äúdishonest‚Äù listener, some others may not receive the message).  In the final version, I corrected this behavior for ignoring with standard logging, and optionally subscribing to exception events in handlers. <br></div></div><br>  Now, instead of implementing methods, everything can look like in the demo (for example, I chose java.awt.event.ActionEvent): <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ActionListener listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionPerformed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ActionEvent e)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(e); } }; Events.listen(ActionEvent.class, listener);<span class="hljs-comment"><span class="hljs-comment">//   // final ActionEvent event = new ActionEvent(this, ActionEvent.ACTION_PERFORMED, "command"); Events.fire(event, "actionPerformed");// ActionListener.actionPerformed(ActionEvent) // Events.forget(ActionEvent.class); // </span></span></code> </pre><br>  The only inconvenience is that in the Events.fire method, you must also specify the name of the method in a string, and that it must take one argument - the object of our event.  This happened because different listeners implement different methods of reacting to messages, and even one listener can have several such methods - according to the type of event (Like MouseListener defines several methods, for example, mouseOver and mouseOut, as well as others). <br>  And finally, repentance: all methods are statically synchronized, it is necessary to replace ordinary collections with thread-safe ones.  Reflection also slows down the work (in terms of nanoseconds, compared to a direct call of methods) - which occurs in a cycle when an event is initiated for each listener, but I think this is a necessary evil. <br><br><h4>  Crooked, uncomfortable and unnecessary </h4><br>  I myself liked this approach so much that I decided to share the library with the community ( <a href="">https://github.com/lure0xaos/Events.git</a> ).  If you do not like it, put minuses, but in general I will be glad to constructive criticism in the comments and efficient proposals and discussions. </div><p>Source: <a href="https://habr.com/ru/post/198024/">https://habr.com/ru/post/198024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198014/index.html">How Github and StackOverflow can overthrow LinkedIn and other portals to find IT professionals</a></li>
<li><a href="../198016/index.html">History of Apple operating systems. Part 4. New time</a></li>
<li><a href="../198018/index.html">UA Web Challenge V</a></li>
<li><a href="../198020/index.html">The final release of Ubuntu 13.10 "Saucy Salamander"</a></li>
<li><a href="../198022/index.html">Microsoft launches Remote Desktop app for iOS and Android</a></li>
<li><a href="../198028/index.html">CodeLens in Visual Studio 2013</a></li>
<li><a href="../198030/index.html">Yandex launches PaaS Cocaine</a></li>
<li><a href="../198034/index.html">Is Comet ISON Dangerous?</a></li>
<li><a href="../198036/index.html">Anki DRIVE - back to childhood</a></li>
<li><a href="../198038/index.html">The new Nexus appeared in its own Google Play store for as low as $ 349.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>