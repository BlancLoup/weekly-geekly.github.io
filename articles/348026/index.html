<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Installing Linux without .ISO and virtualization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Installing Linux without .ISO and virtualization 


 Creating a file system, installing and cloning Debian and Ubuntu using radish scripts. 
 1. Purpo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Installing Linux without .ISO and virtualization</h1><div class="post__text post__text-html js-mediator-article"><h1>  Installing Linux without .ISO and virtualization </h1><br><p>  Creating a file system, installing and cloning Debian and Ubuntu using radish scripts. </p><br><h1>  1. Purpose and capabilities of radish scripts </h1><br><p>  Usually, the installation of the Linux system is done by running any installer program supplied by the distribution developers.  This is done either directly on the computer on which the installation is being performed, or in some isolated environment, for example, using virtualization.  The procedures described below follow these principles only in the most minimally necessary form.  When creating a system image, any installers are reduced to the debootstrap minimal system generator and the apt package manager interface (both on top of the dpkg package manager), and chroot is used instead of virtualization. </p><br><p>  The installation of a disk image on a device is performed by a minimal script that does not use the installer or package manager at all, nevertheless creating a configuration completely controlled by the package manager in the disk image - all installed components, including the bootloader and the kernel, can be updated and replaced by the same manager actions packages that would be used on a system installed by the standard installer of the distribution kit. </p><br><p>  The scripts are located on the Github server and are available <a href="https://github.com/abelits/radish">here</a> . </p><a name="habracut"></a><br><h2>  1.1.  Restrictions </h2><br><p>  Scripts have been developed for Debian, Ubuntu, and other distributions based on the Debian package manager.  In principle, there are no fundamental restrictions that would prevent the transfer of the same procedures to distributions based on rpm, the Red Hat package manager, or other less common mechanisms.  However, the author first needed the support of Debian and Ubuntu, and therefore the development was carried out precisely in this direction. </p><br><p>  Another existing limitation relates to the use of the MBR disk loading and partitioning mechanism, and not the more modern GPT.  This limits the size of the boot device to 2 terabytes and requires appropriate BIOS configuration on x86 devices.  There are no fundamental restrictions that prevent the support of GPT / UEFI, but the author set himself the goal of creating a simple configuration that is not tied to anything outside the boot disk.  With all its flaws and limitations, on the x86, MBR architecture has one useful feature - if the BIOS selected the disk with the MBR as a boot device, the entire subsequent boot process is exclusively controlled by the chain of boot loaders on this device and receiving configuration from files on the same device.  Apparently, in the future, it makes sense to add support for GPT and UEFI - good, problems with non-standard behavior of UEFI have decreased a lot on the current generation of hardware. </p><br><h2>  1.2.  The procedure for assembling a disk image, its modification and installation on the boot device </h2><br><p>  The installation procedure consists of two stages - the creation of a disk image and its installation on the device.  In addition, each device on which such a disk image is installed becomes bootable on computers with x86 architecture (32-bit or 64-bit, depending on the original build).  The procedure for installing a file system image involves creating unique identifiers (UUIDs) of file systems, which helps to eliminate confusion during the boot and update system, which can occur if several devices with identical partitions are connected to the same computer at the time of loading. </p><br><p> The root ( <code>/</code> ) and boot ( <code>/boot</code> ) file systems are identified in the GRUB configuration and the <code>/etc/fstab</code> by their UUID to avoid dependence on the presence or identification of other devices (drives and partitions).  GRUB always reads its own configuration (BIOS always installs a boot disk containing the first GRUB stage in the MBR, the ‚Äúfirst hard disk‚Äù when accessed through its functions), the GRUB configuration contains the UUID of the root file system sent to the kernel via the command line.  The boot process uses this identifier to determine the device being mounted as <code>/</code> , and then the file <code>/etc/fstab</code> is read from the same device, from which, also by UUID, the file system is defined, which is mounted as / boot if required (for example, when updating the kernel or bootloader).  Also, the root filesystem UUID in <code>/etc/fstab</code> is guaranteed to match the UUID of the file system mounted as <code>/</code> (and containing this file itself).  If several connected devices contained the same file system UUIDs, it would be quite possible that after booting from one of the devices, the file systems were mounted from other devices with the same UUID.  If the UUIDs are unique, and each physical device in the GRUB configuration and <code>/etc/fstab</code> contains references to the UUIDs of its own partitions, this situation is impossible. </p><br><p>  In general, disk images and devices themselves with radish file systems installed on them are designed for maximum compatibility with hardware and maintaining performance in a wide range of possible configurations, provided that the hardware configuration and BIOS does not prevent traditional (via MBR) booting from these devices. </p><br><p>  If desired, the user can unpack the disk image, add files and packages, run unpacked disk images under the chroot, and build a new disk image after these changes.  The user can also install a disk image on the device, boot from it, use it in the usual way, and then use a simple procedure to create a disk image that creates copies of the device in the state in which the user left it at the time of cloning.  At the same time, the installation procedure remains unchanged if the user has not changed any fundamental mechanisms (for example, the boot method or hardware architecture). </p><br><h2>  1.3.  Using a disk image to restore from backups and transfer the running configuration to the new hardware </h2><br><p>  The latter solves the problem of restoring bootable devices from backups - it is enough to create a disk image from a copy of the device created in this way and start the procedure for installing an image on the device on the device, which should become bootable.  Both the file set and the download mechanism after this procedure will be functionally a copy of the device from which the backup was made.  Compatibility with various sets of equipment allows you to completely replace equipment when a server fails or when replacing it with new equipment, and to get a workable, bootable system without any manual configuration.  In this case, one requirement must be met: in at least one of the workable configurations, the system must be bootable from one disk, recognized by the saved configuration of the operating system. </p><br><p>  That is, it may turn out that a disk image from a server booted from a RAID array will not be able to boot to a completely different configuration, which requires additional configuration of hardware and software supported arrays, partitions and logical volumes.  To do this, it makes sense to have at least one device with a ‚Äúsimple‚Äù configuration containing MBR, partitions and file systems, and maintain a copy of the boot system on it even if it is not a boot device during normal server operation.  Then, after changing the hardware, you can start the recovered copy of this device first, and only then, manually or automatically, restore the rest of the configuration. </p><br><h2>  1.4.  Creating a disk image for processor architectures that are different from the architecture of the computer on which the assembly is made </h2><br><p>  At the moment, radish cannot completely create a file system for a ‚Äúforeign‚Äù architecture, however, it can be used in parts to build the source directory tree to run on the device with the required architecture, and then complete the build procedure on this device (real or emulated) before receiving fully functional file system. </p><br><p>  Despite the fact that this is the least developed part of radish, it is quite suitable for inclusion in scripts for creating firmware of various devices from scratch - you only need to add the creation of a minimum file system for running radish (for example, compiling a system based on busybox) bootloader configurations, and procedures for copying files created by radish to a device (for example, switching to the boot file system via ssh / scp, etc.). </p><br><h1>  2. The principle of operation </h1><br><p>  radish is implemented as radish-build and radish-install, bash shell scripts that use a small set of utilities that make up the minimal Linux configuration, plus several utilities that are specific to it.  In the radish itself there is a list of these utilities.  To build the file system are used: </p><br> <code>bzip2 <br> cat <br> chroot <br> cut <br> dd <br> echo <br> fgrep <br> grep <br> kill <br> mktemp <br> mount <br> mv <br> pwd <br> readlink <br> rm <br> rmdir <br> sleep <br> umount <br> debootstrap <br> mkfs.ext4 <br> fsck.ext4 <br> resize2fs <br> partclone.ext4 <br></code> <br><p>  radish checks for their presence at startup, and fails if any of them are missing.  This suggests that the utilities themselves should be present even if the shell itself implements them as built-in commands - such an assumption avoids errors when changing versions and implementations of the shell, and corresponds to the typical configuration of modern Linux distributions, even the most minimal ones based on Busybox. </p><br><p>  Five of these files perform functions specific to creating file systems with a Debian distribution: </p><br><ol><li>  <code>debootstrap</code> .  This is the main script that configures access to the repository and installs basic system packages.  It is well maintained and updated with the release of new versions of various systems compatible with Debian.  It is also distributed in the standard repositories of many distributions that are not compatible with Debian, and can be run under them, creating a directory tree containing a workable system compatible with Debian.  The only requirement for its operation is the availability of hardware, the kernel and the minimum configuration of Linux for the respective architecture, and access to the repository. </li><li>  <code>mkfs.ext4</code> and <code>fsck.ext4</code> .  These utilities create and verify the EXT4 file system, typically used for Linux boot / root devices.  radish works completely under Linux, so EXT4, traditionally supported by all Linux distributions and configurations, can be used for all operations without any format translation or copying. </li><li>  <code>resize2fs</code> .  This utility resizes the collected EXT2, EXT3 or EXT4 file system.  During file system assembly, initially the size of the file system image is selected with a margin.  At the end of the build, the file system is compressed to a minimum size, and in this form is transferred to the partclone format.  When installed on a device, this part of the file system is first installed using the minimum size of the file system, and then the file system is expanded to the size of the partition on the device.  This avoids problems when installing on devices of various sizes - the image always corresponds to the minimum supported size determined by the total size of the installed files (plus incomplete blocks, directories and metadata), but after installation the entire device is used. </li><li>  <code>partclone.ext4</code> .  A utility for copying a file system image in a format that allows you to save only blocks occupied by data.  Since copying occurs after the file system is compressed, dd could be used instead of this utility, however, dd cannot determine if the copied disk image is complete, and partclone will give an error if for some reason the file is truncated. </li></ol><br><p>  For installation are used: </p><br> <code>bzip2 <br> clear <br> cut <br> dd <br> echo <br> head <br> id <br> mount <br> sed <br> sleep <br> sort <br> stat <br> sync <br> tail <br> tempfile <br> umount <br> uniq <br> wc <br> xargs <br> blockdev <br> dialog <br> fsck.ext4 <br> partclone.ext2 <br> parted <br> resize2fs <br> tune2fs <br> blkid <br></code> <br><p>  There are some other utilities in this list that are also specific to the operations performed by this script: </p><br><ol><li>  <code>blockdev</code> .  This utility allows you to request kernel operations on a block device, in this case re-reading the partition table. </li><li>  <code>dialog</code> .  A utility that implements a simple user interface on a text screen.  Used to select a device and enter text - the name of the machine, passwords. </li><li>  <code>parted</code> .  A utility that creates and edits a disk partition table.  In this case, it is used only in the mode for the format with MBR, although it also supports GPT. </li><li>  <code>tune2fs</code> .  A utility that edits file system parameters.  Used to create a unique identifier (UUID) for the created file systems.  After cloning, the original identifier is preserved, which must be replaced with a new one, in order to exclude the possibility of coincidence of identifiers of several file systems that are simultaneously available on the same computer. </li><li>  <code>blkid</code>  A utility that determines the list of block devices in the system and finds their identifiers (tags and UUIDs). </li></ol><br><h2>  2.1.  Creating a file system image </h2><br><p>  The basis of the radish operation is the creation of a directory tree and files on the file system located on the system image file, which is mounted on the local directory via the block device to which this file is mapped ( <code>/dev/loop <i>n</i></code> ).  That is, the radish ‚Äë build script creates a file, formats it as a file system, creates a temporary directory, and mounts this file system under it.  In this directory, the minimal system is first installed via debootstrap, and then it is supplemented to the minimum working server or embedded system configuration (the set of packages can be changed by the user, but this requires editing the script).  In such a workable form, the file system is transferred to the partclone format and compressed with bzip2.  After that, the file system is unmounted, the original image file and directory are deleted, and the compressed partclone file remains, ready for installation with the radish-install script. </p><br><p>  In developing radish, the challenge was to ensure that software could be installed from randomly selected Debian packages.  Debian packages are developed for installation on a computer on which a fully functional system is already installed.  The configuration stage, the final stage of the installation of each package, starts after the installation of all the packages that this package depends on, and can rely on their presence.  This condition is always fulfilled when installing on a loaded and working system, however, it is impossible to guarantee this behavior during the operation of radish, because the directory under which the image of the file system is mounted is not the full equivalent of a working Debian system.  Therefore, additional measures were needed to temporarily create an environment that is fairly close to running Debian during the installation of packages, but ‚Äúfit‚Äù to the mounted directory and after installation does not leave running processes due to which this directory cannot be unmounted.  As it turned out, in most cases it is enough to properly install the packages: </p><br><ol><li>  Run all operations on the mounted file system image under chroot. </li><li>  Mount the special file systems <code>/proc</code> and <code>/sys</code> ( <code>/dev</code> operational as it was created when debootstrap was started). </li><li>  Rename <code>/usr/sbin/invoke-rc.d</code> (from SysV init) and <code>/sbin/initctl</code> (from upstart) if these scripts are installed on the system before starting the installation and rename these files back after the installation is completed.  Systems using systemd do not require any changes, because about such installation procedure systemd does not find its own process and its interfaces under chroot - they are started only when the system is ‚Äúreal‚Äù loaded. </li></ol><br><p>  To fully guarantee that after installing the packages, no processes will be running, the script also includes a procedure for searching for processes running under chroot (the <code>termprocesses()</code> function).  Files of the found processes are renamed (to prevent automatic restart), the processes are terminated first with a TERM signal and renamed back.  If they are not completed after 5 seconds (it is assumed that the processes may spend some time to restore the state, delete files, etc.,), the procedure is repeated with the KILL signal, which leads to immediate completion. </p><br><p>  After completing this installation procedure, the file system is unmounted, compressed by the resize2fs utility, and converted to the partclone format compressed with bzip2.  After creating a file in this format, the source file with the image of the file system and the temporary directory are deleted. </p><br><p>  As a command-line argument, radish-build takes the name of the distribution version, for example, ‚Äúartful‚Äù for Ubuntu 17.10 or ‚Äústretch‚Äù for Debian 9. The script creates the root-image.bin file. </p><br><h2>  2.2.  Installing the system from the image on the device </h2><br><p>  The radish-install script installs the system on the device and configures this device for booting.  This script: </p><br><ol><li>  Interactively requests the device from the list of suitable for installation.  A list of devices suitable for installation is created from <code>/sys/class/block/sd*</code> exception of devices containing mounted partitions that are outside the expected size range and also considered as fixed by the operating system.  These criteria (which are in radish ‚Äë install after scanning devices using the above mask), will probably need to be changed in many cases. </li><li>  Creates two partitions: bootloader and root filesystem. </li><li>  Formats the file system loader. </li><li>  Copies the prepared image to the root file system, creates new UUIDs for file systems. </li><li>  Mounts file systems, transfers the / boot directory from the installed root to the loader file system. </li><li>  Creates the configuration files <code>/etc/fstab</code> , <code>/etc/inittab</code> or <code>/etc/init/ttyS0.conf</code> , <code>/etc/default/grub</code> . </li><li>  Installs the GRUB boot loader onto the device using the boot files already installed from under the chroot.  Only at this stage of the installation is the system boot record in the MBR and the space before the beginning of partitions, that is, in those parts of the device that are not covered by file systems.  This also installs the bootloader files on the file system located in the bootloader section.  These procedures are completely equivalent to installing GRUB on subsequent updates, because they are produced by the same programs that come with the GRUB package.  The only difference is that in this case they are started from under the chroot. </li><li>  Unmounts filesystems. </li><li>  Extends the root file system to the size of the device partition and mounts it again. </li><li>  Queries the machine name and passwords for the predefined root and user users, creates the <code>/etc/hostname</code> file, and edits user passwords using the chpasswd utility. </li><li>  Unmounts the resulting root filesystem and writes all buffers to devices. </li></ol><br><p>  After all these actions, the device can be used to boot a working Linux system.  The file system identifiers correspond to the GRUB and <code>/etc/fstab</code> configurations, that is, regardless of the device numbers for Linux or BIOS, the boot procedure correctly recognizes its own file systems.  After booting, the system can be updated without any changes by the Debian package manager and use all utilities that support synchronization and updates from remote repositories. </p><br><p>  If you wish (and if you have enough free space) you can copy the radish itself and a compressed disk image from which the device was installed to any directory on this device.  In this case, you need to additionally install the utilities used by radish scripts.  Thus, the resulting system can then create copies of its original state ‚Äî this can be convenient for distributing a ‚Äúsample‚Äù file system with installed software to users who can then create their own copies. </p><br><h2>  2.3.  Modifying the created file system image </h2><br><p>  After the file system image file has been created using the radish-build script, it may be necessary to manually install and configure software or any data.  The image file itself is not editable, but there are at least two possibilities to create such an edited image: </p><br><h3>  2.3.1.  Installing software on a physical device followed by preparation for cloning </h3><br><p>  The file system image file is used to install the full bootable system on the device, which after this installation is used to boot.  After downloading, the user installs and configures (and, if necessary, tests) the software in the same way as he would install it on a regular computer.  Upgrading packages and even upgrading to new versions of the distribution can be done using the usual package manager mechanisms.  This results in a file system containing the necessary configuration. </p><br><p>  Having achieved the desired configuration, the user reboots the computer and connects the device with the modified file system to the same or another computer.  The device becomes available as what will be referred to as <code>$TDEV</code> .  ,      <code><i>/dev/sdb</i></code> ,     : </p> <code>TDEV= <i>/dev/sdb</i> <br></code> <br><p>       ${TDEV}2  ,   .               boot   : </p><br><pre> <code class="hljs ruby">mount ${TDEV}<span class="hljs-number"><span class="hljs-number">2</span></span> /mnt mount ${TDEV}<span class="hljs-number"><span class="hljs-number">1</span></span> /mnt/tmp cp -a /mnt/tmp/* <span class="hljs-regexp"><span class="hljs-regexp">/mnt/boot</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ umount /mnt</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tmp umount /mnt</span></span></code> </pre><br><p>       : </p><br><pre> <code class="hljs perl">fsck.ext4 -f ${TDEV}<span class="hljs-number"><span class="hljs-number">2</span></span> resize2fs -M ${TDEV}<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><p> (      ‚Äì        ). </p><br><p>       partclone,  bzip2: </p><br><pre> <code class="hljs swift">partclone.ext4 -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> -s ${<span class="hljs-type"><span class="hljs-type">TDEV</span></span>}<span class="hljs-number"><span class="hljs-number">2</span></span> -o - | bzip2 -<span class="hljs-number"><span class="hljs-number">9</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> &gt; root-image.bin</code> </pre><br><p>       : </p><br><pre> <code class="hljs perl">fsck.ext4 -f ${TDEV}<span class="hljs-number"><span class="hljs-number">2</span></span> resize2fs ${TDEV}<span class="hljs-number"><span class="hljs-number">2</span></span> mount ${TDEV}<span class="hljs-number"><span class="hljs-number">2</span></span> /mnt rm -rf /mnt/boot/* umount /mnt</code> </pre><br><p>          ,   root‚Äëimage.bin    ,   . </p><br><h3> 2.3.2.      </h3><br><p>         ,     ,     <code>/dev/loop <i>n</i></code> ,          partclone,  bzip2.     radish-unpack-image  radish-pack-image.          . </p><br><p>          <code>/proc</code> , <code>/sys</code>  <code>/dev</code> .     radish-unpack-image (,  <code>radish‚Äëimage‚Äë <i>bbbbbbbbbb</i></code>   <code>radish‚Äëmount‚Äë <i>aaaaaaaaaa</i></code> ): </p><br><pre> <code class="hljs mel">./radish-unpack-<span class="hljs-keyword"><span class="hljs-keyword">image</span></span> root-<span class="hljs-keyword"><span class="hljs-keyword">image</span></span>.bin</code> </pre><br><p> ( ,       ) </p><br><pre> <code class="hljs perl">mount --<span class="hljs-keyword"><span class="hljs-keyword">bind</span></span> /proc radish-mount-aaaaaaaaaa/proc mount --<span class="hljs-keyword"><span class="hljs-keyword">bind</span></span> /sys radish-mount-aaaaaaaaaa/sys mount --<span class="hljs-keyword"><span class="hljs-keyword">bind</span></span> /dev radish-mount-aaaaaaaaaa/dev mount --<span class="hljs-keyword"><span class="hljs-keyword">bind</span></span> /dev/pts radish-mount-aaaaaaaaaa/dev/pts mount --<span class="hljs-keyword"><span class="hljs-keyword">bind</span></span> /dev/shm radish-mount-aaaaaaaaaa/dev/shm <span class="hljs-keyword"><span class="hljs-keyword">chroot</span></span> radish-mount-aaaaaaaaaa /bin/bash</code> </pre><br><p> (    chroot) </p> <code>exit <br></code> <br><p> (  - chroot) </p><br><pre> <code class="hljs mel">umount radish-mount-aaaaaaaaaa/dev/shm umount radish-mount-aaaaaaaaaa/dev/pts umount radish-mount-aaaaaaaaaa/dev umount radish-mount-aaaaaaaaaa/sys umount radish-mount-aaaaaaaaaa/<span class="hljs-keyword"><span class="hljs-keyword">proc</span></span></code> </pre><br><p>        , : </p><br><pre> <code class="hljs perl">./radish-<span class="hljs-keyword"><span class="hljs-keyword">pack</span></span>-image radish-mount-aaaaaaaaaa</code> </pre><br><p>    root‚Äëimage.bin,      .    ,       : </p><br><pre> <code class="hljs dos">umount radish‚Äëmount‚Äëaaaaaaaaaa <span class="hljs-built_in"><span class="hljs-built_in">rmdir</span></span> radish‚Äëmount‚Äëaaaaaaaaaa rm radish‚Äëimage‚Äëbbbbbbbbbb</code> </pre><br><p>      ,     ,        chroot   ,    .       ,   radish‚Äëpack‚Äëimage     ,      . </p><br><p>            ,           schroot   .      ,    , ,  </p><br><pre> <code class="hljs perl">cp -a radish‚Äëmount‚Äëaaaaaaaaaa \ /var/lib/<span class="hljs-keyword"><span class="hljs-keyword">chroot</span></span>‚Äëenvironments/debian‚Äë<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>‚Äë<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><p>    /etc/schroot.conf, : </p><br><pre> <code class="hljs pgsql">[debian-<span class="hljs-keyword"><span class="hljs-keyword">system</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=directory directory=/var/lib/chroot‚Äëenvironments/debian‚Äë<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>‚Äë<span class="hljs-number"><span class="hljs-number">1</span></span> users=<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> root-users=root</code> </pre><br><p>     </p><br><pre> <code class="hljs swift">schroot -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> debian‚Äësystem‚Äë<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><p>      ,     ,     -  ,    <code><i>/var/lib/chroot‚Äëenvironments/debian‚Äësystem‚Äë1</i></code> </p><br><p>           -          (        <code><i>/home/user/chroot‚Äëenvironments/debian‚Äësystem‚Äë1/home/user/</i></code>    <code><i>/home/user/</i></code> ),     ,             <code>$HOME/.config</code> , <code>$HOME/.local</code> ,  . .,     ,    .   ,      ,    , ,    ,  . . </p><br><h1> 3.   ,     </h1><br><p> radish       ,               .        .  , radish-install   <code>/etc/default/grub</code>      Linux,        ( <code>"nomodeset"</code> )          ( <code>"console=ttyS0,115200n8"</code> ).  ,                 .             (  <code>/etc/inittab</code>  <code>/etc/init/ttyS0.conf</code> )           , <code>/etc/default/grub</code>  : </p><br><pre> <code class="hljs pgsql"># Uncomment <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> graphical terminal (grub-pc <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>) #GRUB_TERMINAL=console GRUB_TERMINAL=<span class="hljs-type"><span class="hljs-type">serial</span></span> GRUB_SERIAL_COMMAND="serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1"</code> </pre><br><p>  ,        ,  <code>GRUB_TERMINAL</code>   <code>"console"</code> .  ,       . </p><br><p>   ¬´¬ª           ,  <code>/lib/udev/rules.d/75‚Äëpersistent‚Äënet‚Äëgenerator.rules</code> ,   ,   radish‚Äëbuild ,         .      ,    ,      , , ,    , , ,               . </p><br><p>    SSH        ,     SSH     ,       .   ,             .       -  , ,    SSH,        . </p><br><p>       .     ,     radish-install     -   .         ( <code>"x"</code>     <code>/etc/passwd</code> ,   -   <code>/etc/shadow</code> ),        <code>/home/user/.ssh/authorized_keys</code> ,          ). </p><br><p>       -    .     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348026/">https://habr.com/ru/post/348026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348016/index.html">And so it will come down ... or the Hole as a means of protection</a></li>
<li><a href="../348018/index.html">Even in Java 9, ArrayList can still (and should) be improved.</a></li>
<li><a href="../348020/index.html">Blockchain: Networking, Signature Verification and Student Assignment, Part 2</a></li>
<li><a href="../348022/index.html">Game development under NES in C. Chapters 1-3. From introduction to Hello World</a></li>
<li><a href="../348024/index.html">SecurityWeek 2: army of clones, Google hunts for ghosts, Blizzard patches</a></li>
<li><a href="../348028/index.html">Convolutional neural network, part 2: training in the error back-propagation algorithm</a></li>
<li><a href="../348032/index.html">Mobility Express - when they decided to migrate and scale the wireless network, but as always, there is no money</a></li>
<li><a href="../348034/index.html">Meeting Room Little Helper</a></li>
<li><a href="../348036/index.html">Software sound synthesis on early personal computers. Part 1</a></li>
<li><a href="../348038/index.html">WSTester - JS library for testing web services with WebSocket</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>