<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hierarchical data structures and performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 In my previous article, I gave a brief overview of the basic storage models of hierarchical structures in relational databases. As it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hierarchical data structures and performance</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br><br>  In my <a href="http://habrahabr.ru/blogs/development/46659/">previous article,</a> I gave a brief overview of the basic storage models of hierarchical structures in relational databases.  As it should be, for many readers the question has become an edge about the performance of the presented algorithms. <br><br>  In this article I will try to lift the veil over this burning issue, and in the next I promise to touch on the issues of optimization and the search for non-standard solutions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><h2>  Training </h2><br>  So, testing.  Like any other testing, ours also requires certain actions to prepare, analyze, develop goals and an action plan. <br><br>  In fact, the goal is to conduct a series of stress tests of different algorithms on different data volumes.  It would also be nice to get rid of tests on several different hardware platforms, but, alas, the author cannot do this (time and money are to blame for everything). <br><br>  Naturally, it would be good to conduct tests of the most important and significant operations that are usually performed on various trees.  After quite a long thought it was decided to stop at the following list of operations to be tested: <br><ol><li>  Selection of the entire tree </li><li>  Sampling the path to a given node </li><li>  Sampling branches of a given node </li><li>  Search for the parent of the specified node </li><li>  Search for heirs of a given node </li><li>  Adding a new node to the end of the specified parent node </li><li>  Moving a node (or, in other words, changing the parent) </li><li>  Deleting a node (and the entire branch under it) </li></ol><br>  It should be noted that we are approaching these operations to combat conditions, i.e.  the input data for us will be the identifiers of the nodes and their parents.  This will allow not to become attached to specific implementations of each of the algorithms. <br><br>  We further specify that we are interested in the performance of pure SQL, so we will take measurements solely on its work. <br><br>  The author does not claim to be complete of the stated list of operations.  Perhaps, someone will remember about the operations of searching for neighbors of a node or selecting all the sheets of a tree, and even in a given branch - please, everyone has the right to expand and supplement this experiment.  For the time being, I‚Äôll focus on the basic, in my opinion, basic minimal functionality. <br><br>  Now I want to dwell in more detail on the implementation of the functions themselves, tests on which will be carried out in the future.  But, if you are only interested in bare figures and facts, you can proceed to the <a href="http://habrahabr.ru/blogs/development/47280/">next section of the</a> article. <br><br>  Not all of the declared functions have trivial solutions in different methods, especially on pure SQL.  For example, selecting a branch in an AL tree is a purely recursive task.  But is it worth doing this at the SQL level? .. <br><br>  In general, several points should be considered: <br><br>  - DBMS on which tests are made - MySQL version 5.0.x.  Engine - InnoDB (suitable for implementing cascading operations for AL-Tree at the database level). <br><br>  - Sampling requests are executed with the SQL_NO_CACHE flag to estimate the ‚Äúnet‚Äù cost of executing queries. <br><br>  - Trees of different types have the same physical structure of nodes (ie, a tree of the same type is randomly created, and the rest of the trees are built from the first). <br><br>  - Algorithms Nested Set and Materialized Path were strengthened by the level field, which stores the nesting level of the current node in the tree.  In particular, we can say that this allows us to increase, for example, the sampling efficiency of the heirs of a node in the MP tree by more than 100 times!  In fact, without this field, these algorithms, in a sense, lose their appeal.  Therefore, we can speak not so much about their tuning when adding this field, but about the necessary condition for their functioning.  Thus, the structure of our test database is as follows: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">-- Adjacency List Tree Structure</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> `al_tree` ( <br> `id` bigint(20) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> auto_increment, <br> `parent_id` bigint(20) <font color="#0000ff">default</font> <font color="#0000ff">NULL</font> , <br> `name` <font color="#0000ff">varchar</font> (50) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (`id`), <br> <font color="#0000ff">KEY</font> `fk_tree_tree` (`parent_id`), <br> <font color="#0000ff">CONSTRAINT</font> `fk_tree_tree` <font color="#0000ff">FOREIGN</font> <font color="#0000ff">KEY</font> (`parent_id`) <font color="#0000ff">REFERENCES</font> `al_tree` (`id`) <font color="#0000ff">ON</font> <font color="#0000ff">DELETE</font> <font color="#0000ff">CASCADE</font> <font color="#0000ff">ON</font> <font color="#0000ff">UPDATE</font> <font color="#0000ff">CASCADE</font> <br> ) ENGINE=InnoDB <font color="#0000ff">DEFAULT</font> CHARSET=utf8 <br> <br> <font color="#008000">-- Nested Set Tree Structure</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> `ns_tree` ( <br> `id` bigint(20) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> auto_increment, <br> `name` <font color="#0000ff">varchar</font> (50) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> `lft` bigint(20) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> `rgt` bigint(20) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> ` <font color="#0000ff">level</font> ` bigint(20) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (`id`), <br> <font color="#0000ff">KEY</font> `nslrl_idx` (`lft`,`rgt`,` <font color="#0000ff">level</font> `) <br> ) ENGINE=InnoDB <font color="#0000ff">DEFAULT</font> CHARSET=utf8 <br> <br> <font color="#008000">-- Materialized Path Tree Structure</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> `mp_tree` ( <br> `id` bigint(20) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> auto_increment, <br> `name` <font color="#0000ff">varchar</font> (50) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> ` <font color="#0000ff">path</font> ` <font color="#0000ff">varchar</font> (100) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> ` <font color="#0000ff">level</font> ` <font color="#0000ff">int</font> (11) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (`id`), <br> <font color="#0000ff">KEY</font> `mpp_idx` (` <font color="#0000ff">path</font> `) <br> ) ENGINE=InnoDB <font color="#0000ff">DEFAULT</font> CHARSET=utf8</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  - To work with the Nested Set and Materialized Path trees, functions and procedures were written at the database level to simplify the routine operations of working with trees.  In particular, the functions STRFIND, REPLACE_PATH and the procedures MOVE_NODE_NS, MOVE_NODE_MP, REMOVE_NODE_MP are added: <br><br>  <strong>STRFIND (str, delimtr)</strong> <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">--</font> <br> <font color="#008000">--      delimtr   str.</font> <br> <font color="#008000">--       </font> <br> <font color="#008000">--      MATERIALIZED PATH.</font> <br> <font color="#008000">-- (-        )</font> <br> <font color="#008000">--</font> <br> <font color="#008000">-- @param str VARCHAR(255) -  </font> <br> <font color="#008000">-- @param delimtr CHAR(1) -  </font> <br> <font color="#008000">-- @return INT - - </font> <br> <font color="#008000">--</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">FUNCTION</font> `STRFIND`(str <font color="#0000ff">VARCHAR</font> (255), delimtr <font color="#0000ff">CHAR</font> (1)) <font color="#0000ff">RETURNS</font> <font color="#0000ff">INT</font> <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">DECLARE</font> _cnt <font color="#0000ff">INT</font> ; <br> <font color="#0000ff">DECLARE</font> _start <font color="#0000ff">INT</font> ; <br> <font color="#0000ff">SET</font> _cnt = -1; <br> <font color="#0000ff">SET</font> _start = 1; <br> <font color="#0000ff">WHILE</font> _start &gt; 0 DO <br> <font color="#0000ff">SET</font> _start = LOCATE( delimtr, str); <br> <font color="#0000ff">SET</font> str  = <font color="#0000ff">SUBSTRING</font> ( str, _start + 1); <br> <font color="#0000ff">SET</font> _cnt  = _cnt + 1; <br> <font color="#0000ff">END</font> <font color="#0000ff">WHILE</font> ; <br> <font color="#0000ff">RETURN</font> _cnt; <br> END</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  <strong>REPLACE_PATH (_str, _match, _replace)</strong> <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">--</font> <br> <font color="#008000">--      _str</font> <br> <font color="#008000">--  _match   _replace,.</font> <br> <font color="#008000">--  _match      _str</font> <br> <font color="#008000">--      </font> <br> <font color="#008000">-- MATERIALIZED PATH   .</font> <br> <font color="#008000">--</font> <br> <font color="#008000">-- @param _str VARCHAR(255) -  </font> <br> <font color="#008000">-- @param _match VARCHAR(255) -  </font> <br> <font color="#008000">-- @param _replace VARCHAR(255) -  </font> <br> <font color="#008000">-- @return VARCHAR(255) -  </font> <br> <font color="#008000">--</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">FUNCTION</font> `REPLACE_PATH`( _str <font color="#0000ff">VARCHAR</font> (255), _match <font color="#0000ff">VARCHAR</font> (255), _replace <font color="#0000ff">VARCHAR</font> (255)) <font color="#0000ff">RETURNS</font> <font color="#0000ff">VARCHAR</font> (255) <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">IF</font> _str <font color="#0000ff">LIKE</font> CONCAT(_match, <font color="#A31515">'%'</font> ) <font color="#0000ff">THEN</font> <br> <font color="#0000ff">RETURN</font> CONCAT( _replace, <font color="#0000ff">SUBSTRING</font> ( _str, LENGTH(_match)+1, LENGTH(_str))); <br> <font color="#0000ff">END</font> <font color="#0000ff">IF</font> ; <br> <font color="#0000ff">RETURN</font> _str; <br> END</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The main difference of the above function from the built-in REPLACE is that it is guaranteed to change the specified string only if a match is found from the beginning of the string and makes changes only once. <br><br>  <strong>MOVE_NODE_NS (node_id, parent_id)</strong> <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">--</font> <br> <font color="#008000">--       NESTED SET</font> <br> <font color="#008000">--</font> <br> <font color="#008000">-- @param node_id -  ,   </font> <br> <font color="#008000">-- @param parent_id -      </font> <br> <font color="#008000">--</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">PROCEDURE</font> MOVE_NODE_NS( node_id BIGINT, parent_id BIGINT) <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">DECLARE</font> done <font color="#0000ff">INT</font> <font color="#0000ff">DEFAULT</font> 0; <br> <font color="#0000ff">DECLARE</font> c_id, c_lft, c_rgt, c_lvl, nWidth, nLeft, nRight, dtKey, nLvl, pRight, addLvl, addKey BIGINT; <br> <font color="#0000ff">DECLARE</font> c_name <font color="#0000ff">VARCHAR</font> (50); <br> <br> <font color="#008000">--       ,</font> <br> <font color="#008000">--   </font> <br> <font color="#0000ff">DECLARE</font> mvBranch <font color="#0000ff">CURSOR</font> <font color="#0000ff">FOR</font> <br> <font color="#0000ff">SELECT</font> id, name, lft - dtKey, rgt - dtKey, <font color="#0000ff">level</font> - nLvl <font color="#0000ff">FROM</font> ns_tree <br> <font color="#0000ff">WHERE</font> lft &gt;= nLeft <font color="#0000ff">AND</font> rgt &lt;= nRight; <br> <br> <font color="#0000ff">DECLARE</font> <font color="#0000ff">CONTINUE</font> HANDLER <font color="#0000ff">FOR</font> <font color="#0000ff">NOT</font> <font color="#0000ff">FOUND</font> <font color="#0000ff">SET</font> done = 1; <br> <br> <font color="#008000">--      </font> <br> <font color="#0000ff">SELECT</font> rgt - lft + 1, lft, rgt, lft - 1, <font color="#0000ff">level</font> <font color="#0000ff">INTO</font> nWidth, nLeft, nRight, dtKey, nLvl <br> <font color="#0000ff">FROM</font> ns_tree <font color="#0000ff">WHERE</font> id = node_id; <br> <br> <font color="#008000">--    </font> <br> <font color="#0000ff">OPEN</font> mvBranch; <br> <br> <font color="#008000">--    </font> <br> <font color="#0000ff">DELETE</font> <font color="#0000ff">FROM</font> ns_tree <font color="#0000ff">WHERE</font> lft <font color="#0000ff">BETWEEN</font> nLeft <font color="#0000ff">AND</font> nRight; <br> <br> <font color="#008000">--    </font> <br> <font color="#0000ff">UPDATE</font> ns_tree <font color="#0000ff">SET</font> rgt = rgt - nWidth <font color="#0000ff">WHERE</font> rgt &gt; nRight; <br> <font color="#0000ff">UPDATE</font> ns_tree <font color="#0000ff">SET</font> lft = lft - nWidth <font color="#0000ff">WHERE</font> lft &gt; nRight; <br> <br> <font color="#008000">--       </font> <br> <font color="#0000ff">SELECT</font> rgt, <font color="#0000ff">level</font> + 1 <font color="#0000ff">INTO</font> pRight, addLvl <font color="#0000ff">FROM</font> ns_tree <font color="#0000ff">WHERE</font> id = parent_id; <br> <br> <font color="#0000ff">SELECT</font> <font color="#0000ff">MAX</font> (node.rgt) <font color="#0000ff">INTO</font> addKey <font color="#0000ff">FROM</font> ns_tree node, ns_tree parent <br> <font color="#0000ff">WHERE</font> node.lft <font color="#0000ff">BETWEEN</font> parent.lft <font color="#0000ff">AND</font> parent.rgt <font color="#0000ff">AND</font> node. <font color="#0000ff">level</font> = parent. <font color="#0000ff">level</font> + 1 <font color="#0000ff">AND</font> parent.id = parent_id; <br> <br> <font color="#008000">--    ,  </font> <br> <font color="#008000">--    </font> <br> <font color="#0000ff">UPDATE</font> ns_tree <font color="#0000ff">SET</font> rgt = rgt + nWidth <font color="#0000ff">WHERE</font> rgt &gt;= pRight; <br> <font color="#0000ff">UPDATE</font> ns_tree <font color="#0000ff">SET</font> lft = lft + nWidth <font color="#0000ff">WHERE</font> lft &gt; pRight; <br> <br> <font color="#008000">--      .</font> <br> <font color="#008000">--   </font> <br> REPEAT <br> <font color="#0000ff">FETCH</font> mvBranch <font color="#0000ff">INTO</font> c_id, c_name, c_lft, c_rgt, c_lvl; <br> <font color="#0000ff">IF</font> <font color="#0000ff">NOT</font> done <font color="#0000ff">THEN</font> <br> <font color="#0000ff">INSERT</font> <font color="#0000ff">INTO</font> ns_tree <font color="#0000ff">VALUES</font> (c_id, c_name, c_lft + addKey, c_rgt + addKey, c_lvl + addLvl); <br> <font color="#0000ff">END</font> <font color="#0000ff">IF</font> ; <br> UNTIL done <font color="#0000ff">END</font> REPEAT; <br> <br> <font color="#0000ff">CLOSE</font> mvBranch; <br> END</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  <strong>MOVE_NODE_MP (node_id, parent_id)</strong> <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">--</font> <br> <font color="#008000">--       MATERIALIZED PATH</font> <br> <font color="#008000">--</font> <br> <font color="#008000">-- @param node_id -  ,   </font> <br> <font color="#008000">-- @param parent_id -      </font> <br> <font color="#008000">--</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">PROCEDURE</font> MOVE_NODE_MP( node_id BIGINT, parent_id BIGINT) <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">DECLARE</font> done, m_cnt, m_rows, p_cnt, p_rows <font color="#0000ff">INT</font> <font color="#0000ff">DEFAULT</font> 0; <br> <font color="#0000ff">DECLARE</font> c_id, p_id, n_pos, n_lvl, np_id, np_lvl, new_pos, dt_lvl, ch_id, ch_pos BIGINT; <br> <font color="#0000ff">DECLARE</font> c_path, p_path, n_path, np_path, ch_path, new_path <font color="#0000ff">VARCHAR</font> (100); <br> <br> <font color="#008000">--  ,    ,</font> <br> <font color="#008000">--   </font> <br> <font color="#0000ff">DECLARE</font> mvBranch <font color="#0000ff">CURSOR</font> <font color="#0000ff">FOR</font> <br> <font color="#0000ff">SELECT</font> SQL_CALC_FOUND_ROWS node.id, node. <font color="#0000ff">path</font> <font color="#0000ff">FROM</font> mp_tree node, mp_tree parent <br> <font color="#0000ff">WHERE</font> node. <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT(parent. <font color="#0000ff">path</font> , <font color="#A31515">'%'</font> ) <font color="#0000ff">AND</font> parent.id = node_id; <br> <br> <font color="#008000">--  ,      </font> <br> <font color="#008000">--  ,      </font> <br> <font color="#0000ff">DECLARE</font> pChildren <font color="#0000ff">CURSOR</font> <font color="#0000ff">FOR</font> <br> <font color="#0000ff">SELECT</font> SQL_CALC_FOUND_ROWS node.id, node. <font color="#0000ff">path</font> , <br> <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE(node. <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , node. <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED) <font color="#0000ff">as</font> pos <br> <font color="#0000ff">FROM</font> mp_tree node, mp_tree parent <br> <font color="#0000ff">WHERE</font> node. <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT(parent. <font color="#0000ff">path</font> , <font color="#A31515">'%'</font> ) <font color="#0000ff">AND</font> node. <font color="#0000ff">level</font> = parent. <font color="#0000ff">level</font> + 1 <br> <font color="#0000ff">AND</font> <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE(node. <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , node. <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED) &gt; n_pos <br> <font color="#0000ff">AND</font> parent.id = p_id <br> <font color="#0000ff">ORDER</font> <font color="#0000ff">BY</font> pos; <br> <br> <font color="#0000ff">DECLARE</font> <font color="#0000ff">CONTINUE</font> HANDLER <font color="#0000ff">FOR</font> <font color="#0000ff">NOT</font> <font color="#0000ff">FOUND</font> <font color="#0000ff">SET</font> done = 1; <br> <br> <font color="#008000">--   </font> <br> <font color="#0000ff">SELECT</font> <font color="#0000ff">path</font> , <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE( <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED), <font color="#0000ff">level</font> <font color="#0000ff">INTO</font> n_path, n_pos, n_lvl <font color="#0000ff">FROM</font> mp_tree <br> <font color="#0000ff">WHERE</font> id = node_id; <br> <br> <font color="#0000ff">SELECT</font> parent.id, parent. <font color="#0000ff">path</font> <font color="#0000ff">INTO</font> p_id, p_path <font color="#0000ff">FROM</font> mp_tree node, mp_tree parent <br> <font color="#0000ff">WHERE</font> parent. <font color="#0000ff">path</font> = <font color="#0000ff">SUBSTRING</font> ( node. <font color="#0000ff">path</font> , 1, (LENGTH(node. <font color="#0000ff">path</font> ) - LOCATE( <font color="#A31515">'.'</font> , REVERSE(node. <font color="#0000ff">path</font> )))) <br> <font color="#0000ff">AND</font> node.id = node_id; <br> <br> <font color="#0000ff">SELECT</font> id, <font color="#0000ff">path</font> , <font color="#0000ff">level</font> <font color="#0000ff">INTO</font> np_id, np_path, np_lvl <font color="#0000ff">FROM</font> mp_tree <font color="#0000ff">WHERE</font> id = parent_id; <br> <br> <font color="#008000">--        </font> <br> <font color="#008000">--   :</font> <br> <font color="#0000ff">SET</font> dt_lvl = np_lvl - n_lvl + 1; <br> <br> <font color="#0000ff">SELECT</font> <font color="#0000ff">MAX</font> ( <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE(node. <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , node. <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED)) + 1 <br> <font color="#0000ff">INTO</font> new_pos <font color="#0000ff">FROM</font> mp_tree node, mp_tree parent <font color="#0000ff">WHERE</font> node. <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT(parent. <font color="#0000ff">path</font> , <font color="#A31515">'%'</font> ) <br> <font color="#0000ff">AND</font> node. <font color="#0000ff">level</font> = parent. <font color="#0000ff">level</font> + 1 <font color="#0000ff">AND</font> parent.id = parent_id; <br> <br> <font color="#008000">--  </font> <br> <font color="#0000ff">OPEN</font> mvBranch; <br> <font color="#0000ff">SELECT</font> FOUND_ROWS() <font color="#0000ff">INTO</font> m_rows; <br> <br> <font color="#0000ff">WHILE</font> m_cnt &lt; m_rows DO <br> <font color="#0000ff">FETCH</font> mvBranch <font color="#0000ff">INTO</font> c_id, c_path; <br> <font color="#0000ff">UPDATE</font> mp_tree <br> <font color="#0000ff">SET</font> <font color="#0000ff">path</font> = REPLACE_PATH( <font color="#0000ff">path</font> , n_path, CONCAT(np_path, <font color="#A31515">'.'</font> , new_pos)), <font color="#0000ff">level</font> = <font color="#0000ff">level</font> + dt_lvl <font color="#0000ff">WHERE</font> id = c_id; <br> <font color="#0000ff">SET</font> m_cnt = m_cnt + 1; <br> <font color="#0000ff">END</font> <font color="#0000ff">WHILE</font> ; <br> <font color="#0000ff">CLOSE</font> mvBranch; <br> <br> <font color="#008000">--        .</font> <br> <font color="#008000">--   </font> <br> <font color="#0000ff">OPEN</font> pChildren; <br> <font color="#0000ff">SELECT</font> FOUND_ROWS() <font color="#0000ff">INTO</font> p_rows; <br> <br> <font color="#0000ff">WHILE</font> p_cnt &lt; p_rows DO <br> <font color="#0000ff">FETCH</font> pChildren <font color="#0000ff">INTO</font> ch_id, ch_path, ch_pos; <br> <font color="#0000ff">UPDATE</font> mp_tree <font color="#0000ff">SET</font> <font color="#0000ff">path</font> = REPLACE_PATH( <font color="#0000ff">path</font> , ch_path, CONCAT(p_path, <font color="#A31515">'.'</font> , ch_pos - 1)) <font color="#0000ff">WHERE</font> <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT( ch_path, <font color="#A31515">'%'</font> ); <br> <font color="#0000ff">SET</font> p_cnt = p_cnt + 1; <br> <font color="#0000ff">END</font> <font color="#0000ff">WHILE</font> ; <br> <font color="#0000ff">CLOSE</font> pChildren; <br> END</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  <strong>REMOVE_NODE_MP (node_id)</strong> <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">--</font> <br> <font color="#008000">--       MATERIALIZED PATH</font> <br> <font color="#008000">--</font> <br> <font color="#008000">-- @param node_id -  ,   </font> <br> <font color="#008000">--</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">PROCEDURE</font> REMOVE_NODE_MP( node_id BIGINT) <br> <font color="#0000ff">BEGIN</font> <br> <font color="#0000ff">DECLARE</font> n_pos, ch_id, p_id, ch_pos BIGINT; <br> <font color="#0000ff">DECLARE</font> n_path, ch_path, p_path <font color="#0000ff">VARCHAR</font> (100); <br> <font color="#0000ff">DECLARE</font> done, p_cnt, p_rows <font color="#0000ff">INT</font> <font color="#0000ff">DEFAULT</font> 0; <br> <br> <font color="#008000">--  ,      </font> <br> <font color="#008000">--  ,      </font> <br> <font color="#0000ff">DECLARE</font> pChildren <font color="#0000ff">CURSOR</font> <font color="#0000ff">FOR</font> <br> <font color="#0000ff">SELECT</font> SQL_CALC_FOUND_ROWS node.id, node. <font color="#0000ff">path</font> , <br> <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE(node. <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , node. <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED) <font color="#0000ff">as</font> pos <br> <font color="#0000ff">FROM</font> mp_tree node, mp_tree parent <br> <font color="#0000ff">WHERE</font> node. <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT(parent. <font color="#0000ff">path</font> , <font color="#A31515">'%'</font> ) <font color="#0000ff">AND</font> node. <font color="#0000ff">level</font> = parent. <font color="#0000ff">level</font> + 1 <br> <font color="#0000ff">AND</font> <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE(node. <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , node. <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED) &gt; n_pos <br> <font color="#0000ff">AND</font> parent.id = p_id <br> <font color="#0000ff">ORDER</font> <font color="#0000ff">BY</font> pos; <br> <br> <font color="#0000ff">DECLARE</font> <font color="#0000ff">CONTINUE</font> HANDLER <font color="#0000ff">FOR</font> <font color="#0000ff">NOT</font> <font color="#0000ff">FOUND</font> <font color="#0000ff">SET</font> done = 1; <br> <br> <font color="#008000">--   </font> <br> <font color="#0000ff">SELECT</font> <font color="#0000ff">path</font> , <font color="#0000ff">CAST</font> ( <font color="#0000ff">SUBSTRING</font> (REVERSE( <font color="#0000ff">path</font> ), 1, LOCATE( <font color="#A31515">'.'</font> , <font color="#0000ff">path</font> )-1) <font color="#0000ff">AS</font> UNSIGNED) <font color="#0000ff">INTO</font> n_path, n_pos <font color="#0000ff">FROM</font> mp_tree <br> <font color="#0000ff">WHERE</font> id = node_id; <br> <br> <font color="#0000ff">SELECT</font> parent.id, parent. <font color="#0000ff">path</font> <font color="#0000ff">INTO</font> p_id, p_path <font color="#0000ff">FROM</font> mp_tree node, mp_tree parent <br> <font color="#0000ff">WHERE</font> parent. <font color="#0000ff">path</font> = <font color="#0000ff">SUBSTRING</font> ( node. <font color="#0000ff">path</font> , 1, (LENGTH(node. <font color="#0000ff">path</font> ) - LOCATE( <font color="#A31515">'.'</font> , REVERSE(node. <font color="#0000ff">path</font> )))) <br> <font color="#0000ff">AND</font> node.id = node_id; <br> <br> <font color="#008000">--  </font> <br> <font color="#0000ff">DELETE</font> <font color="#0000ff">FROM</font> mp_tree <font color="#0000ff">WHERE</font> <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT( n_path, <font color="#A31515">'%'</font> ); <br> <br> <font color="#008000">--          </font> <br> <font color="#0000ff">OPEN</font> pChildren; <br> <font color="#0000ff">SELECT</font> FOUND_ROWS() <font color="#0000ff">INTO</font> p_rows; <br> <br> <font color="#0000ff">WHILE</font> p_cnt &lt; p_rows DO <br> <font color="#0000ff">FETCH</font> pChildren <font color="#0000ff">INTO</font> ch_id, ch_path, ch_pos; <br> <font color="#0000ff">UPDATE</font> mp_tree <font color="#0000ff">SET</font> <font color="#0000ff">path</font> = REPLACE_PATH( <font color="#0000ff">path</font> , ch_path, CONCAT(p_path, <font color="#A31515">'.'</font> , ch_pos - 1)) <font color="#0000ff">WHERE</font> <font color="#0000ff">path</font> <font color="#0000ff">LIKE</font> CONCAT( ch_path, <font color="#A31515">'%'</font> ); <br> <font color="#0000ff">SET</font> p_cnt = p_cnt + 1; <br> <font color="#0000ff">END</font> <font color="#0000ff">WHILE</font> ; <br> <font color="#0000ff">CLOSE</font> pChildren; <br> END</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In fact, now all the details of the implementation are disclosed, this can be stopped and proceed to the issues of testing. <br><br><h2>  Testing </h2><br><br>  Testing was performed using a self-written console program with the following configuration: <br><br>  Hardware: <br><blockquote>  CPU: Intel¬Æ Core (TM) 2 Duo CPU E7200 @ 2.53GHz 6Mb 64bit <br>  RAM: 4 Gb <br>  HD: 2 x 250Gb 7200rpm RAID 1 </blockquote><br><br>  Software: <br><blockquote>  OS: Debian Linux 2.6.26-1-amd64 (64bit) <br>  PHP-CLI: 5.2.6-5 with Suhosin-Patch 0.9.6.2 <br>  MySQL: 5.0.51a, for debian-linux-gnu (x86_64) using readline 5.2 </blockquote><br><br>  Let's say this machine is a server that is far from being heavily loaded at the moment (about 100,000 fairly simple HTTP requests per day), which is almost negligible for this configuration. <br><br>  You can <a href="">download the</a> program <a href="">from here</a> and try testing it on your machine (it works only in a Unix-like environment).  Instructions for working with the program can be found in the downloaded distribution file in the README.TXT file. <br><br>  During testing, 5 tree configurations were selected: <br><ul><li>  100 nodes and nesting level 5 </li><li>  1000 nodes and nesting level 10 </li><li>  10,000 knots and nesting level 20 </li><li>  100,000 nodes and nesting level 25 </li><li>  500,000 nodes and nesting level 30 </li></ul><br>  These are trees, tests over which managed to be successfully completed.  All tests were completed in less than 6 hours, while most of the time, naturally, took the last test with trees of half a million nodes. <br><br>  The algorithm for creating trees works in such a way that the law of the distribution of nodes in a tree is about the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7c/ab4/556/c7cab45566342a7ebada2a2b7bd48e36.png" title="The law of distribution of nodes in the tree" width="300" height="214"><br><br>  Where the abscissa is the identifiers of the nodes in ascending order, and the ordinate is the number of nodes in the branches of the node with the specified identifier. <br><br>  In connection with this state of affairs, the following testing scheme was chosen.  Per sample - an iterative step-by-step scheme for checking the functioning of the sampling algorithms on different parts of the tree.  Iterations are organized in the following way: <br><br><blockquote><pre>  id&gt; 1 &lt;10 - step 1
 id&gt; 10 &lt;100 - step 10
 id&gt; 100 &lt;1000 - step 100
 id&gt; 1000 &lt;10000 - step 1000
 id&gt; 10000 &lt;100000 - step 10000
 id&gt; 100000 - step 100000 </pre></blockquote><br><br>  This allows tracing the dependence of the search and sampling functions on the distribution law of nodes. <br><br>  For the change functions, the scheme chosen is somewhat different.  Since the change operations themselves for most algorithms are quite costly operations, it makes no sense to check them in an iterative way (the waiting time for testing completion increases too much).  Therefore, the verification method is based on making changes in one of the largest nodes, which is located at the beginning of the tree.  In addition, such a test will be performed once.  In order to describe the overall picture and identify the range of problems - this is quite enough. <br><br><h2>  Analysis </h2><br><br>  So, tests are performed, data is collected.  I believe that there is no point in throwing out in this article all the numbers that we got in the results.  However, they are available for download as an <a href="">archive</a> .  So everyone can look at them personally. <br><br>  Where it will be more interesting to show empirically what these results are.  Let's look at what some graphs look like for a tree with 100,000 nodes. <br><br><blockquote>  Everything below is counted and specified in seconds. </blockquote><br><br><img title="Select all tree" src="https://habrastorage.org/getpro/habr/post_images/1ea/32b/fea/1ea32bfeaa1c450623383dbd8cef68ad.png" width="404" height="271"><br>  <i>Fig.</i>  <i>1. Selection of the entire tree</i> <br><br>  The following graphs show the dependence of the fluctuations of the sample functions on the search in different parts of the tree.  In fact, the numbers on the y-axis indicate the steps discussed above. <br><br><img title="Parent search" src="https://habrastorage.org/getpro/habr/post_images/ddf/561/d28/ddf561d28698893f72f067ba741a34c3.png" width="500" height="244"><br>  <i>Fig.</i>  <i>2. Search for parent node</i> <br><br><img title="Search for heirs" src="https://habrastorage.org/getpro/habr/post_images/e6c/cb2/c05/e6ccb2c05ee1bb08233e84dfd6cb2b9b.png" width="500" height="242"><br>  <i>Fig.</i>  <i>3. Search for heirs of a given node</i> <br><br><img title="Branch selection" src="https://habrastorage.org/getpro/habr/post_images/c29/7a7/fdb/c297a7fdb0b531b2f21ae2b8c1b92951.png" width="500" height="238"><br>  <i>Fig.</i>  <i>4. Selection of the entire branch of a given node</i> <br><br><img title="Choosing the full path to the node" src="https://habrastorage.org/getpro/habr/post_images/75f/c80/da9/75fc80da9802222ca1b77ea91eb206db.png" width="500" height="240"><br>  <i>Fig.</i>  <i>5. Search for the complete path from the root to the given node</i> <br><br>  The following illustrates the function changes that were carried out on trees of various types. <br><br><img title="Add node" src="https://habrastorage.org/getpro/habr/post_images/3ce/ec8/bef/3ceec8bef280762050e395d443f08c15.png" width="414" height="270"><br>  <i>Fig.</i>  <i>6. Adding a new node to the tree</i> <br><br><img title="Moving a node" src="https://habrastorage.org/getpro/habr/post_images/f11/d75/16f/f11d7516f539606eb4202627b3374a64.png" width="415" height="269"><br>  <i>Fig.</i>  <i>7. Moving a node</i> <br><br><img title="Deleting a node" src="https://habrastorage.org/getpro/habr/post_images/83f/032/fe6/83f032fe65882fb750632a68c55c65b6.png" width="401" height="270"><br>  <i>Fig.</i>  <i>8. Removing a node and all its descendants from the tree</i> <br><br>  Generally, in absolute figures, we can draw the following conclusions: <br><br>  <strong>Adjacency List:</strong> <br><table border="1" cellpadding="3"><tbody><tr><td align="right">  <strong>Knots</strong> </td><td align="center">  <strong>ALL</strong> </td><td align="center">  <strong>PATH</strong> </td><td align="center">  <strong>BRANCH</strong> </td><td align="center">  <strong>PARENT</strong> </td><td align="center">  <strong>CHILDREN</strong> </td><td align="center">  <strong>ADD</strong> </td><td align="center">  <strong>MOVE</strong> </td><td align="center">  <strong>Remove</strong> </td></tr><tr><td align="right">  <strong>100</strong> </td><td align="right">  0,00245 </td><td align="right">  0,00016 </td><td align="right">  0,00416 </td><td align="right">  0,00009 </td><td align="right">  0,00011 </td><td align="right">  0,00059 </td><td align="right">  0,00037 </td><td align="right">  0,00009 </td></tr><tr><td align="right">  <strong>1000</strong> </td><td align="right">  0,00335 </td><td align="right">  0,00025 </td><td align="right">  0.03579 </td><td align="right">  0,00009 </td><td align="right">  0,00011 </td><td align="right">  0,00387 </td><td align="right">  0,00037 </td><td align="right">  0,00009 </td></tr><tr><td align="right">  <strong>10,000</strong> </td><td align="right">  0,01244 </td><td align="right">  0,00058 </td><td align="right">  0.38146 </td><td align="right">  0,00024 </td><td align="right">  0,00036 </td><td align="right">  0.03548 </td><td align="right">  0,00081 </td><td align="right">  0,00011 </td></tr><tr><td align="right">  <strong>100,000</strong> </td><td align="right">  0.10798 </td><td align="right">  0,00105 </td><td align="right">  2,55379 </td><td align="right">  0,00155 </td><td align="right">  0,00138 </td><td align="right">  0.06382 </td><td align="right">  0,00119 </td><td align="right">  0.13931 </td></tr><tr><td align="right">  <strong>500,000</strong> </td><td align="right">  0.62305 </td><td align="right">  0,00124 </td><td align="right">  43,91373 </td><td align="right">  0,00053 </td><td align="right">  0,00209 </td><td align="right">  0.05232 </td><td align="right">  0,00077 </td><td align="right">  0,00041 </td></tr></tbody></table><br><br>  <strong>Nested Set</strong> <br><table border="1" cellpadding="3"><tbody><tr><td align="right">  <strong>Knots</strong> </td><td align="center">  <strong>ALL</strong> </td><td align="center">  <strong>PATH</strong> </td><td align="center">  <strong>BRANCH</strong> </td><td align="center">  <strong>PARENT</strong> </td><td align="center">  <strong>CHILDREN</strong> </td><td align="center">  <strong>ADD</strong> </td><td align="center">  <strong>MOVE</strong> </td><td align="center">  <strong>Remove</strong> </td></tr><tr><td align="right">  <strong>100</strong> </td><td align="right">  0,00020 </td><td align="right">  0,00015 </td><td align="right">  0,00020 </td><td align="right">  0,00017 </td><td align="right">  0,00019 </td><td align="right">  0,00367 </td><td align="right">  0.02285 </td><td align="right">  0,00314 </td></tr><tr><td align="right">  <strong>1000</strong> </td><td align="right">  0,00129 </td><td align="right">  0,00040 </td><td align="right">  0,00093 </td><td align="right">  0,00017 </td><td align="right">  0,00059 </td><td align="right">  0.02593 </td><td align="right">  0.19237 </td><td align="right">  0.02619 </td></tr><tr><td align="right">  <strong>10,000</strong> </td><td align="right">  0,01387 </td><td align="right">  0,00433 </td><td align="right">  0,00825 </td><td align="right">  0,01771 </td><td align="right">  0,00460 </td><td align="right">  0.38235 </td><td align="right">  1,37070 </td><td align="right">  0.37219 </td></tr><tr><td align="right">  <strong>100,000</strong> </td><td align="right">  0.17165 </td><td align="right">  0.07634 </td><td align="right">  0.14261 </td><td align="right">  0.17218 </td><td align="right">  0.09953 </td><td align="right">  101,749 </td><td align="right">  213,461 </td><td align="right">  59,1912 </td></tr><tr><td align="right">  <strong>500,000</strong> </td><td align="right">  0.83033 </td><td align="right">  0.41670 </td><td align="right">  0.62517 </td><td align="right">  0.42942 </td><td align="right">  0.15318 </td><td align="right">  1427.96 </td><td align="right">  3712.30 </td><td align="right">  1627.97 </td></tr></tbody></table><br><br>  <strong>Materialized Path</strong> <br><table border="1" cellpadding="3"><tbody><tr><td align="right">  <strong>Knots</strong> </td><td align="center">  <strong>ALL</strong> </td><td align="center">  <strong>PATH</strong> </td><td align="center">  <strong>BRANCH</strong> </td><td align="center">  <strong>PARENT</strong> </td><td align="center">  <strong>CHILDREN</strong> </td><td align="center">  <strong>ADD</strong> </td><td align="center">  <strong>MOVE</strong> </td><td align="center">  <strong>Remove</strong> </td></tr><tr><td align="right">  <strong>100</strong> </td><td align="right">  0,00020 </td><td align="right">  0,00017 </td><td align="right">  0,00020 </td><td align="right">  0,00016 </td><td align="right">  0,00019 </td><td align="right">  0,00076 </td><td align="right">  0.02633 </td><td align="right">  0,00059 </td></tr><tr><td align="right">  <strong>1000</strong> </td><td align="right">  0,00137 </td><td align="right">  0,00069 </td><td align="right">  0,00107 </td><td align="right">  0,00016 </td><td align="right">  0,00071 </td><td align="right">  0,00136 </td><td align="right">  0,22232 </td><td align="right">  0,00136 </td></tr><tr><td align="right">  <strong>10,000</strong> </td><td align="right">  0.01560 </td><td align="right">  0,00608 </td><td align="right">  0.01372 </td><td align="right">  0,00056 </td><td align="right">  0,00737 </td><td align="right">  0,00679 </td><td align="right">  1,44434 </td><td align="right">  0,00801 </td></tr><tr><td align="right">  <strong>100,000</strong> </td><td align="right">  0.18680 </td><td align="right">  0,10466 </td><td align="right">  0.17608 </td><td align="right">  0,00064 </td><td align="right">  0.18546 </td><td align="right">  0.92136 </td><td align="right">  41.5875 </td><td align="right">  1.06560 </td></tr><tr><td align="right">  <strong>500,000</strong> </td><td align="right">  0.99102 </td><td align="right">  0.56412 </td><td align="right">  0.59418 </td><td align="right">  0,00090 </td><td align="right">  0.56800 </td><td align="right">  2.02149 </td><td align="right">  2950.40 </td><td align="right">  1.67124 </td></tr></tbody></table><br><br>  Let's think about what they say all these numbers and graphs. <br><br>  First, all algorithms on small amounts of data (up to 10,000 nodes inclusive) showed quite acceptable performance on all functions. <br><br>  Secondly, problem operations exist, namely: <br><br>  Selection of branches entirely in the tree AL.  Look, this operation takes up to 2.5 seconds. <br><br><blockquote>  I would like to note that we cheated a little in our test.  And this is how.  In the adjacency list (AL) algorithm, we implemented the path selection method of the multiple JOINs of the table with ourselves.  Yes, the result is impressive, especially in comparison with the result of fetching a branch in a recursive way.  But you are unlikely to choose such a way of implementing this function for your application.  Is that as a temporary optimization.  After all, you need to know the maximum level of nesting and not fall under the limitation of the DBMS on the number of JOINs in a single query.  We just did a test. </blockquote><br><br>  Next, we have problems with node movement operations in NS and MP algorithms ranging from 10,000 nodes in the tree (over 1 second) and then everything gets worse - at 100,000 nodes for MP - this figure is over 40 seconds, for NS - almost 4 minutes.  At 500,000 knots, the numbers go beyond all reasonable limits - almost 50 minutes for MP and over 1 hour for NS. <br><br>  For NS, a similar picture develops in the remaining operations of change.  For 10,000 items, the addition takes more than 1.5 minutes, and for 500,000 items, it already takes more than 23 minutes.  With removal, the same problem is almost a minute for 100,000 knots and over 27 minutes for 500,000 knots. <br><br>  MP feels quite confident and on fairly large volumes in the operations of removing and adding nodes.  On trees of 100,000 elements, these operations take place within 1 second, which is more than a positive result.  And even at 500,000 nodes, these operations occur within a few seconds. <br><br>  This means that Nested Set should be used with actually static trees, which, if changed, are extremely rare.  At the same time, it is worthwhile to think about creating a tool that rebuilds the tree on demand completely, using the AL scheme in the base basis (as our program for generating arbitrary random trees does).  This, as evidenced by the facts much faster than the NS routine itself.  Or even abandon this algorithm in favor of the Materialized Path. <br><br><h2>  Conclusion </h2><br><br>  As we were able to find out, the demand for such algorithms as Nested Set and Materialized Path is due, first of all, to large amounts of data, where they can optimize some search and sample requests that will be critical for the application.  Or under high load conditions, where query optimization is also important.  In this case, we are talking about the optimization of such operations as finding the path and selecting the entire branch in the Adjacency List tree.  In practice, it is also worth talking about optimizing the operations of finding neighbors, choosing the ‚Äúleaves‚Äù of the whole tree or in a branch of a given node, as well as other operations not considered here (which, in fact, are difficult to implement for AL at the level of SQL queries). <br><br>  Against the background of the results obtained, the Nested Set is qualitatively inferior to the Materialized Path, which feels quite confident in the operations for deletion and addition (and how often do you move nodes in your trees? ...).  In addition, I see good prospects for optimizing this algorithm, which we will discuss in the next article. <br><br>  Good luck in development! <br><br><blockquote>  <sub>This is a cross-post of the <a href="http://mikhailstadnik.com/hierarchical-data-structures-and-performance">original article</a> from my blog.</sub> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/47280/">https://habr.com/ru/post/47280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../47273/index.html">Russian layout in OpenSolaris 2008.11</a></li>
<li><a href="../47274/index.html">Leaky Ecofont saves paint</a></li>
<li><a href="../47275/index.html">Another iPhone bug, or how to use an iPhone and a sim card with an unknown PIN-code.</a></li>
<li><a href="../47277/index.html">Windows 7 performance versus</a></li>
<li><a href="../47278/index.html">Features of national web design?</a></li>
<li><a href="../47281/index.html">United Keys OLED Display - Optimus Maximus Cheap</a></li>
<li><a href="../47282/index.html">NIC.RU lost domain</a></li>
<li><a href="../47283/index.html">Profitable proposition</a></li>
<li><a href="../47284/index.html">Reality show "Startup for the week." The first report of half a day of work</a></li>
<li><a href="../47286/index.html">Conference on Information Security of the Russian Banking System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>