<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to frequently used features of ES6. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This publication is the second part of the translation of the article ‚ÄúIntroduction to commonly used ES6 features‚Äù by Zell Liew, posted here . The tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to frequently used features of ES6. Part 2</h1><div class="post__text post__text-html js-mediator-article"><p>  <i>This publication is the second part of the translation of the article ‚ÄúIntroduction to commonly used ES6 features‚Äù by Zell Liew, posted</i> <a href="https://zellwk.com/blog/es6/"><i>here</i></a> .  <i>The translation of the 1st part is</i> <a href="https://habrahabr.ru/post/340002/"><i>here</i></a> . </p><br><h2>  Destructuring </h2><br><p>  Destructuring is a convenient way to extract values ‚Äã‚Äãfrom arrays and objects.  There are minor differences between the destructurization of arrays and objects, so we consider them separately. </p><br><h3>  Object Destructuring </h3><br><p>  Suppose you have the following object: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Zell = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Zell'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Liew'</span></span> }</code> </pre> <br><a name="habracut"></a><br><p>  To get <code>firstName</code> and <code>lastName</code> from <code>Zell</code> you need to create two variables, and then assign each variable a value as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstName = Zell.firstName; <span class="hljs-comment"><span class="hljs-comment">// Zell let lastName = Zell.lastName; // Liew</span></span></code> </pre><br><p>  With destructurization, the creation and assignment of these variables is done in a single line of code.  Below is an example of object restructuring: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { firstName, lastName } = Zell; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(firstName); <span class="hljs-comment"><span class="hljs-comment">// Zell console.log(lastName); // Liew</span></span></code> </pre><br><p>  When adding <b>curly braces</b> to a variable declaration, an instruction is made to create these variables and then assign <code>Zell.firstName</code> in <code>firstName</code> , and <code>Zell.lastName</code> in <code>lastName</code> . </p><br><p>  Explain what happens under the "hood": </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   : let { firstName, lastName } = Zell; // ,  ES6 : let firstName = Zell.firstName; let lastName = Zell.lastName;</span></span></code> </pre><br><p>  Now, if the variable name is already taken, then it is impossible to declare the same variable again (especially if you use <code>let</code> or <code>const</code> ). </p><br><p>  The following code does not work: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Zell Liew'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> course = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'JS Fundamentals for Frontend Developers'</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...   } let { name } = course; // Uncaught SyntaxError:     </span></span></code> </pre><br><p>  In such situations, you can rename variables at the same time as destructuring with a colon. </p><br><p>  In the example below, the variable <code>courseName</code> is created and assigned to it <code>course.name</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: courseName } = course; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(courseName); <span class="hljs-comment"><span class="hljs-comment">// JS Fundamentals for Frontend Developers // ,  ES6 : let courseName = course.name;</span></span></code> </pre><br><p>  Note that if you unstructure a variable that is not in the object, then <code>undefined</code> will be returned. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> course = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'JS Fundamentals for Frontend Developers'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { package } = course; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(package); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br><p>  Remember the default settings?  You can also write default parameters for unstructured variables.  Syntax is similar to function declaration syntax. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> course = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'JS Fundamentals for Frontend Developers'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { package = <span class="hljs-string"><span class="hljs-string">'full course'</span></span> } = course; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(package); <span class="hljs-comment"><span class="hljs-comment">// full course</span></span></code> </pre><br><p>  You can even rename variables when specifying default parameters.  It is necessary to make a combination of two syntaxes, which will be unusual at first, but you can get used to this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> course = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'JS Fundamentals for Frontend Developers'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { <span class="hljs-attr"><span class="hljs-attr">package</span></span>: packageName = <span class="hljs-string"><span class="hljs-string">'full course'</span></span> } = course; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(packageName); <span class="hljs-comment"><span class="hljs-comment">// full course</span></span></code> </pre><br><p>  This is all related to the destructuring of objects.  Now consider the destructuring of arrays. </p><br><h3>  Destructuring arrays </h3><br><p>  Destructuring arrays and objects are similar.  When working with arrays instead of braces are used square. </p><br><p>  With array destructurization: </p><br><ul><li>  1st variable - first element of array </li><li>  2nd variable - the second element of the array </li><li>  etc. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [one, two] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(one); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(two); // 2</span></span></code> </pre><br><p>  If during destructuring the number of variables exceeds the size of the array, the additional variables will be <code>undefined</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [one, two, three] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(one); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(two); // 2 console.log(three); // undefined</span></span></code> </pre><br><p>  When destructurizing an array, only the necessary variables are often extracted.  To get the remainder, use the rest statement as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scores = [<span class="hljs-string"><span class="hljs-string">'98'</span></span>, <span class="hljs-string"><span class="hljs-string">'95'</span></span>, <span class="hljs-string"><span class="hljs-string">'93'</span></span>, <span class="hljs-string"><span class="hljs-string">'90'</span></span>, <span class="hljs-string"><span class="hljs-string">'87'</span></span>, <span class="hljs-string"><span class="hljs-string">'85'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [first, second, third, ...rest] = scores; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first); <span class="hljs-comment"><span class="hljs-comment">// 98 console.log(second); // 95 console.log(third); // 93 console.log(rest); // [90, 87, 85]</span></span></code> </pre><br><p>  Rest operator will be presented in more detail in the next section.  Now consider the permutation of variables using array restructuring. </p><br><h4>  Permutation of variables using array destructuring </h4><br><p>  Suppose there are two variables <code>a</code> and <code>b</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><p>  You need to rearrange these variables so that <code>a</code> becomes equal to 3 and <code>b</code> is equal to 2. In ES5, you would use a temporary third variable to solve this problem: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-comment"><span class="hljs-comment">//  temp = a; //   temp  2 a = b; //   a  3 b = temp; //   b  2</span></span></code> </pre><br><p>  This code works, despite the unclear and confusing logic with the inclusion of a third variable. </p><br><p>  With array restructuring in ES6, this is solved in the following way: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    [a, b] = [b, a]; console.log(a); // 3 console.log(b); // 2</span></span></code> </pre><br><p>  This method of variable permutation is much simpler than the previous one. </p><br><p>  Next, we consider the destructurization of arrays and objects in functions. </p><br><h4>  Destructuring arrays and objects when declaring functions </h4><br><p>  Destructuring can be used literally everywhere, even when declaring functions. </p><br><p>  Suppose there is a function that takes an array of values ‚Äã‚Äãand returns an object with three upper values.  Such a function is an analogy of what happens during the destructuring of arrays. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topThree</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scores</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [first, second, third] = scores; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: second, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: third } }</code> </pre><br><p>  An alternative way to write such a function is to destruct the <code>scores</code> when declaring the function.  In this case, you will need to write one less line of code.  It is also necessary to remember that an array will be passed to the function. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topThree</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[first, second, third]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: second, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: third } }</code> </pre><br><p>  If we can combine default parameters and destructuring when declaring functions, what will be the result of the code below? </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayMyName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ firstName = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Zell'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lastName = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Liew'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> } = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(firstName + <span class="hljs-string"><span class="hljs-string">' '</span></span> + lastName); }</code> </pre><br><p>  <b>First</b> , note that a function takes one argument object.  This object is optional and defaults to <code>{}</code> . </p><br><p>  <b>Secondly</b> , an attempt is made to destructurize the variables <code>firstName</code> and <code>lastName</code> from the passed object.  If such properties are found, they will be used. </p><br><p>  <b>As a result,</b> if <code>firstName</code> or <code>lastName</code> not defined ( <code>undefined</code> ) in the object, then they will be assigned the values ‚Äã‚Äãof <code>Zell</code> and <code>Liew</code> , respectively. </p><br><p>  So, this function displays the following results: </p><br><pre> <code class="javascript hljs">sayMyName(); <span class="hljs-comment"><span class="hljs-comment">// Zell Liew sayMyName({firstName: 'Zell'}); // Zell Liew sayMyName({firstName: 'Vincy', lastName: 'Zhang'}); // Vincy Zhang</span></span></code> </pre><br><p>  Next, consider rest and spread. </p><br><h2>  Rest parameter and spread operator </h2><br><p>  Rest parameter and spread operator are similar, since  both are denoted by three dots.  However, they differ in that they perform when used.  For this reason, they are differently named and will be considered separately. </p><br><h3>  Rest parameter </h3><br><p>  In the free interpretation, the rest parameter indicates to take the rest of the data and wrap it in an array.  If in detail, a comma-separated list of arguments is converted into an array. </p><br><p>  Let's get acquainted with the rest parameter in action.  Suppose there is a function <code>add</code> , which summarizes its arguments: </p><br><pre> <code class="javascript hljs">sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 55</span></span></code> </pre><br><p>  In ES5, we depend on the <code>arguments</code> variable every time we deal with a function that accepts an unknown number of variables.  The variable <code>arguments</code> is the array-like <code>Symbol</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/wy/b9/ne/wyb9nefj494x8dtuc3skoyyns0y.png"><br><p>  <code>Arguments</code> - <code>Symbol</code> (not an array) </p><br><p>  One way to calculate this amount of arguments is to convert it to an array using <code>Array.prototype.slice.call(arguments</code> ), and then loop through each element with such array methods as <code>forEach</code> or <code>reduce</code> . </p><br><p>  I'm sure you can implement <code>forEach</code> yourself, so the example below is shown below: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ES5 function sum () { let argsArray = Array.prototype.slice.call(arguments); return argsArray.reduce(function(sum, current) { return sum + current; }, 0) }</span></span></code> </pre><br><p>  In ES6, with the rest parameter, it is possible to translate comma-separated arguments directly into an array: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ES6 const sum = (...args) =&gt; args.reduce((sum, current) =&gt; sum + current, 0); // ES6         function sum (...args) { return args.reduce((sum, current) =&gt; sum + current, 0); }</span></span></code> </pre><br><p>  Rest parameter was previously briefly presented in the section on destructuring.  Then, from the array, the top three values ‚Äã‚Äãwere unstructured: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scores = [<span class="hljs-string"><span class="hljs-string">'98'</span></span>, <span class="hljs-string"><span class="hljs-string">'95'</span></span>, <span class="hljs-string"><span class="hljs-string">'93'</span></span>, <span class="hljs-string"><span class="hljs-string">'90'</span></span>, <span class="hljs-string"><span class="hljs-string">'87'</span></span>, <span class="hljs-string"><span class="hljs-string">'85'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [first, second, third] = scores; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first); <span class="hljs-comment"><span class="hljs-comment">// 98 console.log(second); // 95 console.log(third); // 93</span></span></code> </pre><br><p>  If you need to get the rest of the data, we would refer to the rest parameter. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scores = [<span class="hljs-string"><span class="hljs-string">'98'</span></span>, <span class="hljs-string"><span class="hljs-string">'95'</span></span>, <span class="hljs-string"><span class="hljs-string">'93'</span></span>, <span class="hljs-string"><span class="hljs-string">'90'</span></span>, <span class="hljs-string"><span class="hljs-string">'87'</span></span>, <span class="hljs-string"><span class="hljs-string">'85'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [first, second, third, ...restOfScores] = scores; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(restOfScores); <span class="hljs-comment"><span class="hljs-comment">// [90, 97, 95]</span></span></code> </pre><br><p>  If you are confused by something, remember that the rest parameter translates data into an array and appears in the parameters of the functions and during the destructuring of arrays. </p><br><p>  Next, consider the spread operator. </p><br><h3>  Spread operator </h3><br><p>  Spread operator acts opposite to rest parameter.  In a free interpretation, the operator takes an array and expands it into a comma-separated list of arguments. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = [<span class="hljs-string"><span class="hljs-string">'one'</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>, <span class="hljs-string"><span class="hljs-string">'three'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     console.log(...array); // one two three console.log('one', 'two', 'three'); // one two three</span></span></code> </pre><br><p>  Spread operator is often used to concatenate arrays in an easy-to-read and understandable way. </p><br><p>  Suppose you need to combine the following arrays: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array1 = [<span class="hljs-string"><span class="hljs-string">'one'</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array2 = [<span class="hljs-string"><span class="hljs-string">'three'</span></span>, <span class="hljs-string"><span class="hljs-string">'four'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array3 = [<span class="hljs-string"><span class="hljs-string">'five'</span></span>, <span class="hljs-string"><span class="hljs-string">'six'</span></span>];</code> </pre><br><p>  In ES5, the <code>Array.concat</code> method is used to concatenate arrays.  To combine a set of arrays, a chain is composed as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ES5 let combinedArray = array1.concat(array2).concat(array3); console.log(combinedArray) // ['one', 'two', 'three', 'four', 'five', 'six'];</span></span></code> </pre><br><p>  In ES6 spread, the operator allows combining arrays into a new array in a way that is easier to read: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ES6 let combinedArray = [...array1, ...array2, ...array3]; console.log(combinedArray); // ['one', 'two', 'three', 'four', 'five', 'six']</span></span></code> </pre><br><p>  The spread operator can also be used to remove an item from an array without modifying the array.  This method is common in Redux.  I recommend you watch the <a href="https://egghead.io/lessons/react-redux-avoiding-array-mutations-with-concat-slice-and-spread">video from Dan Abramov</a> to find out how it works. </p><br><h2>  Extended Object Literals </h2><br><p>  Extended object literals in ES6 introduce three improvements.  These include: </p><br><ol><li>  abbreviations for property values </li><li>  abbreviations for methods </li><li>  ability to use calculated property names. </li></ol><br><p>  Consider each of them. </p><br><h3>  Abbreviation for property values </h3><br><p>  Have you noticed that sometimes you write a variable in the property of an object with the same name as the property of the object?  This is shown in the following example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullName = <span class="hljs-string"><span class="hljs-string">'Zell Liew'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Zell = { <span class="hljs-attr"><span class="hljs-attr">fullName</span></span>: fullName }</code> </pre><br><p>  In such situations, would you like to write code shorter? </p><br><p>  ES6 extends objects with abbreviations for property values, which means that you can only write a variable if the variable name matches the property name. </p><br><p>  It looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fullName = <span class="hljs-string"><span class="hljs-string">'Zell Liew'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ES6 const Zell = { fullName } // ,   ES6: const Zell = { fullName: fullName }</span></span></code> </pre><br><h3>  Abbreviations for methods </h3><br><p>  Methods are functions associated with an object property.  Below is an example of a method: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">aMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I'm a method!~~"</span></span>)} }</code> </pre><br><p>  An abbreviation for methods in ES6 is that deleting <code>: function</code> from a method declaration does not break its work: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-comment"><span class="hljs-comment">// ES6 aShorthandMethod (arg1, arg2) {}, // ES5 aLonghandMethod: function (arg1, arg2) {}, }</span></span></code> </pre><br><p>  With this improvement, objects are already getting abbreviations for the method, so I do not recommend using arrow functions when declaring objects, because  this breaks the context of <code>this</code> (go back to the section on arrow functions, if you don‚Äôt remember why this happens). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dontDoThis = { <span class="hljs-comment"><span class="hljs-comment">//    : arrowFunction: () =&gt; {} }</span></span></code> </pre><br><p>  We now turn to the last improvement of objects. </p><br><h3>  Calculated object property names </h3><br><p>  Sometimes there is a need for a dynamic property name when creating objects.  Previously, you would have to create an object, and then add the property as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ES5 const newPropertyName = 'smile'; //    const anObject = { aProperty: 'a value' } //    anObject[newPropertyName] = ':D'; //       anObject['bigger ' + newPropertyName] = 'XD'; //  // { // aProperty: 'a value', // 'bigger smile': 'XD' // smile: ':D', // }</span></span></code> </pre><br><p>  In ES6, there is no need for such a ‚Äúworkaround‚Äù because  It is possible to assign a dynamic property name directly when creating an object.  At the same time, it is important to wrap the dynamic property in square brackets: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newPropertyName = <span class="hljs-string"><span class="hljs-string">'smile'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ES6 const anObject = { aProperty: 'a value', //    [newPropertyName]: ':D', ['bigger ' + newPropertyName]: 'XD', } //  // { // aProperty: 'a value', // 'bigger smile': 'XD' // smile: ':D', // }</span></span></code> </pre><br><p>  This is all about extended object literals.  Next, consider another useful feature: patterned strings. </p><br><h2>  Pattern lines </h2><br><p>  Working with strings in javascript is an extremely difficult process.  We encountered this when creating the announcePlayer function in the section on default parameters.  The code below creates spaces with empty lines, which are combined by addition: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">announcePlayer</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstName, lastName, teamName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(firstName + <span class="hljs-string"><span class="hljs-string">' '</span></span> + lastName + <span class="hljs-string"><span class="hljs-string">', '</span></span> + teamName); }</code> </pre><br><p>  In ES6, this problem is solved by pattern literals (in the specification, they were previously called pattern strings). </p><br><p>  To create a template literal, it is necessary to wrap the lines in reverse apostrophes.  Inside the reverse apostrophes, a special pointer <code>${}</code> is used in which you can write JavaScript code. </p><br><p>  Below is an example of how this looks in action: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstName = <span class="hljs-string"><span class="hljs-string">'Zell'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastName = <span class="hljs-string"><span class="hljs-string">'Liew'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> teamName = <span class="hljs-string"><span class="hljs-string">'unaffiliated'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> theString = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${lastName}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${teamName}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(theString); <span class="hljs-comment"><span class="hljs-comment">// Zell Liew, unaffiliated</span></span></code> </pre><br><p>  Thus, it became possible to make various combinations using template literals, which resembles the use of a template engine. </p><br><p>  The most useful feature of patterned literals is the ability to create multi-line strings.  Below is an example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multi = <span class="hljs-string"><span class="hljs-string">`One upon a time, In a land far far away, there lived a witich, who could change night into day`</span></span>;</code> </pre><br><img src="https://habrastorage.org/webt/v3/ge/_k/v3ge_k550huiwytmxnlqzc9kheg.png"><br><br><p>  Such lines can be used to create HTML elements in JavaScript code (this is not the best way to create HTML elements, but better than creating them one by one separately). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> container = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aListOfItems = <span class="hljs-string"><span class="hljs-string">`&lt;ul&gt; &lt;li&gt;Point number one&lt;/li&gt; &lt;li&gt;Point number two&lt;/li&gt; &lt;li&gt;Point number three&lt;/li&gt; &lt;li&gt;Point number four&lt;/li&gt; &lt;/ul&gt;`</span></span>; container.innerHTML = aListOfItems; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.append(container);</code> </pre><br><p>  Another feature of template literals are tags.  Tags are functions that allow you to manipulate the template literal to replace any string. </p><br><p>  Below is an example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> animal = <span class="hljs-string"><span class="hljs-string">'lamb'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   const tagFunction = () =&gt; { //   } //  tagFunction     const string = tagFunction `Mary had a little ${animal}`;</span></span></code> </pre><br><p>  To be honest, despite the fact that the template tags make an impression, I still have not had a situation to apply them.  In order to study them in more detail, I recommend reading the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">material</a> on MDN. </p><br><h2>  Conclusion </h2><br><p>  These were all the features of ES6 that I use on a regular basis.  It is definitely worth spending a bit of your time and study them in order to understand what others are writing around. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341500/">https://habr.com/ru/post/341500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341486/index.html">What are the most popular programming languages: IT platform statistics</a></li>
<li><a href="../341490/index.html">Introducing free ordering and extended subscription for freelancers</a></li>
<li><a href="../341492/index.html">Network visibility and Ixia solutions</a></li>
<li><a href="../341494/index.html">Intuitive algorithm development</a></li>
<li><a href="../341496/index.html">Flexible access control at the record object level</a></li>
<li><a href="../341502/index.html">We write your mapper for .NET Standard 2.0</a></li>
<li><a href="../341506/index.html">Reed-Solomon codes. Part 2 - Galois Field Arithmetic</a></li>
<li><a href="../341508/index.html">How do we make a map for those who make a map</a></li>
<li><a href="../341510/index.html">Taxes on the sale of Google applications and ads</a></li>
<li><a href="../341512/index.html">FrontFest.Kvartirniki - talking about the future of JavaScript and the fate of the front-end developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>