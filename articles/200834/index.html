<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The problem of monkeys and infinity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone knows that if you plant a monkey for a typewriter and make it always accidentally knock on the keys, then sooner or later, it will type ‚ÄúWar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The problem of monkeys and infinity</h1><div class="post__text post__text-html js-mediator-article"><p>  Everyone knows that if you plant a monkey for a typewriter and make it always accidentally knock on the keys, then sooner or later, it will type ‚ÄúWar and Peace‚Äù, a collection of Pythagorean works and even the article you are reading now. </p><br><img src="https://habrastorage.org/files/e15/7d9/8f5/e157d98f57474214886b657bdfa2a17f.jpg"><br><p>  A terrific fact, but it is even more interesting to try to understand how much time it will take to type a particular text.  In order not to drive an extra parameter - the speed of a monkey set - we will look for the answer to the question: how many keystrokes will it need on average.  Is it obvious to you that the string ‚Äúabc‚Äù is much easier to type than ‚Äúaaa‚Äù?  This post is dedicated to solving this problem.  Along the way, the prefix function and its properties are explained. </p><a name="habracut"></a><br><p>  It is clear that the time spent by the monkey on typing a specific text is a certain random variable.  Therefore, it is logical to ask about her expectation. </p><br><p></p><h2>  Formal statement of the problem </h2><br>  A string s is given, consisting of uppercase Latin letters (‚Äûa‚Äú - ‚Äûz‚Äú).  Need to find a mat.  waiting for the number of random keystrokes before the entire string s is typed, if all characters are typed equiprobably (with a probability of <em>1/26</em> ). <p></p><br><div class="spoiler">  <b class="spoiler_title">Decision code</b> <div class="spoiler_text"><p>  To understand why this works and what the Pi () function is, you need to read the whole article :(. </p><br><pre><code class="hljs pgsql">string s; //,    <span class="hljs-type"><span class="hljs-type">int</span></span> n = s.length(); vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; p = Pi(s); vector&lt;long <span class="hljs-type"><span class="hljs-type">double</span></span>&gt; pow(n+<span class="hljs-number"><span class="hljs-number">1</span></span>); pow[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { pow[i] = pow[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]*<span class="hljs-number"><span class="hljs-number">26</span></span>; } long <span class="hljs-type"><span class="hljs-type">double</span></span> ans = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = n; i&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; i = p[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]) { ans += pow[i]; } cout &lt;&lt; ans;</code> </pre> </div></div><br><p></p><h2>  Prefix function </h2><br>  This function will help us to solve the problem.  The prefix function was introduced by D. Knuth and M. Pratt (and in parallel with D. Morris) for their famous substring search algorithm in the string ( <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">ILC</a> algorithm).  The prefix function for string <em>s</em> returns the length of the longest proper prefix of the string, which is also its suffix. <p></p><br><div class="spoiler">  <b class="spoiler_title">Prefixes and suffixes</b> <div class="spoiler_text"><p>  The prefix is ‚Äã‚Äãjust the beginning of the line, if you drop some characters from the end.  So the string "aba" has 4 prefixes: "" (empty string), "a", "ab" and "aba".  The suffix is ‚Äã‚Äãthe same, but the characters are removed from the beginning.  However, some suffixes and prefixes may coincide.  For the string "aba" there are 3 such prefix-suffixes: "", "a" and "aba" (the fourth suffix "ba" does not match the prefix "ab").  The suffix or prefix is ‚Äã‚Äãcalled <i>proper</i> if it is shorter than the entire string. </p></div></div><br><p>  Formally speaking: <img src="https://tex.s2cms.ru/svg/%5Cpi(s)%20%3D%20max%5C%7B%20k%20%5C%2C%7C%5C%2C%200%5Cle%20k%20%3C%20%7Cs%7C%2C%5C%2C%20pref_k(s)%20%3D%20suf_k(s)%5C%7D%20" alt="\ pi (s) = max \ {k \, |  \, 0 \ le k &amp; lt;  |  s |, \, pref_k (s) = suf_k (s) \}"></p><br><p>  Where <em>pref <sub>k</sub> (s)</em> is a prefix of length <em>k of</em> string <em>s</em> , and <em>suf <sub>k</sub> (s)</em> is a suffix of length <em>k of</em> string <em>s</em> . </p><br><p>  As in the KMP algorithm, and in other applications, it is much more useful to consider the prefix function for all prefixes of a given string at once.  Yes, it sounds scary - for each prefix you need to find the largest of your own prefix, which coincides with the prefix suffix.  But in fact, everything is simple: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cpi_s(k)%20%3D%20%5Cpi(pref_k(s))%2C%5C%2C%201%5Cle%20k%20%5Cle%20%7Cs%7C" alt="\ pi_s (k) = \ pi (pref_k (s)), \, 1 \ le k \ le |  s |"></div><p></p><br><p>  Such an extended prefix function is useful primarily because it is easier to calculate than just <img src="https://tex.s2cms.ru/svg/%5Cpi(s)" alt="\ pi (s)">  .  The following values ‚Äã‚Äãare shown. <img src="https://tex.s2cms.ru/svg/%5Cpi_s(k)" alt="\ pi_s (k)">  for <em>s =</em> "ababac". </p><br><pre>  k: 1 2 3 4 5 6
    s: ababac
 P (i): 0 0 1 2 3 0 </pre><br><p></p><h5>  Calculation function prefix </h5><p></p><br><div class="spoiler">  <b class="spoiler_title">Calculation Code</b> <div class="spoiler_text"><pre> <code class="hljs matlab">vector&lt;int&gt; Pi(string s) { int n = s.<span class="hljs-built_in"><span class="hljs-built_in">length</span></span>(); vector&lt;int&gt; p(n); p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; n; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = p[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; s[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] != s[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]) { <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = p[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] == s[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]) <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++; p[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> </div></div><br><p>  Fast, beyond <em>O (N)</em> , the calculation of the function prefix is ‚Äã‚Äãbased on two simple observations. </p><br><p>  (1) To get the prefix suffix for position <em>k,</em> you need to take some kind of prefix suffix for position <em>k-1</em> and append the character at position <em>k</em> to the end of it. </p><br><p>  (2) All prefixes-suffixes of string <em>s of</em> length <em>n</em> can be obtained as <img src="https://tex.s2cms.ru/svg/%5Cpi_s(n)%2C%5C%2C%20%5Cpi_s(%5Cpi_s(n))%2C%5C%2C%20%5Cpi_s(%5Cpi_s(%5Cpi_s(n)))" alt="\ pi_s (n), \, \ pi_s (\ pi_s (n)), \, \ pi_s (\ pi_s (\ pi_s (n)))">  and so on, until the next value is equal to 0. This property can be checked on the string "abacaba".  Here <img src="https://tex.s2cms.ru/svg/%5Cpi_s(7)%3D3%2C%5C%2C%20%5Cpi_s(3)%3D1%2C%5C%2C%20%5Cpi_s(1)%3D0" alt="\ pi_s (7) = 3, \, \ pi_s (3) = 1, \, \ pi_s (1) = 0">  that matches all suffix prefixes ("aba", "a" and "").  This is because the maximum prefix suffix has a length <img src="https://tex.s2cms.ru/svg/%5Cpi_s(n)" alt="\ pi_s (n)">  .  The next in length prefix suffix will be shorter.  But since the first prefix suffix occurs both at the beginning and at the end of the string <em>s</em> , the next prefix suffix will be the longest prefix suffix in the first prefix suffix. </p><br><p>  Therefore, to build the function prefix for position <em>i, it is</em> sufficient to iterate from the function prefix value in the previous position until the extension of the suffix with the new character is also a prefix (for this you need to check only one new character).  Such an algorithm is executed in linear time, because the value of the function prefix increases by a maximum of <em>1</em> each time, so it cannot be reduced more than <em>n</em> times, which means that the nested loop will be executed in total not more than <em>n</em> times. </p><br><p></p><h2>  KMP Machine </h2><br>  The following mathematical object, which is necessary in solving the set task, is a finite state machine that accepts lines ending in a given string <em>s</em> .  This machine is used in another, less well-known modification of the Knut-Moriss-Pratt algorithm.  In this version of the algorithm, a finite state machine is constructed that accepts all strings that end with a given string (pattern).  Then the string is passed to the machine.  Every time the machine accepts the text transmitted to it, the next occurrence of the pattern is found.  It is this machine that will help us solve the monkey typing machine problem. <p></p><br><div class="spoiler">  <b class="spoiler_title">What is a finite state machine?</b> <div class="spoiler_text"><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">A finite state machine</a> is a mathematical object that is easiest to imagine as some kind of box that has some kind of internal state.  Initially, the box is in the <i>initial state</i> .  You can enter lines in the box, one character at a time.  After each character, the box changes its state, depending on the current state and the character entered.  Also, some states are good (the mathematical term is <em>final states</em> ).  It is said that the automaton <em>accepts the line</em> , if after feeding this line with a symbol-by-character, the automaton is in good condition. </p><br><p>  To determine the QA, you need to determine the initial state, good states and the transition function - for each state and symbol you need to specify a new state to which the machine will go.  It is convenient to draw an automaton as a full directed graph, where vertices are states, and exactly one character is written on each edge.  From each vertex there must be exactly one edge with each symbol.  Then, to process a string, you just need to go over the edges with the characters from this string.  If the path ended in the final state, then the machine accepts such a string. </p></div></div><br><p>  To build this automaton, we will use the prefix function already known to us. <br>  The automaton will have <em>n + 1</em> state, numbered from <em>0</em> to <em>n</em> .  The state <em>k</em> corresponds to the coincidence of the last <em>k</em> characters typed with the prefix of the pattern of length <em>k</em> (If we search for the string "abac", then we are interested in the current text just at the end: "abac", "aba", "ab", "a" or what something else. This information is enough to get the same after writing one character).  State <em>0</em> will be initial and state <em>n will</em> be final.  Sometimes there can be confusion: for example, for the terms ‚Äúababccc‚Äù with the zzzabab line fed to the automat, you can choose both state 2 and 4. But in order not to lose the necessary information about the typed text, we will always choose the greatest state. </p><br><div class="spoiler">  <b class="spoiler_title">example of KMP state machine</b> <div class="spoiler_text"><p>  Here is the automaton for the string "ababac".  For example, the alphabet consists only of the characters 'a' - 'c'.  Parallel ribs are combined for clarity.  In fact, only one symbol corresponds to each edge.  The initial state is <em>0</em> , the final state is <em>6</em> . <br><br><img src="https://habrastorage.org/files/cf0/88c/ac4/cf088cac4e024d888c658a588a1e707b.png"><br>  It is easy to make sure that any path from state <em>0</em> to state <em>6</em> , no matter how difficult it is, necessarily ends with the string "ababac".  Conversely, any such path will necessarily end in state <em>6</em> . </p></div></div><br><div class="spoiler">  <b class="spoiler_title">The build code of the state machine</b> <div class="spoiler_text"><pre> <code class="hljs markdown">string s; // . int n = s.length(); vector<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">vector</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &gt; nxt(n+1, vector<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(256)); //   nxt[<span class="hljs-string"><span class="hljs-string"></span></span>][<span class="hljs-symbol"><span class="hljs-symbol"></span></span>] ==   vector<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> p = Pi(s); //  . .   nxt[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">s[0</span></span>]] = 1; //    0   0. for (int i = 1; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">256</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag">++) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">nxt</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">nxt[p[i-1]][c];</span></span></span></span><span class="xml"><span class="hljs-tag"> //</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">p</span></span></span></span><span class="xml"><span class="hljs-tag">[]   ,   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-1</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">nxt</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">s</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">]] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">i+1;</span></span></span></span><span class="xml"><span class="hljs-tag"> }</span></span></span></span></code> </pre> </div></div><br><p>  Notice how the transitions are constructed.  To calculate transitions from state <em>i,</em> we consider 2 options.  If the new symbol is s [i], then the transition will be to the state <em>i + 1</em> .  Everything is obvious here: if there was a match in <em>i</em> characters, then by adding the next character from string <em>s,</em> we will increase the length of the match by <em>1</em> .  If the symbol does not match, then we simply copy the transitions from the state <img src="https://tex.s2cms.ru/svg/%5Cpi_s(i)" alt="\ pi_s (i)">  .  Why?  The transition in this case will be exactly in the state with the number <em>‚â§i</em> .  So after the transition, we will forget some of the information about the typed text.  You can do this before proceeding.  The very minimum that we can erase is to pretend that in reality the state now is not <em>i</em> , but <img src="https://tex.s2cms.ru/svg/%5Cpi_s(i)" alt="\ pi_s (i)">  .  It is like in the example above, it was possible to consider that the text ends with ‚Äúabab‚Äù or ‚Äúab‚Äù.  If there are no transitions from abab, you can use transitions from ab. </p><br><p></p><h2>  Decision </h2><br>  Now we are ready to solve the task. <br>  Construct for the string s an automaton KMP.  Since all characters are typed by a monkey randomly, the characters themselves are not important to us, but only the edges in the transition graph.  The problem can be reformulated as follows: find mat.  waiting for the number of transitions in a random walk from state <em>0</em> until state <em>n is</em> reached. <p></p><br><p>  It is logical in this formulation to introduce variables: <em>E <sub>k</sub> , 0‚â§k‚â§n</em> is the expectation of the number of transitions to reach state <em>n</em> .  <em>E <sub>0</sub></em> will be the answer to the original problem.  Let <em>Z</em> be the set of valid characters (the alphabet).  You can create a system of equations: </p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(1)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20E_n%20%3D%200%20" alt="E_n = 0"></div><p></p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(2)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20E_k%20%3D%201%20%2B%20%5Cfrac%7B1%7D%7B%7CZ%7C%7D%5Csum_%7Bc%20%5Cin%20Z%7D%7BE_%7Bnxt%5Bk%5D%5Bc%5D%7D%7D%2C%20k%3D0..n-1%20" alt="E_k = 1 + \ frac {1} {|  Z |} \ sum_ {c \ in Z} {E_ {nxt [k] [c]}}, k = 0..n-1"></div><p></p><br><p>  Equation (1) means that when reaching state <em>n,</em> random walk stops. <br>  For any other state, some kind of transition will be made, therefore the term <em>1 is</em> present in equation (2).  The second term is the sum of all possible variants multiplied by the probability of these variants.  All probabilities are the same - therefore it is taken out for the sum sign. </p><br><p>  There is already a solution to the problem in O (n ^ 3): the constructed system of linear equations can be solved by the Gauss method.  But if you look at this system a little and remember that there is a prefix function, that is, the solution is much simpler and faster. </p><br><p>  Recall the construction of a finite automaton.  (For simplicity, instead of <img src="https://tex.s2cms.ru/svg/%5Cpi_s" alt="\ pi_s">  i will use just <img src="https://tex.s2cms.ru/svg/%5Cpi" alt="\ pi">  ).  Transitions from state <em>k</em> almost completely coincide with transitions from state <img src="https://tex.s2cms.ru/svg/%5Cpi(k)" alt="\ pi (k)">  .  The difference in the transition only by the symbol s [k-1].  Therefore, the right sides of equations (2) for the states <em>k</em> and <img src="https://tex.s2cms.ru/svg/%5Cpi(k)" alt="\ pi (k)">  differ only in one term.  In the equation for <img src="https://tex.s2cms.ru/svg/%5Cpi(k)" alt="\ pi (k)">  worth <img src="https://tex.s2cms.ru/svg/E_%7Bnxt%5B%5Cpi(k)%5D%5Bs%5Bk-1%5D%5D%7D%20" alt="E_ {nxt [\ pi (k)] [s [k-1]]}">  instead <img src="https://tex.s2cms.ru/svg/E_%7Bnxt%5Bk%5D%5Bs%5Bk-1%5D%5D%7D" alt="E_ {nxt [k] [s [k-1]]}">  in the equation for <em>k</em> .  Moreover, <em>nxt [k] [s [k-1]] = k + 1</em> .  Using this fact, you can rewrite equations (2): </p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(3)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_k%20%3D%20E_%7B%5Cpi(k)%7D%20%2B%20%5Cfrac%7B1%7D%7B%7CZ%7C%7D(E_%7Bk%2B1%7D-E_%7Bnxt%5B%5Cpi(k)%5D%5Bs%5Bk-1%5D%5D%7D)%20" alt="E_k = E _ {\ pi (k)} + \ frac {1} {| Z |} (E_ {k + 1} -E_ {nxt [\ pi (k)] [s [k-1]]})"></div><p></p><br><p>  Now we need to make another observation.  Turns </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/nxt%5B%5Cpi(k)%5Bs%5Bk-1%5D%5D%20%3D%20%5Cpi(k%2B1)" alt="nxt [\ pi (k) [s [k-1]] = \ pi (k + 1)"></div><p></p><br><p>  Those.  to find the prefix function for a certain state, one must take the prefix function from the previous state and go from there to the symbol leading to the next state. <br>  Indeed, if we consider the state <img src="https://tex.s2cms.ru/svg/%5Cpi(k)" alt="\ pi (k)">  , then it corresponds to a string ending in the character s [k-1].  So there is a transition to this symbol.  Consider the largest state from which such a transition exists, but which has the number <em>&lt;k</em> .  If, after moving on the symbol s [k-1], we got some kind of suffix <img src="https://tex.s2cms.ru/svg/pref_k(s)" alt="pref_k (s)">  then before the transition it was a suffix <img src="https://tex.s2cms.ru/svg/pref_%7Bk-1%7D(s)" alt="pref_ {k-1} (s)">  .  Since this was the rightmost such state, it corresponds to the maximum prefix-suffix <img src="https://tex.s2cms.ru/svg/pref_%7Bk-1%7D(s)" alt="pref_ {k-1} (s)">  which means it has a number <img src="https://tex.s2cms.ru/svg/%5Cpi(k-1)" alt="\ pi (k-1)">  .  So we got this amazing and useful fact. </p><br><p>  Then (3) is converted to: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_k%20%3D%20E_%7B%5Cpi(k)%7D%20%2B%20%5Cfrac%7B1%7D%7B%7CZ%7C%7D(E_%7Bk%2B1%7D-E_%7B%5Cpi(k%2B1)%7D)%20" alt="E_k = E _ {\ pi (k)} + \ frac {1} {| Z |} (E_ {k + 1} -E _ {\ pi (k + 1)})"></div><p></p><br><p>  Or in another way: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%7CZ%7C%20(E_k%20-%20E_%7B%5Cpi(k)%7D)%20%3D(E_%7Bk%2B1%7D-E_%7B%5Cpi(k%2B1)%7D)%20" alt="| Z | (E_k - E _ {\ pi (k)}) = (E_ {k + 1} -E _ {\ pi (k + 1)})"></div><p></p><br><p>  On both sides of the equals sign there are negative numbers (it is logical that the larger the <em>k</em> , the smaller <em>E <sub>k</sub></em> ).  Multiply both sides by <em>-1</em> . </p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(4)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%7CZ%7C%20(E_%7B%5Cpi(k)%7D-E_k)%20%3DE_%7B%5Cpi(k%2B1)%7D-E_%7Bk%2B1%7D%20" alt="| Z | (E _ {\ pi (k)} - E_k) = E _ {\ pi (k + 1)} - E_ {k + 1}"></div><p></p><br><p>  But (4) is valid only for <em>k&gt; 0</em> .  For <em>k = 0,</em> one can explicitly write out equation (2), because only one of <em>| Z |</em>  transitions leads to state <em>1</em> , and all the others return to state <em>0</em> : </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_0%20%3D%201%20%2B%20%5Cfrac%7B1%7D%7B%7CZ%7C%7DE_1%20%2B%20%5Cfrac%7B%7CZ%7C-1%7D%7B%7CZ%7C%7DE_0%20" alt="E_0 = 1 + \ frac {1} {| Z |} E_1 + \ frac {| Z | -1} {| Z |} E_0"></div><p></p><br><p>  Now we collect all the variables on the left, multiply the equation by <em>| Z |</em>  and replace <img src="https://tex.s2cms.ru/svg/0%3D%5Cpi(1)" alt="0 = \ pi (1)">  (the prefix function for one character is always 0, because one character does not have non-empty proper prefixes): </p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(5)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_%7B%5Cpi(1)%7D%20-%20E_1%20%20%3D%20%7CZ%7C" alt="E _ {\ pi (1)} - E_1 = | Z |"></div><p></p><br><p>  I allow myself to repeat equations (1), (4) and (5), since they constitute a system that we will now solve analytically: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_%7B%5Cpi(1)%7D%20-%20E_1%20%3D%20%7CZ%7C%20%5C%5C%0A%7CZ%7C%20(E_%7B%5Cpi(k)%7D-E_k)%20%3DE_%7B%5Cpi(k%2B1)%7D-E_%7Bk%2B1%7D%2C%5C%2C%20k%3D1..n-1%20%5C%5C%0A%20E_n%20%3D%200%20" alt="E _ {\ pi (1)} - E_1 = | Z | \\ Z | (E _ {\ pi (k)} - E_k) = E _ {\ pi (k + 1)} - E_ {k + 1}, \, k = 1..n-1 \\ E_n = 0"></div><p></p><br><p>  Substituting the first equation into the left side of the second with <em>k = 1</em> , then with <em>k = 2</em> , etc.  we get: </p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(6)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20E_%7B%5Cpi(k)%7D%20-%20E_k%20%3D%20%7CZ%7C%5Ek%20%2C%5C%2C%20k%3D1..n%20" alt="E _ {\ pi (k)} - E_k = | Z | ^ k, \, k = 1..n"></div><p></p><br><p>  Now the solution is almost ready: now consider (6) with <em>k = n</em> and recall that <img src="https://tex.s2cms.ru/svg/E_n%20%3D%200" alt="E_n = 0">  we get: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_%7B%5Cpi(n)%7D%20%3D%20%7CZ%7C%5En" alt="E _ {\ pi (n)} = | Z | ^ n"></div><p></p><br><p>  Substitute this value in (6) with <img src="https://tex.s2cms.ru/svg/k%20%3D%20%5Cpi(n)" alt="k = \ pi (n)">  - we get: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_%7B%5Cpi(%5Cpi(n))%7D%20%3D%20%7CZ%7C%5En%20%2B%20%7CZ%7C%5E%7B%5Cpi(n)%7D" alt="E _ {\ pi (\ pi (n))} = | Z | ^ n + | Z | ^ {\ pi (n)}"></div><p></p><br><p>  Similarly, we get: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/E_%7B%5Cpi(%5Cpi(%5Cpi(n)))%7D%20%3D%20%7CZ%7C%5En%20%2B%20%7CZ%7C%5E%7B%5Cpi(n)%7D%20%2B%20%7CZ%7C%5E%7B%5Cpi(%5Cpi(n))%7D" alt="E _ {\ pi (\ pi (\ pi (n)))} = | Z | ^ n + | Z | ^ {\ pi (n)} + | Z | ^ {\ pi (\ pi (n))}"></div><p></p><br><p>  And so you can continue as long as we do not get the expression for <img src="https://tex.s2cms.ru/svg/E_0" alt="E_0">  which, by the way, is the answer to the problem.  Denote <img src="https://tex.s2cms.ru/svg/%5Cpi%5Ek" alt="\ pi ^ k">  function applied <em>k</em> times in a row <img src="https://tex.s2cms.ru/svg/%5Cpi" alt="\ pi">  , then: </p><br><p><img align="right" src="https://tex.s2cms.ru/svg/(*)"></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20E_0%20%3D%20%5Csum_%7Bk%3A%5Cpi%5Ek(n)%20%3E%200%7D%7CZ%7C%5Ek%20" alt="E_0 = \ sum_ {k: \ pi ^ k (n) &amp; gt; 0} | Z | ^ k"></div><p></p><br><p>  Thus, we have obtained the solution of the problem in O (n): construct the prefix function to the string <em>s</em> and iterate over it starting from <em>n</em> until we reach <em>0</em> , adding the powers of <em>| Z |</em>  equal to the current prefix length.  This is the very solution given at the beginning of the article. </p><br><p>  Looking at (*) it becomes clear why the string ‚Äúaaa‚Äù is harder to type than ‚Äúabc‚Äù, because in aaa there is only the third iteration <img src="https://tex.s2cms.ru/svg/%5Cpi" alt="\ pi">  is zero, and the second line has no non-empty prefixes equal to the suffixes and <img src="https://tex.s2cms.ru/svg/%5Cpi" alt="\ pi">  immediately gives zero. </p><br><p></p><h2>  Remarks </h2><br>  The prefix function and the KMP automaton are very useful tools for working with strings.  If dear readers have an interest, then I can make out solutions to other problems.  Any typos please report in a personal, thank you. <p></p><br><p></p><h4>  Update: </h4><p></p><br><p>  Firstly, thanks a <a href="https://habrahabr.ru/users/parpalak/" class="user_link">lot</a> to <a href="https://habrahabr.ru/users/parpalak/" class="user_link">parpalak</a> for its great service for preparing articles with formulas on Habr√© ( <a href="https://habrahabr.ru/post/264709/">https://habrahabr.ru/post/264709/</a> ).  Without him, this article would not exist.  I am very ashamed that I forgot to write about it right away. </p><br><p>  Secondly, very many commentators are confused by their intuition.  In teorvere this often happens.  Yes, the probabilities of typing texts of the same length from the first time are the same.  Yes, the frequency of occurrence of the same length texts is the same in an infinite random text.  All this is true, but it does not follow from these facts that the expectation of the number of characters before the <b>first</b> occurrence of the lines will be the same.  And vice versa, from the fact that the string ‚Äúhh‚Äù in the endless text will occur later than the string ‚Äúchk‚Äù it does not follow that in the casino it is necessary to put red after the black. </p><br><p>  Let's calculate the expectation on the fingers until the two lines ‚Äúhh‚Äù and ‚Äúchk‚Äù are drawn.  The expectation is the sum over all <em>i</em> : the probability of typing a string for <em>i</em> characters <b>for the first time</b> multiplied by <em>i</em> .  The phrase in bold means that, firstly, the last characters typed coincide with the required ones (this probability is the same for both lines), and, secondly, the required line is <b>not found</b> among the first <em>i-2</em> characters.  This second multiplier is different for different lines.  The probability of not finding a line is simply the number of all texts in which this line is not divided by the number of all texts of that length. </p><br><p>  Now important: lines of length <em>k</em> not containing the string ‚Äúchk‚Äù of all <em>k + 1</em> : ‚Äúk ... k‚Äù, ‚Äúk‚Ä¶ kch‚Äù, ‚Äúk‚Ä¶ kchch‚Äù, ‚Äúk‚Ä¶ kkkchch‚Äù, ..., ‚Äúkch ... h‚Äù and ‚Äú h ... h. "  This is because after the ‚Äúh‚Äù character there can only be ‚Äúh‚Äù. </p><br><p>  The sink of the length <em>k</em> not containing the string ‚Äúhh‚Äù will be much larger, namely F <sub>k + 1</sub> - the Fibonacci number under the number <em>k + 1</em> (these are the numbers 1, 1, 2, 3, 5, 8, 13, ... - each next is the sum of the previous two).  For example, for <em>k = 2</em> 3 lines will be "kk", "kch", "chk".  These numbers are growing very quickly and therefore all the terms for the checkmate for the string "QC" will be greater, since there is more likelihood. </p><br><p>  Please note, all due to the fact that the likelihood to print text for the first time in a few clicks depends on the probability <b>not to print the</b> text even at the beginning and middle of the text.  This probability is directly proportional to the number of rows that do not contain the specified string, but it is different for different patterns. </p><br><p>  Once again, it was not I who invented it, it is a well-known fact, although it is extremely unintuitive.  Look, for example, at this article (look for a task about Alice and Bob there - paragraph 4): <a href="https://habrahabr.ru/post/279337/">https://habrahabr.ru/post/279337/</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/200834/">https://habr.com/ru/post/200834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200822/index.html">New look at old games</a></li>
<li><a href="../200824/index.html">IconBIT THOR ZX Review: Lone 9-inch Tablet</a></li>
<li><a href="../200826/index.html">How our mirror works</a></li>
<li><a href="../200828/index.html">Transferring OpenGL ES apps to the Windows Store</a></li>
<li><a href="../200830/index.html">20 years of technical support: how the world has changed around us</a></li>
<li><a href="../200836/index.html">Weekend succeeded. Yota.ru forgot to extend</a></li>
<li><a href="../200838/index.html">VKontakte has opened access to the exchange of advertising in communities</a></li>
<li><a href="../200840/index.html">Novec 1230 dry water to protect server and not only</a></li>
<li><a href="../200842/index.html">Five traits of successful innovators</a></li>
<li><a href="../200844/index.html">Google Helpouts - paid video consultation with experts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>