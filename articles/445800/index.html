<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monads in 15 minutes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 At the conference YOW! 2013 is one of the developers of the Haskell language, prof. Philip Wadler showed how monads allow pure function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monads in 15 minutes</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  At the conference <a href="http://yowconference.com.au/">YOW!</a>  <a href="http://yowconference.com.au/">2013 is</a> one of the developers of the Haskell language, <a href="http://homepages.inf.ed.ac.uk/wadler/">prof.</a>  <a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> showed how monads allow pure functional languages ‚Äã‚Äãto perform essentially imperative operations, such as I / O and exception handling.  It is not surprising that the interest of the audience in this topic was generated by the explosive growth of publications about monads on the Internet.  Unfortunately, most of these publications use examples written in functional languages, implying that newcomers to functional programming want to learn about monads.  But monads are not specific to Haskell or functional languages, and may well be illustrated with examples in imperative programming languages.  This is the purpose of this manual. <br><br>  How does this guide differ from the rest?  We will try to ‚Äúopen‚Äù the monads in no more than 15 minutes using only intuition and a few basic examples of Python code.  We therefore will not begin to theorize and delve into philosophy, talking about <a href="http://blog.plover.com/prog/burritos.html">burritos</a> , <a href="http://www.loria.fr/~kow/monads/index.html">space suits</a> , <a href="http://www.infoq.com/presentations/Why-is-a-Monad-Like-a-Writing-Desk">desks,</a> and endofunctors. <br><a name="habracut"></a><br><h2>  Motivational examples </h2><br>  We consider three problems related to the composition of functions.  We will solve them in two ways: the usual imperative and with the help of monads.  Then we compare the different approaches. <br><br><h3>  1. Logging </h3><br>  Suppose we have three unary functions: <code>f1</code> , <code>f2</code> and <code>f3</code> , which accept a number and return it increased by 1, 2, and 3, respectively.  Also, each function generates a message that represents a report on the operation performed. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + <span class="hljs-number"><span class="hljs-number">1</span></span>, str(x) + <span class="hljs-string"><span class="hljs-string">"+1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span>, str(x) + <span class="hljs-string"><span class="hljs-string">"+2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x + <span class="hljs-number"><span class="hljs-number">3</span></span>, str(x) + <span class="hljs-string"><span class="hljs-string">"+3"</span></span>)</code> </pre> <br>  We would like to chain them to handle the parameter <code>x</code> , in other words, we would like to calculate <code>x+1+2+3</code> .  In addition, we need to get a human-readable explanation of what each function has done. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can achieve the desired result in the following way: <br><pre> <code class="python hljs">log = <span class="hljs-string"><span class="hljs-string">"Ops:"</span></span> res, log1 = f1(x) log += log1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> res, log2 = f2(res) log += log2 + <span class="hljs-string"><span class="hljs-string">";"</span></span> res, log3 = f3(res) log += log3 + <span class="hljs-string"><span class="hljs-string">";"</span></span> print(res, log)</code> </pre> <br>  This solution is not ideal, since it consists of a large number of uniform glue code.  If we want to add a new function to our chain, we will have to repeat this binding code.  In addition, manipulations with the variables <code>res</code> and <code>log</code> affect the readability of the code, making it difficult to follow the main logic of the program. <br><br>  Ideally, the program should look like a simple chain of functions, like <code>f3(f2(f1(x)))</code> .  Unfortunately, the data types returned by <code>f1</code> and <code>f2</code> do not correspond to the types of parameters <code>f2</code> and <code>f3</code> .  But we can add new functions to the chain: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x, <span class="hljs-string"><span class="hljs-string">"Ops:"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, f)</span></span></span><span class="hljs-function">:</span></span> res = f(t[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (res[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>] + res[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">";"</span></span>)</code> </pre> <br>  Now we can solve the problem as follows: <br><pre> <code class="python hljs">print(bind(bind(bind(unit(x), f1), f2), f3))</code> </pre> <br>  The following diagram shows the computational process that occurs when <code>x=0</code> .  Here, <code>v1</code> , <code>v2</code> and <code>v3</code> are the values ‚Äã‚Äãderived from the calls <code>unit</code> and <code>bind</code> . <br><br><img src="https://habrastorage.org/webt/dy/ta/f0/dytaf0ku8j3y7ctrcrhjlqbs2ck.png"><br><br>  The <code>unit</code> function converts the input parameter <code>x</code> to a tuple of number and string.  The <code>bind</code> function calls the function passed to it as a parameter and accumulates the result in the intermediate variable <code>t</code> . <br><br>  We were able to avoid repetition of the linking code by placing it in the <code>bind</code> function.  Now, if we have a function <code>f4</code> , we simply include it in the chain: <br><pre> <code class="python hljs">bind(f4, bind(f3, ... ))</code> </pre> <br>  And we will not need to make any other changes. <br><br><h3>  2. List of intermediate values </h3><br>  We will also begin this example with simple unary functions. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  As in the previous example, we need to assemble these functions to calculate <code>x+1+2+3</code> .  We also need to obtain a list of all values ‚Äã‚Äãobtained as a result of the operation of our functions, that is, <code>x</code> , <code>x+1</code> , <code>x+1+2</code> and <code>x+1+2+3</code> . <br><br>  Unlike the previous example, our functions are composable, that is, the types of their input parameters coincide with the type of result.  Therefore, a simple chain <code>f3(f2(f1(x)))</code> returns the final result.  But in this case, we will lose intermediate values. <br><br>  Solve the problem "in the forehead": <br><pre> <code class="python hljs">lst = [x] res = f1(x) lst.append(res) res = f2(res) lst.append(res) res = f3(res) lst.append(res) print(res, lst)</code> </pre> <br>  Unfortunately, this solution also contains a lot of glue code.  And if we decide to add <code>f4</code> , we again have to repeat this code to get the correct list of intermediate values. <br><br>  Therefore, we add two additional functions, as in the previous example: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x, [x]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, f)</span></span></span><span class="hljs-function">:</span></span> res = f(t[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (res, t[<span class="hljs-number"><span class="hljs-number">1</span></span>] + [res])</code> </pre> <br>  Now we will rewrite the program as a chain of calls: <br><pre> <code class="python hljs">print(bind(bind(bind(unit(x), f1), f2), f3))</code> </pre> <br>  The following diagram shows the computational process that occurs when <code>x=0</code> .  Again, <code>v1</code> , <code>v2</code> and <code>v3</code> denote the values ‚Äã‚Äãresulting from the calls <code>unit</code> and <code>bind</code> . <br><br><img src="https://habrastorage.org/webt/qh/uw/7y/qhuw7yx5fo1yjlcbce34kuhejj4.png"><br><br><h3>  3. Empty values </h3><br>  Let's try to give a more interesting example, this time with classes and objects.  Suppose we have an <code>Employee</code> class with two methods: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Employee</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_boss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Return the employee's boss def get_wage(self): # Compute the wage</span></span></code> </pre> <br>  Each object of class <code>Employee</code> has a manager (another object of class <code>Employee</code> ) and a salary, which can be accessed through appropriate methods.  Both methods can also return <code>None</code> (the employee has no supervisor, salary is unknown). <br><br>  In this example, we will create a program that shows the salary of the head of this employee.  If the manager is not found, or his salary cannot be determined, the program will return <code>None</code> . <br><br>  Ideally, we need to write something like <br><pre> <code class="python hljs">print(john.get_boss().get_wage())</code> </pre> <br>  But in that case, if any of the methods returns <code>None</code> , our program will end with an error. <br><br>  An obvious way to handle this situation might look like this: <br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> john <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> john.get_boss() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> john.get_boss().get_wage() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: result = john.get_boss().get_wage() print(result)</code> </pre> <br>  In this case, we allow unnecessary calls to <code>get_boss</code> and <code>get_wage</code> .  If these methods are hard enough (for example, accessing a database), our solution is no good.  Therefore, change it: <br><pre> <code class="python hljs">result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> john <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: boss = john.get_boss() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> boss <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: wage = boss.get_wage() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wage <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: result = wage print(result)</code> </pre> <br>  This code is optimal in terms of calculations, but is hard to read due to the three nested <code>if</code> .  Therefore, we will try to use the same trick as in the previous examples.  We define two functions: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, f)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> f(e)</code> </pre> <br>  And now we can build the entire solution into one line. <br><pre> <code class="python hljs">print(bind(bind(unit(john), Employee.get_boss), Employee.get_wage))</code> </pre> <br>  As you probably already noticed, in this case we didn‚Äôt have to write the <code>unit</code> function: it simply returns the input parameter.  But we will leave it so that it will be easier for us to summarize our experience later. <br><br>  Note also that in Python we can use methods as functions, which allowed us to write <code>Employee.get_boss(john)</code> instead of <code>john.get_boss()</code> . <br><br>  The following diagram shows the calculation process when John does not have a manager, that is, <code>john.get_boss()</code> returns <code>None</code> . <br><br><img src="https://habrastorage.org/webt/hm/ae/9r/hmae9rlrkzaorijygg-jg2u7wrq.png"><br><br><h2>  findings </h2><br>  Suppose we want to combine functions of the same type <code>f1</code> , <code>f2</code> , <code>‚Ä¶</code> , <code>fn</code> .  If their input parameters coincide in type with the results, we can use a simple chain of the form <code>fn(‚Ä¶ f2(f1(x)) ‚Ä¶)</code> .  The following diagram shows a generalized calculation process with intermediate results, denoted as <code>v1</code> , <code>v2</code> , <code>‚Ä¶</code> , <code>vn</code> . <br><br><img src="https://habrastorage.org/webt/dl/yl/lp/dlyllpbpaltz_hwgjbugs8ti2zg.png"><br><br>  Often this approach is not applicable.  Types of input values ‚Äã‚Äãand function results may vary, as in the first example.  Alternatively, the functions can be composable, but we want to insert additional logic between calls, as in Examples 2 and 3 we inserted an aggregation of intermediate values ‚Äã‚Äãand a null value check, respectively. <br><br><h3>  1. Imperative decision </h3><br>  In all the examples, we first used the most straightforward approach, which can be displayed in the following diagram: <br><br><img src="https://habrastorage.org/webt/bo/2i/co/bo2ico2rhkvds3jmirwyzsyd3yc.png"><br><br>  Before calling <code>f1</code> we did some initialization.  In the first example, we initialized a variable to store the common log, in the second, for a list of intermediate values.  After that, we interleaved the function calls with some kind of linking code: we calculated the aggregate values, checked the result to <code>None</code> . <br><br><h3>  2. Monads </h3><br>  As we saw with examples, imperative decisions have always suffered from verbosity, repetition, and confusing logic.  To get a more elegant code, we used a certain design pattern, according to which we created two functions: <code>unit</code> and <code>bind</code> .  This pattern is called a <b>monad</b> .  The <code>bind</code> function contains the glue code while the <code>unit</code> performs initialization.  This allows you to simplify the final decision to one line: <br><pre> <code class="python hljs">bind(bind( ... bind(bind(unit(x), f1), f2) ... fn<span class="hljs-number"><span class="hljs-number">-1</span></span>), fn)</code> </pre> <br>  The calculation process can be represented by the diagram: <br><br><img src="https://habrastorage.org/webt/tw/n5/ro/twn5ro-lppmqs2rssnne7buoqxo.png"><br><br>  Calling <code>unit(x)</code> generates an initial value of <code>v1</code> .  Then <code>bind(v1, f1)</code> generates a new intermediate value <code>v2</code> , which is used in the next call to <code>bind(v2, f2)</code> .  This process continues until the final result is obtained.  By defining different <code>unit</code> and <code>bind</code> within this template, we can combine various functions into a single chain of calculations.  Monad libraries ( <i>for example, PyMonad or OSlash, - approx. Transl.</i> ) Usually contain ready-to-use monads (pairs of functions <code>unit</code> and <code>bind</code> ) to implement certain compositions of functions. <br><br>  To chain functions, the values ‚Äã‚Äãreturned by <code>unit</code> and <code>bind</code> must be of the same type as the <code>bind</code> input parameters.  This type is called <b>monadic</b> .  In terms of the above diagram, the type of variables <code>v1</code> , <code>v2</code> , <code>‚Ä¶</code> , <code>vn</code> must be a monadic type. <br><br>  Finally, consider how to improve the code written using monads.  Obviously, repeated <code>bind</code> calls look inelegant.  To avoid this, we define another external function: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipeline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, *functions)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> functions: e = bind(e, f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e</code> </pre> <br>  Now instead of <br><pre> <code class="python hljs">bind(bind(bind(bind(unit(x), f1), f2), f3), f4)</code> </pre> <br>  we can use the following abbreviation: <br><pre> <code class="python hljs">pipeline(unit(x), f1, f2, f3, f4)</code> </pre> <br><br><h2>  Conclusion </h2><br>  Monads are a simple and powerful design pattern used to compose functions.  In declarative programming languages, it helps implement such imperative mechanisms as logging or input / output.  In imperative languages <br>  it helps to generalize and shorten the code linking a series of calls of functions of the same type. <br><br>  This article provides only a superficial, intuitive understanding of monads.  You can find out more by accessing the following sources: <br><br><ol><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B0_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">Wikipedia</a> </li><li>  <a href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html">Monads in Python (with nice syntax!)</a> </li><li>  <a href="https://wiki.haskell.org/Monad_tutorials_timeline">Monad tutorials timeline</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/445800/">https://habr.com/ru/post/445800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445788/index.html">Doing cloud-based video surveillance do-it-yourself: new Ivideon Web SDK features</a></li>
<li><a href="../445792/index.html">How we develop documentation in an open project Embox</a></li>
<li><a href="../445794/index.html">IT giants unveiled collaborative solution to deploy hybrid cloud</a></li>
<li><a href="../445796/index.html">Fintech Digest: Dorsey pays Bitcoins, Australia's blockchain strategy, Levi's IPO, Chicago Mayor and the inevitability of Bitcoin</a></li>
<li><a href="../445798/index.html">Rhino inside the cat - run the firmware in the Kopycat emulator</a></li>
<li><a href="../445802/index.html">5 trends of the Internet of Things everyone should know about</a></li>
<li><a href="../445804/index.html">Encapsulation for real samurai, or nuances related to the internal keyword in C #</a></li>
<li><a href="../445806/index.html">How artificial intelligence changes science</a></li>
<li><a href="../445808/index.html">Hated and hounded: the dangerous life of a virus hacker, making powerful enemies</a></li>
<li><a href="../445814/index.html">How the delivery robot changed the culinary habits of American students</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>