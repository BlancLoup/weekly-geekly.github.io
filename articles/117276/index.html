<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>F # The most difficult game in the world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspired by the possibilities of functional programming, in particular F #, and seeing by example that you can create only a few dozen lines, I decide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>F # The most difficult game in the world</h1><div class="post__text post__text-html js-mediator-article">  Inspired by the possibilities of functional programming, in particular F #, and <a href="http://channel9.msdn.com/coding4fun/blog/Fun-with-F-Life-the-solar-system-and-everything-in-101-samples">seeing by example</a> that you can create only a few dozen lines, I decided to implement a simple version of the <a href="http://gametime.com.ua/online-games/the_worlds_hardest_game-359.htm">most complex</a> flash game. <br><br>  It turned out in haste, but <br><a name="habracut"></a><br><br><h4>  Main objects </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First we will determine what type of objects we will have to work with.  Obviously this will be ourselves in the form of a red square, yellow coins and hated blue killers.  All these classes will implement the interface. <br><pre><code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> IPaintObject = <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> Paint : Graphics -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> Recalc : float -&gt; <span class="hljs-keyword"><span class="hljs-keyword">unit</span></span></code> </pre> <br>  Paint will draw on the form, and Recalc (time) will calculate where the object will be located at the time point. <br>  All objects will be located in one array. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> po = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResizeArray&lt;IPaintObject&gt;()</code> </pre><br><br><h5>  RedSquare </h5><br>  The simplest object, to work with which you need to know only its current parameters (position, size) and state (alive or dying, as it will die gradually). <br><pre> <code class="hljs sql">type RedSquare(xx:int, yy:int, ww:int, hh:int, speed:int) = ... member rs.X <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> xCoord <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(v) = (xCoord &lt;- v) <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> rs.Y <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> yCoord <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(v) = (yCoord &lt;- v) <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> rs.W <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = width <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(v) = (width &lt;- v) <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> rs.H <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = height <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(v) = (height &lt;- v) <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> rs.Got <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = gather //    <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> rs.isDying <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (dying&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> rs.Speed = speed</code> </pre><br><br>  Let's start drawing (having missed the process of dying). <br><pre> <code class="hljs sql"> interface IPaintObject <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">member</span></span> obj.Paint(g) = let rect = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (dying) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; Rectangle(x=<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> xCoord-width/<span class="hljs-number"><span class="hljs-number">2</span></span>, y=<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> yCoord-height/<span class="hljs-number"><span class="hljs-number">2</span></span>, width=width, height=height) ... g.FillRectangle(Brushes.Red, rect) g.DrawRectangle(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pen(Color.Black, float32 <span class="hljs-number"><span class="hljs-number">2</span></span>), rect)</code> </pre><br><br>  The hard part is to implement Recalc.  The difficulty is not to go beyond the boundaries of the map.  But more about that later, since we still do not know how to set the level. <br><br><h5>  Yellowcircle </h5><br>  Coins.  Set by position and rotation speed <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YellowCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xx:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, yy:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rr:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, tr:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span></span><span class="hljs-function">)</span></span> = ...</code> </pre><br><br>  There is nothing interesting in the implementation of the class, it is only necessary to check if it does not intersect with RedSquare.  This can be done in the Recalc method. <br>  First, draw a red square from the array <br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rs = seq { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> po <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> obj with | :? RedSquare <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> p -&gt; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> p | _ -&gt; yield! Seq.empty } |&gt; Seq.head</code> </pre><br>  Not the optimal method, the capabilities of the OP are shown.  A set is created, to which an object is added, if it is of the RedSquare type and nothing ‚Äî if of any other.  So, as RedSquare only one - we take Seq.head <br><br>  Next comes the standard task of intersecting a circle and a square.  If it crosses, we kill the coin and add one point to our asset. <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntersects xx yy rr (rs.X-rs.W/<span class="hljs-number"><span class="hljs-number">2</span></span>) (rs.Y-rs.H/<span class="hljs-number"><span class="hljs-number">2</span></span>) (rs.W) (rs.H)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> yc.Take() rs.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>()</code> </pre><br><br><h5>  Bluecircle </h5><br>  The most interesting character.  To set it, you need a lot of parameters - <pre> <code class="hljs lisp">type BlueCircle(<span class="hljs-name"><span class="hljs-name">xx</span></span><span class="hljs-symbol"><span class="hljs-symbol">:int</span></span>, yy<span class="hljs-symbol"><span class="hljs-symbol">:int</span></span>, rr<span class="hljs-symbol"><span class="hljs-symbol">:int</span></span>, speed<span class="hljs-symbol"><span class="hljs-symbol">:int</span></span>, segments:(<span class="hljs-name"><span class="hljs-name">int*int</span></span>)[]) =</code> </pre><br>  coordinates, radius, speed and closed set of segments along which it will move.  The segments are specified as vectors (dx, dy).  Ie from the current position, the circle will go along the first segment, then turn to the corresponding second vector and so on.  After the last vector will return to the first. <br>  In this implementation, it is not possible to move an object in a circle (unless it is made of a many-many-polygon and move along small vectors). <br>  Some basic class properties <br><pre> <code class="hljs pgsql"> member bc.<span class="hljs-keyword"><span class="hljs-keyword">Stable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (bc.TotalDist &lt; <span class="hljs-number"><span class="hljs-number">1e-8</span></span>) //    member bc.Speed <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-type"><span class="hljs-type">float</span></span> speed member bc.Dists = segments |&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.map(fun (dx, dy) -&gt; Math.Sqrt(<span class="hljs-type"><span class="hljs-type">float</span></span>(dx*dx+dy*dy))) //   member bc.TotalDist = bc.Dists |&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.sum member bc.TotalTime = bc.TotalDist/bc.Speed</code> </pre><br><br>  Implement the function Recalc. <br>  As well, there is the possibility of taking modulo fractional numbers.  So, as the circle path is cyclic and knowing the time of its passage, you can determine the current position <br><pre> <code class="hljs haskell"> member bc.<span class="hljs-type"><span class="hljs-type">Recalc</span></span>(tt) = //   -  ,  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bc.<span class="hljs-type"><span class="hljs-type">Stable</span></span>=false) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutable t1 = tt%bc.<span class="hljs-type"><span class="hljs-type">TotalTime</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutable ind = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">X</span></span> &lt;- xx <span class="hljs-type"><span class="hljs-type">Y</span></span> &lt;- yy //     -  ,     while (ind&lt;len<span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; t1*bc.<span class="hljs-type"><span class="hljs-type">Speed</span></span>&gt;=bc.<span class="hljs-type"><span class="hljs-type">Dists</span></span>.[ind]) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">X</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">X</span></span> + (fst segments.[ind]) <span class="hljs-type"><span class="hljs-type">Y</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">Y</span></span> + (snd segments.[ind]) t1 &lt;- t1-bc.<span class="hljs-type"><span class="hljs-type">Dists</span></span>.[ind]/bc.<span class="hljs-type"><span class="hljs-type">Speed</span></span> ind &lt;- ind+<span class="hljs-number"><span class="hljs-number">1</span></span> //    <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (dx, dy) = (((float (fst segments.[ind]))/(bc.<span class="hljs-type"><span class="hljs-type">Dists</span></span>.[ind])), ((float (snd segments.[ind]))/(bc.<span class="hljs-type"><span class="hljs-type">Dists</span></span>.[ind]))) <span class="hljs-type"><span class="hljs-type">X</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">X</span></span> + int (dx*t1*bc.<span class="hljs-type"><span class="hljs-type">Speed</span></span>) <span class="hljs-type"><span class="hljs-type">Y</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">Y</span></span> + int (dy*t1*bc.<span class="hljs-type"><span class="hljs-type">Speed</span></span>)</code> </pre><br><br>  To check the intersection with RedSquare, we use the same method as when implementing YellowSquare. <br><br><h5>  Map </h5><br>  The natural solution was to set the map matrix.  We introduce the following notation. <br>  -1 - forbidden zone <br>  0 - free cell <br>  &gt; 0 - checkpoints (green areas).  They can be saved.  The maximum number indicates the end of the round (if all the coins are present, of course). <br><br><h5>  The form </h5><br>  Yes, all this is good, but it's time to decide on what and how to draw it all. <br>  Define a SmoothForm class, inherited from Form, and add a few of its methods. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SmoothForm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dx:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dy:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _path:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">as</span></span></span><span class="hljs-function"> x</span></span> = <span class="hljs-function"><span class="hljs-function">inherit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Form</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> x.DoubleBuffered &lt;- </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">true</span></span></span><span class="hljs-function"> ... </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> mutable Map</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span> member x.Load(_map:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][], obj, _need) = Map &lt;- _map po.Clear() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> po.Add o need &lt;- _need x.Init()</code> </pre><br><br>  x.Load loads the level, on the map, an array of objects and the number of coins that must be collected to complete the level. <br>  x.Init is mainly concerned with calculating the coordinates of save points for each green area. <br><br>  Actually, it remains to define the Paint method and intercept keystrokes <br><br><pre> <code class="hljs lua">let form = new SmoothForm(Text=<span class="hljs-string"><span class="hljs-string">"F# The world hardest game"</span></span>, Visible=<span class="hljs-literal"><span class="hljs-literal">true</span></span>, TopMost=<span class="hljs-literal"><span class="hljs-literal">true</span></span>,Width=.../* */) form.Paint.Add(fun <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> -&gt; let g = <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>.Graphics <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> to form.rows<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span> to form.cols<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> (form.map.[i].[j], (i+j)%<span class="hljs-number"><span class="hljs-number">2</span></span>) with //   | (<span class="hljs-number"><span class="hljs-number">-1</span></span>, _) -&gt; g.FillRectangle(Brushes.DarkViolet, j*form.DX, i*form.DY, form.DX, form.DY) //   | ( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) -&gt; g.FillRectangle(Brushes.White, j*form.DX, i*form.DY, form.DX, form.DY) //   | ( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; g.FillRectangle(Brushes.LightGray, j*form.DX, i*form.DY, form.DX, form.DY) //   | ( p, _) when p&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; g.FillRectangle(Brushes.LightGreen, j*form.DX, i*form.DY+<span class="hljs-number"><span class="hljs-number">1</span></span>, form.DX, form.DY) //  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (form.map.[i].[j]&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; form.map.[i<span class="hljs-number"><span class="hljs-number">-1</span></span>].[j]&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || form.map.[i].[j]&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; form.map.[i<span class="hljs-number"><span class="hljs-number">-1</span></span>].[j]&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> g.DrawLine(new Pen(Color.Black, float32 <span class="hljs-number"><span class="hljs-number">2</span></span>), j*form.DX, i*form.DY, (j+<span class="hljs-number"><span class="hljs-number">1</span></span>)*form.DX, i*form.DY) //  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (form.map.[i].[j]&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; form.map.[i].[j<span class="hljs-number"><span class="hljs-number">-1</span></span>]&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || form.map.[i].[j]&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; form.map.[i].[j<span class="hljs-number"><span class="hljs-number">-1</span></span>]&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> g.DrawLine(new Pen(Color.Black, float32 <span class="hljs-number"><span class="hljs-number">2</span></span>), j*form.DX, i*form.DY, j*form.DX, (i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*form.DY) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> po <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> //     obj.Recalc((DateTime.Now-SS).TotalSeconds) obj.Paint(g) async { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>! Async.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>) //  <span class="hljs-number"><span class="hljs-number">10</span></span> form.Invalidate() } |&gt; Async.Start )</code> </pre><br><br>  To intercept the key, as it turned out, nothing complicated is needed <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">form</span></span>.<span class="hljs-type"><span class="hljs-type">KeyDown</span></span> //       |&gt; <span class="hljs-type"><span class="hljs-type">Event</span></span>.filter(fun args -&gt; (args.<span class="hljs-type"><span class="hljs-type">KeyValue</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">37</span></span>) &amp;&amp; (args.<span class="hljs-type"><span class="hljs-type">KeyValue</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">40</span></span>)) |&gt; <span class="hljs-type"><span class="hljs-type">Event</span></span>.add (fun args -&gt; match (args.<span class="hljs-type"><span class="hljs-type">KeyCode</span></span>) with | <span class="hljs-type"><span class="hljs-type">Keys</span></span>.<span class="hljs-type"><span class="hljs-type">Down</span></span> -&gt; form.<span class="hljs-type"><span class="hljs-type">Down</span></span> &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-type"><span class="hljs-type">Keys</span></span>.<span class="hljs-type"><span class="hljs-type">Left</span></span> -&gt; form.<span class="hljs-type"><span class="hljs-type">Left</span></span> &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-type"><span class="hljs-type">Keys</span></span>.<span class="hljs-type"><span class="hljs-type">Right</span></span> -&gt; form.<span class="hljs-type"><span class="hljs-type">Right</span></span> &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-type"><span class="hljs-type">Keys</span></span>.<span class="hljs-type"><span class="hljs-type">Up</span></span> -&gt; form.<span class="hljs-type"><span class="hljs-type">Up</span></span> &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> )</code> </pre><br>  Similarly for form.KeyUp <br><br> <a href="http://pixs.ru/%3Fr%3D2014174"><img src="http://i.pixs.ru/storage/1/7/4/psJPG_3130090_2014174.jpg"></a> <br><br>  Something like ... <br><br>  It remains to learn how to load the level of the files.  To do this, we write a function that takes the path to the file as a parameter and returns the level parameters.  The file will go <br><ol><li>  Map dimensions </li><li>  Map </li><li>  BlueCircle number </li><li>  The parameters of each of them </li><li>  YellowCircle Amount </li><li>  The parameters of each of them </li><li>  Coordinates, size and speed RedSquare </li></ol><br><br><pre> <code class="hljs kotlin">let LoadLevel _path = let pp = new ResizeArray&lt;IPaintObject&gt;() let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = File.ReadAllLines(_path) |&gt; Array.toSeq; let L1 = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> |&gt; Seq.skip <span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; Seq.take n |&gt; Seq.toArray |&gt; Array.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> x -&gt; x.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([|</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">' '</span></span></span></span><span class="hljs-function"><span class="hljs-params">|])</span></span></span></span> |&gt; Array.filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> x -&gt; Int32.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, ref tmp)</span></span></span></span>) |&gt; Array.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> x -&gt; Int32.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span>)) ...</code> </pre><br><br>  Since this function is implemented after all classes, you need to add its delegate to the form <br><br><pre> <code class="hljs cs">type DelegateLoad = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">) -&gt; (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][]*ResizeArray&lt;IPaintObject&gt;*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">) type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SmoothForm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dx:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dy:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _path:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">as</span></span></span><span class="hljs-function"> x</span></span> = ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dd:DelegateLoad</span></span></span><span class="hljs-function">)</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span> ... member x.LoadNext() = currLevel &lt;- currLevel + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pathToLevel = pathToFolder+<span class="hljs-string"><span class="hljs-string">"\\"</span></span>+<span class="hljs-string"><span class="hljs-string">"L"</span></span>+currLevel.ToString()+<span class="hljs-string"><span class="hljs-string">".txt"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(pathToLevel) = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) then complete &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> x.Load(dd.Invoke(pathToLevel)) x.Invalidate()</code> </pre><br><br>  (dd.Invoke) performs the function with the specified parameters. <br><br><h5>  Conclusion </h5><br>  Of course, this implementation is not flexible or optimal.  <a href="http://paste.org/pastebin/view/31585">The code</a> and <a href="http://paste.org/pastebin/view/31587">the levels themselves</a> are in a state of improvement.  I will be glad to hear comments and suggestions. <br><br>  <strong>UPD.</strong>  <a href="">Code + exe + 2 leveled</a> </div><p>Source: <a href="https://habr.com/ru/post/117276/">https://habr.com/ru/post/117276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../117264/index.html">Creating a multilingual installer for Windows using WiX</a></li>
<li><a href="../117266/index.html">Space Competition "Let's Go!" Or "To iPad 2?"</a></li>
<li><a href="../117268/index.html">Work with mail on MS Exchange server via EWS. Part 1</a></li>
<li><a href="../117271/index.html">Go sling! - shooting a slingshot at ducks</a></li>
<li><a href="../117274/index.html">What are the types of OutOfMemoryError or from what parts is the memory of the java process</a></li>
<li><a href="../117278/index.html">Report ‚ÄúGolden rules for creating successful websites‚Äù at the IT2Days Usability conference</a></li>
<li><a href="../117279/index.html">Cosmonautics Day @ Google</a></li>
<li><a href="../117280/index.html">The problem with the avast! Antivirus .. "Virus" html: script-inf</a></li>
<li><a href="../117283/index.html">Try Gnome 3 on Ubuntu 11.04 Natty Narwhal</a></li>
<li><a href="../117284/index.html">Online tests to determine the level of knowledge of Desktop Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>