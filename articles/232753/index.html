<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Check PVS-Studio with Clang</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yes Yes. You heard right. This time the article is ‚Äúthe opposite‚Äù. We didn‚Äôt check a project, but checked our analyzer with another tool. In fact, we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Check PVS-Studio with Clang</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/958/ffd/41c/958ffd41ca0618a12d80e8204e7c5696.png" alt="Checking PVS-Studio with Clang" align="left"><br>  Yes Yes.  You heard right.  This time the article is ‚Äúthe opposite‚Äù.  We didn‚Äôt check a project, but checked our analyzer with another tool.  In fact, we have done this before.  For example, they checked PVS-Studio with Cppcheck, using the analyzer built into Visual Studio, and looked at Intel C ++ warnings.  But earlier there was no reason to write an article.  There was nothing interesting.  But Clang could be interested in its diagnostic messages. <br><a name="habracut"></a><br>  We checked <a href="http://www.viva64.com/go.php%3Furl%3D1423">Clang</a> twice with PVS-Studio [ <a href="http://www.viva64.com/ru/b/0108/">1</a> , <a href="http://www.viva64.com/ru/b/0155/">2</a> ] and each time we found something interesting.  But we could not check PVS-Studio at all.  Clang developers have long reported that they are good at building projects in Windows developed using Visual C ++.  But in practice, somehow it does not work.  Or we have no luck. <br><br>  And the other day we suddenly realized that we could easily test our analyzer with the help of Clang.  It was just necessary to approach the task from the other side.  Every night the command-line version of PVS-Studio under Linux is built with the help of GCC.  And the GCC compiler is very easily replaced by Clang.  Accordingly, we can easily try to check PVS-Studio.  And really.  On the same day, as a bright idea came to mind to one of the employees, we had a report on the verification of PVS-Studio.  Now I sit and talk about the contents of the report and my impressions. <br><br><h2>  Impression of html reports </h2><br>  I, of course, already dealt with Clang.  However, it is difficult to judge the quality of analysis on third-party projects.  I often cannot understand whether there is an error or not.  It is especially scary when Clang shows that you need to view the path of 37 points in the source code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The PVS-Studio code, on the contrary, is familiar to me, and I was finally able to fully work with the report issued by Clang.  Unfortunately, this confirmed my earlier impressions that the often shown way of reaching a detected error is redundant and confuses the programmer.  I understand that it is extremely difficult to produce key points of program execution and build such a path.  We, for example, in PVS-Studio are generally afraid to take on such a voluminous task.  However, since Clang implements the display of this path, it is clearly necessary to go further in improving this mechanism. <br><br>  Otherwise, such points only knock down, litter the conclusion and complicate understanding: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a7/229/0df/9a72290df25c4813b55cf451be23b0b5.png"><br><br>  The figure shows the "point N4".  Somewhere below is an error.  I understand that an error will occur only if the condition is not met.  This is what Clang reports.  But why display this information?  And so it is clear that if the condition is true, then there will be an exit from the function and there will be no error.  Extra meaningless information.  There is a lot of such redundant information.  It is obviously possible and worth improving this mechanism. <br><br>  However, I want to give credit to the Clang developers.  Often, showing such a path really helps to understand the cause of the error, especially when more than one function is involved in it.  And, unequivocally, the Clang developers have shown the way of reaching the error much better than in the Visual Studio 2013 static analyzer. Half of the function consisting of 500 lines is often tinted there.  And what gives this coloring is completely incomprehensible. <br><br><h2>  Criticality of errors found </h2><br>  PVS-Studio check is a very good example of how ungrateful it is to show the benefits of static analysis on a working, well-tested project.  In fact, I can "otmazatsya" from all the errors, saying that: <ul><li>  this code is not used now; </li><li>  this code is used extremely rarely or in error handling; </li><li>  This error, but it will not lead to noticeable consequences (its correction does not manifest itself on a huge number of regression tests). </li></ul><br><br>  "Having otmazavshis", I will pretend that I do not make serious mistakes and with a proud look I can say that Clang is suitable only for beginners in programming. <br><br>  Of course, so I will not say!  The fact that critical errors were not found does not at all indicate that Clang is weak in analysis.  The absence of such defects is the result of a lot of testing work using various methods: <ul><li>  internal unit tests; </li><li>  diagnostic regression testing (tagged files); </li><li>  testing on sets of * .i files containing various C ++ constructions and various extensions; </li><li>  regression testing on 90 open-source projects; </li><li>  and, of course, static analysis with PVS-Studio. </li></ul><br><br>  After such a layered defense, it is difficult to expect that Clang will find 20 dereferencing null pointers and 10 divisions by 0. However, think about it.  Even in a thoroughly tested project, Clang found several errors.  This means that with regular use you can avoid a lot of trouble.  It is better to correct the error when Clang finds it, than to get the * .i file from the user where PVS-Studio crashes. <br><br>  Naturally, we made conclusions for ourselves.  Now my colleague is in the process of setting up a Clang launch on the server and sending logs to the mail if the analyzer finds something. <br><br><h2>  About false positives </h2><br>  In total, the Clang analyzer issued 45 warnings.  I don‚Äôt want to talk about the number of false positives.  Better to say that you should definitely fix 12 places. <br><br>  The fact is that ‚Äúfalse positives‚Äù are relative matters.  Formally, the analyzer is right - the code is bad and suspicious.  But this does not mean that a defect was found.  Let me explain with examples. <br><br>  In the beginning, consider the real false positive: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CreateBitMask(bitNum) ((v_uint64)(1) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; bitNum) unsigned GetBitCountForRepresntValueLoopMethod( v_int64 value, unsigned maxBitsCount) { if (value == 0) return 0; if (value &lt; 0) return maxBitsCount; v_uint64 uvalue = value; unsigned n = 0; int bit; for (bit = maxBitsCount - 1; bit &gt;= 0; --bit) { if ((uvalue &amp; CreateBitMask(bit)) != 0) // Clang: Within the expansion of the macro 'CreateBitMask': // The result of the '&lt;&lt;' expression is undefined { n = bit + 1; break; } .... }</span></span></span></span></code> </pre> <br>  As I understand it, the analyzer reports that a shift operation may lead to undefined behavior.  Apparently, Clang got confused in logic or could not correctly calculate the possible range of values ‚Äã‚Äãfor the maxBitsCount variable.  I carefully studied how the function GetBitCountForRepresntValueLoopMethod () is called and could not find a situation when the value in the 'maxBitsCount' variable is too large.  I understand shifts [ <a href="http://www.viva64.com/ru/b/0142/">3</a> ].  So I am sure that there is no error. <br><br>  Self-confidence is good, but not enough.  Therefore, I wrote this assert (): <br><pre> <code class="cpp hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bit = maxBitsCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; bit &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --bit) { VivaAssert(bit &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bit &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((uvalue &amp; CreateBitMask(bit)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) ....</code> </pre> <br>  And on all tests this assert () did not work.  So this is really an example of a false positive of the Clang analyzer. <br><br>  The pleasant consequence of adding assert () was that Clang stopped issuing the message.  It focuses on assert () macros.  They tell the analyzer possible ranges of variable values. <br><br>  There are few such false positives.  Much more such messages here: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G807_IsException1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *p)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kind == ntArrayExpr) { p = First(p); kind = p-&gt;What(); <span class="hljs-comment"><span class="hljs-comment">// Clang: Value stored to 'kind' is never read ....</span></span></code> </pre> <br>  The assignment "kind = p-&gt; What ();" is not used.  Previously used, and after the changes, this line has become redundant.  The analyzer is right.  The string is superfluous, and it should be deleted at least so that it does not confuse the person who will accompany this code. <br><br>  Another example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;() { .... <span class="hljs-comment"><span class="hljs-comment">//  nullWalker     . VivaCore::VivaWalker *nullWalker = 0; left.m_simpleType = ST_INT; left.SetCountOfUsedBits(32); left.m_creationHistory = TYPE_FROM_VALUE; right.m_simpleType = ST_INT; right.SetCountOfUsedBits(11); right.m_creationHistory = TYPE_FROM_EXPRESSION; result &amp;= ApplyRuleN1(*nullWalker, left, right, false); // Clang: Forming reference to null pointer .... }</span></span></code> </pre> <br>  In the unit test, the null pointer is dereferenced.  Yes, you can not do so and ugly.  But really want.  The point is that it is very difficult to prepare an instance of the VivaWalker class, and in this case the reference to the object is not used at all. <br><br>  Both examples show code that works.  However, I do not call this a false positive.  These are the shortcomings that need to be addressed.  However, I would not write these warnings in the column ‚Äúerrors found‚Äù either.  That's why I say that a false positive is a relative concept. <br><br><h2>  Bugs found </h2><br>  Finally we got to the section where I will show interesting code snippets that Clang found inside PVS-Studio. <br><br>  Found errors are not critical for the program.  I'm not trying to justify myself.  But it turned out really so.  After editing all the warnings, the regression tests did not reveal any differences in the operation of PVS-Studio. <br><br>  However, we are talking about the real mistakes and it's great that Clang could find them.  I hope now with its regular launches, he will be able to find more serious blunders in the fresh code of PVS-Studio. <br><br><h3>  Using two uninitialized variables </h3><br>  The code was big and complicated.  There is no point in citing it in the article.  I made a synthetic code that reflects the essence of the error. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A, B; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> getA, getB; Get(A, getA, B, getB); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TmpA = A; <span class="hljs-comment"><span class="hljs-comment">// Clang: Assigned value is garbage or undefined int TmpB = B; // Clang: Assigned value is garbage or undefined if (getA) Use(TmpA); if (getB) Use(TmpB);</span></span></code> </pre> <br>  The Get () function can initialize the variables A and B. It initialized them or not, it marks in the variables getA, getB. <br><br>  Regardless of whether the variables A and B are initialized, their values ‚Äã‚Äãare copied to TmpA, TmpB.  This is where uninitialized variables are used. <br><br>  Why am I saying that this is a non-critical error?  In practice, copying an uninitialized variable of the 'int' type does not cause any trouble.  Formally, as I understand it, an Undefined behavior occurs.  In practice, the garbage is simply copied.  Further variables with garbage are not used. <br><br>  The code was rewritten as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getA) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TmpA = A; Use(TmpA); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getB) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TmpB = B; Use(TmpB); }</code> </pre> <br><h3>  Uninitialized pointers </h3><br>  Let's look at the function call GetPtreePos ().  It is passed links to uninitialized pointers. <br><pre> <code class="cpp hljs">SourceLocation Parser::GetLocation(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ptree* ptree) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *begin, *end; GetPtreePos(ptree, begin, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetSourceLocation(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, begin); }</code> </pre> <br>  It is not right.  The GetPtreePos () function assumes that the pointers will be initialized to nullptr.  Here is how it works: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPtreePos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&amp;begin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&amp;end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (p != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p-&gt;IsLeaf()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pos = p-&gt;GetLeafPosition(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (begin == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Clang: The left operand of '==' is a garbage value begin = pos; } else { begin = min(begin, pos); } end = max(end, pos); } return; } GetPtreePos(p-&gt;Car(), begin, end); p = p-&gt;Cdr(); } }</span></span></code> </pre> <br>  It only saves you from shame that the GetLocation () function is called when a specific code parsing error occurs in the unit test subsystem.  Apparently, this has never happened. <br><br>  A good example of <a href="http://www.viva64.com/ru/a/0080/">how static analysis complements TDD</a> [4]. <br><br><h3>  Scary explicit type conversions </h3><br>  There are three similar functions with scary and incorrect type conversions.  Here is one of them: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Environment::LookupType( CPointerDuplacateGuard &amp;envGuard, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len, Bind*&amp; t, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Environment **ppRetEnv, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeFunctions) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { VivaAssert(m_isValidEnvironment); <span class="hljs-comment"><span class="hljs-comment">//todo: Environment *eTmp = const_cast&lt;Environment *&gt;(this); Environment **ppRetEnvTmp = const_cast&lt;Environment **&gt;(ppRetEnv); bool r = eTmp-&gt;LookupType(envGuard, name, len, t, ppRetEnvTmp, includeFunctions); ppRetEnv = const_cast&lt;const Environment **&gt;(ppRetEnvTmp); // Clang: Value stored to 'ppRetEnv' is never read return r; }</span></span></code> </pre> <br>  Sodom and Gomorrah.  We tried to remove constancy.  And then return the resulting value.  But, in fact, in the line ‚ÄúppRetEnv = const_cast ....‚Äù the local variable ppRetEnv just changes. <br><br>  Let me explain where this ugliness came from and how it affects the work of the program. <br><br>  PVS-Studio analyzer is based on the OpenC ++ library.  It almost did not use the keyword 'const'.  At any time, you could change anything and anywhere, using pointers to non-constant objects.  PVS-Studio inherited this flaw. <br><br>  They fought with him.  But not yet until the end.  You enter in one place const, it is necessary to enter in the second place, then in the third and so on.  Then it turns out that in certain situations something needs to be changed with the help of the pointer and it is necessary to divide the function into parts or even more extensive refactoring. <br><br>  The last heroic attempt to make everywhere const one of the idealistic employees took a week to complete and ended in partial failure.  It became clear that we needed big changes in the code and editing of some data storage structures.  The carrying of light into the kingdom of darkness was stopped.  There are several functions of stubs, as discussed, the purpose of which is to make the code being compiled. <br><br>  What does this error affect?  Oddly enough, it seems no matter what.  All unit tests and regression tests did not reveal any changes in the behavior of PVS-Studio after the corrections.  Apparently, the return value in ‚ÄúppRetEnv‚Äù is not very necessary at work. <br><br><h3>  Using a potentially uninitialized variable </h3><br><pre> <code class="cpp hljs">v_uint64 v; <span class="hljs-comment"><span class="hljs-comment">// Clang: 'v' declared without an initial value verify(GetEscape(p, len - 3, v, notation, &amp;p)); retValue &lt;&lt;= 8; retValue |= v; // Clang: Assigned value is garbage or undefined</span></span></code> </pre> <br>  The function GetEscape () may not work correctly and then the variable 'v' will remain uninitialized.  The result of the work GetEscape () for some reason checks the macro verify ().  How it happened is already unknown. <br><br>  The error goes unnoticed for the following reason.  The function GetEscape () does not initialize the variable only if the PVS-Studio analyzer will work with incorrect text of the program.  In the correct text of the program there are always correct <a href="http://www.viva64.com/go.php%3Furl%3D1419">escape sequences</a> and the variable is always initialized. <br><br><h3>  I'm surprised how it worked </h3><br><pre> <code class="cpp hljs">Ptree *varDecl = bind-&gt;GetDecl(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (varDecl != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (varDecl-&gt;m_wiseType.IsIntegerVirtualValue()) varRanges.push_back(....); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (varDecl-&gt;m_wiseType.IsPointerVirtualValue()) varRanges.push_back(....); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> varRanges.push_back(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } rangeTypes.push_back(varDecl-&gt;m_wiseType.m_simpleType); <span class="hljs-comment"><span class="hljs-comment">// Clang: Dereference of null pointer</span></span></code> </pre> <br>  The varDecl pointer may be nullptr.  However, the last line is always executed.  And a null pointer dereference can occur: varDecl-&gt; m_wiseType.m_simpleType. <br><br>  Why there has never been a fall here is a mystery to me.  The only assumption is that we never get here unless the object stores a pointer to a declaration of a variable (declarator of variable).  But it is still impossible to rely on it. <br><br>  Found a very serious mistake, which, if not now, then, someday would definitely manifest itself. <br><br><h3>  Surprisingly, the fall was not seen here either. </h3><br>  Another amazing place.  Apparently, a combination of factors that can lead to null pointer dereferencing is extremely unlikely.  At least the fall has not been seen since the writing of this function.  But since that moment, it has already been a year and a half.  Miracle. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyRuleG_657</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BindFunctionName *bind, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntegerVirtualValueArray *pReturnIntegerVirtualValues, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PointerVirtualValueArray *pReturnPointerVirtualValues, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *body, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *bodySrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Environment *env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || bodySrc == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { VivaAssert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bind == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pReturnIntegerVirtualValues == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; pReturnPointerVirtualValues == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> integerValueCount = pReturnIntegerVirtualValues-&gt;size(); <span class="hljs-comment"><span class="hljs-comment">// Clang: Called C++ object pointer is null</span></span></code> </pre> <br>  The pReturnIntegerVirtualValues ‚Äã‚Äãpointer may well be equal to nullptr. <br><br>  At first glance, it seems that there is an error in the condition and that the operator should be used: " <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pReturnIntegerVirtualValues == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; pReturnPointerVirtualValues == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br>  But it is not.  The condition is correct.  You just need to check that the pointer is not null before dereferencing the pointer.  If it is zero, the value 0 must be assigned to the integerValueCount variable. The correct variant is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> integerValueCount = pReturnIntegerVirtualValues != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? pReturnIntegerVirtualValues-&gt;size() : <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Amazing.  So many tests.  Runs on 90 open source projects.  Plus for the year we checked a lot of other projects.  And still, the bug lives in the code.  And after all, he would have shown himself to our important potential client. <br><br>  Glory to static analyzers!  Glory Clang! <br><br><h3>  Other </h3><br>  The analyzer revealed some more errors that should be corrected.  It is difficult to describe them, but I don‚Äôt want to make synthetic examples.  Plus there are a couple of warnings that are absolutely true, but useless.  There had to turn off the analysis. <br><br>  For example, Clang was worried about uninitialized variables when using the RunPVSBatchFileMode () function.  But the fact is that the batch run is simply not implemented for Linux, and there is a stub there.  And we are not planning to implement it yet. <br><br><h2>  findings </h2><br>  Use static analyzers in your work. <br><br>  I think the core of PVS-Studio is extremely tested.  However, the Clang static analyzer found 12 real errors.  Other places are not errors, but they were code that smells, and I fixed all such places. <br><br>  The errors found could manifest themselves at the most inopportune moment.  Plus, I think this analyzer would help find a lot of errors that were detected by tests.  A run of the main regression tests takes about 2 hours.  If you find something before, that's fine. <br><br>  That turned out such an article with advertising Clang.  But he deserved that. <br><br>  Just do not think that other analyzers are of little use.  For example, I personally like the <a href="http://www.viva64.com/ru/t/0083/">Cppcheck</a> analyzer.  It is very easy to use and has very clear diagnostics.  But it so happened that he did not find a bunch of errors in PVS-Studio, so I cannot write a similar article about him. <br><br>  And, of course, I recommend using the PVS-Studio analyzer in your work.  It is extremely convenient for using Visual C ++ [ <a href="http://www.viva64.com/ru/b/0222/">5</a> ].  Especially do not forget about the automatic analysis that starts after the successful compilation of the changed files. <br><br><h2>  This article is in English. </h2><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="http://www.viva64.com/en/b/0270/">Checking PVS-Studio with Clang</a> . <br><br><h2>  Additional links: </h2><br><ol><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/b/0108/">PVS-Studio vs Clang</a> . </li><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/b/0155/">Static analysis should be applied regularly</a> . </li><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/b/0142/">Without knowing the ford, do not go into the water.</a>  <a href="http://www.viva64.com/ru/b/0142/">Part Three (about shift operations)</a> . </li><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/a/0080/">How static analysis complements TDD</a> . </li><li>  Andrey Karpov.  <a href="http://www.viva64.com/ru/b/0222/">PVS-Studio for Visual C ++</a> . </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected the answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio and CppCat, version 2014</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/232753/">https://habr.com/ru/post/232753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232743/index.html">Implementing the physical layer in switches</a></li>
<li><a href="../232745/index.html">Using Faye with SSL</a></li>
<li><a href="../232747/index.html">Russian pilots again report GPS crashes - now in the territory of the Russian Federation</a></li>
<li><a href="../232749/index.html">Tomorrow we make St. Petersburg Oculus Rift + Leap Motion happy</a></li>
<li><a href="../232751/index.html">Inspector Buddy - a robot with the heart of a Nokia smartphone</a></li>
<li><a href="../232755/index.html">20 most popular speeches of all time at the TED conference</a></li>
<li><a href="../232757/index.html">The expressive simplicity of python on the example of tasks from combinatorics</a></li>
<li><a href="../232761/index.html">Web mapping and SVG effects</a></li>
<li><a href="../232767/index.html">Grafana - a convenient dashboard for metrics</a></li>
<li><a href="../232769/index.html">Habraklany</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>