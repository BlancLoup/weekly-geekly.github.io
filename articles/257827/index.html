<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Translation) Introduction to C ++ Development in UE4 Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1. Introduction. Creating a class and adding properties. Extending the C ++ class with Blueprint. 
 Part 2. Classes of gameplay. Structures. Refl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Translation) Introduction to C ++ Development in UE4 Part 2</h1><div class="post__text post__text-html js-mediator-article">  <b><a href="http://habrahabr.ru/post/254931/">Part 1. Introduction.</a></b>  <b><a href="http://habrahabr.ru/post/254931/">Creating a class and adding properties.</a></b>  <b><a href="http://habrahabr.ru/post/254931/">Extending the C ++ class with Blueprint.</a></b> <br>  <b>Part 2. Classes of gameplay.</b>  <b>Structures.</b>  <b>Reflection (reflection) in Unreal.</b>  <b>Object / Actor iterators.</b>  <b>Memory manager and garbage collector.</b> <br>  Part 3. Prefixes in class names.  Integer types.  Types of containers.  Container iterators  For-each loop, hash functions. <br>  Part 4. Unreal Engine 4 for Unity developers. <br>  Part 5. ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae0/eae/16e/ae0eae16e60b43dee85e413c14972087.png" alt="image"><br><br>  From the Author: The beginning of the summer turned out to be hot for projects, so the translation was postponed for a long time, then it will be faster. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article is a continuation of the translation of part of the documentation on UE4.  You can find the original article by <a href="https://docs.unrealengine.com/latest/INT/Programming/Introduction/index.html">following this link</a> . <br><a name="habracut"></a><br>  Nice to see you still with us.  In the following sections, we will explore the hierarchy of gameplay classes.  We start with the basic blocks and talk about how they are related to each other.  We will also study how UE uses inheritance and composition to create custom gameplay features. <br><br><h1>  Gameplay classes: Object, Actor and Component </h1><br>  The four main gameplay classes are most often expanded.  These are <i>UObject, AActor, UActorComponent</i> and <i>UStruct.</i>  Further each of them will be described in detail.  You can create types that do not extend any of these classes, but they will not allow you to use most of the built-in features of the engine.  As a rule, classes that are created outside the <i>UObject hierarchy</i> (not inherited from any depth from the <i>UObject</i> ) exist for the following purposes: integration of third-party libraries, wrapping features of the operating system, etc. <br><br><h2>  Unreal Objects (UObject) </h2><br>  The base unit in a UE is the <i>UObject</i> class.  This class, together with the <i>UClass</i> class, provides you with the most important basic engine features: <br><ul><li>  Reflection of properties and methods </li><li>  Property serialization </li><li>  Garbage collector </li><li>  Search UObject by name </li><li>  Setting Property Values </li><li>  Network mode support for properties and methods </li></ul><br><br>  Each class inherited from <i>UObject</i> contains a <i>UClass singleton</i> created for it.  This class contains all the metadata about a class instance.  The capabilities of <i>UObject</i> and <i>UClass</i> lie (jointly) at the heart of all that the gameplay object does during its life cycle.  It is best to think about the difference between <i>UClass</i> and <i>UObject</i> as if <i>UClass</i> describes exactly how the <i>UObject</i> instance looks, what properties are available for serialization, networking, etc.  Basically, gameplay development is not connected with inheritance directly from <i>UObject</i> , but with inheritance from classes <i>AActor</i> and <i>UActorComponents</i> .  You do not need to know the details of how <i>UClass / UObject</i> works.  But knowledge of their existence will be useful. <br><br><h2>  AActor </h2><br>  The <i>AActor</i> class represents an object that is part of the gameplay.  An instance of this class is either hosted by the designer at the level, or created at runtime (using gameplay systems).  All objects placed on a level are descendants of this class.  For example - <i>AStaticMeshActor, ACameraActor</i> and <i>APointLight.</i>  <i>AActor is</i> inherited from <i>UObject,</i> that is, it uses the standard functions that were listed in the previous section.  <i>AActor</i> can be destroyed using game code (C ++ or Blueprint) or the standard garbage collection mechanism (when unloading a level from memory).  It provides high-level behavior of our game objects, as well as being the base type that provides replication capability for the network mode.  When replicating (in multi-user mode), <i>AActor</i> also gives access to information about any of its <i>UActorComponent,</i> which is required to support the operation of the network mode. <br><br>  <i>AActor</i> has its own behaviors (specializes in inheritance), but other than that, they are containers for the <i>UActorComponents</i> hierarchy (specializes in composition).  This can be done with the help of our <i>AActor RootComponent member.</i>  It contains one <i>UActorComponent,</i> which, in turn, may contain many others.  Before placing an <i>AActor</i> on a level, it must contain at least a <i>USceneComponent</i> that stores the position, rotation, and scale of the <i>AActor.</i> <br><br>  <i>AActor</i> provide access to several events that are triggered during the entire <i>AActor</i> life cycle <i>.</i>  Below is a short list of some of them: <br><br><table><tbody><tr><td>  BeginPlay </td><td>  Called once the object enters the game. </td></tr><tr><td>  Tick </td><td>  Each frame is called to execute code during this frame. </td></tr><tr><td>  Endplay </td><td>  Called when an object leaves the game. </td></tr></tbody></table><br><br>  For a more detailed study of the class <i>AActor,</i> you can follow the <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/index.html">link</a> . <br><br><h2>  Duration of life cycle </h2><br>  In the previous section, the topic of the <i>AActor</i> life cycle was <i>touched on a bit.</i>  For <i>Actors</i> placed at the level of the life cycle, you can imagine the following - loading and the beginning of the existence of <i>Actor</i> and his subsequent destruction (at the unloading level).  Let's see what are the processes of creation and destruction during execution.  Creating an <i>AActor is a</i> bit more complicated than creating a regular object.  This happens because the <i>AActor</i> must be registered with different systems (running at run-time) - the physics engine, the manager responsible for the information coming in every frame, etc.  Therefore, to create an object, there is the <i>UWorld :: SpawnActor ()</i> method <i>.</i>  After the required <i>Actor is</i> created successfully, the <i>BeginPlay ()</i> method is <i>called,</i> followed by the <i>Tick ‚Äã‚Äã()</i> method (in the next frame). <br><br>  If <i>Actor has</i> existed the time you need, you can destroy it by calling the <i>Destroy ()</i> method <i>.</i>  In this case, the <i>EndPlay ()</i> method will be called <i>,</i> in which you can write the necessary code that is executed when the object is destroyed.  Another option for <i>Actor's</i> life <i>control</i> is to use the <i>LifeSpan</i> field <i>(lifetime).</i>  You can set this value in the constructor (or later at run-time).  If the specified time expires, the <i>Destroy</i> method will be called automatically. <br><br>  You can learn more about creating <i>Actors by</i> clicking on the <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/Spawning/index.html">link.</a> <br><br><h2>  UActorComponent </h2><br>  <i>UActor Components</i> have their own behavior and, as a rule, are responsible for the functionality that is common to different <i>AActors</i> ‚Äî for example, displaying meshes, particle systems, camera work, and physical interactions.  Unlike the <i>AActors,</i> who provide the high-level logic of their behavior in your game, the <i>UActorComponents</i> usually perform individual tasks required to support higher-level objects.  Components can be children of other components.  They can be attached to only one parent component or <i>Actor,</i> but the component itself can have many child components.  You can imagine this relationship as a tree of components.  It should be remembered that the child components have a position, rotation and scale <u>relative to the</u> parent components or <i>Actor.</i> <br><br>  There are many options for using <i>Actors and components.</i>  One of the ways to imagine the relations of <i>Actors</i> and components is the following - <i>Actor</i> answers the question <i>‚ÄúWhat is this thing?</i>  <i>(what is this thing?) ‚Äù,</i> and the components - to the question <i>‚Äú What is it made of?</i>  <i>(what is this thing made of?) "</i> <br><br><ul><li>  RootComponent - An object that contains a top-level component in the <i>AActor</i> component tree <i>.</i> </li><li>  Ticking - A component that updates every frame (tick) is part of the Tick () method of its own <i>AActor.</i> </li></ul><br><br><h2>  Dissect First Person Character </h2><br>  In the previous sections there were many words without demonstrations.  To illustrate the relationship between <i>AActor</i> and its <i>UActor Components,</i> let's examine the <i>Blueprint that</i> is generated when opening a project based on the <i>First Person</i> template <i>.</i>  The picture below shows the component tree for the <i>FirstPersonCharacter Actor.</i>  Here <i>RootComponent</i> is <i>CapsuleComponent.</i>  Attached to the <i>CapsuleComponent</i> components are <i>ArrowComponent, Mesh</i> and <i>FirstPersonCameraComponent.</i>  The most deeply nested vertex is the <i>Mesh1P</i> component <i>, the</i> parent of which is <i>FirstPersonCameraComponent.</i>  This means that the position of the mesh is relative to this camera. <br><img src="https://habrastorage.org/getpro/habr/post_images/df1/146/71a/df114671a9ff5403d1d008a6c06bffcc.jpg" alt="image"><br><br>  Graphic this component tree looks like it is shown in the picture below, where you can see all the components in 3d space (except for the Mesh component) <br><img src="https://habrastorage.org/getpro/habr/post_images/774/bca/03e/774bca03e7704d3ef241e727e1cb8281.jpg" alt="image"><br><br>  This component tree is attached to one actor-class.  As we can see, we can create complex gameplay objects using both inheritance and composition.  Inheritance should be used when changing an existing <i>AActor</i> or <i>UActorComponent,</i> and composition, if the set of <i>AActor</i> types must have similar functionality. <br><br><h2>  Ustruct </h2><br>  To use <i>UStruct,</i> you do not need to inherit from any particular class, it is enough to note the structure with the <i>USTRUCT ()</i> macro and the build tools will do the main work for you.  Unlike <i>UObject,</i> the garbage collector does not track <i>UStruct.</i>  If you dynamically create instances of them, you must independently manage their life cycle.  <i>UStructs</i> are used so that <i>POD types</i> have support for <i>UObject reflection</i> for editing in the <i>UE,</i> management via <i>Blueprint,</i> serialization, networking, etc. <br><br>  Now, after discussing the basics of hierarchies for creating our gameplay classes, it's time to choose your path again.  You can learn more about the gameplay classes, explore our examples in search of more information, or continue to dive deeper into the features of C ++ to create a game. <br><br><h1>  Dive even deeper </h1><br>  Are you sure you want to know more?  We will continue to study the work of the engine. <br><br><h2>  Unreal reflection system </h2><br>  Blog Post: <a href="https://www.unrealengine.com/blog/unreal-property-system-reflection">Property System in Unreal (Reflection)</a> <br><br>  The gameplay classes use special markup, so before moving on to them, let's look at some basic things from the <i>Unreal</i> properties system <i>.</i>  <i>UE4</i> uses its own reflection system, which provides you with various dynamic capabilities ‚Äî garbage collection, serialization, network replication, and <i>Blueprint / C ++</i> interaction <i>.</i>  These features are optional, that is, you must add the required markup yourself for your types, otherwise <i>Unreal</i> ignores them and does not generate the necessary data for reflection.  Below is a brief overview of the main markup elements: <br><br><ul><li>  UCLASS () - used to generate reflection data for a class.  The class must be a UObject descendant. </li><li>  USTRUCT () - used to generate reflection data for the structure </li><li>  GENERATED_BODY () - UE4 replaces this with all the necessary generic code that is created for the type. </li><li>  UPROPERTY () - allows the use of a UCLASS or USTRUCT member variable as an UPROPERTY.  UPROPERTY has many use cases. This macro allows you to make a variable available for replication, serialization, and accessible from Blueprint.  It is also used by the garbage collector to track the number of references to a UObject. </li><li>  UFUNCTION () - allows a UCLASS or USTRUCT class method to be used as a UFUNCTION.  UFUNCTION can allow a method to be called from Blueprint and used as RPCs, etc. </li></ul><br><br>  Example of the UCLASS class definition: <br><br><pre><code class="hljs kotlin">#include <span class="hljs-string"><span class="hljs-string">"MyObject.generated.h"</span></span> UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public UObject { GENERATED_BODY</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyUObject(); UPROPERTY(BlueprintReadOnly, EditAnywhere) float ExampleProperty; UFUNCTION(BlueprintCallable) void ExampleFunction(); };</code> </pre> <br>  You may notice for the first time the inclusion of the <i>‚ÄúMyClass.generated.h‚Äù</i> header <i>.</i>  <i>Unreal</i> will place all generated data for reflection in this file.  In the declaration of your type (in the list of included files) this file should be located last. <br><br>  You may also have noticed that it is possible to add additional qualifiers to markup macros.  In the code above, some of the most common ones are added for demonstration.  They allow you to specify the specific behavior that our types possess: <br><ul><li>  Blueprintable - The class can be extended using Blueprint. </li><li>  BlueprintReadOnly - The property is read only from Blueprint, and is not writable. </li><li>  Category - Defines the section in which the property is displayed in the Details view in the editor.  Used for organization. </li><li>  BlueprintCallable - The function can be called from Blueprint. </li></ul><br><br>  The number of qualifiers is very large, so we will not list them here, but give links to the relevant sections of the documentation: <br><ul><li>  List of <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Classes/Specifiers/index.html">UCLASS</a> specifiers </li><li>  <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html">UPROPERTY Specifier</a> List </li><li>  List of <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Functions/Specifiers/index.html">UFUNCTION qualifiers</a> </li><li>  <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Structs/Specifiers/index.html">USTRUCT Specifier</a> List </li></ul><br><br><h2>  Object / Actor iterators </h2><br>  Object iterators are a very useful tool for iterating through all instances of a particular type of <i>UObject</i> and its subclasses. <br><br><pre> <code class="hljs pgsql">//     UObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TObjectIterator&lt;UObject&gt; It; It; ++It) { UObject* CurrentObject = *It; UE_LOG(LogTemp, <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>, TEXT("Found UObject named: %s"), *CurrentObject.GetName()); }</code> </pre><br>  You can limit the search by providing a more specific type of iterator.  Suppose you have a class called <i>UMyClass,</i> inherited from <i>UObject.</i>  You can find all instances of this class (and all that are its descendants) as follows: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TObjectIterator&lt;UMyClass&gt; It; It; ++It) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  WARNING: Using iterator objects in <i>PIE (Play in Editor)</i> can produce unexpected results.  While the editor is loaded, the object iterator will return all the <i>UObjects</i> created for your instance of the game world, in addition to those used in the editor. <br><br>  <i>Actor</i> iterators work in a similar way, just like object iterators, but they work only for the heirs from the <i>AActor.</i>  <i>Actor</i> iterators <i>do</i> not have the problem mentioned above and return only those objects that are used in the current exam of the game world. <br><br>  When an <i>Actor</i> iterator is <i>created,</i> it needs to pass a pointer to a <i>UWorld</i> instance <i>.</i>  Many child classes from <i>UObject,</i> for example, <i>APlayerController</i> provide this method.  If you are not sure, you can check the return value of the <i>ImplementsGetWorld</i> method to see if a particular class <i>supports the GetWorld</i> method <i>.</i> <br><br><pre> <code class="hljs ruby">APlayerController* MyPC = GetMyPlayerControllerFromSomewhere(); UWorld* World = MyPC-&gt;GetWorld(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Like object iterators, you can provide a specific <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">only</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">objects</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">that</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">are</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">derive</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">that</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TActorIterator</span></span></span><span class="hljs-class">&lt;AEnemy&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">);</span></span> It; ++It) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... }</code> </pre><br>  Since the <i>AActor</i> is a heir from <i>UObject,</i> you can use <i>TObjectIterator</i> as well to find all <i>AActors</i> instances <i>.</i>  But be careful in <i>PIE!</i> <br><br><h1>  Memory Manager and Garbage Collector </h1><br>  <i>Actors</i> are usually not collected by the garbage collector.  You must manually call the <i>Destroy</i> method after spawning <i>Actor.</i>  Removal will not happen immediately, but only during the next phase of garbage collection. <br><br>  This case is most common if you have <i>Actors</i> with <i>UObject</i> properties <i>.</i> <br><br><pre> <code class="hljs cpp">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY() MyGCType* SafeObject; MyGCType* DoomedObject; AMyActor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer) { SafeObject = NewObject&lt;MyGCType&gt;(); DoomedObject = NewObject&lt;MyGCType&gt;(); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnMyActor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UWorld * World, FVector Location, FRotator Rotation)</span></span></span><span class="hljs-function"> </span></span>{ World-&gt;SpawnActor&lt;AMyActor&gt;(Location, Rotation); }</code> </pre><br>  When we call this function, we generate <i>Actor</i> in our world.  Its constructor creates two objects.  One is labeled <i>UPROPERTY, the</i> other is a regular pointer.  While <i>Actors</i> are part of the root object, <i>SafeObject</i> will not be collected by the garbage collector, since it can be accessed from this root.  <i>DoomedObject,</i> however, will have a different life cycle.  Since it is not marked as <i>UPROPERTY,</i> the garbage collector knows nothing about references to it and eventually it will be destroyed. <br><br>  When a <i>UObject</i> is collected by the garbage collector, all <i>UPROPERTY</i> references will get <i>nullptr</i> values <i>.</i>  This is done to safely check whether the object is destroyed by the garbage collector or not. <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MyActor-&gt;SafeObject != nullptr) { <span class="hljs-comment"><span class="hljs-comment">// Use SafeObject }</span></span></code> </pre><br>  This is an important note, because, as mentioned earlier, the actors for whom the <i>Destroy ()</i> method was called are not deleted until the next phase of garbage collection.  You can check whether the <i>UObject is</i> waiting for deletion using the <i>IsPendingKill ()</i> method <i>.</i>  If the method returns true, the object is considered dead and should not be used. <br><br><h2>  UStructs </h2><br>  As mentioned earlier, <i>UStructs</i> is a lightweight version of <i>UObject.</i>  <i>UStructs</i> cannot be collected by the garbage collector.  If you are using a dynamic copy of <i>UStructs,</i> you can use smart pointers, which we will talk about later. <br><br><h2>  Links not to UObject </h2><br>  Typically, <i>non-UObjects</i> may also have the ability to add an object reference to prevent them being deleted by the garbage collector.  To do this, the object must inherit <i>FGCObject</i> and override the <i>AddReferencedObjects</i> method <i>.</i> <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FMyNormalClass</span></span></span><span class="hljs-class"> : public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FGCObject</span></span></span><span class="hljs-class"> { public: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UObject</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SafeObject</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FMyNormalClass</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Uobject</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SafeObject</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">) { } void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddReferencedObjects</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FReferenceCollector</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collector</span></span></span><span class="hljs-class">) override { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collector</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddReferencedObject</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SafeObject</span></span></span><span class="hljs-class">); } }</span></span></code> </pre><br><br>  We use the <i>FReferenceCollector</i> to manually add a hard link to the required <i>UObject,</i> which should not be collected by the garbage collector.  When an object is deleted (the destructor is triggered), all links added by it will be deleted. <br><br>  PS: I ask all suggestions for correcting errors and inaccuracies sent in a personal. </div><p>Source: <a href="https://habr.com/ru/post/257827/">https://habr.com/ru/post/257827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257813/index.html">Writing Beethoven in Javascript or a bit of MIDI.js</a></li>
<li><a href="../257817/index.html">The history of one test task</a></li>
<li><a href="../257819/index.html">Apple's social network, new title from Rovio, success secrets from the creators of Vainglory - and other news of the week for a mobile developer</a></li>
<li><a href="../257823/index.html">Useful extension for SQL Server Management Studio</a></li>
<li><a href="../257825/index.html">What kind of javascript framework are you using? Survey among JS-developers</a></li>
<li><a href="../257829/index.html">Choosing a corporate Internet gateway</a></li>
<li><a href="../257831/index.html">Scientists have tested brain activity to find cybersecurity threat</a></li>
<li><a href="../257835/index.html">Analysis of CPL malware, part 2</a></li>
<li><a href="../257837/index.html">How to use Twitter at technical conferences?</a></li>
<li><a href="../257839/index.html">The eleventh issue of TsODY.RF magazine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>