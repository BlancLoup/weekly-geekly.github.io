<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Handling large amounts of data in memory in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share the experience recently gained in C # on loading and processing large amounts of data in memory. All of the following applies to Visua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Handling large amounts of data in memory in C #</h1><div class="post__text post__text-html js-mediator-article">  I want to share the experience recently gained in C # on loading and processing large amounts of data in memory.  All of the following applies to Visual Studio 2008 and .Net Framework 3.5.1, in case of any differences in other versions of the language or libraries. <br><br>  So, we have the following tasks: <br>  1. Place in memory up to 100 million records consisting of a string, 16 characters long (unique key) and two integer values, 4 bytes each; <br>  2. Quickly find and edit a record by key. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Problem solving ‚Ññ1.  Location in memory. </h4><br><br>  Let's start with the placement.  The total size of useful information in the record is 24 bytes.  The entire data set should take about 2.4 GB (we will not deal with accurate recalculations along the 1024 border).  Here we are in for the first trouble: on x32, the Windows OS process can allocate only 2 GB.  In practice, in the .Net process, this value is even smaller, I managed to allocate somewhere around 1.8 GB.  I assume that the remaining space is occupied by the libraries that are used in the project.  So  We can solve the problem completely only on the x64 platform.  In the example, we will still consider x32 for comparison. <br><br>  So, without further ado, we take the pen (mouse and keyboard) and begin to sculpt what immediately comes to mind.  Make a representative of the record in memory: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Entry</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Key; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntValue1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntValue2; }</code> </pre> <br><br>  The int alias is cross-platform and always corresponds to Int32, so it will be the same for x32 and x64. <br>  We make a simple array and load 10 million records into it: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Entry[] Entries = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entry[<span class="hljs-number"><span class="hljs-number">10000000</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnCreate_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Entries.Length; i++) { Entries[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entry() {Key = i.ToString(<span class="hljs-string"><span class="hljs-string">"0000000000000000"</span></span>)}; } GC.Collect(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Created {0}, Memory {1}"</span></span>, i.ToString(<span class="hljs-string"><span class="hljs-string">"0,0"</span></span>), GC.GetTotalMemory(<span class="hljs-literal"><span class="hljs-literal">true</span></span>).ToString(<span class="hljs-string"><span class="hljs-string">"0,0"</span></span>)); lbLog.Items.Add(msg); }</code> </pre> <br><br>  And we see that we occupied about 760 MB (x32) and 1040 MB (x64), i.e.  at 76/104 B per record, of which only 24 are useful. It turns out that 100 million will occupy 7.6 / 10.4 GB! <br><br>  What took 52/80 B?  There are several points: the infrastructure of .Net objects and the alignment of memory locations.  Let's start with the first.  A good article can be read <a href="http://www.simple-talk.com/dotnet/.net-framework/object-overhead-the-hidden-.net-memory--allocation-cost/">here</a> .  It turns out that on the class infrastructure we lose 8/16 B and another 4/8 B on the link (our array of class instances is actually an array of pointers to instances).  Check by replacing class with struct: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Entry ...</code> </pre> <br><br>  Measurement showed costs 64/80 B to write.  Everything fits together - we saved 12/24 B. The structure is ValueType, so it is logical to assume that in the array we now have not links, but the values ‚Äã‚Äãthemselves.  So it is, so we actually saved 4/8 B on the link.  The infrastructure of the structure itself does not take anything.  Before we go further and start optimizing Key, on which we, apparently, are losing a lot, let's stop at one important point.  Having transferred the record to the structure, we dug a hole for ourselves - if we place the data in one array of structures, then we will need one very large block of memory.  Even if there is enough free memory, such a solid block may not appear due to fragmentation.  In practice, I began to face problems allocating more than 500 MB.  We will solve this question in the 2nd problem.  Additionally, with each transfer of the record, we will now lose on cloning the structure, and when organizing the link, we will lose on boxing / unboxing.  But nowhere to go, you need to save space. <br><br>  Continue with the Key field.  The String type is a class, so we immediately lose 12/24 B on the record.  In fact, the line is very heavy, for example, you can read <a href="http://www.yoda.arachsys.com/csharp/strings.html">here</a> .  Practically, having made an array of strings of length 16, we are convinced of the occupation by the field Key 56/72 B on the record.  Total: <br>  For class: 8 (two int) + 56/72 (Key) +12/24 (class infrastructure + link) = 76/104 B. <br>  For the structure: 8 (two int) + 56/72 (Key) = 64/80 B. <br><br>  Let's try to translate the Key field to char [].  We get the benefit of 8 B on both platforms.  The array is also a class, so we did not save on the infrastructure, but only on the internal organization of the string itself, given that inside it also stores the char array.  Each character is Unicode and occupies 2 bytes.  Plus, alignment in memory can play a role.  It's time to talk about it. <br><br>  I think many people know that it is advantageous to align data in memory along a border defined by a platform, for example, along an Int32 border.  Details about this can be found <a href="http://www.developerfusion.com/article/84519/mastering-structs-in-c/">here</a> .  In our case, we did not lose anything at the location of the Entry class / structure, since  all fields fall exactly on the border of 4 bytes (remember that Key is a link).  You can experiment by changing the settings of the StructLayout attribute and using the Marshal.SizeOf (new Entry ()) metering.  But if you make one field of type byte instead of int, it turns out that we only occupy the same amount of memory per array as with int, even if you set the property Pack = 1 for StructLayout. That is,  the structure itself will be packed at the 1 byte boundary, but the array elements will be located at the 4 byte boundary.  I‚Äôll say right away that I didn‚Äôt solve the problem of array packing, since  the final solution of the problem did not require it.  Therefore, this topic, as well as the topic of lines / characters, is not fully disclosed here.  I also want to add that the CharSet = CharSet.Ansi value of the StructLayout attribute did not affect the amount of memory occupied by either the string or the char []. <br><br>  So, at the moment we saved 20/32 B on the record.  Because  the string in this problem was not meant to be unicode, it was decided to use byte [] instead of char [].  We save another 16 B on both platforms.  One record now occupies 40/56 B. Isfat - 16/32 B per organization of the array.  It turns out that .Net has the ability to organize a static fixed buffer using an insecure mode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> _key[<span class="hljs-number"><span class="hljs-number">16</span></span>];</code> </pre> <br><br>  This is where we finally achieve 100% rationality - our recording takes exactly 24 B in memory on both platforms.  At x32 we will be able to download about 75 million (1.8 GB), on x64 all 100 million (2.4 GB).  The maximum amount on x64 is essentially limited by the amount of available memory.  You can use this happiness only in unsafe and fixed blocks.  There is a suspicion that here we will lose in performance, but as far as I don‚Äôt know, I didn‚Äôt make measurements, because  The final version fully satisfied the needs. <br><br>  We smoke and move on to solving the second problem. <br><br><h4>  Problem solving ‚Ññ2.  Fast access. </h4><br><br>  For quick access to 100 million records, we need something like a hash table.  Standard Hashtable is not suitable, because  uses Object, which means that each record-structure will be put in a special class (boxing) and we will again start losing on the class infrastructure.  We need Generic.  There is such a - Dictionary &lt;TKey, TValue&gt;.  After an unsuccessful attempt to use and disassemble, we find the following (those who are not familiar with the principles of the work of hash tables should be read <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588-%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">here</a> ): <br><br>  - an excess of 8 B per occurrence: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Entry { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashCode; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TKey key; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TValue <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br>  Losing hashcode and organizing a linked list (using the chaining method).  Here, by the way, we need two structures - one for the key, the other for the values. <br><br>  - one segment for data: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Entry&lt;TKey, TValue&gt;[] entries;</code> </pre> <br>  There is an acute problem of allocating one large block of memory. <br><br>  - the hash segment is greater than or equal to the capacity (many questions arise): <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ num = HashHelpers.GetPrime(capacity); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[num]; ‚Ä¶</code> </pre> <br><br>  - when filling, resizing occurs with a minimum of two-fold reserve, fitting to this size of the hash segment and correspondingly rehashing: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ num = HashHelpers.GetPrime(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count * <span class="hljs-number"><span class="hljs-number">2</span></span>); numArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[num]; ‚Ä¶ entryArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entry&lt;TKey, TValue&gt;[num]; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buckets = numArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entries = entryArray; }</code> </pre> <br><br>  I think you should not describe in detail what this all leads to.  Think about at least the logic of double growth on millions of volumes. <br><br>  Having discovered such inadequate behavior, I no longer began to delve into my native collections for something more rational, but wrote my own dictionary.  In fact, everything is quite trivial, especially since I do not need 90% of the functionality that the standard implements.  I will not give the code, I will only indicate the key points: <br>  - do not separate key and value, all in one Entry structure. <br>  - in the structure, Entry has overlapped (and how is it possible to overlap something in the structure ?!) with the GetHashCode () method.  Used the modified FNV method <a href="http://bretm.home.comcast.net/~bretm/hash/6.html">from here</a> (fig.4) <br>  - in the Entry structure, overlapped the Equals (object obj) method.  Comparison is only a key. <br>  - the size of the hash segment made custom in the designer.  Changing its size and rehashing is not provided. <br>  - the index in the hash segment is calculated as the remainder of the hashcode divided by the size of the hash segment. <br>  - each cell of the hash segment is an ordinary List, which is filled with records with the same hashcode.  This is where the problem of one large block of memory is solved. <br><br>  Calculate how much memory we spend on the organization: <br>  - hash segment = array of links to lists (size of hash segment * 4/8 B); <br>  - list instances = class infrastructure + list fields (hash segment size * (8/16 +28/44)). <br>  Total, for the organization of a segment of 1 million, we will spend about 40/68 MB. <br><br>  Everything would be great and it's time to drink champagne.  But it was not there.  It turns out that List: <br><br>  - as the standard dictionary grows with doubling: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureCapacity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ num = (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._items.Length) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ? <span class="hljs-number"><span class="hljs-number">4</span></span> : (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._items.Length) * <span class="hljs-number"><span class="hljs-number">2</span></span>); ‚Ä¶</code> </pre> <br><br>  - the function of freeing the excess memory does not release 0.1 volume: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimExcess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num; num = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._items.Length)) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._size &gt;= num) { <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> Label_002A; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Capacity = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._size; Label_002A: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><br>  - well, in the appendage it is redundant (for our purposes) in the fields and in what is a class: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">List</span></span>... { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _defaultCapacity = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T[] _emptyArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T[] _items; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _size; [NonSerialized] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _syncRoot; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _version; ...</code> </pre> <br><br>  I had to write my list, with custom linear growth, complete memory release and saving 8 B in the _syncRoot and _version fields.  You can also translate it into a structure, saving 12 B. <br><br>  Everything, the problem is solved - we drink champagne! <br><br><h5>  And some practice </h5><br><br>  PC Core 2 Quad Q9400 @ 2.66, RAM 4 Gb, Windows Server 2008 R2 Standard x64 <br><br>  Hesh segment 1 million, list growth 25. <br>  Filling 100 million. 5 min. 50 sec.  Memory 2.46 GB, peak 3.36 GB. <br>  Statistics: filling 100%, minimum chain 56, maximum 152, standard deviation 10. <br>  Comparison of 100 million in memory with external 100 million 4 min 10 sec. <br><br>  Hesh segment 2 million, growth lists 20. <br>  Filling 100 million. 4 min. 43 sec.  Memory 2.53 GB, peak 3.57 GB. <br>  Statistics: filling 100%, minimum chain 20, maximum 89, standard deviation 7. <br>  Comparison of 100 million in memory with external 100 million 2 min 56 sec. <br><br>  A small remark: .Net does not immediately free up memory, even if we freed a large number of objects.  This may not happen after garbage collection.  The memory remains reserved for future use and will be released if there is an acute shortage of memory in the system (perhaps even by some criteria). <br><br>  I hope this experience will be useful to someone else when solving optimization problems. </div><p>Source: <a href="https://habr.com/ru/post/114495/">https://habr.com/ru/post/114495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114489/index.html">About image gradient</a></li>
<li><a href="../114490/index.html">Now habrovchan has a team in the project GIMPS!</a></li>
<li><a href="../114492/index.html">3D sound - from 19th century technology to 21st technology</a></li>
<li><a href="../114493/index.html">People in a startup: you are hired!</a></li>
<li><a href="../114494/index.html">New version of Developer Tools</a></li>
<li><a href="../114496/index.html">kedDroid - S02E03. Video review software for Android</a></li>
<li><a href="../114497/index.html">Organize and optimize styles</a></li>
<li><a href="../114499/index.html">1261262 visitors in two weeks on a new site without a ruble on advertising - this is real</a></li>
<li><a href="../114500/index.html">FAIL</a></li>
<li><a href="../114502/index.html">Turning off the white list Wifi in HP laptops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>