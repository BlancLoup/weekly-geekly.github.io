<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>There are two functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are two boolean functions.  arguments, one - constant, the other - balanced. Which one will you sit on, which fender? Only functions are unknown...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>There are two functions</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/b23/210/7ba/b232107bab944fea972f96b3243e7189.png" alt="Hello"></div><br>  There are two boolean functions. <img src="https://tex.s2cms.ru/svg/n" alt="n">  arguments, one - constant, the other - balanced.  Which one will you sit on, which fender?  Only functions are unknown, and they can only be called once. <br><br>  If you do not know how to solve a similar problem, welcome under cat.  There I will talk about quantum algorithms and show you how to emulate them in the most popular language - in Python. <br><a name="habracut"></a><br><h2>  I've come to talk with you again </h2><br>  Let's formulate the problem of two functions a little more formally.  Let a Boolean function be given. <img src="https://tex.s2cms.ru/svg/f%3A%20%5C%7B0%2C%201%5C%7D%5En%20%5Cto%20%5C%7B0%2C%201%5C%7D" alt="f: \ {0, 1 \} ^ n \ to \ {0, 1 \}">  and it is known a priori that it is either constant, that is, for any of its arguments, it always returns either 0 or 1, or is balanced, that is, exactly half of its arguments returns 0, and exactly half of it 1. It is required to determine whether the function is constant or balanced.  It is considered that the time of the function call is incommensurable more than any other operations, therefore the complexity of the algorithm is determined by the number of function calls. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fb1/00c/303/fb100c3038b141cb8f0b781345239e5e.jpg" alt="hard_choice"></div><br>  <em>Example:</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li><img src="https://tex.s2cms.ru/svg/f(x_1%2C%20x_2)%20%3D%20x_1%20%5Coplus%20x_2" alt="f (x_1, x_2) = x_1 \ oplus x_2">  balanced: <br><table><thead><tr><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/x_1" alt="x_1"></div></th><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/x_2" alt="x_2"></div></th><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/f" alt="f"></div></th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  one </td><td>  one </td></tr><tr><td>  one </td><td>  0 </td><td>  one </td></tr><tr><td>  one </td><td>  one </td><td>  0 </td></tr></tbody></table><br></li><li><img src="https://tex.s2cms.ru/svg/f(x_1%2C%20x_2)%20%3D%20x_1%20%5Cvee%20x_2%20%5Cvee%20(%5Cneg%20x_1%20%5Cwedge%20%5Cneg%20x_2)" alt="f (x_1, x_2) = x_1 \ vee x_2 \ vee (\ neg x_1 \ wedge \ neg x_2)">  constant: <br><table><thead><tr><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/x_1" alt="x_1"></div></th><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/x_2" alt="x_2"></div></th><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/f" alt="f"></div></th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  one </td></tr><tr><td>  0 </td><td>  one </td><td>  one </td></tr><tr><td>  one </td><td>  0 </td><td>  one </td></tr><tr><td>  one </td><td>  one </td><td>  one </td></tr></tbody></table><br></li><li><img src="https://tex.s2cms.ru/svg/f(x_1%2C%20x_2)%20%3D%20x_1%20%5Cwedge%20x_2" alt="f (x_1, x_2) = x_1 \ wedge x_2">  neither balanced nor constant: <br><table><thead><tr><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/x_1" alt="x_1"></div></th><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/x_2" alt="x_2"></div></th><th><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/f" alt="f"></div></th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  one </td><td>  0 </td></tr><tr><td>  one </td><td>  0 </td><td>  0 </td></tr><tr><td>  one </td><td>  one </td><td>  one </td></tr></tbody></table></li></ol><br>  The task is, of course, artificial and it is unlikely that someone will ever meet in practice, but it is a classic guide to the brave new world of quantum computing, and I don‚Äôt dare break traditions. <br><br><h3>  Classic deterministic solution </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8f8/a87/862/8f8a87862cc54ff3b5e80aa480a456d7.jpg" alt="bruteforce"></div><br>  Let's first solve the problem in the classical model of computation.  To do this, in the worst case, you need to call the function on <img src="https://tex.s2cms.ru/svg/2%5E%7Bn-1%7D%2B1" alt="2 ^ {n-1} +1">  arguments: exactly half and one more.  If all calculated values ‚Äã‚Äãare the same, then the function is obviously constant.  If there are at least two different results, the function is balanced.  The complexity of the deterministic algorithm is exponential and is <img src="https://tex.s2cms.ru/svg/O(2%5E%7Bn-1%7D%20%2B%201)" alt="O (2 ^ {n-1} + 1)">  . <br><br>  Algorithm in Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> product, starmap, tee <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairwise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs)</span></span></span><span class="hljs-function">:</span></span> a, b = tee(xs) next(b, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(a, b) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_constant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, n)</span></span></span><span class="hljs-function">:</span></span> m = <span class="hljs-number"><span class="hljs-number">2</span></span> ** (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, (x, y) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(pairwise(starmap(f, product({<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, repeat=n)))): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; m: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x != y: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><h3>  Classic probabilistic solution </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/577/689/b46/577689b46bf7415bb938b7a6a876ac66.jpg" alt="rasta"></div><br>  But what if, instead of half the arguments, we check a smaller number of them and make a verdict?  Exact answer will not be, but with what probability we make a mistake?  Let's say we calculated a function on <img src="https://tex.s2cms.ru/svg/k%20%3C%202%5E%7Bn-1%7D%20%2B%201" alt="k &amp; lt; 2 ^ {n-1} + 1">  arguments.  If among the values ‚Äã‚Äãof the function there are two different, then everything is simple - the function is balanced.  Otherwise, we declare it constant with probability <img src="https://tex.s2cms.ru/svg/p(k)%20%3C%201" alt="p (k) &amp; lt; one">  .  Suppose we are wrong and the function is actually balanced.  Calculate the probability of error <img src="https://tex.s2cms.ru/svg/1%20-%20p(k)" alt="1 - p (k)">  .  If we choose the arguments uniformly, then the probability that the two values ‚Äã‚Äãof the function are equal are the same, <img src="https://tex.s2cms.ru/svg/1%2F2" alt="1/2">  , and the probability to meet <img src="https://tex.s2cms.ru/svg/k" alt="k">  equal consecutive values ‚Äã‚Äãequal <img src="https://tex.s2cms.ru/svg/1%2F2%5Ek" alt="1/2 ^ k">  .  In this way: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/1%20-%20p(k)%20%3D%20%5Cfrac%7B1%7D%7B2%5Ek%7D%2C" alt="1 - p (k) = \ frac {1} {2 ^ k},"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/p(k)%20%3D%201%20-%20%5Cfrac%7B1%7D%7B2%5Ek%7D." alt="p (k) = 1 - \ frac {1} {2 ^ k}."></div><br>  Reverse function: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/k(p)%20%3D%20%5Clog_2%7B%5Cfrac%7B1%7D%7B1%20-%20p%7D%7D." alt="k (p) = \ log_2 {\ frac {1} {1 - p}}."></div><br>  With fixed <img src="https://tex.s2cms.ru/svg/p" alt="p">  the complexity of the classical probabilistic algorithm is constant and equal to <img src="https://tex.s2cms.ru/svg/O(%5Clog_2%7B%5Cfrac%7B1%7D%7B1%20-%20p%7D)%7D." alt="O (\ log_2 {\ frac {1} {1 - p})}.">  To be sure of the 99.99% response, you need to call the function only 14 times. <br><br>  Algorithm in Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> product, starmap, tee <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairwise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs)</span></span></span><span class="hljs-function">:</span></span> a, b = tee(xs) next(b, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(a, b) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_constant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, n, k=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">14</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> xs = list(product({<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, repeat=n)) random.shuffle(xs) xs = xs[:k] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairwise(starmap(f, xs)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x != y: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  And if I tell you that there is a constant deterministic solution with complexity <img src="https://tex.s2cms.ru/svg/O(1)" alt="O (1)">  allowing to call a function only once? <br><br>  However, before you consider it, you will have to digress ... <br><br><h2>  Because a vision softly creeping </h2><br><h3>  Myths </h3><br>  Before starting, I would like to discuss a few common myths associated with quantum computing: <br><br><ol><li>  <em>Quantum algorithms are hard.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cc9/401/f4c/cc9401f4c8704c0c831da7b4bfc4c00d.jpg" alt="difficult"></div><br>  Yes, they are difficult to synthesize, because it requires for this mathematical imagination and insight.  They are difficult to implement on real quantum computers: for this you need to know the physics perfectly and stay up late every day in the laboratory at the department.  But what exactly does not require any special knowledge and an incredible amount of zeal is their understanding.  I argue that <strong>everyone can understand quantum algorithms</strong> : they rely on extremely simple mathematics, accessible to any freshman.  All that is required of you - just a little time to study. <br><br></li><li>  <em>There are already quantum computers on thousands of qubits from D-Wave</em> <br>  No, these are not real quantum computers. <br><br></li><li>  <em>There is not a single real quantum computer.</em> <br>  No, there are.  In the laboratory, and they have only a few qubits. <br><br></li><li>  <em>Quantum computers will allow to solve problems that were previously unavailable.</em> <br>  No, the set of problems computable in the classical and quantum models coincide.  Quantum computing only reduces the complexity of a small subset of these problems. <br><br></li><li>  <em>On the Crysis quantum computer at max speeds will fly</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/70d/608/00c/70d60800c91e494088c3d8a4dfd73ddb.png" alt="wat"></div><br>  With the exception of a certain subset of problems that the quantum model of computation is capable of speeding up, the rest can be solved only by emulating a classical computer.  Which, as you understand, is very slow.  Crysis is likely to lag. <br><br></li><li>  <em>A quantum computer is a black box with input and output, looking into which you can ruin everything.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/33e/2a4/0e6/33e2a40e61d04be288d92eaef77d5601.jpg" alt="blackbox"></div><br>  If you are 12 years old, this analogy will fit.  In any other case, it, like all other analogies with boxes, cats, loops and electrons ‚Äúbound‚Äù by threads, so actively promoted in all popular science sources, only confuses, creates the illusion of false understanding and is more harmful than useful.  Discard these analogies. <br></li></ol><br><h3>  What for? </h3><br>  Why should an applied mathematics (programmer) be able to understand quantum algorithms at the application level?  Everything is simple, I am ready to offer you two reasons: <br><br><ol><li>  <strong>For self-development.</strong>  Why not? <br></li><li>  <strong>They are already coming.</strong>  They are quantum computers.  They are already near.  You will not have time to blink, as a couple will appear in the server of your company, and in a few more years in the form of a coprocessor in your laptop.  And there will be nowhere to run.  We'll have to program for them, call quantum coroutines.  And without understanding it is difficult to do, agree. <br></li></ol><br><h2>  I was sleeping </h2><br>  The most basic component of quantum computing is a quantum system.  <strong>A quantum system</strong> is a physical system, all of whose actions are comparable in magnitude with the Planck constant.  This definition and the fact that quantum systems obey the laws of <strong>matrix mechanics</strong> - all the knowledge that we need from physics.  Next - only math. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/344/060/c25/344060c251d14768a25bcc7b18a4fa46.jpg" alt="loldontinterrupt"></div><br>  Like any other physical system, a quantum system can be in a certain state.  All possible states of a quantum system form a <strong>Hilbert space</strong> <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D" alt="\ mathcal {H}">  over the field of complex numbers.  I hope the reader is familiar with the concept of complex numbers - their understanding is necessary everywhere in the future.  If not, I advise you to meet and come back.  The Hilbert space is a complete normed metric linear space with norm <img src="https://tex.s2cms.ru/svg/%5CVert%20x%20%5CVert%20%3D%20%5Csqrt%7B(x%2C%20x)%7D" alt="\ Vert x \ Vert = \ sqrt {(x, x)}">  where <img src="https://tex.s2cms.ru/svg/(x%2C%20y)" alt="(x, y)">  - scalar product.  In order from the end: <br><br><ol><li>  <strong>Linear (vector) space</strong> - a set of elements <img src="https://tex.s2cms.ru/svg/X" alt="X">  with the operations of addition of elements introduced on it <img src="https://tex.s2cms.ru/svg/x%20%2B%20y" alt="x + y">  and multiplications <img src="https://tex.s2cms.ru/svg/x%20%5Ccdot%20%5Clambda" alt="x \ cdot \ lambda">  on field item <img src="https://tex.s2cms.ru/svg/K" alt="K">  (in our case, the field of complex numbers).  These operations must be closed (the result must belong to the set <img src="https://tex.s2cms.ru/svg/X" alt="X">  ) and must be fulfilled 8 axioms.  View a full list of them, as well as get acquainted with the linear spaces I recommend <a href="http://pmpu.ru/vf4/linear_space">here</a> . <br><br></li><li>  In <strong>metric space</strong> <img src="https://tex.s2cms.ru/svg/X" alt="X">  for any items <img src="https://tex.s2cms.ru/svg/x%2C%20y%20%5Cin%20X" alt="x, y \ in X">  distance determined <img src="https://tex.s2cms.ru/svg/%5Crho(x%2C%20y)" alt="\ rho (x, y)">  which satisfies the requirements (the axioms of metric <br>  spaces): <br><br><ul><li><img src="https://tex.s2cms.ru/svg/%5Crho(x%2C%20y)%20%5Cgeqslant%200" alt="\ rho (x, y) \ geqslant 0">  , wherein <img src="https://tex.s2cms.ru/svg/%5Crho(x%2C%20y)%20%3D%200" alt="\ rho (x, y) = 0">  then and only if <img src="https://tex.s2cms.ru/svg/x" alt="x">  and <img src="https://tex.s2cms.ru/svg/y" alt="y">  match up; <br></li><li><img src="https://tex.s2cms.ru/svg/%5Crho(x%2C%20y)%20%3D%20%5Crho(y%2C%20x)" alt="\ rho (x, y) = \ rho (y, x)">  ; <br></li><li><img src="https://tex.s2cms.ru/svg/%5Crho(x%2C%20y)%20%5Cleqslant%20%5Crho(x%2C%20z)%20%2B%20%5Crho(z%2C%20y)" alt="\ rho (x, y) \ leqslant \ rho (x, z) + \ rho (z, y)">  - triangle inequality. <br></li></ul><br></li><li>  In <strong>normalized space</strong> <img src="https://tex.s2cms.ru/svg/X" alt="X">  for any item <img src="https://tex.s2cms.ru/svg/x%20%5Cin%20X" alt="x \ in X">  there is a real number <img src="https://tex.s2cms.ru/svg/%5CVert%20x%20%5CVert%20%5Cin%20R" alt="\ Vert x \ Vert \ in R">  , called its norm and satisfying, again, three axioms: <br><br><ul><li><img src="https://tex.s2cms.ru/svg/%5CVert%20x%20%5CVert%20%5Cgeqslant%200" alt="\ Vert x \ Vert \ geqslant 0">  , if <img src="https://tex.s2cms.ru/svg/%5CVert%20x%20%5CVert%20%3D%200" alt="\ Vert x \ Vert = 0">  then <img src="https://tex.s2cms.ru/svg/x%20%3D%200" alt="x = 0">  - zero element; <br></li><li><img src="https://tex.s2cms.ru/svg/%5CVert%20%5Clambda%20%5Ccdot%20x%20%5CVert%20%3D%20%5Cvert%20%5Clambda%20%5Cvert%20%5Ccdot%20%5CVert%20x%20%5CVert" alt="\ Vert \ lambda \ cdot x \ Vert = \ vert \ lambda \ vert \ cdot \ Vert x \ Vert">  ; <br></li><li><img src="https://tex.s2cms.ru/svg/%5CVert%20x%20%2B%20y%20%5CVert%20%5Cleqslant%20%5CVert%20x%20%5CVert%20%2B%20%5CVert%20y%20%5CVert" alt="\ Vert x + y \ Vert \ leqslant \ Vert x \ Vert + \ Vert y \ Vert">  . <br></li></ul><br></li></ol><br>  In the resulting space we introduce the scalar product that satisfies the usual requirements of the scalar product, we introduce the norm as shown above and obtain the Hilbert space. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f59/64d/eed/f5964deedb104f26839a9bd1f7b2b3ef.jpg" alt="hilbertalmost"></div><br>  Let us also discuss the concept of <strong>conjugate space</strong> .  Space conjugate to <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D" alt="\ mathcal {H}">  called space <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%5E*%7D" alt="\ mathcal {H ^ *}">  linear operators over <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D" alt="\ mathcal {H}">  .  What is a linear operator?  You can think of it as a generalization of a linear function: for a linear operator <img src="https://tex.s2cms.ru/svg/A%3A%20%5Cmathcal%7BH%7D%20%5Cto%20Y" alt="A: \ mathcal {H} \ to Y">  must be performed: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/A%20(%5Clambda_1%20x_1%20%2B%20%5Clambda_2%20x_2)%20%3D%20%5Clambda_1%20A%20x_1%20%2B%20%5Clambda_2%20A%20x_2%2C" alt="A (\ lambda_1 x_1 + \ lambda_2 x_2) = \ lambda_1 A x_1 + \ lambda_2 A x_2,"></div><br>  Where <img src="https://tex.s2cms.ru/svg/x_1%2C%20x_2%20%5Cin%20%5Cmathcal%7BH%7D" alt="x_1, x_2 \ in \ mathcal {H}">  , <img src="https://tex.s2cms.ru/svg/%5Clambda_1%2C%20%5Clambda_2%20%5Cin%20K" alt="\ lambda_1, \ lambda_2 \ in K">  .  (In fact, its norm should also be limited to a single hypersphere, but in order to avoid a dozen more cumbersome definitions, we restrict ourselves to such an intuitive notion.) <br><br>  For historical reasons, Dirac is used in quantum informatics.  They may seem unreasonably cumbersome and fanciful, but they are a standard worth adhering to.  In these notation, an element of our Hilbert space that describes the state of the system is called a <strong>ket vector</strong> and is denoted by <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%5Cin%20%5Cmathcal%7BH%7D." alt="\ left | \ psi \ right \ rangle \ in \ mathcal {H}."></div><br>  <strong>Sconce vector</strong> is an element of the conjugate space <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Clangle%5Cleft%20%5Cphi%20%5Cright%7C%20%5Cin%20%5Cmathcal%7BH%5E*%7D%2C" alt="\ langle \ left \ phi \ right | \ in \ mathcal {H ^ *},"></div><br>  such that <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/(%5Clangle%5Cleft%20%5Cphi%20%5Cright%7C)%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%20(%5Cleft%7C%20%5Cphi%20%5Cright%5Crangle%2C%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle)%20%3D%20%5Clangle%5Cleft%20%5Cphi%20%7C%20%5Cpsi%20%5Cright%5Crangle." alt="(\ langle \ left \ phi \ right |) \ left | \ psi \ right \ rangle = (\ left | \ phi \ right \ rangle, \ left | \ psi \ right \ rangle) = \ langle \ left \ phi | \ psi \ right \ rangle."></div><br>  That is, it is a linear operator, the application of which to our state vector is similar to the scalar product on the corresponding element of the ‚Äúoriginal‚Äù Hilbert space.  For convenience of writing, when applying the bra-vector to the ket vector, the two vertical lines merge into one, as shown in the expression above. <br><br>  It is important that the vectors differing only by multiplying by some non-zero constant correspond to the same physical state, therefore, not all possible states are often considered, but only the normalized ones, that is, such a subset <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D" alt="\ mathcal {H}">  , what <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Clangle%5Cleft%20%5Cpsi%20%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%201" alt="\ langle \ left \ psi | \ psi \ right \ rangle = 1"></div><br>  - the norm of each element is equal to one.  All such vectors live on a single hypersphere. <br><br>  If we isolate in our Hilbert state space some basis <img src="https://tex.s2cms.ru/svg/%5C%7B%5Cleft%7C%20e_i%20%5Cright%5Crangle%5C%7D_%7Bi%3D1%7D%5Em%20%5Csubset%20%5Cmathcal%7BH%7D" alt="\ {\ left | e_i \ right \ rangle \} _ {i = 1} ^ m \ subset \ mathcal {H}">  then we can write any ket vector in the form of a vector of complex numbers - coefficients of its expansion in this basis: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%20%5Csum_%7Bi%3D1%7D%5Em%7B%5Clangle%5Cleft%20e_i%20%7C%20%5Cpsi%20%5Cright%5Crangle%20%5Cleft%7C%20e_i%20%5Cright%5Crangle%7D%2C" alt="\ left | \ psi \ right \ rangle = \ sum_ {i = 1} ^ m {\ langle \ left e_i | \ psi \ right \ rangle \ left | e_i \ right \ rangle},"></div><br>  in this case, the matrix mechanics tells us that the squares of the modules of the coefficients of the decomposition <img src="https://tex.s2cms.ru/svg/%5Cvert%20%5Clangle%5Cleft%20e_i%20%7C%20%5Cpsi%20%5Cright%5Crangle%20%5Cvert%5E2" alt="\ vert \ langle \ left e_i | \ psi \ right \ rangle \ vert ^ 2">  physically means the <strong>probabilities of finding a quantum system in the corresponding basic state when measured in this basis</strong> . <br><br>  Here it is - the <strong>first and main property of quantum systems</strong> , which is so often gnawed in popular articles: if you measure the system in some basis, it will go into one of the basic states, lose information and will not be able to go back.  It‚Äôs only when reading it that one gets the feeling that everything happens absolutely randomly and cannot be influenced in any way, whereas in fact the transition probabilities are known in advance and, moreover, depend on the measurement basis.  If everything were as random as we are supposed to be, deterministic quantum algorithms would be impossible. <br><br>  If we can represent an element of the Hilbert space as a vector for some fixed basis, then we can represent the linear operator over this space as a matrix. <br><br>  Really, <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/A%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%20%5Csum_%7Bi%3D1%7D%5Em%7B%5Clangle%5Cleft%20e_i%20%7C%20%5Cpsi%20%5Cright%5Crangle%20A%20%5Cleft%7C%20e_i%20%5Cright%5Crangle%7D" alt="A \ left | \ psi \ right \ rangle = \ sum_ {i = 1} ^ m {\ langle \ left e_i | \ psi \ right \ rangle A \ left | e_i \ right \ rangle}"></div><br>  is equivalent to <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/A%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%20%5Chat%7BA%7D%20%5Chat%7B%5Cpsi%7D%2C" alt="A \ left | \ psi \ right \ rangle = \ hat {A} \ hat {\ psi},"></div><br>  Where <img src="https://tex.s2cms.ru/svg/%5Chat%7BA%7D" alt="\ hat {A}">  obtained by the alternate use of the operator <img src="https://tex.s2cms.ru/svg/A" alt="A">  to basic elements <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20e_i%20%5Cright%5Crangle" alt="\ left | e_i \ right \ rangle">  and writing the resulting elements in rows, and <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Cpsi%7D" alt="\ hat {\ psi}">  - decomposition <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle" alt="\ left | \ psi \ right \ rangle">  in the same basis. <br><br>  Let the operator <img src="https://tex.s2cms.ru/svg/A" alt="A">  seems to be a matrix <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/A%20%3D%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%20a_%7B11%7D%20%26%20a_%7B12%7D%20%26%20a_%7B13%7D%20%26%20%5Cdots%20%20%26%20a_%7B1m%7D%20%5C%5C%0A%20%20%20%20a_%7B21%7D%20%26%20a_%7B22%7D%20%26%20a_%7B23%7D%20%26%20%5Cdots%20%20%26%20a_%7B2m%7D%20%5C%5C%0A%20%20%20%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%20%20%20%20a_%7Bm1%7D%20%26%20a_%7Bm2%7D%20%26%20a_%7Bm3%7D%20%26%20%5Cdots%20%20%26%20a_%7Bmm%7D%0A%5Cend%7Bpmatrix%7D." alt="A = \ begin {pmatrix} a_ {11} &amp; amp; a_ {12} &amp; amp; a_ {13} &amp; amp; \ dots &amp; amp; a_ {1m} \\ a_ {21} &amp; amp; a_ {22} &amp; amp; a_ {23} &amp; amp; \ dots &amp; amp; a_ {2m} \\ \ vdots &amp; amp; \ vdots &amp; amp; \ vdots &amp; amp; \ ddots &amp; amp; \ vdots \\ a_ {m1} &amp; amp; a_ {m2} &amp; amp; a_ {m3} &amp; amp; \ dots &amp; amp; a_ {mm} \ end {pmatrix}."></div><br>  Matrix elements are complex numbers.  Let's take each element and replace it with complex conjugate (complex conjugate to <img src="https://tex.s2cms.ru/svg/x%20%2B%20iy" alt="x + iy">  called number <img src="https://tex.s2cms.ru/svg/x%20-%20iy" alt="x - iy">  ) and, at the same time, we transpose the entire matrix: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/A%5E%5Cdagger%20%3D%20%5Coverline%7BA%7D%5ET%20%3D%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%20%5Coverline%7Ba_%7B11%7D%7D%20%26%20%5Coverline%7Ba_%7B21%7D%7D%20%26%20%5Coverline%7Ba_%7B31%7D%7D%20%26%20%5Cdots%20%20%26%20%5Coverline%7Ba_%7Bm1%7D%7D%20%5C%5C%0A%20%20%20%20%5Coverline%7Ba_%7B12%7D%7D%20%26%20%5Coverline%7Ba_%7B22%7D%7D%20%26%20%5Coverline%7Ba_%7B32%7D%7D%20%26%20%5Cdots%20%20%26%20%5Coverline%7Ba_%7Bm2%7D%7D%20%5C%5C%0A%20%20%20%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%20%20%20%20%5Coverline%7Ba_%7B1m%7D%7D%20%26%20%5Coverline%7Ba_%7B2m%7D%7D%20%26%20%5Coverline%7Ba_%7B3m%7D%7D%20%26%20%5Cdots%20%20%26%20%5Coverline%7Ba_%7Bmm%7D%7D%0A%5Cend%7Bpmatrix%7D." alt="A ^ \ dagger = \ overline {A} ^ T = \ begin {pmatrix} \ overline {a_ {11}} &amp; amp; \ overline {a_ {21}} &amp; amp; \ overline {a_ {31}} &amp; amp; \ dots &amp; amp; \ overline {a_ {m1}} \\ \ overline {a_ {12}} &amp; amp; \ overline {a_ {22}} &amp; amp; \ overline {a_ {32}} &amp; amp; \ dots &amp; amp; \ overline {a_ {m2}} \\ \ vdots &amp; amp; \ vdots &amp; amp; \ vdots &amp; amp; \ ddots &amp; amp; \ vdots \\ \ overline {a_ {1m}} &amp; amp; \ overline {a_ {2m}} &amp; amp; \ overline {a_ {3m}} &amp; amp; \ dots &amp; amp; \ overline {a_ {mm}} \ end {pmatrix}."></div><br>  Such a matrix <img src="https://tex.s2cms.ru/svg/A%5E%5Cdagger" alt="A ^ \ dagger">  called <strong>Hermitian conjugate</strong> <img src="https://tex.s2cms.ru/svg/A" alt="A">  .  If a <img src="https://tex.s2cms.ru/svg/A%20A%5E%5Cdagger%20%3D%20A%5E%5Cdagger%20A%20%3D%20I" alt="A A ^ \ dagger = A ^ \ dagger A = I">  where <img src="https://tex.s2cms.ru/svg/I" alt="I">  - the unit operator (with the unit matrix), then the corresponding operator is called <strong>unitary</strong> . <br><br>  <strong>The second rule that matrix mechanics dictates to us</strong> : only unitary operators can act on a quantum system.  Why?  Because such transformations are reversible in time and do not lose information.  Indeed, if <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/U%20%5Cleft%7C%20%5Cpsi_0%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%20%5Cpsi_1%20%5Cright%5Crangle%2C" alt="U \ left | \ psi_0 \ right \ rangle = \ left | \ psi_1 \ right \ rangle,"></div><br>  then you can apply the inverse transform <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/U%5E%5Cdagger%20%5Cleft%7C%20%5Cpsi_1%20%5Cright%5Crangle%20%3D%20U%5E%5Cdagger%20U%20%5Cleft%7C%20%5Cpsi_0%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%20%5Cpsi_0%20%5Cright%5Crangle" alt="U ^ \ dagger \ left | \ psi_1 \ right \ rangle = U ^ \ dagger U \ left | \ psi_0 \ right \ rangle = \ left | \ psi_0 \ right \ rangle"></div><br>  and get the initial state of the system. <br><br>  Finally, the most important: <strong>tensor product</strong> .  The tensor product of two Hilbert spaces <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_1" alt="\ mathcal {H} _1">  and <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_2" alt="\ mathcal {H} _2">  called Hilbert space, denoted by <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_1%20%5Cotimes%20%5Cmathcal%7BH%7D_2" alt="\ mathcal {H} _1 \ otimes \ mathcal {H} _2">  .  I will not give a formal definition, just note the important properties for us: <br><br><ol><li>  The dimension of the resulting space is equal to the product of the dimensions of the original spaces: <br><img src="https://tex.s2cms.ru/svg/%5Cdim%7B%5Cmathcal%7BH%7D_1%20%5Cotimes%20%5Cmathcal%7BH%7D_2%24%7D%20%3D%20%5Cdim%7B%5Cmathcal%7BH%7D_1%7D%20%5Ccdot%20%5Cdim%7B%5Cmathcal%7BH%7D_2%7D" alt="\ dim {\ mathcal {H} _1 \ otimes \ mathcal {H} _2 $} = \ dim {\ mathcal {H} _1} \ cdot \ dim {\ mathcal {H} _2}">  ; <br></li><li>  If a <img src="https://tex.s2cms.ru/svg/%5C%7B%5Cleft%7C%20e_i%20%5Cright%5Crangle%5C%7D_%7Bi%3D1%7D%5Em" alt="\ {\ left | e_i \ right \ rangle \} _ {i = 1} ^ m">  - basis <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_1" alt="\ mathcal {H} _1">  , but <img src="https://tex.s2cms.ru/svg/%5C%7B%5Cleft%7C%20f_i%20%5Cright%5Crangle%5C%7D_%7Bi%3D1%7D%5En" alt="\ {\ left | f_i \ right \ rangle \} _ {i = 1} ^ n">  - basis <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_2" alt="\ mathcal {H} _2">  then <img src="https://tex.s2cms.ru/svg/%5C%7B%5Cleft%7C%20e_i%20%5Cotimes%20f_j%20%5Cright%5Crangle%5C%7D_%7Bi%3D1%2C%20j%3D1%7D%5E%7Bm%2C%20n%7D" alt="\ {\ left | e_i \ otimes f_j \ right \ rangle \} _ {i = 1, j = 1} ^ {m, n}">  - generating basis <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_1%20%5Cotimes%20%5Cmathcal%7BH%7D_2" alt="\ mathcal {H} _1 \ otimes \ mathcal {H} _2">  . <br></li></ol><br>  <strong>By tensor products of operators</strong> <img src="https://tex.s2cms.ru/svg/A" alt="A">  of <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_1%5E*" alt="\ mathcal {H} _1 ^ *">  and <img src="https://tex.s2cms.ru/svg/B" alt="B">  of <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_2%5E*" alt="\ mathcal {H} _2 ^ *">  (operator <img src="https://tex.s2cms.ru/svg/A" alt="A">  represented by the matrix shown above) is called the operator <img src="https://tex.s2cms.ru/svg/A%20%5Cotimes%20B" alt="A \ otimes B">  of <img src="https://tex.s2cms.ru/svg/%5Cbig%5B%20%5Cmathcal%7BH%7D_1%20%5Cotimes%20%5Cmathcal%7BH%7D_2%20%5Cbig%5D%5E*" alt="\ big [\ mathcal {H} _1 \ otimes \ mathcal {H} _2 \ big] ^ *">  with matrix <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AA%20%5Cotimes%20B%20%3D%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%20a_%7B11%7D%20%5Ccdot%20B%20%26%20a_%7B12%7D%20%5Ccdot%20B%20%26%20a_%7B13%7D%20%5Ccdot%20B%20%26%20%5Cdots%20%20%26%20a_%7B1m%7D%20%5Ccdot%20B%20%5C%5C%0A%20%20%20%20a_%7B21%7D%20%5Ccdot%20B%20%26%20a_%7B22%7D%20%5Ccdot%20B%20%26%20a_%7B23%7D%20%5Ccdot%20B%20%26%20%5Cdots%20%20%26%20a_%7B2m%7D%20%5Ccdot%20B%20%5C%5C%0A%20%20%20%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%20%20%20%20a_%7Bm1%7D%20%5Ccdot%20B%20%26%20a_%7Bm2%7D%20%5Ccdot%20B%20%26%20a_%7Bm3%7D%20%5Ccdot%20B%20%26%20%5Cdots%20%20%26%20a_%7Bmm%7D%20%5Ccdot%20B%0A%5Cend%7Bpmatrix%7D.%0A" alt="A \ otimes B = \ begin {pmatrix} a_ {11} \ cdot B &amp; amp; a_ {12} \ cdot B &amp; amp; a_ {13} \ cdot B &amp; amp; \ dots &amp; amp; a_ {1m} \ cdot B \\ a_ {21} \ cdot B &amp; amp; a_ {22} \ cdot B &amp; amp; a_ {23} \ cdot B &amp; amp; \ dots &amp; amp; a_ {2m} \ cdot B \\ \ vdots &amp; amp; \ vdots &amp; amp; \ vdots &amp; amp; \ ddots &amp; amp; \ vdots \\ a_ {m1} \ cdot B &amp; amp; a_ {m2} \ cdot B &amp; amp; a_ {m3} \ cdot B &amp; amp; \ dots &amp; amp; a_ {mm} \ cdot B \ end {pmatrix}."></div><br>  Such a product is also called a Kronecker product: we multiply the second matrix by each element of the first matrix and from the resulting blocks we compose a block matrix.  If dimension A was equal <img src="https://tex.s2cms.ru/svg/n_1%20%5Ctimes%20n_2" alt="n_1 \ times n_2">  , and dimensionality B was equal <img src="https://tex.s2cms.ru/svg/m_1%20%5Ctimes%20m_2" alt="m_1 \ times m_2">  then the dimension of the matrix obtained in the course of the tensor product will be equal to <img src="https://tex.s2cms.ru/svg/n_1%20%5Ccdot%20m_1%20%5Ctimes%20n_2%20%5Ccdot%20m_2" alt="n_1 \ cdot m_1 \ times n_2 \ cdot m_2">  . <br><br>  <em>Example:</em> <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AA%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%26%202%20%5C%5C%0A%20%20%20%203%20%26%200%0A%5Cend%7Bbmatrix%7D%2C%5C%3B%0AB%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%26%201%20%5C%5C%0A%20%20%20%201%20%26%202%0A%5Cend%7Bbmatrix%7D%2C%0A" alt="A = \ begin {bmatrix} 1 &amp; amp; 2 \\ 3 &amp; amp; 0 \ end {bmatrix}, \; B = \ begin {bmatrix} 1 &amp; amp; 1 \\ 1 &amp; amp; 2 \ end {bmatrix},"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AA%20%5Cotimes%20B%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%5Ccdot%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%201%20%26%201%20%5C%5C%0A%20%20%20%201%20%26%202%0A%5Cend%7Bpmatrix%7D%20%26%202%20%5Ccdot%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%201%20%26%201%20%5C%5C%0A%20%20%20%201%20%26%202%0A%5Cend%7Bpmatrix%7D%20%5C%5C%0A%20%20%20%203%20%5Ccdot%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%201%20%26%201%20%5C%5C%0A%20%20%20%201%20%26%202%0A%5Cend%7Bpmatrix%7D%20%26%200%20%5Ccdot%20%5Cbegin%7Bpmatrix%7D%0A%20%20%20%201%20%26%201%20%5C%5C%0A%20%20%20%201%20%26%202%0A%5Cend%7Bpmatrix%7D%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%26%201%20%26%202%20%26%202%20%5C%5C%0A%20%20%20%201%20%26%202%20%26%202%20%26%204%20%5C%5C%0A%20%20%20%203%20%26%203%20%26%200%20%26%200%20%5C%5C%0A%20%20%20%203%20%26%206%20%26%200%20%26%200%20%5C%5C%0A%5Cend%7Bbmatrix%7D.%0A" alt="A \ otimes B = \ begin {bmatrix} 1 \ cdot \ begin {pmatrix} 1 &amp; amp; 1 \\ 1 &amp; amp; 2 \ end {pmatrix} &amp; amp; 2 \ cdot \ begin {pmatrix} 1 &amp; amp; 1 \\ 1 &amp; amp; 2 \ end {pmatrix} \\ 3 \ cdot \ begin {pmatrix} 1 &amp; amp; 1 \\ 1 &amp; amp; 2 \ end {pmatrix} &amp; amp; 0 \ cdot \ begin {pmatrix} 1 &amp; amp; 1 \\ 1 &amp; amp; 2 \ end {pmatrix} \ end {bmatrix} = \ begin {bmatrix} 1 &amp; amp; 1 &amp; amp; 2 &amp; amp; 2 \\ 1 &amp; amp; 2 &amp; amp; 2 &amp; amp; 4 \\ 3 &amp; amp; 3 &amp; amp; 0 &amp; amp; 0 \\ 3 &amp; amp; 6 &amp; amp; 0 &amp; amp; 0 \\ \ end {bmatrix}."></div><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AA%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%5Cend%7Bbmatrix%7D%2C%5C%3B%0AB%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%5C%5C%0A%20%20%20%202%0A%5Cend%7Bbmatrix%7D%2C%0A" alt="A = \ begin {bmatrix} 1 \\ 0 \\ \ end {bmatrix}, \; B = \ begin {bmatrix} 1 \\ 2 \ end {bmatrix},"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AA%20%5Cotimes%20B%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%5C%5C%0A%20%20%20%202%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%5Cend%7Bbmatrix%7D.%0A" alt="A \ otimes B = \ begin {bmatrix} 1 \\ 2 \\ 0 \\ 0 \\ \ end {bmatrix}."></div><br>  <strong>The third important property of quantum systems</strong> : two quantum systems can be in a state of <strong>superposition</strong> , while the new state space is the tensor product of the original spaces, and the state of the new system will be the tensor product of the states of the original systems.  So, the superposition of systems in the states <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%5Cin%20%5Cmathcal%7BH%7D_1" alt="\ left | \ psi \ right \ rangle \ in \ mathcal {H} _1">  and <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cphi%20%5Cright%5Crangle%20%5Cin%20%5Cmathcal%7BH%7D_2" alt="\ left | \ phi \ right \ rangle \ in \ mathcal {H} _2">  there will be a new system in the state <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%5Cotimes%20%5Cleft%7C%20%5Cphi%20%5Cright%5Crangle" alt="\ left | \ psi \ right \ rangle \ otimes \ left | \ phi \ right \ rangle">  described by a Hilbert space <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D_1%20%5Cotimes%20%5Cmathcal%7BH%7D_2" alt="\ mathcal {H} _1 \ otimes \ mathcal {H} _2">  . <br><br><h2>  And the vision </h2><br>  That's all the math that we need.  Just in case, summarizing: <br><br><ol><li>  For a fixed basis, the quantum system can be described by a complex vector, and the evolution of this system can be described by a unitary complex matrix; <br></li><li>  A quantum system can be measured in some basis and it will go into one of the basic states according to predetermined probabilities. <br></li></ol><br>  It turns out that in order to describe, study, understand and emulate quantum algorithms on a classical computer, you just need to multiply matrices by vectors - <strong>it is even simpler than neural networks</strong> : there are no nonlinearities here! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f5d/15a/e2b/f5d15ae2bdf5414aa67eabab5592eb1f.jpg" alt="woooho"></div><br><h3>  Qubit </h3><br>  Let's look at <em>some</em> quantum system described by a two-dimensional Hilbert space <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D%5E2" alt="\ mathcal {H} ^ 2">  and select in it <em>some</em> basis, the vectors of which are denoted as <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%200%20%5Cright%5Crangle" alt="\ left | 0 \ right \ rangle">  and <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%201%20%5Cright%5Crangle" alt="\ left | 1 \ right \ rangle">  .  Inside the parentheses, the index of the basis vector in the binary number system is written, starting with zero without additional characters.  Such designations will be very convenient.  In this way, <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%5C%5C%0A%20%20%20%200%20%0A%5Cend%7Bbmatrix%7D%2C%5C%3B%0A%5Cleft%7C%201%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%200%20%5C%5C%0A%20%20%20%201%20%0A%5Cend%7Bbmatrix%7D%2C%0A" alt="\ left | 0 \ right \ rangle = \ begin {bmatrix} 1 \\ 0 \ end {bmatrix}, \; \ left | 1 \ right \ rangle = \ begin {bmatrix} 0 \\ 1 \ end {bmatrix},"></div><br>  and arbitrary vector <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%5Cin%20%5Cmathcal%7BH%7D%5E2" alt="\ left | \ psi \ right \ rangle \ in \ mathcal {H} ^ 2">  can be expressed as follows: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%20%5Calpha%20%5Cleft%7C%200%20%5Cright%5Crangle%20%2B%20%5Cbeta%20%5Cleft%7C%201%20%5Cright%5Crangle%2C" alt="\ left | \ psi \ right \ rangle = \ alpha \ left | 0 \ right \ rangle + \ beta \ left | 1 \ right \ rangle,"></div><br>  Where <img src="https://tex.s2cms.ru/svg/%5Calpha" alt="\ alpha">  and <img src="https://tex.s2cms.ru/svg/%5Cbeta" alt="\ beta">  - some complex numbers such that <img src="https://tex.s2cms.ru/svg/%5Cvert%20%5Calpha%20%5Cvert%5E2%20%2B%20%5Cvert%20%5Cbeta%20%5Cvert%5E2%20%3D%201" alt="\ vert \ alpha \ vert ^ 2 + \ vert \ beta \ vert ^ 2 = 1">  (remember the interpretation of the decomposition coefficients and the normalization condition from the previous section).  So, such a simple quantum system is called a <strong>qubit</strong> ( <strong>quantum bit</strong> , <strong>qbit</strong> ).  A qubit is an analogue of a classic bit in a quantum computation model.  It is easy to see that the space of all possible states of a single qubit <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D%5E2" alt="\ mathcal {H} ^ 2">  is a three-dimensional sphere, called the Bloch sphere, where <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%200%20%5Cright%5Crangle" alt="\ left | 0 \ right \ rangle">  corresponds to the lower pole, and <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%201%20%5Cright%5Crangle" alt="\ left | 1 \ right \ rangle">  - top. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c59/aba/e08/c59abae082214d7db57caab0decac738.png" alt="sphere"></div><br><br><h3>  Register </h3><br>  A single qubit, like a single bit, is too boring, so we immediately consider the superposition of several qubits.  Such a superposition is called a <strong>quantum register</strong> ( <strong>quantum register</strong> , <strong>qregister</strong> ) of <img src="https://tex.s2cms.ru/svg/n" alt="n">  qubits.  For example, a quantum register of 2 qubits will be described by the space <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D%5E4" alt="\ mathcal {H} ^ 4">  and have 4 basic states: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%2000%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%200%20%5Cright%5Crangle%20%5Cotimes%20%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%0A%5Cend%7Bbmatrix%7D%2C" alt="\ left | 00 \ right \ rangle = \ left | 0 \ right \ rangle \ otimes \ left | 0 \ right \ rangle = \ begin {bmatrix} 1 \\ 0 \\ 0 \\ 0 \ end {bmatrix},"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%2001%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%200%20%5Cright%5Crangle%20%5Cotimes%20%5Cleft%7C%201%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%200%20%5C%5C%0A%20%20%20%201%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%0A%5Cend%7Bbmatrix%7D%2C" alt="\ left | 01 \ right \ rangle = \ left | 0 \ right \ rangle \ otimes \ left | 1 \ right \ rangle = \ begin {bmatrix} 0 \\ 1 \\ 0 \\ 0 \ end {bmatrix},"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%2010%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%201%20%5Cright%5Crangle%20%5Cotimes%20%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%201%20%5C%5C%0A%20%20%20%200%0A%5Cend%7Bbmatrix%7D%2C" alt="\ left | 10 \ right \ rangle = \ left | 1 \ right \ rangle \ otimes \ left | 0 \ right \ rangle = \ begin {bmatrix} 0 \\ 0 \\ 1 \\ 0 \ end {bmatrix},"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%2011%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%201%20%5Cright%5Crangle%20%5Cotimes%20%5Cleft%7C%201%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%200%20%5C%5C%0A%20%20%20%201%0A%5Cend%7Bbmatrix%7D." alt="\ left | 11 \ right \ rangle = \ left | 1 \ right \ rangle \ otimes \ left | 1 \ right \ rangle = \ begin {bmatrix} 0 \\ 0 \\ 0 \\ 1 \ end {bmatrix}."></div><br>  Accordingly, any state of such a register <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cphi%20%5Cright%5Crangle%20%5Cin%20%5Cmathcal%7BH%7D%5E4" alt="\ left | \ phi \ right \ rangle \ in \ mathcal {H} ^ 4">  can be represented as <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cphi%20%5Cright%5Crangle%20%3D%20%5Calpha_1%20%5Cleft%7C%2000%20%5Cright%5Crangle%20%2B%20%5Calpha_2%20%5Cleft%7C%2001%20%5Cright%5Crangle%20%2B%20%5Calpha_3%20%5Cleft%7C%2010%20%5Cright%5Crangle%20%2B%20%5Calpha_4%20%5Cleft%7C%2011%20%5Cright%5Crangle%2C" alt="\ left | \ phi \ right \ rangle = \ alpha_1 \ left | 00 \ right \ rangle + \ alpha_2 \ left | 01 \ right \ rangle + \ alpha_3 \ left | 10 \ right \ rangle + \ alpha_4 \ left | 11 \ right \ rangle,"></div><br>  Where <img src="https://tex.s2cms.ru/svg/%5Cvert%20%20%5Calpha_1%20%5Cvert%5E2%20%2B%20%5Cvert%20%20%5Calpha_2%20%5Cvert%5E2%20%2B%20%5Cvert%20%20%5Calpha_3%20%5Cvert%5E2%20%2B%20%5Cvert%20%20%5Calpha_4%20%5Cvert%5E2%20%3D%201" alt="\ vert \ alpha_1 \ vert ^ 2 + \ vert \ alpha_2 \ vert ^ 2 + \ vert \ alpha_3 \ vert ^ 2 + \ vert \ alpha_4 \ vert ^ 2 = 1">  .  Notice that in our notation, a basis vector with a unit on <img src="https://tex.s2cms.ru/svg/k" alt="k">  the second place is indicated by a number <img src="https://tex.s2cms.ru/svg/k" alt="k">  recorded in binary form. <br><br>  Further similar.  Quantum register of <img src="https://tex.s2cms.ru/svg/m" alt="m">  qubits will be described <img src="https://tex.s2cms.ru/svg/2%5Em" alt="2 ^ m">  -dimensional Hilbert space <img src="https://tex.s2cms.ru/svg/%5Cmathcal%7BH%7D%5E%7B2%5Em%7D" alt="\ mathcal {H} ^ {2 ^ m}">  to have <img src="https://tex.s2cms.ru/svg/2%5Em" alt="2 ^ m">  basic states formed in a similar way.  Without delay, let's learn how to emulate quantum registers: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QRegister</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n_qbits, init)</span></span></span><span class="hljs-function">:</span></span> self._n = n_qbits <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(init) == self._n self._data = np.zeros((<span class="hljs-number"><span class="hljs-number">2</span></span> ** self._n), dtype=np.complex64) self._data[int(<span class="hljs-string"><span class="hljs-string">'0b'</span></span> + init, <span class="hljs-number"><span class="hljs-number">2</span></span>)] = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  3 lines of code to create a quantum register is not at all difficult, agree.  You can use this way: <br><br><pre> <code class="python hljs">a = QRegister(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># |0&gt; b = QRegister(1, '1') # |1&gt; c = QRegister(3, '010') # |010&gt;</span></span></code> </pre><br>  <strong>The quantum algorithm</strong> includes: <br><br><ol><li>  Initialization of the quantum register; <br></li><li>  A set of unitary transformations over it; <br></li><li>  Measurement result. <br></li></ol><br><h3>  Measurement </h3><br>  We figured out the first item and learned how to emulate it, now let's learn how to emulate the last one: measurement.  As you remember, the squares of the state vector coefficients physically mean the probabilities of transition to this state.  In accordance with this, we are implementing a new method in the QRegister class: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> probs = np.real(self._data) ** <span class="hljs-number"><span class="hljs-number">2</span></span> + np.imag(self._data) ** <span class="hljs-number"><span class="hljs-number">2</span></span> states = np.arange(<span class="hljs-number"><span class="hljs-number">2</span></span> ** self._n) mstate = np.random.choice(states, size=<span class="hljs-number"><span class="hljs-number">1</span></span>, p=probs)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{mstate:&gt;</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">{self._n}</span></span></span><span class="hljs-string">b}'</span></span></code> </pre><br>  We generate probabilities of <code>probs</code> choosing one of <img src="https://tex.s2cms.ru/svg/2%5En" alt="2 ^ n">  <code>states</code> and randomly select it using <code>np.random.choice</code> .  It remains only to return the binary string with the corresponding number of padding zeros.  It is obvious that for basic states the answer will always be the same and equal to this state itself.  Check: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>QRegister(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>).measure() <span class="hljs-string"><span class="hljs-string">'0'</span></span> &gt;&gt;&gt; QRegister(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'10'</span></span>).measure() <span class="hljs-string"><span class="hljs-string">'10'</span></span> &gt;&gt;&gt; QRegister(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'01001101'</span></span>).measure() <span class="hljs-string"><span class="hljs-string">'01001101'</span></span></code> </pre><br>  Almost everything is ready to solve our problem!  It remains only to learn how to influence the quantum registers.  We already know that this can be done by unitary transformations.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In quantum informatics, the unitary transformation is called a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quantum gate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qgate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gates </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, we consider only a small number of the most basic gates, which will be useful to us. </font><font style="vertical-align: inherit;">In fact, they are much more.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A single gate is the easiest one to look at. </font><font style="vertical-align: inherit;">Its matrix is ‚Äã‚Äãas follows:</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/I%20%3D%20%5Cbegin%7Bbmatrix%7D%0A%20%20%20%201%20%26%200%5C%5C%0A%20%20%20%200%20%26%201%0A%5Cend%7Bbmatrix%7D." alt="I = \begin{bmatrix}
    1 &amp;amp; 0\\
    0 &amp;amp; 1
\end{bmatrix}."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It does not change the qubit on which it acts: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/I%20%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%200%20%5Cright%5Crangle%2C%5C%3B%20I%20%5Cleft%7C%201%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%201%20%5Cright%5Crangle%2C%20%5C%3B%20I%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%20%5Cpsi%20%5Cright%5Crangle%2C" alt="I \left| 0 \right\rangle = \left| 0 \right\rangle,\; I \left| 1 \right\rangle = \left| 1 \right\rangle, \; I \left| \psi \right\rangle = \left| \psi \right\rangle,"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, you should not consider it useless - we will need it more than once. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gate Hadamard </font></font></h4><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/H%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%201%5C%5C%0A1%20%26%20-1%0A%5Cend%7Bbmatrix%7D" alt="H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 &amp;amp; 1\\
1 &amp;amp; -1
\end{bmatrix}"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is easy to verify that the matrix is ‚Äã‚Äãunitary: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/H%20H%5E%5Cdagger%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%201%5C%5C%0A1%20%26%20-1%0A%5Cend%7Bbmatrix%7D%20%5Ccdot%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%201%5C%5C%0A1%20%26%20-1%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cbegin%7Bbmatrix%7D%0A2%20%26%200%5C%5C%0A0%20%26%202%0A%5Cend%7Bbmatrix%7D%20%3D%20I." alt="H H^\dagger = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 &amp;amp; 1\\
1 &amp;amp; -1
\end{bmatrix} \cdot \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 &amp;amp; 1\\
1 &amp;amp; -1
\end{bmatrix} = \frac{1}{2} \begin{bmatrix}
2 &amp;amp; 0\\
0 &amp;amp; 2
\end{bmatrix} = I."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider the effect of Hadamard gate on basic qubits: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AH%20%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%201%5C%5C%0A1%20%26%20-1%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%5C%5C%0A0%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%5C%5C%0A1%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%20(%5Cleft%7C%200%20%5Cright%5Crangle%20%2B%20%5Cleft%7C%201%20%5Cright%5Crangle)%2C%0A" alt="H \left| 0 \right\rangle = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 &amp;amp; 1\\
1 &amp;amp; -1
\end{bmatrix}
\begin{bmatrix}
1\\
0
\end{bmatrix} = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1\\
1
\end{bmatrix} = \frac{1}{\sqrt{2}} (\left| 0 \right\rangle + \left| 1 \right\rangle),"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AH%20%5Cleft%7C%201%20%5Cright%5Crangle%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%201%5C%5C%0A1%20%26%20-1%0A%5Cend%7Bbmatrix%7D%0A%5Cbegin%7Bbmatrix%7D%0A0%5C%5C%0A1%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%5C%5C%0A-1%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%20(%5Cleft%7C%200%20%5Cright%5Crangle%20-%20%5Cleft%7C%201%20%5Cright%5Crangle).%0A" alt="H \left| 1 \right\rangle = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 &amp;amp; 1\\
1 &amp;amp; -1
\end{bmatrix}
\begin{bmatrix}
0\\
1
\end{bmatrix} = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1\\
-1
\end{bmatrix} = \frac{1}{\sqrt{2}} (\left| 0 \right\rangle - \left| 1 \right\rangle)."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Or in general terms [1]: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AH%20%5Cleft%7C%20x%20%5Cright%5Crangle%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%20%5Csum_%7By%20%5Cin%20%5Clbrace%200%2C1%20%5Crbrace%7D%20(-1)%5E%7Bx%20%5Ccdot%20y%7D%20%5Cleft%7C%20y%20%5Cright%5Crangle.%0A" alt="H \left| x \right\rangle = \frac{1}{\sqrt{2}} \sum_{y \in \lbrace 0,1 \rbrace} (-1)^{x \cdot y} \left| y \right\rangle."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you can see, Hadamard's gate translates any baseline state into equally probable - when measuring with equal probability, you can get any result. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gates of Pauli </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Three extremely important gates to which the matrices introduced by Wolfgang Pauli correspond: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AX%20%3D%0A%5Cbegin%7Bbmatrix%7D%0A0%20%26%201%5C%5C%0A1%20%26%200%0A%5Cend%7Bbmatrix%7D%2C%5C%3B%0AY%20%3D%0A%5Cbegin%7Bbmatrix%7D%0A0%20%26%20-i%5C%5C%0Ai%20%26%200%0A%5Cend%7Bbmatrix%7D%2C%5C%3B%0AZ%20%3D%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%200%5C%5C%0A0%20%26%20-1%0A%5Cend%7Bbmatrix%7D.%0A" alt="X =
\begin{bmatrix}
0 &amp;amp; 1\\
1 &amp;amp; 0
\end{bmatrix},\;
Y =
\begin{bmatrix}
0 &amp;amp; -i\\
i &amp;amp; 0
\end{bmatrix},\;
Z =
\begin{bmatrix}
1 &amp;amp; 0\\
0 &amp;amp; -1
\end{bmatrix}."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gate is </font></font><img src="https://tex.s2cms.ru/svg/X" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also called NOT-gate:</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/X%20%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%201%20%5Cright%5Crangle%2C%20%5C%3B%20X%20%5Cleft%7C%201%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%200%20%5Cright%5Crangle%2C" alt="X \left| 0 \right\rangle = \left| 1 \right\rangle, \; X \left| 1 \right\rangle = \left| 0 \right\rangle,"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and its geometrical use is equivalent to a rotation on the Bloch sphere by </font></font><img src="https://tex.s2cms.ru/svg/%5Cpi" alt="\pi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radians around an axis</font></font><img src="https://tex.s2cms.ru/svg/x" alt="x">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/106/b9f/479/106b9f4794c1455ba0cce4e424b4fbb1.png" alt="X gate"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gates </font></font><img src="https://tex.s2cms.ru/svg/Y" alt="Y">  and <img src="https://tex.s2cms.ru/svg/Z" alt="Z"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar to the gate, </font></font><img src="https://tex.s2cms.ru/svg/X" alt="X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the exception that the rotation is performed around the corresponding axis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a theorem according to which with the help of gates</font></font><img src="https://tex.s2cms.ru/svg/I" alt="I">  , <img src="https://tex.s2cms.ru/svg/X" alt="X">  , <img src="https://tex.s2cms.ru/svg/Y" alt="Y">  and <img src="https://tex.s2cms.ru/svg/Z" alt="Z"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Any one quit gate can be expressed. </font></font> For example: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/H%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cbig(X%20%2B%20Z%5Cbig)%2C" alt="H = \frac{1}{\sqrt{2}}\big(X + Z\big),"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where you can see that Hadamard gate geometrically means rotation on </font></font><img src="https://tex.s2cms.ru/svg/%5Cpi" alt="\pi"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radians around the axis</font></font><img src="https://tex.s2cms.ru/svg/%5Cfrac%7Bx%20%2B%20z%7D%7B%5Csqrt%7B2%7D%7D" alt="\frac{x + z}{\sqrt{2}}">  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implement all the considered gates in Python. </font><font style="vertical-align: inherit;">To do this, create another class:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QGate</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, matrix)</span></span></span><span class="hljs-function">:</span></span> self._data = np.array(matrix, dtype=np.complex64) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(self._data.shape) == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> self._data.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] == self._data.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] self._n = np.log2(self._data.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> self._n.is_integer() self._n = int(self._n)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the class </font></font><code>QRegister</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we add the operation of applying the gate:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, gate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> isinstance(gate, QGate) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> self._n == gate._n self._data = gate._data @ self._data</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And create already known to us gates: </font></font><br><br><pre> <code class="python hljs">I = QGate([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]]) H = QGate(np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>]]) / np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>)) X = QGate([[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]]) Y = QGate([[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1j</span></span>], [<span class="hljs-number"><span class="hljs-number">1j</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]]) Z = QGate([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>]])</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Heads or tails? </font></font></h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a95/84e/28b/a9584e28be9e436d8fc74e08eaa75d87.jpg" alt="coin"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us consider, for example, the simplest quantum algorithm: it will generate a random bit - zero or one, eagle or tails. </font><font style="vertical-align: inherit;">It will be the most honest coin in the universe - the result will be known only when measuring, and the nature of randomness is sewn into the very foundation of the universe and cannot be influenced by it in any way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the algorithm we need only one qubit. </font><font style="vertical-align: inherit;">Let it be in the initial moment of time</font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%200%20%5Cright%5Crangle" alt="\left| 0 \right\rangle">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cbegin%7Bbmatrix%7D%0A1%5C%5C%0A0%0A%5Cend%7Bbmatrix%7D." alt="\left| 0 \right\rangle = \begin{bmatrix}
1\\
0
\end{bmatrix}."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now apply the Hadamard gate to it </font></font><img src="https://tex.s2cms.ru/svg/H" alt="H"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get the state</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/H%20%5Cleft%7C%200%20%5Cright%5Crangle%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%0A%5Cbegin%7Bbmatrix%7D%0A1%5C%5C%0A1%0A%5Cend%7Bbmatrix%7D." alt="H \left| 0 \right\rangle = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1\\
1
\end{bmatrix}."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we now measure the resulting system, with probability </font></font><img src="https://tex.s2cms.ru/svg/%5CBig%5Cvert%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%20%5CBig%5Cvert%5E2%20%3D%20%5Cfrac%7B1%7D%7B2%7D" alt="\Big\vert \frac{1}{\sqrt{2}} \Big\vert^2 = \frac{1}{2}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will be able </font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%200%20%5Cright%5Crangle" alt="\left| 0 \right\rangle"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and with exactly the same probability as</font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%201%20%5Cright%5Crangle" alt="\left| 1 \right\rangle">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains only to record the result. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's check the algorithm by emulating it on our classic computer:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> quantum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QRegister, H <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quantum_randbit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> a = QRegister(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>) a.apply(H) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.measure() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">32</span></span>): print(quantum_randbit(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>) print()</code> </pre><br>  Results: <br><br><pre> <code class="hljs mel">‚ûú <span class="hljs-keyword"><span class="hljs-keyword">python</span></span> example-randbit.py <span class="hljs-number"><span class="hljs-number">11110011101010111010011100000111</span></span> ‚ûú <span class="hljs-keyword"><span class="hljs-keyword">python</span></span> example-randbit.py <span class="hljs-number"><span class="hljs-number">01110000111100011000101010100011</span></span> ‚ûú <span class="hljs-keyword"><span class="hljs-keyword">python</span></span> example-randbit.py <span class="hljs-number"><span class="hljs-number">11111110011000001101010000100000</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All the above algorithm can be written with a pair of formulas: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20q_0%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%200%20%5Cright%5Crangle%5C%5C%0A%5Cleft%7C%20q_1%20%5Cright%5Crangle%20%3D%20H%20%5Cleft%7C%20q_0%20%5Cright%5Crangle%5C%5C%0Ar%20%3D%20measure(%5Cleft%7C%20q_1%20%5Cright%5Crangle)" alt="\left| q_0 \right\rangle = \left| 0 \right\rangle\\
\left| q_1 \right\rangle = H \left| q_0 \right\rangle\\
r = measure(\left| q_1 \right\rangle)"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it is not very convenient to work with such a record: the structure of the list is a sequence of actions that is well suited for classical algorithms, is not applicable in the quantum case: here we have neither cycles nor conditions, only state flow forward (and sometimes back) in time . </font><font style="vertical-align: inherit;">Therefore, quantum schemes are widely used to describe algorithms in quantum computer science. </font><font style="vertical-align: inherit;">Here is a diagram of the above algorithm:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/files/948/fae/19a/948fae19a82143a38d555dafaadbc610.png" alt="simple"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the left is always indicated the initial state of the system. </font><font style="vertical-align: inherit;">Unitary transformations performed on this state are indicated in the rectangles, and at the end a measuring instrument icon is placed on all or on several qubits - a measurement operation. </font><font style="vertical-align: inherit;">There is also a ‚Äúsyntactic sugar‚Äù for some multi-qubit transformations in the form of points, ramifications, and circles.</font></font> And that's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you can distinguish a square from a triangle and a circle, you will easily understand any scheme of the quantum algorithm. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6a7/cfa/3be/6a7cfa3be5a94797921995caab6514c8.jpg" alt="holes"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> More qubits to qubit god </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what if we work not with one qubit, but with their whole register? </font><font style="vertical-align: inherit;">And, let's say, we want to apply the gate only to one qubit? </font><font style="vertical-align: inherit;">The properties of the tensor product come to the rescue. </font><font style="vertical-align: inherit;">By definition, the tensor product of an operator</font></font><img src="https://tex.s2cms.ru/svg/A%3A%20V%20%5Cto%20W" alt="A: V \to W">  and <img src="https://tex.s2cms.ru/svg/B%3A%20X%20%5Cto%20Y" alt="B: X \to Y">  : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/(A%20%5Cotimes%20B)(v%20%5Cotimes%20x)%20%3D%20Av%20%5Cotimes%20Bx%2C" alt="(A \otimes B)(v \otimes x) = Av \otimes Bx,"></div><br>  Where <img src="https://tex.s2cms.ru/svg/v%20%5Cin%20V" alt="v \in V">  , <img src="https://tex.s2cms.ru/svg/x%20%5Cin%20X" alt="x \in X">  .  Then: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/(A%20%5Cotimes%20I)(v%20%5Cotimes%20x)%20%3D%20Av%20%5Cotimes%20Ix%20%3D%20Av%20%5Cotimes%20x%2C" alt="(A \otimes I)(v \otimes x) = Av \otimes Ix = Av \otimes x,"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that is, it doesn't matter if you apply the gate to one qubit, and then connect it with the second one and get a quantum register, or apply the operator to the whole register </font></font><img src="https://tex.s2cms.ru/svg/A%20%5Cotimes%20I" alt="A \otimes I">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, if we want to apply the operator </font></font><img src="https://tex.s2cms.ru/svg/A" alt="A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only to the second qubit, we can apply the operator to the whole register</font></font><img src="https://tex.s2cms.ru/svg/I%20%5Cotimes%20A" alt="I \otimes A">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This means that this scheme: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/516/0a8/eb8/5160a8eb80bb42beb992a7d61e01f56e.png" alt="example0"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Completely similar to this: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c6d/d1d/24d/c6dd1d24d1b94ef39563df9068dba258.png" alt="example1"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only single gates are omitted for convenience. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if we, on the contrary, want to apply the gate to several qubits at once? </font><font style="vertical-align: inherit;">Again, from the definition of a tensor product, for this we can apply this gate to them, the tensor multiplied by itself the necessary number of times:</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/Hv%20%5Cotimes%20Hx%20%3D%20(H%20%5Cotimes%20H)%20(v%20%5Cotimes%20x)%20%3D%20H%5E%7B%5Cotimes2%7D%20(v%20%5Cotimes%20x)." alt="Hv \otimes Hx = (H \otimes H) (v \otimes x) = H^{\otimes2} (v \otimes x)."></div><br><img src="https://tex.s2cms.ru/svg/A%5E%7B%5Cotimes%20n%7D" alt="A^{\otimes n}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> means tensor exponentiation. </font></font> By the way <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%20%5Cright%20%5Crangle%5E%7B%5Cotimes%20n%7D" alt="\left| \psi \right \rangle^{\otimes n}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for brevity, recorded as </font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%5Cpsi%5En%20%5Cright%20%5Crangle" alt="\left| \psi^n \right \rangle">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this way, </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/H%5E%7B%5Cotimes%20n%7D%20%5Cleft%7C%200%5En%20%5Cright%20%5Crangle" alt="H^{\otimes n} \left| 0^n \right \rangle"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means: </font></font><img src="https://tex.s2cms.ru/svg/n" alt="n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apply a Hadamard transform </font><font style="vertical-align: inherit;">to each qubit of the quantum register of </font><font style="vertical-align: inherit;">zero qubits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a tensor product and exponentiation to ours </font></font><code>QGate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__matmul__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QGate(np.kron(self._data, other._data)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__pow__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n, modulo=None)</span></span></span><span class="hljs-function">:</span></span> x = self._data.copy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n - <span class="hljs-number"><span class="hljs-number">1</span></span>): x = np.kron(x, self._data) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QGate(x)</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quantum oracle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each binary function </font></font><img src="https://tex.s2cms.ru/svg/f%20%3A%20%5C%7B0%2C%201%5C%7D%5En%20%5Cto%20%5C%7B0%2C%201%5C%7D" alt="f : \{0, 1\}^n \to \{0, 1\}"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponds to a single multi-qubit gate of dimension </font></font><img src="https://tex.s2cms.ru/svg/n%20%2B%201" alt="n + 1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is denoted </font></font><img src="https://tex.s2cms.ru/svg/U_f" alt="U_f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and called the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quantum oracle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for this function. </font><font style="vertical-align: inherit;">It contains all the information about the function </font></font><img src="https://tex.s2cms.ru/svg/f" alt="f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and ‚Äúallows‚Äù to simultaneously call it on all of its possible arguments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is its dimension</font></font><img src="https://tex.s2cms.ru/svg/n%20%2B%201" alt="n + 1">  ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The thing is that according to another fundamental property of quantum computing, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">information is not lost</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in them </font><font style="vertical-align: inherit;">and they are reversible in time. </font><font style="vertical-align: inherit;">If we call a function in the classical computational model </font></font><img src="https://tex.s2cms.ru/svg/f(x%2C%20y)%20%3D%20x%20%5Coplus%20y" alt="f(x, y) = x \oplus y"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and get the result, then we can‚Äôt tell with one of which arguments the function was called and, accordingly, we cannot invert the computations in time.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/847/f41/ec1/847f41ec1fd14bcc95a54a97ee5f8b5c.png" alt="diagram0"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One way to avoid this is to memorize the arguments with which the function was invoked. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5c3/293/8c2/5c32938c25824ab48dbb7d2f3fb18381.png" alt="diagram1"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same thing happens in the quantum model of computation, only there it is embedded in their very nature - without saving the complete information, it is impossible to build a unitary transformation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A quantum oracle is </font></font><img src="https://tex.s2cms.ru/svg/U_f" alt="U_f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined as a unitary transformation that transforms a state </font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20x%20%5Cright%20%5Crangle%20%5Cleft%7C%20y%20%5Cright%20%5Crangle" alt="\left| x \right \rangle \left| y \right \rangle"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into a state</font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20x%20%5Cright%20%5Crangle%20%5Cleft%7C%20y%20%5Coplus%20f(x)%20%5Cright%20%5Crangle" alt="\left| x \right \rangle \left| y \oplus f(x) \right \rangle">  where <img src="https://tex.s2cms.ru/svg/n" alt="n"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qubits, denoted </font></font><img src="https://tex.s2cms.ru/svg/x" alt="x"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, carry information about the function argument and remain unchanged, and the only qubit </font></font><img src="https://tex.s2cms.ru/svg/y" alt="y"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- its result. </font></font><img src="https://tex.s2cms.ru/svg/%5Coplus" alt="\oplus"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denotes addition modulo 2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at an example. </font><font style="vertical-align: inherit;">Suppose we want to build an oracle for a function of one argument</font></font><img src="https://tex.s2cms.ru/svg/f(x)%20%3D%20x" alt="f(x) = x">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hence, the corresponding operator </font></font><img src="https://tex.s2cms.ru/svg/U_f" alt="U_f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be two-qubit and can be described by a square matrix of dimension</font></font><img src="https://tex.s2cms.ru/svg/2%5E2%20%3D%204" alt="2^2 = 4">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In accordance with the rule described above, let's see into which states all the basic register states should go: </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%7C%2000%20%5Cright%20%5Crangle%20%20%3D%20%5Cleft%7C%200%20%5Cright%20%5Crangle%20%5Cleft%7C%200%20%5Cright%20%5Crangle%20%5Cto%20%5Cleft%7C%200%20%5Cright%20%5Crangle%20%5Cleft%7C%200%20%5Coplus%20f(0)%20%5Cright%20%5Crangle%20%3D%20%5Cleft%7C%2000%20%5Cright%20%5Crangle%0A" alt="\left| 00 \right \rangle  = \left| 0 \right \rangle \left| 0 \right \rangle \to \left| 0 \right \rangle \left| 0 \oplus f(0) \right \rangle = \left| 00 \right \rangle"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%7C%2001%20%5Cright%20%5Crangle%20%20%3D%20%5Cleft%7C%200%20%5Cright%20%5Crangle%20%5Cleft%7C%201%20%5Cright%20%5Crangle%20%5Cto%20%5Cleft%7C%200%20%5Cright%20%5Crangle%20%5Cleft%7C%200%20%5Coplus%20f(1)%20%5Cright%20%5Crangle%20%3D%20%5Cleft%7C%2001%20%5Cright%20%5Crangle%0A" alt="\left| 01 \right \rangle  = \left| 0 \right \rangle \left| 1 \right \rangle \to \left| 0 \right \rangle \left| 0 \oplus f(1) \right \rangle = \left| 01 \right \rangle"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%7C%2010%20%5Cright%20%5Crangle%20%20%3D%20%5Cleft%7C%201%20%5Cright%20%5Crangle%20%5Cleft%7C%200%20%5Cright%20%5Crangle%20%5Cto%20%5Cleft%7C%201%20%5Cright%20%5Crangle%20%5Cleft%7C%201%20%5Coplus%20f(0)%20%5Cright%20%5Crangle%20%3D%20%5Cleft%7C%2011%20%5Cright%20%5Crangle%0A" alt="\left| 10 \right \rangle  = \left| 1 \right \rangle \left| 0 \right \rangle \to \left| 1 \right \rangle \left| 1 \oplus f(0) \right \rangle = \left| 11 \right \rangle"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cleft%7C%2011%20%5Cright%20%5Crangle%20%20%3D%20%5Cleft%7C%201%20%5Cright%20%5Crangle%20%5Cleft%7C%201%20%5Cright%20%5Crangle%20%5Cto%20%5Cleft%7C%201%20%5Cright%20%5Crangle%20%5Cleft%7C%201%20%5Coplus%20f(1)%20%5Cright%20%5Crangle%20%3D%20%5Cleft%7C%2010%20%5Cright%20%5Crangle%0A" alt="\left| 11 \right \rangle  = \left| 1 \right \rangle \left| 1 \right \rangle \to \left| 1 \right \rangle \left| 1 \oplus f(1) \right \rangle = \left| 10 \right \rangle"></div><br>          ,       <img src="https://tex.s2cms.ru/svg/i" alt="i"> -    <img src="https://tex.s2cms.ru/svg/i" alt="i"> -           .     <img src="https://tex.s2cms.ru/svg/i" alt="i"> -     <img src="https://tex.s2cms.ru/svg/j" alt="j"> -  ,   ,   <img src="https://tex.s2cms.ru/svg/j" alt="j"> -      ,    <img src="https://tex.s2cms.ru/svg/i" alt="i"> -   .         <img src="https://tex.s2cms.ru/svg/%7B00%7D_2%20%3D%200" alt="{00}_2 = 0">  and <img src="https://tex.s2cms.ru/svg/%7B01%7D_2%20%3D%201" alt="{01}_2 = 1">       <img src="https://tex.s2cms.ru/svg/%7B10%7D_2%20%3D%203" alt="{10}_2 = 3">  and <img src="https://tex.s2cms.ru/svg/%7B11%7D_2%20%3D%204" alt="{11}_2 = 4"> .  Then <img src="https://tex.s2cms.ru/svg/U_f" alt="U_f">    : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AU_f%20%3D%20%5Cbegin%7Bbmatrix%7D%0A1%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%201%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%200%20%26%201%5C%5C%0A0%20%26%200%20%26%201%20%26%200%5C%5C%0A%5Cend%7Bbmatrix%7D.%0A" alt="U_f = \begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\
\end{bmatrix}."></div><br> : <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cbegin%7Bbmatrix%7D%0A1%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%201%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%200%20%26%201%5C%5C%0A0%20%26%200%20%26%201%20%26%200%5C%5C%0A%5Cend%7Bbmatrix%7D%5Cbegin%7Bbmatrix%7D%0Ax_%7B00%7D%20%5C%5C%0Ax_%7B01%7D%20%5C%5C%0Ax_%7B10%7D%20%5C%5C%0Ax_%7B11%7D%20%5C%5C%0A%5Cend%7Bbmatrix%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%0Ax_%7B00%7D%20%5C%5C%0Ax_%7B01%7D%20%5C%5C%0Ax_%7B11%7D%20%5C%5C%0Ax_%7B10%7D%20%5C%5C%0A%5Cend%7Bbmatrix%7D.%0A" alt="\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\
\end{bmatrix}\begin{bmatrix}
x_{00} \\
x_{01} \\
x_{10} \\
x_{11} \\
\end{bmatrix} = \begin{bmatrix}
x_{00} \\
x_{01} \\
x_{11} \\
x_{10} \\
\end{bmatrix}."></div><br>        .  : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">U</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, n)</span></span></span><span class="hljs-function">:</span></span> m = n + <span class="hljs-number"><span class="hljs-number">1</span></span> U = np.zeros((<span class="hljs-number"><span class="hljs-number">2</span></span>**m, <span class="hljs-number"><span class="hljs-number">2</span></span>**m), dtype=np.complex64) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bin2int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs)</span></span></span><span class="hljs-function">:</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(reversed(xs)): r += x * <span class="hljs-number"><span class="hljs-number">2</span></span> ** i <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> xs <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> product({<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, repeat=m): x = xs[:~<span class="hljs-number"><span class="hljs-number">0</span></span>] y = xs[~<span class="hljs-number"><span class="hljs-number">0</span></span>] z = y ^ f(*x) instate = bin2int(xs) outstate = bin2int(list(x) + [z]) U[instate, outstate] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QGate(U)</code> </pre><br><h2> Still remains </h2><br>       ,              ,      . ,      ,    ,    ‚Äî .          1985   ,         1992     .    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/67a/0d5/1ee/67a0d51eec354b5da2e7ce1d08c74d16.png" alt="dj"></div><br>     0,   ,  ‚Äî .   : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> quantum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QRegister, H, I, U <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_constant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, n)</span></span></span><span class="hljs-function">:</span></span> q = QRegister(n + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span> * n + <span class="hljs-string"><span class="hljs-string">'1'</span></span>) q.apply(H ** (n + <span class="hljs-number"><span class="hljs-number">1</span></span>)) q.apply(U(f, n)) q.apply(H ** n @ I) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> q.measure()[:~<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'0'</span></span> * n: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br>  : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x ^ y <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> print(<span class="hljs-string"><span class="hljs-string">'f(x) = x is {}'</span></span>.format(<span class="hljs-string"><span class="hljs-string">'constant'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_constant(f1, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'balansed'</span></span>)) print(<span class="hljs-string"><span class="hljs-string">'f(x) = 1 is {}'</span></span>.format(<span class="hljs-string"><span class="hljs-string">'constant'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_constant(f2, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'balansed'</span></span>)) print(<span class="hljs-string"><span class="hljs-string">'f(x, y) = x ^ y is {}'</span></span>.format(<span class="hljs-string"><span class="hljs-string">'constant'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_constant(f3, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'balansed'</span></span>)) print(<span class="hljs-string"><span class="hljs-string">'f(x, y, z) = 0 is {}'</span></span>.format(<span class="hljs-string"><span class="hljs-string">'constant'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_constant(f4, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'balansed'</span></span>))</code> </pre><br>  Result: <br><br><pre> <code class="hljs cs">f(x) = <span class="hljs-function"><span class="hljs-function">x </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">is</span></span></span><span class="hljs-function"> balansed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">is</span></span></span><span class="hljs-function"> constant </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> = x ^ <span class="hljs-function"><span class="hljs-function">y </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">is</span></span></span><span class="hljs-function"> balansed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">)</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> constant</code> </pre><br>  Works.  Wonderful.    ?          . <br><br>    <img src="https://tex.s2cms.ru/svg/H" alt="H">        [1]: <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AH%5E%7B%5Cotimes%20n%7D%20%5Cleft%7Cx_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%5Crangle%20%3D%0A" alt="H^{\otimes n} \left|x_1, x_2, \ldots, x_n\right\rangle ="></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (by the property of a tensor product) </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%3D%20H%20%5Cleft%7C%20x_1%20%5Cright%5Crangle%20%5Cotimes%20H%20%5Cleft%7C%20x_2%20%5Cright%5Crangle%20%5Cotimes%20%5Cdots%20%5Cotimes%20H%20%5Cleft%7C%20x_n%20%5Cright%5Crangle%20%3D%0A" alt="= H \left| x_1 \right\rangle \otimes H \left| x_2 \right\rangle \otimes \dots \otimes H \left| x_n \right\rangle ="></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (applicable to every single qubit) </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5En%7D%7D%20%5CBig(%5Csum%20%5Climits_%7By_1%20%5Cin%20%5Clbrace%200%2C1%20%5Crbrace%7D%20(-1)%5E%7Bx_1%20%5Ccdot%20y_1%7D%20%5Cleft%7C%20y_1%20%5Cright%5Crangle%20%5Cotimes%20%5Csum%20%5Climits_%7By_2%20%5Cin%20%5Clbrace%200%2C1%20%5Crbrace%7D%20(-1)%5E%7Bx_2%20%5Ccdot%20y_2%7D%20%5Cleft%7C%20y_2%20%5Cright%5Crangle%20%5Cotimes%20%5Cldots%20%5Cotimes%20%5Csum%20%5Climits_%7By_n%20%5Cin%20%5Clbrace%200%2C1%20%5Crbrace%7D%20(-1)%5E%7Bx_n%20%5Ccdot%20y_n%7D%20%5Cleft%7C%20y_n%20%5Cright%5Crangle%20%5CBig)%20%3D%0A" alt="=\frac{1}{\sqrt{2^n}} \Big(\sum \limits_{y_1 \in \lbrace 0,1 \rbrace} (-1)^{x_1 \cdot y_1} \left| y_1 \right\rangle \otimes \sum \limits_{y_2 \in \lbrace 0,1 \rbrace} (-1)^{x_2 \cdot y_2} \left| y_2 \right\rangle \otimes \ldots \otimes \sum \limits_{y_n \in \lbrace 0,1 \rbrace} (-1)^{x_n \cdot y_n} \left| y_n \right\rangle \Big) ="></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (we take out -1 for the sign of the tensor product) </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5En%7D%7D%20%5Csum%20%5Climits_%7B(y_1%2C%20y_2%2C%20%5Cldots%2C%20y_n)%20%5Cin%20%5Clbrace%200%2C1%20%5Crbrace%5En%7D%20(-1)%5E%7Bx_1%20%5Ccdot%20y_1%20%5Coplus%20x_2%20%5Ccdot%20y_2%20%5Coplus%20%5Cdots%20%5Coplus%20x_n%20%5Ccdot%20y_n%7D%20%5Cleft%7C%20%7By_1%20y_2%20%5Cldots%20y_n%7D%20%5Cright%5Crangle%20%3D%0A" alt="=\frac{1}{\sqrt{2^n}} \sum \limits_{(y_1, y_2, \ldots, y_n) \in \lbrace 0,1 \rbrace^n} (-1)^{x_1 \cdot y_1 \oplus x_2 \cdot y_2 \oplus \dots \oplus x_n \cdot y_n} \left| {y_1 y_2 \ldots y_n} \right\rangle ="></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (redefine for compactness) </font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5En%7D%7D%20%5Csum%20%5Climits_%7By%20%5Cin%20%5Clbrace%200%2C1%20%5Crbrace%5En%7D%20(-1)%5E%7B(x%2C%20y)%7D%20%5Cleft%7C%20y%20%5Cright%5Crangle%2C%0A" alt="=\frac{1}{\sqrt{2^n}} \sum \limits_{y \in \lbrace 0,1 \rbrace^n} (-1)^{(x, y)} \left| y \right\rangle,"></div><br>  Where <img src="https://tex.s2cms.ru/svg/%5Coplus" alt="\oplus"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- addition modulo 2, and </font></font><img src="https://tex.s2cms.ru/svg/(x%2C%20y)" alt="(x, y)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- scalar product modulo 2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the initial moment of time the system is in a state </font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%7Bq_0%7D%20%5Cright%5Crangle%20%5Cleft%7C%20%7Bq_1%7D%20%5Cright%5Crangle%20%3D%20%5Cleft%7C%200%20%5Cright%5Crangle%5E%7B%5Cotimes%20n%7D%20%5Cleft%7C%201%20%5Cright%5Crangle" alt="\left| {q_0} \right\rangle \left| {q_1} \right\rangle = \left| 0 \right\rangle^{\otimes n} \left| 1 \right\rangle"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and under the action of the Hadamard transform will go into</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AH%5E%7B%5Cotimes%20n%7D%20%5Cleft%7C%200%20%5Cright%5Crangle%5E%7B%5Cotimes%20n%7D%20(H%20%5Cleft%7C%201%20%5Cright%5Crangle)%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5E%7Bn%2B1%7D%7D%7D%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20%5Cleft%7C%20x%20%5Cright%5Crangle%20%5Cbig(%5Cleft%7C%200%20%5Cright%5Crangle%20-%20%5Cleft%7C1%20%5Cright%5Crangle%20%5Cbig).%0A" alt="H^{\otimes n} \left| 0 \right\rangle^{\otimes n} (H \left| 1 \right\rangle) = \frac{1}{\sqrt{2^{n+1}}}\displaystyle\sum_{x=0}^{2^n} \left| x \right\rangle \big(\left| 0 \right\rangle - \left|1 \right\rangle \big)."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle will </font></font><img src="https://tex.s2cms.ru/svg/U_f" alt="U_f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">put the system in state</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5E%7Bn%2B1%7D%7D%7D%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20%5Cleft%7C%20x%20%5Cright%5Crangle%20%5CBig(%5Cleft%7C%20%7Bf(x)%7D%20%5Cright%5Crangle%20%5Coplus%20%5Cbig(%5Cleft%7C%200%20%5Cright%5Crangle%20-%20%5C%20%5Cleft%7C%201%20%5Cright%5Crangle%20%5Cbig)%20%5CBig)%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5E%7Bn%2B1%7D%7D%7D%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20%5Cleft%7C%20x%20%5Cright%5Crangle%20%5CBig(%20%5Cleft%7C%20%7Bf(x)%7D%20%5Cright%5Crangle%20-%20%5Cleft%7C%20%7Bf(x)%20%5Coplus%201%7D%20%5Cright%5Crangle%20%5CBig).%0A" alt="\frac{1}{\sqrt{2^{n+1}}}\displaystyle\sum_{x=0}^{2^n} \left| x \right\rangle \Big(\left| {f(x)} \right\rangle \oplus \big(\left| 0 \right\rangle - \ \left| 1 \right\rangle \big) \Big) = \frac{1}{\sqrt{2^{n+1}}}\displaystyle\sum_{x=0}^{2^n} \left| x \right\rangle \Big( \left| {f(x)} \right\rangle - \left| {f(x) \oplus 1} \right\rangle \Big)."></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that if at some fixed argument the </font></font><img src="https://tex.s2cms.ru/svg/x" alt="x"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function </font></font><img src="https://tex.s2cms.ru/svg/f(x)" alt="f (x)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes the value 0, then the coefficient before </font></font><img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20x%20%5Cright%5Crangle" alt="\left| x \right\rangle"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will not change, otherwise it will change the sign. </font><font style="vertical-align: inherit;">Based on this observation, you can rewrite the current state as</font></font><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5E%7Bn%2B1%7D%7D%7D%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20(-1)%5E%7Bf(x)%7D%20%5Cleft%7C%20x%20%5Cright%5Crangle%20%5Cbig(%20%5Cleft%7C%200%20%5Cright%5Crangle%20-%20%5Cleft%7C%201%20%5Cright%5Crangle%20%5Cbig).%0A" alt="\frac{1}{\sqrt{2^{n+1}}}\displaystyle\sum_{x=0}^{2^n} (-1)^{f(x)} \left| x \right\rangle \big( \left| 0 \right\rangle - \left| 1 \right\rangle \big)."></div><br>                <img src="https://tex.s2cms.ru/svg/n" alt="n"> ,    <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0AH%5E%7B%5Cotimes%20n%7D%20%5CBig(%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5En%7D%7D%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20(-1)%5E%7Bf(x)%7D%20%5Cleft%7C%20x%20%5Cright%5Crangle%20%5CBig)%20%3D%20%5Cfrac%7B1%7D%7B2%5En%7D%5Cdisplaystyle%5Csum_%7By%3D0%7D%5E%7B2%5En%7D%20%5CBig(%20%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20(-1)%5E%7Bf(x)%20%2B%20x%20%5Ccdot%20y%7D%20%5CBig)%20%5Cleft%7C%20y%20%5Cright%5Crangle.%0A" alt="H^{\otimes n} \Big( \frac{1}{\sqrt{2^n}}\displaystyle\sum_{x=0}^{2^n} (-1)^{f(x)} \left| x \right\rangle \Big) = \frac{1}{2^n}\displaystyle\sum_{y=0}^{2^n} \Big( \displaystyle\sum_{x=0}^{2^n} (-1)^{f(x) + x \cdot y} \Big) \left| y \right\rangle."></div><br>    <img src="https://tex.s2cms.ru/svg/x%20%5Ccdot%200%5En%20%3D%200" alt="x \cdot 0^n = 0"> ,    <img src="https://tex.s2cms.ru/svg/%5Cleft%7C%20%7B0%5En%7D%20%5Cright%5Crangle" alt="\left| {0^n} \right\rangle">  equals <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5Cfrac%7B1%7D%7B2%5En%7D%5Cdisplaystyle%5Csum_%7Bx%3D0%7D%5E%7B2%5En%7D%20(-1)%5E%7Bf(x)%7D%20%3D%20%0A%5Cbegin%7Bcases%7D%0A%20%20%201%20%26%5Ctext%7B%2C%20%D0%B5%D1%81%D0%BB%D0%B8%20%24f(x)%24%20%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%B0%7D%5C%5C%0A%20%20%200%20%26%5Ctext%7B%2C%20%D0%B5%D1%81%D0%BB%D0%B8%20%24f(x)%24%20%D1%81%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B0%7D%0A%5Cend%7Bcases%7D.%0A" alt="\frac{1}{2^n}\displaystyle\sum_{x=0}^{2^n} (-1)^{f(x)} = 
\begin{cases}
   1 &amp;amp;\text{,  $f(x)$ }\\
   0 &amp;amp;\text{,  $f(x)$ }
\end{cases}."></div><br>  That's all.       ,  -               ¬´¬ª   ‚Äî  -.    ,   ,      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ff6/569/ed2/ff6569ed2c604105b4c869851eebee86.jpg" alt="."></div><br> ‚Üí      <a href="https://github.com/meownoid/quantum-python">GitHub</a> <br><br>  Thanks for reading!  ,   ,  ,   .  . <br><br><h3>  Literature </h3><br><ul><li> [1] <em>. </em> , ¬´ :   <br> ¬ª <br></li><li> [2] <em>. . </em> , ¬´    ¬ª <br></li><li> [3] <em>MA Nielsen</em> , ¬´Quantum Information Theory¬ª <br></li></ul><br> <strong>PS</strong> :    ‚Äî .  Roman Parpalak   <a href="https://upmath.me/">upmath.me</a> ,          . </div><p>Source: <a href="https://habr.com/ru/post/321292/">https://habr.com/ru/post/321292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321280/index.html">The history of the development of TWIME - the new high-speed interface of the Moscow Exchange</a></li>
<li><a href="../321282/index.html">Riot loafers, or again about the accounting of working time</a></li>
<li><a href="../321286/index.html">Password recovery D-Link DPH-400S or the story of a small hack</a></li>
<li><a href="../321288/index.html">Undocumented features of Windows: breakpoints for registry keys</a></li>
<li><a href="../321290/index.html">The brilliance and poverty of test automation</a></li>
<li><a href="../321294/index.html">Browser Fingerprint - anonymous browser identification</a></li>
<li><a href="../321298/index.html">Free IOT & GPS service VIALATM</a></li>
<li><a href="../321302/index.html">How to remotely and centrally manage patches and software updates in the company</a></li>
<li><a href="../321304/index.html">Neurostream - a new chip for deep learning</a></li>
<li><a href="../321306/index.html">How does hashCode () work by default?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>