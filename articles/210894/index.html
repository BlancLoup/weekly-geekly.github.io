<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CRTP. Static polymorphism. MixIn. Reflections on the topic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post, I will reflect on the topic of static polymorphism in C ++, the architectural solutions built on its basis. Consider an interesting idio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CRTP. Static polymorphism. MixIn. Reflections on the topic</h1><div class="post__text post__text-html js-mediator-article">  In this post, I will reflect on the topic of static polymorphism in C ++, the architectural solutions built on its basis.  Consider an interesting idiom - <i>CRTP</i> .  I will give a few examples of its use.  In particular, I will consider the concept of <i>MixIn</i> classes.  I am writing to systematize my own knowledge, but maybe you can find something interesting for yourself. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  As you know, C ++ is a multi-paradigm language.  You can write in it in a procedural style, use language constructs that support object-oriented programming, templates allow generalized programming, <i>STL,</i> and new language features ( <i>lambda, std :: function, std :: bind</i> ), if you wish, you can write in a functional style in runtime, and template metaprogramming is a pure functional programming in <i>compile time</i> . <br>  Despite the fact that in any real large program you can most likely encounter a mixture of all these techniques, an object-oriented paradigm implemented using the concept of classes, an open interface and a closed implementation (encapsulation), inheritance, and dynamic polymorphism implemented through virtual functions, undoubtedly the most widely used. <br><br>  However, dynamic polymorphism is not free.  Despite the fact that the time spent on calling a virtual function is not too large, under certain circumstances, for example, a cycle that processes many polymorphic objects, the overhead of such a solution becomes noticeable compared to ordinary functions. <br><br><h4>  Static polymorphism </h4><br>  While dynamic polymorphism is a polymorphism of runtime and explicit interfaces, static polymorphism is a polymorphism of compile time and implicit interfaces.  Let's see what this means. <br>  Looking at the following code 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base* b)</span></span></span><span class="hljs-function"> </span></span>{ b-&gt;prepare(); b-&gt;work(); ... }</code> </pre> <br><br>  we can say the following: the pointer passed to the <i>process ()</i> function must point to an object that implements the interface (inherit) <i>base,</i> and the choice of implementations of the <i>prepare ()</i> and <i>work ()</i> functions will be made during the execution of the program depending on which object derived from <i>base</i> type indicates <i>b</i> . <br><br>  If we consider the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ t.prepare(); t.work(); }</code> </pre><br>  then we can say that, firstly, an object of type <i>T</i> must have the <i>prepare ()</i> and <i>work ()</i> functions, and secondly, the implementations of these functions will be selected at compile time based on the deduced real type of <i>T.</i> <br>  As you can see, for all the different approaches, the main (from a practical point of view) common feature of both types of polymorphism is that the client code does not need to change anything when working with objects of different types, provided that they meet the requirements described above. <br><br>  Since everything is so great, the code is not complicated in principle, the runtime overhead is leveled, why not completely replace dynamic polymorphism with a static one?  Unfortunately, as is usually the case, things are not so simple.  There are a number of both subjective and objective shortcomings of static polymorphism.  The subjective ones include, for example, the fact that an explicit interface often simplifies the life of developers, especially in large projects.  Having before your eyes a header file with a class - an interface that you need to implement is much more convenient than examining the code of template functions for what functions you need to implement and how to make this code work.  Imagine, moreover, that this code was written a long time ago and now there is no one to ask what was meant in one or another piece. <br><br>  Objective reasons can somehow be reduced to the fact that after instantiation, the template classes (functions) have different, often unconnected types. <br>  Why is that bad?  Objects of such types without additional tweaks (see <i>boost :: variant, boost :: tuple, boost :: any, boost :: fusion,</i> etc.) cannot be put into one container and therefore batch processed.  It is impossible, for example, to replace the object - a member of a class - with a different type of object, during the execution of the ‚ÄúStrategy‚Äù or ‚ÄúState‚Äù.  And although these patterns can be implemented in other ways without class hierarchies, for example, using <i>std :: function</i> or just <i>function</i> pointers, the restriction is, nevertheless, on the face. <br><br>  But no one forces us to strictly adhere to any one paradigm.  The most powerful, flexible and interesting solutions arise at the junction of these two approaches, at the junction of the PLO paradigm and <i>generic</i> paradigm.  The <i>CRTP</i> idiom is just one example of such a paradigm merger. <br><br><h4>  CRTP </h4><br>  <i>CRTP (Curiously Recurring Template Pattern)</i> is a design idiom, consisting in that the class inherits from the base template class with itself as a parameter of the template of the base class.  It sounds confusing, but the code looks pretty simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> base&lt;derived&gt; {};</code> </pre><br><br>  What can it give us?  This design makes it possible to refer to the derived class from the base. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;D*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;bar();} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">derived</span></span></span><span class="hljs-class"> :</span></span> base&lt;derived&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br><br>  And the possibility of such communication, in turn, opens up several interesting possibilities. <br><br><h4>  Explicit interface </h4><br>  In the chapter on static static polymorphism, I called the lack of explicit interfaces a subjective lack of static polymorphism.  On this topic, you can argue, but somehow, an explicit interface is easy to determine using <i>CRTP</i> .  Indeed, we can determine the set of required interface functions through calls to these functions from the base class. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">base_worker</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;D*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;work_impl();} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;D*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;prepare_impl();} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_concrete_worker</span></span></span><span class="hljs-class"> :</span></span> base_worker&lt;some_concrete_worker&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     void prepare_impl(); //    }; template&lt;typename Worker&gt; void polymorhic_work(const Worker&amp; w) { w.prepare(); w.work(); }; int main() { some_concrete_worker w1; some_concrete_worker_2 w2; polymorhic_work(w1); //     polymorhic_work(w2); //  prepare_impl()  work_impl()  w1  w2 }</span></span></code> </pre><br><br>  Using this design, one developer (architect) can define an interface of a certain set of classes, and the rest of the programmers will be guided by what to implement when implementing this interface.  But <i>CRTP</i> capabilities <i>are</i> not limited to this. <br><br><h4>  Mixin </h4><br>  <i>MixIn</i> is a design technique in which a class (interface, module, etc.) implements some functionality that can be ‚Äúmixed in‚Äù, introduced into another class.  <i>By itself</i> , the <i>MixIn</i> class is usually not used.  This technique is not C ++ specific, and in some other languages ‚Äã‚Äãit is supported at the level of language constructs. <br>  In C ++ there is no native support for <i>MixIn</i> 's, but nevertheless this idiom can be fully implemented using <i>CRTP</i> . <br>  For example, the <i>MixIn</i> class can implement the functionality of a singleton or object reference counting.  And in order to use such a class, it is enough to inherit from it with ‚Äúme‚Äù as a template parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">singleton</span></span></span><span class="hljs-class">{</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_class</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> singleton&lt;my_class&gt;{...};</code> </pre><br><br>  Why is CRTP here?  Why not just inherit from a class that implements some of the functionality we need? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">singleton</span></span></span><span class="hljs-class">{</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_class</span></span></span><span class="hljs-class"> :</span></span> singleton{...};</code> </pre><br><br>  The fact is that inside <i>MixIn</i> 'and we need access to the functions of the inherited class (in the case of a singleton to the constructor) and <i>CRTP</i> comes to the rescue <i>here</i> .  And if the example with the singleton seems far-fetched (really, who is using singleton today?), Then below you will find two examples closer to reality. <br><br><h5>  Enable_shared_from_this </h5><br>  <i>MixIn</i> structure <i>(boost) std :: enable_shared_from_this</i> allows you to get a <i>shared_ptr</i> to an object without creating a new group of ownership. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bad</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;bad&gt; get() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;bad&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} };</code> </pre><br><br>  In this case, each <i>shared_ptr</i> obtained using the function <i>bad :: get ()</i> opens a new group of ownership of the object, and when it is time to destroy <i>shared_ptr</i> 's, delete for our object will be called more than once. <br><br>  Correctly do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">good</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt;good&gt; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;good&gt; get() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shared_from_this(); <span class="hljs-comment"><span class="hljs-comment">//    //  enable_shared_from_this } };</span></span></code> </pre><br><br>  This supporting structure is organized like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_shared</span></span></span><span class="hljs-class"> {</span></span> weak_ptr&lt;T&gt; t_; enable_shared() { t_ = weak_ptr&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; shared_from_this() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;(t_); } };</code> </pre><br><br>  As you can see, here <i>CRTP</i> allows the base class to ‚Äúsee‚Äù the type of the derived class and return the pointer to it. <br><br><h5>  Mixin function </h5><br>  <i>MixIn</i> functionality does not have to be included inside a class.  Sometimes it is possible to implement it as a free function.  As an example, we implement the ‚Äú! =‚Äù Operator for all classes for which the == operator is defined. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">non_equalable</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> != (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> non_equalable&lt;D&gt;&amp; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> non_equalable&lt;D&gt;&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> D&amp;&gt;(lhs) == <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> D&amp;&gt;(rhs)); }</code> </pre><br><br>  As you can see, inside operator! = We use the fact that <i>non_equalable</i> can use the ‚Äú==‚Äù operator defined in the derived type. <br>  You can use this <i>MixIn</i> as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_struct</span></span></span><span class="hljs-class"> :</span></span> non_equalable&lt;some_struct&gt; { some_struct(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w) : i_(w){} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_struct&amp; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_struct&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.i_ == rhs.i_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">some_struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">some_struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; (s1 != s2) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br><br><h4>  MixIn vice versa </h4><br>  Imagine that we are writing an implementation of the classes of gaming spacecraft.  Our ships will move according to the same algorithm, except for some moments, for example, the mechanism for counting the remaining fuel and the current speed will differ from ship to ship.  The classic implementation of the pattern template method (and this is it) will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">space_ship</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... void move() { if(!fuel()) return; int current_speed = speed(); // further actions ... } virtual ~space_ship(){} private: virtual bool fuel() const = 0; virtual int speed() const = 0; }; class interceptor : public space_ship { public: // ... private: bool fuel() const { ... } int speed() const { ... } }; class other_ship : public space_ship { ... }; class other_ship_2 : public space_ship { ... }; // ‚Ä¶</span></span></code> </pre><br><br>  Now we will try to apply <i>CRTP</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">space_ship</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;D*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;fuel()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current_speed = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;D*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;speed(); <span class="hljs-comment"><span class="hljs-comment">// ... } }; class interceptor : public space_ship&lt;interceptor&gt; { public: bool fuel() const; int speed() const; };</span></span></code> </pre><br><br>  In this implementation, we got rid of virtual functions and the code itself became shorter (no need to describe purely virtual functions in the base class). <br><br>  The concept of <i>MixIn</i> 'and with this approach is turned upside down.  The main work is done in the base class, and we add the additional (different) functionality from the derived classes. <br><br>  I want to focus your attention on this design technique and <i>Mixin</i> 'ah in general.  Do not be confused by the artificial example of spaceships or singleton.  In real-world tasks, this approach allows building very flexible architectures, avoiding duplicate code, localizing the functionality in small classes and subsequently ‚Äúmixing‚Äù them into the right mix at the moment.  Especially, he begins to shine in cooperation with the means that allow a multitude of objects of different types to be batch-processed (see <i>boost :: fusion</i> ). <br><br><h4>  MixIn Variations </h4><br>  The main software development theorem ( <i>FTSE</i> ) states: ‚ÄúAny problem can be solved by introducing additional levels of indirection‚Äù.  Let's see how this can be applied to <i>CRTP</i> <i>MixIn</i> 's. <br>  You may have noticed in the previous chapters ‚ÄúExplicit Interface‚Äù and ‚ÄúOn the contrary‚Äù MixIn I used public functions in a derived class.  Generally speaking, this is not very good, since it breaks encapsulation.  It turns out that the functions that are not intended for what the user called them directly ‚Äústick out‚Äù outwardly. <br>  You can solve this problem by making the base classes friends of the derivative.  After that, you can add these functions to the <i>private</i> section, but imagine that you need to inherit from several basic <i>MixIn</i> 's.  Have to make friends all the base classes.  For a comprehensive solution to this problem, as well as to ensure compilation on some old compilers, you can introduce a new level of indirection.  It is a structure whose functions redirect calls from the base to the derived class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">access</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Impl&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_handle_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Impl* impl)</span></span></span><span class="hljs-function"> </span></span>{impl-&gt;handle_connect();} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Impl&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_handle_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Impl* impl)</span></span></span><span class="hljs-function"> </span></span>{impl-&gt;handle_response();} };</code> </pre><br><br>  Now from the base classes, we call not the functions of the derivative, but the functions of the intermediate structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void on_connection() { access::on_handle_connect(static_cast&lt;D*&gt;(this)); } }; template&lt;typename D&gt; struct response_handler { // ... void on_response() { access::on_handle_response(static_cast&lt;D*&gt;(this)); } };</span></span></code> </pre><br><br>  In the derived class, we only need to add as friends to the <i>access</i> structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">combined_handler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_handler&lt;worker&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> response_handler&lt;worker&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">access</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br><br>  Additional advantages of this approach include the fact that base classes no longer ‚Äúknow‚Äù about their derived classes, in particular, which particular functions need to be called, and a loosely coupled system, as a rule, is more flexible than the strongly connected one, and also all calls to the derived class are collected in one place (in the access structure), thus making it easier to visually separate them from the functions of the derived class that perform other work. <br>  The downside, as is often the case, is the complexity of the design decision.  Therefore, in no case do I call for the use of such a scheme both in the tail and in the mane, but it seems to me that it would not be superfluous to have an idea about it. </div><p>Source: <a href="https://habr.com/ru/post/210894/">https://habr.com/ru/post/210894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210878/index.html">Paradox of choice: no longer means better</a></li>
<li><a href="../210884/index.html">Bundle ... Para-para-pa Hey! or Bundle Transformer walks on planet 2</a></li>
<li><a href="../210886/index.html">New features for supporting JavaScript in ReSharper 8.1</a></li>
<li><a href="../210890/index.html">RealMusic.ru now allows you to upload music under Creative Commons 3.0</a></li>
<li><a href="../210892/index.html">SaaS Pricing Model: More Money, More Problems</a></li>
<li><a href="../210898/index.html">We write applications for Sony SmartWatch and SmartWatch 2</a></li>
<li><a href="../210904/index.html">9 major trends in the mobile application market in 2013</a></li>
<li><a href="../210910/index.html">Under pressure from Google, Samsung will remove its work and native apps from Android</a></li>
<li><a href="../210912/index.html">Facebook saved $ 1.2 billion with Open Compute implementation</a></li>
<li><a href="../210914/index.html">Overview of the active stylus HEX3 Nota</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>