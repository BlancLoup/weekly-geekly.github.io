<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse Engineering for the smallest: breaking keygen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post will be really interesting to those who are just beginning to be interested in this topic. For people with experience, he may only cause yaw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse Engineering for the smallest: breaking keygen</h1><div class="post__text post__text-html js-mediator-article">  This post will be really interesting to those who are just beginning to be interested in this topic.  For people with experience, he may only cause yawns.  Except maybe an <a href="https://habr.com/ru/post/220245/">epilogue</a> ... <br>  Reverse engineering in the less legal part, where it does not deal with debugging and optimizing its own product, also concerns the following task: ‚Äúfind out how it works for them‚Äù.  In other words, the restoration of the original algorithm of the program, having on hand its executable file. <br>  In order to hold on to the basics and avoid some of the problems - ‚Äúhack‚Äù is not something, but ... keygen.  In 90% it will not be packaged, encrypted or otherwise protected - including the norms of international law ... <br><a name="habracut"></a><br><h5>  In the beginning was the word.  Double </h5><br>  So, we need a keygen and disassembler.  As for the second, let's assume that it will be Ida Pro.  An experimental nameless keygen found on the web: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be7/ee5/d2f/be7ee5d2f2bc746cd55bd8cd9709d76a.png" alt="image"></div><br><br>  Opening the keygen file in Ida, we see a list of functions. <br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/7cc/c0e/3ad7ccc0ece9364d5427875d53daaa3b.png" alt="image"><br><br>  After analyzing this list, we see several standard functions (WinMain, start, DialogFunc) and a bunch of auxiliary-system functions.  These are all standard features that make up the framework. <br>  User functions that represent the implementation of the program's tasks, and not its wrapper from API-system and system calls, the disassembler does not recognize and simply calls sub_number.  Considering that there is only one such function here - it should attract our attention as, most likely, containing the algorithm we are interested in or part of it. <br><img src="https://habrastorage.org/getpro/habr/post_images/62c/903/cce/62c903cce2b95c2a03bcc92fbdf3e6af.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's run keygen.  He asks for two 4-digit lines.  Suppose eight characters are sent to the key calculation function at once.  Analyzing the function code sub_401100.  The answer to the hypothesis is contained in the first two lines: <br><blockquote>  var_4 = dword ptr -4 <br>  arg_0 = dword ptr 8 </blockquote><br>  The second line unambiguously hints at receiving the function argument at offset 8. However, the size of the argument is a double word equal to 4 bytes, not 8. This means that the function processes one line of four characters most likely in one pass, but it is called twice. <br>  The question that can probably arise is: why is an offset of 8 bytes reserved for receiving the function argument, but pointing to 4, because there is only one argument?  As we remember, the stack grows down;  adding values ‚Äã‚Äãto the stack reduces the stack pointer by the corresponding number of bytes.  Therefore, after adding the function argument to the stack and before it starts working, something else is added to the stack.  This is obviously the return address that is added to the stack after calling the system call function. <br><br>  We will find places in the program where there are calls to the sub401100 function.  There are actually two of them: at the address DialogFunc + 97 and DialogFunc + 113.  Instructions of interest to us begin here: <br><div class="spoiler">  <b class="spoiler_title">Relatively long piece of code</b> <div class="spoiler_text"><pre><code class="hljs perl">loc_401196: mov esi, [ebp+hDlg] mov edi, ds:SendDlgItemMessageA lea ecx, [ebp+lParam] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ; lParam <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> 0Ah ; wParam <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> 0Dh ; Msg <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>E8h ; nIDDlgItem <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi ; hDlg call edi ; SendDlgItemMessageA lea edx, [ebp+var_1C] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx ; lParam <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> 0Ah ; wParam <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> 0Dh ; Msg <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>E9h ; nIDDlgItem <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi ; hDlg call edi ; SendDlgItemMessageA pusha movsx ecx, byte ptr [ebp+lParam+<span class="hljs-number"><span class="hljs-number">2</span></span>] movsx edx, byte ptr [ebp+lParam+<span class="hljs-number"><span class="hljs-number">1</span></span>] movsx eax, byte ptr [ebp+lParam+<span class="hljs-number"><span class="hljs-number">3</span></span>] shl eax, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> eax, ecx movsx ecx, byte ptr [ebp+lParam] shl eax, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> eax, edx shl eax, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> eax, ecx mov [ebp+arg_4], eax popa mov eax, [ebp+arg_4] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax call sub_40110<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> </div></div><br><br>  First, the two functions SendDlgItemMessageA are called in a row.  This function takes an element handle and sends it a system Msg message.  In our case, the Msg in both cases is 0Dh, which is the hexadecimal equivalent of the WM_GETTEXT constant.  Here, the values ‚Äã‚Äãof two text fields in which the user entered ‚Äútwo 4-character strings‚Äù are extracted.  The letter A in the name of the function indicates that the ASCII format is used - one byte per character. <br>  The first line is written by the offset lParam, the second, which is obvious - by the offset var_1C. <br>  So, after performing the SendDlgItemMessageA functions, the current state of the registers is saved on the stack using the pusha command, then one byte of one of the lines is written to the ecx, edx and eax registers.  As a result, each of the registers takes the form: 000000 ##.  Then: <br><ol><li>  The SHL command shifts the bit content of the eax register by 1 byte, or in other words, multiplies the arithmetic content by 100 in the hexadecimal system or by 256 in the decimal.  As a result, eax takes the form 0000 ## 00 (for example, 00001200). </li><li>  An OR operation is performed between the received eax value and the ecx register in the form 000000 ## (let it be 00000034).  As a result, the eax will look like: 00001234. </li><li>  The last, fourth byte of the string is written to the ‚Äúfreed‚Äù exx. </li><li>  The content each is shifted by byte again, freeing up space in the lower byte for the next OR command.  Now it looks like this: 00123400. </li><li>  The OR instruction is executed, this time between eax and edx, which contains, say, 00000056. Now, eax is 00123456. </li><li>  Two steps SHL eax, 8 and OR are repeated, with the result that the new content ecx (00000078) is added to the ‚Äúend‚Äù eax.  As a result, eah stores the value 12345678. </li></ol><br>  Then this value is stored in the ‚Äúvariable‚Äù - in the memory area at the offset arg_4.  The state of the registers (their previous values), previously stored on the stack, is pulled out of the stack and distributed to the registers.  Then the value of arg_4 is written back to the register eah and this value is pushed out of the register to the stack.  After that the function call sub_401100 follows. <br><br>  What is the meaning of these operations?  It is very easy to figure out, even in practice, without theory.  Put a breakpoint in the debugger, for example, on the push eax instruction (just before the subfunction call) and run the program for execution.  Keigen will start, ask to enter lines.  Enter qwer and tyui and stop at breakpoint, look at the value of eax: 72657771. Decode to text: rewq.  That is, the physical meaning of these operations is string inversion. <br><br>  We now know that in sub_401100 one of the source strings is transmitted, inverted backwards, in the size of a double word, which completely fits in any of the standard registers.  Perhaps you can take a look at the sub_401100 instructions. <br><div class="spoiler">  <b class="spoiler_title">Another relatively long piece of code</b> <div class="spoiler_text"><pre> <code class="hljs perl">sub_40110<span class="hljs-number"><span class="hljs-number">0</span></span> proc near var_4= dword ptr -<span class="hljs-number"><span class="hljs-number">4</span></span> arg_<span class="hljs-number"><span class="hljs-number">0</span></span>= dword ptr <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp mov ebp, esp <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edi pusha mov ecx, [ebp+arg_<span class="hljs-number"><span class="hljs-number">0</span></span>] mov eax, ecx shl eax, <span class="hljs-number"><span class="hljs-number">10</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> eax add ecx, eax mov eax, ecx shr eax, <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, ecx lea ecx, [eax+eax*<span class="hljs-number"><span class="hljs-number">8</span></span>] mov edx, ecx shr edx, 0Dh <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ecx, edx mov eax, ecx shl eax, <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> eax add ecx, eax mov eax, ecx shr eax, <span class="hljs-number"><span class="hljs-number">11</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, ecx mov [ebp+var_4], eax popa mov eax, [ebp+var_4] <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx mov esp, ebp <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp retn sub_40110<span class="hljs-number"><span class="hljs-number">0</span></span> endp</code> </pre></div></div><br>  At the very beginning there is nothing interesting here - the state of the registers is carefully stored in the stack.  But the first team that interests us is the one following the PUSHA instruction.  It writes the function argument to the EXC, stored at the offset arg_0.  Then this value is transferred to eax.  And cut in half: as we remember, in our example, 72657771 is transmitted in sub_401100;  a logical left shift of 10h (16 decimal) turns the register value into 77710000. <br>  After this, the register value is inverted by the NOT instruction.  This means that in the binary representation of the register, all zeros are turned into ones, and ones - into zeros.  Register after the execution of this instruction contains 888FFFF. <br>  The ADD instruction adds (adds, plus, etc.) the resulting value to the initial value of the argument, which is still contained in the eX register (now it is clear why it was written first in eX, and then in eax?).  The result is saved in the Ex.  Check how it will look like after this operation: FAF47770. <br>  This result is copied from ec to eax, after which the SHR instruction is applied to the content eax.  This operation is the opposite of SHL - if the latter shifts digits to the left, then the first shifts them to the right.  Just as a logical left shift operation is equivalent to multiplying by powers of two, a logical right shift operation is equivalent to the same division.  Let's see what value will be the result of this operation: 7D7A3BB. <br>  Now let's commit another violence against the contents of eax and ecx: the XOR instruction is modulo 2 addition or ‚Äúexclusive OR‚Äù.  The essence of this operation, roughly speaking, is that its result is equal to one (true) only if its operands are significant.  For example, in the case of 0 xor 1, the result is true, or one.  In the case of 0 xor 0 or 1 xor 1, the result will be false, or zero.  In our case, as a result of executing this instruction, with regard to the registers eax (7D7A3BB) and exx (FAF47770), the value FD23D4CB is written to the register eax. <br><br>  The following command LEA ecx, [eax + eax * 8] elegantly and naturally multiplies e by 9 and records the result in ec.  Then this value is copied to edx and shifted to the right by 13 digits: we get 73213 in edx and E6427B23 in Ex.  Then again xorim ecx and edx, writing in ecx E6454930.  Copy it in eax, move it to the left by 9 bits: 8926000, then we invert it, getting 756D9FFF.  We add this value to the ech register - we have 5BB2E92F.  We copy it in eax, we shift to the right by as much as 17 digits - 2DD9 - and xorym with ecx.  We end up with 5BB2C4F6.  Then ... then ... what about us?  What all?.. <br>  So, we save this value to the memory area at var_4 offset, load the register status from the stack, again take the total value from memory and finally retrieve the remaining register states saved at the beginning from the stack.  Exit the function.  Hooray! .. However, it is still too early to rejoice, so far we have a maximum of four semi-printed characters at the output of the first function call, and yet we still have a whole raw line, and we need to bring this one to the divine form. <br><br>  Let's move to a higher level of analysis - from the disassembler to the decompiler.  Imagine the entire function DialogFunc, which contains calls to sub_401100, in the form of C-like pseudocode.  As a matter of fact, this disassembler calls it ‚Äúpseudocode‚Äù, in practice it is practically C code, only ugly.  We look: <br><div class="spoiler">  <b class="spoiler_title">Need more code.</b>  <b class="spoiler_title">Need to build a ziggurat.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> SendDlgItemMessageA(hDlg, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0xD</span></span>u, <span class="hljs-number"><span class="hljs-number">0xA</span></span>u, (LPARAM)&amp;lParam); SendDlgItemMessageA(hDlg, <span class="hljs-number"><span class="hljs-number">1001</span></span>, <span class="hljs-number"><span class="hljs-number">0xD</span></span>u, <span class="hljs-number"><span class="hljs-number">0xA</span></span>u, (LPARAM)&amp;v15); v5 = sub_401100((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)lParam | ((SBYTE1(lParam) | ((SBYTE2(lParam) | (SBYTE3(lParam) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)); v6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { v21[v6] = v5 % <span class="hljs-number"><span class="hljs-number">0x24</span></span>; v7 = v21[v6]; v5 /= <span class="hljs-number"><span class="hljs-number">0x24</span></span>u; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( v7 &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> ) v8 = v7 + <span class="hljs-number"><span class="hljs-number">55</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> v8 = v7 + <span class="hljs-number"><span class="hljs-number">48</span></span>; v21[v6++] = v8; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( v6 &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> ); v22 = <span class="hljs-number"><span class="hljs-number">0</span></span>; v9 = sub_401100(v15 | ((v16 | ((v17 | (v18 &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)); v10 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { v19[v10] = v9 % <span class="hljs-number"><span class="hljs-number">0x24</span></span>; v11 = v19[v10]; v9 /= <span class="hljs-number"><span class="hljs-number">0x24</span></span>u; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( v11 &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> ) v12 = v11 + <span class="hljs-number"><span class="hljs-number">55</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> v12 = v11 + <span class="hljs-number"><span class="hljs-number">48</span></span>; v19[v10++] = v12; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( v10 &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> ); v20 = <span class="hljs-number"><span class="hljs-number">0</span></span>; wsprintfA(&amp;v13, <span class="hljs-string"><span class="hljs-string">"%s-%s-%s-%s"</span></span>, &amp;lParam, &amp;v15, v21, v19); SendDlgItemMessageA(hDlg, <span class="hljs-number"><span class="hljs-number">1002</span></span>, <span class="hljs-number"><span class="hljs-number">0xC</span></span>u, <span class="hljs-number"><span class="hljs-number">0</span></span>, (LPARAM)&amp;v13);</code> </pre></div></div><br><br>  It is already easier to read than an assembler listing.  However, not in all cases you can rely on the decompiler: you need to be ready for hours to monitor the thread of assembler logic, the state of registers and stack in the debugger ... and then give written explanations to the FSB or the FBI.  In the evening I have a particularly funny joke. <br>  As I said, it is easier to read, but still far from perfect.  Let's analyze the code and give the variables more readable names.  We give clear and logical names to the key variables, and simpler and temporary ones. <br><div class="spoiler">  <b class="spoiler_title">The same, only translated from Chinese to Hindu.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SendDlgItemMessageA(hDlg, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0xD</span></span>u, <span class="hljs-number"><span class="hljs-number">0xA</span></span>u, (LPARAM)&amp;first_given_string); SendDlgItemMessageA(hDlg, <span class="hljs-number"><span class="hljs-number">1001</span></span>, <span class="hljs-number"><span class="hljs-number">0xD</span></span>u, <span class="hljs-number"><span class="hljs-number">0xA</span></span>u, (LPARAM)&amp;second_given_string); first_given_string_encoded = sub_401100((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)first_given_string | ((SBYTE1(first_given_string) | ((SBYTE2(first_given_string) | (SBYTE3(first_given_string) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)); i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { first_result_string[i] = first_string_encoded % <span class="hljs-number"><span class="hljs-number">0x24</span></span>; temp_char = first_result_string[i]; first_string_encoded /= <span class="hljs-number"><span class="hljs-number">0x24</span></span>u; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( temp_char &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> ) next_char = temp_char + <span class="hljs-number"><span class="hljs-number">55</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> next_char = temp_char + <span class="hljs-number"><span class="hljs-number">48</span></span>; first_result_string[i++] = next_char; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> ); some_kind_of_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; second_string_encoded = sub_401100(byte1 | ((byte2 | ((byte3 | (byte4 &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>)); j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { second_result_string[j] = second_string_encoded % <span class="hljs-number"><span class="hljs-number">0x24</span></span>; temp_char2 = second_result_string[j]; second_string_encoded /= <span class="hljs-number"><span class="hljs-number">0x24</span></span>u; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( temp_char2 &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> ) next_char2 = temp_char2 + <span class="hljs-number"><span class="hljs-number">55</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> next_char2 = temp_char2 + <span class="hljs-number"><span class="hljs-number">48</span></span>; second_result_string[j++] = next_char2; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> ); yet_another_some_kind_of_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; wsprintfA(&amp;buffer, <span class="hljs-string"><span class="hljs-string">"%s-%s-%s-%s"</span></span>, &amp;first_given_string, &amp;second_given_string, first_result_string, second_result_string); SendDlgItemMessageA(hDlg, <span class="hljs-number"><span class="hljs-number">1002</span></span>, <span class="hljs-number"><span class="hljs-number">0xC</span></span>u, <span class="hljs-number"><span class="hljs-number">0</span></span>, (LPARAM)&amp;buffer);</code> </pre></div></div><br><a name="epilog"></a><br><h5>  Epilogue </h5><br>  <i>Level complete</i> .  The next (and final) goal is to write your keygen using this algorithm.  I will, out of habit, write in the Linux shell script bash script language.  <b>test $ {# reg1} -gt &amp;&amp; reg1 = `echo" $ {reg1: -8} "`</b> is cutting the string that contains the emulated register value, up to 8 low characters.  When performing operations, extra high-order bits were added there.  All the rest is painstaking emulation of assembly listing.  I pointed at the top of the ‚ÄúAbnormal programming‚Äù hub, right? .. <br><br>  bash-implementation of the notorious sub_401100: <br><img src="https://habrastorage.org/getpro/habr/post_images/d95/102/3fe/d951023fe7a31063e3bd331a524d1568.png" alt="image"><br><br>  The main function of keygen: <br><img src="https://habrastorage.org/getpro/habr/post_images/e3a/17c/984/e3a17c9842720f7ae96e576406083d55.png" alt="image"><br><br>  Testing and comparison: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/40f/93e/36640f93e5666d4fd895406d70ae2dbe.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/900/569/d0d/900569d0d23fcdf985c42c9ef3b3fff1.png" alt="image"></div><br><br><h5>  Conclusion </h5><br>  Now we could generate keys to some gaming software directly from the Linux console, but this is impossible for several reasons: firstly, I don‚Äôt know what software this target is intended for - I downloaded it at random on the Internet;  secondly, the use of fake keys and unlicensed proprietary software is prohibited by international law.  ;) <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b05/ec5/361/b05ec5361ec0f921a91281d8f555818c.gif" alt="image"></div></div><p>Source: <a href="https://habr.com/ru/post/220245/">https://habr.com/ru/post/220245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220235/index.html">History of one internationalization</a></li>
<li><a href="../220237/index.html">12 little-known CSS features</a></li>
<li><a href="../220239/index.html">Sandbox Augmented Reality</a></li>
<li><a href="../220241/index.html">Domestic processor "Elbrus-4C" will soon be launched into mass production</a></li>
<li><a href="../220243/index.html">Yandex cloud platform: Cocaine in action</a></li>
<li><a href="../220247/index.html">As we Lenovo ThinkServer met</a></li>
<li><a href="../220249/index.html">Job search with a bear</a></li>
<li><a href="../220253/index.html">Technopark Mail.Ru. First two years</a></li>
<li><a href="../220255/index.html">Minecraft helps upgrade cities</a></li>
<li><a href="../220257/index.html">SpaceX Dragon private spacecraft successfully docked with the ISS.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>