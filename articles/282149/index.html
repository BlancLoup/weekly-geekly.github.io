<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proper error handling in javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Error handling in JavaScript is a risky business. If you believe in Murphy's law , then you know perfectly well: if something can go wrong, this is ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Proper error handling in javascript</h1><div class="post__text post__text-html js-mediator-article"> Error handling in JavaScript is a risky business.  If you believe in <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%259C%25D0%25B5%25D1%2580%25D1%2584%25D0%25B8">Murphy's law</a> , then you know perfectly well: if something can go wrong, this is exactly what will happen!  In this article, we will look at the pitfalls and the right approach to error handling in JS.  And finally, let's talk about asynchronous code and Ajax. <br><br>  I believe that the JS event paradigm adds a certain wealth to the language.  I like to present the browser as an event-driven machine, including bugs.  In fact, an error is the non-occurrence of some event, although someone will not agree with this.  If this statement seems strange to you, then fasten your seat belts, this trip will be unusual for you. <br><br>  All examples will be considered in relation to client-side JavaScript.  The basis of the story went to the ideas voiced in the article " <a href="http://www.sitepoint.com/exceptional-exception-handling-in-javascript/">Exceptional event handling in JavaScript</a> ."  The name can be rephrased like this: "When an exception occurs, JS checks for the presence of a handler in the call stack."  If you are unfamiliar with basic concepts, I recommend reading this article first.  Here we will consider the issue more deeply, not limited to simple requirements for exception handling.  So the next time you again get a <code>try...catch</code> , then you will approach it with an eye to it. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Demo code </h1><br>  The code used for the examples can be downloaded from <a href="https://github.com/sitepoint-editors/ProperErrorHandlingJavaScript">GitHub</a> , it represents such a page: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba5/3ee/f31/ba53eef3166be73578d3b861371985ac.jpg"><br><br>  When you click on each of the buttons, a ‚Äúbomb‚Äù explodes, simulating a <code>TypeError</code> exception.  The following is the definition of this module from the unit test. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.bar(); }</code> </pre><br>  First, the function declares an empty <code>foo</code> object.  Note that there is no <code>bar()</code> definition anywhere.  Let's now see how our bomb explodes when the unit test runs. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'throws a TypeError'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ should.throws(target, <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>); });</code> </pre><br>  The test is written in <a href="http://mochajs.org/">Mocha</a> using test assertions from <a href="http://shouldjs.github.io/">should.js</a> .  Mocha acts as a test performer, and should.js acts as a library of statements.  If you have not yet encountered these test APIs, then you can safely study them.  Test execution begins with <code>it('description')</code> , and ends with a successful or unsuccessful completion in <code>should</code> .  Run can be done directly on the server, without using a browser.  I recommend not to neglect testing, because it allows you to prove the key ideas of pure JavaScript. <br><br>  So, <code>error()</code> first defines an empty object, and then tries to access the method.  But since <code>bar()</code> inside the object does not exist, an exception occurs.  And this can happen to everyone if you use a dynamic language like JavaScript! <br><br><h1>  Bad processing </h1><br>  Consider an example of incorrect error handling.  I tied the launch handler to a button click.  Here is what it looks like in unit tests: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">badHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br>  As a dependency, the handler receives a callback <code>fn</code> .  This dependency is then called from within the handler function.  Unit tests demonstrate its use: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'returns a value without errors'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = target(fn); result.should.equal(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'returns a null with errors'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'random error'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = target(fn); should(result).equal(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); });</code> </pre><br>  As you can see, in the event of a problem, this strange handler returns <code>null</code> .  A callback <code>fn()</code> may indicate either a normal method or a ‚Äúbomb‚Äù.  Continuation of a story: <br><br><pre> <code class="javascript hljs"> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">handler, bomb</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> badButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'bad'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (badButton) { badButton.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ handler(bomb); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Imagine, getting promoted for hiding mistakes'</span></span>); }); } }(badHandler, error));</code> </pre><br>  What is wrong with getting just <code>null</code> ?  This leaves us in the dark about the cause of the error, does not provide any useful information.  Such an approach ‚Äî stopping execution without explicit notification ‚Äî can be the cause of incorrect decisions from the point of view of UX that could lead to data corruption.  You can kill a few hours for debugging, while losing sight of the <code>try...catch</code> .  The handler above just swallows errors in the code and pretends that everything is in order.  This rolls in companies that are not too concerned about the high quality of the code.  But remember that hiding errors in the future is fraught with large time losses for debugging.  In a multi-layered product with deep call stacks, it is almost impossible to find the root of the problem.  There are a number of situations where it makes sense to use the hidden <code>try...catch</code> , but in error handling this is best avoided. <br><br>  If you use stop execution without explicit notification, then in the end you will want to approach error handling more intelligently.  And JavaScript allows for a more elegant approach. <br><br><h1>  Curve processing </h1><br>  Go ahead.  Now it's time to look at the error handler curve.  Here we will not touch on the use of DOM, the essence is the same as in the previous part.  The curve handler differs from the bad only in the way the exception is handled: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uglyHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'a new error'</span></span>); } } it(<span class="hljs-string"><span class="hljs-string">'returns a new error with errors'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'type error'</span></span>); }; should.throws(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ target(fn); }, <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>); });</code> </pre><br>  If you compare it with a bad handler, it is definitely better.  The exception causes the call stack to ‚Äúpop up‚Äù.  Here, I like the fact that errors will <b>unwind the stack</b> , and this is extremely useful for debugging.  When an exception occurs, the interpreter will go up the stack in search of another handler.  This gives us plenty of opportunity to work with errors at the very top of the call stack.  But since this is a crooked handler, the original error is simply lost.  You have to go back down the stack, trying to find the original exception.  Well at least that we know about the existence of a problem that has thrown an exception. <br><br>  The harm from a crooked handler is less, but the code still turns out with a ghost.  Let's see if the browser has an appropriate ace in the hole for this. <br><br><h1>  Stack rollback </h1><br>  You can wind off exceptions in one way - by placing <code>try...catch</code> at the top of the call stack.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bomb</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { bomb(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-comment"><span class="hljs-comment">// Handle all the error things } }</span></span></code> </pre><br>  But with us, the browser is event driven, remember?  And exceptions in JavaScript are the same full events.  Therefore, in this case, the interpreter interrupts the execution of the current context and produces an unwind.  We can use the global <code>onerror</code> event <code>onerror</code> , and it will look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> error = e.error; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); });</code> </pre><br>  This handler can catch the error in any executable context.  That is, any error can cause an error event (Error event).  The caveat here is that all error handling is localized in one place in the code - in the event handler.  As in the case of any other events, you can create chains of handlers to handle specific errors.  And if you adhere to the principles of <a href="https://ru.wikipedia.org/wiki/SOLID_%2528%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%2529">SOLID</a> , you can ask each error handler its own specialization.  You can register handlers at any time, the interpreter will run as many handlers in a loop as needed.  At the same time, you can rid your codebase of <code>try...catch</code> blocks, which will only be useful for debugging.  That is, the point is to approach error handling in JS as well as event handling. <br><br>  Now that we can unwind the stack with the help of global handlers, what will we do with this treasure? <br><br><h1>  Stack capture </h1><br>  The call stack is an incredibly useful tool for solving problems.  Not least because the browser provides information as is, out of the box.  Of course, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Stack">stack</a> property in the error object is not standard, but it is consistently available in the most recent browser versions. <br><br>  This allows us to do such cool things as logging to the server: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = e.error.stack; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = e.error.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack) { message += <span class="hljs-string"><span class="hljs-string">'\n'</span></span> + stack; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-string"><span class="hljs-string">'/log'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.send(message); });</code> </pre><br>  Perhaps, in the above code, this is not striking, but such an event handler will work in parallel with the one above.  Since each handler performs any one task, we can follow the <a href="https://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself">DRY</a> principle when writing code. <br><br>  I like how these messages are caught on the server. <br><br><img src="https://habrastorage.org/files/e70/70b/623/e7070b623e6c4a67b46526d741c2038a.jpg"><br><br>  This is a screenshot of a message from Firefox Developer Edition 46. Please note that due to the correct error handling, there is nothing superfluous here, everything is brief and to the point.  And do not hide mistakes!  Just look at the message, and it becomes immediately clear who and where threw the exception.  Such transparency is extremely useful when debugging front-end code.  Such messages can be stored in a persistent store for future analysis in order to better understand the situations in which errors occur.  In general, do not underestimate the possibilities of the call stack, including for debugging needs. <br><br><h1>  Asynchronous processing </h1><br>  JavaScript extracts asynchronous code from the current executable context.  This means that there is a problem with <code>try...catch</code> expressions like the one below. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fn(); }, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { } }</code> </pre><br>  The development of events according to the modular version: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'does not catch exceptions with errors'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'type error'</span></span>); }; failedPromise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ target(fn); }).should.be.rejectedWith(<span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">failedPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(fn); }); }</code> </pre><br>  I had to wrap the exception check handler in the handler.  Notice that there is an unhandled exception, despite the presence of a block of code around the wonderful <code>try...catch</code> .  Unfortunately, <code>try...catch</code> expressions work only with a single executable context.  And by the time the exception was thrown, the interpreter had already moved to another part of the code, left <code>try...catch</code> .  Exactly the same situation arises with Ajax calls. <br><br>  Here we have two ways.  The first is to catch an exception inside an asynchronous callback: <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-comment"><span class="hljs-comment">// Handle this async error } }, 1);</span></span></code> </pre><br>  This is quite a working option, but there are a lot of things that can be improved.  First, <code>try...catch</code> blocks are scattered everywhere - a tribute to the programming of the 1970s.  Secondly, <a href="https://ru.wikipedia.org/wiki/V8_%2528%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25BE%25D0%25BA_JavaScript%2529">the V8 engine</a> does not <a href="https://github.com/nodejs/node-v0.x-archive/wiki/Best-practices-and-gotchas-with-v8">use these blocks</a> too well <a href="https://github.com/nodejs/node-v0.x-archive/wiki/Best-practices-and-gotchas-with-v8">inside functions</a> , so developers recommend placing <code>try...catch</code> on top of the call stack. <br><br>  So what should we do?  I did not just mention that global error handlers work with any executable context.  If such a handler subscribe to a window.onerror event, then nothing else is needed!  You immediately begin to follow the principles of DRY and SOLID. <br><br>  Below is an example of a report sent to the server by an exception handler.  If you run the demo, then this report may be slightly different, depending on the browser used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9a/5f5/854/a9a5f585459087731f28f445d448c629.jpg"><br><br>  This handler even reports that the error is related to asynchronous code, more precisely with the <code>setTimeout()</code> handler.  Right tale! <br><br><h1>  Conclusion </h1><br>  There are at least two basic approaches to error handling.  The first is when you ignore errors, stopping performance without notice.  The second is when you immediately receive information about the error and wind off until the moment it occurs.  I think everyone knows which of these approaches is better and why.  In short: do not hide the problem.  No one will blame you for possible failures in the program.  It is perfectly acceptable to stop execution, roll back the state and give the user a new attempt.  The world is imperfect, so it is important to give a second chance.  Mistakes are inevitable, and only how you deal with them matters. </div><p>Source: <a href="https://habr.com/ru/post/282149/">https://habr.com/ru/post/282149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282133/index.html">SpyEye authors were given 24 years for two</a></li>
<li><a href="../282139/index.html">IT Center at the DUMP-2016 Conference</a></li>
<li><a href="../282141/index.html">Introduction to offline navigation for augmented reality</a></li>
<li><a href="../282143/index.html">How Google in London trained on Android N</a></li>
<li><a href="../282145/index.html">How to hope for the Ministry of Emergency Situations and disappear in the forests of Karelia - bad advice from an experienced tourist</a></li>
<li><a href="../282151/index.html">DevConf-2016: waiting for applications for reports</a></li>
<li><a href="../282153/index.html">INTEL represents the release of the source code for the Arduino 101 firmware</a></li>
<li><a href="../282155/index.html">There is a question: why e-mail topics become longer, and what does it affect</a></li>
<li><a href="../282157/index.html">Network protocol for backing up data in networks with delay and packet loss</a></li>
<li><a href="../282159/index.html">Profiling JS code from functions. Yandex experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>