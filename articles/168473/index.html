<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The impact of data bus loading on application scalability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I‚Äôll talk about how the data bus load affects the scalability of applications. By scalability, we will understand not only the abilit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The impact of data bus loading on application scalability</h1><div class="post__text post__text-html js-mediator-article">  In this article, I‚Äôll talk about how the data bus load affects the <b>scalability of</b> applications.  By scalability, we will understand not only the ability of a multi-threaded application to reduce its execution time as the number of threads increases.  We will also add here the ability of a single-threaded application running simultaneously in several instances to run in the same period of time as one copy.  Although the last example would be more correctly described by such a property as <b>throughput</b> , as it relates to the ‚Äúserver‚Äù mode of launching applications.  Those.  This is the mode in which a single-threaded application is launched on the server each time a new client connects to it.  The main task in developing such applications is to reduce their dependence on shared resources, one of which may be a data bus. <br><a name="habracut"></a><br>  Below is a picture that shows the position of the memory bus in the system.  On the left is a diagram for the ‚Äúantediluvian‚Äù architecture of Core 2, on the right for the less old - Nehalem.  All subsequent Intel architectures have a similar circuit with Nehalem (with the exception of the Intel MIC). <br><br><img src="https://habrastorage.org/storage2/5e5/86f/d1d/5e586fd1defdfbb02dabab616f86dc64.jpg"><br><br>  So, why do we need to know the state of the bus at runtime?  But why?  Sometimes it happens that the program seems to be written in accordance with the canons of parallel programming: the percentage of single-threaded code is insignificant, the threads are loaded evenly, and there is almost no synchronization, and so on, but something still prevents it from linearly scaling with increasing number of threads .  In such cases, experts analyze the performance of the application at the architectural level.  At this level, you can find problems specific to a particular processor model or system configuration.  These problems include the data bus load. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's see how bus load affects scalability.  To do this, we write a simple program that will read and write elements of a one-dimensional array in a loop. <br><br><img src="https://habrastorage.org/storage2/11b/622/f46/11b622f460fe63c4fc3df615601f0047.jpg"><br><br>  We will run this program with a different number of threads and a different parameter STEP.  The STEP parameter corresponds to the cache line utilization.  We remember that the processor exchanges portions of 64 bytes with memory, which are called CASH lines.  If we need to read only one byte, the processor will still download 64 bytes from memory.  This data exchange is due to the principle of <b>spatial locality</b> .  This is the first principle that underlies the cache.  The processor as if assumes that if we considered some array value from memory, then in the next step we need to read the next value from the same array.  Therefore, it is important to place the data as close as possible to each other in order to reduce the load on the tire.  Thus, with STEP = 1, the utilization of the CASH line is 100%, with STEP = 4, recycling - 25%, STEP = 8, recycling - 12.5% ‚Äã‚Äãand with STEP = 64, recycling - 1.56%.  In fact, the last parameter means downloading a new CASH line at each iteration of the internal loop. <br><br>  Another note: the test program was compiled by the Intel compiler with the ‚Äìno-vec option to get a scalar code instead of a vector one.  This was done in order to obtain "beautiful data" to facilitate understanding of the theory. <br><br><img src="https://habrastorage.org/storage2/0a5/be8/87a/0a5be887a966f0540c0b63cda7308cb8.jpg"><br><br>  This graph shows the execution time of our application, depending on the parameters tested.  We see that as the cache-line utilization deteriorates (parameter STEP), scalability, i.e.  the ratio of time for a smaller number of streams to time for a larger number of streams also becomes worse. <br>  Now let's see how the load on the data bus varies depending on the tested parameters.  We will measure the load using VTune Amplifer using Bandwidth analysis. <br><br><img src="https://habrastorage.org/storage2/41d/866/981/41d866981c344d187529688b88262d48.jpg"><br><br>  We see that simultaneously with the deterioration of scalability, the load on the tire increases.  The explanation here is simple - streams are increasingly required to cache lines and because of the limited bus they have to idle longer and longer while waiting for data.  This is the reason for the deterioration of scalability.  It is also important to note that the load value ceases to change significantly at some point and gradually approaches a certain value, which is called <b>peak load</b> .  In our case, the peak load is 19 Gb / s. <br><br>  Now consider what the principle of <b>temporal locality</b> .  This is another principle that underlies the CASH and says the following: if we considered some element from memory, then most likely we will turn to this element again after some time.  To demonstrate this principle, take the worst case, where the utilization of the cache line is 1.56%.  For this case, we apply a loop bypass in blocks, without violating the integrity of the data and preserving the semantics of the program. <br><br><img src="https://habrastorage.org/storage2/1ef/264/6e3/1ef2646e36cb7ea1c26292f6c730be4c.png"><br><br>  This optimization allows us to process the required number of times the data that is currently in the cache.  After the data has been processed, we move to the next batch, pumping them through the bus, and repeat the summation.  It is important to note that the serving volume corresponds to the second level cache. <br><br><img src="https://habrastorage.org/storage2/15f/0ad/f2a/15f0adf2ad511514676f86b9082f206a.jpg"><br><br>  This approach not only reduced the application execution time, but also, what is most important for us, significantly improved scalability.  This optimization has reduced the dependence of flows on a shared resource, i.e.  from the data bus, and switch them to a second-level cache, which is its own resource for each core, and also faster.  We also see that the bus load has become scanty. <br><br>  So, in order to improve the scalability of our application, we must use one of the principles of locality.  And if we also want to significantly reduce the execution time, then we must use both principles. <br>  Someone will say that the case of using movnti instructions intended for tire unloading has not been considered, but I will note that we will discuss this in the next article. <br><br>  Now let's answer the main question of this article: ‚ÄúAnd how to understand that the weak scalability of the application is caused by the high data bus load?‚Äù. <br>  To answer this question, we must do the following steps using VTune Amplifer: <br><ol><li>  Measure peak load for data bus in our system </li><li>  Figure out how the bus load changes depending on the increase in the number of threads in our application. </li><li>  If we see that with an increase in the number of threads, the load on the bus quickly reaches its peak values ‚Äã‚Äã(measured in item 1), then this is the cause of our troubles (poor scalability).  At the same time, we must understand that there are still other reasons (for example, false-sharing), which we have already checked. </li></ol><br>  To determine the peak load, we take the test program from the first example with the parameter STEP = 64. <br><br><img src="https://habrastorage.org/storage2/c49/acc/164/c49acc16478fa20b1008a81eb794fc42.jpg"><br><br>  Just in case, I recommend to collect this program without the option of interprocedural analysis.  It will be enough to compile it simply with the ‚ÄìO2 option.  Here you need to take into account that the size of the arrays should not exceed the size of the RAM, otherwise paging of the operating system may affect the measurement.  The number of threads should be no less than the number of cores, and if Hyper-Threading is enabled, then it should be no more than the number of hardware threads.  The number of repetitions (REPEAT) can be any, as long as the test runs for substantial time and VTune gives the same bandwidth from start to start. <br><br>  And now we will consider an example from real life.  Take the 470.lbm application from the SPEC CPU2006 package.  This is one of the versions of the well-known method for solving problems of hydrodynamics (the full name is Lattice Boltzmann Method).  This version is written in such a way as to shift the load balance from the processor to the memory bus.  Run the application on a two-socket server based on Nehalem and look at scalability. <br><br><img src="https://habrastorage.org/storage2/760/fc0/770/760fc0770208544e8b72f4946c6c7886.jpg"><br><br>  We see that already on four streams the scaling worsens, and the load on the bus increases significantly and on eight streams it reaches a peak value.  At the same time, I already performed checks for other reasons for poor scalability, and they were not confirmed, so I conclude that it is this kind of bus load that is the main reason. <br><br>  Now take a look at the hot loop of this application. <br><br><img src="https://habrastorage.org/storage2/5d5/ade/9bd/5d5ade9bd65642456c561a7e871397ae.jpg"><br><br>  We see that the principle of "spatial locality" is violated in it, i.e.  Modified elements from the srcGrid array are written to 19 arrays (writing to the dstGrid array with large offsets for the processor is just the same as writing to different arrays).  The main problem with this application is inconsistent recording in increments of 20 elements.  Such a complex record is due to a specific data structure.  The fact is that during the execution of an application, one cube is transformed into another, and each element of this cube is a structure of 20 double elements.  Those.  in fact, we are dealing with an array of structures, although they are not explicitly declared. <br><br><img src="https://habrastorage.org/storage2/6ea/71c/47d/6ea71c47d790ee3a0dd25b3e628cccf3.jpg"><br><br>  In order to make the record linear, we need to apply the classical optimization, which is called ‚Äútransformation of an array of structures into an array structure‚Äù.  How to apply this optimization can be found in the article ‚ÄúOptimization Study for Multicores.  Muneeb Anwar Khan.  After applying the optimization and breaking the record into blocks (to improve the hardware prefetcher's work), we have the following cycle: <br><br><img src="https://habrastorage.org/storage2/8ab/a33/081/8aba33081139b7d29fc570715c296650.jpg"><br><br>  And the result: <br><br><img src="https://habrastorage.org/storage2/4d0/12e/daf/4d012edaf209490a0e5f48a2274bed66.jpg"><br><br>  We see that scalability has improved due to reduced load on the tire.  Although you need to recognize that the execution time of the application in one thread has increased slightly.  This is due to the fact that during data transformation we had to add another 19 arrays for the srcGrid, and this increased the load on the hardware prefetcher.  An interesting result is obtained when running a single-threaded version of this application in eight copies, i.e.  in the "server" mode.  (The application was compiled without paralleling options.) <br><br><img src="https://habrastorage.org/storage2/e08/072/403/e08072403528f6788ffc96390e84fb0a.jpg"><br><br>  The simultaneous execution of eight single-threaded copies on eight cores takes 252 seconds, which is less than eight consecutive launches of the multi-threaded version, which are performed 8 * 37 = 296 seconds.  This suggests that in a multi-threaded version there are some <u>algorithmic</u> problems associated with parallelization.  But that's another story. </div><p>Source: <a href="https://habr.com/ru/post/168473/">https://habr.com/ru/post/168473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168459/index.html">For bills abroad - a fine of up to 100%</a></li>
<li><a href="../168461/index.html">Why does Google add while (1); to your JSON responses?</a></li>
<li><a href="../168463/index.html">Explanation of the situation with the forbidden registry. About the meeting in Roskomnadzor</a></li>
<li><a href="../168467/index.html">Cackle - Affiliate Program</a></li>
<li><a href="../168471/index.html">Correct transition from the old domain to the new one</a></li>
<li><a href="../168475/index.html">Marketing from Blizzard Entertainment</a></li>
<li><a href="../168477/index.html">Attributes system</a></li>
<li><a href="../168483/index.html">5 Practical Tips for Using Lithium-Ion Batteries</a></li>
<li><a href="../168485/index.html">The dark side of the code</a></li>
<li><a href="../168487/index.html">Ordinary screen user: who is he?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>