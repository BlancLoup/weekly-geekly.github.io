<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JMeter: Forget Beanshell Sampler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the help of standard elements of the test plan in Jmeter, much can be done, but not all. To extend the functionality and implement more complex l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JMeter: Forget Beanshell Sampler</h1><div class="post__text post__text-html js-mediator-article">  With the help of standard elements of the test plan in Jmeter, much can be done, but not all.  To extend the functionality and implement more complex logic, it is customary to use the BeanShell Sampler - somehow it has historically been around the world.  And all over the world they periodically suffer from this, but continue to eat cactus. <br><a name="habracut"></a><br><h4>  How without him? </h4><br>  In principle, in order to achieve the best results in terms of the performance of the load station itself, the most effective way is to implement your Java Request or even write your own sampler.  But personally, I do not like this decision because of: <br><ul><li>  more effort to develop a solution; </li><li>  non-transparent support for the solution (the code lies elsewhere; it must be recompiled using additional actions); </li><li>  possible loss of bonuses that JMeter gives (for example, if you have implemented a request in the DBMS in the code, and then an HTTP request, then you will see in the statistics them in sum, and not separately). </li></ul><br>  So I always tried to avoid such a decision (and so far I avoided it!).  I personally like it when the code is in the test plan itself, and you can track the time to execute this code using JMeter.  In this sense, the BeanShell approach of the sampler is very convenient, only its implementation is bad.  I'll tell you why. <br><br><h4>  What is bad Beanshell Sampler </h4><br><img src="https://habrastorage.org/files/c06/b02/990/c06b029902fc49e59795d3799c83313e.jpg"><br><br>  Once we developed a highly loaded test plan using code inserts in BeanShell Sampler.  At the design stage, everything went fine, but when we started the trial runs of the load tests, we were faced with very unpleasant behavior.  On a certain number of threads, everything worked fine.  But with an increase in the number of threads, some kind of inadequacy began.  The test was heavily deficient in the target load intensity, and reports showed that the processing time of individual BeanShell samplers reached tens of seconds!  Moreover, there were quite a few BeanShell samplers ‚Äî one or two per thread group, and not to say that something complicated was happening there.  Studying the performance parameters of the load station itself did not reveal any problems: the CPU load was 20‚Äì30 percent, the memory for the JMeter process was sufficient and the garbage collector cleared it in a timely manner.  It is clear that the problem is in the JMeter software itself or in the implementation of the BeanShell interpreter.  Playing with Reset bsh.Interpreter does not give anything;  Moreover, in one place they write that it is better to install it so that there is no memory overflow, in another it is better to remove it for performance reasons. <br>  Messages about such problems are occasionally found on the JMeter forums and come in the Apache JMeter User mailing list.  Colleagues also complained about the behavior of some tests, but tended to attribute the problem to the tool itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What to do </h4><br>  JMeter has a very similar sampler called the JSR223 Sampler.  Not even just a sampler, but the whole family: Sampler, Timer, Pre- and PostProcessor, Assertion, Timer and Listener.  <a href="http://jmeter.apache.org/usermanual/component_reference.html">Documentation</a> on it begins with very encouraging words that this sampler will allow to achieve significant performance improvements.  But the attentive reader is immediately frustrated: to achieve this effect, you should choose a scripting engine that supports compilation.  Right there, beside, it is indicated that the engine for Java is not. <br>  Regarding Java, I will say even more: it is implemented by the same engine as BeanShell.  It is easy to be convinced of it, having caused an error in the executed code.  In the stack of exceptions in the log you will see that both there and there the bsh interpreter is called.  Therefore, there is absolutely no difference between JSR223 / java and BeanShell Sampler.  About the other engines, nothing is said, but they are also all interpretable.  Thus, in the standard JMeter delivery there are no engines on which it would be possible to get profit from compilation. <br>  The only compiled script engine mentioned in the documentation is <a href="http://groovy-lang.org/">Groovy</a> .  There are other engines that support JSR223.  I tried Scala, was horrified by how slowly this bundle works and left this topic until better times.  <i>(Note: the point here is probably not in Scala, but in the implementation of the JSR 223 standard and in the implementation of the <a href="http://docs.oracle.com/javase/7/docs/api/javax/script/Compilable.html">Compilable</a> interface.)</i> <br>  To enable Groovy support, you need to download the latest version of binaries from <a href="http://groovy.codehaus.org/Download">the project site</a> or <a href="http://mvnrepository.com/artifact/org.codehaus.groovy/groovy-all">here</a> .  From the archive we need only one file: embeddable \ groovy-all- {version} .jar.  It needs to be unpacked in the zhimetra lib folder  After restarting the program, Groovy appears in the list of available JSR223 languages: <br><br><img src="https://habrastorage.org/files/2c0/aa0/3ee/2c0aa03eea894e47b620b0d898ddde4b.png"><br><br>  After we remade all the BeanShell samplers of our test plan for JSR223 + Groovy, a miracle happened: everything began to work as it should (well, or at least how we programmed), without brakes, and the CPU load became even lower.  The response time of the JSR223 samplers was lower by orders of magnitude and the test went out to the required load. <br><br><h4>  Groovy performance </h4><br>  If we go back to what we started with - various ways to implement additional program logic - then the solution with Groovy should be enough for almost all cases, except for those that really need to squeeze out the percentages.  Groovy scripts are compiled into regular Java bytecode and executed in the context of each stream as if it were native Java code (but you have to remember that it has its own compiler, and there is an overhead for calling the engine).  The guys from Blazemeter <a href="http://blazemeter.com/blog/beanshell-vs-jsr223-vs-java-jmeter-scripting-its-performance">compared the</a> speed of various implementation options and came to the conclusion that the Groovy code is only slightly inferior in speed to the code in pure Java. <br>  I also did a little experiment.  I wrote a small fragment that performs some kind of artificial calculations in integer arithmetic: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = Integer.parseInt(Parameters); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { s += i * (i % <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>); } log.warn(s.toString());</code> </pre> <br><br>  The dependence on the input data (Parameters) and the logging are added just in case, in order to prevent any cunning compilers and interpreters from optimizing the code, excluding its implementation altogether or caching the result.  Moreover, Parameters was also unique.  On my laptop with a Core i7 with 100 threads of 1000 iterations, each result was as follows: <br><br><table><tbody><tr><th>  Implementation </th><th>  Throughput <br></th></tr><tr><td>  Beanshell Sampler </td><td>  ~ 20 / sec <br></td></tr><tr><td>  JSR223 + (java | beanshell | bsh) </td><td>  ~ 20 / sec <br></td></tr><tr><td>  JSR223 + Groovy </td><td>  ~ 13800 / sec <br></td></tr></tbody></table><br>  The gap between Groovy is so significant that it is even hard to believe in it, nevertheless, judging by the log, everything worked out correctly. <br><br><h5>  Java as a subset of Groovy </h5><br>  The big advantage of Groovy is that in 95% of cases, arbitrary Java code is Groovy valid code.  Even the BeanShell syntax is further away from the current Java standard (for example, in BeanShell you have to be perverted in the case of calling functions with an arbitrary number of arguments).  If you are not interested in learning all its possibilities right now, then you should not.  On the other hand, if you <a href="http://groovy-lang.org/documentation.html">master it</a> , you <a href="http://groovy-lang.org/documentation.html">will</a> certainly be able to increase your efficiency. <br><br><h5>  bsh.shared </h5><br>  If you used the global namespace bsh.shared in BeanShell, then a small ambush arises: there is nothing like this in Groovy.  Fortunately, this problem is easy to solve on your own.  For this, 10 lines of code are written: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ConcurrentHashMap; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedHashMap</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConcurrentHashMap instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ConcurrentHashMap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } }</code> </pre><br>  In essence, this is a singleton, which will always (each thread) return the same object.  Further it gathers in jar and is put in the lib folder of Zhimetra.  Since the class is declared in the global namespace (yes, I deserve censure for it), then in the Groovy code, without any import, you can use SharedHashMap to put something there: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     hash map. sharedHashMap = SharedHashMap.GetInstance() //   -. sharedHashMap.put('Counter', new java.util.concurrent.atomic.AtomicInteger())</span></span></code> </pre><br>  When you need to pick up, it is similar: <br><br><pre> <code class="java hljs">sharedHashMap = SharedHashMap.GetInstance() <span class="hljs-comment"><span class="hljs-comment">// * counter = sharedHashMap.get('Counter') counter.incrementAndGet() //..</span></span></code> </pre><br>  <i>* Groovy does not have to be a declaration of variable types, as well as semicolons.</i> <br><br><h5>  Migrating with Beanshell Sampler </h5><br>  Suppose you already have a test plan that already has many BeanShell samplers, and you have found this article because you have a problem.  You want to switch to Groovy.  Connecting Groovy is described above and takes you no more than five minutes. <br>  First you need to create a JSR223 Sampler and transfer the code from BeanShell to it.  You can significantly simplify your life if you can unify the code and select it into a separate file by entering it in the File Name field.  Then you just need to paste the JSR223 samplers into the right places using Copy / Paste.  If not, copy the code from BeanShell in each case. <br><br><h5>  Caching key </h5><br>  It is important to note here that JMeter will compile the code entered in the sampler itself only if the compilation key is specified (the Compilation Cache Key field).  It should be just a string, unique within the test plan.  For scripts connected via files, you do not need to enter the compilation key, as it uses the full path to the file. <br><br><h5>  Java and Groovy strings </h5><br>  There is one subtlety in Groovy syntax.  First, there are two types of strings: <br><ul><li>  in double quotes - Groovy strings </li><li>  in single quotes - Java strings </li></ul><br>  See more <a href="http://groovy-lang.org/differences.html">here</a> .  Groovy strings have the ability to use $ {expression} type expressions that are automatically expanded within strings to the value of expression.  This is quite a convenient moment, but it surprisingly coincides in syntax with reference to JMeter variables.  So if you write in Groovy <br><br><pre> <code class="java hljs">currId = <span class="hljs-number"><span class="hljs-number">123</span></span> log.info(<span class="hljs-string"><span class="hljs-string">"Current ID: ${currId}"</span></span>)</code> </pre><br>  and at the same time, the usual JMeter variable with the name currId is defined in the current thread, then its value will be substituted directly into the script.  In addition, it is substituted once, because  after that, the code will be compiled, and the result will be cached.  Therefore, care must be taken that variable names used in such expressions do not overlap with JMeter variables.  And if you really need to transfer the value to the JSR223 sampler, then you need to use the Parameters field for this. <br><br><img src="//habrastorage.org/files/278/1de/2b5/2781de2b5ba141ef9ebfad5c52cffd7d.png"><br><br>  When using an external file as a source code, JMeter variable substitutions do not occur (they occur only in the fields), but you can use Parameters. <br>  If you do not plan to use the Groovy string capabilities, then it is advisable to use Java strings (that is, in single quotes).  In addition, it will be better for performance, although a penny, of course. <br><br><h4>  Conclusion </h4><br>  The BeanShell sampler behavior illustrates a typical interpreter problem: the low speed of the interpreted code.  If you have only a few lines in BeanShell, you probably won't notice any problems, but you will definitely notice if there is a lot of code or if there are loops there.  Exactly the same problem <a href="http://habrahabr.ru/post/231875/">was observed</a> in the LoadRunner interpreter. <br>  If you have not had any problems running a test that uses BeanShell, then I would recommend to be safe and not create them yourself in the future.  Instead, it‚Äôs better to use JSR223 + Groovy right away, thus reducing the likelihood of performance problems with load stations. <br><br>  Important points to take out of the article. <br><ul><li>  Do not use BeanShell Sampler, use JSR223 + Groovy instead. </li><li>  JSR223 + java = the same BeanShell, therefore, see item 1. </li><li>  If it is possible to unify the code of several JSR223, then we use an external file.  Besides the fact that eliminating duplication of code is in itself a good programming style, without having to worry about Compilation Cache Key. </li><li>  If we use the built-in sampler script, do not forget about Compilation Cache Key. </li><li>  If you need an analogue of bsh.shared, use the above solution. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/250731/">https://habr.com/ru/post/250731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250721/index.html">HighLoad in the platform for online auto parts stores</a></li>
<li><a href="../250723/index.html">Ara, yes? Or the modular smartphone of the future</a></li>
<li><a href="../250725/index.html">Results of testing algorithms of Russian biometric companies in the world market</a></li>
<li><a href="../250727/index.html">DIY Math Package for Android</a></li>
<li><a href="../250729/index.html">How to simplify the verification of a bank card holder for online payments?</a></li>
<li><a href="../250733/index.html">Introducing the Realtek RTL8954C debug card</a></li>
<li><a href="../250735/index.html">What DDoS protection services do not negotiate or why protection does not work</a></li>
<li><a href="../250743/index.html">Weekly assembly Vivaldi 1.0.105.7</a></li>
<li><a href="../250745/index.html">The story of one failure (the development of the first mobile game) with conclusions and tips</a></li>
<li><a href="../250749/index.html">Where do the security gaps come from?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>