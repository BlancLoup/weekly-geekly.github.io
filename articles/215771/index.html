<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we saved eyes with opencv</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post has been delayed for 4 months. We are a young development team, and we are just learning to break dead lines, but it seems that we‚Äôve got a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we saved eyes with opencv</h1><div class="post__text post__text-html js-mediator-article">  This post has been delayed for 4 months.  We are a young development team, and we are just learning to break dead lines, but it seems that we‚Äôve got a good turn.  The prehistory in <a href="http://habrahabr.ru/post/197986/">this article</a> , where we promised to lay out a sequel.  The story will go about how our application works (or does not work, it's up to the reader). <br><br>  Which app?  We are a Viewaide project team (formerly EyeDoc) and are writing software that, using a webcam, determines eye fatigue parameters and displays notifications, the task of which is to reduce the risk of vision deterioration due to long work at the monitor.  Than 100 times to hear, it is better to see 1 time. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/vkxjJw2b5p4%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253&amp;usg=ALkJrhh_l5trpiNPd97DOgAKwUiTD3-hGA" frameborder="0" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can download and try <a href="http://viewaide.com/">this link</a> , as they say, ‚Äúfor free, without SMS‚Äù.  In addition to the software, we also have a part of the web-service, but about everything in order. <br><a name="habracut"></a><br>  How painful it is for us to realize that the monitor is harmful to the eyes is described in the <a href="http://habrahabr.ru/post/197986/">previous article</a> , but briefly I want to say that we started doing such things not for profit (although someone will refuse it), but for the sake of solving our own problem.  A year ago, when we were just starting work on the project, the problem was acute: one co-founder struggled to catch a minibus, and the second was actively approaching the sight of the first.  Not to be unfounded, a few numbers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd9/630/c41/cd9630c413b2bb6d04515a7f5f212f44.jpg"><br><br>  <a href="http://www.computer-vision-syndrome.org/">Computer visual syndrome</a> (GLC) is a temporary condition resulting from prolonged continuous focusing of the eyes on the display. <br><br>  According to <a href="http://en.wikipedia.org/wiki/National_Institute_of_Occupational_Safety_and_Health">some sources</a> , about 75% of people who work at the computer for more than 3 hours a day are exposed to the visual symptoms of this syndrome. <br><br>  GLC occurs as a result of eye fatigue, resulting in headaches, blurred vision, redness in the eyes, tension, fatigue, dry eyes, and as a result - loss of visual acuity.  It may also be a cause for the development of more serious eye diseases.  What can we say, if about 40 million Americans suffer from dry eye syndrome.  Dry eye symptoms are the number one reason for visiting an ophthalmologist in the United States. <br><br>  Having studied in more detail the material on this topic in the network, after talking with ophthalmologists, we learned that eye fatigue can be determined by some parameters: <br><ul><li>  squinting </li><li>  blink rate </li><li>  average distance between monitor and user, etc. </li></ul><br>  These are the factors by which one can determine whether a person‚Äôs eyes are tired.  And subsequently, the very ignoring of these little things may further aggravate the situation. <br><br>  Frankly, the idea came not after a meticulous market research and analysis of current IT trends, but after we thought: ‚ÄúWhy would you code such a code more abruptly?‚Äù A year ago, Image Processing seemed cool.  Then we thought about it: ‚ÄúThe webcam is constantly in front of the nose, is it really necessary only to talk in Skype?‚Äù We wanted to create not only something cool, but also useful.  So the idea appeared that if the eyes are always in the camera's view, then you only need to properly process their image, taking into account various factors (eye fatigue parameters are given above), and maybe something will work out. <br><br>  The choice of development tools fell on <a href="http://qt-project.org/">Qt</a> + <a href="http://opencv.org/">OpenCV</a> .  Qt liked not only because it was a beautiful green color, with a convenient code editor and syntax highlighting, but also because it gave a chance to create cross-platform applications for people with C ++ hardening.  Now there is a hope that it will be possible to write full-fledged <a href="http://qt.digia.com/Product/Qt-for-Mobile-Development/Qt-Mobile-Edition/">mobile applications</a> .  Wait and see.  If Qt was responsible for the GUI, then something else was needed to work with the images.  OpenCV is a library written by computer vision adepts from Intel.  It has very detailed documentation and many examples on the web.  Oh yeah, all these development tools are free, including for commercial use, which is a big plus. <br><br><h2>  Task ‚Ññ1 Get images of the eyes using a web-camera. </h2><br>  If you can perform any manipulations with the image, you must first get it.  And in this case it is enough to get only an image of the eyes.  We'll get the streaming video from the webcam; there are plenty of <a href="http://robocraft.ru/blog/computervision/275.html">examples</a> on the net. <br><br>  The search for objects in an image in OpenCV is implemented <a href="http://habrahabr.ru/post/133826/">by the Viola-Jones method</a> .  The theme of pattern recognition is not biased towards frequent innovations, the method was introduced in 2001, and 13 years later it is still leading in its field.  If in short, the method substitutes the so-called Haar primitives, which are a set of elementary combinations of dark and light areas, and if an area is found in the image in which a sufficient number of primitives fits, then the object is found.  In order to understand whether this area is bright or dark, it is necessary to sum up the value of the neighboring pixels.  In order not to do this many times in the process of searching for an object, the image is translated into an <a href="http://robocraft.ru/blog/computervision/536.html">integral representation</a> .  Despite all the optimization of the speed of the method, searching for a person on video in real-time on a budget PC cannot be achieved.  Or is it still possible? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc9/dbf/b06/bc9dbfb0624a5f3388ff0b64e03d25e5.jpg" width="500" height="550"><br><br>  So, the task is to find the user's eyes with a webcam.  Take the image resolution of 640x480. <br><br><pre><code class="hljs pgsql">vHaarDetectObjects(frame,left_eye_cascade,<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>,<span class="hljs-number"><span class="hljs-number">1.1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,CV_HAAR_DO_CANNY_PRUNING,cvSize(<span class="hljs-number"><span class="hljs-number">22</span></span>,<span class="hljs-number"><span class="hljs-number">22</span></span>);</code> </pre> <br>  The purpose of this function is to find the left eye.  If you solve the problem in the forehead, then the speed will be just awful, and the processor load is too big for the background application.  In addition, there will be a lot of unnecessary positives.  Therefore, it was decided - you need to start with a face search. <br><br><pre> <code class="hljs pgsql">vHaarDetectObjects(frame,face_cascade,<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>,<span class="hljs-number"><span class="hljs-number">1.1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,CV_HAAR_DO_CANNY_PRUNING,cvSize(<span class="hljs-number"><span class="hljs-number">80</span></span>,<span class="hljs-number"><span class="hljs-number">80</span></span>);</code> </pre> <br>  Already works more brightly.  What has changed?  The last argument of the function determines the minimum size of the desired object.  In numerous examples, OpenCV states that for eyes it is necessary to look for an area of ‚Äã‚Äãat least 22x22 pixels, and for a face it is possible to have 80x80.  Here it becomes clear why the search for the face is faster: to go over the entire image with a 22x22 area is far from as fast as 80x80.  For comparison, on my Intel Core 2 Duo 2.2 GHz machine, RAM 2 Gb, the eye search function takes an average of 900 milliseconds, and the face search takes 200 milliseconds. <br><br>  As you know, the face is not square (unless our user is Sponge Bob).  Let's make the minimum search area rectangular.  With these figures, the work time is already 160 milliseconds. <br><br><pre> <code class="hljs pgsql">vHaarDetectObjects(frame,face_cascade,<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>,<span class="hljs-number"><span class="hljs-number">1.1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,CV_HAAR_DO_CANNY_PRUNING,cvSize(<span class="hljs-number"><span class="hljs-number">80</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span>);</code> </pre> <br>  What is the 3rd argument, equal to 1.1?  This is the step with which the ‚Äúsearch window‚Äù is expanded.  That is, if there were no faces with dimensions 80x120, then the size is multiplied by 1.1.  And what if you increase not by 10%, but by 20%?  Not bad, the running time is already 100 milliseconds. <br><br><pre> <code class="hljs pgsql">vHaarDetectObjects(frame,face_cascade,<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>,<span class="hljs-number"><span class="hljs-number">1.2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,CV_HAAR_DO_CANNY_PRUNING,cvSize(<span class="hljs-number"><span class="hljs-number">80</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span>);</code> </pre> <br>  And one more thought.  Why do we need the image 640x480?  If you reduce it by 2 times (now 320x240), then you can quickly search for the desired object.  Having reduced the image, we see that the face can be seen as well.  It is logical that the speed increased by 2 times, the operation time - 50 milliseconds. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dee/b98/25d/deeb9825d373ecaf527ed81b7fdd18cf.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/532/75e/8db/53275e8dbd4f67d53a9a775aac185307.jpg"><br><br><pre> <code class="hljs pgsql">vHaarDetectObjects(frame,face_cascade,<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>,<span class="hljs-number"><span class="hljs-number">1.2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,CV_HAAR_DO_CANNY_PRUNING,cvSize(<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">60</span></span>);</code> </pre> <br>  The face search works more or less tolerably, but we still need eyes.  There is no point in looking for them all over your face.  It is better to identify areas where they can, in principle, be located.  The idea is easy to illustrate. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbc/613/064/fbc613064c67a6744e10782a06ac0bab.png"><br><br>  Already inside these areas we will look for the eyes.  Agree that the amount of work has become much smaller compared with the amount of work when searching for the entire image.  In addition, the probability of a false positive is already low. <br><br>  Do we need to look for a face in every frame?  Hardly.  The main goal is to find the eyes.  In order not to complicate the life of the processor, complicate it yourself.  When the eye is found, take the rectangle in which it is located and increase the area by 2 times.  Then we apply this area to the next frame of video from the webcam, and voila!  With high enough fps (and we just tried to speed up the processing of each frame) in this area it is very likely to find our eye. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1f/032/355/f1f032355667df5a6eebbefbd2446587.jpg"><br><br>  The screenshot shows the main stages of an optimized eye search.  If the eyes are not found, then after several attempts, you need to return to the face search. Now the search function, with all its components, takes an average of 30 milliseconds of processor time, which is 30 times less than the head-on approach. <br><br><h2>  Task ‚Ññ2 Determination of the distance to the monitor. </h2><br>  To solve this problem, <a href="http://alexkutsan.blogspot.com/2012/10/pythonopencv.html">this article</a> has helped us prohibitively. In this example, the author gives us a fairly simple geometry, demonstrating the work of a webcam: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/ecf/d23/5daecfd230c31ab20eb003975b35ccd7.jpg"><br><br>  In this case, we see that the triangles ABC and ECD are similar.  We will hold two heights from point C and remove all unnecessary information. <br><img src="https://habrastorage.org/getpro/habr/post_images/dbf/d16/4fa/dbfd164fa84eaea13d52dcfbf19d92b8.jpg" width="400" height="300"><br>  Now, looking at the geometric version of the webcam, we understand that the ratio of the sides AB / CF is equal to the ratio ED / CH.  Let's calculate this ratio.  This is done very simply.  Place a line of 10 cm in front of the webcam so that it fits in frame from edge to edge.  After that, measure the distance from the camera to the ruler.  Our result will be equal to 16 cm. The ratio of the distance to the length of the ruler, respectively, 16/10 = 1.6. <br><br>  If the face area completely enters the frame, we will get a distance of 24 cm (1.6 * 15).  Why 15 cm?  Because the average length of a person's face is just that.  The error due to the average value is almost imperceptible (only if you, again, not Sponge Bob).  Now it's up to you.  It is necessary to determine the distance if the person occupies less than 100% in the frame.  To do this, it is enough to determine the number of centimeters in one percent.  And this is 24/100 = 0.24.  Thus, we calculate that the distance to the monitor = 24 + (100% is the percentage of space occupied by the person in the frame) * 0.24. <br><br>  In fact, we take not the face area as the reference point, but the distance between the eyes.  This is due to the fact that the search for the eyes is carried out at each iteration of the application, and the search for the face - only when necessary.  And in general, It`s all about eyes. <br><br><h2>  Task number 3 Definition of squinting / blinking. </h2><br>  In general, squinting is a very subjective parameter.  And one would not have thought about it if it were not for the remarks of the parents in childhood ‚Äúdo not squint, username‚Äù.  Nevertheless, it is necessary to tell about its implementation, since the recognition of blinks follows from this. <br><br>  Question one: what distinguishes a fully open eye from a half-closed or closed?  The distance between the centuries.  So, it is necessary to look for him.  On the image, the eyelids are represented by a thin border of color transition.  Then the solution is to find the border in the image. <br><br>  In between times, I would like to advise a very interesting book <a href="http://rutracker.org/forum/viewtopic.php%3Ft%3D2127548">Marr D. - Sight.</a>  <a href="http://rutracker.org/forum/viewtopic.php%3Ft%3D2127548">Informational approach to the study of the presentation and processing of visual images</a> .  It describes quite an interesting approach to human vision in accordance with the theory of information.  If you adhere to the theory described in the above literature, then even such wonders of sight, like stereoscopy, begin with the search for boundaries in the image.  The most popular border <a href="http://robocraft.ru/blog/computervision/484.html">detector is Kenny's border detector</a> .  Whether the image was very small, or the hands were crooked, or the moon was not in that phase, but the results were inaccurate, so I had to go a little deeper into the details. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a64/a48/c3f/a64a48c3f70f957f17772f86625c84fb.jpg"><br><br>  We start the classic search for boundaries with the use of a Gaussian filter that helps to get rid of noise.  In fact, it turns out that the images of the eyes are so small and pixelated that they do not need additional blurring.  The next step is a face search.  Faces are nothing but sharp color transitions.  For convenience, you can convert the image to monochrome.  Anyway, the borders of the eyelids represent a contrasting transition, and the black and white image reflects this perfectly, only it is easier to process it. <br><br>  To find a sharp brightness transition, we use the differential operator (the <a href="http://robocraft.ru/blog/computervision/460.html">Laplace operator</a> is best suited for this operation. The Sobel operator is also used).  Without going into details, let's think about why the differential?  If the edges are a sharp color transition, then the difference between the sum of the values ‚Äã‚Äãof neighboring pixels on the border and near it should be greater than in areas of the same color.  If we replace ‚Äúthe sum of the pixel values‚Äù with the word ‚Äúfunction‚Äù, then it is clear that we are interested in the places of its sharp change.  Just for such situations comrades Leibniz and Newton came up with differential calculus. <br><br><pre> <code class="hljs matlab">vLaplace(<span class="hljs-built_in"><span class="hljs-built_in">eye</span></span>, dst, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  OpenCV has a ready implementation of this operator with a simple application.  Therefore, it is enough to indicate the original image, the address for the resultant, as well as the dimension of the square matrix of pixels that the operator will ‚Äúwalk‚Äù in the image, performing a differential rite. <br><br>  To remove unnecessary areas in the selection area, and generally make your life easier, you can binarize the image (in other words, leave only 2 colors: black and white, no shades).  To do this, you can use the threshold conversion.  To begin with, we take the average color of the pixels, and then convert everything below this value to black, which is higher ‚Äî to white. <br><br><pre> <code class="hljs lisp">cvThreshold(<span class="hljs-name"><span class="hljs-name">dst</span></span>,dst,threshold,<span class="hljs-number"><span class="hljs-number">255</span></span>,CV_THRESH_BINARY)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Here the threshold is our average.  Next, you need to perform several cosmetic improvements, such as: clustering white pixels (faces) in order to highlight the largest clusters and remove false ones;  sorting clusters by area (but this is not so important, besides, I don‚Äôt want to bore the reader or throw code at it, especially if he has read this far, which is already nice). We illustrate the process described above step by step. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ef/7f8/c75/3ef7f8c75b126f0593bd486fc9e24a97.jpg" height="120"><br><br>  It remains only to count the number of pixels between the upper boundary and the lower (upper and lower eyelids) and compare with the normal state, which is preserved during calibration. <br><br>  Oh yeah, how to implement the recognition of blinking?  Everything is simple, a closed eye is characterized by the fact that its upper eyelid is below the midline of the eye, this is the condition that is checked. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d0/5c3/a6a/2d05c3a6ad1090cdd4c20c82d82e9bf3.jpg" height="120"><br><br><h2>  Task number 4 - Determination of the level of illumination. </h2><br>  The level of illumination also plays an important role if you are worried about your vision.  The work area can be considered not very well organized if you work in a dark room, and the bright display prohibits your eyes beyond limit.  It is also better not to sit in front of the computer if another bright source of light shines into the eyes behind the screen.  Still do not forget about the glare that the monitor can create from a light source, located behind you.  It is hardly possible to completely eliminate such a problem with a webcam.  But we still tried to implement a partial solution. <br><br>  So what do you need to do?  First we need to divide the image into 2 parts: the face and everything else, that is, the background.  We will compare the brightness of these two pictures.  You can easily convert the image to monochrome, because we do not care what saturation to consider, the total or divided into three channels (RGB).  Our next step is to build histograms from two images.  This procedure is necessary for us to subsequently have an idea of ‚Äã‚Äãthe overall level of brightness of the image. <br><br>  As a result, the horizontal axis represents the brightness, and the vertical axis shows the relative number of pixels with a specific brightness value.  Next, we conditionally divide the pixels into light and dark.  From each image there are 4 groups.  Now, with a certain analysis and comparison between these 4 groups, we can draw several conclusions: when all the number of dark pixels significantly predominates both on the face and on the background, then we work in a dark room, and only the monitor emits light.  When the number of bright pixels on the face is much more than on the background, it means that behind the monitor there is some other source of light that shines directly into our faces.  It can be either a desk lamp or the sun outside the window.  An example of image splitting into face and background, followed by the construction of histograms is presented below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c76/f57/aa9/c76f57aa9447d1dd2ba3fc3ae5b7ef7c.jpg"><br>  In this case, the user is in a dark room, and the desk lamp shines directly into the face, which is not right.  It is quite logical to assume that here we cannot take into account the difference between the amount of light, color and its saturation.  We tried to do this in several ways.  However, histograms were the most effective way to predict the level of illumination. <br><br>  It is impossible not to say how entertaining the process of testing all this joy is.  And how sad it is, when everything works at home ‚Äúwith a bang‚Äù, and when you demonstrate the application to your friends, it will determine the eye in the nose, or else where it is worse.  Algorithms definitely need constant optimization.  But if after a month of work, the results scared us with our inaccuracy, then a year later we ourselves began to use our application.  It still has a lot of unexpected bugs, but from your own experience you can say that, in general, everything works tolerably.  Sometimes you start to squint because of the unusual brightness, sometimes, immersed in the work, you approach the monitor and really do not notice it.  This is where Viewaide tells you to be inattentive.  Now is the time to share the result of our work with the IT-community, with those who more often think about a possible deterioration of vision or a decrease in efficiency. <br><br>  A full Windows version is currently available, as well as a Beta version on Mac.  Within a month, we plan to release a ready-made application on Mac and Linux.  And if the community is interested, then 2 articles will be published on the subtleties of porting Qt applications from Windows to Mac and Linux. <br><br>  We would appreciate any criticism.  And if you have not downloaded Viewaide yet, then it's time <a href="http://viewaide.com/">to do it</a> . </div><p>Source: <a href="https://habr.com/ru/post/215771/">https://habr.com/ru/post/215771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215759/index.html">HiRISE high-resolution ‚Äúpopular‚Äù camera at the Mars Reconnaissance Orbiter received an HD shot of the Martian crater</a></li>
<li><a href="../215763/index.html">Moscow hackspace Neuron accepts bitcoins</a></li>
<li><a href="../215765/index.html">Google Drive reduces the price of cloud gigabytes several times</a></li>
<li><a href="../215767/index.html">A unique video of a volcanic eruption was filmed using a quadrocopter.</a></li>
<li><a href="../215769/index.html">Plugin for working with Gist in Notepad ++</a></li>
<li><a href="../215773/index.html">They promise a hot summer ... Changes in the "anti-piracy" law take effect July 1, 2014</a></li>
<li><a href="../215775/index.html">Rapid generation of random number arrays for simulation, statistical estimation, and re-sampling</a></li>
<li><a href="../215777/index.html">Javascript: suction fractal</a></li>
<li><a href="../215779/index.html">To the 45th anniversary of the Apollo-9 spacecraft flight: exposing a popular myth about a lunar module allegedly made of foil</a></li>
<li><a href="../215785/index.html">NASA Announces Computer Algorithm Contest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>