<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 4: Client and Server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". 

 Content: 


- Chapter 1: Getting Started with Boost....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 4: Client and Server</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". <br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/192284/">Chapter 1: Getting Started with Boost.Asio</a> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <a href="http://habrahabr.ru/post/193038/">Part 1: The Basics of Boost.Asio</a> </li><li>  <a href="http://habrahabr.ru/post/195006/">Part 2: Asynchronous Programming</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/195386/">Chapter 3: Echo Server / Client</a> </li><li>  <b>Chapter 4: Client and Server</b> </li><li>  <a href="http://habrahabr.ru/post/196354/">Chapter 5: Synchronous vs. Asynchronous</a> </li><li>  <a href="http://habrahabr.ru/post/196888/">Chapter 6: Boost.Asio - Other Features</a> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  In this chapter, we are going to delve into creating non-trivial client / server applications using Boost.Asio.  You can run and test them, and once you understand them, you can use them as a basis for creating your own applications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  In the following applications: <br><ul><li>  Client enters server with username (without password) </li><li>  All connections are initiated by the client, where the client requests a response from the server </li><li>  All requests and responses to them end with the character '\ n' </li><li>  The server disables any client that does not ping for 5 seconds. </li></ul><br>  The client can make the following requests: <br><ul><li>  Get a list of all connected clients </li><li>  The client can respond, and when it pings the server to respond either to <code>ping_ok</code> or <code>ping client_list_chaned</code> (in the latter case, the client re-requests a list of connected clients). </li></ul><br>  For interest, add a few frills: <br><ul><li>  Each client application includes 6 connected users, such as John, James, Lucy, Tracy Frank and Abby. </li><li>  Each client checks the connection with the server at a random point in time (every 1-7 seconds, thus, from time to time the connection with the server will be disconnected) </li></ul><br><br><h4>  Synchronous server / client </h4><br>  First, we implement a synchronous application.  You will see that the code is simple and easy to understand.  However, the network part must be executed in a separate thread, since all network calls are blocked. <br><br><h5>  Synchronous client </h5><br>  The synchronous client, as you expected, does everything consistently;  connects to the server, enters it, and then performs a communication cycle, namely, fall asleep, make a request, read the server's response, fall asleep again, and so on. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/81c/762/b9981c7620aae9e4668bbeba8d9c1fd3.png"><br><br>  Since we are making the synchronous option, this allows us to make some things simpler.  First, connect to the server;  let's do it in the form of a loop, for example, like this: <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; client_name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">talk_to_svr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client_name)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { client.connect(ep); client.loop(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(boost::system::system_error &amp; err) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"client terminated "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }</code> </pre><br>  The following example is the class <code>talk_to_svr</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_svr</span></span></span><span class="hljs-class"> {</span></span> talk_to_svr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; username): sock_(service), started_(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), username_(username) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::endpoint ep)</span></span></span><span class="hljs-function"> </span></span>{ sock_.connect(ep); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ write(<span class="hljs-string"><span class="hljs-string">"login "</span></span> + username_ + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); read_answer(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( started_) { write_request(); read_answer(); boost::this_thread::sleep(millisec(rand() % <span class="hljs-number"><span class="hljs-number">7000</span></span>)); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">username</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> username_; } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ip::tcp::socket sock_; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { max_msg = <span class="hljs-number"><span class="hljs-number">1024</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> already_read_; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff_[max_msg]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> started_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> username_; };</code> </pre><br>  In the loop, we just ping, read the response from the server, and fall asleep.  We fall asleep indefinitely (sometimes more than 5 seconds), so at some point the server will shut us down: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ write(<span class="hljs-string"><span class="hljs-string">"ping\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_answer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ already_read_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; read(sock_, buffer(buff_), boost::bind(&amp;talk_to_svr::read_complete, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, _1, _2)); process_msg(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buff_, already_read_)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"login "</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_login(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_ping(msg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"clients "</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_clients(msg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"invalid msg "</span></span> &lt;&lt; msg &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  To read the response, we use <code>read_complete</code> (which was discussed a lot in the last chapter) to make sure that we read the symbol '\ n'.  The logic is contained in the <code>process_msg()</code> function, where we read the client's response and direct it to the correct function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_ask_clients(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">istringstream</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> answer; in &gt;&gt; answer &gt;&gt; answer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( answer == <span class="hljs-string"><span class="hljs-string">"client_list_changed"</span></span>) do_ask_clients(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> clients = msg.substr(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; username_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">", new client list:"</span></span> &lt;&lt; clients; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ask_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ write(<span class="hljs-string"><span class="hljs-string">"ask_clients\n"</span></span>); read_answer(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ sock_.write_some(buffer(msg)); } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boost::system::error_code &amp; err, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-comment"><span class="hljs-comment">// ... same as before }</span></span></code> </pre><br>  When reading the response from the server in our ping, if we get <code>client_list_changed</code> , then we again make a request for a sheet of clients. <br><br><h5>  Synchronous server </h5><br>  Synchronous server is also quite simple.  It needs two threads, one to listen to new customers, the other to handle existing ones.  It cannot use a single thread, waiting for a new client is a blocking operation, so we need an additional stream to process existing clients. <br><br><img src="http://habrastorage.org/storage3/828/809/c3f/828809c3f98b1e13000ca0b105f90faa.png"><br><br>  As expected, the server is a little more difficult to write than the client.  On the one hand, it must manage all connected clients.  Since we are writing a synchronous version of the server, we need at least two streams, one of which accepts new clients (since <code>accept()</code> blocking operation), and the other is responsible for existing ones: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ip::tcp::<span class="hljs-function"><span class="hljs-function">acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ip::tcp::endpoint(ip::tcp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-function"><span class="hljs-function">client_ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> talk_to_client)</span></span></span></span>; acceptor.accept(new_-&gt;sock()); boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs)</span></span></span></span>; clients.push_back(new_); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_clients_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { boost::this_thread::sleep( millisec(<span class="hljs-number"><span class="hljs-number">1</span></span>)); boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>::iterator b = clients.begin(),e = clients.end(); b != e; ++b) (*b)-&gt;answer_to_client(); <span class="hljs-comment"><span class="hljs-comment">// erase clients that timed out clients.erase(std::remove_if(clients.begin(), clients.end(), boost::bind(&amp;talk_to_client::timed_out,_1)), clients.end()); } } int main(int argc, char* argv[]) { boost::thread_group threads; threads.create_thread(accept_thread); threads.create_thread(handle_clients_thread); threads.join_all(); }</span></span></code> </pre><br>  We need a list of clients to handle incoming requests from them. <br>  Each instance of <code>talk_to_client</code> has a socket.  It does not have a copy constructor, so if you want to stuff it into <code>std::vector</code> , then you need to get a shared pointer on it.  There are two ways to do this: either inside the <code>talk_to_client</code> get a shared pointer to the socket, and then make an array of instances of <code>talk_to_client</code> or when there is an instance of talk_to_client with a socket by value and get an array of shared pointer on talk_to_client.  I chose the latter, but you can go another way: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;talk_to_client&gt; client_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;client_ptr&gt; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> clients; boost::recursive_mutex cs; <span class="hljs-comment"><span class="hljs-comment">// thread-safe access to clients array</span></span></code> </pre><br>  The main <code>talk_to_client</code> code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_client</span></span></span><span class="hljs-class"> :</span></span> boost::enable_shared_from_this&lt;talk_to_client&gt; { talk_to_client() { ... } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">username</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> username_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">answer_to_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read_request(); process_request(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> ( boost::system::system_error&amp;) { stop(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( timed_out()) stop(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_clients_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clients_changed_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ip::tcp::<span class="hljs-function"><span class="hljs-function">socket &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sock_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timed_out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ptime now = microsec_clock::local_time(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ms = (now - last_ping).total_milliseconds(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms &gt; <span class="hljs-number"><span class="hljs-number">5000</span></span> ; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ boost::system::error_code err; sock_.close(err); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sock_.available()) already_read_ += sock_.read_some( buffer(buff_ + already_read_, max_msg - already_read_)); } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... same as in Synchronous Client bool clients_changed_; ptime last_ping; };</span></span></code> </pre><br>  The above code is pretty obvious.  The most important function is <code>read_request()</code> .  Reading will occur only if there is data, so the server will never be blocked: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> found_enter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find(buff_, buff_ + already_read_, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &lt; buff_ + already_read_; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !found_enter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// message is not full // process the msg last_ping = microsec_clock::local_time(); size_t pos = std::find(buff_, buff_ + already_read_, '\n') - buff_; std::string msg(buff_, pos); std::copy(buff_ + already_read_, buff_ + max_msg, buff_); already_read_ -= pos + 1; if ( msg.find("login ") == 0) on_login(msg); else if ( msg.find("ping") == 0) on_ping(); else if ( msg.find("ask_clients") == 0) on_clients(); else std::cerr &lt;&lt; "invalid msg " &lt;&lt; msg &lt;&lt; std::endl; } void on_login(const std::string &amp; msg) { std::istringstream in(msg); in &gt;&gt; username_ &gt;&gt; username_; write("login ok\n"); update_clients_changed(); } void on_ping() { write(clients_changed_ ? "ping client_list_changed\n" : "ping ok\n"); clients_changed_ = false; } void on_clients() { std::string msg; { boost::recursive_mutex::scoped_lock lk(cs); for( array::const_iterator b = clients.begin(), e = clients.end() ;b != e; ++b) msg += (*b)-&gt;username() + " "; } write("clients " + msg + "\n"); } void write(const std::string &amp; msg) { sock_.write_some(buffer(msg)); }</span></span></code> </pre><br>  Take a look at <code>process_request()</code> .  After we considered the data that was available, we should check whether we <code>found_enteris</code> message to the end (if yes, the <code>found_enteris</code> set to true).  If this is the case, then we protect ourselves from reading, maybe more than one message (after the '\ n' character, nothing will be saved to the buffer), and then we interpret the completely read message.  The rest of the code is pretty simple. <br><br><h4>  Asynchronous server / client </h4><br>  And now the most interesting (and difficult) part, let's go asynchronously. <br><br><h5>  Asynchronous client </h5><br>  Things will now be considered a little more complicated, but, of course, manageable.  And we will have an application that is not blocked. <br><br><img src="http://habrastorage.org/storage3/8b4/b3c/9b0/8b4b3c9b004b7500d82f3889012d04d8.png"><br><br>  You should already understand the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN(x) boost::bind(&amp;self_type::x, shared_from_this()) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN1(x,y) boost::bind(&amp;self_type::x, shared_from_this(),y) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN2(x,y,z) boost::bind(&amp;self_type::x, shared_from_this(),y,z) class talk_to_svr : public boost::enable_shared_from_this</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;talk_to_svr&gt;, boost::noncopyable { typedef talk_to_svr self_type; talk_to_svr(const std::string &amp; username) : sock_(service), started_(true), username_(username), timer_(service) {} void start(ip::tcp::endpoint ep) { sock_.async_connect(ep, MEM_FN1(on_connect,_1)); } public: typedef boost::system::error_code error_code; typedef boost::shared_ptr&lt;talk_to_svr&gt; ptr; static ptr start(ip::tcp::endpoint ep, const std::string &amp; username) { ptr new_(new talk_to_svr(username)); new_-&gt;start(ep); return new_; } void stop() { if ( !started_) return; started_ = false; sock_.close(); } bool started() { return started_; } ... private: size_t read_complete(const boost::system::error_code &amp; err, size_t bytes) { if ( err) return 0; bool found = std::find(read_buffer_, read_buffer_ + bytes, '\n') &lt; read_buffer_ + bytes; return found ? 0 : 1; } private: ip::tcp::socket sock_; enum { max_msg = 1024 }; char read_buffer_[max_msg]; char write_buffer_[max_msg]; bool started_; std::string username_; deadline_timer timer_; };</span></span></span></span></code> </pre><br>  You will see an additional <code>deadline_timer</code> timer function for pinging the server;  and again, we will check the connection to the server at a random point in time. <br>  Well, now let's see what the main logic of the class looks like: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !err) do_write(<span class="hljs-string"><span class="hljs-string">"login "</span></span> + username_ + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stop(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) stop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// process the msg std::string msg(read_buffer_, bytes); if ( msg.find("login ") == 0) on_login(); else if ( msg.find("ping") == 0) on_ping(msg); else if ( msg.find("clients ") == 0) on_clients(msg); } void on_login() { do_ask_clients(); } void on_ping(const std::string &amp; msg) { std::istringstream in(msg); std::string answer; in &gt;&gt; answer &gt;&gt; answer; if ( answer == "client_list_changed") do_ask_clients(); else postpone_ping(); } void on_clients(const std::string &amp; msg) { std::string clients = msg.substr(8); std::cout &lt;&lt; username_ &lt;&lt; ", new client list:" &lt;&lt; clients ; postpone_ping(); }</span></span></code> </pre><br>  In <code>on_read()</code> in the first two lines of the code everything is done very beautifully.  In the first line, we check if there is an error, if so, we stop.  In the second line, we check whether we stopped (before or just that), if so, we return.  Otherwise, if all is well, we process the incoming message. <br>  Finally, the <code>do_*</code> functions <code>do_*</code> as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_write(<span class="hljs-string"><span class="hljs-string">"ping\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postpone_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ timer_.expires_from_now(boost::posix_time::millisec(rand() % <span class="hljs-number"><span class="hljs-number">7000</span></span>)); timer_.async_wait( MEM_FN(do_ping)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ask_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_write(<span class="hljs-string"><span class="hljs-string">"ask_clients\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ do_read(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ async_read(sock_, buffer(read_buffer_), MEM_FN2(read_complete,_1,_2), MEM_FN2(on_read,_1,_2)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(msg.begin(), msg.end(), write_buffer_); sock_.async_write_some( buffer(write_buffer_, msg.size()), MEM_FN2(on_write,_1,_2)); }</code> </pre><br>  Please note that each <code>read</code> operation causes a ping: <br><ul><li>  When the <code>read</code> operation completes, <code>on_read()</code> </li><li>  <code>on_read()</code> redirected to <code>on_login(), on_ping()</code> , or <code>on_clients()</code> </li><li>  Each of the functions either postpones ping or requests customers </li><li>  If we request clients when the read operation has received them, it will postpone the ping </li></ul><br><br><h5>  Asynchronous server </h5><br>  The scheme is quite complicated, you can see that four arrows go from Boost.Asio to <code>on_accept, on_read, on_write</code> and <code>on_check_ping</code> .  Basically, this means that you will never know by calling which of these asynchronous operations will all end, but you know for sure that this will be one of them. <br><br><img src="http://habrastorage.org/storage3/838/8b5/614/8388b56149cd8278cc37b8a9547c68d5.png"><br><br>  So, we work asynchronously, so we can work in one thread.  Receiving customers is the easiest part, as shown in the following code snippet: <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ip::tcp::endpoint(ip::tcp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(talk_to_client::ptr client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err)</span></span></span><span class="hljs-function"> </span></span>{ client-&gt;start(); talk_to_client::ptr new_client = talk_to_client::new_(); acceptor.async_accept(new_client-&gt;sock(), boost::bind(handle_accept,new_client,_1)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ talk_to_client::ptr client = talk_to_client::new_(); acceptor.async_accept(client-&gt;sock(), boost::bind(handle_accept,client,_1)); service.run(); }</code> </pre><br>  The code above will always wait for new clients asynchronously (each new client connection will cause a different asynchronous wait). <br>  We have to monitor the <code>client list changed</code> event (a new client has connected or one of the clients received the list and disconnected) and notify other clients when this happens.  Thus, we need to store an array of clients, otherwise there would be no need for this array if you would not like to know all the connected clients at a given time: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_client</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;talk_to_client&gt; client_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;client_ptr&gt; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> clients;</code> </pre><br>  The skeleton of the <code>connection</code> class is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_client</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;talk_to_ client&gt;, boost::noncopyable { talk_to_client() { ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::system::error_code error_code; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;talk_to_client&gt; ptr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ started_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; clients.push_back( shared_from_this()); last_ping = boost::posix_time::microsec_clock::local_time(); do_read(); <span class="hljs-comment"><span class="hljs-comment">// first, we wait for client to login } static ptr new_() { ptr new_(new talk_to_client); return new_; } void stop() { if ( !started_) return; started_ = false; sock_.close(); ptr self = shared_from_this(); array::iterator it = std::find(clients.begin(), clients.end(), self); clients.erase(it); update_clients_changed(); } bool started() const { return started_; } ip::tcp::socket &amp; sock() { return sock_;} std::string username() const { return username_; } void set_clients_changed() { clients_changed_ = true; } ... private: ip::tcp::socket sock_; enum { max_msg = 1024 }; char read_buffer_[max_msg]; char write_buffer_[max_msg]; bool started_; std::string username_; deadline_timer timer_; boost::posix_time::ptime last_ping; bool clients_changed_; };</span></span></code> </pre><br>  I call <code>talk_to_client</code> or <code>talk_to_server</code> from the <code>connection</code> class to clarify what I'm saying. <br>  We will have to use the previous code now;  it is similar to what we used for the client application.  We have an additional <code>stop()</code> function that removes a connected client from an array of clients. <br>  The server continuously expects asynchronous read operations: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) stop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(read_buffer_, bytes)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"login "</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_login(msg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_ping(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"ask_clients"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_clients(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">istringstream</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span></span>; in &gt;&gt; username_ &gt;&gt; username_; do_write(<span class="hljs-string"><span class="hljs-string">"login ok\n"</span></span>); update_clients_changed(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_write(clients_changed_ ? <span class="hljs-string"><span class="hljs-string">"ping client_list_changed\n"</span></span> : <span class="hljs-string"><span class="hljs-string">"ping ok\n"</span></span>); clients_changed_ = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> msg; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>::const_iterator b =clients.begin(),e =clients.end(); b != e; ++b) msg += (*b)-&gt;username() + <span class="hljs-string"><span class="hljs-string">" "</span></span>; do_write(<span class="hljs-string"><span class="hljs-string">"clients "</span></span> + msg + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); }</code> </pre><br>  The code is pretty simple;  one thing is that when a new client enters the system, we call <code>update_clients_changed()</code> , which sets <code>clients_changed_</code> to <code>true</code> for all clients. <br>  As soon as he receives a request, he immediately responds to it, as shown in the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_write(<span class="hljs-string"><span class="hljs-string">"ping\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ask_clients</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_write(<span class="hljs-string"><span class="hljs-string">"ask_clients\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ do_read(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ async_read(sock_, buffer(read_buffer_), MEM_FN2(read_complete,_1,_2), MEM_FN2(on_read,_1,_2)); post_check_ping(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(msg.begin(), msg.end(), write_buffer_); sock_.async_write_some( buffer(write_buffer_, msg.size()), MEM_FN2(on_write,_1,_2)); } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boost::system::error_code &amp; err, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-comment"><span class="hljs-comment">// ... as before }</span></span></code> </pre><br>  At the end of each write operation, <code>on_write()</code> is called, which calls another asynchronous read, and thus waits for the request ‚Äî responds to it, the cycle continues until the client turns off or the timer runs. <br>  Since each reading begins with an asynchronous wait for 5 seconds, you can see if the client has a timer.  If so, then we close the connection: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_check_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ptime now = microsec_clock::local_time(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (now - last_ping).total_milliseconds() &gt; <span class="hljs-number"><span class="hljs-number">5000</span></span>) stop(); last_ping = boost::posix_time::microsec_clock::local_time(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post_check_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ timer_.expires_from_now(boost::posix_time::millisec(<span class="hljs-number"><span class="hljs-number">5000</span></span>)); timer_.async_wait( MEM_FN(on_check_ping)); }</code> </pre><br>  That's the whole server.  You can start it and start working with it! <br><br><h4>  Summary </h4><br>  In this chapter, we looked at how to write a few basic client / server applications.  We avoided such traps as memory leaks and deadlocks.  All programs are suitable as a basis for your future applications, they can be expanded and adapted. <br>  In the next chapter, we will get a deeper understanding of synchronous versus asynchronous, the differences when using Boost.Asio;  Let's see how you can connect your own asynchronous operation. <br><br>  Resources for this article: <a href="https://github.com/Vasilui/habrahabr/tree/master/Boost.Asio_C%252B%252B_Network_Programming/Chapter_4">link</a> <br><br>  Thank you all for your attention, until we meet again! </div><p>Source: <a href="https://habr.com/ru/post/195794/">https://habr.com/ru/post/195794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195772/index.html">Overview of the trading platform TetraMall</a></li>
<li><a href="../195778/index.html">Smart BLF and Digium D40 IP Phone Comparison</a></li>
<li><a href="../195784/index.html">YAC-2013: a round table on the problems of DDoS-attacks in the networks of large operators</a></li>
<li><a href="../195788/index.html">RCE in Android applications through third-party services</a></li>
<li><a href="../195792/index.html">Poll: A new life to a "spoiled" / outdated smartphone</a></li>
<li><a href="../195796/index.html">Through thorns in the market</a></li>
<li><a href="../195798/index.html">About choosing hard drives for servers</a></li>
<li><a href="../195800/index.html">Synchronization of the web developer workspace</a></li>
<li><a href="../195802/index.html">Strategy for promoting a new site. When will the top 10 and search traffic?</a></li>
<li><a href="../195804/index.html">Automatic lap and time counting system for RC cars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>