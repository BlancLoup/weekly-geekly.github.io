<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You must be kidding, Mr. Dahl, or why Node.js is the crown of web server evolution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js is a thing around which there is now a lot of noise, enthusiastic reviews and angry shouts. At the same time, according to my observations, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You must be kidding, Mr. Dahl, or why Node.js is the crown of web server evolution</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/f2e32d3f/e7465c41/a0239358/d0f78e08.png" alt="WTF is Node.js?"><br><br>  <a href="http://nodejs.org/" title="Node.js">Node.js</a> is a thing around which there is now a lot of noise, enthusiastic reviews and angry shouts.  At the same time, according to my observations, the following idea of ‚Äã‚Äãwhat Node.js is in the minds of people: ‚Äúthis is a thing that allows writing on JavaScript on the server side and using the JavaScript engine from Google Chrome‚Äù.  Fans of the language enthusiastically sighed: ‚ÄúAh!  It has come true! ‚Äù, The opponents said through clenched teeth:‚Äú Well, only this nonsense with prototypes and dynamic typing was not enough for us on the servers! ‚Äù.  And they ran together to break spears in blogs and forums. <br><br>  At the same time, many representatives of both camps hold the opinion that Node.js is an esoteric toy, a cheerful idea for transferring the language of browser scripts to the ‚Äúnew wheels‚Äù.  In order to be completely honest, I confess that I also adhered to this point of view.  At one fine moment, I gained inspiration and decided to "dig deeper."  It turned out that the creator of Node.js, <a href="http://github.com/ry" title="Ryan Dahl">Ryan Dahl, was</a> far from a fanatic, but a person trying to solve a real problem.  And his creation is not a toy, but a practical solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  So what is Node.js?  The <a href="http://nodejs.org/" title="Node.js">official site has an</a> inscription: "Evented I / O for V8 JavaScript".  Not very meaningful, right?  Well, let's try to ‚Äúinvent a bicycle‚Äù and ‚Äúinvent‚Äù this most notorious ‚ÄúEvented I / O for V8 JavaScript‚Äù.  Of course, we will not write any code (poor Ryan still had to do it), but just try to build a chain of conclusions that will lead us to the idea of ‚Äã‚Äãcreating Node.js and how it should be arranged. <br><br><h2>  Keep it simple, stupid </h2><br>  So, you know that web applications use a <a href="http://en.wikipedia.org/wiki/Client%25E2%2580%2593server_model" title="Client ‚Äì ‚Äã‚Äãserver model">client-server software model</a> .  The client is the user's browser, and the server is, for example, one of the machines in the data center of a certain hoster (select any one to your taste).  The browser requests a resource from the server, which, in turn, gives it to the client.  This way of communication between the client and the server is called ‚Äú <a href="http://en.wikipedia.org/wiki/Pull_technology" title="Pull technology">client pull</a> ‚Äù, because the client literally pulls ( <em>English</em> pull) the server - ‚ÄúGive me that page, give me ...‚Äù.  The server "ponders" the answer to the question of the annoying client and gives it to him in a digestible form. <br><br><img src="https://habrastorage.org/storage/a4bc2b7d/06587fa1/4619ad11/45b977ec.png" alt="Simple web server"><br><br>  So, we have a simplest web server model - a program that accepts requests from client browsers, processes them and returns a response. <br><br><h2>  Parallel universe </h2><br>  This is great, but such a simple server can communicate with only one user at a time.  If at the time of processing the request to contact another client, then he will have to wait until the server responds first.  So we need to parallelize the processing of requests from users.  The obvious solution: handle user requests in separate <a href="http://en.wikipedia.org/wiki/Thread_(computer_science)" title="Thread">threads</a> or operating system <a href="http://en.wikipedia.org/wiki/Process_(computing)" title="Process">processes</a> .  Let's call each such process or thread worker ( <em>English</em> worker). <br><br><img src="https://habrastorage.org/storage/7e5f6b0d/c170225b/b0fc86bf/e14a1f43.png" alt="Server with threads"><br><br>  In one form or another, many of the most popular web servers today (for example, <a href="httpd.apache.org/" title="Apache server official site">Apache</a> and <a href="http://www.iis.net/" title="Microsoft IIS official site">IIS</a> ) adhere to this approach.  This model is relatively simple to implement and at the same time can meet the needs of most small and medium-sized web resources today. <br><br>  But this model is completely incapable, if you need to process thousands of requests simultaneously.  There are several reasons for this.  First, creating processes and threads is a damn expensive thing for any operating system.  But we can go to the trick and create threads or processes in advance and use them as needed.  OK, we just came up with mechanisms called <a href="http://en.wikipedia.org/wiki/Thread_pool_pattern" title="Thread pool pattern">thread pool</a> for threads and <a href="httpd.apache.org/docs/2.0/mod/prefork.html" title="prefork">process prefork</a> .  This will help us not to waste resources on creating processes and threads, since this invoice operation can be performed, for example, when the server is started.  Secondly, what to do if all the workers created are busy?  Create new?  But we already fully loaded all the processor cores of our server; if we add several more threads or processes, they will compete for processor time with threads and processes already running.  So both those and others will work even more slowly.  Yes, and as noted earlier, creating and servicing threads and processes is a costly thing in terms of memory consumption, and if we create a stream for each of the thousands of users, then we may soon find ourselves in a situation where there is simply no memory left on the server and worker You will be in a state of constant competition for hardware resources. <br><br><h2>  To infinity and beyond! </h2><br>  It would seem that we were in an unsolvable situation with the available computing resources.  The only solution is to <a href="http://en.wikipedia.org/wiki/Scalability" title="Scalability">scale hardware resources</a> , which is costly in all respects.  Let's try to look at the problem from the other side: what are the majority of our workers doing?  They accept the request from the client, create a response and send it to the client.  So where is the weak link?  There are two of them here - receiving a request from a client and sending a response.  To understand that this is so, it is enough just to remember the average speed of the Internet connection today.  But after all, the I / O subsystem can work in <a href="http://en.wikipedia.org/wiki/Asynchronous_I/O" title="Asynchronous I / O">asynchronous mode</a> , and therefore it can not block workers.  Hmm, then it turns out that the only thing our workers will do is generate a response for the client and manage tasks for the I / O subsystem.  Previously, each worker could serve only one client at a time, since he took responsibility for the execution of the entire request processing cycle.  Now, when we delegated the network I / O to the I / O subsystem, one worker can simultaneously serve several requests, for example, generating a response for one client while the answer for another is given by the I / O subsystem.  It turns out now that we do not need to allocate a thread for each of the users, and we can create one worker per server processor, thus giving him a maximum of hardware resources. <br><br>  In practice, such delegation is implemented using the <a href="http://en.wikipedia.org/wiki/Event-driven_programming" title="Event-driven programming">event-oriented programming</a> paradigm.  Programs developed according to this paradigm can be implemented as a <a href="http://en.wikipedia.org/wiki/Finite-state_machine" title="Finite-state machine">state machine</a> .  Certain events translate this automaton from one state to another.  In our case, the server will be implemented as an infinite loop that will generate responses for clients, query <a href="http://www.freebsd.org/doc/en/books/design-44bsd/overview-io-system.html" title="Descriptors and I / O">I / O subsystem descriptors</a> for their readiness to perform a particular operation, and, if successful, send them a new task.  The process of polling I / O subsystem descriptors is called ‚Äú <a href="http://en.wikipedia.org/wiki/Polling_(computer_science)" title="Polling">polling</a> ‚Äù.  The fact is that effective polling implementations are currently available only in * nix-systems, since  the latter provide very fast linear execution time system calls for these purposes (for example, <a href="http://www.kernel.org/doc/man-pages/online/pages/man4/epoll.4.html" title="epoll (7)">epoll</a> on Linux and <a href="http://www.freebsd.org/cgi/man.cgi%3Fquery%3Dkqueue%26sektion%3D2" title="kqueue (2)">kqueue</a> on BSD systems).  This is a very efficient server model, because it allows you to use hardware resources to the maximum.  In fact, none of the server subsystems are idle idle, as can be easily seen by looking at the figure. <br><br><img src="https://habrastorage.org/storage/3dec2601/61d68188/548d8ac4/f1abe808.png" alt="Server with async I / O"><br><br>  A similar concept is used by servers such as <a href="http://sysoev.ru/nginx/" title="nginx">nginx</a> and <a href="httpd.net/" title="lighttpd">lightppd</a> , which have proven themselves in high-load systems. <br><br><h2>  Let's come together </h2><br>  But (there is always ‚Äúone thing‚Äù), before that we were repelled by the idea that generating an answer takes an order of magnitude less time than communicating with a client.  And this is partly true.  However, sometimes generating a response can be a complex and complex task, which can include reading and writing to disk, working with a database (which can also be located on a remote server).  Well, it turns out we actually returned to the original problem.  In practice, it is resolved as follows: the system is divided into two parts - the <a href="http://en.wikipedia.org/wiki/Front-end_and_back-end" title="Front-end and back-end">front-end and the back-end</a> .  The front-end is the server with which the client directly communicates.  As a rule, this is a server with an asynchronous event model that can quickly communicate with clients and give them query results (for example, nginx).  A back-end is a server with a blocking I / O model (for example, Apache), to which the front-end delegates the creation of a response for the client, just as it does with the I / O subsystem.  Such a front-end is also called ‚Äú <a href="http://en.wikipedia.org/wiki/Reverse_proxy" title="Reverse proxy">reverse proxy</a> ‚Äù, because in fact it is a regular <a href="http://en.wikipedia.org/wiki/Proxy_server" title="Proxy server">proxy server</a> , but installed in the same server environment as the server to which it redirects requests. <br><br>  If we draw analogies with real life, then the front-end is a manager with teeth shining in whiteness and in an expensive suit, the back-end is a group of workers at the plant, and the I / O subsystem is the transport department of the company that the manager works for and which owns factory.  Clients contact the manager by sending him letters through the transport department.  The manager makes a deal with the customer for the delivery of a batch of products and sends an instruction to the workers to make a batch.  The manager himself, in turn, does not expect the workers to finish the execution of the order, but continues to take care of their immediate responsibilities - concludes transactions with clients and ensures that the whole process proceeds in a coordinated and fine manner.  Periodically, the manager contacts the workers to inquire about the degree of readiness of the order, and if the party is ready, he instructs the transport department to send the order to the client.  Well, of course, periodically it follows that the goods reach the customer.  This is how the idea of ‚Äã‚Äãthe division of labor which was invented thousands of years ago found an unexpected application in high technology. <br><br><h2>  And the reaper, and the Swiss, and on the dude igrets (it would seem, and here JavaScript?) </h2><br>  Well, all this works fine, but somehow our system is extremely complicated, isn‚Äôt it?  Yes, even though we delegate the generation of a response to another server, this is still not the fastest process, because during it, blocking can occur due to file I / O and database operation, which inevitably leads to processor idle time.  So how do we restore integrity to the system and at the same time eliminate bottlenecks in the process of generating an answer?  Elementary, Watson - we will do all the input / output and work with the database non-blocking, built on events (yes, that <em>evented I / O</em> )! <br><br>  ‚ÄúBut this also changes the whole paradigm of creating web applications, and most of the existing frameworks are no longer applicable or applicable, but solutions using them are not elegant!‚Äù - you say and you will be right.  Yes, and the human factor cannot be excluded - applying <a href="http://en.wikipedia.org/wiki/Murphy%27s_law" title="Murphy's law">the Murphy law</a> it can be argued that ‚Äú <em>if there is a possibility to use the functions of blocking I / O, then someone will do it sooner or later</em> ‚Äù, thus breaking the whole initial idea.  It is only a matter of time, project scope, and programmer qualifications.  ‚ÄúBe careful making abstractions.  You might have to use them. "( <em>Eng.</em> " Be careful in creating abstractions, because you may have to use them ") - says Ryan in his <a href="http://www.youtube.com/watch%3Fv%3DF6k8lTrAE2g" title="Ryan Dahl on Google Tech Talk">speech on Google Tech Talk</a> .  So let's stick to minimalism and create only a foundation that will allow us to develop web applications and at the same time will be so well sharpened by an asynchronous programming model that we will not have the opportunity, and most importantly - the desire, to retreat from it.  So what is the minimum we need? <br><br>  Obviously, we first need <a href="http://en.wikipedia.org/wiki/Run-time_system" title="Run-time system">an</a> execution <a href="http://en.wikipedia.org/wiki/Run-time_system" title="Run-time system">environment</a> , the main requirements for which are fast execution of the response generation code and asynchronous I / O.  What modern programming language is designed for an event model, is it known to all web developers and at the same time has fast and actively developing implementations?  The answer is obvious - this is javascript.  Moreover, we have at our disposal a JavaScript <a href="http://code.google.com/p/v8/" title="V8 on Google code">V8 engine from Google</a> , distributed under a very liberal BSD license.  V8 is beautiful in many aspects: firstly, it uses <a href="http://en.wikipedia.org/wiki/Just-in-time_compilation" title="Just in time compilation">JIT compilation</a> and <a href="http://code.google.com/intl/ru-RU/apis/v8/design.html" title="V8 Design elements">many other optimization techniques</a> , and secondly, it is an example of a well-made, thoughtful and actively developing software product (I usually cite V8 as an example of really high-quality C ++ code for colleagues at work).  Add to all this the library <a href="http://software.schmorp.de/pkg/libev.html" title="libev official page">libev</a> , which will allow us to easily organize an event loop and provide a higher level wrapper for the polling mechanisms (so that we do not have to worry about the features of its implementation for various operating systems).  We also need the <a href="http://software.schmorp.de/pkg/libeio.html" title="libeio official site">libeio</a> library for fast asynchronous file I / O.  Well, on this our performing environment can be considered finished. <br><br>  And, of course, we need a standard library that will contain JavaScript wrappers for all basic I / O operations and functions, without which web development cannot go far (for example, parsing HTTP headers and URLs, hash counting, DNS rezolving, etc.). <br><br><img src="https://habrastorage.org/storage/b76971f3/cb22b677/2f5813a3/d630d8a2.png" alt="Node.js architecture"><br><br>  It is probably worth congratulating us - we just came up with the concept of a very fast server - Node.js. <br><br><h2>  I'm just sayin ' </h2><br>  Summarizing, I would like to say that Node.js is a very young project that, if properly used, can make a revolution in the world of web development in due time.  Today the project has a number of unsolved problems that complicate its use in real high-load systems (although there are already <a href="http://amix.dk/blog/post/19490" title="Node.js and plurk COMET">precedents</a> ).  For example, Node.js is essentially only one worker.  If you have, say, a dual-core processor, then the only way to fully use its hardware resources with Node.js is to run two server instances (one for each core) and use reverse proxy (for example, the same nginx) to load balance between them. <br>  But all such problems are solvable and active work is being done on them, and a huge community is being built around Node.js, and many large companies are paying considerable attention to this development.  It remains only to wish Mr. Dal to finish his job (in which, by the way, <a href="http://nodejs.org/" title="Contributing to Node.js">you can help him</a> ), and you, dear reader, spend a lot of pleasant time working on Node.js. </div><p>Source: <a href="https://habr.com/ru/post/108241/">https://habr.com/ru/post/108241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108231/index.html">I collect ugly from programmers</a></li>
<li><a href="../108233/index.html">Meeting poSEEDelki in Yandex</a></li>
<li><a href="../108236/index.html">Java Core Task</a></li>
<li><a href="../108238/index.html">CodeRush custom test templates. Testing the order of method calls</a></li>
<li><a href="../108239/index.html">HTC Desire Z: phone, keyboard, root access</a></li>
<li><a href="../108242/index.html">Server redirect to the mobile version of the site</a></li>
<li><a href="../108243/index.html">Read more about closed auctions in the zone. RF</a></li>
<li><a href="../108245/index.html">Lecture about processor architecture</a></li>
<li><a href="../108246/index.html">0W-httpd - simple fast frontend</a></li>
<li><a href="../108247/index.html">Promotion "Available RF!". Domain RF for 90 rubles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>