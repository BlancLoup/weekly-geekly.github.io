<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Networks for the harshest. Micro issue ‚Ññ7. EVPN</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you remember from the past release, the provider linkmeup has risen to the Tier 2 stage. But simply providing Internet access services or L2 / 3VPN...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Networks for the harshest. Micro issue ‚Ññ7. EVPN</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/6bd/21f/c62/6bd21fc6286d4b72a35809f4d4b04331.jpg"><br><br>  As you remember from the past release, the provider linkmeup has risen to the <a href="https://en.wikipedia.org/wiki/Tier_2_network">Tier 2</a> stage.  But simply providing Internet access services or L2 / 3VPNs (to be essentially a traffic pipe) Linkmeup does not like.  Cloud storage services are now in great demand, so linkmeup has acquired several of its own data centers located for economic reasons in Ryazan.  In this regard, we faced a new challenge - how to connect data centers with each other and provide customers with access to corporate storage systems located in our avtozalah?  Since MPLS is already running in the core-network, our choice fell on EVPN / MPLS.  We will consider it. <a name="habracut"></a><br><br>  This technology solves the problems of currently existing methods of combining data centers through a virtual L2 network.  Of course, this technology is not the only one of its kind, but we will not consider others as yet because of their proprietaryity.  You should always look to the future and although today we will build a network exclusively on Juniper MX, we, as a provider, cannot be sure that we will not have a couple of ASR9K tomorrow.  Perhaps some of the solutions applied in EVPN may seem too complicated and incomprehensible to you.  But you should not forget why this technology was invented, what problems it solves and whether it was possible to implement it in a different way.  Although the title contains the word micro-release, you should not think that this article will be small and simple.  On the contrary, the volume of the article is more than 115,000 characters (about 60 A4 pages written in the 11th font) and much of the description is not quite obvious and understandable the first time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately I want to draw the reader‚Äôs attention to the fact that in this article we will deploy and consider EVPN over MPLS, and not <a href="https://ru.wikipedia.org/wiki/Virtual_Extensible_LAN">VXLAN, in practice</a> .  But, as you understand, EVPN is a control plane, so the principle of operation is that over MPLS, that over VXLAN will be approximately the same, but there are significant differences.  Therefore, if you want to get to know EVPN / VXLAN, you can read the documentation, for example, <a href="http://www.brocade.com/content/html/en/brocade-validated-design/brocade-ip-fabric-bvd/GUID-4255D86A-F886-4E76-BE37-A55DB5638A59.html">Brocade</a> - they have this topic well covered, or the Cisco documentation on <a href="http://www.cisco.com/c/en/us/products/switches/nexus-9000-series-switches/index.html">Nexus</a> series <a href="http://www.cisco.com/c/en/us/products/switches/nexus-9000-series-switches/index.html">switches</a> .  Well, we will proceed to the study of EVPN / MPLS. <br><br><div class="spoiler">  <b class="spoiler_title">The content of the article:</b> <div class="spoiler_text">  1.0.  Remember the VPLS <br>  2.0.  Basic part of EVPN technology <br>  3.0  Laboratory for tests and configuration <br>  4.0  Type 3 route <br>  5.0.  Type 2 Route <br>  5.1.  Learning MAC Addresses <br>  6.0.  Type 1 Route <br>  6.1.  Auto search for multihomed PE and ESI label <br>  6.2.  MAC Mass Withdrawal <br>  6.3.  Aliasing label <br>  7.0 Type 4 Route <br>  7.1 DF selection mechanism <br>  8.0.  L3-functional in EVPN <br>  8.1.  IRB synchronization <br>  8.2.  Routing between bridge domains <br>  8.3.  Exit to other VRF and external networks <br>  9.0.  Why is it still needed? <br>  10.0.  Conclusion <br></div></div><br><h2>  <font color="#0A3BA3">Remember the VPLS</font> </h2><br>  I think everyone has already read the issue about L2VPN and imagine what a <abbr title="Virtual Private Lan Services">VPLS is</abbr> and what it is eaten with.  Let's slightly refresh in memory what types of VPLS exist today and how they differ significantly: <br><br><ul><li>  VPLS LDP-signaling (Martini) </li><li>  VPLS LDP-signaling with BGP-Autodiscovery </li><li>  VPLS BGP-signaling (Kompella) </li></ul><br>  <b><font color="#0112FF">VPLS LDP-signaling (Martini)</font></b> is the simplest technology that implements the VPLS functionality, both in terms of configuration and troubleshooting, but difficult to administer, since this is not endowed with the function of automatically searching for PE routers that belong to one VPLS domain.  Therefore, all PE routers participating in the same VPLS domain are explicitly assigned to each PE router manually.  As a result, adding a new site to an existing VPLS domain implies a configuration change on all PE routers of this VPLS domain, which, in my opinion, is not very convenient, especially if the client has 5-6 sites or more.  The advantages of this technology include its simplicity and the absence of the need to add a new address family to the BGP protocol (for a part of the old equipment, at the moment the technology was born, it would be necessary to update the software).  Since all the alarm systems work exclusively on LDP, the work of this technology was understood by engineers without the need to re-learn something (after all, we, the people, for the most part are lazy creatures).  But in today's reality, I think that it‚Äôs more convenient to add a new address family to BGP once (even if you need to update the software on a pair of hardware), rather than constantly running around all the PEs when adding a new one to the VPLS domain. <br><br>  <b><font color="#0112FF">VPLS LDP-signaling with BGP-Autodiscovery</font></b> .  In the end, the developers of the VPLS LDP-signaling technology still understood their mistake - the lack of automatic searching for other PE-shakes severely limited the scalability of this solution in comparison with VPLS BGP-signaling, so it was decided to add automatic search for PE-routers to this technology.  Naturally, they did not succeed in using LDP, so a great and powerful BGP was used, to which one more address family was added (moreover, different from the address family used in VPLS Kompella), a new extended community <a href="https://www.juniper.net/documentation/en_US/junos14.2/topics/reference/configuration-statement/l2vpn-id-edit-routing-instances.html">l2vpn-id was</a> added and a new one was added FEC - FEC129 (FEC128 is used in VPLS LDP).  As a result, when using this technology, PE router search is performed via BGP protocol, and L2 channels are already signaled via LDP.  In my opinion, the developers canceled out all these actions that they were proud of before, and if your equipment is supported by both Martini + BGP AD and Kompella, then personally I would prefer the latter. <br><br>  <b><font color="#0112FF">VPLS BGP-signaling (Kompella)</font></b> .  This technology is very different from the previous two - the only goal they have in common is the organization of a virtual L2 network over the provider's network.  This type of VPLS uses BGP for signaling, which provides both automatic neighbor search and signaling of virtual L2 channels.  As a result, we have a well-scalable solution, and the lower prevalence of VPLS BGP-signaling in provider networks is most likely due to the fact that this development was promoted by Juniper and was not supported by other vendors until a certain time, and also the seemingly seeming complexity of the technology itself one label distribution model. <br><br>  All of these technologies provide the same result - the organization of a virtual L2 network over the provider‚Äôs network, only the means of implementation and the capabilities of these technologies, which you can read about in the previous release of SDTSM, differ.  But these technologies have several common problems that impose certain inconveniences during operation and do not give rest to developers.  There are at least three such problems: <br><br>  1. There is no possibility for multihomed sites (sites connected to 2 or more PE routers at the same time) to use all links to send traffic (work in Active-Active mode); <br><br>  2. These technologies do not provide advanced L3 functions, with the exception of the banal addition of the <abbr title="Bridge virtual interface">BVI</abbr> / <abbr title="Integrated Routing and Bridging">IRB</abbr> interface to the VPLS domain for access to the external network; <br><br>  3. MAC addresses are studied exclusively at the data plane level, which leads to an increase in the flood of <abbr title="Broadcast, Unknown Unicast, Multicast">BUM</abbr> traffic in the provider's network. <br><br>  To combat these shortcomings in VPLS is already useless - it will complicate much the already not simple technologies (for example, there is the <abbr title="Next-Generation VPLS">NG-VPLS</abbr> technology that uses <a href="https://www.juniper.net/documentation/en_US/junos14.2/topics/concept/mpls-lsp-point-multipoint.html">P2MP LSP</a> , but I have not heard about its actual use).  Therefore, a new technology was invented in which these shortcomings were eliminated.  Today we talk about Ethernet VPN (EVPN).  There is an opinion that this technology is the development of VPLS BGP-signaling, I think that for simplicity of perception, in this article it would not be superfluous to compare EVPN with VPLS BGP-signaling (I will write below just VPLS, which VPLS BGP-signaling implies). <br><br>  My personal opinion is that this technology is a hybrid of L3VPN and VPLS BGP signaling.  And why, I think, you will understand, having read the article to the end.  So let's go ... <br><br><h2>  <font color="#0A3BA3">Basic part of EVPN technology</font> </h2><br>  Like VPLS, EVPN uses only BGP for signaling, but already uses the new NLRI: <abbr title="Address Family Identifier">AFI</abbr> 25 <abbr title="Subsequent Address Family Identifier">SAFI</abbr> 70 (some versions of Wireshark do not yet know this AFI / SAFI and write unknown SAFI for AFI 25 when removing the dump).  The use of the new address family is due to the fact that EVPN uses not only a data-plane, as in a standard VPLS or switch, but also a control-plane to learn MAC addresses: <br><img src="https://habrastorage.org/files/871/bbb/cdc/871bbbcdc18d4d039cd7603cb120790d.png"><br>  A small lyrical digression: perhaps Brocade-style illustrations may not please someone, but the use of these illustrations is due to the fact that if you use the notation of Juniper or Cisco-style routers and switches, then we will get an unreadable mess in some of the drawings, but we don‚Äôt want it .  Well, I personally like such pictures as they like more (but this, as they say, to the taste and color ...).  Below is a list of all the symbols on the diagrams: <br><img src="https://habrastorage.org/files/3e8/74f/d02/3e874fd025894eb1b47650388d7da413.png"><br>  Let's take a look at how the learning of MAC addresses in EVPN happens.  We will use just such a banal network: <br><img src="https://habrastorage.org/files/c06/8d6/ab9/c068d6ab994c4386906294ce96341872.png"><br>  Imagine that CE1 wants to send an ICMP packet to CE2: <br><br>  1. Since CE1 does not have the CE2 MAC address, CE1 makes a broadcast ARP request for resolving the CE2 address. <br><br>  2. PE1, having received a broadcast packet from CE1, analyzes its header and understands that this packet should be forwarded to all other PE routers in this broadcast domain.  In addition, PE1 writes the source MAC to the MAC table of the corresponding bridge domain. <br><br>  If we had VPLS, then PE1 wouldn‚Äôt do any more operations.  But we have EVPN, so PE1 generates BGP Update, in which it indicates the CE1 MAC address and VPN label, and sends it to all other PE routers (of course, via a router-reflector). <br><br>  3. PE2 and PE3 receive this broadcast packet and send it to all connected CE routers.  Like VPLS, EVPN has a split horizon function - a packet received from a PE router will not be sent to other PE routers. <br><br>  In VPLS PE2 and PE3, when receiving a packet from PE1, you would have to write the MAC address of CE1 in the MAC table and associate it with the PW in the direction of PE1.  But in EVPN, there is no need to study MAC addresses for source addresses of packets coming from other PE routers, because PE1 has already made a MAC + label announcement, which means PE1 and PE2 will write to the MAC address table for this announcement (yes, as in L3VPN with IPv4 prefixes). <br><br>  4. PE2 receives from CE2 a response to this ARP request.  Since the MAC address of CE1 and the label before it are already known from the BGP announcement received from PE1, the packet is sent by a unicast directly to PE1.  In addition, PE2 writes the MAC address of CE2 to the MAC table and generates BGP Update, which indicates the MAC address of CE2 and the label, and sends it to the other PE routers. <br><br>  5. PE1 receives a unicast packet and sends it to the appropriate interface using the MAC table. <br><br>  As you already understood, EVPN uses MAC addresses as routing addresses.  This can be compared to the distribution of routes within L3VPN. <br><br>  I think everyone who reads the article about L2VPN remembers that in VPLS labels are distributed using BGP blocks, because the recipient of the packet (in the sense of a PE router) needs to know which PE router came from this packet and associate the MAC address with the PW before PE router.  In EVPN, this is no longer necessary.  This is due to the fact that EVPN handles MAC addresses, as well as the L3VPN IPv4 prefixes - the PE router, having learned the new MAC address through the data plane from the connected CE router, immediately announces this MAC via BGP.  In the BGP announcement, the MPLS label and the protocol next-hop are specified (as a rule, this is a loopback PE router).  As a result, all other PE routers know where to send the packet and with what label. <br><br><blockquote>  An interesting fact: in VPLS (any of its form), in the scenario described above, PE3 would only recognize the MAC address of CE1, since the packet from CE2 to CE1 is already transmitted unicast and will not fall on PE3.  And when using EVPN, PE3 studies both MAC addresses: both CE1 and CE2, the first one learns from the announcement from PE1, the second one from the announcement from PE2. </blockquote><br>  I hope the principle of operation of the technology is clear, and now we can move from theory to practice and look at the work of EVPN with an example. <br><br><h3>  <font color="#0A3BA3">Laboratory for tests and configuration</font> </h3><br>  For tests, I used <a href="http://www.unetlab.com/">Unetlab</a> , in which I assembled a stand of four <a href="http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/">vMX</a> and three Cisco IOL (L3).  As you understand, vMX-sy is used to emulate the network of the provider, and Cisco is used as client CE routers.  If anyone is interested, then this lab was run on the most ordinary laptop with i5 and 12 GB of RAM (of which only 6 were occupied, and the CPU load did not exceed 30 percent) - so you can run and touch EVPN. <br><br>  Our scheme is as follows: <br><img src="https://habrastorage.org/files/3b1/9ae/ec8/3b19aeec87ac413ca55797acec6184c6.png"><br>  As you understand, we have three PE routers, one P-router, it is also a router reflector, and three CE routers.  All addressing for convenience is shown in the diagram. <br><br>  Juniper allows us to configure routing-instance for EVPN in two ways - the first is an instance with type EVPN ‚Äî the simplest, and the second, an instance with type virtual-switch.  Personally, I prefer the second option, since it is more flexible, but for clarity in our lab we will use both methods.  However, the differences between these two methods are not only in the configuration. <br><br>  <b><font color="#0112FF">VLAN Based Service</font></b> - This type of use of EVPN is good because the bridge domains are completely isolated from each other.  But for each vlan you have to do a new routing instance.  In such a scenario, traffic between PE routers can go either with a vlan tag or untagged.  JunOS defaults to send tagged traffic with the original tag (unless, of course, any tag rewriting rules are configured on the interface). <br><br>  The configuration of the routing instance with the EVPN type looks like this: <br><br><pre><code class="bash hljs">bormoglotx@RZN-PE-3&gt; show configuration routing-instances RZN-VPN-1 instance-type evpn; vlan-id 777; interface ge-0/0/2.200; interface ge-0/0/2.777; routing-interface irb.777; route-distinguisher 62.0.0.3:1; vrf-import VPN-1-IMPORT; vrf-export VPN-1-EXPORT; protocols { evpn { interface ge-0/0/2.777; } } bormoglotx@RZN-PE-3&gt; show configuration interfaces ge-0/0/2 description <span class="hljs-string"><span class="hljs-string">"link to RZN-CE3-SW1"</span></span>; flexible-vlan-tagging; encapsulation flexible-ethernet-services; mac 50:01:00:03:00:04; unit 777 { encapsulation vlan-bridge; vlan-id 777; family bridge; }</code> </pre> <br>  In an EVPN type instance configuration, you should pay attention to this line: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show configuration routing-instances RZN-VPN-1 | match vlan vlan-id 777;</code> </pre> <br>  This value determines which tag is used for normalization.  That is, if in addition to Vlan 777, Vlan 200 is also connected to this EVPN instance (as in the config shown above), when receiving a packet with a tag 200, the PE router will remove this tag (tag 200) and hang a new one - 777. At the reception PE will act in reverse order - tag 777 will be removed and tag 200 will be hung when sent to the interface in the direction of the CE router, in our case to the ge-0/0 / 2.200 interface (see the configuration above, this CE is not shown in the diagrams ). <br><br>  This is the minimum configuration that will allow EVPN to work (do not forget about the basic network configuration - IGP, MPLS, etc., which is not represented here).  As you can see, we specify <a href="https://en.wikipedia.org/wiki/Route_distinguisher">RD</a> and <a href="https://habrahabr.ru/sandbox/99255/">RT</a> , since BGP is used for signaling.  Everything is as usual - RD makes our route unique, and RT is used to filter routes.  The import and export policies on all PE routers are the same, but for those who are interested in their configuration, I will bring it under the spoiler: <br><br><div class="spoiler">  <b class="spoiler_title">Policy configuration</b> <div class="spoiler_text"><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show configuration policy-options policy-statement VPN-1-IMPORT term DEFAULT-IMPORT { from { protocol bgp; community VPN-1; } <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> accept; } term REJECT { <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> reject; } bormoglotx@RZN-PE-3&gt; show configuration policy-options policy-statement VPN-1-EXPORT term DEFAULT { <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { community + VPN-1; accept; } } term REJECT { <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> reject; } bormoglotx@RZN-PE-3&gt; show configuration policy-options community VPN-1 members target:6262:777;</code> </pre> <br></div></div><br>  <b><font color="#0112FF">VLAN Aware Service</font></b> - in this case we do only one routing instance with the type virtual switch and add bridge domains to it.  If the client has 30 vlans, we do not need to fence the config into hundreds of lines, making an instance for each vlan - just add 30 bridge-domains to the instance created for the client.  In this case, the presence of the vlan tag, according to the RFC, is mandatory. <br><br>  The instance configuration with the type virtual-switch has something like this: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-instances RZN-VPN-1 instance-type virtual-switch; interface ge-0/0/2.0; route-distinguisher 62.0.0.1:1; vrf-import VPN-1-IMPORT; vrf-export VPN-1-EXPORT; protocols { evpn { extended-vlan-list 777; } } bridge-domains { VLAN-777 { vlan-id 777; } } bormoglotx@RZN-PE-1&gt; show configuration interfaces ge-0/0/2 description <span class="hljs-string"><span class="hljs-string">"link to RZN-CE1-SW1"</span></span>; flexible-vlan-tagging; encapsulation flexible-ethernet-services; mac 50:01:00:01:00:04; unit 0 { family bridge { interface-mode trunk; vlan-id-list 777; } }</code> </pre><br>  There should be no problems when using EVPN on the one hand, and there should be no virtual switch on the other (if you do everything as it should be), since JunOS from the EVPN instance sends tagged traffic with the original tag.  In any case, during the testing I did not find any problems.  But there is one nuance.  It should be borne in mind that normalization can play a cruel joke with you if you start using different types of instances in the same EVPN domain without dividing the bridge across the bridge domains.  For example, on one PE router to the EVPN type instance you add two vlans: 777 and 1777, and for normalization you use the vlan 777. From the other end you will have a virtual switch with two bridge domains - vlan 777 and vlan 1777. As a result, we get: the packet arrives from CE in vlan 1777, the vlan happens to normalize to 777 and the virtual switch instantiates the packet arrives in vlan 777. And the destination host is in vlan 1777, that is, in another bridge domain.  As a result, you do not have connectivity between hosts in the same vlan.  Or another scenario - in the same bridge domain, you configured different tags for normalization.  In this scenario, you also will not have connectivity (it will not exist at all), since with PE1 the packet will fly away, for example, with the normal tag 777, and on PE2 the normal tag will be 1777. As a result, PE2 will simply discard the packets with the wrong vlan number. <br><br><h3>  <font color="#001eff">Type 3 route</font> </h3><br>  At this point in time, no exchange of packets between CE routers has been done (of course, <a href="https://ru.wikipedia.org/wiki/CDP">CDP</a> , <a href="https://ru.wikipedia.org/wiki/LLDP">LLDP</a> and other joys are disabled, so that something extra is not flown into the network), so none of the PE routers have learned a single MAC address.  This can be checked: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show evpn instance RZN-VPN-1 brief Intfs IRB intfs MH MAC addresses Instance Total Up Total Up Nbrs ESIs Local Remote RZN-VPN-1 1 1 0 0 2 0 0 0</code> </pre> <br>  From this conclusion, we can learn that there is only 1 interface in this routing-instance and it is active, we do not have IRB interfaces (more about them later).  We see two neighbors (according to our scheme, this is PE2 and PE3), and also that we have not yet studied any MAC addresses (local is MAC addresses local to this PE router, and remote are MAC addresses received from neighboring PE routers). <br><br>  Now let's see what routes we have in the routing table of this routing-instance: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table RZN-VPN-1.evpn.0 RZN-VPN-1.evpn.0: 3 destinations, 3 routes (3 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 3:62.0.0.1:1::777::62.0.0.1/304 *[EVPN/170] 01:33:42 Indirect 3:62.0.0.2:1::777::62.0.0.2/304 *[BGP/170] 01:10:22, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299808 3:62.0.0.3:1::777::62.0.0.3/304 *[BGP/170] 01:10:01, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299776</code> </pre> <br>  We have only three routes, with the first local one for PE1.  What are these routes and why are they needed?  Let's figure it out.  There are only 5 types of routes in EVPN: <br><br><ul><li>  1 - Ethernet Auto-Discovery (AD) route </li><li>  2 - MAC / IP Advertisement route </li><li>  3 - Inclusive Multicast Ethernet Tag route </li><li>  4 - Ethernet Segment route </li><li>  5 - IP Prefix Route * </li></ul><br><blockquote>  Note: the route of the 5th type is currently not yet approved in the RFC statute, and so far it has been described only in the <a href="https://tools.ietf.org/html/draft-rabadan-l2vpn-evpn-prefix-advertisement-00">draft</a> and therefore we will not consider it in this article. <br></blockquote><br>  In the above output, we see that the first digit in the route is <b><font color="#0112FF">3</font></b> , which means it is <b><font color="#0112FF">Inclusive Multicast Ethernet Tag route</font></b> .  This route is generated by each PE router and is used to receive and send <abbr title="Broadcast, Unknown Unicast, Multicast">BUM</abbr> traffic.  The route consists of the following fields: <br><img src="https://habrastorage.org/files/59c/b35/655/59cb356559b24e9d8c729584abfb5299.jpg"><br>  <b><font color="#0112FF">RD</font></b> - I think everyone understands what it is, in the announcement below it is <font color="#FF00E7">: 62.0.0.3: 1:</font> <br>  <b><font color="#0112FF">Ethernet Tag ID</font></b> is the Vlan number, in our case <font color="#FF00E7">: 777:</font> <br>  <b><font color="#0112FF">IP Address Length</font></b> - the length of the IP address specified in the next field (this value is not shown on Juniper equipment) <br>  <b><font color="#0112FF">Originating Router's IP Address</font></b> - The IP address of the originator of the route, usually a loopback PE router.  In our case it is <font color="#FF00E7">: 62.0.0.3</font> . <br><br><blockquote>  Note: <b><font color="#FF00E7">/ 304</font></b> is the prefix length, Juniper automatically adds it to all EVPN routes, in fact, does not carry a semantic load.  As written on the Juniper website, this value means the maximum length of the route and allows you to use this feature when searching for routes using regular expressions.  Well, we take into account for the future. </blockquote><br><pre> <code class="bash hljs">3:62.0.0.3:1::777::62.0.0.3/304 (1 entry, 1 announced) *BGP Preference: 170/-101 Route Distinguisher: 62.0.0.3:1 PMSI: Flags 0x0: Label 299904: Type INGRESS-REPLICATION 62.0.0.3 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Indirect Address: 0x95ca3d4 Next-hop reference count: 2 Source: 62.0.0.255 Protocol next hop: 62.0.0.3 Indirect next hop: 0x2 no-forward INH Session ID: 0x0 State: &lt;Secondary Active Int Ext&gt; Local AS: 6262 Peer AS: 6262 Age: 1:16:02 Metric2: 1 Validation State: unverified Task: BGP_6262.62.0.0.255+179 Announcement bits (1): 0-RZN-VPN-1-evpn AS path: I (Originator) Cluster list: 62.0.0.255 Originator ID: 62.0.0.3 Communities: target:6262:777 Import Accepted Localpref: 100 Router ID: 62.0.0.255 Primary Routing Table bgp.evpn.0</code> </pre> <br>  If you look at the route more closely, we see the following line: <br><br><pre> <code class="bash hljs"> PMSI: Flags 0x0: Label 299904: Type INGRESS-REPLICATION 62.0.0.3</code> </pre> <br>  PMSI stands for Provider Multicast Service Interface, and this is nothing more than Point-to-Multipoint LSPs.  In this article we will not consider how P2MP LSP works, since this is a very large and complex topic, but as you can see, EVPN uses p2mp LSP functionality to forward <abbr title="Broadcast, Unknown Unicast, Multicast">BUM</abbr> traffic.  PE3 generated a 299904 label that other PE routers can use to send <abbr title="Broadcast, Unknown Unicast, Multicast">BUM</abbr> traffic to PE3. <br><br>  The type 3 route is generated for each vlan separately, which is what the words Ethernet Tag say in its name.  If you have two bridge-domains (for example, vlan 777 and vlan 1777), then the PE router will generate two type 3 routes ‚Äî one for each vlan (bridge-domain). <br><br>  We found out that at the initial moment of time there are only type 3 routes in the EVPN routing table, so that PE routers know what label to send broadcast packets to remote PE routers. <br><br><h3>  <font color="#001eff">Type 2 Route</font> </h3><br>  Now run the ping between CE1 and CE2: <br><br><pre> <code class="bash hljs">RZN-CE1-SW1<span class="hljs-comment"><span class="hljs-comment">#ping 10.0.0.2 Type escape sequence to abort. Sending 5, 100-byte ICMP Echos to 10.0.0.2, timeout is 2 seconds: .!!!! Success rate is 80 percent (4/5), round-trip min/avg/max = 7/8/11 ms</span></span></code> </pre> <br>  One packet was lost because CE1 made an ARP request for resolving the address 10.0.0.2.  Now let's see if the addresses appear in the MAC table: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show evpn instance RZN-VPN-1 brief Intfs IRB intfs MH MAC addresses Instance Total Up Total Up Nbrs ESIs Local Remote RZN-VPN-1 1 1 0 0 2 0 1 1</code> </pre> <br>  Two MAC addresses appeared at once: one local for PE1 (address CE1) and one MAC received from PE2 (address CE2): <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table RZN-VPN-1.evpn.0 RZN-VPN-1.evpn.0: 5 destinations, 5 routes (5 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 2:62.0.0.1:1::777::aa:bb:cc:00:06:00/304 *[EVPN/170] 00:05:23 Indirect 2:62.0.0.2:1::777::aa:bb:cc:00:07:00/304 *[BGP/170] 00:05:23, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299808</code> </pre> <br>  Now we have two new routes in the table (just in route table 5, type 3 routes are not shown to reduce the output).  Routes are type 2 - MAC / IP Advertisement route.  This route is as follows: <br><br><img src="https://habrastorage.org/files/85b/c9e/6a3/85bc9e6a3ddf41d8ae82b1643bafaf1e.jpg"><br>  <b><font color="#0112FF">RD</font></b> - Route Distinguisher, where without it, in our case it is <font color="#FF00E7">: 62.0.0.2: 1</font> ; <br>  <b><font color="#0112FF">Ethernet Segment Identifier</font></b> - identifier of <abbr title="Ethernet Segment Identifier">ESI</abbr> , we will talk about it later.  JunOS shows this value only for detail or extensive outputs, in our route it is zero: <font color="#FF00E7">ESI: 00: 00: 00: 00: 00: 00: 00: 00: 00: 00: 00</font> ; <br>  <b><font color="#0112FF">Ethernet Tag ID</font></b> - Vlan number <font color="#FF00E7">: 777</font> ; <br>  MAC Address Length - the length of the MAC address, in fact, always 48 bits, and JunOS does not output this value; <br>  <b><font color="#0112FF">MAC Address</font></b> - the MAC address itself: <font color="#FF00E7">aa: bb: cc: 00: 07: 00</font> ; <br>  <b><font color="#0112FF">IP Address Length</font></b> is the length of the IP address, is 32 bits for IPv4, and 128 for IPv6. This field is optional and may not contain any values ‚Äã‚Äã(all zeros).  JunOS does not display this value. <br>  <b><font color="#0112FF">IP Address</font></b> - the address itself, it is not represented in the output below.  The field is filled optionally. <br>  <b><font color="#0112FF">MPLS Label1 | 2</font></b> - the label itself, JunOS shows it only when it is detailed or extensive output. <br><br><pre> <code class="bash hljs">2:62.0.0.2:1::777::aa:bb:cc:00:07:00/304 (1 entry, 1 announced) *BGP Preference: 170/-101 Route Distinguisher: 62.0.0.2:1 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Indirect Address: 0x95c9f90 Next-hop reference count: 4 Source: 62.0.0.255 Protocol next hop: 62.0.0.2 Indirect next hop: 0x2 no-forward INH Session ID: 0x0 State: &lt;Secondary Active Int Ext&gt; Local AS: 6262 Peer AS: 6262 Age: 26 Metric2: 1 Validation State: unverified Task: BGP_6262.62.0.0.255+179 Announcement bits (1): 0-RZN-VPN-1-evpn AS path: I (Originator) Cluster list: 62.0.0.255 Originator ID: 62.0.0.2 Communities: target:6262:777 Import Accepted Route Label: 300272 ESI: 00:00:00:00:00:00:00:00:00:00 Localpref: 100 Router ID: 62.0.0.255 Primary Routing Table bgp.evpn.0</code> </pre> <br>  As I wrote earlier, EVPN uses MAC addresses as routing addresses.  From the announcement from PE2, PE1 now knows that in order to get to the MAC address aa: bb: cc: 00: 07: 00 in vlan 777 (note that it is in 777 vlan, since the same MAC address is maybe in different vlans, and these will be different routes), you need to hang two tags on the packet: 300272 (VPN) and a transport label up to 62.0.0.2. <br><br><blockquote>  Note: in addition to the well-known Route Distinguisher, Protocol next hop, and so on fields, we see the <abbr title="Ethernet Segment Identifier">ESI</abbr> field, which is set to zero in this announcement.  This field is very important when using multihomed sites, and we will return to it a little later, in this scenario it does not matter. <br></blockquote><br>  Like L3VPN, EVPN can generate per-mac, per-next-hop and per-instance tags: <br><br>  <b><font color="#0112FF">per-mac</font></b> - a separate label is generated for each mac address.  As you understand this kind of label distribution is too wasteful; <br><br>  <b><font color="#0112FF">per-next-hop</font></b> - probably more accurate is to say per-CE or per-AC, that is, the same label is generated only for MAC addresses that are located behind the same Attachment Circuit (that is, if to the same PE router in the same routing-instance has two CE routers connected, then for MAC addresses learned from CE1, PE router will generate one label, and for MAC addresses learned from CE2 - another) <br><br>  <b><font color="#0112FF">per-instance</font></b> - one label is generated for the entire routing-instance, that is, all routes will have the same label.  In JunOS, you can see this label when viewing the EVPN instance in extensive mode. <br><br><h3>  <font color="#001eff">Learning MAC Addresses</font> </h3><br>  Now look at the MAC table on PE1: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show bridge mac-table MAC flags (S -static MAC, D -dynamic MAC, L -locally learned, C -Control MAC SE -Statistics enabled, NM -Non configured MAC, R -Remote PE MAC) Routing instance : RZN-VPN-1 Bridging domain : VLAN-777, VLAN : 777 MAC MAC Logical NH RTR address flags interface Index ID aa:bb:cc:00:06:00 D ge-0/0/2.0 aa:bb:cc:00:07:00 DC 1048575 1048575</code> </pre> <br>  The flag column tells us how this address was learned: the MAC address aa: bb: cc: 00: 06: 00 has only the D flag, which means that this Mac is dynamically learned (in the standard way through the data plane) and as we don‚Äôt see any more flags, we can safely say that this MAC has been learned from a locally connected CE router.  But the MAC address aa: bb: cc: 00: 07: 00 has two flags - DC.  We already know what the first flag means, but the C flag indicates that this address was learned through the control plane. <br><br>  If we look at the table of MAC addresses on PE3, we will see that all the addresses are learned by the PE router via the control plane, and there is not a single local MAC address: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show evpn mac-table MAC flags (S -static MAC, D -dynamic MAC, L -locally learned, C -Control MAC SE -Statistics enabled, NM -Non configured MAC, R -Remote PE MAC) Routing instance : RZN-VPN-1 Bridging domain : __RZN-VPN-1__, VLAN : 777 MAC MAC Logical NH RTR address flags interface Index ID aa:bb:cc:00:06:00 DC 1048574 1048574 aa:bb:cc:00:07:00 DC 1048575 1048575</code> </pre> <br><blockquote>  Note: if you noticed, in one case I used the show bridge command mac-table, and in the second I showed evpn mac-table command.  This is due to the fact that on different PE routers the routing instance is configured differently - in the first case, virtual-swicth, in the second EVPN. </blockquote><br>  There are no locally learned MAC addresses on PE3, as there has not yet been traffic from CE3.  Let's correct this situation by running the ping to CE3, and once again look at this table: <br><br><pre> <code class="bash hljs">RZN-CE1-SW1<span class="hljs-comment"><span class="hljs-comment">#ping 10.0.0.3 Type escape sequence to abort. Sending 5, 100-byte ICMP Echos to 10.0.0.3, timeout is 2 seconds: .!!!! Success rate is 80 percent (4/5), round-trip min/avg/max = 7/10/13 ms</span></span></code> </pre> <br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show evpn mac-table MAC flags (S -static MAC, D -dynamic MAC, L -locally learned, C -Control MAC SE -Statistics enabled, NM -Non configured MAC, R -Remote PE MAC) Routing instance : RZN-VPN-1 Bridging domain : __RZN-VPN-1__, VLAN : 777 MAC MAC Logical NH RTR address flags interface Index ID aa:bb:cc:00:05:00 D ge-0/0/2.777 aa:bb:cc:00:06:00 DC 1048574 1048574 aa:bb:cc:00:07:00 DC 1048575 1048575</code> </pre> <br>  As you can see, the CE3 MAC address has now appeared on PE3, learned through the data plane. <br><br>  Like an ordinary switch, addresses in the EVPN MAC table have a certain ‚Äúexpiration date‚Äù, by default this period is 300 seconds.  If during this time this MAC was inactive and not updated, the route is removed from the table.  It seems that everything is simple - the timer has worked - the MAC has been deleted.  But everything is not as simple as it seems.  Let's look at how this happens. <br><br>  So, PE3 learned the MAC address of CE3 and sent it in BGP announcement to the other PE routers.  Suppose that the recording was not updated within 300 seconds.  Then PE3 must remove this MAC address from the table, which it does.  But we remember that PE3 sent information to all its neighbors that this MAC address is located behind it.  What if this host has moved or is it already turned off?  What then?  Will the other PE routers send packets for CE3 to PE3, like in a black hole?  Of course not.  The fact is that if the PE router removes the local MAC address from the table, then it sends a BGP Withdrawn message, which causes other PE routers to delete this route, and therefore the MAC address, from their tables.  Let's check it out. <br><br>  The first screen shows BGP UPDATE Message, which announces the MAC address aa: bb: cc: 00: 07: 00 (the pictures are clickable): <br><br> <a href=""><img src="https://habrastorage.org/files/4b0/a86/b2e/4b0a86b2eabe4a58824ec8ba2a3438a6.jpg"></a> <br><br>  After 300 seconds, we see another BGP UPDATE Message, which is a Withdrawn message, canceling the route to the previously specified MAC address: <br><br> <a href=""><img src="https://habrastorage.org/files/2cf/a64/e99/2cfa64e9929640fea06f60192338e64e.jpg"></a> <br><br>  In addition to MAC aging time, EVPN has a mechanism for signaling the change of the MAC address.  When a Gratuitous ARP is received from the PE router's CE, BGP Update is generated, which contains a withdrawn message indicating the old MAC address and the announcement of the new MAC address. <br><br>  But besides the MAC address, the MAC / IP Advertisement route can optionally also contain the IP address of the host.  Add the IRB routing interface to our EVPN and see which route appeared: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration interfaces irb.777 family inet { address 10.0.0.254/24; } mac 02:00:00:00:00:02; bormoglotx@RZN-PE-1&gt; *2:62.0.0.1:1::777::02* show route table RZN-VPN-1.evpn.0 match-prefix RZN-VPN-1.evpn.0: 18 destinations, 18 routes (18 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 2:62.0.0.1:1::777::02:00:00:00:00:02/304 *[EVPN/170] 14:17:31 Indirect 2:62.0.0.1:1::777::02:00:00:00:00:02::10.0.0.254/304 *[EVPN/170] 14:17:31 Indirect</code> </pre> <br>  There are two new routes, the first is only the irb.777 MAC address, and here is the second MAC + IP.  Mac + IP announcement has the form of ARP records, all PE routers participating in the same EVPN domain synchronize their ARP records, which allows reducing the number of flood of broadcasting ARP requests across the provider's network. <br><br>  Now we will take a closer look at the route: <br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table RZN-VPN-1.evpn.0 match-prefix *2:62.0.0.1:1::777::02* detail RZN-VPN-1.evpn.0: 18 destinations, 18 routes (18 active, 0 holddown, 0 hidden) 2:62.0.0.1:1::777::02:00:00:00:00:02/304 (1 entry, 1 announced) *EVPN Preference: 170 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Indirect Address: 0x940d804 Next-hop reference count: 7 Protocol next hop: 62.0.0.1 Indirect next hop: 0x0 - INH Session ID: 0x0 State: &lt;Active Int Ext&gt; Age: 14:21:34 Validation State: unverified Task: RZN-VPN-1-evpn Announcement bits (1): 1-BGP_RT_Background AS path: I Communities: evpn-default-gateway Route Label: 300144 ESI: 00:00:00:00:00:00:00:00:00:00</code> </pre> <br>  In this route, a new extended community evpn-default-gateway appeared.  This is how routes that are the main gateway for the routing-instance are marked.  This route will be generated for each vlan separately. <br><br>  Why are two routes generated?  The fact is that the first route, in which only the MAC address is specified, is used exclusively for switching in the bringe domain, while the MAC + IP route is already used for routing and is essentially an arp entry.  I'll run a bit ahead and write that routes to hosts will also be generated in the same way when traffic moves to other vlans or to an external network (we will look at this later when adding another vlan to the scheme). <br><br><h3>  <font color="#001eff">Type 1 Route</font> </h3><br>  So far, we have ignored type 1 and type 4 routes. These routes are used for multihomed sites. <br><br><blockquote>  Note: due to too much of the article, we will not dive deep into the work of EVPN with multihomed sites.  If someone is interested - write in the comments - I will write a separate article on this topic. </blockquote><br>  Type 1 route is as follows: <br><br><img src="https://habrastorage.org/files/403/f9b/e0a/403f9be0a3644dfb9c99602f5f058d5d.jpg"><br><pre> <code class="bash hljs">1:62.0.0.2:0::112233445566778899aa::0/304 *[BGP/170] 00:00:56, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299792</code> </pre> <br>  This route does not carry information about MAC-addresses, but has a very wide application, such as: <br><br><ul><li>  Automatic search for PE routers to which the same CE router is connected </li><li>  <abbr title="Ethernet Segment Identifier">ESI</abbr> announcement tags </li><li>  Announcement of mass cancellation of learned MAC addresses </li><li>  Announcement Aliasing tags </li></ul><br>  Type 1 route can be announced per- <abbr title="EVPN instance">EVI</abbr> or per-ESI.  The first announcement is used when announcing the Aliasing label, the second - to enable the mass cancellation of the announced MAC addresses of any ethernet segment. <br><br>  Let's look at the above described function of this route in more detail. <br><br><h2>  <font color="#6577f9">Auto search for multihomed PE and <abbr title="Ethernet Segment Identifier">ESI</abbr> label</font> </h2><br>  Unlike VPLS, the automatic discovery of PE routers connected to the same CE router (multihomed sites) is enabled in EVPN.  In terms of EVPN, the PE &lt;-&gt; CE junction is called Ethernet Segment.  Each segment is assigned an ESI (Ethernet Segment Identifier, a number of 80 bits in size recorded in 10 groups of 8 bits in a group).  For single-homed sites, this identifier does not matter and is therefore automatically assigned and equal to 0. But for multihomed sites, this identifier is very important and must be unique for the entire EVPN domain (since the number of possible <abbr title="Ethernet Segment Identifier">ESI</abbr> combinations is very large and equal to 2 ^ 80) .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESs connected to the same CE router must have the same </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Two values ‚Äã‚Äãfrom the entire range are reserved and cannot be set administratively - these are all zeros (used as an identifier for non-multihoming segments) and all F. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above output, a magic set of letters and numbers </font></font><b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: 112233445566778899aa:</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is nothing more than </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> configured network administrator on the physical interface:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show configuration interfaces ge-0/0/4 description <span class="hljs-string"><span class="hljs-string">"link to RZN-MULTI-SW-1"</span></span>; flexible-vlan-tagging; encapsulation flexible-ethernet-services; esi { 11:22:33:44:55:66:77:88:99:aa; single-active; } mac 50:01:00:02:00:06; unit 111 { encapsulation vlan-bridge; vlan-id 111; family bridge; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This route, in addition to </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI,</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is very important, which is represented in the form of an extended community: esi-label. </font><font style="vertical-align: inherit;">It looks like this:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show route table RZN-VPN-3.evpn.0 match-prefix *1:62* detail RZN-VPN-3.evpn.0: 6 destinations, 6 routes (6 active, 0 holddown, 0 hidden) 1:62.0.0.1:0::112233445566778899aa::0/304 (1 entry, 1 announced) *BGP Preference: 170/-101 Route Distinguisher: 62.0.0.1:0 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Indirect Address: 0x95c0f28 Next-hop reference count: 20 Source: 62.0.0.255 Protocol next hop: 62.0.0.1 Indirect next hop: 0x2 no-forward INH Session ID: 0x0 State: &lt;Secondary Active Int Ext&gt; Local AS: 6262 Peer AS: 6262 Age: 2:50 Metric2: 1 Validation State: unverified Task: BGP_6262.62.0.0.255+179 Announcement bits (1): 0-RZN-VPN-3-evpn AS path: I (Originator) Cluster list: 62.0.0.255 Originator ID: 62.0.0.1 Communities: target:6262:111 esi-label:00049660(label 300640) &lt;&lt;&lt;&lt;&lt;&lt;community Import Accepted Localpref: 100 Router ID: 62.0.0.255 Primary Routing Table bgp.evpn.0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since this route has a native extended community, typical for this EVPN-domain, all PE routers in the evpn-domain import this route into the routing table of the corresponding EVPN instance: </font></font><br><br><pre> <code class="hljs dos">bormoglotx@RZN-PE-<span class="hljs-number"><span class="hljs-number">3</span></span>&gt; show route table RZN-VPN-<span class="hljs-number"><span class="hljs-number">3</span></span>.evpn.<span class="hljs-number"><span class="hljs-number">0</span></span> match-prefix *<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">62</span></span>* detail | match esi Communities: target:<span class="hljs-number"><span class="hljs-number">6262</span></span>:<span class="hljs-number"><span class="hljs-number">111</span></span> esi-<span class="hljs-built_in"><span class="hljs-built_in">label</span></span>:<span class="hljs-number"><span class="hljs-number">00049660</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">label</span></span> <span class="hljs-number"><span class="hljs-number">300640</span></span>) Communities: target:<span class="hljs-number"><span class="hljs-number">6262</span></span>:<span class="hljs-number"><span class="hljs-number">111</span></span> esi-<span class="hljs-built_in"><span class="hljs-built_in">label</span></span>:<span class="hljs-number"><span class="hljs-number">00049680</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">label</span></span> <span class="hljs-number"><span class="hljs-number">300672</span></span>)</code> </pre> <br>  Why is it needed?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the following scheme: </font></font><br><img src="https://habrastorage.org/files/a27/8d8/189/a278d8189f604803b31deccf6f50c89c.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this scenario, we have a potential L2 loop, because if </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic from CE1 falls on PE2, it will be sent to all other PE routers, including PE1. </font><font style="vertical-align: inherit;">PE1 also has a link to CE1, from which the </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic </font><font style="vertical-align: inherit;">was received </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And if PE1 sends a packet to CE1, then we get a loop at level 2, and as you know, there is no ttl field in the L2 header. </font><font style="vertical-align: inherit;">The situation, to put it mildly, will be unpleasant.</font></font> How to deal with it?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In EVPN, a Designated Forwarder (DF) selection is automatically used for this purpose. How it is chosen, we will consider later, but for now let's talk about his appointment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DF has the exclusive right to send broadcast frames towards the CE of the router located on the ethernet segment for which this PE router is DF. All other non-DF routers </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic towards the CE router does not send. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can have two scenarios: when using Single-Active mode and when using Active-Active mode (All-Active).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you might guess, in Single-Active mode, we have only one shoulder, the second is in reserve. In the case of the fall of the main shoulder, the traffic goes to the backup. It is possible to use one shoulder to transmit traffic in one vlan, and the second in the second, but traffic cannot go along both shoulders in one vlan (it should not be more precise - if not, then write in support, apparently you found a bug, or more likely, from the engineer who collected the circuit, hand curves). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Active-Active or All-Active mode, all links from CE to PE work, for which the </font></font><a href="http://www.juniper.net/techpubs/en_US/junos12.3/topics/concept/lag-multichassis-qfx-series-overview.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MC-LAG is built</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The principle of operation of the MC-LAG technology in this article will not be considered: it is understood that the reader has already studied this topic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first case, everything is simple - DF is selected, and all traffic, including </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traffic, only he forwards. At the same time, there is no </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> label in the announcement (in any case it is not on Juniper equipment), although according to the RFC, even in Single-Active mode, it is recommended to use this label so that in case of an error in the DF selection mechanism (when both PE routers suddenly consider themselves DF) did not form a loop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">During normal operation of the DF selection mechanism, one shoulder is simply blocked, which means that the PE router does not examine the MAC address via a blocked link, and therefore does not announce anything to other PE routers. But, even if some </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic </font><font style="vertical-align: inherit;">arrives on this router </font><font style="vertical-align: inherit;">, it will just be dropped. </font></font><br><img src="https://habrastorage.org/files/548/b35/063/548b35063e0c4167b3f8fe762e740272.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second case, a little harder. There is also selected DF, which has the right to send</font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic in the direction of the CE router - that is, problems with traffic going to the CE router, no. Problems may arise when sending </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic from the CE router. Since the CE router has absolutely no difference who of the PE DF routers (more precisely, the CE router thinks that it is simply connected to another switch with an aggregated interface), the following situation is possible. Suppose that a broadcast packet from CE1 arrives on PE1, which is not a DF. PE1 receives the packet and sends it to all other PE routers, including PE2. PE2, being the DF router for this segment, will forward </font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traffic back to CE router. </font><font style="vertical-align: inherit;">Yes, got a loop. </font><font style="vertical-align: inherit;">This is where the ESI label comes in handy. </font><font style="vertical-align: inherit;">The fact is that when sending a packet to PE2, PE1 places two labels: the ESI label (bottom of the labels) and the Inclusive Multicast label. </font><font style="vertical-align: inherit;">PE2 receives the packet, removes the top label and detects the ESI label, this tells the router that it does not need to flood the packet in the direction of CE1, since the traffic from this segment has flown. </font><font style="vertical-align: inherit;">But why then send this packet to PE2? </font><font style="vertical-align: inherit;">The fact is that PE2, in addition to CE1, from which this traffic was received, can be connected to other CE routers that may be interested in this traffic.</font></font><br><img src="https://habrastorage.org/files/711/93e/ad0/71193ead02b84c19a2b3f0324f05142e.png"><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbreviations in the diagram: </font></font><br> <b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IM</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Inclusive Multicast label </font></font><br> <b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ESI label </font></font><br> <b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TL</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Transport MPLS label</font></font></blockquote><br><blockquote> : PE1  PE2  ,        PE1  PE2  .         ,        . </blockquote><br><h4> <font color="#6577f9">MAC Mass Withdrawal</font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function is intended for those cases when one of the links with which the multihomed CE router is connected falls off. Since in the case of the Active-Active mode, the traffic from the CE of the router is balanced, the MAC addresses will also be learned from both PE routers. If one of the links falls, the PE router should cancel all routes of this segment that were sent to them. Imagine that there are 1000 or more of them, then we will get a high utilization of the processor by a sharp burst of BGP messages, which can badly affect the entire control-plane. And in time, processing a large number of Withdrawn messages is not so simple. Therefore, the PE router sends Withdrawn a message about canceling a previously sent type 1 route generated per-ESI (more on that later). Having received this message,other PE routers can either clear all MAC label matches that are associated with a given segment (ES), or if there is another router in this segment that is able to forward traffic, then use the routes received from it (that is, in fact, change the protocol next -hop) If the last router in the segment has died, then clear the MAC address table associated with the segment.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you understand, it is necessary to quickly switch from reserve to backup. </font></font><br><br><h4> <font color="#6577f9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aliasing label</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, this feature concerns the multihoming CE. </font><font style="vertical-align: inherit;">Traffic from the CE router in All-Active mode must be balanced between all links. </font><font style="vertical-align: inherit;">Since balancing is performed according to some algorithm, known only to the CE router and its developer, it is possible that the multihoming CE router will send all outgoing traffic only through one interface. </font><font style="vertical-align: inherit;">As a result, type 2 routes will be sent from only one PE router, suppose that only from PE1:</font></font><br><img src="https://habrastorage.org/files/c7f/c5c/9a3/c7fc5c9a3890419b859182a874fabd6f.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since other routers will not know how to get to the specified segment through PE2, traffic will not flow through it, which will cause a simple one of the shoulders between the PE and CE routers. To do this, each PE router announces announces an Aliasing label for its ethernet segment. Since the remaining PE routers receive type 1 routes, they see that PE1 and PE2 have links in the same ES and work in All-Active mode. Using the received aliasing tag, other PE routers can send packets to the CE router and through PE1 and PE2, visiting the packet that goes through PE2 instead of the VPN tag ‚Äî the Aliasing tag received from PE2 in a type 1 route generated by per- </font></font><abbr title="EVPN instance"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><img src="https://habrastorage.org/files/cea/d5f/219/cead5f219d624baebca0449b05ac0e4f.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbreviations on the diagram:</font></font><br><blockquote> <b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AL</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Aliasing label</font></font><br> <b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EVPN</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - EVPN label</font></font><br> <b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Transport MPLS label</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In routes of type 1 there is a flag that is responsible for informing other PE routers of the mode in which the PE router is operating in this ethernet segment ‚Äî Single-Active or All-Active. </font><font style="vertical-align: inherit;">This flag is located in the extended community, added to the announcement of the type 1 route. If the flag is raised, the router operates in the Single-Active mode (the flag is called the Single-Active flag), if the flag is not raised, the router operates in All- Active mode. </font><font style="vertical-align: inherit;">Below is an example of a route in which the flag is raised and the label is missing:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 table __default_evpn__.evpn.0 detail match-prefix *112233445566778899aa::* __default_evpn__.evpn.0: 9 destinations, 9 routes (9 active, 0 holddown, 0 hidden) * 1:62.0.0.1:0::112233445566778899aa::0/304 (1 entry, 1 announced) BGP group RR-NODES <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Internal Route Distinguisher: 62.0.0.1:0 Nexthop: Self Flags: Nexthop Change Localpref: 100 AS path: [6262] I Communities: target:6262:111 esi-label:100000(label 0)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But the route is already marked and not raised by the Single-Active flag: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 table __default_evpn__.evpn.0 detail match-prefix *62000000000000000001::* __default_evpn__.evpn.0: 9 destinations, 9 routes (9 active, 0 holddown, 0 hidden) * 1:62.0.0.1:0::62000000000000000001::0/304 (1 entry, 1 announced) BGP group RR-NODES <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Internal Route Distinguisher: 62.0.0.1:0 Nexthop: Self Flags: Nexthop Change Localpref: 100 AS path: [6262] I Communities: target:100:100 esi-label:000493a0(label 299936)</code> </pre> <br><h3> <font color="#001eff"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type 4 route</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's sort the route of type 4. This route is needed to select the DF, the purpose of which I wrote earlier. </font><font style="vertical-align: inherit;">This route is as follows:</font></font><br><img src="https://habrastorage.org/files/4c5/ce0/965/4c5ce09653474292a212a86610c45ac5.jpg"><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show route table bgp.evpn.0 match-prefix *4:6* bgp.evpn.0: 11 destinations, 11 routes (11 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 4:62.0.0.1:0::112233445566778899aa:62.0.0.1/304 *[BGP/170] 01:07:57, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.3 via ge-0/0/0.0, Push 299808</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is noteworthy that this route does not carry the community, which is configured for export from the routing-instance: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show route table bgp.evpn.0 match-prefix *4:6* detail bgp.evpn.0: 11 destinations, 11 routes (11 active, 0 holddown, 0 hidden) 4:62.0.0.1:0::112233445566778899aa:62.0.0.1/304 (1 entry, 0 announced) *BGP Preference: 170/-101 Route Distinguisher: 62.0.0.1:0 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Indirect Address: 0x95c1954 Next-hop reference count: 14 Source: 62.0.0.255 Protocol next hop: 62.0.0.1 Indirect next hop: 0x2 no-forward INH Session ID: 0x0 State: &lt;Active Int Ext&gt; Local AS: 6262 Peer AS: 6262 Age: 1:07:59 Metric2: 1 Validation State: unverified Task: BGP_6262.62.0.0.255+51796 AS path: I (Originator) Cluster list: 62.0.0.255 Originator ID: 62.0.0.1 Communities: es-import-target:33-44-55-66-77-88 Import Accepted Localpref: 100 Router ID: 62.0.0.255 Secondary Tables: __default_evpn__.evpn.0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These routes use the new community: </font></font><b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es-import-target: XX-XX-XX-XX-XX-XX</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The community itself is generated from ESI. To do this, 48 ‚Äã‚Äãbits are taken from the identifier, as shown below: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11:22: </font></font><b><font color="#FF01CE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33: 44: 55: 66: 77: 88</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 99: aa </font><font style="vertical-align: inherit;">Community </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generated: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Communities: es-import-target: </font></font><b><font color="#FF01CE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33-44-55 -66-77-88</font></font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only PE routers that have the same </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (more precisely, the same bits from 16 to 64 in the identifier) ‚Äã‚Äãimport this route. As you can see, in the announcement there is no RT specified for import or export in the routing instance. That is, type 4 routes are not visible in the routing table of EVPN itself. They can be viewed only in the bgp.evpn.0 and __default_evpn __. Evpn.0 tables.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the other PE router has </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for example aaaa334455667788aaaa, then, as it is not difficult to guess, their community will be the same, which means the route will also be imported. </font><font style="vertical-align: inherit;">But do not panic, everything is already stolen to us: the full identifier of the </font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is indicated in the body of the route itself </font><font style="vertical-align: inherit;">and this route will be imported but ignored. </font><font style="vertical-align: inherit;">Like RT, the es-import-target is intended only for route filtering. </font><font style="vertical-align: inherit;">Below is the type 4 route and its community itself:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table bgp.evpn.0 match-prefix *4:62* detail | match <span class="hljs-string"><span class="hljs-string">"comm|\/304"</span></span> 4:62.0.0.2:0::112233445566778899aa:62.0.0.2/304 (1 entry, 0 announced) Communities: es-import-target:33-44-55-66-77-88</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An interesting case is this config: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration interfaces ae1 | match esi | display <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ae1 esi 62:00:00:00:00:00:00:00:00:01 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ae1 esi all-active</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I think you already guessed that we get in the announcement of an extended community consisting of all zeros: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 table __default_evpn__.evpn.0 detail match-prefix *62000000000000000001:6* __default_evpn__.evpn.0: 9 destinations, 9 routes (9 active, 0 holddown, 0 hidden) * 4:62.0.0.1:0::62000000000000000001:62.0.0.1/304 (1 entry, 1 announced) BGP group RR-NODES <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Internal Route Distinguisher: 62.0.0.1:0 Nexthop: Self Flags: Nexthop Change Localpref: 100 AS path: [6262] I Communities: es-import-target:0-0-0-0-0-0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not assume that because of this, everything will break. </font><font style="vertical-align: inherit;">Even with such a community everything will work, but if you have, for example, an ESI in the range xx: xx: 00: 00: 00: 00: 00: 00: 00: 01-xx: xx: 00: 00: 00 : 00: 00: 00: 99: 99, then all type 4 routes will have the same community, which means that PE routers will accept and install all type 4 routes in the routing tables, even if they do not need them. </font><font style="vertical-align: inherit;">But I think that you shouldn‚Äôt sweat about it, plus / minus 100 weather routes will not do (why they won‚Äôt, you will understand when you finish the article to the end). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I don‚Äôt know if the reader noticed, but on routes like 1 and 4 the RD looks a bit strange. </font><font style="vertical-align: inherit;">For example, route type 2 from PE2:</font></font><br><br><pre> <code class="bash hljs">2:62.0.0.2:1::777::aa:bb:cc:00:07:00/304 *[BGP/170] 00:00:18, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299792</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But the route type 1 from the same PE2: </font></font><br><br><pre> <code class="bash hljs">1:62.0.0.2:0::112233445566778899aa::0/304 *[BGP/170] 00:00:56, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299792</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From PE2, route 1 of type 1 has </font></font><b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD 62.0.0.2</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , although routes from type 2 or 3 of this same PE2 come from </font></font><b><font color="#0112FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD 62.0.0.2:1</font></font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is configured in routing instance. </font><font style="vertical-align: inherit;">What happens with RD? </font><font style="vertical-align: inherit;">To test this phenomenon, we create two routing instances with EVPN type and assign them completely different RDs:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-instances RZN-VPN-3 | match route route-distinguisher 62.0.0.1:3; bormoglotx@RZN-PE-1&gt; show configuration routing-instances RZN-VPN-4 | match route route-distinguisher 9999:99;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's see how the RD type 1 route will be announced: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 | match <span class="hljs-string"><span class="hljs-string">"1:6"</span></span> 1:62.0.0.1:0::112233445566778899aa::0/304 1:62.0.0.1:0::aaaa334455667788aaaa::0/304</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD in the route does not match the configured configuration on either RZN-VPN-3 or RZN-VPN-4. </font><font style="vertical-align: inherit;">Where does this RD come from? </font><font style="vertical-align: inherit;">JunOS automatically generates it from a router-id or loopback address. </font><font style="vertical-align: inherit;">And the first value has priority. </font><font style="vertical-align: inherit;">For example, we now have a router-id:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-options router-id router-id 62.0.0.1;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this value is taken as the first part of the RD, and the second is set to zero in our case. </font><font style="vertical-align: inherit;">Let's remember the router id:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-options router-id router-id 62.62.62.62;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look, what routes are given now: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 | match <span class="hljs-string"><span class="hljs-string">"1:6"</span></span> 1:62.62.62.62:0::112233445566778899aa::0/304 1:62.62.62.62:0::aaaa334455667788aaaa::0/304</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see JunOS itself generated RD. </font><font style="vertical-align: inherit;">What happens if we do not specify the router-id? </font><font style="vertical-align: inherit;">Let's check. </font><font style="vertical-align: inherit;">But let's complicate the task by hanging a couple of addresses on a loopback:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration interfaces lo0 description <span class="hljs-string"><span class="hljs-string">"BGP &amp; MPLS router-id"</span></span>; unit 0 { family inet { address 10.1.1.1/32; address 62.0.0.1/32; address 62.62.62.62/32; } family iso { address 49.0000.0620.0000.0001.00;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look now: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 | match <span class="hljs-string"><span class="hljs-string">" 1:(1|6)"</span></span> 1:10.1.1.1:0::112233445566778899aa::0/304 1:10.1.1.1:0::aaaa334455667788aaaa::0/304</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JunOS chose the smallest loupeback IP address and used it as a router-id. </font><font style="vertical-align: inherit;">This is because this type 1 route is generated per-ESI. </font><font style="vertical-align: inherit;">If the route is generated by per- </font></font><abbr title="EVPN instance"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then it will have a native RD instance from which this route is announced. </font><font style="vertical-align: inherit;">But the type 4 route will always have a RD unique to the router, since it is always generated per-ESI. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Per-ESI route generation has some peculiarity. </font><font style="vertical-align: inherit;">Since the </font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;">ESI</font></abbr><font style="vertical-align: inherit;"> id</font></font><abbr title="Ethernet Segment Identifier"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configured on the physical interface, if we have for example 10 logical units (we can say vlans) on this interface and all in different EVPN instances, we will get that the same type 1 route will be generated in different instances. Why generate 10 identical routes (the difference in them will be only in RT), if you can generate only one and attach RT-ki to all instances that are interested in this route? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how this works with an example. </font><font style="vertical-align: inherit;">Here is the ESI configuration on the physical interface:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration interfaces ge-0/0/2 | match esi | display <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ge-0/0/2 esi 00:00:00:00:00:00:00:00:00:07 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> interfaces ge-0/0/2 esi single-active</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This interface is used by two evpn type instances: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-instances | display <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> | match ge-0/0/2. <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> routing-instances RZN-VPN-1 interface ge-0/0/2.0 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> routing-instances eVPN-test interface ge-0/0/2.200</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's see which RTs correspond to these instances (I deleted the policies and prescribed RT using the vrf-target for clarity): </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-instances RZN-VPN-1 | match target vrf-target target:62:1; bormoglotx@RZN-PE-1&gt; show configuration routing-instances eVPN-test | match target vrf-target target:62:2;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's look at the route of type 1, announced on the reflector: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route advertising-protocol bgp 62.0.0.255 table __default_evpn__.evpn.0 match-prefix *1:6*:07:* detail __default_evpn__.evpn.0: 8 destinations, 8 routes (8 active, 0 holddown, 0 hidden) * 1:62.0.0.1:0::07::0/304 (1 entry, 1 announced) BGP group RR-NODES <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Internal Route Distinguisher: 62.0.0.1:0 Nexthop: Self Flags: Nexthop Change Localpref: 100 AS path: [6262] I Communities: target:62:1 target:62:2 esi-label:100000(label 0)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the route has two RTs: target: 62: 1, which corresponds to RZN-VPN-1 and target: 62: 2, corresponding to eVPN-test. </font><font style="vertical-align: inherit;">This feature reduces convergence time. </font><font style="vertical-align: inherit;">If this link falls off, it will fall off at all instances to which it is attached. </font><font style="vertical-align: inherit;">In our case, instead of 2-x BGP Withdrawn messages, only one will fly away, but with two RTs.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note: Type 1 and 4 routes, if we wish, we will consider the reader separately, in a separate article on EVPN multihoming. </font></font></blockquote><br><h3> <font color="#001eff"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DF selection mechanism</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The DF selection mechanism allows you to select different DF for different Vlans, thus, for example, you can achieve balancing traffic between different bridge domains - traffic from different Vlans will follow different links in the direction of the CE of the router inside one EVPN instance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The router sends a type 4 route announcement with an indication of ESI and the corresponding community and starts the DF selection timer. By default, this timer is set to 3 seconds. It can be changed, but it must be the same on all PE routers of the segment - otherwise the algorithm may not work correctly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the timer expires, all PE routers participating in the DF selection make a complete list of all PE routers of the segment, starting with the smallest address. Each of the PE routers in the list is assigned a number (i), starting with zero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, the number of DF is calculated by the formula </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BA%25D0%25BE%25D0%25BC"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V mod N = i</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where V is the number of the vlan, and N is the number of PE routers in the segment. </font><font style="vertical-align: inherit;">The PE router whose number will be the result of the calculation and becomes the DF of this segment in the given plane. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to calculate DF for Vlan 777 if we have only 2 PE routers with addresses 62.0.0.1 and 62.0.0.2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both PE routers will make this list.</font></font><br><br><pre> <code class="bash hljs">62.0.0.1 i=0 62.0.0.2 i=1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we have 777 vlan, then V = 777, and N = 2 (since we have only two routers in the segment). </font><font style="vertical-align: inherit;">Now we consider 777 mod 2 = 1. So DF is 62.0.0.2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will increase the number of PE routers in the segment to 3 and count again.</font></font><br><br><pre> <code class="bash hljs">62.0.0.1 i=0 62.0.0.2 i=1 62.0.0.3 i=2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">777 mod 3 = 0, which means DF 62.0.0.1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you might guess, if we have two vlans in the segment, for example, 777 and 778 and two PE routers, then in 777 vlan DF will be PE1, and in 778 PE2. </font></font><br><img src="https://habrastorage.org/files/769/569/f85/769569f8510741a4b737b14a653bd442.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, let's see who in the above scheme will be DF with vlan-id 777:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2<span class="hljs-comment"><span class="hljs-comment"># run show evpn instance RZN-VPN-3 extensive | match "vlan|forward" VLAN ID: 777 Designated forwarder: 62.0.0.2 Backup forwarder: 62.0.0.1</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's change the number of the vlan to 778 and see if the DF changes: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2<span class="hljs-comment"><span class="hljs-comment"># run show evpn instance RZN-VPN-3 extensive | match "vlan|forward" VLAN ID: 778 Designated forwarder: 62.0.0.1 Backup forwarder: 62.0.0.2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you can see the mechanism works. </font></font><br><br><h2> <font color="#0A3BA3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evpn L3 functionality</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment we have figured out what routes exist in EVPN and how traffic will be transmitted within one bridge-domain. </font><font style="vertical-align: inherit;">This is certainly good, but after all, this technology is designed to connect data centers, and, as a rule, they are not just one vlan, like a regular client, and it is logical that traffic should go between them (vlans). </font><font style="vertical-align: inherit;">Yes, and the connection of the data center with the outside world is also necessary. </font><font style="vertical-align: inherit;">Now we will analyze how the routing of packets between different vlans (bridge-domains) works.</font></font><br><br><h3> <font color="#001eff"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IRB synchronization</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But before diving headlong into the strange but interesting world of routing integrated into EVPN, let us highlight a very important point - the synchronization of default gateways. </font><font style="vertical-align: inherit;">We still don‚Äôt know why the default-gateway community is added to the announcements of the IRB interfaces. </font><font style="vertical-align: inherit;">Not for beauty. </font><font style="vertical-align: inherit;">I think that based on the name of this item, you have already guessed that it is necessary to synchronize the default gateways. </font><font style="vertical-align: inherit;">What is synchronization, how does it happen and why is it needed?</font></font> Let's figure it out. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's look at all the MAC addresses on PE1,2 and 3, which are hung on their IRB interfaces. </font><font style="vertical-align: inherit;">In order, PE1:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show interfaces irb.777 | match mac MAC: 02:00:00:00:07:77 bormoglotx@RZN-PE-1&gt; show interfaces irb.1777 | match mac MAC: 02:00:00:00:17:77</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On PE1 mac, irb interface addresses are manually configured. </font><font style="vertical-align: inherit;">We now turn to PE2:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show interfaces irb.777 | match mac MAC: 02:00:00:02:07:77 bormoglotx@RZN-PE-2&gt; show interfaces irb.1777 | match mac MAC: 02:00:00:02:17:77</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then I allowed myself to assign addresses to IRB interfaces. </font><font style="vertical-align: inherit;">Well, let's look at PE3:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show interfaces irb | match curr Current address: 00:05:86:71:96:f0, Hardware address: 00:05:86:71:96:f0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the MAC is more terrible, since I left it the way it is sewn into the equipment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All PE routers announce the MAC + IP route to their or their default gateways (irb.777 and irb.1777). When the PE router receives the MAC + IP route marked by the default-gateway community, it begins to perceive the received MAC address of the remote IRB interface as its own address. After all, if there are interfaces on which there are several IP addresses and one MAC, then why can‚Äôt the reverse be true - one IP and several MAC addresses? Synchronization of default gateways is of two types: automatic and manual. We will consider automatic synchronization now, to manual return later. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can see which addresses are used by the PE router by the following command (we will check on PE1):</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show bridge evpn peer-gateway-macs Routing instance : RZN-VPN-1 Bridging domain : VLAN-1777, VLAN : 1777 Installed GW MAC addresses: 02:00:00:02:17:77 Bridging domain : VLAN-777, VLAN : 777 Installed GW MAC addresses: 00:05:86:71:96:f0 02:00:00:02:07:77</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On PE1 there are two bridge-domains, for each of which synchronization of default gateways is done individually. </font><font style="vertical-align: inherit;">Unlike PE1, there is only one bridge domain and one IRB interface on PE3. </font><font style="vertical-align: inherit;">Accordingly, synchronization is performed only for the VLAN-777 bridge-domain:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show evpn peer-gateway-macs Routing instance : RZN-VPN-1 Bridging domain : __RZN-VPN-1__, VLAN : 777 Installed GW MAC addresses: 02:00:00:00:07:77 02:00:00:02:07:77</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The result is the following picture - irb.777 on PE1 should respond to three MAC addresses: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 00: 05: 86: 71: 96: f0 (PE3) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 02: 00: 00: 02: 07: 77 (PE2) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 02: 00: 00: 00: 07: 77 (native PE1) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, naturally, we will now verify that the IRB interface will respond to packets addressed not to its own MAC. </font><font style="vertical-align: inherit;">Let's do it in a rustic way - we just write a static arp entry on the CE router to the MAC address we need. </font><font style="vertical-align: inherit;">Since CE1-1 is connected to PE1 in the bridge-domain of VLAN-777, when it resolves to the MAC address irb.777, it gets the native MAC address irb.777-02: 00: 00: 00: 07: 77. </font><font style="vertical-align: inherit;">We will create a static arp entry on CE1-1, which will indicate that the MAC address of irb.777 on PE1 is not 02: 00: 00: 00: 07: 77, but 02: 00: 00: 02: 07: 77 ( which actually belongs to irb.777 on PE2):</font></font><br><br><pre> <code class="bash hljs">RZN-CE1-SW1<span class="hljs-comment"><span class="hljs-comment">#sh start | i arp arp 10.0.0.254 0200.0002.0777 ARPA RZN-CE1-SW1#show arp | i 10.0.0.254 Internet 10.0.0.254 - 0200.0002.0777 ARPA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is logical to assume that the traffic will go to PE2, since the MAC address indicated on CE1-1 corresponds to irb.777 on PE2. </font><font style="vertical-align: inherit;">In order to check where the traffic will go, we attach the following filters to the PEB-NIS IRB interfaces:</font></font><br><br><pre> <code class="bash hljs">[edit] bormoglotx@RZN-PE-2<span class="hljs-comment"><span class="hljs-comment"># show | compare [edit interfaces irb unit 777 family inet] + filter { + input irb777-counter; + } [edit interfaces IRB unit 1777 family inet] + filter { + input irb1777-counter; + } [edit] + firewall { + family inet { + filter irb777-counter { + term 1 { + then { + count irb777; + accept; + } + } + } + filter irb1777-counter { + term 1 { + then { + count irb1777; + accept; + } + } + } + } + }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the filters just think that they hit the IRB interface and let all traffic through. </font><font style="vertical-align: inherit;">At the moment, both PE1 and PE2 counters are by zero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On PE1:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show firewall filter irb777-counter counter irb777 Filter: irb777-counter Counters: Name Bytes Packets irb777 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On PE2: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show firewall filter irb777-counter counter irb777 Filter: irb777-counter Counters: Name Bytes Packets irb777 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, let's run 33 icmp requests up to 10.0.0.254 with CE1-1 (why 33? So no one would guess!): </font></font><br><br><pre> <code class="bash hljs">RZN-CE1-SW1<span class="hljs-comment"><span class="hljs-comment">#ping 10.0.0.254 repeat 33 Type escape sequence to abort. Sending 33, 100-byte ICMP Echos to 10.0.0.254, timeout is 2 seconds: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Success rate is 100 percent (33/33), round-trip min/avg/max = 1/2/6 ms</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you remember, CE1-1 considers that the MAC address of the default gateway is not the local MAC irb.777 PE1, but MAC irb.777 PE2, this is very important. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We look that at us with the counter on PE1:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show firewall filter irb777-counter counter irb777 Filter: irb777-counter Counters: Name Bytes Packets irb777 3300 33</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oops, all 33 packets were received by the local IRB interface. </font><font style="vertical-align: inherit;">Let's see what's going on with the meter on PE2:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show firewall filter irb777-counter counter irb777 Filter: irb777-counter Counters: Name Bytes Packets irb777 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All by zeros. The traffic simply did not go there and was processed by the local IRB interface PE1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will give a couple of screenshots from Wireshark. Here is the packet from CE1-1 to PE1: </font><font style="vertical-align: inherit;">As the destination is not the local interface MAC interface irb.777 on PE1, but the MAC address irb.777 PE2. But what is remarkable: let's see from what address the answer from PE1 arrives at CE1-1: The </font><font style="vertical-align: inherit;">answer is still PE1 sent from the native MAC address irb.777. That is, as you understand, irb.777 only accepts packets addressed to the MAC addresses of other irb.777 interfaces (PE2 and PE3), but does not use someone else's MAC addresses as a source address when sending a packet. This is very important, since, for example, when resolving the address of the default gateway, the IRB interface will respond and indicate only its native MAC address.</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/6eb/d90/14f/6ebd9014f35c4499a3ea9b659eb837b5.JPG"></a> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/files/90f/7a3/b3a/90f7a3b3a14549ccbdbc957556546a9e.JPG"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For the purity of the experiment, let us indicate to CE1-1 that the irb.777 MAC address is now equal to the irb.777 interface MAC address on PE3: </font></font><br><br><pre> <code class="bash hljs">RZN-CE1-SW1<span class="hljs-comment"><span class="hljs-comment">#sh start | i arp arp 10.0.0.254 0005.8671.96f0 ARPA RZN-CE1-SW1#show arp | i 10.0.0.254 Internet 10.0.0.254 - 0005.8671.96f0 ARPA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, on irb.777 PE3, I also hung this filter. </font><font style="vertical-align: inherit;">Run the ping and check:</font></font><br><br><pre> <code class="bash hljs">RZN-CE1-SW1<span class="hljs-comment"><span class="hljs-comment">#ping 10.0.0.254 repeat 27 Type escape sequence to abort. Sending 27, 100-byte ICMP Echos to 10.0.0.254, timeout is 2 seconds: !!!!!!!!!!!!!!!!!!!!!!!!!!! Success rate is 100 percent (27/27), round-trip min/avg/max = 1/2/5 ms</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look in WIreshark to make sure that the packet with CE was sent with the necessary MAC address: </font><font style="vertical-align: inherit;">Look at the counter on PE1:</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/501/b09/52c/501b0952cea04de492a17f83ffc0f50a.JPG"></a> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show firewall filter irb777-counter counter irb777 Filter: irb777-counter Counters: Name Bytes Packets irb777 6000 60</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> irb.777 on PE1 processed another 27 packets, while on PE3 the counter stands at zero: </font></font><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show firewall filter irb777-couter counter irb777 Filter: irb777-couter Counters: Name Bytes Packets irb777 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This we have reviewed the automatic synchronization mechanism. </font><font style="vertical-align: inherit;">We now turn to manual synchronization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, manual synchronization is simply disabling automatic synchronization, due to the fact that it is simply not needed.</font></font> Why?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have now configured on all PEs the same IP addresses on IRB interfaces, but different MACs. The second way to configure IRB interfaces in EVPN (the same as recommended) is the same IP and MAC addresses on all IRB interfaces of the same bridge domain. In this scenario, the IRB-interfaces are already synchronized, since the same MAC everywhere. Therefore, you can give the command default-gateway do-not-advertise and thus prohibit the generation of MAC + IP routes for IRB interfaces.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The big advantage of synchronizing default gateways is that it allows us to move virtual machines between data centers without interrupting the service (if certain conditions are met, such as a delay of less than 100ms between points A (where the machine moves) and Z (where the machine moves) and so on ). After moving the virtual machine, it can continue to send packets to the external network to the default gateway address, which is located in its arp ‚Äî that is, we will not even have to clear the arp cache. Naturally, a new BGP Update will be generated, stating that now this MAC is in a different place. In general, on the topic of VM Mobility in EVPN, you need to write a separate rather big article and, therefore, we will not cover it now.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that all of the above has been deposited in memory, because without this, the mechanism of operation of L3 interfaces in EVPN will not be clear. </font><font style="vertical-align: inherit;">We now turn directly to the transfer of packets between bridge-domains.</font></font><br><br><h3> <font color="#001eff"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Packet routing between bridge domains</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take as a basis the fact that within one bridge-domain packets are switched, and between different bridge-domains (or when leaving the external network) are routed. To allow traffic to be routed, we need to add routing interfaces to our instances. At JunOS, the routing interface is IRB (Integrated Routing and Bridging). This interface is not tagged, and the vlan tag is removed from the traffic that hits it. Like the usual interface on JunOS, IRB has units. The number of a unit in the IRB interface (as, in fact, the number of units on the physical interfaces) does not mean that this interface belongs to any particular vlan. For example, the irb.777 interface does not necessarily have to refer to the 777 vlan. But it is still more convenient to read the configuration files when the vlan number and the IRB number of the unit in the same bridge-domain are the same.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For testing, we will use the same lab as before, but add routing interfaces and a CE of routers to it, as indicated in the diagram: </font></font><br><img src="https://habrastorage.org/files/6fe/8d0/ab3/6fe8d0ab3be8433ab0f223d726fcf689.png"><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For simplicity, in the article I will not indicate hostnames as they are shown in the diagram, but I will use abbreviations: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RZN-CE1-SW1 ‚áí CE1-1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RZN-CE1-SW2 ‚áí CE1-2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RZN-CE2-SW1 ‚áí CE2-1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RZN- CE2-SW2 ‚áí CE2-2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RZN-CE2-SW1 ‚áí CE3</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first glance, the scheme has a strange appearance, to put it mildly - all PE routers have the same IRB interfaces. </font><font style="vertical-align: inherit;">I think that you should have at least two questions - how it works and why it is needed. </font><font style="vertical-align: inherit;">Let's try to answer these questions.</font></font><br><br>  So let's go.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin, let us recall how the main (or default, as you like) gateway works in the VPLS we have already studied. We have some kind of PE router on which we create an IRB interface. We add the same IRB interface to a VRF or release it in </font></font><abbr title="Global routing table"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GRT</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if there is such a need. It is possible that we have more than one such router, and we use vrrp to reserve the main gateway, but someone will still be the master. That is, in VPLS, we have only one access to the external network located on some PE router that is included in the VPLS domain. All outward traffic from all other PE routers will go through this PE-ku, as it is the only access to the external network (this, if you do not use crutches in the form of intentionally broken vrrp). The disadvantages of this scheme are obvious - PE, on which the default gateway will be located, will have to digest all outgoing traffic from the VPLS domain, sent to the external network and all traffic from the outside world that is included in the VPLS domain. And so, if this PE fails, and we have not assembled VRRP,then we will generally be cut off from other networks or the outside world. Oddly enough, but this scheme has its advantages - it is simplicity. To any engineer, the solution described above will be understandable both in terms of configuration and in terms of troubleshooting, which I cannot say about the solution used in EVPN.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the shortcomings described above, there is one more important nuance - in the scheme described above, we can‚Äôt optimize L3 traffic going inside or leaving the VPLS domain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVPN offers us a completely different way of using L3 interfaces. If the CE router wants to have access to the external network, other authorities or the Internet, then the default gateway as an L3 interface must be configured on the PE that this CE is connected to the router. Naturally, each vlan must have its own gateway. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is noteworthy that the RFC does not explicitly state that every PE router must have an IRB interface in order to be able to go to the external network. But in the Juniper documentation for configuring EVPN there are such lines:</font></font><br><br><blockquote> <i>Initially when EVPN and Layer 3 gateway functionality were conceived, some basic assumptions were made, and RFC requirements were to be followed. <br><br> These were: <br><br> 1. All PE's for an EVPN instance must have an IRB configured. <br><br> 2. All PE's should have the same IP address for the GW. From the RFC, if there is a discrepancy between the GW IP addresses, an error is logged. Though it must be noted that different addresses can still be configured as both MAC/IP for advertisement to remote provider edge (PE) devices and are installed on all participating PE devices.</i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, if you use EVPN / MPLS, then it is necessary to configure the L3 interface on each PE router, otherwise this site simply will not leave Vlan. But for EVPN / VXLAN this requirement is not (by the way, this is a significant difference between EVPN / VXLAN and EVPN / MPLS) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us return to our scheme. We have two bridge-domains - this is the domain VLAN-777 and VLAN-1777. In vlan 1777 we have two CE routers - this is CE1-2 and CE2-2, in vlan 777 there are three routers: CE1-1, CE2-1 and CE3. Naturally, I want to have connectivity between all the CE routers indicated in the diagram.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in order to link several bridge-domains to each other, the mere addition of an L3 interface to the routing-instance EVPN is not enough. </font><font style="vertical-align: inherit;">It is also necessary to create on each PE router a routing-instance with a VRF type (which is used for L3VPN), in which our L3 interfaces must be placed. </font><font style="vertical-align: inherit;">Thus we will connect two instances: VRF and EVPN (or virtual-switch):</font></font><br><img src="https://habrastorage.org/files/5dc/529/c24/5dc529c243bc4766a00f19fd10cb915f.png"><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: you can release our EVPN in </font></font><abbr title="Global routing table"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GRT</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but it seems to me that this is not a good idea. </font><font style="vertical-align: inherit;">In any case, this is supported, and everybody decides whether to implement this functionality or not.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, we need to configure the routing instance with a VRF type and associate it with EVPN. </font><font style="vertical-align: inherit;">Below is the configuration with PE2 - virtual switch and its associated VRF:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show configuration routing-instances RZN-VPN-1 instance-type virtual-switch; interface ge-0/0/2.0; interface ge-0/0/3.0; route-distinguisher 62.0.0.2:1; vrf-import VPN-1-IMPORT; vrf-export VPN-1-EXPORT; protocols { evpn { extended-vlan-list [ 777 1777 ]; } } bridge-domains { VLAN-1777 { vlan-id 1777; routing-interface irb.1777; } VLAN-777 { vlan-id 777; routing-interface irb.777; } } bormoglotx@RZN-PE-2&gt; show configuration routing-instances VRF-VPN-1 instance-type vrf; interface irb.777; interface irb.1777; route-distinguisher 62.0.0.2:10002; vrf-target { import target:6262:10001; <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> target:6262:10001; } vrf-table-label;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same VRFs rise on the other PE routers, except that the VRF on PE3 does not have the irb.1777 interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We already know that a type 2 route can optionally contain a host‚Äôs IP address. We have already seen the MAC + IP route itself: if you remember, when adding an IRB interface to EVPN, we generated two routes: just the MAC address of the IRB interface so that you can reach it inside the bridge domain without resorting to routing and MAC + IP, to which the default gateway was attached. The second route was necessary for routing and is an arp entry. But the MAC + IP route is generated not only for the default gateway. Such a route to any host will appear in the event that this host tries to go to the external network or another vlan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does the host need to get out of the vlan? True - you need to send the packet to the default gateway. In our case, the gateway for the bridge-domain is played by the PE PE IRB interface. And in order to send a packet to the IRB interface, the host needs to know the MAC address of this IRB interface. Therefore, to start, the host sends an arp request for resolving the MAC addresses of the IRB interface. At that moment, when the IRB interface receives an arp request from the host (in our case, the router's CE), which is directly connected to this PE router *, it generates two type 2 routes: only the MAC address and MAC + IP - and sends them via BGP in the form of EVPN routes. In addition, since the same route in the form of a normal IPv4 prefix with a mask / 32 will also appear in the associated with EVPN VRF, as a local route,then via BGP, the vpnv4 route to this host is also sent (why you need the second one - you will understand later). Actually, the above is the main principle of EVPN operation for routing between vlans, which allows to optimize the passage of traffic between different bridge-domains or between EVPN and external networks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The table itself arp records can be viewed on each PE router. </font><font style="vertical-align: inherit;">For example on PE2:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show bridge evpn arp-table INET MAC Logical Routing Bridging address address interface instance domain 10.0.1.2 aa:bb:cc:00:0a:00 irb.1777 RZN-VPN-1 VLAN-1777 10.0.1.22 aa:bb:cc:00:0a:00 irb.1777 RZN-VPN-1 VLAN-1777 10.0.1.222 aa:bb:cc:00:0a:00 irb.1777 RZN-VPN-1 VLAN-1777 10.0.0.2 aa:bb:cc:00:07:00 irb.777 RZN-VPN-1 VLAN-777</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* 10.0.1.22 and 10.0.1.222 are the secondary addresses of CE2-2, hung during testing for dumping. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output indicates which interface the arp request was made from, in which bridge-domain and the routing instance. </font><font style="vertical-align: inherit;">This information will be useful, since the same MAC address may be in different Vlans or, as in the above output, there may be several addresses on the same physical interface, and, of course, they will have one MAC address. </font><font style="vertical-align: inherit;">To all these hosts you will definitely find a route in the VRF:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show route table VRF-VPN-1.inet.0 active-path | match <span class="hljs-string"><span class="hljs-string">"(10.0.0.2\/)|(10.0.1.2{1,3}\/)"</span></span> 10.0.0.2/32 *[EVPN/7] 00:09:38 10.0.1.2/32 *[EVPN/7] 09:11:03 10.0.1.22/32 *[EVPN/7] 02:02:40 10.0.1.222/32 *[EVPN/7] 01:54:26</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's move from theory to practice: let's look at how traffic will go from CE3 to CE1-2. The first is in vlan 777 and has an address of 10.0.0.3, the second in vlan of 1777 and has an address of 10.0.1.1. I remind you that on PE3 there is no local interface irb.1777.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, CE3 wants to send a packet to CE1-2, which is on a different network. CE3 does not know the MAC address of the main gateway, so it makes an arp request for resolv address 10.0.0.254, which for this CE router is the main gateway to other networks. Naturally, on CE3 (and on all other CE routers, the default route is registered towards the IRB interface). Since PE3 receives an arp request from CE3 addressed to its local IRB interface, PE3 generates a MAC + IP route and sends it to the remaining PEs. In addition, since the route 10.0.0.3/32 appeared in the VRF as a local route, PE3 also announces the BGP vpnv4 route:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route advertising-protocol bgp 62.0.0.255 | match 10.0.0.3 * 10.0.0.3/32 Self 100 I 2:62.0.0.3:1::777::aa:bb:cc:00:05:00::10.0.0.3/304</code> </pre> <br><blockquote> :  ,   2,   MAC-,    .        ,   . PE     MAC+IP .      ,      ‚Äî ,  ,  . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving on. CE3 now knows the MAC address of the default gateway, which means it knows where to send the packet addressed to CE1-1 (meaning the MAC address of the L2 header). CE3 forms a packet and in the L3 header the destination address indicates the address of CE1-1 (10.0.1.1), the outgoing address indicates its own address CE3 (10.0.0.3). In the L2 header, the destination address indicates the MAC address of irb.777, and the outgoing address indicates its own MAC address (the interface address in the direction of the PE of the router). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Package arrives at PE3. Since the destination MAC address is the irb.777 local interface, PE3 removes the L2 header and does an IP lookup in the VRF routing table that is associated with our EVPN-instance. There are currently four active routes in this table:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 active-path VRF-VPN-1.inet.0: 4 destinations, 9 routes (4 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.0.0/24 *[Direct/0] 00:20:05 &gt; via irb.777 10.0.0.3/32 *[EVPN/7] 00:00:06 &gt; via irb.777 10.0.0.254/32 *[Local/0] 04:04:34 Local via irb.777 10.0.1.0/24 *[BGP/170] 02:19:20, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.0.0.0/24 and 10.0.0.3/32 are local for PE3 (the second one was just generated with an arp request for irb.777), but the route to the network 10.0.1.0/24 is received via BGP from PE1 and PE2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since PE1 and PE2 are created with the same VRF as PE3 (with the same RT), PE3 accepts all announcements from PE1 and PE2. On them (PE1 and PE2), in turn, the irb.1777 interface is added to this VRF, which means they will announce the route to the 10.0.1.0/24 network via BGP as a normal vpnv4 route, which will be imported into the VRF routing table on PE3. In the output above, only active routes are shown, so we see only one announcement, in total, of course, two - one received from PE1, the second - from PE2. The best choice is the route from PE1, since it has a smaller router-id, and all other parameters of the routes received from both PE-NIS are completely identical. Which route will be chosen the best - from PE1 or PE2 - is absolutely unimportant (for example, if we have 10 sites, we will get 9 routes to one network, but only one will be chosen),since all the same when receiving</font></font><abbr title="Broadcast, Unknown Unicast, Multicast"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUM</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic from the bridge-domain of VLAN-777, PE1 will flood it to all interfaces of the bridge-domain of VLAN-1777. Why - find out further. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">During the IP lookup, PE3 learns that the prefix 10.0.1.0/24 is on PE1, so PE3 sends the packet via L3VPN to PE1:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.1.0/24 active-path VRF-VPN-1.inet.0: 4 destinations, 9 routes (4 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.1.0/24 *[BGP/170] 02:23:12, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a possibility when traffic balancing on equivalent paths (ECMP) will be enabled on PE3 and two routes will be installed in the FIB, which means traffic can also go to PE2, but this, as I wrote above, is not important - the main thing is that the packet gets to PE a router on which there is a local bridge-domain VLAN-1777 (it cannot be any other way, unless, of course, you have any hard liking between VRFs configured). If there is no such bridge-domain on PE-ke, then there will be no announcement from it to the network 10.0.1.0/24. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE1 accepts a packet from PE3 in VRF, does an IP lookup and understands that the packet is intended for the bridge-domain of VLAN-1777:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table mpls.0 label 16 mpls.0: 22 destinations, 23 routes (22 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 16 *[VPN/0] 02:25:02 to table VRF-VPN-1.inet.0, Pop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since PE1 does not know the MAC address of the host 10.0.1.1, it floods the arp request to all interfaces of the bridge-domain VLAN-1777 to the resolver of this address. More specifically, one copy of the packet is sent to CE1-2, and the second, with an inclusive multicast tag to PE2. But what about the split horizon function? After all, the packet received from the PE router should not be sent to other PE routers. And then in fact we are breaking it without a twinge of conscience. The fact is that this packet came, according to L3VPN (that is, in fact, from some external network in relation to EVPN on PE1), therefore the split-horizon rule does not work here. But we know that the packet arrived from EVPN - will there be a broadcast storm? Although the packet arrived from evpn, but from another broadcast domain (CE3 is in vlan 777, and CE1-2 in vlan 1777). Since these are different bridge domains,then there can be no broadcast storm between them - packets are routed between bridge-domains.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since CE1-2 is the destination host and is connected to PE1, it responds to the given arp request. </font><font style="vertical-align: inherit;">As we remember, after receiving the arp addressed to the IRB interface from any host, the PE router should generate a type 2 MAC + IP route. </font><font style="vertical-align: inherit;">In this regard, PE1 generates the MAC + IP and vpnv4 route:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table RZN-VPN-1.evpn.0 match-prefix *10.0.1.1* RZN-VPN-1.evpn.0: 19 destinations, 19 routes (19 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 2:62.0.0.1:1::1777::aa:bb:cc:00:09:00::10.0.1.1/304 *[BGP/170] 00:02:46, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 299792 bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.1.1/32 VRF-VPN-1.inet.0: 5 destinations, 10 routes (5 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.1.1/32 *[BGP/170] 00:02:48, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299792(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE1 now has a MAC + IP route to host 10.0.0.3 in the EVPN routing table and 10.0.0.3/32 in the VRF routing table. </font><font style="vertical-align: inherit;">Similarly, from the side of PE3: the route to the host 10.0.1.1/32 is in the routing table epn and VRF. </font><font style="vertical-align: inherit;">It turns out that now the exchange of packets between CE3 and CE1-2 does not prevent anything.</font></font> But there is one nuance.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's look at the routing table in VRF on PE1: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table VRF-VPN-1.inet.0 10.0.0.3/32 VRF-VPN-1.inet.0: 7 destinations, 15 routes (7 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.0.3/32 *[EVPN/7] 00:24:37, metric2 1 &gt; to 10.62.0.1 via ge-0/0/0.0, Push 300352, Push 299792(top) [BGP/170] 00:24:37, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 16, Push 299792(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On PE1 there are two routes to host 10.0.0.3/32, while on PE3 there is only one route to 10.0.1.1/32: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.1.1/32 VRF-VPN-1.inet.0: 6 destinations, 11 routes (6 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.1.1/32 *[BGP/170] 02:25:44, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In VRF, there appeared some strange route with so far unknown to us the EVPN protocol, and yes even with preferential 7, which makes it better than BGP (and also preferable to ISIS, OSPF, etc.). </font><font style="vertical-align: inherit;">It's strange, isn't it? </font><font style="vertical-align: inherit;">What is this route? </font><font style="vertical-align: inherit;">Why do we need it, because without it everything will work. </font><font style="vertical-align: inherit;">The fact is that this route is necessary for direct traffic exchange between EVPN, bypassing L3VPN. </font><font style="vertical-align: inherit;">Let's look at it carefully:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table VRF-VPN-1.inet.0 10.0.0.3/32 protocol evpn detail VRF-VPN-1.inet.0: 7 destinations, 15 routes (7 active, 0 holddown, 0 hidden) 10.0.0.3/32 (2 entries, 1 announced) *EVPN Preference: 7 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Indirect Address: 0x97f5f90 Next-hop reference count: 2 Next hop <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Router, Next hop index: 615 Next hop: 10.62.0.1 via ge-0/0/0.0, selected Label operation: Push 300352, Push 299792(top) Label TTL action: no-prop-ttl, no-prop-ttl(top) Load balance label: Label 300352: None; Label 299792: None; Session Id: 0x1 Protocol next hop: 62.0.0.3 Label operation: Push 300352 Label TTL action: no-prop-ttl Load balance label: Label 300352: None; Composite next hop: 0x95117b8 670 INH Session ID: 0x2 Ethernet header rewrite: SMAC: 02:00:00:00:07:77, DMAC: aa:bb:cc:00:05:00 TPID: 0x8100, TCI: 0x0309, VLAN ID: 777, Ethertype: 0x0800 Indirect next hop: 0x9860990 1048583 INH Session ID: 0x2 State: &lt;Active NoReadvrt Int Ext&gt; Age: 1:09 Metric2: 1 Validation State: unverified Task: RZN-VPN-1-evpn Announcement bits (1): 0-KRT AS path: I</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We are interested in the following lines of this output: </font></font><br><br><pre> <code class="bash hljs"> Ethernet header rewrite: SMAC: 02:00:00:00:07:77, DMAC: aa:bb:cc:00:05:00 TPID: 0x8100, TCI: 0x0309, VLAN ID: 777, Ethertype: 0x0800</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is nothing but an indication of which L2 header to add in order to send a packet to CE3! </font><font style="vertical-align: inherit;">Let's see what the MAC address is listed as the source: SMAC: 00: 05: 86: 71: 1a: f0. </font><font style="vertical-align: inherit;">It is logical that if this is the source of the packet, then it should be on PE1. </font><font style="vertical-align: inherit;">Let's estimate, from what MAC-address can packets leave in vlan 777? </font><font style="vertical-align: inherit;">It is logical to assume that this will be the irb.777 interface, which means that its L2 header should be its MAC. </font><font style="vertical-align: inherit;">Let's see what is actually the MAC address of irb.777:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show interfaces irb.777 | match mac MAC: 02:00:00:00:07:77</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's right, the header contains the MAC address of the local interface irb.777 on PE1, which means our reasoning was correct. </font><font style="vertical-align: inherit;">Let's now identify who the destination MAC address belongs to: DMAC: aa: bb: cc: 00: 05: 00? </font><font style="vertical-align: inherit;">I think it is not worth guessing - it should be MAC CE3. </font><font style="vertical-align: inherit;">Let's check:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show route table RZN-VPN-1.evpn.0 match-prefix *10.0.0.3* RZN-VPN-1.evpn.0: 21 destinations, 21 routes (21 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 2:62.0.0.3:1::777::aa:bb:cc:00:05:00::10.0.0.3/304 *[BGP/170] 00:05:18, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 299792</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This MAC belongs to the host 10.0.0.3, where it indicates the route. </font><font style="vertical-align: inherit;">To be sure, let's go to CE3 and see how the MAC on its interface is towards PE:</font></font><br><br><pre> <code class="bash hljs">RZN-CE3-SW1<span class="hljs-comment"><span class="hljs-comment">#sh ip int br | i 10.0.0.3 Ethernet0/0.777 10.0.0.3 YES NVRAM up up RZN-CE3-SW1#sh interfaces eth0/0.777 | i Hard Hardware is AmdP2, address is aabb.cc00.0500 (bia aabb.cc00.0500)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affiliation of addresses we have established. </font><font style="vertical-align: inherit;">Now let's look at the second line of the output part of interest:</font></font><br><br><pre> <code class="bash hljs">TPID: 0x8100, TCI: 0x0309, VLAN ID: 777, Ethertype: 0x0800</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And these are the values ‚Äã‚Äãthat you need to fill in the remaining ethernet fields of the frame when sending to CE3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, this route clearly indicates to us that if you need to send an ethernet frame from irb.777 to host CE3, then you need to add the specified values ‚Äã‚Äãto the L2 header, hang two tags: Push 300352, Push 299792 (top) and send the packet to the ge- interface 0/0 / 0.0.</font></font> It's simple. <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: this action with the package implies the use of a composite next hop. </font><font style="vertical-align: inherit;">That is why the inclusion of the chained-composite-next-hop functionality is mandatory on Juniper, when configuring EVPN.</font></font></blockquote><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-1&gt; show configuration routing-options forwarding-table chained-composite-next-hop { ingress { evpn; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where does this route come from? </font><font style="vertical-align: inherit;">Maybe PE3 sent it to us? </font><font style="vertical-align: inherit;">Let's check that PE3 announces on the reflector:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route advertising-protocol bgp 62.0.0.255 | match 10.0.0.3 * 10.0.0.3/32 Self 100 I 2:62.0.0.3:1::777::aa:bb:cc:00:05:00::10.0.0.3/304</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nothing criminal, only two routes have the address 10.0.0.3. </font><font style="vertical-align: inherit;">The first is the vpnv4 route, the second is EVPN type 2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So this route is local to the PE router.</font></font> That's right.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This route is generated by the local PE router based on the EVPN MAC + IP route. </font><font style="vertical-align: inherit;">But then why is it not on PE3? </font><font style="vertical-align: inherit;">Using the method of banal erudition, we can come to the conclusion that PE3 does not have a bridge-domain vlan 1777 with interface irb.1777 (after all, the package should go to CE1-2) and interface irb.1777 is not in the associated VRF. </font><font style="vertical-align: inherit;">And since there is no local interface, what MAC address should be specified as source? </font><font style="vertical-align: inherit;">You can not put the address of another interface. </font><font style="vertical-align: inherit;">That is why this route is absent on PE3. </font><font style="vertical-align: inherit;">Let's check this theory - we deactivate irb.777 interface on PE1 in the VRF interface, from which the packet will have to fly to PE3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the route to PE1 is now:</font></font><br><br><pre> <code class="bash hljs">[edit] bormoglotx@RZN-PE-1<span class="hljs-comment"><span class="hljs-comment"># run show route table VRF-VPN-1.inet.0 10.0.0.3/32 VRF-VPN-1.inet.0: 8 destinations, 18 routes (8 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.0.3/32 *[EVPN/7] 00:01:22, metric2 1 &gt; to 10.62.0.1 via ge-0/0/0.0, Push 300352, Push 299792(top) [BGP/170] 00:04:41, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 16, Push 299792(top)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deactivate the IRB interface in VRF on PE1: </font></font><br><br><pre> <code class="bash hljs">[edit] bormoglotx@RZN-PE-1<span class="hljs-comment"><span class="hljs-comment"># show | compare [edit routing-instances VRF-VPN-1] ! inactive: interface irb.777 { ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And check that we have a route to 10.0.0.3/32: </font></font><br><br><pre> <code class="bash hljs">[edit] bormoglotx@RZN-PE-1<span class="hljs-comment"><span class="hljs-comment"># run show route table VRF-VPN-1.inet.0 10.0.0.3/32 VRF-VPN-1.inet.0: 7 destinations, 13 routes (7 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.0.3/32 *[BGP/170] 00:05:47, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.1 via ge-0/0/0.0, Push 16, Push 299792(top)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, let's check, and will there be a ping? </font></font><br><br><pre> <code class="bash hljs">RZN-CE1-SW2<span class="hljs-comment"><span class="hljs-comment">#ping 10.0.0.3 Type escape sequence to abort. Sending 5, 100-byte ICMP Echos to 10.0.0.3, timeout is 2 seconds: !!!!! Success rate is 100 percent (5/5), round-trip min/avg/max = 11/14/21 ms</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, the ping passed, but now the traffic goes through L3VPN in both directions. But I want to say that even in such a scenario, the traffic route is optimized. The same will happen if the bridge-domain of VLAN-777 is removed from the configuration (in this case, irb.777 will still be in the VRF, but in the down state, since for the IRB interface to be in the up, at least one physical interface is needed able up in the bridge-domain in which the IRB-interface is located). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we stopped at the fact that the package from CE3 reached CE1-2. Now CE1-2 wants to respond to this package. Here we will do without conclusions from the CLI.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, CE1-2 sends a packet to the address of the main gateway, the address of which it already knows. PE1 accepts a packet in the bridge domain VLAN-1777. Since in the packet in the L2 header, the destination address is irb.1777, PE1 removes the L2 header and does an IP lookup in the VRF routing table. In the routing table there is a route to the host 10.0.0.3/32, and, as shown above, there are two routes and the best EVPN. PE1 simply changes the L2 header, sticks tags and sends a packet to PE3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE3 receives the packet, sees a label that indicates that the L2 lookup needs to be done in the bridge-bridge MAC table of VLAN-777, and, according to the information in it, forward the packet to CE3.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, we have reviewed the entire process that occurs with the package, as it moves from CE3 to CE1-2 and back. </font><font style="vertical-align: inherit;">But we considered the process at a time when there was no traffic between these nodes and the PE routers did not know the MAC addresses of CE1-2 and CE3. </font><font style="vertical-align: inherit;">After the addresses became known and the routes scattered across all the PEs, the traffic will go a little differently. </font><font style="vertical-align: inherit;">Let's take a quick look at how traffic will eventually go: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From CE3 to CE1-2:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The package from CE3 falls into the bridge-domain Vlan 777 on PE3. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE3 does an IP lookup in the associated VRF and sees a specific route to host 10.0.1.1/32. </font><font style="vertical-align: inherit;">Since there is no local bridge vlan 1777 on PE3, there is no EVPN route either. </font><font style="vertical-align: inherit;">So traffic goes through L3VPN to PE1.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE1 accepts the packet in the VRF, removes the label from it and sees that it is intended for the bridge-bridge vlan 1777. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE1 sends a packet to CE2-1 according to the MAC table of the bridge domain vlan 1777. </font></font></li></ol><br><img src="https://habrastorage.org/files/fe5/190/4bd/fe51904bd39047c0a85d73b0300dca83.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now pack in the opposite direction From CE1-2 to CE3: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CE1-2 sends a reply packet to PE1. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE1 does an IP lookup in VRF and sees the route to the host 10.0.0.3/32, and the best route is the EVPN route. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE1 sticks a new L2 header and adds a stack of two labels, according to the information contained in the EVPN route in the associated VRF. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE3 accepts a packet from PE1, removes the label and sees that it is necessary to do L2 lookup in the MAC table of the bridge-domain VLAN-777. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE3 then forwards the packet to CE3. </font></font></li></ol><br><img src="https://habrastorage.org/files/8e1/786/5ef/8e17865ef7cc4ef880fd9e1e1e88884b.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, in the opposite direction the package flies a little differently - this is called asymmetric forwarding. A reasonable question arises - why asymmetric? The fact is that ingress PE does an IP lookup in the VRF and sends a packet based on the route that EVFN has in the VRF, but the egress PE already accepts the packet not in the VRF, but in the EVPN instance. If we compare the last two schemes, the symmetry and asymmetry of traffic will be clearly visible. I think everyone understood how it works.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scheme, which we have disassembled, is called a scheme with a symmetric use of IRB interfaces (different vendors can call this scheme differently, this term is taken from the manuals for configuring EVPN on Brocade). An asymmetric scheme will be a scheme when all PE routers have the same IRB interfaces, even if the specified vlan does not exist on this PE router. The advantage of the asymmetric scheme is that in all VRFs there will be EVPN protocol routes ([EVPN / 7]) and your traffic will not go one way through L3VPN, but back directly to EVPN. In our case, if we add irb.1777 to PE3 to the scheme, we will get an asymmetric scheme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is one more thing that needs to be illuminated.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you know, an ARP request is sent to a broadcast address, and the answer to it is forwarded back to the sender's MAC address specified in the header. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above case, CE1-2 was directly connected to PE1 and everything worked normally: PE1 sent an arp request, and CE1-2 answered it - in fact, no problems. </font><font style="vertical-align: inherit;">But, if CE3 sent a packet to CE2-2, the events would have evolved somewhat differently. </font><font style="vertical-align: inherit;">At first, everything is the same as described earlier:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE3 looks at the VRF routing table and sees the route to the 10.0.1.0/24 network received from PE1. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PE3 has no other options than to send a packet via L3VPN to PE1. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PE1 accepts the packet, makes the L3 lookup and forwards it to the bridge-domain of VLAN-1777. </font><font style="vertical-align: inherit;">Since irb.1777 does not yet know the MAC address of CE2-2, it initiates an arp request for resolving the address of CE2-2 (10.0.1.2), sending the packet to CE1-2 and PE2.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CE1-2 drops the packet, since the address 10.0.1.2 does not belong to it. </font><font style="vertical-align: inherit;">PE2 forwards the received request to CE2-2.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CE2-2 accepts the arp request and responds with a unicast to the MAC address belonging to irb.1777 to PE1. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But will irb.1777 on PE1 get a response from CE2-2? </font><font style="vertical-align: inherit;">We recall the synchronization of MAC addresses between default gateways.</font></font> Remember?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So you understand that irb.1777 on PE2 will receive a packet directed to the MAC address of irb.1777 PE1. As a result, PE1 will not receive a response to its request, no matter how much it sends them, which means it will not split the destination IP address and will not be able to send a packet to CE2-2. It would have been like that if it hadn't been EVPN. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since irb.1777 on PE2 received arp from CE2-2, it generates a type 2 route (MAC and MAC + IP), as well as a vpnv4 prefix. As you understand, PE1 no longer needs an answer to its arp request, since now it received the MAC address of CE2-2 via BGP and can send it a packet that was in the buffer. It turns out that traffic to CE2-2, which lives on PE2 comes with a PE3 loop through PE1?</font></font> Not certainly in that way.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loop came only package (or packages), which PE3 has already managed to send and which were in the queue to send to PE1. But since, as on PE3, a more specific route to CE2-2 appeared in VRF, the traffic will no longer go through PE1 via route 10.0.1.0/24, but directly to PE2 (via route 10.0.1.2/32, which will appear in VRF routing table). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case we considered, all the IRB interfaces had different MAC addresses, which implied the need to synchronize the default gateways. The recommended use of IRB interfaces is to use the same MAC and IP addresses on all PE routers of the same bridge domain. As you understand, when MAC addresses are the same everywhere and everything will work as I described above, only synchronization of default gateways is essentially not necessary.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ultimately, in any case, no matter how you use IRB interfaces: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the same IP, but different MAC addresses; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the same IP and MAC addresses, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anyway, all PE routers in the EVPN domain will receive the MAC + IP route and the BGP vpnv4 prefix, which means that when sending a packet from another CE router, you will not need to send the arp request again to the resolver. </font><font style="vertical-align: inherit;">This allows you to significantly reduce arp flooding on the provider's network.</font></font><br><br><h3> <font color="#001eff"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exit to other VRF and external networks</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, we have analyzed how the traffic will go between the vlans. </font><font style="vertical-align: inherit;">But what about access from other VRF unrelated evpn? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to reach for example the host 10.0.1.1/32 of a VRF that is not associated with any EVPN. </font><font style="vertical-align: inherit;">I don‚Äôt want to make a new VRF, so I‚Äôll do it easier: deactivate instance evpn on PE3, deactivate irb.777 in VRF and add a new interface irb.0 (20.0.0.1/24):</font></font><br><img src="https://habrastorage.org/files/e23/2b6/c6b/e232b6c6bb4241b5be302c3100bdd3ed.png"><br><pre> <code class="bash hljs">[edit] bormoglotx@RZN-PE-3<span class="hljs-comment"><span class="hljs-comment"># show routing-instances RZN-VPN-1 ## ## inactive: routing-instances RZN-VPN-1 ## instance-type evpn; vlan-id 777; interface ge-0/0/2.777; routing-interface irb.777; route-distinguisher 62.0.0.3:1; vrf-import VPN-1-IMPORT; vrf-export VPN-1-EXPORT; protocols { evpn { interface ge-0/0/2.777; } } [edit] bormoglotx@RZN-PE-3# show routing-instances VRF-VPN-1 instance-type vrf; interface irb.0; inactive: interface irb.777; route-distinguisher 62.0.0.3:10003; vrf-target { import target:6262:10001; export target:6262:10001; } vrf-table-label; [edit] bormoglotx@RZN-PE-3# show interfaces irb.0 family inet { address 20.0.0.1/24;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look at what we have in the routing table: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 active-path VRF-VPN-1.inet.0: 7 destinations, 9 routes (7 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.0.0/24 *[BGP/170] 00:00:03, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top) 10.0.1.0/24 *[BGP/170] 00:00:03, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top) 10.0.1.1/32 *[BGP/170] 00:00:03, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top) 10.0.1.2/32 *[BGP/170] 00:00:03, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299792(top) 10.0.1.22/32 *[BGP/170] 00:00:03, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299792(top) 20.0.0.0/24 *[Direct/0] 00:00:03 &gt; via irb.0 20.0.0.1/32 *[Local/0] 00:00:03 Local via irb.0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I specifically deactivated this VRF to show that the routes / 32 will immediately arrive in the form of vpnv4 prefixes and stand in the routing table (as you can see the lifetime of the route in the table for all prefixes is the same and equals three seconds). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we‚Äôll run the ping from our IRB interface (20.0.0.1) on CE1-2 (10.0.1.1), which lives behind PE1:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; ping rapid routing-instance VRF-VPN-1 <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 20.0.0.1 10.0.1.1 PING 10.0.1.1 (10.0.1.1): 56 data bytes !!!!! --- 10.0.1.1 ping statistics --- 5 packets transmitted, 5 packets received, 0% packet loss round-trip min/avg/max/stddev = 5.828/7.872/10.368/1.655 ms</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And now before the host CE2-2 10.0.1.2, who lives on PE2: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; ping rapid routing-instance VRF-VPN-1 <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 20.0.0.1 10.0.1.2 PING 10.0.1.2 (10.0.1.2): 56 data bytes !!!!! --- 10.0.1.2 ping statistics --- 5 packets transmitted, 5 packets received, 0% packet loss round-trip min/avg/max/stddev = 5.443/6.713/7.342/0.656 ms</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now back to the routes and see if the packages go in different ways: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.1.1/32 VRF-VPN-1.inet.0: 7 destinations, 9 routes (7 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.1.1/32 *[BGP/170] 00:03:50, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299776(top)</code> </pre> <br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.1.2/32 VRF-VPN-1.inet.0: 7 destinations, 9 routes (7 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.1.2/32 *[BGP/170] 00:03:52, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299792(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, up to 10.0.1.1 the transport label 299776, and up to 10.0.1.2 - 299792. We look at what the LSP is: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Label 299776 is a transport label up to 62.0.0.1 (PE1):</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route 62.0.0.1/32 table inet.3 inet.3: 3 destinations, 3 routes (3 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 62.0.0.1/32 *[LDP/9] 03:36:41, metric 1 &gt; to 10.62.0.5 via ge-0/0/0.0, Push 299776</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tag 299776 - transport tag up to 62.0.0.2 (PE2): </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route 62.0.0.2/32 table inet.3 inet.3: 3 destinations, 3 routes (3 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 62.0.0.2/32 *[LDP/9] 03:36:45, metric 1 &gt; to 10.62.0.5 via ge-0/0/0.0, Push 299792</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, even from VRF, which knows absolutely nothing about EVPN, traffic goes the best way. </font><font style="vertical-align: inherit;">The reverse traffic from EVP to VRF to the network 20.0.0.0/24 follows the route obtained via BGP:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-2&gt; show route table VRF-VPN-1.inet.0 20.0.0.0/24 active-path VRF-VPN-1.inet.0: 10 destinations, 16 routes (10 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 20.0.0.0/24 *[BGP/170] 00:06:44, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.3 via ge-0/0/0.0, Push 16, Push 299808(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Package path from VRF (irb.0 20.0.0.1) to EVPN (CE1-2 10.0.1.1): </font></font><br><img src="https://habrastorage.org/files/b3a/7fa/e91/b3a7fae9168c44aeb39cb43a584462fb.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return traffic route: </font></font><br><img src="https://habrastorage.org/files/c80/bda/15b/c80bda15b99142379a90aca233280d0b.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the presented case is simple - routes to hosts 10.0.1.1 and 10.0.1.2 were already in the routing table. </font><font style="vertical-align: inherit;">What if there is no route to the host? </font><font style="vertical-align: inherit;">Here everything works the same way as in the first case (when there is no bridge-domain on the PE router in which the destination host lives). </font><font style="vertical-align: inherit;">Let's reach for example 10.0.0.2, which we don‚Äôt currently have a specific route to:</font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.0.2/32 bormoglotx@RZN-PE-3&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There really is no route, but we have a route to 10.0.0.0/24: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.0.0/24 | match \/24 10.0.0.0/24 *[BGP/170] 00:13:14, localpref 100, from 62.0.0.255</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is logical that the traffic will go along this route. </font><font style="vertical-align: inherit;">Run ping and verify that everything works: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bormoglotx @ RZN-PE-3&gt; ping rapid routing-instance VRF-VPN-1 source source 20.0.0.1 10.0.0.2</font></font><br><br><pre> <code class="bash hljs">PING 10.0.0.2 (10.0.0.2): 56 data bytes !!!!! --- 10.0.0.2 ping statistics --- 5 packets transmitted, 5 packets received, 0% packet loss round-trip min/avg/max/stddev = 6.135/7.206/7.806/0.663 ms</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ping successfully passed, and in VRF we had a route to host 10.0.0.2/32: </font></font><br><br><pre> <code class="bash hljs">bormoglotx@RZN-PE-3&gt; show route table VRF-VPN-1.inet.0 10.0.0.2/32 VRF-VPN-1.inet.0: 9 destinations, 11 routes (9 active, 0 holddown, 0 hidden) + = Active Route, - = Last Active, * = Both 10.0.0.2/32 *[BGP/170] 00:00:06, localpref 100, from 62.0.0.255 AS path: I, validation-state: unverified &gt; to 10.62.0.5 via ge-0/0/0.0, Push 16, Push 299792(top)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I hope you understand how it works. </font></font><br><br><h3> <font color="#0A3BA3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is it still needed?</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of my friends dubbed this technology - drug addiction. It is possible that the algorithm for using the IRB interface is too complicated and difficult to understand, not only in terms of work, but also in terms of why it is needed at all. But remember, when you first heard about MPLS - did you really understand this technology? I think that is unlikely. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But why it was impossible to do the same as in VPLS - one way out of the entire domain? Let's think about what problem the use of the L3 interface described above solves. EVPN was essentially designed to connect data centers. From the data center comes a very decent amount of traffic, in contrast to the simple client VPLS. Therefore, consider the following case:</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/27b/e5c/680/27be5c680cb14fdf82bc8e9fc9dc446b.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have one exit point from VPLS, located on PE2, and suppose that CE1 is connected to L3VPN, and CE2 to VPLS domain. The important thing is that both of these grids will live in the same datacenter, but the traffic between them will go along such a loop:</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/e5b/f16/5e9/e5bf165e9b4d4274aa9d05a2d165d21f.png"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the traffic from Server 2 goes to the exit from the VPLS domain, which is on PE2, and from PE2, through L3VPN it returns back to PE1. It is possible that even these two servers will be included in the same switch and / or stand in the same cabinet in the data center. Yes, if this is some kind of low traffic volume, then let it go like this - most likely, the game is not worth the trouble. But, if this is a streaming video, downloading any content from an FTP server and so on? Then all this amount of traffic passes through the network core twice, simply clogging the bandwidth with essentially ‚Äúspurious‚Äù traffic. This is exactly the task that the L3 EVPN functionality solves. By generating a / 32 route to the host and transferring it to the VRF, EVPN optimizes the flow of traffic between different networks. If you use EVPN in the above scheme, then PE1 would generate a / 32 route to server1,and the traffic would go locally through PE1, and not loop through the entire core:</font></font><br><br> <a href=""><img src="https://habrastorage.org/files/cea/9a1/535/cea9a15359634c2d8f61414e45d4812c.png"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this is just one example ... </font></font><br><br><h3>  <font color="#001eff">Conclusion</font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, EVPN is not just a Level 2 technology. </font><font style="vertical-align: inherit;">Routing and switching are deeply integrated into this technology. </font><font style="vertical-align: inherit;">Moreover, it is not necessary to use the above-described scheme with integration into the VRF, if you simply pass through the client L2 service.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But for everything in this world you have to pay and EVPN is no exception. The fact that the technology is complicated and confused is not a problem, you just have to figure it out (because when the VPLS seemed like a dark forest - and now it seems that everything seems logical and understandable (in any case, to me)). One of the problems can be a large number / 32 and a large number of type 2 routes, which will sometimes be unrealistic to understand. Let's estimate that we have, for example, 4 networks, the size of / 24 - roughly speaking, these are networks with 250 hosts. If we want all the hosts to communicate with each other, then we get 1000 routes / 32 (250 routes / 32 and type 2 on each network / 24). And if such domains will be 10? Then already 10,000 masked routes / 32 will fly through our network, loading the control plane.Moreover, these figures in the realities of modern data centers with their virtualization systems will be 2-3 orders higher than those described in the article. We know that router reflector sends to its neybor all the routes allowed by group export policy. If, for example, we add a PE4 router to our topology, which will have a vpnv4 session with a reflector, then it will receive all our 10,000 routes from the reflector, which are not particularly needed for it. Naturally, PE4 will look at RT and discard the announcement, but this work will also load the RE processor. There is no recommendation in the RFC about this. Juniper also recommends using the route-target family of addresses in order to receive only the necessary announcements. But in my practice I have received so far only problems from this address family.that the router will send to its neybor all the routes allowed by group export policy. If, for example, we add a PE4 router to our topology, which will have a vpnv4 session with a reflector, then it will receive all our 10,000 routes from the reflector, which are not particularly needed for it. Naturally, PE4 will look at RT and discard the announcement, but this work will also load the RE processor. There is no recommendation in the RFC about this. Juniper also recommends using the route-target family of addresses in order to receive only the necessary announcements. But in my practice I have received so far only problems from this address family.that the router will send to its neybor all the routes allowed by group export policy. If, for example, we add a PE4 router to our topology, which will have a vpnv4 session with a reflector, then it will receive all our 10,000 routes from the reflector, which are not particularly needed for it. Naturally, PE4 will look at RT and discard the announcement, but this work will also load the RE processor. There is no recommendation in the RFC about this. Juniper also recommends using the route-target family of addresses in order to receive only the necessary announcements. But in my practice I have received so far only problems from this address family.then he will receive from our reflector all of our 10,000 routes, which he doesn‚Äôt really need. Naturally, PE4 will look at RT and discard the announcement, but this work will also load the RE processor. There is no recommendation in the RFC about this. Juniper also recommends using the route-target family of addresses in order to receive only the necessary announcements. But in my practice I have received so far only problems from this address family.then he will receive from our reflector all of our 10,000 routes, which he doesn‚Äôt really need. Naturally, PE4 will look at RT and discard the announcement, but this work will also load the RE processor. There is no recommendation in the RFC about this. Juniper also recommends using the route-target family of addresses in order to receive only the necessary announcements. But in my practice I have received so far only problems from this address family.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On top of that, let's answer a simple question: why aren't MAC addresses used for routing? Indeed, unlike IPv4 addresses, there are more MAC addresses, they are globally unique, there are both broadcast and multicast addresses, there are even private (or, more precisely, manually assigned by administrators regardless of the equipment manufacturer) MAC addresses. Use - I do not want! But for some reason IP is used with all its crutches like NAT and so on. One of the most important reasons is that MAC addresses, unlike IP addresses, are not aggregated in a subnet, since the first part of them is not responsible for geographical the location of the address or the organization to which this block of addresses was issued, but for the equipment belonging to one or another manufacturer. In the end, it turns out that theoretically, MAC addresses are amenable to aggregation, but practically on a live network it is impossible to do this,for example, the MAC address 04: 01: 00: 00: 01: 01 belongs to a piece of iron located somewhere on the coast of Florida, and the piece of hardware with a MAC address is 04: 01: 00: 00: 01: 02 for example, already in Ryazan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today, FV has more than </font></font><a href="http://www.cidr-report.org/as2.0/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">600,000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aggregated routes. Imagine the size of the routing table if only 32 addresses were used for routing. Why am I writing about this? The fact is that if you have 5-6 data centers connected in which there are about 100k MAC addresses, then imagine what load will lie on the control plane on the distribution of only EVPN routes (about the same number / 32 I am silent). This problem has solutions, for example, using </font></font><a href="https://www.juniper.net/techpubs/en_US/junos13.3/topics/concept/pbb-understanding.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PBB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but, as they say, this is a completely different story ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If someone is more interested in digging deeper, then here are some links to information on this topic: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí Immediately </font></font><a href="https://datatracker.ietf.org/doc/rfc7432/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 7432 itself</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the entire history of changes; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí Juniper </font></font><a href="https://www.juniper.net/documentation/en_US/junos14.2/topics/concept/evpns-overview.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVPN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí Juniper </font></font><a href="https://www.juniper.net/documentation/en_US/junos14.1/topics/concept/evpn-irb-soultion-overview.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVPN IRB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí Cisco </font></font><a href="http://www.cisco.com/c/en/us/products/collateral/routers/asr-9000-series-aggregation-services-routers/whitepaper_c11-731864.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVPN PBB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí Cisco </font></font><a href="http://www.cisco.com/c/en/us/products/collateral/switches/nexus-9000-series-switches/guide-c07-734107.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVPN VXLAN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí Brocade </font></font><a href="http://www.brocade.com/content/html/en/brocade-validated-design/brocade-bgp-evpn-based-dci-bvd/GUID-126A7474-2591-40CE-B4F8-0B5C7E6CF415.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVPN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links to all previous issues of SDSM:</font></font></b> <div class="spoiler_text"> <a href="http://linkmeup.ru/blog/261.html">12.    .    .  . MPLS L2VPN</a> <br> <a href="http://linkmeup.ru/blog/248.html">11.1.</a>  <a href="http://linkmeup.ru/blog/248.html">Networks for the smallest.</a> <a href="http://linkmeup.ru/blog/248.html"> ‚Ññ6. MPLS L3VPN    </a> <br> <a href="http://linkmeup.ru/blog/204.html">11.    .  . MPLS L3VPN</a> <br> <a href="http://linkmeup.ru/blog/154.html">10.    .  .  MPLS</a> <br> <a href="http://linkmeup.ru/blog/129.html">9.    .  . </a> <br> <a href="http://linkmeup.ru/blog/92.html">8.1    .  ‚Ññ3. IBGP</a> <br> <a href="http://linkmeup.ru/blog/65.html">8.    .</a>  <a href="http://linkmeup.ru/blog/65.html">Part Eight</a>  <a href="http://linkmeup.ru/blog/65.html">BGP and IP SLA</a> <br> <a href="http://linkmeup.ru/blog/50.html">7.    .  .</a>  <a href="http://linkmeup.ru/blog/50.html">VPN</a> <br> <a href="http://linkmeup.ru/blog/33.html">6.    .</a>  <a href="http://linkmeup.ru/blog/33.html">Part six.</a> <a href="http://linkmeup.ru/blog/33.html"> </a> <br> <a href="http://linkmeup.ru/blog/16.html">5.    :  . NAT  ACL</a> <br> <a href="http://linkmeup.ru/blog/15.html">4.    :  .</a>  <a href="http://linkmeup.ru/blog/15.html">STP</a> <br> <a href="http://linkmeup.ru/blog/14.html">3.    :  .  </a> <br> <a href="http://linkmeup.ru/blog/13.html">2.    .</a>  <a href="http://linkmeup.ru/blog/13.html">Part two.</a> <a href="http://linkmeup.ru/blog/13.html"></a> <br> <a href="http://linkmeup.ru/blog/12.html">1.    .</a>  <a href="http://linkmeup.ru/blog/12.html">Part one.</a> <a href="http://linkmeup.ru/blog/12.html">   cisco</a> <br> <a href="http://linkmeup.ru/blog/11.html">0.    .  .</a>  <a href="http://linkmeup.ru/blog/11.html">Planning</a> </div></div><br><h4> <font color="#407BF9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the author</font></font></font> </h4><br> <font color="#407BF9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Writing an article, testing various functions, reading the RFC and other available literature from various vendors (not limited to Cisco and Juniper) took more than 2 months. </font><font style="vertical-align: inherit;">As you can see, the tests were conducted exclusively at Juniper, and for other vendors the implementation of some functionality may differ slightly from that described above. </font><font style="vertical-align: inherit;">I hope the article will be clear and useful to readers. </font><font style="vertical-align: inherit;">If you found typos in the article or some shoals - write in a personal. </font><font style="vertical-align: inherit;">Well, thank you for your attention ...</font></font></font> </div><p>Source: <a href="https://habr.com/ru/post/316792/">https://habr.com/ru/post/316792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316782/index.html">Fuel cells as one of the sources of energy for the data center</a></li>
<li><a href="../316784/index.html">Psychology of persuasion. How to convince others and be able to recognize the manipulation</a></li>
<li><a href="../316786/index.html">Unifi Controller + Nginx. HTTP & HTTPS</a></li>
<li><a href="../316788/index.html">Own platform. Part 0.2 Theory. CHIP8 interpreter</a></li>
<li><a href="../316790/index.html">URL rewriting on github pages</a></li>
<li><a href="../316794/index.html">The digest of interesting materials for the mobile developer # 182 (November 28-December 4)</a></li>
<li><a href="../316800/index.html">Diary of performances from Minsk DevGAMM 2016</a></li>
<li><a href="../316802/index.html">Running PHP applications on Docker containers (PHP-FPM, Nginx, PostgreSQL)</a></li>
<li><a href="../316806/index.html">htop and more on your fingers</a></li>
<li><a href="../316808/index.html">An easy way to present your UX solutions to a potential client.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>