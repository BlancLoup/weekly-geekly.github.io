<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>License to drive a car, or why applications should be Single-Activity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At AppsConf 2018 , which was held on October 8-9, I gave a presentation on the creation of android applications entirely in one Activity. Although the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>License to drive a car, or why applications should be Single-Activity</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/n0/m4/p4/n0m4p4tyrh-7bky85jet7jyzllc.png" alt="image"></p><br><p>  At <a href="http://appsconf.ru/2018">AppsConf 2018</a> , which was held on October 8-9, I gave a presentation on the creation of android applications entirely in one Activity.  Although the topic is well-known, there are many prejudices regarding this choice - a crowded room and the number of questions after the presentation is confirmed.  In order not to wait for the video, I decided to make an article with a transcript of the speech. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1b8/c2d/a29/1b8c2da294869720e98d50d529300817.jpg"></p><br><p>  What I will tell you </p><br><ol><li>  Why and why it is necessary to switch to Single-Activity </li><li>  A universal approach to solving the problems that you are used to solve on multiple activities </li><li>  Examples of standard business tasks </li><li>  Narrow places where the code is usually propped up and not done honestly </li></ol><a name="habracut"></a><br><h2 id="pochemu-single-activity---eto-pravilno">  Why is Single-Activity right? </h2><br><h4 id="zhiznennyy-cikl">  Life cycle </h4><br><p><img src="https://habrastorage.org/webt/6i/k8/fk/6ik8fkusqlvahretkm_yqfhfgg8.png"></p><br><p>  All android developers know the scheme of the "cold" launch of the application.  First, onCreate is called on the Application class, then the life cycle of the first Activity comes into effect. <br>  If in our application there are several Activities (and most of such applications), the following occurs: </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">App</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onPause</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStop</span></span>()</code> </pre> <br><p>  This is the abstract startup log of ActivityB from ActivityA.  Empty line - the moment when the launch of the new screen was called.  At first glance, everything is fine.  But if we turn to the documentation, it becomes clear: to ensure that the screen is visible to the user, and he can interact with it, it is possible only after calling <code>onResume</code> on each screen: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">App</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">--------</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onPause</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onCreate</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStart</span></span>() <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityB</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onResume</span></span>() &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">--------</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ActivityA</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.onStop</span></span>()</code> </pre> <br><p>  The problem is that such a log does not help to understand the life cycle of an application.  When the user is still inside, and when he has already moved to another application or has turned ours and so on.  And this is necessary <strong>when we want to bind business logic to the life cycle of an application, for example, keep the socket connection while the user is in the application, and close it when exiting</strong> </p><br><p>  In the Single-Activity application, everything is simple - the life of the Activity becomes the life of the application.  Everything you need for any logic is easy to link to the state of the application. </p><br><h4 id="zapusk-ekranov">  Running screens </h4><br><p>  As a user, I often come across the fact that a call from the phone book (and this is clearly the launch of a separate Activity) does not occur after clicking on a contact.  It is not clear what this is connected with, but those to whom I tried to get through unsuccessfully said they took the call and heard the sound of footsteps.  Moreover, my smartphone has long been in my pocket. </p><br><p><img src="https://habrastorage.org/webt/iq/u5/kx/iqu5kxfhylvhmqh5wzuwvqpztzi.png"></p><br><p>  The problem is that launching an Activity is a completely asynchronous process!  There is no guarantee of instant launch, and even worse is that we can not control the process.  Totally. </p><br><p>  In the Single-Activity application, working with the fragment manager, we can control the process. <br>  <code>transaction.commit()</code> - performs screen switching asynchronously, which allows you to open or close multiple screens in a row. <br>  <code>transaction.commitNow()</code> - switches the screen synchronously, if you do not need to add it to the stack. <br>  fragmentManager.executePendingTransactions () `allows you to perform all previously started transactions right now. </p><br><h4 id="analiz-steka-ekranov">  Screen stack analysis </h4><br><p>  Imagine that the business logic of your application depends on the current depth of the stack of screens (for example, nesting restrictions).  Or at the end of some process you need to return to a certain screen, and if there are several identical ones, to the one closest to the root (the beginning of the chain). <br>  How to get an Activity stack?  What parameters need to be specified when starting the screen? </p><br><p><img src="https://habrastorage.org/webt/pk/bz/5h/pkbz5hhcjv_gqiyirr7ab5e27h8.png"></p><br><p>  By the way, about the magic of startup parameters Activity: </p><br><ul><li>  you can specify the launch flags in Intent (and also mix them with each other, and change them from different places); </li><li>  you can add startup parameters in the manifest, because all Activity should be described there; </li><li>  add Intent filters here to handle external launch; </li><li>  and finally think about MultiTasks, when the Activity can run in different ‚Äútasks‚Äù. </li></ul><br><p>  Taken together, this creates confusion and problems with debugging support.  You can never say with certainty exactly how the screen was launched, and how it affected the stack. </p><br><p>  In the Single-Activity application, all screens are switched only through fragment transactions.  You can analyze the current screen stack and saved transactions. <br>  In the demo application of the <a href="https://github.com/terrakok/Cicerone">Cicerone</a> library, you can see how the current stack status is displayed in the toolbar. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/45f/285/af2/45f285af219d69df32d0994db1eeb58d.gif" alt="image"></p><br><p>  <em>Note:</em> in the latest version of the library support, access to the fragment array inside the fragment manager was closed, but if you really want, this problem can always be solved. </p><br><h4 id="activity-tolko-odna-na-ekrane">  Activity is only one on the screen. </h4><br><p>  In real applications, we will definitely need to combine the "logical" screens in one Activity, then you cannot write a real application ONLY to the Activity.  Duality of approach is always bad, since the same problem can be solved in different ways (somewhere, the layout is right in the Activity, and somewhere, the Activity is just a container). </p><br><h4 id="dont-keep-activities">  Don't keep activities </h4><br><p>  This flag for testing really allows you to find some bugs in the application, but the behavior that it reproduces is <strong>NEVER</strong> encountered in reality!  It does not happen that the application process remains, and at this moment the Activity, even if not active, is dying!  An activity can only die with an application process.  If the application is displayed to the user, and the system lacks resources, everything around will die (other inactive applications, services, and even a launcher), and your application will live to a victorious end, and if it has to die, then it will be complete. <br>  You can check. </p><br><h4 id="nasledie">  Heritage </h4><br><p>  Historically, the Activity has a huge amount of superfluous logic, which most likely will not be useful to you.  For example, everything you need to work with <code>loaders</code> , <code>actionBar</code> , <code>action menu</code> and so on.  This makes the class itself quite massive and ponderous. </p><br><h4 id="animacii">  Animations </h4><br><p>  Anyone can make a simple shift animation when switching between activities.  Here it is necessary to clarify that we need to make a discount on the asynchronous launch of the Activity, which we talked about earlier. <br>  If you need something more interesting, you can think of such examples of transition animation, which are made on the Activity: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62f/b33/b28/62fb33b285f8eb80ff856c813e278552.gif" alt="image"></p><br><p>  But there is a big problem: it is almost impossible to customize this animation.  Designers and the customer is unlikely to please. </p><br><p>  With fragments everything is different.  We can go straight down to the level of the view hierarchy and make any animation you can imagine!  Direct evidence <a href="https://github.com/danielzeller/Depth-LIB-Android-">here</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/446/23f/e72/44623fe72553a5f7ba0b0074c45109eb.gif" alt="image"></p><br><p>  If you look at the source code, you will find that this is done in a conventional layout.  Yes, the code is decent there, but animation is always quite difficult, and having this opportunity is always a plus.  If you have two Activities switching, then there is no common container in the application where you can make such transitions. </p><br><h4 id="izmenenie-konfiguracii-naletu">  Configuration change on the fly </h4><br><p>  This point was not in my statement, but it is also very important.  If you have a feature with language switching inside the application, then with several Activities it will be quite problematic to implement it, if, among other things, you don‚Äôt need to restart the application, but stay in the same place where the user was at the moment of the functionality call. </p><br><p>  In the Single-Activity application, it is enough to change the installed locale in the application context and call <code>recreate()</code> on the Activity; the system will do the rest by itself. </p><br><h4 id="naposledok">  At last </h4><br><p>  Google has a solution for navigation, the documentation of which <a href="https://android-developers.googleblog.com/2018/05/use-android-jetpack-to-accelerate-your.html%3Fm%3D1">explicitly states</a> that it is desirable to write a Single-Activity application. </p><br><p>  At this point, I hope you have no doubt that the classic approach with several Activities contains a number of drawbacks, which are usually taken as a blind eye, hiding behind the general tendency of Android discontent. </p><br><h2 id="esli-vse-tak-to-pochemu-single-activity-esche-ne-standart-razrabotki">  If so, then why is Single-Activity not yet a development standard? </h2><br><p>  Here I will quote my good friend: </p><br><p><img src="https://habrastorage.org/webt/z_/k_/ou/z_k_outvwlcibszeamtv2jhjst0.png"></p><br><p>  Starting a new serious project, any leader is afraid of failure and avoids risky decisions.  It is right.  But I will try to provide a comprehensive plan for the transition to Single-Activity. </p><br><h4 id="perehod-na-single-activity">  Transition to Single-Activity </h4><br><p><img src="https://habrastorage.org/webt/vf/sw/8h/vfsw8hvr_sfcjs3olaxb3s2lptw.png"></p><br><p>  If you study this application, you can determine by its characteristic animations and behavior that it is written in several Activities.  I could be wrong, and everything was done even on custom views, but this will not affect our reasoning. </p><br><p>  And now attention!  Do this like this: </p><br><p><img src="https://habrastorage.org/webt/0v/dt/cm/0vdtcmkom7y0jt0osv3fj61wn4k.png"></p><br><p>  We made only two changes: we added the AppActivity class and replaced all the Activities with FlowFragment.  Consider each change in more detail. </p><br><p>  What is <strong>AppActivity</strong> responsible for: </p><br><ul><li>  contains only a container for fragments <br><ul><li>  is the initialization point of UI scop objects (earlier it was necessary to do this in Application, which is wrong, because, for example, the services in our application do not exactly need such objects) </li><li>  is a lifecycle provider application </li><li>  brings all the advantages of a single-activity. </li></ul></li></ul><br><p>  What is <strong>FlowFragment</strong> : </p><br><ul><li>  does exactly the same as the Activity that was created instead. </li></ul><br><h4 id="novaya-navigaciya">  New navigation </h4><br><p>  The main difference from the old approach is navigation. </p><br><p><img src="https://habrastorage.org/webt/6c/xe/xm/6cxexm9iv1rxz4p9ag1hov7jb90.png"></p><br><p>  Previously, the developer had a choice: to launch a new Activity or a fragment transaction in the current one.  The choice has not disappeared, but the methods have changed - now you have to decide whether to start the fragments transaction in AppActivity or inside the current FlowFragment. </p><br><p><img src="https://habrastorage.org/webt/am/cq/ac/amcqacvs343ah96hpnaykgnixtw.png"></p><br><p>  Similarly, with the processing of the Back button.  Previously, the Activity passed the event to the current fragment, and if it did not process it, it made the decision itself.  Now AppActivity sends the event to the current FlowFragment, and that, in turn, sends it to the current fragment. </p><br><h4 id="peredacha-rezultata-mezhdu-ekranami">  Transfer the result between screens </h4><br><p>  For inexperienced developers, the issue of data transfer between screens is the main problem of the new approach, because before it was possible to use the startActivityForResult () functionality! </p><br><p>  Not the first year various architectural approaches to writing applications are discussed.  The main task here is the separation of the UI from the data layer and the business logic.  From this point of view, startActivityForResult () breaks the canon, since the data between the screens of <strong>one</strong> application is transmitted on the side of the UI layer entities.  I emphasize that it is exactly <strong>one</strong> application, since we have a common data layer, common models in the global scopa, and so on.  We do not use these opportunities and drive ourselves into the framework of one Bundle (serialization, size, and more). <br>  <strong>My advice</strong> : do not use startActivityForResult () inside the application!  Use it only for its intended purpose - to launch external applications and get results from them. </p><br><p>  How then to launch the screen with a choice for other screen?  There are three options: </p><br><ol><li>  TargetFragment </li><li>  Eventbus </li><li>  reactive model </li></ol><br><p>  TargetFragment is an out-of-box option, but the same data transfer is on the UI layer side.  <strong>Bad option.</strong> </p><br><p>  EventBus - if you can agree in a team and - most importantly - monitor the arrangements, then on the global data bus you can implement data transfer between screens.  But since this is a dangerous move, the conclusion is a <strong>bad option.</strong> </p><br><p>  Reactive model - this approach implies the presence of callbacks and nothing more.  How you implement them is decided by the team of each project.  But it is this approach that is optimal, as it provides control over what is happening and does not allow using the code for other purposes.  <strong>Our choice!</strong> </p><br><h4 id="itog">  Total </h4><br><p>  I love new approaches when they are simple and have clear benefits.  I hope that in this case it is.  The benefits are described in the first part, and the difficulty of judging you.  It is enough to replace all the Activity with FlowFragment, keeping all logic unchanged.  Slightly change the navigation code and think about working with transferring data between screens, if this has not already been done. </p><br><p>  To show the simplicity of the approach, I myself <a href="https://gitlab.com/terrakok/gitlab-client/commit/0d5e108e426a4a284b0f08887bc2671f927643bd">translated the open application</a> to a Single-Activity, and it took only a few hours (of course it is worth considering that this is no older than Legacy, and everything is more or less good with architecture). </p><br><h2 id="chto-poluchilos">  What happened? </h2><br><p>  Let's see how now to solve standard problems in a new approach. </p><br><h4 id="bottomnavigationbar-i-navigationdrawer">  BottomNavigationBar and NavigationDrawer </h4><br><p>  Using the simple rule that we replace all Activity with FlowFragment, the side menu will now be in a certain fragment and switch nested fragments in it: </p><br><p><img src="https://habrastorage.org/webt/hp/dv/u9/hpdvu9gp85_zzzt2qi23ndafrxw.png"></p><br><p>  Similar to BottomNavigationBar. <br>  Much more interesting is that some FlowFragment we can invest in others, because these are still ordinary fragments! </p><br><p><img src="https://habrastorage.org/webt/vk/qo/2r/vkqo2rovrabjb_2qorv-ot6leie.png"></p><br><p>  This option can be found in <a href="https://gitlab.com/terrakok/gitlab-client">GitFox</a> . </p><br><p>  It is the ability to simply combine some fragments inside others without any problems to make a dynamic UI for different devices: tablets + smartphones. </p><br><h4 id="di-skoupy">  Di scopes </h4><br><p>  If you have a flow of purchase of goods from several screens, and on each screen you need to show the name of the product, you probably already carried it into a separate Activity, which stores the product and provides it with screens. <br>  It will be the same with FlowFragment - it will contain a DI-scop with models for all nested screens.  This approach eliminates the difficult time management of the life of a scop, tying it to the lifetime of the FlowFragment. </p><br><p><img src="https://habrastorage.org/webt/jg/o7/fc/jgo7fcldgytixv_pi4rd4vv9ynw.png"></p><br><h4 id="deep-links">  Deep-links </h4><br><p>  If you used filters in the manifest to launch via a deep-link specific screen, you might have problems starting the Activity, which I wrote about in the first part.  In the new approach, all deep-link fall into AppActivity.onNewIntent.  Further, according to the data obtained, a transition occurs to the required screen (or a chain of screens. I suggest looking at this <a href="">functionality in Chicheron</a> ). </p><br><p><img src="https://habrastorage.org/webt/hg/hv/dz/hghvdzuz1kp_zaj_mqqxwgbbmk0.png"></p><br><h4 id="smert-processa">  Death process </h4><br><p>  If the application is written on several Activities, you should know that when the application dies, then when the process is restored, the user will be on the last Activity, and all previous ones will be restored only when they are returned to them. </p><br><p><img src="https://habrastorage.org/webt/za/39/ws/za39wsenkveryhdk21ngp0w-hyq.png"></p><br><p>  If this is not taken into account in advance, problems may arise.  For example, if the scop needed for the last Activity was opened at the previous one, no one will recreate it.  What to do?  Bring it to the Application class?  Make a few points of opening scop? </p><br><p>  Everything is easier with fragments, as they are inside an Activity or another FlowFragment, and any container will be restored BEFORE re-creating the fragment. </p><br><p><img src="https://habrastorage.org/webt/8p/vd/q5/8pvdq5nmwbgjbfi6am26nzotpnq.png"></p><br><p>  Other practical problems can be discussed in the comments, because otherwise there is a chance that the article will be too voluminous. </p><br><p>  And now the most interesting part. </p><br><h2 id="uzkie-mesta-nado-pomnit-i-dumat">  Narrow places (remember and think). </h2><br><p>  Here are collected important things that you should think about in any project, but everyone is so accustomed to ‚Äúpodkostilivat‚Äù in projects for several Activities, which is worth recalling and telling how to solve them correctly in a new approach.  And first on the list </p><br><h4 id="povorot-ekrana">  Screen rotation </h4><br><p>  That most <u>terrible fairy tale</u> for fans to whine that Android recreates Activity when turning the screen.  The most popular solution method is fixing the portrait orientation.  Moreover, this proposal is no longer developers, but managers, frightened by phrases like " <em>supporting a turn is very difficult and costs several times more</em> ." <br>  We will not argue about the correctness of such a decision.  Another thing is important: the <strong>fixation of the rotation does not exempt from the treatment of death</strong>  Since the same processes occur when many other events occur: split-mode, when several applications are displayed on the screen, connecting an external monitor, changing the application configuration on the fly, and so on. </p><br><p>  Moreover, the screen rotation allows you to check the correct ‚Äúrubberiness‚Äù of the layout, so in our St. Petersburg team we do not disable the rotation on all debug builds, even if it isn‚Äôt in the release version.  Not to mention the typical bugs that will still be found during the check. </p><br><p>  Many solutions have already been written to handle the rotation, starting with <a href="https://github.com/Arello-Mobile/Moxy">Moxy</a> and ending with various MVVM implementations.  Make it no more difficult than anything else. </p><br><p>  Consider another interesting case. <br>  Imagine a product catalog application.  We do it in Single-Activity.  Everywhere the portrait mode is fixed, but the customer wants a feature when, when viewing a photo gallery, a user can watch them in landscape orientation.  How to support this? </p><br><p>  Someone will offer the <strong>first crutch</strong> : </p><br><pre> <code class="hljs pgsql">&lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".AppActivity" android:configChanges="orientation" /&gt;</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigurationChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(newConfig: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Configuration</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newConfig?.orientation == Configuration.ORIENTATION_LANDSCAPE) { <span class="hljs-comment"><span class="hljs-comment">//ignore } else { super.onConfigurationChanged(newConfig) } }</span></span></code> </pre> <br><p>  Thus, we can not call <code>super.onConfigurationChanged(newConfig)</code> , but process it ourselves and rotate only the necessary views on the screen. <br>  But with API 23, the project will crash with <code>SuperNotCalledException</code> , so a <strong>bad choice</strong> . </p><br><p>  <strong>In the statements above, an error was made:</strong> <br>  I was reasonably corrected in the comments that it is enough to add android: configChanges = "orientation | screenSize", and then you can call super when the turn is over and the Activity will not be recreated.  It is useful to use when on the screen a webview or a map that is long initialized, and this one wants to avoid. <br>  This will help solve the described case with the gallery, but the main message of this section is: <u>do not ignore the re-creation of the Activity</u> , this can happen in many other cases. </p><br><p>  Someone may suggest another solution: </p><br><pre> <code class="hljs pgsql">&lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".AppActivity" android:screenOrientation="portrait" /&gt; &lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".RotateActivity" /&gt;</code> </pre> <br><p>  But in this way we move away from the Single-Activity approach for solving a simple task and deprive ourselves of all the benefits of the approach.  This is a crutch, and a crutch is always a <strong>bad choice</strong> . </p><br><p>  Here is the right decision: </p><br><pre> <code class="hljs pgsql">&lt;activity android:<span class="hljs-type"><span class="hljs-type">name</span></span>=".AppActivity" android:configChanges="orientation" /&gt;</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResume() activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause() activity?.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT }</code> </pre> <br><p>  That is, when a fragment is opened, the application starts to ‚Äúspin‚Äù, and when it returns, it is fixed again.  According to my observations, this is how the <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.airbnb.android">AirBnB</a> application <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.airbnb.android">works</a> .  If you open the view of housing photos, cornering is activated, but in landscape orientation you can pull the photo down to exit the gallery.  Below it, the previous screen in landscape orientation will be visible, which you usually will not find, since immediately after leaving the gallery the screen will turn into a portrait and fix. </p><br><p><img src="https://habrastorage.org/webt/to/wt/kj/towtkjtucdgw_d2s5da7b2awzkm.png"></p><br><p>  This is where the timely preparation for screen rotation will help. </p><br><h4 id="transparent-status-bar">  Transparent status bar </h4><br><p>  Only Activity can work with the system bar, and now it‚Äôs only one for us, so you should always specify </p><br><pre> <code class="hljs pgsql">&lt;item <span class="hljs-type"><span class="hljs-type">name</span></span>="android:windowTranslucentStatus"&gt;<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&lt;/item&gt;</code> </pre> <br><p>  But on some screens there is no need to "crawl" under it, and you need to display all the content below.  The flag comes to the rescue </p><br><pre> <code class="hljs objectivec">android:fitsSystemWindows=<span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br><p>  which indicates the layout that you should not draw under the system bar.  But if you specify it in the layout of the fragment, and then you try to display the fragment through the transaction in the fragment manager, then you will be disappointed ... it will not work! <br>  <a href="https://stackoverflow.com/questions/31190612">The answer is quickly googled</a> <br>  I highly recommend that you read, there is a really comprehensive answer and many useful links. <br>  A quick and working ( <em>but not the most correct</em> ) solution is to wrap the layout in <code>CoordinatorLayout</code> </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:app</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:fitsSystemWindows</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  A better solution helps to handle and keyboard. </p><br><h4 id="izmenenie-verstki-pri-poyavlenii-klaviatury">  Change the layout when the keyboard appears </h4><br><p>  When the keyboard leaves, the layout should be changed so that the important elements of the UI do not remain out of reach.  And if earlier we could specify different modes of reaction to the keyboard for different Activities, now we need to do this in Single-Activity.  Therefore it is necessary to use </p><br><pre> <code class="hljs objectivec">android:windowSoftInputMode=<span class="hljs-string"><span class="hljs-string">"adjustResize"</span></span></code> </pre> <br><p>  If you use the approach from the previous section for processing the transparent status bar, you will find an annoying error: if the fragment successfully ‚Äúcrawled‚Äù under the status bar, then when the keyboard appears, it will shrink from the top and bottom, since both the status bar and the keyboard inside the system work through <code>SystemWindows</code> . </p><br><p>  Note the title </p><br><p><img src="https://habrastorage.org/webt/vr/ay/xo/vrayxosszrpgfsq-eyia_z4hshi.gif"></p><br><p>  What to do?  Learn the documentation!     <a href="https://www.youtube.com/watch%3Fv%3D_mGDMVRO3iE">Chris Banes  WindowInsets</a> . </p><br><p>  WindowInsets  </p><br><ul><li>      (   51dp) </li><li>          </li><li>    ( !) </li><li>       . </li></ul><br><p> <strong>  WindowInsets!</strong> </p><br><h4 id="splash-screen"> Splash screen </h4><br><p>  -    ,   Splash screen ‚Äî      ,   ,  ,     ,   Activity   .   <a href="https://medium.com/%40ssaurel/create-a-splash-screen-on-android-the-right-way-93d6fb444857"></a>   . </p><br><p><img src="https://habrastorage.org/webt/fs/nd/nt/fsndntzk-erl-iebzisfiiftsfc.png"></p><br><p>    ,   Single-Activity,    Splash screen.     ,     deep-link      Splash screen     . </p><br><h4 id="zapusk-vashego-prilozheniya-iz-drugih-prilozheniy">       </h4><br><p>  <strong>    </strong> ,    ,      ,    . </p><br><p> ,       .    Single-Activity.    -         ,   ,    . <br>                 ... <br>  Intent,   ,        ... <br>  What's next?   : </p><br><ul><li>    ,       ¬´¬ª.    ¬´¬ª,    .    ,   ! </li><li>      ,    ‚Ä¶ </li></ul><br><p>      ,     .           ?     ‚Äî           ¬´¬ª   ¬´¬ª   . </p><br><p>  What to do?  ,    . </p><br><p>    Activity! <br> ,    :       ,   ‚Äî        . <br>       ‚Äî ,      (   Activity),    . </p><br><p>  Activity ‚Äî       .      Activity,         .     . </p><br><p><img src="https://habrastorage.org/webt/hj/cs/wd/hjcswdrykm21jtyzupyongbe494.png"></p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>    ()   ,        Activity,        Android-.         ,             . </p><br><p>    :     Google       .        ‚Äî      ,   ,    Activity     . </p><br><p> ,    ,      ,        !  Thank! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/426617/">https://habr.com/ru/post/426617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426605/index.html">Static analysis of PHP code on the example of PHPStan, Phan and Psalm</a></li>
<li><a href="../426609/index.html">In Office 365 and other MS products will add voice I / O mode for dyslexics</a></li>
<li><a href="../426611/index.html">Integration with SAP ERP, for example with Django-python, using the oData (rest) protocol</a></li>
<li><a href="../426613/index.html">Do not let the 3D printer lazy</a></li>
<li><a href="../426615/index.html">We write CLI on NodeJS</a></li>
<li><a href="../426621/index.html">Compact strings in Java 9</a></li>
<li><a href="../426623/index.html">This is an electric bus: what do we know about transport with a battery</a></li>
<li><a href="../426625/index.html">Multilingual trees in Yii2 on the example of creating a menu module</a></li>
<li><a href="../426627/index.html">Flexbox usage examples</a></li>
<li><a href="../426629/index.html">Trump's Tax Reform Philosophy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>