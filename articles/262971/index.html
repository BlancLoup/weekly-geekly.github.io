<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thinking about error handling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of error handling is complex and ambiguous. There is still no optimal approach or group of approaches to this problem. All of them suffer fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thinking about error handling</h1><div class="post__text post__text-html js-mediator-article">  The topic of error handling is complex and ambiguous.  There is still no optimal approach or group of approaches to this problem.  All of them suffer from certain shortcomings.  In this article I would like to share my thoughts on this topic, and last but not least, learn new knowledge in the comments. <br><br>  The code in the article is given in scala, but the approach in question can be implemented in many other languages ‚Äã‚Äã(c ++ using macros, java using JetBrains MPS, etc.).  The closest analogue of this approach is the haskell error handling method. <br><a name="habracut"></a><br>  When designing a function, the way to deal with errors inside it depends on the intended method of use in case of an error.  There are two main ways: <br><ul><li>  The error leads to an incorrect state of the program and we must report it to the user as soon as possible and in detail.  Systems with this type of error handling have the fail-fast (FF) property. </li><li>  The error is a standard situation and will be processed automatically without user intervention.  Similar systems are fault-tolerant (FT) </li></ul><br>  Then I will use two abbreviations: the function designed for the fact that the external code will work with it in FT mode is the FT function and, similarly, the FF function. <br><br>  Why even allocate several ways to work with errors, and not use any one for all cases?  The fact is that the functions calculated on the FF used in the FT mode, as a rule, will result in the system working too slowly.  While functions designed for FT, used in FF mode will not provide enough information to quickly find errors by the user. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many examples of inconsistencies between goals and ways of use are generated by the standard function from JDK Integer.parseInt, which was explicitly designed for FF.  For example, if you are in a loop, you read lines from a stream and process only numbers, and skip the rest.  In this case, try {Integer.parseInt (...)} catch {...} can slow down your code several times.  A more detailed explanation and tests can be found here <a href="http://nadeausoftware.com/articles/2009/08/java_tip_how_parse_integers_quickly">nadeausoftware.com/articles/2009/08/java_tip_how_parse_integers_quickly</a> . <br><br>  FT functions should return error information in the most concise manner so as not to waste resources.  Most often it is either a boolean value or an error code of type int.  At the same time, if some fatal error has occurred, then the information on it should be passed to the user or to the log by the upstream FF function.  FT functions must be of a minimum size so that by the error code it can be understood where this error occurred. <br><br>  If you are writing a regular business or web application, i.e.  is, where the main role is played by an external user (and the vast majority of such applications are currently), and not the rover control system, then 99% of your code will be FF.  Those.  the user will be asked to enter correct data, and if some incorrect ones still skipped, then to fall with an error and require the developer to add more checks.  All error handling code will take up &lt;1% of computer time, even if its volume is large, unless you use the FF functions from the FT code.  Therefore, in the future, I would like to consider in more detail how to design FF functions and reduce the amount of code necessary for convenient error handling. <br><br>  Since  with the FF approach, our task is to minimize all current activities as quickly as possible and notify the user about the error, it is necessary to make the error message as informative as possible and it does not matter what resources are required for this, since  the bottleneck will still be the user or the programmer, who will eliminate this error altogether.  Those.  in this case, the error is an extraordinary situation and the system is not designed for a constant processing cycle for such an error with the maximum throughput. <br><br>  Here we need to dwell on the requirements that we can make to the error handling method: <br><ul><li>  The error should be described in sufficient detail for the user to understand the reason for its occurrence.  For example: division by zero. </li><li>  The user must understand where to look for this cause.  Those.  not only that this division by zero, but also in what field he introduced this zero.  In what form was this field and on which tab of our multipage application was this form. </li><li>  The error description for the user should not contain any informational garbage, such as tracing the call stack.  At least without clicking on the "more" button. </li><li>  Error information should be available, according to which the programmer can easily find the place of its occurrence, i.e.  most likely it is just a call stack. </li></ul><br>  Thus, our object describing the error should contain two principal parts: information for the user and information for the programmer. <br><br>  If we are talking, for example, about checking the format of a phone number in a browser, then it is quite simple to issue a relevant error message and even a programmer can usually understand without a call stack where to look for an error if the function starts to swear at the correct number.  This is because such a function is extremely small and almost directly related to the form field that it checks. <br><br>  However, consider this example.  There is a set of text files of one format, and the user wants to convert them in batch mode to a set of text files of another format.  At the same time, the formats are not fully compatible and require manual correction of some data.  However, the situation of the appearance of incorrect data is extremely rare (for example, once every six months) and therefore, at the current time, the application developer did not bother to create a corresponding replacement wizard within the application, but limited to displaying an error message. <br><br>  The implementation of this functionality can be represented by the function <br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertFiles</span></span></span></span>(files: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">File</span></span>]): <span class="hljs-type"><span class="hljs-type">Unit</span></span></code> </pre> <br>  Since  A full implementation can take several hundred or even thousands of lines, depending on the complexity of the formats, then the code should be broken down into a number of nested functions with minimal responsibility and maximum clarity (I mean pure functions).  Suppose we have the following functions. <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertFiles</span></span></span></span>(files: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">File</span></span>]): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertFile</span></span></span></span>(in: <span class="hljs-type"><span class="hljs-type">File</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertStream</span></span></span></span>(is: <span class="hljs-type"><span class="hljs-type">InputStream</span></span>, os: <span class="hljs-type"><span class="hljs-type">OutputStream</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertCity</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InCity</span></span>): <span class="hljs-type"><span class="hljs-type">OutCity</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPersons</span></span></span></span>(pl: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">InPerson</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">OutPerson</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertManager</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InManager</span></span>): <span class="hljs-type"><span class="hljs-type">OutManager</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertProgrammer</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InProgrammer</span></span>): <span class="hljs-type"><span class="hljs-type">OutProgrammer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPosition</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InPosition</span></span>): <span class="hljs-type"><span class="hljs-type">OutPosition</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOutdated</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">PosType</span></span>): <span class="hljs-type"><span class="hljs-type">Boolean</span></span></code> </pre><br>  The call tree might look like this: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertFiles</span></span></span></span>(files: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">File</span></span>]): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertFile</span></span></span></span>(in: <span class="hljs-type"><span class="hljs-type">File</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertStream</span></span></span></span>(is: <span class="hljs-type"><span class="hljs-type">InputStream</span></span>, os: <span class="hljs-type"><span class="hljs-type">OutputStream</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertCity</span></span></span></span>(c: <span class="hljs-type"><span class="hljs-type">InCity</span></span>): <span class="hljs-type"><span class="hljs-type">OutCity</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPersons</span></span></span></span>(pl: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">InPerson</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">OutPerson</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertManager</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InManager</span></span>): <span class="hljs-type"><span class="hljs-type">OutManager</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPosition</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InPosition</span></span>): <span class="hljs-type"><span class="hljs-type">OutPosition</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOutdated</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">PosType</span></span>): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertProgrammer</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InProgrammer</span></span>): <span class="hljs-type"><span class="hljs-type">OutProgrammer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPosition</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InPosition</span></span>): <span class="hljs-type"><span class="hljs-type">OutPosition</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOutdated</span></span></span></span>(f: <span class="hljs-type"><span class="hljs-type">PosType</span></span>): <span class="hljs-type"><span class="hljs-type">Boolean</span></span></code> </pre><br>  In our fictional example, some posts may become outdated and then the manager must manually, depending on certain personal considerations, correct an outdated post for one of the 10 new ones that came to replace her.  But as has been said, such posts are extremely rare. <br><br>  One way, especially common in the java-community, is to use exceptions to handle errors.  Suppose isOutdated returns false.  In this case, convertPosition cannot continue to work and throws an exception.  The code that calls convertFiles intercepts it and notifies the user of the incident, and also writes a call stack to the log (if the post is not outdated, the programmer will quickly find the source of the error). <br><br>  However, how bad is this method (at least in the current implementation in jvm)?  The convertPosition function does not know anything about the context in which it is executed, so all it can say about the error is that the position is outdated.  She does not know which person had this position, in which file and on which line to look for the error.  According to such an error message, the user will not understand at all what to do next. <br>  The situation can try to fix it in two ways. <br><br>  The first is to transfer context to all internal functions (i.e., an object containing a person, a file, etc.).  At the same time, the signatures of functions, the method of calling, the readability of the program as a whole will become more complicated, the coherence of functions between themselves will greatly increase.  In other words: do not be so. <br><br>  Second.  convertPosition throws an exception.  convertManager and convertProgrammer contain the code: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertManager</span></span></span></span>(el: <span class="hljs-type"><span class="hljs-type">InManager</span></span>): <span class="hljs-type"><span class="hljs-type">OutManager</span></span> = { ... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> position = convertPosition(el.position) ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">PositionException</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">PersonException</span></span>(<span class="hljs-string"><span class="hljs-string">s"    </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${p.name}</span></span></span><span class="hljs-string">"</span></span>, p, e) } ... }</code> </pre><br>  Those.  we intercept the exception that occurred in convertPosition, and instead we throw a new one with a modified message, additional information in the form of a person and an indication of the previous exception as the cause parameter of the new exception.  This procedure can be repeated at higher levels.  Thus, to the very top we will have an exception tree.  We can give the user a message composed of the messages of all our exceptions, so it will be clear in which file the error and in which line and what happened (i.e. the post is outdated).  The programmer will receive a trace in the log. <br><br>  What are the disadvantages of this approach?  First, we have to throw a lot of exceptions.  And although it is not a pity for resources especially for such a thing, a certain surplus in expenses is already felt here.  Secondly, the syntax is such that when an example becomes more complicated, you can dig into try ... catch.  For example, there may be an example, when in the next step we pass to the function the data obtained in the previous one.  Then we already have a set of nested try ... catch.  Handling a person might look like this: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InPerson</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, tel: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, addr: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Address</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Age</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutPerson</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, homeAdder: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Address</span></span></span></span><span class="hljs-class"><span class="hljs-params">, workAddr: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Address</span></span></span></span><span class="hljs-class"><span class="hljs-params">, distance: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">convertPerson</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">InPerson</span></span></span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">OutPerson</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = convertName(p.name) <span class="hljs-comment"><span class="hljs-comment">//     ,      0 val homeAddr = convertAddr(p.addr) val age = convertAge(p.age) try { val (id, wAddr) = db.query("select id, work_addr from persons where tel = ?", p.tel) val workAddr = addrFromStr(wAddr) val distance = calcDistance(homeAddr, workAddr) if (distance == 0) throw new PersonException(s",   ${p.name}   ", p, e) OutPerson(id, name, homeAddr, workAddr, distance) } catch { case e: NotFoundException =&gt; throw new PersonException(s"         ${p.tel}", p, e) } } catch { case e @ _: AddressException | _: AgeException =&gt; throw new PersonException(s"    ${p.name}", p, e) } }</span></span></code> </pre><br>  Nested try ... catch blocks significantly reduce readability of the code.  In addition, the error message is sometimes far enough away from the very place of the error.  All this is enough to try to find an alternative. <br><br>  I believe that exceptions in their current form should be used only for two purposes: <br>  1. To leave the current stack frame.  And for this, for good, there should be a more lightweight alternative, but it is not there now. <br>  2. In situations of 1 per million lines of code, when there is no more possibility to report an error.  For example, in the standard scala library there is an Option class with the get method, which returns a value only if we have a variable of the Option class in our variable - the Some class.  If there is a class None, then an exception occurs.  In this case, it is not possible to replace the result of get with Option [X], since  this will make the get call meaningless and we just have to throw an exception.  In the rest of the code, however, in a similar situation, we can replace our result X with Option [X] and do without exceptions. <br><br>  So what does the standard library scala, the library scalaz and haskell offer us?  There are many articles on the Internet on this topic, and the topic itself is not so new.  Therefore, retelling these articles, it seems to me, is not worth it.  The essence of them comes down to the use of existing monads. <br><br>  For example, an article about the capabilities of the standard library. <br>  <a href="https://tersesystems.com/2012/12/27/error-handling-in-scala/">tersesystems.com/2012/12/27/error-handling-in-scala</a> <br>  suggests us to use Option, Either and Try.  But it all works on fairly simple examples.  If, when rewriting convertPerson, we need to use a condition in the middle, like if (distance == 0) ..., then this situation will require splitting one common for into two, which will immediately create code no less than using try ... catch.  And if our function returning Either or Try is called from a foreach, map or fold loop, then the only way to interrupt the loop is to use scala.util.control.Breaks and a variable at a higher level if you need to pass some value to the top. . <br><br>  Scalaz, with his \ /, - \ / and \ / - in fact almost does not change the situation <br>  <a href="http://typelevel.org/blog/2014/02/21/error-handling.html">typelevel.org/blog/2014/02/21/error-handling.html</a> <br>  Well, or I do not understand something about it and I will be glad to hear about it in the comments. <br><br>  In addition, the structures described either do not track the call stack, or do not allow to specify error messages, or all at once. <br><br>  The haskell uses the Error monad, which is very similar to Try and \ /, - \ /, \ / -. <br>  <a href="http://book.realworldhaskell.org/read/error-handling.html">book.realworldhaskell.org/read/error-handling.html</a> <br>  But there are not many of the problems that arise in scala because of the other device of the code itself and the standard library.  Therefore, there this approach can be considered quite working, although it also has a number of drawbacks. <br><br><h4>  My bike </h4><br>  I tried to take the best of both approaches (exceptions and monads) and eliminate, if possible, flaws.  The result can be seen here. <br>  <a href="https://github.com/cs0ip/habr-error-handling/">github.com/cs0ip/habr-error-handling</a> <br>  For further reading, you need to look into the code so that I do not have to give all its description here.  It is better to take this code not as a ready-made library, although I use it in my development, but rather as an implementation of an idea that can be developed.  In class names, abbreviations are used first for brevity, second for reducing the possibility of intersection with already existing names, which as a rule do not use abbreviations (at least for me). <br><br>  I used 4 entities.  Res is a class similar to Try.  His descendants Ok and Err, corresponding to the correct result and error.  As well as the Exit class, which serves to interrupt loops and pass values ‚Äã‚Äãup the stack.  Exit is similar to scala.util.control.Breaks.  To all this, methods have been added that make life bearable when using code that does not support Res.  So, for example, Res can be created from Option, Either, Try, and even Boolean, which makes it possible to insert into for statements if able to interrupt execution and not related to the previous expression.  In addition, it is possible to easily handle code that throws exceptions using the safe function, without having to wrap it in Try. <br><br>  Suppose that all functions written by us now support Res, then convertPerson can be rewritten as follows: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPerson</span></span></span></span>(p: <span class="hljs-type"><span class="hljs-type">InPerson</span></span>): <span class="hljs-type"><span class="hljs-type">Res</span></span>[<span class="hljs-type"><span class="hljs-type">OutPerson</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- convertName(p.name) homeAddr &lt;- convertAddr(p.addr) age &lt;- convertAge(p.age) (id, wAddr) &lt;- <span class="hljs-type"><span class="hljs-type">Res</span></span>.safe(db.query(<span class="hljs-string"><span class="hljs-string">"select id, work_addr from persons where tel = ?"</span></span>, p.tel)) mapErr { e =&gt; e.ex.get <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _: <span class="hljs-type"><span class="hljs-type">NotFoundException</span></span> =&gt; e.replace(<span class="hljs-string"><span class="hljs-string">s"         </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${p.tel}</span></span></span><span class="hljs-string">"</span></span>) }} workAddr &lt;- addrFromStr(wAddr) distance &lt;- calcDistance(homeAddr, workAddr) _ &lt;- <span class="hljs-type"><span class="hljs-type">Res</span></span>(distance != <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">s",   </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${p.name}</span></span></span><span class="hljs-string">   "</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">OutPerson</span></span>(id, name, homeAddr, workAddr, distance) res.mapErr(e =&gt; e.push(<span class="hljs-string"><span class="hljs-string">s"    </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${p.name}</span></span></span><span class="hljs-string">"</span></span>)) }</code> </pre><br>  Err stores the value of the Option [Throwable] type, which firstly allows you to track the call stack, and secondly, you can refuse to create an exception in general, where you need to improve performance.  In addition, Err stores a list of error messages and allows you to easily replace the last message and add a new one.  It should also be noted that Err is completely persistent, which excludes the possibility of accidental modification of data. <br><br>  An example of using Exit might look like this: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertPersons</span></span></span></span>(pl: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">InPerson</span></span>]): <span class="hljs-type"><span class="hljs-type">Res</span></span>[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">OutPerson</span></span>]] = exitRes[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">OutPerson</span></span>]]{ex =&gt; <span class="hljs-type"><span class="hljs-type">Ok</span></span>(pl.foldLeft(<span class="hljs-type"><span class="hljs-type">Nil</span></span>){<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (z, p) =&gt; (p <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> p: <span class="hljs-type"><span class="hljs-type">InManager</span></span> =&gt; convertManager(p) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> p: <span class="hljs-type"><span class="hljs-type">InProgrammer</span></span> =&gt; convertProgrammer(p) }) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Ok</span></span>(out) =&gt; out :: z <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">Err</span></span> =&gt; ex.go(e) } }) }</code> </pre><br>  exitRes [X] expects to get a value of type Res [X].  Unfortunately, when using exitRes (and exit), you always need to specify the type of the received value, since  the compiler cannot output it.  Theoretically, type inference can be done using macros, but as long as they are unstable, I do not want to use them. <br><br>  I would also like to mention a couple of points.  If you are writing a library for public use, then perhaps you want to specify your type for each error, as can be done with exceptions (InputException, NullPointerException, etc.).  Err allows both to indicate the type of error with the help of the Throwable contained in it, and with the help of each element from the lst message list.  Those.  you can create your successors Err.Er.  In addition, I would like to note that thanks to the implicit convertion from String to Err.Er, strings can be used everywhere where the signature implies Err.Er. <br><br>  If you are writing your application, and not a public api, then most often in fail-fast mode you do not care about the type of error, but what is important is the message about it to the user and the location for the opportunity to be corrected.  In this case, in the examples above, you can omit all checks of the type "case _: NotFoundException" and the code will become even more compact. <br><br><h4>  Java and other languages </h4><br>  In most languages, it is possible to implement a certain monadic entity, like the one described by Res.  The problem arises from the fact that all the power of Res is revealed mainly within the for statement for scala or do for haskell.  Those.  need to implement a similar statement.  In principle, using the tools mentioned at the beginning of the article, it seems to me possible.  A description of the most for ... yield can be found here <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html">docs.scala-lang.org/tutorials/FAQ/yield.html</a> <br><br><h4>  Pros / Cons </h4><br>  The advantages of this approach compared to pure exception handling: <br><ul><li>  Better error control; </li><li>  the ability to edit and supplement messages in the parent functions; </li><li>  less waste of resources on exceptions: only one exception is used to indicate a position, and a lightweight exception without a stack of calls is used to climb a stack; </li><li>  sometimes a significant decrease in the amount of code; </li></ul><br>  Pluses in comparison with the methods using monads by links (Try, \ /, ...): <br><ul><li>  The data approach works where the methods indicated in the articles require improvement and are simply not applicable. </li></ul><br>  Disadvantages compared to pure exception handling: <br><ul><li>  Much of the code should be located in for, which makes it look somewhat unusual, although you can get used to it. </li><li>  It can be difficult to design from top to bottom.  Those.  when for the stack of function calls, only the signature without implementation is described, and the main efforts are made to this function without the need to be distracted by the details.  The problem may arise due to the fact that some functions should not return errors in general and, accordingly, should not return Res.  As a result, the function signature is not always immediately clear. </li></ul><br><br><h4>  Total </h4><br>  What I would like to say in conclusion.  This approach still has drawbacks that you might not be able to fix without the support of the language.  Sometime in the distant and beautiful future, I would like to see a language with support for lightweight constructs for passing values ‚Äã‚Äãup the stack.  With the ability to track the current line of code and at the same time do not spend resources on getting a stack of calls until the very moment when it will need to be displayed in the log.  And most importantly, I would like to be able to describe the correct result and error independently, always explicitly and while processing, not to drown in constructions like try ... catch, but also not to modify the code to use monads.  I believe that this is possible, and even have some thoughts on how, but as always there is no time to implement such things.  However, it is good that any ideas usually come to the heads of different people independently and in parallel, so one can hope that someday error handling will reach a new level. </div><p>Source: <a href="https://habr.com/ru/post/262971/">https://habr.com/ru/post/262971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262953/index.html">Creating plug-ins for AutoCAD using the .NET API (part 6 - finding and changing objects in a drawing)</a></li>
<li><a href="../262957/index.html">The magic of tensor algebra: Part 10 - Get the angular velocity vector. We work on the shortcomings</a></li>
<li><a href="../262963/index.html">Emmett Shire: How to conduct interviews with users</a></li>
<li><a href="../262967/index.html">As we built the constructor of Telegram bots in 24 hours, and then threw half of them and rewrote</a></li>
<li><a href="../262969/index.html">Results of the Summer Hola JS Programming Contest</a></li>
<li><a href="../262977/index.html">Message broker for ZMQ-based service architecture - or developer‚Äôs leisure</a></li>
<li><a href="../262979/index.html">The subtleties of working with PassportJs</a></li>
<li><a href="../262983/index.html">Personal web server on Wolfram Language</a></li>
<li><a href="../262987/index.html">Adding bidirectional support to your own Textbox</a></li>
<li><a href="../262991/index.html">Using morph.io for web parsing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>