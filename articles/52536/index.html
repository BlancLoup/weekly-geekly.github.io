<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with databases in Qt in a multithreaded environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All those who develop applications on Qt, sooner or later face the work with the database in a multithreaded environment. And if you do not read the A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with databases in Qt in a multithreaded environment</h1><div class="post__text post__text-html js-mediator-article">  All those who develop applications on Qt, sooner or later face the work with the database in a multithreaded environment.  And if you do not read the Assistant carefully, then you may come across some very interesting rakes. <br><a name="habracut"></a><br><h2>  Description of the environment </h2><br>  Consider a typical problem.  You write an application that works with the database, while you need to access the database from several threads (it does not matter at the same time or not).  For example, this happens if you write the server part of a certain application, or you simply have a logging thread with a record in the database. <br><br><h2>  Rake </h2><br><h4>  Rake description </h4><br>  If we carefully read the assistant (that is, not only the description of classes, but also general articles), we will see the following inscription in the description of multi-threaded programming under Qt: ‚ÄúA connection can only be used by the thread that created it.  At the same time, transferring the connection itself or using requests from other streams is not supported ‚Äù(loose translation). <br><br><h4>  Explanation of the rake </h4><br>  Thus, the banal mutex we have planned to connect to the database unfortunately will not work.  Also (if we don‚Äôt need to divide the connection between several threads all the time, and in the first half of the program‚Äôs work, one thread should use it, and then the other) and the moveToThread () method will not work well, for example, when working with sockets. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Attempt to reflect on the problem </h2><br>  Ok, we cannot share one connection between multiple threads.  But how can we get around this problem?  I see two ways: <br><ol><li>  Do not bathe and make your connection in each stream </li><li>  Refer to the good old pattern Singleton </li></ol><br>  Well, the first option is too simple and is not suitable for the option when threads are created, they do something with the database and almost immediately die (there will be an extra person overhead for a connection).  Although for some cases the first option is ideal;) <br>  So the second way. <br><br><h2>  A bit of theory about the pattern </h2><br>  The Singleton pattern implies that we can have only one object of a certain class, and any treatment will execute code within this object.  Further in the article we will slightly deviate from the canonical form of this pattern, but more on that later. <br><br><h2>  Singleton implementation in C ++ </h2><br>  To implement this pattern, we must prohibit the following for the class: <br><ol><li>  Creating a new object </li><li>  Create a copy of the object </li><li>  Object assignment operation </li></ol><br>  We must also give the opportunity to get this very single instance of the class. <br>  The class is called DatabaseAccessor.  We write the minimal implementation of a singleton. <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//databaseaccessor.h</font> <br> <br> <font color="#0000ff">class</font> DatabaseAccessor <br> { <br> <font color="#0000ff">public</font> : <br> <font color="#0000ff">static</font> DatabaseAccessor* getInstance(); <br> <br> <font color="#0000ff">private</font> : <br> DatabaseAccessor(); <br> DatabaseAccessor( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> DatabaseAccessor&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> }; <br> <br> <font color="#008000">//databaseaccessor.cpp</font> <br> <br> DatabaseAccessor::DatabaseAccessor() <br> { <br> } <br> <br> DatabaseAccessor* DatabaseAccessor::getInstance() <br> { <br> <font color="#0000ff">static</font> DatabaseAccessor instance; <br> <font color="#0000ff">return</font> &amp;instance; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  That is, we simply create an object and return it when we first access DatabaseAccessor :: getInstance ().  Later we return the same object. <br><br><h2>  Add a connection to the database </h2><br>  Well, everything is simple, we add a connection to the database to the constructor. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//databaseaccessor.h</font> <br> <br> <font color="#0000ff">class</font> DatabaseAccessor <br> { <br> <font color="#0000ff">public</font> : <br> <font color="#0000ff">static</font> DatabaseAccessor* getInstance(); <br> <font color="#0000ff">static</font> QString dbHost; <br> <font color="#0000ff">static</font> QString dbName; <br> <font color="#0000ff">static</font> QString dbUser; <br> <font color="#0000ff">static</font> QString dbPass; <br> <font color="#0000ff">private</font> : <br> <br> DatabaseAccessor(); <br> DatabaseAccessor( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> DatabaseAccessor&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> QSqlDatabase db; <br> }; <br> <br> <font color="#008000">//databaseaccessor.cpp</font> <br> <br> DatabaseAccessor::DatabaseAccessor() <br> { <br> <br> db = QSqlDatabase::addDatabase( <font color="#A31515">"QMYSQL"</font> ); <br> db.setHostName(dbHost); <br> db.setDatabaseName(dbName); <br> db.setUserName(dbUser); <br> db.setPassword(dbPass); <br> <font color="#0000ff">if</font> (db.open()) <br> { <br> qDebug( <font color="#A31515">"connected to database"</font> ); <br> } <br> <font color="#0000ff">else</font> <br> { <br> qDebug( <font color="#A31515">"Error occured in connection to database"</font> ); <br> } <br> } <br> <br> DatabaseAccessor* DatabaseAccessor::getInstance() <br> { <br> <font color="#0000ff">static</font> DatabaseAccessor instance; <br> <font color="#0000ff">return</font> &amp;instance; <br> } <br> <br> <font color="#008000">//main.cpp</font> <br> <br> <font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> *argv[]) <br> { <br> <font color="#008000">//...</font> <br> DatabaseAccessor::dbHost = <font color="#A31515">"localhost"</font> ; <br> DatabaseAccessor::dbName = <font color="#A31515">"our_db"</font> ; <br> DatabaseAccessor::dbUser = <font color="#A31515">"root"</font> ; <br> DatabaseAccessor::dbPass = <font color="#A31515">""</font> ; <br> DatabaseAccessor::getInstance(); <br> <font color="#008000">//...</font> <br> <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  When the program was initialized, we simply registered the necessary data for access to the database and created a connection object to the database. <br><br><h2>  So, what is next? </h2><br>  Now we need to give the opportunity to work with this database.  To begin with, we will implement the possibility of a simple query without receiving the data back (update, deletion, insertion without the need to know the new id). <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//databaseaccessor.h</font> <br> <br> <font color="#0000ff">class</font> DatabaseAccessor <br> { <br> <font color="#0000ff">public</font> : <br> <font color="#0000ff">static</font> DatabaseAccessor* getInstance(); <br> <font color="#0000ff">static</font> QString dbHost; <br> <font color="#0000ff">static</font> QString dbName; <br> <font color="#0000ff">static</font> QString dbUser; <br> <font color="#0000ff">static</font> QString dbPass; <br> <br> <font color="#0000ff">public</font> slots: <br> <font color="#0000ff">void</font> executeSqlQuery(QString); <br> <br> <font color="#0000ff">private</font> : <br> <br> DatabaseAccessor(); <br> DatabaseAccessor( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> DatabaseAccessor&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> QSqlDatabase db; <br> }; <br> <br> <font color="#008000">//databaseaccessor.cpp</font> <br> <br> DatabaseAccessor::DatabaseAccessor() <br> { <br> <br> db = QSqlDatabase::addDatabase( <font color="#A31515">"QMYSQL"</font> ); <br> db.setHostName(dbHost); <br> db.setDatabaseName(dbName); <br> db.setUserName(dbUser); <br> db.setPassword(dbPass); <br> <font color="#0000ff">if</font> (db.open()) <br> { <br> qDebug( <font color="#A31515">"connected to database"</font> ); <br> } <br> <font color="#0000ff">else</font> <br> { <br> qDebug( <font color="#A31515">"Error occured in connection to database"</font> ); <br> } <br> } <br> <br> DatabaseAccessor* DatabaseAccessor::getInstance() <br> { <br> <font color="#0000ff">static</font> DatabaseAccessor instance; <br> <font color="#0000ff">return</font> &amp;instance; <br> } <br> <br> <font color="#0000ff">void</font> DatabaseAccessor::executeSqlQuery(QString query) <br> { <br> QSqlQuery sqlQuery(query, db); <br> } <br> <br> <font color="#008000">//ourthread.h</font> <br> <br> <font color="#0000ff">class</font> OurThread : <font color="#0000ff">public</font> QThread <br> { <br> Q_OBJECT <br> <font color="#008000">//...</font> <br> signals: <br> <font color="#0000ff">void</font> executeSqlQuery(QString); <br> <font color="#008000">//...</font> <br> } <br> <br> <font color="#008000">//ourthread.cpp</font> <br> <br> OurThread::OurThread() <br> { <br> connect( <font color="#0000ff">this</font> , SIGNAL(executeSqlQuery(QString)), DatabaseAccessor::getInstance(), SLOT(executeSqlQuery(QString))); <br> } <br> <br> <font color="#0000ff">void</font> OurThread::run() <br> { <br> <font color="#0000ff">emit</font> executeSqlQuery( <font color="#A31515">"DELETE FROM users WHERE uid=5"</font> ); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Here we create a public slot in our singleton that accepts a query string and sends it to the database.  In a typical flow, we create a signal and connect it to a singleton slot.  When starting the stream, we send a request to delete the user with id 5. <br><br><h2>  But how to get the result of the query? </h2><br>  First, we need to first decide what we want from our singleton.  Either we want it to perform a large number of various queries (similar to the usual class for working with the database), or we have a certain set of typical queries that we need to perform.  In the second option, we can transfer all validation to our singleton and thereby reduce the amount of code in the project;) According to the old tradition, we will implement the second option;) Add a method that will check the user's login / password. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//databaseaccessor.h</font> <br> <br> <font color="#0000ff">class</font> DatabaseAccessor <br> { <br> <font color="#0000ff">public</font> : <br> <font color="#0000ff">static</font> DatabaseAccessor* getInstance(); <br> <font color="#0000ff">static</font> QString dbHost; <br> <font color="#0000ff">static</font> QString dbName; <br> <font color="#0000ff">static</font> QString dbUser; <br> <font color="#0000ff">static</font> QString dbPass; <br> <br> <font color="#0000ff">public</font> slots: <br> <font color="#0000ff">void</font> executeSqlQuery(QString); <br> <font color="#0000ff">void</font> validateUser(QString, QString); <br> <br> <font color="#0000ff">private</font> : <br> <br> DatabaseAccessor(); <br> DatabaseAccessor( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> DatabaseAccessor&amp; <font color="#0000ff">operator</font> =( <font color="#0000ff">const</font> DatabaseAccessor&amp; ); <br> QSqlDatabase db; <br> }; <br> <br> <font color="#008000">//databaseaccessor.cpp</font> <br> <br> DatabaseAccessor::DatabaseAccessor() <br> { <br> <br> db = QSqlDatabase::addDatabase( <font color="#A31515">"QMYSQL"</font> ); <br> db.setHostName(dbHost); <br> db.setDatabaseName(dbName); <br> db.setUserName(dbUser); <br> db.setPassword(dbPass); <br> <font color="#0000ff">if</font> (db.open()) <br> { <br> qDebug( <font color="#A31515">"connected to database"</font> ); <br> } <br> <font color="#0000ff">else</font> <br> { <br> qDebug( <font color="#A31515">"Error occured in connection to database"</font> ); <br> } <br> } <br> <br> DatabaseAccessor* DatabaseAccessor::getInstance() <br> { <br> <font color="#0000ff">static</font> DatabaseAccessor instance; <br> <font color="#0000ff">return</font> &amp;instance; <br> } <br> <br> <font color="#0000ff">void</font> DatabaseAccessor::executeSqlQuery(QString query) <br> { <br> QSqlQuery sqlQuery(query, db); <br> } <br> <br> <font color="#0000ff">void</font> DatabaseAccessor::validateUser(QString login, QString pass) <br> { <br> login.remove(QRegExp( <font color="#A31515">"['\"]"</font> )); <br> pass.remove(QRegExp( <font color="#A31515">"['\"]"</font> )); <br> QString query = <font color="#A31515">"SELECT IFNULL(uid, -1) as user_id FROM users WHERE username='"</font> +login+ <font color="#A31515">"' AND password='"</font> +pass+ <font color="#A31515">"'"</font> ; <br> QSqlQuery sqlQuery(query, db); <br> <font color="#0000ff">if</font> (sqlQuery.first()) <br> { <br> <font color="#0000ff">long</font> userId = sqlQuery. <font color="#0000ff">value</font> (0).toInt(); <br> QMetaObject::invokeMethod(sender(), <font color="#A31515">"setUserId"</font> , Qt::DirectConnection, Q_ARG( <font color="#0000ff">long</font> , userId)); <br> } <br> <font color="#0000ff">else</font> <br> { <br> QMetaObject::invokeMethod(sender(), <font color="#A31515">"setUserId"</font> , Qt::DirectConnection, Q_ARG( <font color="#0000ff">long</font> , -1)); <br> } <br> } <br> <br> <font color="#008000">//ourthread.h</font> <br> <br> <font color="#0000ff">class</font> OurThread : <font color="#0000ff">public</font> QThread <br> { <br> Q_OBJECT <br> <font color="#008000">//...</font> <br> signals: <br> <font color="#0000ff">void</font> executeSqlQuery(QString); <br> <font color="#0000ff">void</font> validateUser(QString, QString); <br> <br> <font color="#0000ff">public</font> slots: <br> <font color="#0000ff">void</font> setUserId( <font color="#0000ff">long</font> ); <br> <br> <font color="#0000ff">private</font> : <br> <font color="#0000ff">bool</font> lastResultQueryIsReallyLast; <br> <font color="#0000ff">long</font> userId; <br> <font color="#0000ff">bool</font> checkUser( <font color="#0000ff">const</font> <font color="#0000ff">char</font> *, <font color="#0000ff">const</font> <font color="#0000ff">char</font> *); <br> <br> <font color="#008000">//...</font> <br> } <br> <br> <font color="#008000">//ourthread.cpp</font> <br> <br> OurThread::OurThread() <br> { <br> lastResultQueryIsReallyLast = <font color="#0000ff">false</font> ; <br> connect( <font color="#0000ff">this</font> , SIGNAL(validateUser(QString,QString)), DatabaseAccessor::getInstance(), SLOT(validateUser(QString,QString)), Qt::BlockingQueuedConnection); <br> connect( <font color="#0000ff">this</font> , SIGNAL(executeSqlQuery(QString)), DatabaseAccessor::getInstance(), SLOT(executeSqlQuery(QString))); <br> } <br> <br> <font color="#0000ff">void</font> OurThread::run() <br> { <br> checkUser( <font color="#A31515">"user"</font> , <font color="#A31515">"password"</font> ); <br> } <br> <br> <font color="#0000ff">bool</font> OurThread::checkUser( <font color="#0000ff">const</font> <font color="#0000ff">char</font> * login, <font color="#0000ff">const</font> <font color="#0000ff">char</font> * pass) <br> { <br> emit validateUser(login, pass); <br> <font color="#0000ff">while</font> (!lastResultQueryIsReallyLast) <br> { <br> msleep(1); <br> } <br> lastResultQueryIsReallyLast = <font color="#0000ff">false</font> ; <br> <font color="#0000ff">return</font> (userId &gt; 0); <br> } <br> <br> <font color="#0000ff">void</font> OurThread::setUserId( <font color="#0000ff">long</font> userId) <br> { <br> <font color="#0000ff">this</font> -&gt;userId = userId; <br> lastResultQueryIsReallyLast = <font color="#0000ff">true</font> ; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Here we added another slot to our singleton, which takes 2 parameters (username and password).  Also in our stream we connected it to the signal in the ‚Äúqueue with blocking‚Äù mode (that is, the slot will run in the context of the stream with a singleton, but our stream will wait until the signal reaches the addressee).  We also added a slot to our stream that accepts the found user id.  At the start, the thread emits a signal to check the user and waits until the answer comes (the variable lastResultQueryIsReallyLast is responsible for this).  Naturally, Singleton does not know all its user threads, so the invokeMethod () method is used to call the method on the object that sender () returns (this is the method that returns the sender of the signal if we are in the slot).  Moreover, the sender method is called directly in order not to wait for the next pass of the event cycle. <br>  In principle, the first method (when we do more general methods of accessing the database) is easily obtained from the second.  It is just necessary in the singleton method to bypass all the rows returned by the database and stuff them into some QList, which is returned to the sender of the request. <br><br><h2>  Finally </h2><br>  Principle, it turned out not difficult and quite nice. <br>  Plus, we have the ability to break into several connections (remember, I talked about the retreat from the pattern).  In this case, we need to slightly rewrite the method of obtaining the instance (we need to add balancing on several instances and return the least busy plus, of course, remember who took what instance), you also need to add the connection name to the database creation (for example, you can generate the name of the first object access to this instance) and add a method that will return the desired connection name based on the sender of the request. <br></div><p>Source: <a href="https://habr.com/ru/post/52536/">https://habr.com/ru/post/52536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../52531/index.html">About operators</a></li>
<li><a href="../52532/index.html">Proper use of AUTOLOAD</a></li>
<li><a href="../52533/index.html">Netscape founder on Twitter, startups and more [2]</a></li>
<li><a href="../52534/index.html">Good topic or concept habrafutbolok</a></li>
<li><a href="../52535/index.html">Crisis idleness developer</a></li>
<li><a href="../52537/index.html">Where to put the old iron</a></li>
<li><a href="../52538/index.html">Triangle Time ‚Äî Nerves ‚Äî Money for simple planning and evaluation of personal resources.</a></li>
<li><a href="../52539/index.html">qpimg - dynamic creation of CSS sprites</a></li>
<li><a href="../52540/index.html">Free computers</a></li>
<li><a href="../52541/index.html">A new (working!) Version of the plug-in Idea-android (0.3) has been released.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>