<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thoughts on modern C ++ and game development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The new year for game developers began with a wave of criticism that struck the C ++ Standardization Committee after the publication of Aras Prankevic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thoughts on modern C ++ and game development</h1><div class="post__text post__text-html js-mediator-article">  <i>The new year for game developers began with a wave of criticism that struck the C ++ Standardization Committee after the <a href="http://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/">publication of Aras Prankevichus ‚ÄúComplaints about modern C ++‚Äù</a> .</i>  <i>There was a serious question: did the standards committee really lose touch with reality, or is it the other way around, and these game developers have split off from the rest of the C ++ community?</i> <i><br><br></i>  <i>We offer you a translation of Ben Dean's <a href="https://twitter.com/ben_deane/status/1080249110303666176">popular post</a> , a <a href="https://www.linkedin.com/in/elbeno/">veteran of the gaming industry</a> who has worked for a long time at Blizzard, Electronic Arts and Bullfrog as a C ++ developer and team leader, in which he responds to criticism from the perspective of his own experience.</i> <br><blockquote>  TL; DR: The C ++ Standardization Committee does not have a hidden goal to ignore the needs of game developers, and ‚Äúmodern‚Äù C ++ is not going to become an ‚Äúnon-debugable‚Äù language. </blockquote>  Throughout last week <a href="https://twitter.com/meetingcpp/status/1078732469350944770">, Twitter</a> was <a href="https://twitter.com/aras_p/status/1078682464602726400">actively debated</a> , during which many programmers - especially those who work in the field of game development - said that the current vector of development of "modern C ++" <a href="https://twitter.com/gafferongames/status/1076689358067982336">does not meet their needs</a> .  In particular, from the standpoint of a regular game developer, it looks as if the debugging performance in the language is ignored, and code optimization becomes expected and necessary. <br><br>  Due to the fact that in 2019 I had been working in the gaming industry for more than 23 years, I have my own opinion based on observations on this topic in relation to game development, which I would like to share.  Is "debugging" important for game developers and why?  What are the issues related to it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a start - a small excursion into history. <br><a name="habracut"></a><br>  Many game developers who write in C ++ work in Microsoft Visual C ++.  Historically, around the Microsoft platforms, a huge market for games has formed, and this is reflected in the typical experience of the average game programmer.  In the 90s and 2000s, most games were written in the light of these circumstances.  Even with the advent of consoles from other manufacturers and the increasing popularity of mobile gaming, the wealth of many AAA studios and numerous game programmers today are tools made by Microsoft. <br><br>  Visual Studio is arguably the best debugger for C ++ in the world.  And most of all, Visual Studio really stands out in terms of debugging programs ‚Äî more than with its front-end, back-end, STL implementation, or anything else.  In the past five years, Microsoft has made great strides in developing C ++ development tools, but even before these achievements, the debugger in Visual Studio has always been very cool.  So when you are developing on a Windows PC, you have a world-class debugger at hand. <br><br>  Considering the above, let's consider the process of obtaining a code in which there will be no bugs;  the possibilities we have from the point of view of a programmer who does not play games;  and the limitations that game developers face.  If we rephrase the main argument in favor of the ‚Äúvector of development of modern C ++‚Äù, then it will be reduced to types, tools and tests.  Following this thought, the debugger should be the <a href="https://twitter.com/PeterSommerlad/status/1078958027175329793">last line of defense</a> .  Before we reach it, we have the following options. <br><br><h3>  Option # 1: Types </h3><br>  We can use as much typing as needed to eliminate whole classes of bugs during compilation.  Strong typing is, without a doubt, an opportunity that the recent evolution of C ++ has given us;  for example, starting with C ++ 11, we managed to get: <br><br><ul><li> significant expansion of <code><a href="https://en.cppreference.com/w/cpp/header/type_traits">type traits</a></code> ; </li><li>  innovations such as <code>nullptr</code> and <code>scoped enum</code> to combat the legacy of C - weak typing; </li><li>  <a href="https://github.com/Microsoft/GSL">GSL</a> and auxiliary tools; </li><li>  <a href="https://en.cppreference.com/w/cpp/concepts">concepts</a> in C ++ 20. </li></ul><br>  Some of you may not like template metaprogramming;  others may not like the way they write code, in which <code>auto</code> used almost everywhere.  Regardless of these preferences, the main motive for using the listed styles in C ++ is clearly visible here - this is the desire to help the compiler so that he, in turn, can help us, using what he knows best: a type system. <br><br>  If we talk about game programming, strong typing here is a wide field for research, and it is actively used by game programmers I know who are interested in improving their C ++ skills in practice.  There are two important things of concern here: the effect on compile time, and the effect on code readability. <br><br>  Frankly, you can easily ignore the compilation time - but only if you are a programmer in a very large company that does not play games and has a well-established internal infrastructure and endless computing power to compile any code you can write .  Such huge companies are concerned about the cost of compilation - therefore they use modules - but, as a rule, this does not cause pain to individual developers.  At the same time, for most game programmers, this is not at all the case.  Indie developers don't have farms to build builds;  AAA games developers often use something like <a href="https://www.incredibuild.com/">Incredibuild</a> , but given the fact that they can easily work with a code base that has turned 10 years or more, the build process can still take 15-20 minutes. <br><br>  We can argue about the relative cost of adding ‚Äúhardware‚Äù versus the time cost of a programmer, and I agree with the position that hardware costs less, however: <br><br><ul><li>  The hardware is the real one-time expenses that will be borne by the budget of the current quarter, as opposed to not so tangible expenses in time / hiring / and the like, which will be distributed over a longer period of time.  People do not cope well with the decision in favor of such a compromise, and companies are specially built to optimize short-term profit. </li><li>  Infrastructure requires support, and almost no one goes into the gaming industry in order to become a release engineer.  Compared to other areas where C ++ is used, the salary of game developers is not so high - and non-game engineers are paid even less. </li></ul><br>  You can also speculate on the fact that the compile time should never have reached such a state;  and again I agree with you.  The price of this is in constant vigilance - outgoing, again, from the release engineer - and, ideally, some automated tool that allows you to track changes over time required to build the build.  Fortunately, due to the emergence of CI-systems, this goal today can be achieved much easier. <br><br><h3>  Option # 2: Tools </h3><br>  We must use the maximum of tools available to us ‚Äî warnings, static analysis, sanitizers, dynamic analysis tools, profilers, and others. <br><br>  My experience says that game developers use these tools where it is possible, but here the industry as a whole has several problems: <br><br><ul><li>  These tools tend to work better on <a href="http://www.valgrind.org/info/platforms.html">non-Microsoft</a> platforms ‚Äî and, as mentioned earlier, this is not a typical scenario in game development. </li><li>  Most of these tools are designed to work with ‚Äústandard‚Äù C ++.  Out-of-the-box, they support <code>std::vector</code> , but not my self- <code>CStaticVector</code> class <code>CStaticVector</code> from a hypothetical engine.  Of course, blaming the tools for this is useless, but it is still one of the barriers to their use that developers have to overcome. </li><li>  Creating and maintaining a CI chain that will launch all of these tools requires the presence of release engineers ‚Äî and, as mentioned earlier, hiring people for engineering jobs that are not directly related to games is a systemic problem for the gaming industry. </li></ul><br>  So, since these tools work so well with standard C ++, then why don't game developers use STL? <br><br>  How to start the answer to this question?  Perhaps, from the next excursion into the history of game development: <br><br><ul><li>  Until the early 90s, we did not trust the C compilers, so we wrote games in assembly language. </li><li>  From the beginning to the mid-90s, we began to trust the C compilers, but we still did not trust the C ++ compilers.  Our code was C, which used C ++ style comments, and we no longer needed to write typedefs for our structures all the time. </li><li>  Around 2000, the C ++ revolution took place in the game development world.  It was the era <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">of design patterns</a> and <a href="https://www.java.com/">large class hierarchies</a> .  At that time, support for STL on consoles left much to be desired, and the world was then ruled by consoles.  On PS2, we are forever stuck with GCC 2.95. </li><li>  Around 2010, two more revolutions are being undertaken.  The pain of using large class hierarchies has stimulated the development of a component code approach.  This change continues its evolution today in the form of Entity-Component-System architectures.  Hand in hand with this was the second revolution - an attempt to take advantage of multiprocessor architectures. </li></ul><br>  In the course of these paradigm shifts, the gaming development platforms themselves were constantly changing, and moreover they changed seriously.  Segmented memory has given way to a flat address space.  Platforms have become multiprocessor, symmetric and not very.  Game developers, accustomed to working with Intel architectures, had to get used to MIPS (Playstation), then to a special ‚Äúhardware‚Äù with heterogeneous CPU (PS2), then to PowerPC (XBox 360), then to even greater heterogeneity (PS3) ... Each New platform came new performance for processors, memory and disks.  If you wanted to achieve optimal performance, then you had to rewrite your old code, a lot and often.  I‚Äôm not even going to mention how much the games were influenced by the emergence and growth of the Internet, as well as the limitations that platform holders put on developers. <br><br>  Historically, STL implementations on gaming platforms have been unsatisfactory.  It is not a secret that STL-containers are poorly suited for gaming.  If you press the game developer to the wall, then perhaps he admits that <code>std::string</code> is quite OK, and <code>std::vector</code> is a reasonable default option.  But all the containers contained in the STL have a problem of controlling allocation and initialization.  In many games, you have to worry about the limitation of memory for various tasks - and for those objects, the memory for which you will most likely have to allocate dynamically during gameplay, <a href="https://ru.wikipedia.org/wiki/Slab"><i>slab</i></a> or <i>arena</i> allocators are often used.  <a href="https://en.cppreference.com/w/cpp/container/vector/push_back">Amortized constant time</a> is not a good enough result, since allocation is potentially one of the most ‚Äúexpensive‚Äù things that can happen during program execution, and I don‚Äôt want to miss a frame just because it happened when I didn‚Äôt expect it .  I, as a game developer, have to manage my memory requirements in advance. <br><br>  A similar story is obtained for other dependencies in general.  Game developers want to know what takes each processor cycle, where and when and for what each byte of memory is responsible, as well as where and when each execution thread is controlled.  Until recently, Microsoft's compilers changed ABI with every update - so if you had a lot of dependencies, then rebuilding all of them could be a painful process.  Game developers usually prefer small dependencies that are easily integrated, do just one thing and do it well ‚Äî preferably with a C-style API ‚Äî and are used in many companies, are in the public domain or have a free license that is not requires indication of the author.  <i>SQLite</i> and <i>zlib</i> are good examples of what game developers prefer to use. <br><br>  In addition, the C ++ games industry has a rich history of patients with the ‚ÄúNot invented here‚Äù syndrome.  This is to be expected from an industry that began with lonely enthusiasts who were making something of their own on completely new equipment and had no other options.  The gaming industry, among other things, is the only one where programmers appear in captions in no particular order.  <i>Writing a variety of things is fun, and it helps your career!</i>  <i>It is much better to build something of your own than to buy ready-made!</i>  And since we are so worried about performance, we can tailor our solution so that it is appropriate for our project - instead of taking a generalized solution that wastes resources available.  Dislike Boost is a prime example of how such thinking manifests itself in game development.  I worked on projects that went the following way: <br><br><ul><li>  To begin with, to solve this or that problem, we connect the library from Boost to the project. </li><li>  Everything works very well.  When you need to upgrade, there is a little pain, but no more than when updating any other dependencies. </li><li>  Another game wants to use our code, but the stumbling block is that we use Boost - despite the fact that our experience with using Boost was completely normal. </li><li>  We remove the code using Boost, but now we are faced with a new problem: we have to solve a problem that was previously solved instead of our library from Boost. </li><li>  We essentially copy the parts of the Boost code we need into our own namespaces. </li><li>  Later, we inevitably and again and again encounter the fact that we need additional functionality, which would already be in the original code, if we had not thrown it out.  But now we ourselves are the owners of this code, so we have to continue supporting it. </li></ul><br>  We don‚Äôt like something huge trying to do too many things at the same time or that can affect the compile time ‚Äî and that‚Äôs quite reasonable.  What people make mistakes over and over again is that they are opposed to accepting the supposed pain today - while because of this decision they are faced with a very real and much greater pain, supported by something the budget they will have to experience over the next three years.  Alas, the existence of evidence in the form of games that successfully use a dish from STL and Boost, in no way can affect the psychology of the person and persuade game developers. <br><br>  For all these reasons, many gaming companies have created their own libraries that cover what STL does ‚Äî and more ‚Äî and still support game-specific use cases.  Some large gaming companies were even able to master the development of their own, fully-fledged, almost completely compatible with the <a href="https://github.com/electronicarts/EASTL">STL replacement</a> API, which later entailed the huge costs of supporting this project. <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DvElZc6zSIXM">It is reasonable to find an improved alternative to</a> <code>std::map</code> , or apply <i>small buffer optimization</i> to <code>std::vector</code> .  It is much less acceptable to be doomed to support your own implementation of <code>algorithms</code> or <code>type traits</code> , which will bring almost no benefit.  As for me, it is regrettable that STL for most developers is only containers.  Since learning STL at the start is taught by them, speaking of STL most implies <code>std::vector</code> - although in fact they should think about <code>std::find_if</code> . <br><br><h3>  Option number 3: Tests </h3><br>  It is argued that extensive testing should be carried out, TDD and / or BDD should cover all the code that can be covered, and bugs should be fought by writing new tests. <br><br>  So let's discuss the topic of testing. <br><br>  Judging by my experience, automated testing in the gaming industry is almost never used.  Why? <br><br><h4>  1. Because correctness is <i>not so</i> important, and there is no real specification. </h4><br>  As a young programmer in the gaming industry, I quickly got rid of the thought that I should strive to model something realistically.  Games are the <i>smoke and mirrors</i> and the search for short confuses.  No one cares how realistic your simulation is;  The main thing is that it is fascinating.  When you have no other specification than ‚Äúthe game should be felt right,‚Äù there is no test item itself.  Thanks to the bugs, the gameplay can even get better.  Quite often, the bug gets into the release, and even wins the love of users ( <a href="https://kotaku.com/why-gandhi-is-such-an-asshole-in-civilization-1653818245">remember the same Gandy from Civilization</a> ).  Games are different from other areas in which C ++ is used;  here the lack of correctness does not lead to the fact that someone as a result loses their savings. <br><br><h4>  2. Because it's hard </h4><br>  Of course, you would like to do automated tests wherever you can.  This can be implemented for some subsystems for which there are clearly defined outcomes.  Unit testing in the gaming industry is, of course, present, but is usually limited to low-level code ‚Äî the previously mentioned STL analogs, string conversion procedures, methods of the physics engine, etc.  Those cases where the executable part of the code has predictable results are usually tested by unit tests, although TDD is not used here - because game programmers prefer to simplify their lives, and not vice versa.  But how do you test the gameplay code (see point one)?  As soon as you go beyond unit testing, you immediately encounter another reason why testing games is so difficult. <br><br><h4>  3. Because content is involved in it. </h4><br>  Testing of non-trivial systems may include the provision of content, with the participation of which it will be carried out.  Most engineers are not very good at making this content on their own, so you need to involve someone with the right content creation skills to get a meaningful test.  After that, you will encounter the problem of measuring what you get at the output - after all, it is no longer a string or number, but an image on the screen or sound that changes over time. <br><br><h4>  4. Because we do not practice it. </h4><br>  Unit testing is a function for which I know the possible inputs and outputs.  However, gameplay is an unpredictable, dynamically developing behavior, and I don‚Äôt know how such a phenomenon could be properly tested.  What I can test is - if, of course, I get permission from my manager to devote enough time to it - this is, for example, performance, or high-level matchmaking capabilities, which I can analyze.  Such infrastructure work can be fascinating for some game programmers, but most of them are simply uninteresting - and, in addition, require the approval and support of the wallet owner.  In the role of a game programmer, I never have the opportunity to practice writing high-level tests. <br><br><h4>  5. Because [the company] sees no need for automated testing. </h4><br>  Our main goal is to release the game.  We live in a time of an industry that moves forward with hits that earn most of their money in the first month of sales, when the marketing costs of these hits are at their maximum.  The life cycle of consoles taught us that the code will not live in such a long time either.  If we are working on an online game, then most likely we will get additional time to test matchmaking or server load.  Because for the release of the game, we need its performance to be in order, we should at least do performance testing, but we should not automate this process.  For management in the gaming industry, automated testing is nothing more than a waste of time and money.  For it, you have to hire experienced engineers who will produce work, the result of which will be almost imperceptible.  The same time could be spent on developing new features.  In the short term, it is much more profitable to use QA personnel to test the game, which brings us to the next point. <br><br><h4>  6. Because in general, testing refers to second-rate activities in games. </h4><br>  I adore good QA specialists.  For me they are worth their weight in gold.  They know how to make your game better, breaking it in a way that would never occur to you.  They are profile experts in your gameplay in the sense that you do not understand, and hardly ever will understand.  They are better than a team of super-capable compilers that help you do everything right.  I am glad that I had the chance to work with several wonderful QA specialists over the years of my work. <br><br>  I almost always had to fight only to keep them on my team. <br><br>   AAA-, ,  QA ‚Äî         ,       .     ,         .  ,      . <br><br>   ,      ,              ,       .   ¬´¬ª   ,       ,  QA   ,          ,        ,          . <br><br>   .             ,     .      QA-,          ,     API         ,    ¬´ ¬ª.    ,        ,         . <br><br>   .  ,       ,            ,     ‚Äî       . <br><br>   .       .       ,      ,  ¬´ .¬ª  ¬´ Y.¬ª.      QA- ‚Äî   ,         ,   . <br><br>      ,          ,        ;  ,     ‚Äî ,      ,      ‚Äî   QA   ,     , ,   ,   QA  . <br><br>   ,     ,    ,       QA-,      .            .           .      ,    ,         . <br><br><h3>   </h3><br>     ‚Äî   ,   API  ,     ,   (    )   ‚Äî  ,        . <br><br>        ,    ,         C++. <br><br>      ,    .    ,   ,  ,  ,        ,      .  ,  - ,            ,      . <br><br>  ,     ,    ,   ,               .    ,     ,          ‚Äî    ,    . ,      ( <i>data breakpoints</i> )        ,   ,       ‚Äî ,    ,       ?   ,      ,     ,      ,     ,         ,       ,       ,    ,     ( <i>soak testing</i> )? <br><br>          .      ,    .    ,    ;         ;      ;      ;      ;    ,    ;    ,     ,   . <br><br> ,       ¬´¬ª,      .  ,   ,    ,   ‚Äî      .   ,   ‚Äî  ,         .  -    ,         . <br><br>   ¬´ ++¬ª       ,   .      ;     ,   ;    ,    .   ¬´ C++¬ª     , ‚Äî  ,    ,  STL  _ _,    STL .    ,  STL  ¬´ ¬ª,     ; ,    , <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/just-my-code%3Fview%3Dvs-2017">   ,      </a> . <br><br>       ,      ,  ¬´ C++¬ª   ‚Äî   ,           .   <i> </i> ‚Äî    ,   . <br><br>      ,    C++      ,         .    ,     .     ,                .     <a href="https://godbolt.org/z/e7g6PI"><i>copy elision</i> ( )   </a> ,         .         . ,      ,      NRVO    ,      ,         . ,  C++     <i></i> . <br><br><h3> :   ++ </h3><br>            ,   C++,           . <br><br><h4> 1.    </h4><br>  ,         C++,         ,     .       ,      .     ,    ,    ‚Äî             . <br><br>       ,        . C++98,       , -    ,     . <br><br> ,      ,           ,         .   ,     C++-,       ¬´¬ª C++.    ‚Äî      , C  C++98.    ,     ,      ,   ‚Äì ,          .       ? <br><br><h4> 2.   </h4><br>  ,         GDC,   <a href="https://cppcon.org/">CppCon</a> ,        ,     .    ;   <a href="https://groups.google.com/a/isocpp.org/forum/"></a>    ;  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/"> </a>     .        ,     ,      ‚Äî        ,       . <br><br>     C++   .     ,       SG14,  SG7,  SG15 ‚Äî     ,     ‚Äî <a href="https://isocpp.org/std">    isocpp.org</a> .       ‚Äî   ,    ,   200       ?    ¬´¬ª     ¬´¬ª  . <br><br>   ,     ,      ,      ,    Twitter  Reddit. ,    ‚Äî      . </div><p>Source: <a href="https://habr.com/ru/post/435036/">https://habr.com/ru/post/435036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435018/index.html">In 2018, we finally began to take seriously the time spent at the smartphone</a></li>
<li><a href="../435020/index.html">Hall of Fame Consumer Electronics: Stories of the Best Gadgets of the Last 50 Years, Part 2</a></li>
<li><a href="../435026/index.html">Making an instant messenger * that even works in an elevator</a></li>
<li><a href="../435028/index.html">Tests on C without SMS and registration</a></li>
<li><a href="../435032/index.html">The spacecraft "Chang'e-4" made a successful landing on the far side of the moon and sent the first photo</a></li>
<li><a href="../435038/index.html">World nuclear power in 2018</a></li>
<li><a href="../435040/index.html">Bitcoin 10 years ago</a></li>
<li><a href="../435044/index.html">Antiquities: Minidisk in its natural habitat</a></li>
<li><a href="../435050/index.html">A tale about how .NET 4.5 was installed on ReactOS</a></li>
<li><a href="../435054/index.html">ITMO University "in practice": with which technology companies we cooperate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>