<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DIY bytecode interpreters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Virtual machine programming languages ‚Äã‚Äãin recent decades have become very widespread. A lot of time has already passed since the presentation of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DIY bytecode interpreters</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  Virtual machine programming languages ‚Äã‚Äãin recent decades have become very widespread.  A lot of time has already passed since the presentation of the Java Virtual Machine in the second half of the 90s, and it can be said with confidence that bytecode interpreters are not the future, but the present. </p><br><p>  But this technique, in my opinion, is almost universal, and an understanding of the basic principles of interpreter development is useful not only for the creator of the next contender for the title "Language of the Year" according to <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a> , but in general to any programmer. </p><br><p>  In a word, if you are interested in knowing how numbers add up to our favorite programming languages, what the developers of virtual machines are still arguing about and how to compare strings and regular expressions painlessly, I ask for cat. </p><a name="habracut"></a><br><h1 id="predystoriya">  Prehistory </h1><br><p>  One of the self-written systems of the Business Intelligence department of our company has an interface in the form of a simple query language.  In the first version of the system, this language was interpreted on the fly, without compilation, directly from the input string with the query.  The second version of the parser will work with intermediate byte-code, which will allow to separate the query language from their execution and greatly simplify the code. </p><br><p>  In the process of working on the second version of the system, I had a vacation, during which for an hour or two I was distracted every day from family matters to study materials on the architecture and performance of bytecode interpreters.  I decided to share the resulting notes and examples of interpreters with Habr's readers in the form of a series of articles. </p><br><p>  The first of them presents five small (up to a hundred lines of simple C code) virtual machines (OK), each of which reveals a certain aspect of the development of such interpreters. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  Where there are bytecodes in programming languages </h1><br><p>  Virtual machines, a wide variety of virtual instruction sets over the past few decades, a great many have been invented.  Wikipedia claims that the first programming languages ‚Äã‚Äãwere compiled into various simplified intermediate representations as early as the 1960s.  Some of these first bytecodes were converted to machine codes and executed by real processors, others were interpreted by virtual processors on the fly. </p><br><p>  The popularity of virtual instruction sets as an intermediate code representation is explained by three reasons: </p><br><ol><li>  Programs in the form of bytecodes are easily transferred to new platforms. </li><li>  Bytecode interpreters work faster than the syntax tree interpreters. </li><li>  You can develop a simple virtual machine in just a couple of hours. </li></ol><br><p>  Let's make some simplest C virtual machines and use these examples to highlight the main technical aspects of the implementation of virtual machines. </p><br><p>  Full sample codes are posted on <a href="https://github.com/vkazanov/bytecode-interpreters-post">GitHub</a> .  Examples can be collected with any relatively fresh GCC: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  All examples have the same structure: first comes the code of the virtual machine itself, after - the main function with assertions that check the operation of the code.  I tried to clearly comment on opcodes and key interpreter locations.  I hope the article will be clear even to people who do not write daily in C. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  The world's easiest bytecode interpreter </h1><br><p>  As I said before, the simplest interpreter is very easy to make.  Comments - right after the listing, but let's start directly with the code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  There are less than one hundred lines, but all the characteristic attributes of the virtual machine are represented.  The machine has a single register ( <code>vm.accumulator</code> ), three operations (register increment, register decrement and program execution completion) and a pointer to the current instruction ( <code>vm.ip</code> ). </p><br><p>  Each operation (eng. <em>Operation code</em> , or <em>opcode</em> ) is encoded in one byte, and dispatching is performed using a normal <code>switch</code> in the <code>vm_interpret</code> function.  The branches in the <code>switch</code> contain the logic of operations, that is, they change the state of the register or complete the execution of the program. </p><br><p>  The operations are transferred to the <code>vm_interpret</code> function as an array of bytes - bytecode ( <em>bytecode</em> ) - and are executed sequentially until the virtual machine shutdown operation ( <code>OP_DONE</code> ) is <code>OP_DONE</code> . </p><br><p>  A key aspect of a virtual machine is semantics, that is, a set of operations that are possible on it.  In this case, there are only two operations, and they change the value of a single register. </p><br><p>  Some researchers ( <a href="https://www.sba-research.org/wp-content/uploads/publications/bytecode09.pdf">Virtual-machine Abstraction and Optimization Techniques</a> , 2009) propose to divide virtual machines into <em>high-level</em> and <em>low-level ones</em> according to the proximity of the semantics of the virtual machine to the semantics of the physical machine on which the byte code will be executed. </p><br><p>  In the limiting case, the bytecode of low-level virtual machines can completely repeat the machine code of the physical machine with simulated RAM, a full set of registers, instructions for working with the stack, and so on.  The <a href="http://bochs.sourceforge.net/">Bochs</a> virtual machine, for example, repeats the set of instructions for the x86 architecture. </p><br><p>  And vice versa: the operations of high-level virtual machines closely reflect the semantics of the specialized programming language compiled into byte-code.  This is how SQLite, Gawk, and numerous versions of Prolog work, for example. </p><br><p>  Intermediate position is occupied by interpreters of general-purpose programming languages, having elements of both high and low levels.  In the most popular Java Virtual Machine there are both low-level instructions for working with the stack, and built-in support for object-oriented programming with automatic memory allocation. </p><br><p>  The code above is more likely to be the most primitive of low-level virtual machines: each virtual instruction is a wrapper over one or two physical instructions, and the virtual register fully corresponds to one register of the ‚Äúiron‚Äù processor. </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Arguments bytecode instructions </h1><br><p>  We can say that the only case in our example of a virtual machine is both the argument and the return value of all the instructions being executed.  However, we may need the ability to pass arguments to instructions.  One way is to directly put them into bytecode. </p><br><p>  We extend the example by inserting instructions (OP_ADDI, OP_SUBI), which take an argument in the form of a byte, immediately following the opcode: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  New instructions (see the <code>vm_interpret</code> function) read their argument from the bytecode and add it to the register / subtract it from the register. </p><br><p>  Such an argument is called an immediate argument (the <em>immediate argument</em> ), since it is located directly in the array of opcodes.  The main limitation in our implementation is that the argument is a single byte and can only take 256 values. </p><br><p>  In our virtual machine, the range of possible values ‚Äã‚Äãof the arguments of instructions does not play a big role.  But if the virtual machine will be used as an interpreter of a real language, it makes sense to complicate the byte-code by adding a table of constants separate from the opcode array and instructions with a direct argument corresponding to the address of the present argument in the table of constants. </p><br><h1 id="stekovaya-mashina">  Stack machine </h1><br><p>  Instructions in our simple virtual machine always work with one register and cannot transfer data to each other in any way.  In addition, the argument of the instruction can only be direct, but, say, the operation of addition or multiplication takes two arguments. </p><br><p>  Simply put, we have no way to evaluate complex expressions.  To solve this problem, you need a stack machine, that is, a virtual machine with a built-in stack: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  In this example, there are more operations, and almost all of them work only with the stack.  OP_PUSHI pushes its immediate argument onto the stack.  The instructions OP_ADD, OP_SUB, OP_DIV, OP_MUL retrieve a pair of values ‚Äã‚Äãfrom the stack, calculate the result and push it back onto the stack.  OP_POP_RES removes the value from the stack and places it in the result register, intended for the results of the virtual machine. </p><br><p>  For the operation of division (OP_DIV), the error of division by zero is trapped, which stops the operation of the virtual machine. </p><br><p>  The capabilities of such a machine are much wider than the previous one with a single register and allow, for example, to calculate complex arithmetic expressions.  Another (and important!) Advantage is the simplicity of compiling programming languages ‚Äã‚Äãinto a byte-code stack machine. </p><br><h1 id="registrovaya-mashina">  Register machine </h1><br><p>  Due to its simplicity, stack virtual machines are the most widely distributed among developers of programming languages;  the same JVM and Python VMs use them. </p><br><p>  However, such machines have drawbacks: they have to add special instructions for working with the stack, when calculating expressions all arguments repeatedly pass through a single data structure, a lot of unnecessary instructions appear in the stacking code. </p><br><p>  Meanwhile, the implementation of each extra instruction entails the cost of scheduling, that is, decoding the opcode and the transition to the body of instructions. </p><br><p>  An alternative to stack machines is register-based virtual machines.  They have a more complicated byte-code: each instruction clearly encodes the number of register-arguments and the number of the register-result.  Accordingly, instead of a stack, an extended set of registers is used as a repository of intermediate values. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  The example shows a register machine with 16 registers.  The instructions take 16 bits each and are encoded in three ways: </p><br><ol><li>  4 bits per opcode + 4 bits per register name + 8 bits per argument. </li><li>  4 bits for the operation code + three times 4 bits for the names of the registers. </li><li>  4 bits per opcode + 4 bits for a single register name + 8 unused bits. </li></ol><br><p>  Our small virtual machine has very few operations, so four bits (or 16 possible operations) per opcode are enough.  The operation determines exactly what the remaining bits of the instruction represent. </p><br><p>  The first type of coding (4 + 4 + 8) is needed to load data into the registers with the OP_LOADI operation.  The second type (4 + 4 + 4 + 4) is used for arithmetic operations, which should know where to take a couple of arguments and where to add the result of the calculation.  And finally, the last view (4 + 4 + 8 unnecessary bits) is used for instructions with a single register as an argument, in our case it is OP_MOV_RES. </p><br><p>  For encoding and decoding instructions, special logic is now needed (the <code>decode</code> function).  On the other hand, the logic of instructions due to the explicit indication of the location of the arguments becomes easier - operations with the stack disappear. </p><br><p>  The key features are: there are fewer instructions in the byte code of the register machines, separate instructions are wider, compiling into such byte code is more complicated - the compiler has to decide how to use the available registers. </p><br><p>  It should be noted that in practice in register virtual machines there is usually a stack where, for example, function arguments are placed;  registers are used to evaluate individual expressions.  Even if there is no explicit stack, then an array is used to build the stack, which plays the same role as the RAM in physical machines. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  Stack and register machines, comparison </h1><br><p>  There is an interesting study ( <a href="https://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf">Virtual machine showdown: Stack versus registers</a> , 2008), which had a great influence on all subsequent developments in the field of virtual machines for programming languages.  Its authors proposed a method of live translation from the stack code of the standard JVM to the register code and compared the performance. </p><br><p>  The method is non-trivial: the code is first translated and then optimized in a rather complicated way.  But the subsequent comparison of the performance of the same program showed that the additional processor cycles spent on decoding instructions were fully compensated by a decrease in the total number of instructions.  In general, in short, the register machine turned out to be more efficient than the stack one. </p><br><p>  As mentioned above, this efficiency has a very tangible price: the compiler must allocate the registers itself and additionally it is desirable to have a developed optimizer. </p><br><p>  The debate about which architecture is better is still not over.  If we talk about Java compilers, the Dalvik VM bytecode, which until recently worked in every Android device, was registered;  but the titular JVM kept the stack instruction set.  The Lua virtual machine uses the register machine, but the Python VM is still a stack.  And so on. </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Byte code in regular expression interpreters </h1><br><p>  Finally, to distract from low-level virtual machines, let's look at a specialized interpreter that checks strings for regular expression matching: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  The main instruction is OP_CHAR.  It takes its immediate argument and compares it with the current character in the string ( <code>char *sp</code> ).  In case of coincidence of the expected and current characters in the line, the transition to the next instruction and the next character takes place. </p><br><p>  The machine also understands the transition operation (OP_JUMP), which takes a single immediate argument.  Argument means absolute offset in bytecode, from where the calculation should be continued. </p><br><p>  The last important operation is OP_OR.  It takes two offsets, trying to apply the code first on the first one, then, in case of an error, the second one.  It does this with the help of a recursive call, that is, the instruction makes a crawl into the depth of the tree of all possible variants of a regular expression. </p><br><p>  Surprisingly, four opcodes and seventy lines of code are enough to express regular expressions of the form "abc", "a? Bc", "(ab | bc) d", "a * bc".  In this virtual machine, there is not even an explicit state, since all that is needed - pointers to the beginning of the instruction stream, the current instruction and the current symbol - is passed in by the arguments of the recursive function. </p><br><p>  If you are interested in the details of the work of regular expression engines, for a start you can familiarize yourself with the <a href="https://swtch.com/~rsc/regexp/">series of articles by</a> Russ Cox (Google <a href="https://github.com/google/re2">Co2</a> , author <em>Russ Cox</em> ), the author of the regular expression engine from Google <a href="https://github.com/google/re2">RE2</a> . </p><br><h1 id="itogi">  Results </h1><br><p>  Let's summarize. </p><br><p>  For general purpose programming languages, as a rule, two architectures are used: stack and register. </p><br><p>  In a stack model, the main data structure and the way to transfer arguments between instructions is the stack.  In the register model, a set of registers is used to evaluate expressions, but an explicit or implicit stack is still used to store function arguments. </p><br><p>  The presence of an explicit stack and a set of registers brings such machines to low-level and even physical ones.  The abundance of low-level instructions in such a bytecode means that a significant amount of physical processor resources is spent on decoding and dispatching virtual instructions. </p><br><p>  On the other hand, high-level instructions play an important role in popular virtual machines.  In Java, for example, these are instructions for polymorphic function calls, allocation of objects, and garbage collection. </p><br><p>  Purely high-level virtual machines - for example, interpreters of byte-codes of languages ‚Äã‚Äãwith advanced and far from iron semantics - spend most of their time not in the controller or decoder, but in the instructions bodies and, accordingly, are relatively effective. </p><br><p>  Practical recommendations: </p><br><ol><li>  If you need to execute any byte-code and do it within a reasonable time, then try to operate with instructions that are closest to your task;  the higher the semantic level, the better.  This will reduce the cost of scheduling and simplify code generation. </li><li>  If greater flexibility and heterogeneous semantics were required, then you should at least try to isolate the common denominator in the byte code so that the resulting instructions are conditionally average. </li><li>  If in the future it may be necessary to calculate any expressions, make a stack machine, this will reduce the headache when compiling bytecode. </li><li>  If no expressions are foreseen, then make a trivial register machine, which will avoid the cost of the stack and simplify the instructions themselves. </li></ol><br><p>  In the following articles, I will analyze the practical implementations of virtual machines in popular programming languages ‚Äã‚Äãand will explain why the Business Intelligence Badoo department needed a bytecode. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425325/">https://habr.com/ru/post/425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425313/index.html">10 best VS Code-extensions of 2018 for front-end developers</a></li>
<li><a href="../425315/index.html">Organize code storage in GitLab and integrate code review in GitFlow</a></li>
<li><a href="../425317/index.html">How it is done: we write "Minesweeper" in 4 minutes</a></li>
<li><a href="../425321/index.html">Programming is the materialization of ideas.</a></li>
<li><a href="../425323/index.html">"Rabbit Hole". UX designer in the product team</a></li>
<li><a href="../425327/index.html">Functional programming: measure seven times, cut once</a></li>
<li><a href="../425329/index.html">A few tips to the millennials from the "oldies". How to succeed in our digital world</a></li>
<li><a href="../425331/index.html">Alice will help developers find objects in user requests. NER in Dialogues</a></li>
<li><a href="../425333/index.html">Boot yourself, Spring is coming (Part 2)</a></li>
<li><a href="../425335/index.html">Invincible Garmin Armada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>