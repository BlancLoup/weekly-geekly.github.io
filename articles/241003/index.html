<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exploit Analysis Dianti.A</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently we wrote about a set of detected vulnerabilities in Windows, which were used by attackers in targeted attacks, before the release of the corr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exploit Analysis Dianti.A</h1><div class="post__text post__text-html js-mediator-article">  Recently we <a href="http://habrahabr.ru/company/eset/blog/240445/">wrote</a> about a set of detected vulnerabilities in Windows, which were used by attackers in targeted attacks, before the release of the corresponding fix by Microsoft (0day).  One of these vulnerabilities in the OLE Package manager (Packager.dll) component was added to our databases as <a href="http://www.virusradar.com/en/Win32_Exploit.CVE-2014-4114.A/description">Win32 / Exploit.CVE-2014-4114.A by</a> virus analysts.  Attackers could <a href="http://habrahabr.ru/company/eset/blog/240345/">exploit</a> this vulnerability through a specially crafted PowerPoint presentation document with an OLE object embedded there. <br><br><img src="https://habrastorage.org/files/d88/c9d/236/d88c9d236fd645f699ea3b5085775776.png"><br><br>  In this post we would like to highlight another vulnerability from this list.  This vulnerability was assigned an identifier CVE-2014-4113 and it is present in the win32k.sys driver of all supported versions of Windows (2k3 +).  Vulnerability allows unauthorized (bypassing the limitations of the OS) to execute the kernel mode code and raise the privileges of the application launched by the exploit to the maximum possible level (SYSTEM).  CVE-2014-4113 was closed by updating MS14-058 as part of the October patch tuesday, and the 64-bit version of the exploit was added to the database as <a href="http://www.virusradar.com/en/Win64_Dianti.A/description">Win64 / Dianti.A</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  Win32k.sys itself over the past few years has been a real treasure to search for vulnerabilities like Elevation Of Privilege (or Local Privelege Escalation, LPE).  In <a href="http://habrahabr.ru/company/eset/blog/209694/">our report</a> for 2013, it was noted that this component of the OS ranks second in the number of vulnerabilities corrected for it for the whole year.  It is only ahead of the product Internet Explorer, which consists of a large number of executable files, while in the case of win32k.sys there is only one file. <br><br>  Win32k.sys itself has already been written more than once, it is that part of the Windows subsystem that runs in kernel mode and is responsible for the logic and mechanisms associated with the implementation of the Windows GUI interface and its interaction with the user through input devices.  In the distant past, when Windows NT was only turning into what history remembered as Windows 2000 (NT 5.0), Windows XP (NT 5.1), etc., and now Windows 10 (NT 6.4), the entire GUI subsystem worked in user mode and required a large overhead of process context switches when performing operations on screen display, processing keyboard messages, etc. <br><br>  Then in NT 4.0, the win32k.sys kernel mode driver appeared to improve performance and reduce the overhead of context switches.  The logic of the GUI-subsystem was divided into the part that works in user mode (known libraries user32.dll and gdi32.dll) and part of the kernel mode in the form of the win32k.sys driver.  Perhaps this is why so many bugs are covered in win32k.sys, the driver code could be copied from user mode libraries in places.  In addition, driver functions that should return pointers were implemented in such a way that they could also return constants, i.e. values ‚Äã‚Äãthat could not be interpreted as pointers. <br><br>  Windows allows you to execute kernel-mode code only through special mechanisms (API), since such code is provided with full access to all software and hardware resources of the OS.  Vulnerabilities of win32k.sys somehow allow attackers to bypass these restrictions and execute kernel mode code through an exploit. <br><br>  In the case of CVE-2014-4113, the point is that you can create a special system structure for win32k ( <i>win32k! Tagwnd</i> ), project it into kernel mode and force one of the driver's functions to call a callback from this generated structure.  The vulnerability itself lies in the fact that one of the driver functions ( <i>xxxHandleMenuMessages</i> ) does not check the value returned by the other function ( <i>xxxMNFindWindowFromPoint</i> ) (the expected pointer), and passes it on to another function ( <i>xxxSendMessage</i> ) that operates on the wrong value.  See <a href="http://blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-a-windows-kernel-mode-vulnerability-cve-2014-4113/">blog.trendmicro.com/trendlabs-security-intelligence/an-analysis-of-a-windows-kernel-mode-vulnerability-cve-2014-4113</a> . <br><br>  <b>32-bit version</b> <br><br>  In the case of the 32-bit version of the exploit, it uses an integer overflow argument, which is passed to the <i>xxxSendMessage</i> function from <i>xxxHandleMenuMessages</i> .  This argument itself can be interpreted by the <i>xxxHandleMenuMessages</i> function as a pointer or as a negative value in case of an error, which is returned by the <i>xxxMNFindWindowFromPoint</i> function.  Due to the lack of a negative value (error) <i>check</i> in <i>xxxHandleMenuMessages</i> , this function passes this value instead of the pointer to <i>xxxSendMessage</i> . <br><br>  In general, the exploit applies the following steps to exploit. <br><br><ul><li>  Using the function <i>ntdll! ZwAllocateVirtualMemory</i> allocates a page of memory at the zero address. </li><li>  On this page, it creates a fake <i>win32k! Tagwnd structure</i> , initializing a pointer to an exploit callback function (shellcode). </li><li>  Creates a condition for triggering a vulnerability, that is, passing an invalid argument (0xfffffffb, -5) to the <i>xxxSendMessage</i> function, which leads to an integer overflow during pointer dereferencing and memory access on a zero page.  That is, when the <i>xxxSendMessage</i> function is <i>accessed</i> to the pointer field to the callback function, an overflow occurs (0xfffffffb + 0x60) of the intended address and as a result, the function will receive a pointer to the shell code. </li><li>  As a result of operation, the control receives a shell code that rewrites a pointer to the access token in the structure of the current process's EPROCESS kernel object so that it points to the access token of the system process.  Later this will lead to the fact that the process created by the exploit will inherit the system process access token and gain maximum privileges in the system. </li></ul><br>  Thus, preparation for operation is reduced to the following function. <br><br><img src="https://habrastorage.org/files/cd3/e19/6c8/cd3e196c8d5d486fab75deed0697c56a.png"><br>  Fig.  Preparing for the exploitation of the vulnerability on a 32-bit system.  To allocate an address on a zero page, the already popular <i>ZwAllocateVirtualMemory</i> call is <i>used</i> , to which one is passed as the address, which leads to a page alignment of the reserved address to zero.  This ‚Äúfeature‚Äù has been closed for Windows 7 by updating <a href="https://technet.microsoft.com/ru-ru/library/security/ms13-031.aspx">MS13-031</a> , and in Windows 8+ this update is enabled by default.  At the beginning of the function, the non-exported <i>user32!</i> PtiCurrent function is <i>called</i> , which returns a pointer to the Win32ThreadInfo structure.  This pointer will be used to initialize the win32k! _THRDESKHEAD.pti structure field. <br><br>  <b>64-bit version</b> <br><br>  In a 64-bit virtual address space, instead of integer overflow, the exploit uses memory allocation at a given address in memory.  That is, the returned constant itself is used as an address when reserving a page of memory that will be filled with the <i>fnFillmalicioustagWnd</i> function (see the screenshot below). <br><br><img src="https://habrastorage.org/files/be6/a56/607/be6a56607200402a90ec6a7a398e701e.png"><br>  Fig.  This is the structure of tagWND on Windows 7 x64.  Red is the pointer to the callback function, which will point to the shell code. <br><br><img src="https://habrastorage.org/files/8b9/c7e/731/8b9c7e7314234ab1bd3146b454439cd0.png"><br>  Fig.  The shellcode function itself, which replaces the pointer to the access token for the current process EPROCESS. <br><br><img src="https://habrastorage.org/files/14e/2dc/cef/14e2dccef5cd43bcb5623ab1682fedb5.png"><br>  Fig.  The function of creating a fake tagWND structure.  To fill the first field of the structure, use the received pointer ( <i>user32! PtiCurrent</i> ) on Win32ThreadInfo. <br><br><img src="https://habrastorage.org/files/8e0/160/c4c/8e0160c4c48d4b2486904d836f70bccd.png"><br>  Fig.  Part of the <i>fnPrepareExploitation</i> function.  On x64, a memory page is reserved by the pointer of the returned constant, i.e. 0xFFFFFFFB. <br><br>  After the end of the preparatory activities, the exploit enters the exploitation stage, i.e., creates conditions for the vulnerability to trigger.  To do this, use various manipulations with the menu controls and setting window traps, which ultimately causes the vulnerable function win32k to return a constant instead of a pointer.  Then the process is created using the <i>CreateProcessA</i> function. <br><br><img src="https://habrastorage.org/files/f5f/9ba/162/f5f9ba16213b408b8a8fc8b38f0511f1.png"><br>  Fig.  As a result of the exploit, the child command line process inherited its system access token. <br><br>  It is worth noting that the exploitation of this vulnerability is not possible on Windows 8+ x32 &amp; x64.  In the 32-bit version, protection against allocating memory by the null pointer is present by default, and in the 64-bit version, execution of code in kernel mode from a page in user mode will be blocked by the <a href="http://blog.ptsecurity.com/2012/09/bypassing-intel-smep-on-windows-8-x64.html">SMEP</a> mechanism. </div><p>Source: <a href="https://habr.com/ru/post/241003/">https://habr.com/ru/post/241003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240993/index.html">China carries out MiTM-attack on iCloud users</a></li>
<li><a href="../240995/index.html">Courses of ethical hacking and penetration testing</a></li>
<li><a href="../240997/index.html">Gesture Recognition in sketchometry</a></li>
<li><a href="../240999/index.html">TeaVM is another way to launch Java in the browser</a></li>
<li><a href="../241001/index.html">FTDI Strikes Back</a></li>
<li><a href="../241005/index.html">Organizing your personal knowledge base in Evernote</a></li>
<li><a href="../241009/index.html">Accident or predestination</a></li>
<li><a href="../241011/index.html">Good morning, Vietnam!</a></li>
<li><a href="../241015/index.html">Mark Andressen: why optimism is always a winning strategy</a></li>
<li><a href="../241017/index.html">Simple examples of genuine customer focus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>