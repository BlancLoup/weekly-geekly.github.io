<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the new sync.Map in Go 1.9</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the innovations in Go 1.9 was the addition to the standard library of the new type sync.Map , and if you have not yet figured out what it is an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the new sync.Map in Go 1.9</h1><div class="post__text post__text-html js-mediator-article"><p>  One of the innovations in Go 1.9 was the addition to the standard library of the new type <a href="https://golang.org/pkg/sync/">sync.Map</a> , and if you have not yet figured out what it is and why it is needed, then this article is for you. </p><br><p>  For those who are interested only in output, TL; DR: </p><br><blockquote>  if you have a highly loaded (and 100ns solves) system with a large number of processor cores (32+), you may want to use sync.Map instead of the standard map + sync.RWMutex.  In other cases, sync.Map is not particularly needed. </blockquote><p><img src="https://habrastorage.org/web/fc8/179/905/fc81799050554f20a7b28314b68afe47.png"></p><br><p>  If the details are interesting, then let's start with the basics. </p><a name="habracut"></a><br><h1 id="tip-map">  Map type </h1><br><p> If you work with data in the "key" format - "value", then all you need is the built-in type <code>map</code> .  A good introduction to how to use the map is in <a href="https://golang.org/doc/effective_go.html">Effective Go</a> and the <a href="https://blog.golang.org/go-maps-in-action">blog post "Go Maps in Action"</a> . </p><br><p>  <code>map</code> is a generic data structure in which the key can be any type, except for slices and functions, and the value can be any type.  In essence, this is a well-optimized hash table.  If you are interested in the internal structure of the map - <a href="https://www.youtube.com/watch%3Fv%3DTl7mi9QmLns">in the past GopherCon was a very good report on this topic</a> . </p><br><p>  Remember how to use the map: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  m := make(map[string]int) //  m["habr"] = 42 //  val := m["habr"] //   comma,ok val, ok := m["habr"] // ok  true,    //  for k, v := range m { ... } //  delete(m, "habr")</span></span></code> </pre> <br><p>  During the iteration, the values ‚Äã‚Äãin the map may change. </p><br><p>  Go, as you know, is a language created for writing concurrent programs - programs that work effectively on multiprocessor systems.  But the map type is not secure for parallel access.  Ie, for reading, of course, is safe - 1000 gorutin can be read from the map without fear, but in parallel to it it is also possible to write - no longer.  Before Go 1.8, competitive access (reading and writing from various gorutin) could lead to uncertainty, and after Go 1.8, this situation began to clearly throw out panic with the message "concurrent map writes". </p><br><h1 id="pochemu-map-ne-potokobezopasen">  Why map is not thread safe </h1><br><p>  <a href="https://golang.org/doc/faq">The decision to make or not the</a> map was thread-safe was not easy, but it was decided not to do it - this security is not given for free.  Where it is not needed, additional synchronization tools like mutexes will unnecessarily slow down the program, and where it is needed, it is not difficult to implement this security using <a href="https://golang.org/pkg/sync/">sync.Mutex</a> . </p><br><p>  The current map implementation is very fast: <br><img src="https://habrastorage.org/web/4c3/5b8/a25/4c35b8a25c95465db94ab6a51409efa0.png"></p><br><p>  Such a compromise between speed and thread safety, while leaving the possibility of having the first and second option.  Either you have a super-fast map without any mutexes, or a bit slower, but safe for parallel access.  It is important to understand here that in Go the use of a variable in parallel with several gorutins is not far the only way to write concurrent programs, so this case is not as frequent as it may seem at first. </p><br><p>  Let's see how this is done. </p><br><h1 id="map--syncmutex">  Map + sync.Mutex </h1><br><p>  Implementing a thread-safe map is very simple - we create a new data structure and embed a mutex into it.  The structure can be called whatever you like - even MyMap, but it makes sense to give it a meaningful name - most likely you are solving a specific task. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Counters <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { sync.Mutex m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  You don't need to initialize a mutex, its "zero value" is a unlocked mutex ready for use, and map is still needed, so it will be convenient (but not necessary) to create a constructor function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewCounters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counters</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Counters{ m: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), } }</code> </pre> <br><p>  Now the variable type Counters will have a <code>Lock()</code> and <code>Unlock()</code> method, but if we want to simplify our life and use this type from other packages, it will also be convenient to make wrapper functions like <code>Load()</code> and <code>Store()</code> .  In this case, you can not embed a mutex, but simply make it a ‚Äúprivate‚Äù field: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Counters <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mx sync.Mutex m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Counters)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { c.mx.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> c.mx.Unlock() val, ok := cm[key] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val, ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Counters)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { c.mx.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> c.mx.Unlock() cm[key] = value }</code> </pre> <br><p>  Here you need to pay attention to two points: </p><br><ul><li>  <code>defer</code> has a small overhead (about 50-100 nanoseconds), so if you have a code for a highly loaded system and 100 nanoseconds matter, then it may be more advantageous not to use <code>defer</code> </li><li>  <code>Get()</code> and <code>Store()</code> methods must be defined for the pointer to <code>Counters</code> , not to <code>Counters</code> (ie, not <code>func (c Counters) Load(key string) int { ... }</code> , because in this case the value of the receiver ( <code>c</code> ) it is copied, with which the mutex in our structure is copied, which deprives the whole idea of ‚Äã‚Äãmeaning and leads to problems. </li></ul><br><p>  You can also, if necessary, define the <code>Delete()</code> and <code>Range()</code> methods to protect the map mutex during deletion and iteration over it. </p><br><p>  By the way, pay attention, I intentionally write ‚Äúif needed‚Äù, because you always solve a specific task and in each specific case you can have different usage profiles.  If you do not need <code>Range()</code> - do not waste time on its implementation.  When you need - you can always add.  Keep it simple. </p><br><p>  Now we can easily use our secure data structure: </p><br><pre> <code class="go hljs">counters := NewCounters() counters.Store(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>) v, ok := counters.Load(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>)</code> </pre> <br><p>  Depending, again, on a specific task, you can make any method convenient for you.  For example, for counters it is convenient to do an increase in value.  With a regular map, we would do something like: </p><br><pre> <code class="go hljs">counters[<span class="hljs-string"><span class="hljs-string">"habr"</span></span>]++</code> </pre> <br><p>  and for our structure we can make a separate method: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Counters)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { c.mx.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> c.mx.Unlock() cm[key]++ } ... counters.Inc(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>)</code> </pre> <br><p>  But often, working with data in the "key" format is "value", the access pattern is uneven - either a frequent entry and a rare reading, or vice versa.  A typical case is that update is rare, and iteration (range) over all values ‚Äã‚Äãis often.  Reading, as we remember, from the map is safe, but now we‚Äôll latch on to each read operation, losing without much benefit the time to wait for unlocking. </p><br><h1 id="syncrwmutex">  sync.RWMutex </h1><br><p>  In the standard library for solving this situation there is a type <a href="https://golang.org/pkg/sync/">sync.RWMutex</a> .  In addition to <code>Lock()/Unlock()</code> , RWMutex has some similar read-only methods - <code>RLock()/RUnlock()</code> .  If the method needs only reading, it uses <code>RLock()</code> , which does not block other read operations, but blocks the write operation and vice versa.  Let's update our code: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Counters <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mx sync.RWMutex m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Counters)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { c.mx.RLock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> c.mx.RUnlock() val, ok := cm[key] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val, ok }</code> </pre> <br><p>  <code>map+sync.RWMutex</code> are almost a standard for <code>map+sync.RWMutex</code> that should be used from various Gorutin.  They are very fast. </p><br><p>  Until you have 64 cores and a large number of simultaneous reads. </p><br><h1 id="cache-contention">  Cache contention </h1><br><p>  If you look at <a href="">the sync.RWMutex code</a> , you can see that when locking for reading, each goroutin must update the <code>readerCount</code> field - a simple counter.  This is done atomically using the function from the <a href="https://golang.org/pkg/sync/atomic">sync / atomic</a> <a href="https://golang.org/pkg/sync/atomic/">atomic.AddInt32 ()</a> package.  These functions are optimized for the architecture of a specific processor and <a href="">implemented in assembly language</a> . </p><br><p>  When each processor core updates the counter, it resets the cache for this address in memory for all other cores and announces that it has the actual value for this address.  The next kernel, before updating the counter, must first subtract this value from the cache of another kernel. </p><br><p>  On modern hardware, the transfer between the L2 cache takes about 40 nanoseconds.  This is not much, but when many cores are simultaneously trying to update the counter, each of them stands in a queue and waits for this invalidation and subtraction from the cache.  An operation that must be stacked at a constant time suddenly becomes O (N) by the number of cores.  This problem is called <em>cache contention</em> . </p><br><p>  Last year issue issue tracker Go created <a href="https://github.com/golang/go/issues/17973">issue # 17973</a> to this RWMutex problem.  The benchmark below shows an almost 8-fold increase in time on RLock () / RUnlock () on a 64-nuclear machine as the number of Gorutin actively "reading" increases (using RLock / RUnlock): </p><br><p><img src="https://habrastorage.org/web/1f0/f9d/89a/1f0f9d89aacb4bfa8866219621f5a996.png"></p><br><p>  And this is a benchmark on the same amount of gorutin (256) as the number of cores increases: </p><br><p><img src="https://habrastorage.org/web/f67/7d2/e57/f677d2e57a1f4949b1f543e0263ca156.png"></p><br><p>  As you can see, the obvious linear dependence on the number of processor cores involved. </p><br><p>  In the standard library, maps are used in quite a few places, including packages such as <code>encoding/json</code> , <code>reflect</code> or <code>expvars</code> and the problem described may lead to not very obvious slowdowns in higher-level code that does not directly use map + RWMutex, but , for example, uses reflect. </p><br><p>  Actually, to solve this problem, cache contention in the standard library was added sync.Map. </p><br><h1 id="syncmap">  sync.Map </h1><br><p>  So, I‚Äôll emphasize again - sync.Map solves the very specific cache contention problem in the standard library for those cases where the keys in the map are stable (not updated often) and there are a lot more reads than records. </p><br><p>  <strong>If you have not clearly identified a bottleneck in your program due to cache contention in map + RWMutex, then most likely you will not get any benefit from <code>sync.Map</code> , and you may even lose a little in speed.</strong> </p><br><p>  Well, if all the same it is your case, then let's see how to use the sync.Map API.  And it is surprisingly simple to use it - almost 1-in-1 our code before: </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// counters := NewCounters() &lt;-- var counters sync.Map</span></span></code> </pre> <br><p>  Record: </p><br><pre> <code class="go hljs"> counters.Store(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><p>  Reading: </p><br><pre> <code class="go hljs"> v, ok := counters.Load(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>)</code> </pre> <br><p>  Uninstall: </p><br><pre> <code class="go hljs"> counters.Delete(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>)</code> </pre> <br><p>  When reading from sync.Map, you will probably also need to cast to the desired type: </p><br><pre> <code class="go hljs">v, ok := counters.Load(<span class="hljs-string"><span class="hljs-string">"habr"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { val = v.(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) }</code> </pre> <br><p>  In addition, there is the <a href="">LoadAndStore ()</a> method, which returns the existing value, and if it doesn‚Äôt, it stores a new value, and <a href="https://golang.org/pkg/sync/">Range ()</a> , which takes a function argument for each iteration step: </p><br><pre> <code class="go hljs"> v2, ok := counters.LoadOrStore(<span class="hljs-string"><span class="hljs-string">"habr2"</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>)</code> </pre> <br><pre> <code class="go hljs"> counters.Range(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(k, v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"key:"</span></span>, k, <span class="hljs-string"><span class="hljs-string">", val:"</span></span>, v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">// if false, Range stops })</span></span></code> </pre> <br><p>  The API is driven solely by usage patterns in the standard library.  Now <code>sync.Map</code> used in encoding / {gob / xml / json}, mime, archive / zip, reflect, expvars, net / rpc packages. </p><br><p>  By performance, sync.Map guarantees a constant access time to the map, regardless of the number of simultaneous reads and the number of cores.  Up to 4 cores, <code>sync.Map</code> with a large number of parallel readings, can be significantly slower, but after that it starts to beat map + RWMutex: </p><br><p><img src="https://habrastorage.org/web/fc8/179/905/fc81799050554f20a7b28314b68afe47.png"></p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Summarizing - <code>sync.Map</code> is not a universal implementation of a non-blocking map structure for all occasions.  This implementation is for a specific usage pattern for, primarily, the standard library.  If your pattern matches this and you clearly know that the bottleneck in your program is cache contention on <code>map+sync.RWMutex</code> - feel free to use sync.Map.  Otherwise, <code>sync.Map</code> is unlikely to help you. </p><br><p>  If you are just too lazy to write a map + RWMutex wrapper and high performance is not critical at all, but you need a thread-safe map, then <code>sync.Map</code> can also be a good option.  But don't expect too much from sync.Map for all cases. </p><br><p>  Also other implementations of hash-tables, for example, on lock-free algorithms, may be more suitable for your case.  Such packages were long ago, and the only reason why sync.Map is in the standard library is its active use by other packages from the standard library. </p><br><h1 id="ssylki">  Links </h1><br><ul><li>  <a href="https://golang.org/pkg/sync/">https://golang.org/pkg/sync/#Map</a> </li><li>  <a href="https://github.com/golang/go/issues/17973">https://github.com/golang/go/issues/17973</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DC1EtfDnsdDs">https://www.youtube.com/watch?v=C1EtfDnsdDs</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DTl7mi9QmLns">https://www.youtube.com/watch?v=Tl7mi9QmLns</a> </li><li>  <a href="https://medium.com/%40deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c">https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338718/">https://habr.com/ru/post/338718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338704/index.html">On the classification of Fourier transform methods by examples of their software implementation by means of Python</a></li>
<li><a href="../338710/index.html">Energy efficient data center: familiarity with international experience</a></li>
<li><a href="../338712/index.html">Kali Linux: system protection and monitoring exercises</a></li>
<li><a href="../338714/index.html">How to get to ITMO University Technopark</a></li>
<li><a href="../338716/index.html">As we celebrated 256 day of the year and drew pixels through the API</a></li>
<li><a href="../338720/index.html">Use PubNub: Emotional Talking Chat Do It Yourself</a></li>
<li><a href="../338722/index.html">The second version of the Air Quality Monitor</a></li>
<li><a href="../338724/index.html">How to build a self-managed business: formulating the ‚Äúlaws of robotics‚Äù Hamster Marketplace</a></li>
<li><a href="../338730/index.html">IT events digest for October</a></li>
<li><a href="../338732/index.html">Performance: what's in my name? - Alexey Shipilev about optimization in large projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>