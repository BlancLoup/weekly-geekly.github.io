<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Union Arduino and classic processor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retrocomputers are of varying degrees of fastidiousness. Some are content with emulation. Others prefer FPGA, because then it turns out not emulation,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Union Arduino and classic processor</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/8r/yr/ol8ryrltwjene6e2frje_pacnti.jpeg"></div><br>  Retrocomputers are of varying degrees of fastidiousness.  Some are content with emulation.  Others prefer FPGA, because then it turns out not emulation, but re-creation.  Finally, give the third a real processor. <br><br>  But the processor needs so much to work!  Again, the dilemma: to take real microcircuits of the same years, or put everything in the FPGA, leaving the processor outside?  However, why must FPGA?  Long live the union of Arduino and the classic processor! <a name="habracut"></a><br><br>  Give your Arduino a ‚Äúsecond brain‚Äù and make it ‚Äúsmarter‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This eight-bit microprocessor executes programs, and the Arduino emulates ROM, RAM, and simple peripherals. <br><br>  Design the virtual peripherals in the Arduino IDE, and on the microprocessor, run the code in assembler.  No need to collect complex schemes and flash parallel ROMs. <br><br>  Supported microprocessors: 6502, 6809 and Z80 (18581), others are on the way. <br><br>  Shield with a microprocessor does not interfere with connecting other shields: with LCD, memory cards, etc. <br><br>  In addition to independent programming in assembler, you can try to run on a microprocessor some classic code. <br><br>  True, the microprocessor will operate at a very small frequency - about 95 kHz, its exact value depends on the optimization of the peripheral emulation code. <br><br>  The distribution of the address space is set programmatically in the sketch.  The microprocessor can allocate from 4 to 6 KB of RAM of 8 KB, available on the Arduino Mega.  ROM can be allocated more than 200 KB of the existing 256. <br><br>  Using the Arduino Mega serial port, you can emulate a UART. <br><br>  Schemes, circuit boards, Gerber files are available under CC-BY-SA 4.0 <a href="https://gitlab.com/8bitforce/retroshield-hw">here</a> .  In this case, there is a requirement to necessarily attach the file README.md, because it contains the following warning: <br><blockquote>  Do not connect the shield until it is filled with a sketch of emulation of the periphery!  Otherwise it is possible to short the output lines of the microprocessor. </blockquote>  Yes, and in the sketch itself, something needs to be redone carefully for the same reason. <br><br>  Diagram of the device at 6502: <br><br><img src="https://habrastorage.org/webt/e0/n8/6k/e0n86kpozlcttklifjihnl51quo.png"><br><br>  Diagram of the device at 6809: <br><br><img src="https://habrastorage.org/webt/qf/yi/kx/qfyikx1tktdjuad0hocivlpsolw.png"><br><br>  Diagram of the device on the Z80: <br><br><img src="https://habrastorage.org/webt/ct/uh/qs/ctuhqskjmmp1rvxrhs8abcoqvne.png"><br><br>  Already you can run: <br><br>  On a device with 6502 - <a href="https://gitlab.com/8bitforce/retroshield6502">Apple I, Woz Monitor + ROM with BASIC</a> <br><br>  On a device with 6809 - <a href="https://gitlab.com/8bitforce/retroshield6809">Analogue of the self-made computer Simon6809 of the same developer, a training monitor with assembler and disassembler</a> <br><br>  On the device with the Z80, for the time being, only <a href="https://gitlab.com/8bitforce/retroshieldz80">a serial port echo test</a> allows you to test the operability of the virtual 8251 (58051). <br><br>  Peripheral emulation firmware - MIT licensed. <br><br>  Brief descriptions of the principle of action: <br><br>  <a href="http://www.8bitforce.com/blog/2019/03/12/retroshield-6502-operation/">To device on 6502</a> <br><br>  <a href="http://www.8bitforce.com/blog/2019/03/12/retroshield-6809-operation/">To device on 6809</a> <br><br>  To the device on the Z80 - in preparation. <br><br>  The developer is trying to <a href="http://www.8bitforce.com/store/">sell the</a> device, but with delivery only in the USA.  It makes no sense to buy, because the scheme is very simple, you can repeat it on a piece of the layout in an hour. <br><br>  The development of similar boards for RCA1802, 68008, 8085 (KR1821VM85A), 8088 (KR1810VM88) is planned.  About K1801VM1 not said, but you can throw the author such an idea. <br><br>  Files: <br><br>  To the device on 6502: <a href="https://cdn.hackaday.io/files/1645567040363904/RetroShield6502_Assembly_Instructions_RevA.pdf">assembly instructions</a> , <a href="">screen printing</a> , <a href="https://cdn.hackaday.io/files/1645567040363904/k6502_sch.pdf">scheme</a> <br><br>  To the device at 6809: <a href="https://cdn.hackaday.io/files/1645567040363904/RetroShield6809E_Assembly_Instructions_RevA.pdf">assembly instructions</a> , <a href="">screen printing</a> , <a href="https://cdn.hackaday.io/files/1645567040363904/k6809e_sch.pdf">scheme</a> <br><br>  To the device on the Z80: <a href="https://cdn.hackaday.io/files/1645567040363904/RetroShieldZ80_Assembly_Instructions_RevA.pdf">assembly instructions</a> , <a href="">screen printing</a> , <a href="https://cdn.hackaday.io/files/1645567040363904/kz80_sch.pdf">scheme</a> <br><br>  Consider the interaction of the Arduino and the device at 6502. Arduino periodically changes the level at the input of the microprocessor, designed to supply clock pulses, from zero to one and back.  At each time it checks what is happening on the control lines and the address bus, and, depending on the situation, it reads information from the data bus or sends it there.  Arduino can also control IRQ and NMI lines, causing interrupts.  The figure shows the types of data and their direction of transmission: <br><br><img src="https://habrastorage.org/webt/tr/in/je/trinjeibi9cwwrngfq628lm4yns.png"><br><br>  Conformity of ports Arduino and conclusions of the microprocessor is configured in the sketch: <br><br><pre><code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_RW_N 40 #define uP_RDY 39 #define uP_SO_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_E 52 #define uP_GPIO 53</code> </pre> <br>  We divide each measure into the following events: <br><br>  CLK changes state from one to zero (decay) <br>  CLK is in zero state <br>  CLK changes state from one to zero (increment) <br>  CLK is in unit state <br>  CLK changes state from one to zero again ... <br><br>  What happens at the time of the change of states? <br><br>  6502 receives clock pulses at the CLK0 input, buffers them and sends them to two outputs: CLK1 and CLK2.  Although in the microprocessor all events are tied to CLK1, we will assume that the delay is small and they are tied to CLK0 - the line through which the microprocessor receives clock pulses from the Arduino.  And call the signal just CLK. <br><br><img src="https://habrastorage.org/webt/9i/kq/hc/9ikqhcytwd4sjg6rwjnvmohgkvi.png"><br><br>  1. CLK changes state from one to zero. <br><br>  2. The microprocessor outputs the new address to the address bus, and the R / W output - a switching signal between reading and writing.  But he is not yet ready to exchange data. <br><br>  3. CLK enters the state of one, and this means that the exchange of data has begun.  If this is a read operation, the microprocessor transfers the data bus pins to the input state and receives the data, and if the write operation translates them to the output state and sends the data.  And the R / W signal switches the external device to write or read mode, opposite to the corresponding state of the microprocessor. <br><br>  4. CLK goes to zero state.  Now neither the microprocessor nor the I / O devices output anything to the data bus.  The microprocessor can set the data bus line and R / W pin to a new state. <br><br>  A simple explanation, understandable and child.  Who will never think about these "backstage intrigues", if only microcontrollers are programmed.  Even in assembly language. <br><br>  If you need to connect your peripheral device, it must have time to prepare the data before the unit appears on the CLK line (preparation time), but for now there is one unit - not to change them.  If the peripheral device does not have time to prepare the data, until the CLK is zero, or it changes it when there is one, you will long wonder why your code is not working.  Since the microprocessor clock frequency here is ten to fifteen times lower than the nominal one, it is easy to comply with this requirement.  But it is necessary. <br><br>  So, you need to ‚Äúteach‚Äù Arduino to generate clock pulses, continuously checking what happens on the address bus and the R / W line, and interacting with the data bus accordingly.  To do this, the timer timer interrupt is activated in the sketch, generating pulses with a frequency of 95 kHz.  Arduino works much faster than a microprocessor, and therefore it has time to read and prepare everything between its cycles.  It is important to ensure that after modifying the sketch this condition continues to be observed. <br><br>  Here is an excerpt from the sketch, which makes it clear how the CLK goes from zero to one, and what happens next: <br><br><pre> <code class="plaintext hljs">//////////////////////////////////////////////////////////////////// // Processor Control Loop //////////////////////////////////////////////////////////////////// // This is where the action is. // it reads processor control signals and acts accordingly. // ISR(TIMER1_COMPA_vect) { // Drive CLK high CLK_E_HIGH; // Let's capture the ADDR bus uP_ADDR = ADDR; if (STATE_RW_N) ////////////////////////////////////////////////////////////////// // HIGH = READ transaction { // uP wants to read so Arduino to drive databus to uP: DATA_DIR = DIR_OUT; // Check what device uP_ADDR corresponds to: // ROM? if ( (ROM_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= ROM_END) ) DATA_OUT = pgm_read_byte_near(rom_bin + (uP_ADDR - ROM_START)); else if ( (BASIC_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= BASIC_END) ) DATA_OUT = pgm_read_byte_near(basic_bin + (uP_ADDR - BASIC_START)); else // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) DATA_OUT = RAM[uP_ADDR - RAM_START]; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } else ////////////////////////////////////////////////////////////////// // R/W = LOW = WRITE { // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) RAM[uP_ADDR - RAM_START] = DATA_IN; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } //////////////////////////////////////////////////////////////// // We are done with this cycle. // one full cycle complete clock_cycle_count ++; // start next cycle CLK_E_LOW; // If Arduino was driving the bus, no need anymore. // natural delay for DATA Hold time after CLK goes low (t_HR) DATA_DIR = DIR_IN; }</code> </pre> <br>  The distribution of the address space can be done in any way; in an unmodified sketch, it is the same as in Apple 1 with 256 bytes of ROM, 8 kilobytes of ROM for BASIC, 4 kilobytes of RAM and an input-output device 6821. <br><br><pre> <code class="plaintext hljs">// MEMORY LAYOUT // 4K MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF byte RAM[RAM_END-RAM_START+1]; // ROMs (Monitor + Basic) #define ROM_START 0xFF00 #define ROM_END 0xFFFF #define BASIC_START 0xE000 #define BASIC_END 0xEFFF //////////////////////////////////////////////////////////////////// // Woz Monitor Code //////////////////////////////////////////////////////////////////// // PROGMEM const unsigned char rom_bin[] = { 0xd8, 0x58, 0xa0, 0x7f, 0x8c, 0x12, 0xd0, 0xa9, 0xa7, 0x8d, 0x11, 0xd0, ... 0x00, 0xff, 0x00, 0x00 }; // BASIC ROM starts at E000 PROGMEM const unsigned char basic_bin[] = { 0x4C, 0xB0, 0xE2, 0xAD, 0x11, 0xD0, 0x10, 0xFB, ... 0xE0, 0x80, 0xD0, 0x01, 0x88, 0x4C, 0x0C, 0xE0 };</code> </pre> <br>  RAM is emulated by the byte RAM array [RAM_END-RAM_START + 1].  Two PROGMEM keywords are needed so that the contents of the emulated ROMs are stored in the flash memory of the microcontroller. <br><br>  6821 is emulated sufficiently so that the virtual keyboard and display work through the terminalku.  Woz Monitor and BASIC work, which the author wanted. <br><br>  To emulate any peripheral device, you need to carefully read its datasheet and find out what registers it has and what they are for.  The convenience of emulation is in the flexibility with which software analogs of the periphery can be made. <br><br>  I / O devices are located in the address space of the microprocessor, they are accessed in the same way as memory cells.  To use "iron" peripherals, such as LCD display, memory card, sound output, you need to allocate them a place in the address space. <br><br>  References: <br><br>  <a href="http://www.6502.org/">www.6502.org</a> <br>  <a href="http://www.callapple.org/soft/ap1/emul.html">www.callapple.org/soft/ap1/emul.html</a> <br>  <a href="https://skilldrick.github.io/easy6502/">skilldrick.github.io/easy6502</a> <br>  <a href="http://searle.hostei.com/grant/6502/Simple6502.html">searle.hostei.com/grant/6502/Simple6502.html</a> <br>  <a href="http://wilsonminesco.com/6502primer/">wilsonminesco.com/6502primer</a> <br>  SB-Assembler: <a href="https://www.sbprojects.net/sbasm/">www.sbprojects.net/sbasm</a> <br><br>  Go to 6809, it has: <br><br>  Two eight-bit batteries A and B, which can be combined into one six-bit battery <br>  Two 16-bit index stack pointers <br>  Addressing the team counter <br>  Automatic addition or subtraction of the number 1 or 2 <br>  Multiplication of two eight-bit unsigned numbers <br>  16-bit arithmetic <br>  Transfer and exchange of data between all registers <br>  Record and read all registers and any combination of them <br><br>  The microprocessor 6809E (external) needs an external clock, in 6809 it is internal.  In Hitachi, they are called, respectively, 6309E and 6309, they differ from the usual ones in that they perform operations inside the 32-bit form, but it is possible to switch to compatibility mode with the classic version. <br><br>  Actually, the whole project of RetroShield started because the author wanted to upgrade his own self-made computer Simon6809 and name the result Simon6809 Turbo.  But it turned out that standard logic chips for everything he wanted to implement there would have required a lot.  Therefore, the author first formulated the idea of ‚Äã‚ÄãRetroShield for the 6809, and only then thought: ‚Äúwhat if you do the same with other processors?‚Äù. <br><br>  The device, of course, used 6809E, which requires an external clock generator, so that you can synchronize its work from the outside.  Lines E and Q are the same for both processors, only 6809 have outputs, and 6809E have inputs. <br><br>  With the 6809, the Arduino interacts the same way as with the 6502, but it has two clock inputs: E and Q, and three interrupt inputs: IRQ, FIRQ and NMI. <br><br><img src="https://habrastorage.org/webt/0i/uk/dn/0iukdn25vkrhbsvd8spjlhr-s3q.png"><br><br>  This time the matching of the Arduino ports and the microprocessor pins is configured as: <br><br><pre> <code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_E 52 #define uP_Q 53 #define uP_RW_N 40 #define uP_FIRQ_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_GPIO 39</code> </pre> <br>  As can be seen from the graphs, the signal Q is shifted relative to E by a quarter of the period: <br><br>  We almost will not pay attention to Q, since all events are tied to E. And everything happens like this: <br><br><img src="https://habrastorage.org/webt/ao/hj/qv/aohjqvkk89mbouy7_njtjqbz3ku.png"><br><br><ol><li>  E switches to zero.  The processor places a new address on the address bus and changes the state of the R / W line. </li><li>  E switches to one, the processor becomes ready for data exchange. </li><li>  It doesn‚Äôt matter what happens with the data bus, as long as there is a E unit, the main thing is that the required data is present there at the moment E goes back to zero. </li><li>  When reading data, the I / O device must supply the required data to the data bus before line E goes from one to zero (the minimum delay is indicated by the number 17 in a circle). </li><li>  When writing, the I / O device must record the data in some register as it was at the moment E goes from one to zero.  The processor will supply this data on the bus even earlier - at the moment Q goes to the unit (the number 20 in a circle). </li><li>  After the transition E to zero, everything repeats. </li></ol><br>  All of the above about 6502 about the need for a peripheral device (including virtual) to generate all signals in time also concerns 6809. <br><br>  Generation of signals E and Q, as in the case of 6502, with the only difference that the signals are two, and they must be switched in accordance with the graphs.  And in the same way, a subroutine called by an interrupt performs data input or output at the required moments. <br><br>  The address space in the unmodified sketch is distributed in the same way as in the homemade <a href="http://www.8bitforce.com/projects/simon6809/">Simon6809</a> computer: <br><br><pre> <code class="plaintext hljs">// MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF #define ROM_START 0xE000 #define ROM_END 0xFFFF byte RAM[RAM_END-RAM_START+1]; //////////////////////////////////////////////////////////////////// // Monitor Code //////////////////////////////////////////////////////////////////// // static const unsigned char PROGMEM const unsigned char simon09_bin[] = { 0x1a, 0xff, 0x4f, 0x1f, 0x8b, 0x0f, 0x36, 0x7f, 0x01, 0xa5, 0x10, 0xce, ... 0x00, 0x09, 0x00, 0x0c, 0x00, 0x0f, 0xe0, 0x00 };</code> </pre> <br>  RAM and ROM are stored in arrays in the same way as in the 6502 version, with the only difference being that there is one array with ROM data. <br><br>  I / O devices are also allocated areas of the address space, and they can be both virtual and real.  Since Simon6809 is a modern machine on a vintage element base, with a PC running the terminal, it communicates via FTDI.  Here it is emulated. <br><br>  References: <br><br>  A lot of information on 6809 on the <a href="http://atjs.mbnet.fi/mc6809/">Arto Page</a> <br>  <a href="https://en.wikipedia.org/wiki/Motorola_6809">Wikipedia article on 6809</a> <br>  <a href="http://www.swtpcemu.com/swtpc/default.htm">SWTPc 6809 systems</a> <br>  <a href="https://en.wikipedia.org/wiki/FLEX_(operating_system)">Wikipedia article on the FLEX operating system</a> </div><p>Source: <a href="https://habr.com/ru/post/446048/">https://habr.com/ru/post/446048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446038/index.html">A short guide to the creation of oracles, the gods of the car and the errors of the second kind</a></li>
<li><a href="../446040/index.html">FullStek Confession: Profession, Religion, Dreams</a></li>
<li><a href="../446042/index.html">DJI Mavic 2 Pro after half a year of use</a></li>
<li><a href="../446044/index.html">Do not be afraid to try, or How I became a programmer at an age far beyond 29</a></li>
<li><a href="../446046/index.html">Expansion of the Universe - the greatest misconception in the history of science</a></li>
<li><a href="../446052/index.html">Creating a voice & tone for your product</a></li>
<li><a href="../446054/index.html">Backup at the ready: destroying myths in honor of the holiday</a></li>
<li><a href="../446058/index.html">How to build SDN - eight open source tools</a></li>
<li><a href="../446060/index.html">Synthesis of high molecular dreams</a></li>
<li><a href="../446062/index.html">Quo vadis. Developer Bans on Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>