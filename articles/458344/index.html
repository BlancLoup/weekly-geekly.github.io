<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use asynchronous messaging to improve accessibility</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrozhiteli! We recently commissioned a book by Chris Richardson to the print shop, the goal of which is to teach us how to successfully develop ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use asynchronous messaging to improve accessibility</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/ru/company/piter/blog/458344/"><img src="https://habrastorage.org/webt/hz/bw/dj/hzbwdju5aq8nv9xbromr1vbgdsi.jpeg" align="left" alt="image"></a>  Hi, Habrozhiteli!  We recently commissioned a book by <a href="https://www.amazon.com/Chris-Richardson/e/B00MBVFJHU/ref%3Ddp_byline_cont_book_1">Chris Richardson</a> to the print shop, the goal of which is to teach us how to successfully develop applications using microservice architecture.  The book discusses not only the advantages, but also the disadvantages of microservices.  You will learn in what situations it makes sense to apply them, and when it is better to think about a monolithic approach. <br><br>  The focus of the book is on architecture and design.  It is designed for anyone whose responsibilities include writing and delivering software, including developers, architects, technical directors and heads of development departments. <br><br>  Below is an excerpt from the book "Using asynchronous messaging" <br><a name="habracut"></a><br><h3>  Use asynchronous messaging to improve accessibility </h3><br>  As you have seen, the various IPC mechanisms are pushing you to various compromises.  One of these is related to how the IPC mechanism affects accessibility.  In this section, you will learn that synchronous interaction with other services as part of request processing reduces the availability of an application.  In this regard, when designing your services, you should use asynchronous messaging whenever possible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, let's see what problems synchronous interaction creates and how it affects accessibility. <br><br><h3>  3.4.1.  Synchronized communication reduces availability </h3><br>  REST is an extremely popular IPC mechanism.  You may be tempted to use it for interservice interactions.  But the problem with REST is that it is a synchronous protocol: the HTTP client has to wait until the service returns a response.  Every time when services communicate with each other over a synchronous protocol, it reduces the availability of the application. <br><br>  To understand why this is happening, consider the scenario presented in Fig.  3.15.  The Order service has a REST API for creating orders.  To check the order, he refers to the Consumer and Restaurant services, which also have a REST API. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pn/uq/22/pnuq22tmdzqdhbr_wxa9nuntoeq.png" alt="image"></div><br>  Creating an order consists of such a sequence of steps. <br><br><ol><li>  The client makes an HTTP POST / orders request to the Order service. </li><li>  The Order service retrieves customer information by performing an HTTP GET / consumers / id request to the Consumer service. </li><li>  The Order service retrieves restaurant information by executing an HTTP GET / restaurant / id request to the Restaurant service. </li><li>  Order Taking verifies the request, using information about the customer and the restaurant. </li><li>  Order Taking creates an order. </li><li>  Order Taking sends an HTTP response to the client. </li></ol><br>  Since these services use HTTP, all of them must be available for the FTGO application to process the CreateOrder request.  It will not be able to create an order if at least one of the services is unavailable.  From a mathematical point of view, the availability of a system operation is a product of the availability of the services that are involved in it.  If the Order service and the two services it calls have 99.5% availability, then their overall availability will be 99.5% 3 = 98.5%, which is much lower.  Each subsequent service involved in the request makes the operation less accessible. <br><br>  This issue is not unique to REST-based communication.  Availability is reduced whenever a service must receive responses from other services to respond to a client.  It does not help even the transition to the style of interaction "request / response" on top of asynchronous messages.  For example, if the Order service sends a message to the Consumer service through a broker and starts to wait for a response, its availability will deteriorate. <br><br>  If you want to maximize availability, minimize the amount of synchronous interaction.  Let's see how to do it. <br><br><h3>  3.4.2.  Disposal of synchronous interaction </h3><br>  There are several ways to reduce the amount of synchronous interaction with other services when processing synchronous requests.  First, to completely avoid this problem, all services can be provided exclusively with asynchronous APIs.  But this is not always possible.  For example, public APIs generally adhere to the REST standard.  Therefore, some services are required to have synchronous APIs. <br><br>  Fortunately, in order to process synchronous requests, it is not at all necessary to execute them yourself.  Let's talk about such options. <br><br>  <b>Using asynchronous interaction styles</b> <br><br>  Ideally, all interaction should occur in the asynchronous style described earlier in this chapter.  Imagine, for example, that an FTGO application client uses an asynchronous request / asynchronous response style to create orders.  To create an order, it sends a message requesting the Order service.  Then this service asynchronously exchanges messages with other services and eventually returns the answer to the client (Fig. 3.16). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/j3/px/7ej3pxinlckogxf4ga0fmjaxtmu.png" alt="image"></div><br>  The client and service communicate asynchronously, sending messages through the channels.  None of the participants in this interaction is blocked in anticipation of a response. <br><br>  Such an architecture would be extremely robust, because the broker buffers messages until their consumption becomes possible.  But the problem is that services often have an external API that uses a synchronous protocol like REST and, as a result, is obliged to immediately respond to requests. <br><br>  If the service has a synchronous API, accessibility can be improved by replicating data.  Let's see how it works. <br><br>  <b>Data replication</b> <br><br>  One way to minimize synchronous interaction during query processing is data replication.  The service stores a copy (replica) of data that it needs to process requests.  To keep the cue up to date, it subscribes to events posted by the services to which it belongs.  For example, the Order service may store a copy of data belonging to the Consumer and Restaurant services.  This will allow it to process requests to create orders without accessing these services.  This architecture is shown in Fig.  3.17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p9/vz/zs/p9vzzssvlgjr7xx3efpsyjtesly.png" alt="image"></div><br>  Services Consumer and Restaurant publish events whenever their data changes.  The Order service subscribes to these events and updates its replica. <br><br>  In some cases, data replication is a good solution.  For example, chapter 5 describes how the Order service replicates data from the Restaurant service in order to be able to check menu items.  One of the drawbacks of this approach is that sometimes it requires copying large amounts of data, which is inefficient.  For example, if we have many customers, storing a replica of data belonging to the Consumer service may not be practical.  Another disadvantage of replication lies in the fact that it does not solve the problem of updating data belonging to other services. <br><br>  To solve this problem, the service may delay the interaction with other services until it responds to its client.  This will be discussed further. <br><br>  <b>Completion of processing after returning the answer</b> <br><br>  Another way to eliminate synchronous interaction during query processing is to perform this processing in the following steps. <br><br><ol><li>  The service only checks the request with data available locally. </li><li>  It updates its database, including adding messages to the OUTBOX table. </li><li>  Returns the answer to its client. </li></ol><br>  During the processing of a request, the service does not communicate synchronously with any other services.  Instead, he sends them asynchronous messages.  This approach provides a weak connectivity of services.  As you will see in the next chapter, this process is often implemented in the form of narration. <br><br>  Imagine that the Order service is acting like this.  It creates an order with a PENDING state and then checks it, exchanging asynchronous messages with other services.  In fig.  Figure 3.18 shows what happens when the createOrder () operation is called.  The chain of events looks like this. <br><br><ol><li>  The Order service creates an order with a PENDING state. </li><li>  The Order service returns to the client a response with the order ID. </li><li>  The Order Service sends a message ValidateConsumerInfo to the Consumer service. </li><li>  Service Order Sends a ValidateOrderDetails message to the Restaurant service. </li><li>  The Consumer service receives a ValidateConsumerInfo message, checks if the customer can place an order, and sends a ConsumerValidated message to the Order service. </li><li>  The Restaurant service receives the message ValidateOrderDetails, checks the correctness of the menu items and the ability of the restaurant to deliver the order to the specified address, and sends the OrderDetailsValidated message to the Order service. </li><li>  The Order service receives messages ConsumerValidated and OrderDetailsValidated and changes the order status to VALIDATED. </li></ol><br>  And so on‚Ä¶ <br><br>  The Order Service may receive the ConsumerValidated and OrderDetailsValidated messages in any order.  To know which one he got first, he changes the order status.  If the first message came ConsumerValidated, the order status changes to CONSUMER_VALIDATED, and if OrderDetailsValidated, it changes to ORDER_DETAILS_VALIDATED.  Upon receiving the second message, the Order service assigns the status VALIDATED to the order. <br><br>  After checking the order, the Order service performs the remaining steps to create it, which we will discuss in the next chapter.  A remarkable side of this approach is that the Order service will be able to create an order and respond to the customer, even if the Consumer service is unavailable.  Sooner or later, the Consumer service will recover and process all pending messages, which will allow you to complete the verification of orders. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/d2/e_/hvd2e_kioxghqoo4jwcyqroerk8.png" alt="image"></div><br>  The disadvantage of returning a response before the request is fully processed is that it makes the client more difficult.  For example, when the Order service returns an answer, it gives minimal guarantees about the status of the order just created.  He answers immediately, even before checking the order and authorizing the client‚Äôs bank card.  Thus, in order to find out whether the order has been successfully created, the client must periodically request information or the Order service must send him a notification message.  Despite the complexity of this approach, in many cases it is better to prefer it, especially because it takes into account problems with managing distributed transactions, which we discuss in Chapter 4. In Chapters 4 and 5 I will demonstrate this technique using the example of the Order service. <br><br><h3>  Summary </h3><br><ul><li>  Microservice architecture is distributed, therefore interprocess communication plays a key role in it. </li><li>  The development of the service API should be approached carefully and carefully.  The easiest way to make backward compatible changes is because they do not affect the customer experience.  When making breaking changes to the service API, it is usually necessary to maintain both the old and the new version until the clients update. </li><li>  There are many IPC technologies, each with its own advantages and disadvantages.  The key decision at the design stage is the choice between synchronous remote procedure calls and asynchronous messages.  The easiest to use are synchronous protocols like REST, based on a remote procedure call.  But ideally, to increase availability, services should interact using asynchronous messaging. </li><li>  To prevent an avalanche-like accumulation of system failures, a client using a synchronous protocol must be able to cope with partial failures ‚Äî that the called service is either unavailable or exhibits high latency.  In particular, when executing requests, you should count down the waiting time, limit the number of overdue requests, and use the ‚ÄúFuse‚Äù template to avoid appeals to a failed service. </li><li>  An architecture using synchronous protocols must contain a discovery mechanism so that clients can determine the network location of service instances.  The easiest way to stop is on the detection mechanism that the deployment platform provides: on the ‚ÄúServer-side detection‚Äù and ‚ÄúThird-party registration‚Äù templates.  An alternative approach is to implement application discovery at the application level: ‚ÄúClient-side Detection‚Äù and ‚ÄúSelf-Registration‚Äù patterns.  This method requires more effort, but is suitable for situations where services are running on multiple deployment platforms. </li><li>  The message and channel model encapsulates the details of the messaging system implementation and becomes a good choice when designing this type of architecture.  Later, you can bind your architecture to a specific messaging infrastructure, which usually uses a broker. </li><li>  The key difficulty in the exchange of messages associated with their publication and update the database.  A good solution is to use the ‚ÄúEvent Publishing‚Äù template: the message at the very beginning is written to the database as part of a transaction.  Then, a separate process retrieves the message from the database, using the "Interrogating Publisher" or "Transaction Log Tracking" template, and sends it to the broker. </li></ul><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/soon/product/mikroservisy-patterny-razrabotki-i-refaktoringa">the publisher site</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610996/978544610996_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610996/978544610996_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley 30% discount on pre-order book on coupon - <b>Microservices</b> </div><p>Source: <a href="https://habr.com/ru/post/458344/">https://habr.com/ru/post/458344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45833/index.html">Page-view pattern in javascript</a></li>
<li><a href="../458332/index.html">Asynchronous programming - async performance: understand the costs of async and await</a></li>
<li><a href="../458334/index.html">Continuous replication from old to new PostgreSQL using Slony</a></li>
<li><a href="../45834/index.html">SimpleModal - simple modal windows</a></li>
<li><a href="../458342/index.html">Texturing, or what you need to know to become an artist on surfaces. Part 1. Pixel</a></li>
<li><a href="../458346/index.html">Solution of the task with pwnable.kr 01 - fd. File Descriptors and Processes</a></li>
<li><a href="../458348/index.html">"Samsung Ecosystem" - the results of the competition</a></li>
<li><a href="../45835/index.html">Program development cycle</a></li>
<li><a href="../458350/index.html">Twitter's VS7.0-ER Dirty Electric Bike Review</a></li>
<li><a href="../458352/index.html">[Peter] Meeting JUG.ru with Cliff Click - A JVM Does That?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>