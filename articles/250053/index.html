<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why developers don't like Unit Tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maybe they just do not know how to "cook" them? 

 Intro 
 On duty, I participate in the development of applications for microcontrollers. But it so h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why developers don't like Unit Tests</h1><div class="post__text post__text-html js-mediator-article">  Maybe they just do not know how to "cook" them? <br><a name="habracut"></a><br><h2>  Intro </h2><br>  On duty, I participate in the development of applications for microcontrollers.  But it so happened that I was more involved in various kinds of testing (both my own and someone else's code) than, actually, in development.  Far from the first attempt, I managed to master TDD.  Now the volumes of the test and ‚Äúcombat‚Äù code more or less dwindled :) <br>  I hope that after reading this article the question ‚ÄúWhy not the first time?‚Äù Will be removed. <br><br><h2>  Data </h2><br>  In my professional activity, I often hear statements of the following nature: <br><ul><li>  ‚ÄúWhy are we going to spend time on unit tests, we don‚Äôt have time to complete the project on time?‚Äù </li><li>  ‚ÄúWhy do tests dictate how to write code?‚Äù </li><li>  ‚ÄúLet's just write the code, testers will find all the defects.  Then fix it. " </li><li>  ‚ÄúHere, colleagues have implemented a new feature, it is necessary to cover it with unit tests‚Äù </li></ul><br>  Even supporters of flexible development methodologies do not always understand the value of this type of testing.  Actually, article <a href="http://megamozg.ru/post/8666/">Agile from the point of view of the programmer</a> served as the trigger to this publication. <br><br><h2>  As it usually happens </h2><br>  Let's imagine that in the process of developing a certain system there was a need to implement a linked list.  For simplicity, I will limit myself to the functions of push and pop (FIFO) and an integer as payload. <br>  Without additional requirements for this list, we can expect that the experienced developer Maxim will first study the examples that are on the Internet and take one of them as a basis. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result, we have the following implementation: <br><div class="spoiler">  <b class="spoiler_title">my_list.h file</b> <div class="spoiler_text"><pre><code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MY_LIST_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_LIST_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NULL </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* just for this example */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NULL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> void list_push( int val ); int list_pop( void ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">my_list.c file</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"my_list.h"</span></span> #include &lt;stdlib.h&gt; typedef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span></span> { int val; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span></span> * next; } node_t; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> node_t * list_head; void list_push( int val ) { node_t * current = list_head; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(list_head == NULL) { list_head = malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(node_t)); list_head-&gt;val = val; list_head-&gt;next = NULL; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current-&gt;next != NULL) { current = current-&gt;next; } current-&gt;next = malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(node_t)); current-&gt;next-&gt;val = val; current-&gt;next-&gt;next = NULL; } } int list_pop( void ) { int retval = -<span class="hljs-number"><span class="hljs-number">1</span></span>; node_t * next_node = NULL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list_head == NULL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } next_node = list_head-&gt;next; retval = list_head-&gt;val; free(list_head); list_head = next_node; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br>  Well, the implementation is.  Integrated the code into the system, "clicked" everything works. <br>  Then someone remembers that linked lists are a very important matter, address arithmetic is there ... memory leaks ... And you should write unit tests, at least for this module - well, that would have been easy to save. <br>  And I‚Äôm almost 100% sure that this will be handled by another developer, Andrei.  Andrey is a novice developer and he just needs to gain experience.  And since the development of the system is not yet finished, the guys with experience still have something to do. <br><br>  Andrew: "And how to test it?" <br>  Maxim: ‚ÄúWell, look at the code, figure out how it is implemented, and cover all the code branches with tests so that you don‚Äôt miss anything‚Äù <br>  Andrei: ‚ÄúI want to start testing with the list_pop () function.  It allocates memory for a new item and adds it to the list.  But in the same place <b>static</b> and I cannot reach the list from the test code. " <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> * list_head; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list_push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> * current = list_head; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(list_head == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { list_head = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>)); list_head-&gt;val = val; list_head-&gt;next = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } ...</code> </pre><br>  Maxim: ‚ÄúOh, well, let me make a crutch especially for your tests.  In the production build it will not work, but it will help you.  Externally in the test and all. " <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> UNIT_TEST node_t * list_head; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> static node_t * list_head; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  It is natural to expect the following test implementation: <br><div class="spoiler">  <b class="spoiler_title">file test_my_list.c</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"unity.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"my_list.h"</span></span> void setUp(void) { } void tearDown(void) { } typedef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span></span> { int val; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span></span> * next; } node_t; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> node_t * list_head; void test_1( void ) { list_push( <span class="hljs-number"><span class="hljs-number">1</span></span> ); TEST_ASSERT_NOT_NULL( list_head ); <span class="hljs-comment"><span class="hljs-comment">/* Check that memory is allocated */</span></span> TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, list_head-&gt;val ); <span class="hljs-comment"><span class="hljs-comment">/* Check that value is set*/</span></span> TEST_ASSERT_NULL( list_head-&gt;next ); <span class="hljs-comment"><span class="hljs-comment">/* Check that the next pointer has appropriate value */</span></span> }</code> </pre><br></div></div><br>  I think the further expansion of the code coverage with new tests is obvious to the reader.  The result is achieved - the module is tested by unit-tests, the coverage is 100%.  You can sleep well. <br><br><h2>  What's wrong with that? </h2><br>  Of course, the story described above may have another development.  I'm just trying to say that unit tests are different. <br>  In this case, the tests have the following disadvantages: <br><ul><li>  Tests are testing the code (as strange as it sounds) </li><li>  Tests force the developer to do crutches </li><li>  Tests require titanic efforts to support them, even in the case of refactoring, not to mention significant changes. </li><li>  "Failed" tests do not mean at all that some kind of functionality does not work </li></ul><br><br><h2>  And if you first write tests, and then the code.  Will this help? </h2><br>  Unfortunately not.  Or not always. <br>  I am not an ardent supporter of the basic principle of TDD, forcing me to first write a test for non-existent code, and then write code in order for this test to pass.  Sometimes, I write a small piece of code before tests to it. <br><br>  The main thing is different.  It is very important, in my opinion, to consider each module as an independent system: <br><ul><li>  Try to formulate the requirements for this system, which it must meet </li><li>  It is the compliance with these requirements to try to test unit-tests. </li><li>  Try not to delve into the features of the implementation of this system and use only its external API for testing. </li></ul><br><br>  Someone will probably notice ‚Äúthis is BDD‚Äù.  And most likely will be right.  But, it does not matter what comes first in your development: tests, or behavior, or the code itself, which is already written very, very much.  It is important <b>how</b> you write unit tests. <br><br>  For example, the first test for the list implemented above may be: <br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* * Given the list is empty * When I push 1 to the list * Then the pop function shall return 1 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_simple</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { list_push( <span class="hljs-number"><span class="hljs-number">1</span></span> ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, list_pop() ); }</code> </pre><br>  Second test: <br><pre> <code class="hljs vbscript">/* * Given the list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> * When I push <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the list * <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> I push <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the list * <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> the first <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> of the pop <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> shall return <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">second</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> of the pop <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> shall return <span class="hljs-number"><span class="hljs-number">2</span></span> */ void test_order( void ) { list_push( <span class="hljs-number"><span class="hljs-number">1</span></span> ); list_push( <span class="hljs-number"><span class="hljs-number">2</span></span> ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, list_pop() ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">2</span></span>, list_pop() ); }</code> </pre><br>  The first test, we checked that the API module in principle workable.  We also made sure that what we keep on the list can later be retrieved. <br>  By the second test, we checked that the elements are retrieved from the list in the order in which they were placed there. <br>  And it was precisely this kind of functionality that interested us initially when designing the entire software complex, but certainly not the way it was implemented. <br><br><h2>  Benefits </h2><br>  With this approach, the above-described shortcomings of the tests are eliminated: <br><blockquote>  Tests test code </blockquote>  Tests test the behavior of a module without knowing anything about its implementation (black-box) <br><blockquote>  Tests force the developer to do crutches </blockquote>  when testing through an API, this is extremely rare <blockquote>  Tests require titanic efforts to support them, even in the case of refactoring, not to mention significant changes. </blockquote>  in our example, the implementation can be changed completely (an array instead of a linked list, bidirectional list instead of unidirectional, etc.), which should not affect its behavior <blockquote>  "Failed" tests do not mean at all that some kind of functionality does not work </blockquote>  since code refactoring (if successful) does not affect the test results in any way, there is only one reason for the ‚Äúfailures‚Äù of the tests - something really does not work <br><br><h2>  Extra buns </h2><br>  In addition to the above advantages, unit tests have another, in my opinion, very important advantage - they improve the quality of the code. <br>  Whether we like it or not, the code under test (one that can be physically tested) is more flexible, more portable, more scalable.  Maybe something else (I'm afraid to praise). <br><br>  Unfortunately, the list implemented above has not yet been tested for memory leaks.  But this moment was far from the last in the list of fears that made the team think about unit tests for a linked list. <br><br>  In order to verify the absence of leaks, we must control the allocation / release of memory.  And making a mock-and on the functions of the standard library is not the easiest task. <br><br>  There is a way out - add an abstraction layer between the module and the standard library with the following interface: <br><div class="spoiler">  <b class="spoiler_title">my_list_mem.h file</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MY_LIST_MEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_LIST_MEM void * list_alloc_item( int size ); void list_free_item( void * item ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br></div></div><br>  Then, the implementation of the list will look like: <br><div class="spoiler">  <b class="spoiler_title">my_list.c</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include <span class="hljs-string"><span class="hljs-string">"my_list.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"my_list_mem.h"</span></span> typedef struct node { int val; struct node * <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>; } node_t; static node_t * list_head; void list_push( int val ) { node_t * current = list_head; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(list_head == NULL) { // list_head = malloc(sizeof(node_t)); list_head = (node_t*)list_alloc_item( sizeof(node_t) ); list_head-&gt;val = val; list_head-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = NULL; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span> != NULL) { current = current-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>; } // current-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = malloc(sizeof(node_t)); current-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = (node_t*)list_alloc_item( sizeof(node_t) ); current-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>-&gt;val = val; current-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = NULL; } } int list_pop( void ) { int retval = <span class="hljs-number"><span class="hljs-number">-1</span></span>; node_t * next_node = NULL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list_head == NULL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } next_node = list_head-&gt;<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>; retval = list_head-&gt;val; // free(list_head); list_free_item( list_head ); list_head = next_node; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre><br></div></div><br>  Already implemented tests will not change in any way, with the exception of adding mocks: <br><div class="spoiler">  <b class="spoiler_title">file test_my_list.c</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">#include <span class="hljs-string"><span class="hljs-string">"unity.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"my_list.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"mock_my_list_mem.h"</span></span> #include &lt;stdlib.h&gt; static void * list_alloc_item_mock( <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> size, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> numCalls ) { return malloc( size ); } static void list_free_item_mock( void * item, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> numCalls ) { free( item ); } void setUp(void) { list_alloc_item_StubWithCallback( list_alloc_item_mock ); list_free_item_StubWithCallback( list_free_item_mock ); } void tearDown(void) { } /* * Given the list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> * When I push <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the list * <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> the pop <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> shall reutrn <span class="hljs-number"><span class="hljs-number">1</span></span> */ void test_nominal( void ) { list_push( <span class="hljs-number"><span class="hljs-number">1</span></span> ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, list_pop() ); } /* * Given the list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> * When I push <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the list * <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> I push <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the list * <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> the first <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> of the pop <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> shall return <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">second</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> of the pop <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> shall return <span class="hljs-number"><span class="hljs-number">2</span></span> */ void test_order( void ) { list_push( <span class="hljs-number"><span class="hljs-number">1</span></span> ); list_push( <span class="hljs-number"><span class="hljs-number">2</span></span> ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, list_pop() ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">2</span></span>, list_pop() ); }</code> </pre><br></div></div><br>  And finally, new memory management tests: <br><div class="spoiler">  <b class="spoiler_title">file test_my_list_mem_leak.c</b> <div class="spoiler_text"><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"unity.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"my_list.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"mock_my_list_mem.h"</span></span> #include &lt;stdlib.h&gt; static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mallocCounter; static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> freeCounter; static void * list_alloc_item_mock( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numCalls ) { mallocCounter++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> malloc( <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> ); } static void list_free_item_mock( void * item, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numCalls ) { freeCounter++; free( item ); } void setUp(void) { list_alloc_item_StubWithCallback( list_alloc_item_mock ); list_free_item_StubWithCallback( list_free_item_mock ); mallocCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; freeCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } void tearDown(void) { } <span class="hljs-comment"><span class="hljs-comment">/* * Given the list is empty * When I push an item to the list * Then one part of mmory shall be allocated * And no part of memory shall be released */</span></span> void test_push( void ) { list_push( <span class="hljs-number"><span class="hljs-number">1</span></span> ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, mallocCounter ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">0</span></span>, freeCounter ); } <span class="hljs-comment"><span class="hljs-comment">/* * Given the list is empty * When get the item from the list pushed before * Then one part of mmory shall be released * And no part of memory shall be allocated */</span></span> void test_pop( void ) { list_pop(); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">0</span></span>, mallocCounter ); TEST_ASSERT_EQUAL_INT( <span class="hljs-number"><span class="hljs-number">1</span></span>, freeCounter ); }</code> </pre><br></div></div><br>  As a result, on the one hand, we checked the correctness of working with memory, on the other - we implemented an additional layer containing wrappers for malloc () and free () functions.  And if in the future the memory allocation mechanism is changed (a static array of elements of a fixed size, the memory_pool of some RTOS) - our code is ready for these changes, and the list itself and tests for its functionality will not be affected in any way. <br><br><h2>  Conclusions </h2><br>  Yes, ... only two conclusions <br>  1. Unit tests are good, the main thing is to write them correctly. <br>  2. but in order for this to be possible, you should think about testing when developing code. <br><br><h2>  PS </h2><br>  All coincidences with real people are random. <br>  As a basis for the implementation of the text used material <a href="http://www.learn-c.org/en/Linked_lists">www.learn-c.org</a> <br>  All tests are written using <a href="http://throwtheswitch.org/">Unity / CMock / Ceedling tools.</a> </div><p>Source: <a href="https://habr.com/ru/post/250053/">https://habr.com/ru/post/250053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250039/index.html">Symfony2. Universal tool for quick cooking of table lists in the administrative panel</a></li>
<li><a href="../250043/index.html">Developing microservices using Scala, Spray, MongoDB, Docker and Ansible</a></li>
<li><a href="../250045/index.html">Imarker usage statistics (SORM-like web analytics system)</a></li>
<li><a href="../250047/index.html">Raspberry Pi 2 freezes from flash</a></li>
<li><a href="../250049/index.html">DevCon 2015: announcement of key speakers of the plenary session</a></li>
<li><a href="../250055/index.html">WSGI / Rack for PHP</a></li>
<li><a href="../250057/index.html">Music as infrastructure: the choice of headphones</a></li>
<li><a href="../250061/index.html">Sites from right to left: how to connect the RTL-standard</a></li>
<li><a href="../250063/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ146 (February 2 - 8, 2015)</a></li>
<li><a href="../250065/index.html">The fundamental problem of package managers for programming languages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>