<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make a keyboard - Matrix</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posted by : Komar aka Micha≈Ç Trybus; English-Russian translation : firerock 
 Original : blog.komar.be/how-to-make-a-keyboard-the-matrix 

 This is th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make a keyboard - Matrix</h1><div class="post__text post__text-html js-mediator-article">  <sub><b>Posted by</b> : <a href="http://blog.komar.be/about/">Komar</a> aka Micha≈Ç Trybus;</sub>  <sub><b>English-Russian translation</b> : <a href="https://geektimes.ru/users/firerock/" class="user_link">firerock</a></sub> <br>  <sup><b>Original</b> : <a href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/">blog.komar.be/how-to-make-a-keyboard-the-matrix</a></sup> <br><br>  This is the first post in the keyboard series;  I hope he will not be the last.  I would like to end up with a course on making a keyboard from scratch.  Today I will talk about digital I / O and keyboard matrixes.  Arm yourself with elementary school knowledge from the field of electronics - and let's go. <br><a name="habracut"></a><br><h2>  Why the matrix? </h2><br>  And how are we going to do the matrix?  And most importantly - why is it even needed?  Well, the matter is that, basically, the physical limitations of microcontrollers, on the basis of which keyboards are built.  The fact is that with an increase in the number of outputs in microcontrollers and programmable logic chips, their size also grows, which, in turn, entails an increase in energy consumption and opportunities, but the main thing is prices.  As a result, you can choose either a cheap chip with a small performance (which suits you perfectly), but with a small number of inputs and outputs, or a more powerful chip, whose performance, however, greatly exceeds your requirements.  But only this powerful chip will have enough pins to connect every button on the keyboard. <br><br>  Over the decades, the practice of electronics has been developed with the help of various tricks to artificially expand the embedded communication capabilities of processors and controllers.  One of these methods, which is well suited for mechanical contacts (buttons), is the creation of a matrix.  To understand how it works, some basic knowledge is required.  Before we continue, please refresh <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%259E%25D0%25BC%25D0%25B0">Ohm‚Äôs law</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Some theory </h2><br>  To understand how digital electronics works, you need to learn two basic principles. <br><br>  <b>Principle one</b> states that the process of communication within the scheme is not the transmission or receipt of something there.  To ensure communication between the two devices, you simply interconnect their leads with an electrically conductive material.  After that, it is assumed that the state of the material (voltage and current) at both its ends will be the same.  In reality, this, of course, is not so, but for slow communications and short conductors, our assumption works perfectly.  It turns out that sending and receiving information is in fact its sharing. <br><br>  On the transmitter side, you simply change the electrical state of the conductor (by firing direct current into it, changing its potential), hoping that the receiver will be able to detect this change and understand it correctly. <br><br>  <i>It also follows from this principle that there is no dependence between the direction of communication and the direction of electric current.</i>  Many people mistakenly assume the opposite, and this prevents them from understanding how electronics work. <br><br>  If you want to send a logic level "0", then usually the voltage at the output of the transmitter is lowered to 0 V, and a current begins to flow from the receiver to the transmitter so that the receiver can determine that the logic level corresponds to "0".  (Whereas the reverse direction of the current would mean that somewhere in the circuit there is a negative potential - and this, as a rule, does not happen in digital electronics.) On the other hand, a voltage equal to the supply voltage is applied to transfer the logic level "1" and since this is, most often, the highest voltage in the circuit, there will be nothing left for the electric current to flow from the transmitter to the receiver. <br><br>  <b>Principle number two</b> is that it is impossible to determine the state of the conductor without changing this state.  It doesn't matter if you are going to measure voltage or current ‚Äî in any case, it requires that electrons flow through your meter.  The flow of electrons is the electric current, and once it flows, it means that in the node to which you connected for measurement, the currents and voltages have already changed (see <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%259A%25D0%25B8%25D1%2580%25D1%2585%25D0%25B3%25D0%25BE%25D1%2584%25D0%25B0">Kirchhoff's laws</a> ).  From this it follows that if you need to ‚Äútransfer‚Äù information by changing the state of the output electrically connected to another output, then this requires maintaining this state, and therefore, must comply with all requirements imposed by the receiver. <br><br><h2>  Button </h2><br>  A mechanical button (and in this context, the word ‚Äúmechanical‚Äù is not associated with the phrase ‚Äúmechanical keyboard‚Äù) is just a pair of metal contacts that, when touching, electrically connect the two terminals.  Of course, there are other types of switches, structurally more complex and having more conclusions, but they are not interesting to us, because they are not used in keyboards. <br><br><img src="https://habrastorage.org/files/910/b1e/9b7/910b1e9b776543e0a3cf502aca657473.jpg"><br>  <sub>Cherry MX button.</sub>  <sub>Image source: <a href="http://deskthority.net/wiki/Cherry_MX">Deskthority wiki</a></sub> <br><br>  Well, and how will we connect the button to the input of the microcontroller?  In principle, any input can operate with two possible logical levels: "0" and "1".  It is common practice to accept voltages close to 0 V as a logical zero, and voltages close to the supply voltage (usually 5 V or 3.3 V) as a logical unit.  But the problem is that the mechanical button cannot control the voltage itself.  It controls the current - that is, if we connect two nodes with different electric potential through the button, then the current between these nodes will flow if and only when the button is pressed. <br><br>  But if we add a resistor, we can very easily convert current into voltage. <br><br><img src="https://habrastorage.org/files/2df/7ff/d4e/2df7ffd4e1584d38a170b8028fd06021.png"><br>  <sub>Pull Resistor Button</sub> <br><br>  Take a look at this diagram.  When the button is not pressed (the circuit is broken), the current does not flow through it, so the voltage at node ‚ÄúA‚Äù will be close to the supply voltage VCC (in fact, less than VCC by the voltage drop across the resistor equal to R ‚Ä¢ I).  When the button is pressed (the circuit is closed), the current flows through the resistor to ground.  Taking into account that the resistance of the closed button is very small (about hundreds of millimets), the voltage at the node ‚ÄúA‚Äù will be close to ‚Äú0‚Äù. <br><br>  In this configuration, the resistor is called pull-up, because it "pulls the voltage up" to the level of VCC.  And without connecting to the power through the resistor, there would be no voltage at the node ‚ÄúA‚Äù at all (in this case, the output of the microcircuit is called ‚Äúhanging in the air‚Äù or in a high-impedance state). <br><br>  It should be noted that inside most modern microcontrollers already have pull-up resistors that can be quickly connected or disconnected using the program.  So, the main way to connect a button with a microcontroller is the following: one button output - to the input of the microcontroller, another button output - to the ground.  In this case, if the button is not pressed, then the microcontroller is fed "1", and if it is pressed, then "0".  Perhaps this is contrary to intuition, but this method of connection is the most popular. <br><br>  Please note that if we leave one of the pins of the button hanging in the air, that is, we don‚Äôt connect it anywhere, then this button will not work at all: do not press it, it will not affect the electrical status of the microcontroller.  We still use this property when we make the matrix. <br><br><h2>  Matrix principle </h2><br>  The basic principle of the keyboard matrix is ‚Äã‚Äãthe ability to connect to one input of the microcontroller more than one button. <br><br>  With the help of transistors or properly configured <b>outputs of the</b> microcontroller, we can make the buttons connect to the earth one at a time, while the others will hang in the air.  The remaining pins of each of the buttons are combined into one node and connected to the <b>input of the</b> microcontroller.  I lowered the pull-up resistor, since we know that it is already present inside the microcontroller, in its input stage.  We in turn ‚Äúturn on‚Äù each button, connecting its pin number 1 to the ground via the corresponding output of the microcontroller, after which we can read the button state by removing the voltage from its pin number 2. Other buttons connected to the same input do not affect on his condition, because their conclusions number 1 are currently hanging in the air.  The following diagram illustrates this idea. <br><br><img src="https://habrastorage.org/files/e7e/2db/cca/e7e2dbccac834fef95bb30b1bdb134d3.png"><br>  <sub>Many buttons, one input (node ‚Äã‚Äã"A")</sub> <br><br>  ‚ÄúA‚Äù is the only input of the microcontroller, and ‚ÄúC1‚Äù .. ‚ÄúCn‚Äù is its outputs.  A logical "0" is set at one of the outputs, that is, inside the chip, this contact is somehow connected to ground - therefore, the current will always flow to this contact (in accordance with the first basic principle).  Now, when the button connected to this output is pressed, through it the input ‚ÄúA‚Äù will immediately ‚Äúpress‚Äù to the ground, and it will be set to ‚Äú0‚Äù.  Pressing the other buttons will not change anything, because their earthen findings are not connected at any given time.  When we need to poll the next button, we remove the logical ‚Äú0‚Äù from the current output and set this level to the next output, so that at any time only one of the microcontroller outputs will be activated. <br><br>  Such a configuration (when the output is either connected to ground or disconnected altogether) is called an open drain outlet (OS) (historically, an open collector (OK)).  Here I made some simplification - in fact, the contact cannot be completely disconnected from the circuit, unless it is physically cut off from it.  But for simple digital I / O, such a simplification is fine.  Most microcontrollers provide the ability to programmatically configure their output pins for operating in OS mode.  But what if we do not have such an opportunity?  There is another configuration - push-pull mode;  Today this option is one of the most popular.  This configuration works a little differently.  In the ‚Äú0‚Äù state, the output is still pressed down to the ground, but when the ‚Äú1‚Äù state comes, it is pulled up to the VCC supply voltage, so that the air outlet no longer hangs, now it can become a current source. <br><br>  What changes will this entail in the design of the matrix?  If we are not going to press several buttons at the same time, then none.  But if we are going to, look at the picture and imagine for a second what will happen then.  By pressing two buttons, we connect the two lower outputs into a closed loop.  If at the same time one of them is in the ‚Äú0‚Äù state and the other is in the ‚Äú1‚Äù state, then an electrical current will flow from the output set to ‚Äú1‚Äù to the output set to ‚Äú0‚Äù.  And since this current is not limited by anything (no resistors), not only does the circuit become unstable, the chip can fly as well.  Well and, by itself, hardly it will turn out to consider a logical state normally. <br><br><h2>  Adding lines </h2><br>  You can consider the previous example as a matrix consisting of one row.  Now let's increase it by adding extra lines.  In fact, if we can hang a whole line on one input, then why can't we hang a whole column of buttons on one output?  True, there is a prerequisite - each button of the column must be connected to a separate input of the microcontroller. <br><br>  If we arrange the buttons in the form of an ordinary matrix, then this condition will be fulfilled automatically.  And the following figure shows how the matrix of buttons will look like, consisting of <i>n</i> columns and <i>m</i> rows ( <b>do not pay attention to the green figures yet</b> ). <br><br><img src="https://habrastorage.org/files/8f8/989/832/8f89898324d64a3ead1d3b63fa8ecaa1.png"><br>  <sub>Simple keyboard matrix</sub> <br><br>  Reading this matrix is ‚Äã‚Äãvery simple.  We poll one column at a time.  The column for reading is selected by connecting one of the outputs "C1" .. "Cn" to the ground (the output in the OS mode is converted to "0").  Now, alternately polling the lines "R1" .. "Rm", we can determine the state of each button of the selected column.  Buttons from other columns do not affect anything, even if they are pressed, because at the moment their ground leads are hanging in the air (or, as they say in electronics, they are in the Hi-Z state). <br><br>  After the entire column is polled, we proceed to the next one, releasing the current output and pressing the next one to zero.  Matrix scanning is considered complete when all columns are polled.  If everything is done fairly quickly, then the fastest typesetter will not notice the intervals between polling columns.  Even with a 16 MHz microcontroller, we can easily scan the entire matrix thousands of times per second, while the fastest typesetter in the <a href="http://hi-games.net/">hi-games.net</a> test achieved a speed of 203 words per minute (wpm) - that is, a little less than 17 taps in give me a sec. <br><br>  When designing a keyboard using a matrix, we reduce the number of pins required to connect all the keys.  But in order to reduce the number of conclusions to the minimum possible, we need to make a matrix so that the number of columns is as close as possible to the number of rows.  In an ideal situation, if the number of buttons is <i>n¬≤</i> , then the best that we can achieve with a matrix is <i>2n</i> busy microcontroller pins.  However, today when compiling matrices, it is rare that anyone seeks to minimize the number of legs involved, because modern microcontrollers, as a rule, have a sufficient number of free outputs.  In addition, the maximum optimization of the matrix can later lead to inconveniences ‚Äî the wiring of the board or the distribution of wires in the end device will become significantly more complicated.  Therefore, it is worth going a more convenient way: in drawing up the matrix, try to follow the physical arrangement of the buttons.  In this case, for a standard computer keyboard, the simplest matrix will have only 6 rows and a certain number of columns, depending on the desired layout.  Of course, from the point of view of the number of conclusions involved, this solution is not the most optimal, but in the future, at least, the wiring will be simplified. <br><br><h2>  But what if we don‚Äôt have open drain exits? </h2><br>  You may ask: what can we do if there is no OS mode in the selected microcontroller?  Well, we have already figured out what kind of trouble can happen, and that pulling the outputs to the VCC (that is, ‚Äúconnecting‚Äù them with power) is not a good idea.  There are many ways to solve this problem;  Among them there are not only special output buffers of the OS, but even shift registers with OS-outputs - to further minimize the number of legs involved.  But there is another very popular technique that is often used in the construction of computer keyboards (in fact, it was widely used in the old days). <br><br>  The problem of the columns connected to the push-pull outputs is manifested at the moment when two buttons are pressed together that are in the same line, and at the same time pressing this button a poll is performed in which one of the buttons is located. <br><br><img src="https://habrastorage.org/files/46e/3a8/4b1/46e3a84b1b774e1097d07503e3911c65.png"><br>  <sub>Push-pull problem</sub> <br><br>  From the output, which is pulled to "1" (and does not hang in the Hi-Z state), current begins to flow.  It passes through the nearest closed button, then through the closed button in the column being polled, and finally flows directly into the output set to ‚Äú0‚Äù.  This can lead to anything - from the inability to reliably read the state of the keyboard and ending with the failure of the microcontroller itself. <br><br>  But since we are forced to somehow deal with this problem, we can apply an excellent trick: turn the push-pull exit into something like an open-drain outlet.  I often came across this solution in the construction of old keyboards.  Given that the current should only flow into the outputs (connected to the columns), but never flow out of them, we can limit the direction of the current with the help of diodes.  A diode is a simple device that allows current to flow in only one direction.  In the image of the diode on the electrical circuit, a triangle symbolizes an arrow that indicates this direction.  If we put a diode between each output of the microcontroller and the conductor of the corresponding matrix column, then we will achieve our goal - now the current can only flow into the outputs, because the specified conductors reach each button of their column.  It turns out that from the output set to "1", the current will not flow anywhere, and this almost turns it into an output with an open drain.  Of course, it does not reach the current OS, but it solves our problem of a closed current loop in the keyboard matrix.  Go back to the penultimate pattern of the matrix, but this time <b>take into account the green diodes</b> to understand how this trick works. <br><br>  Naturally, it makes sense to minimize the number of diodes.  To do this, you can reduce the number of columns by increasing the number of rows.  And if the resulting result does not fit well into the actual keyboard layout, then you can "expand" the matrix by 90 ¬∞ (swap rows with columns).  The possibilities are endless.  But nowadays, a huge number of microcontrollers have appeared, which are easy to use and convenient for hobbyists, so today the described method is practically not used in homegrown keyboard projects.  Luckily. <br><br><h2>  Phantom clicks (Ghosting) </h2><br>  If you are interested in clavs, you must have already met this term.  Unfortunately, in the keyboard world, it is often interpreted incorrectly. <br><br>  We are already familiar with the situation when the simultaneous pressing of several buttons on one line can interfere with the normal reading of the matrix.  And this problem, we can say, is solved by us.  And now let's see what happens if you press several buttons that are simultaneously in one line and in one column. <br><br><img src="https://habrastorage.org/files/c1c/830/afd/c1c830afdd614656a91cd6c3ba061cf5.png"><br>  <sub>Phantom push example</sub> <br><br>  In the figure, the three buttons are pressed simultaneously.  Two of them are in the ‚ÄúC2‚Äù column, and two in the ‚ÄúRm‚Äù line.  This means that one of the pressed buttons divides the line with the other pressed button, and the column with the third pressed button.  It is in this situation that <i>phantom depression</i> occurs.  Imagine that at the moment we are querying the ‚ÄúC1‚Äù column (that is, it is pushed to the ground - it is in the ‚Äú0‚Äù state).  Such a characteristic chord of the pressed buttons leads to the following: even though the left top button is not pressed, the string "R2" is in the state "0", because it is pressed to the ground by the column "C1" (located in "0") through three pushed buttons.  As a result, the keyboard controller reads the left upper button as ‚Äúpressed‚Äù, regardless of whether it is actually pressed or not.  The described situation is called <i>phantom pressing</i> ( <i>ghosting</i> ), because some combinations of simultaneously pressed buttons cause phantom triggers of other buttons (ghost keypresses), although physically these other buttons are not pressed. <br><br>  Of course, there are ways to protect compositors and gamers from phantom positives, and these methods are widely used in modern computer keyboards.  You can catch the moment of occurrence of phantom depression and block it.  An ordinary person is not able to simultaneously press or release two keys with perfect accuracy.  Therefore, scanning the matrix quickly enough, we can assume that between two passes through the matrix, it can change no more than one button.  In such a case, the controller accepts single presses and monitors the occurrence of situations in which two or more buttons are pressed between the matrix passes.  Given that the matrix is ‚Äã‚Äãscanned at a speed at which the regular occurrence of such situations is extremely unlikely, we can conclude that one of the buttons just pressed is a phantom.  Therefore, the controller must ignore all of these presses.  In addition, it is safer not to immediately inform the computer about changes in the status of the keyboard ‚Äî first, it makes sense to wait until all these alarms disappear. <br><br>  There is another approach.  You can identify the situation when the ‚Äúthird‚Äù button is triggered, and block both this click and all subsequent ones.  Do not remove the lock until the phantom operation disappears and the situation becomes normal again.  To implement this approach, the program must remember exactly which buttons are pressed now (and usually it remembers this and so) in order to reject the subsequent actuation of the buttons, in the rows and columns of which the simultaneous presses are already fixed.  If you write the program wisely, only problem triggering will be blocked, and all subsequent ones will be accepted as usual - except for those that again break the rules.  Since the controller rejects pressing each button that already has simultaneous operation in its row and column, it turns out that, depending on the status of some buttons, others may not be registered at all.  This situation is commonly known as <i>jamming</i> .  That is, the buttons that prevent the simultaneous operation of other buttons, it turns out, "block" part of the keyboard. <br><br>  From the user's point of view, you can simultaneously press all the buttons from one column (without pressing the buttons from the other), but you can simultaneously press all the buttons from one line only if each of these buttons has no more than one trigger in the column.  The same applies to pressing buttons from one column - additional operations are recorded only if the buttons are in rows that are ‚Äúnot occupied‚Äù. <br><br>  People often confuse ‚Äú <i>phantom triggering</i> ‚Äù and ‚Äú <i>blocking triggering</i> ‚Äù (‚Äú <i>ghosting</i> ‚Äù and ‚Äú <i>jamming</i> ‚Äù), which is a mystery to me personally - in my opinion, these terms are quite intuitive. <br><br>  In keyboards using such matrices, as we have just considered, it is impossible to avoid neither phantom operations, nor blocking.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since phantom triggers in everyday work are unacceptable, to combat them, almost all manufacturers of rubber dome keyboards use various tricks, and blocking comes into play. </font><font style="vertical-align: inherit;">Question: how to create a matrix in such a way that blocking occurs as little as possible and would not be caused by common keyboard shortcuts? </font><font style="vertical-align: inherit;">In fact, this is a good topic for a whole book; </font><font style="vertical-align: inherit;">That is why the matrixes of shirpredetovsky keyboards are so intricate and always block a good mood (like, pun).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diodes on all buttons - the cardinal solution </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look at the image about phantom clicks again, you will be able to notice that the bottom right button is to blame for everything. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this button is the only one through which the current flows in this situation ‚Äúupward‚Äù. So, if we don‚Äôt want the current ‚Äúup‚Äù currents to prevent us from reading the matrix normally, then let us introduce diodes so that the current can flow along the columns strictly from top to bottom, flowing into the microcontroller outputs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, saving here will not work - you have to put a diode on each button. If we talk about polarity, then you should have figured out that in this particular case, the diodes must pass the current ‚Äútop to bottom‚Äù, that is, their cathodes (‚Äúarrow tips‚Äù) should look at the microcontroller outputs (columns), while the anodes should be turned to the inputs (lines).</font></font><br><br><img src="https://habrastorage.org/files/5b6/8bf/f0f/5b68bff0fcf043eaac33246af5320dd1.png"><br> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary Matrix</font></font></sub> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It does not matter which side of the button the diode is located; the main thing is to observe the correct polarity. Just remember that in this case the current will always flow from the inputs to the outputs. By the way, if the inputs are pulled to the power supply, and the outputs are in the OS mode, then this will always happen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this approach, it turns out that the current will always flow "right down", and this eliminates the appearance of closed current paths by simultaneously pressing several buttons. </font><font style="vertical-align: inherit;">In addition, this design is the only one that can provide the keyboard with a full NKRO. </font><font style="vertical-align: inherit;">In addition, it is useful to mention (although it seems obvious) that the problem of the absence of the OS mode from the microcontroller's outputs is now solved automatically. </font><font style="vertical-align: inherit;">Diodes installed in series with each button, relieve the outputs from the circuit is not worse than the previously considered option, where it was supposed to additionally put a diode on each column.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rollover </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, I know that the text is already too long. </font><font style="vertical-align: inherit;">But I still add this last chapter, because, in my opinion, without it the article will be incomplete. </font><font style="vertical-align: inherit;">So, rollover is the ability of the keyboard to perceive several taps at the same time.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> xKRO </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KRO is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key rollover</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key a rollover</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and usually this abbreviation is entitled by some number. For example, 2KRO means two-key rollover. A keyboard has an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keyboard rollover if and only if it is able to register </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simultaneous </font><font style="vertical-align: inherit;">key </font><font style="vertical-align: inherit;">presses, moreover, regardless of which buttons and in what sequence were used. Most modern rubber dome keyboards have 2KRO. From this, however, it does not follow that the permissible number of clicks on these keyboards will always be limited to the number </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In fact, this means that support for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simultaneous clicks is guaranteed exactly.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the design of the matrix and the type of controller, two 2KRO keyboards from different manufacturers may behave quite differently. </font><font style="vertical-align: inherit;">One can always perceive only two simultaneous presses, and the other can easily digest and more. </font><font style="vertical-align: inherit;">It seems that the last keyboard was declared 2KRO because some key combinations (most likely, unlikely) will still cause her to block the pressing of other buttons. </font><font style="vertical-align: inherit;">And since this means that when working with this keyboard, certain combinations of three keys and more will not work, the company announced it as 2KRO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NKRO </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The term NKRO means </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-key rollover</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and is used to designate keyboards that support, in spite of everything, any combination of keys pressed at the same time. But keep in mind that the NKRO matrix and the NKRO keyboard are two big differences. For example, if the final implementation of the matrix, considered by us in the article, supports the NKRO (taking into account the correctly written firmware), then this does not mean that the keyboard using this matrix will also support the NKRO. This may be due to the limitations imposed by the communication ports to which the keyboard is connected; another reason may be the thrift of manufacturers, forever saving here and there. The problem of NKRO when connecting with PS / 2 and USB, I will try to clarify in the following sections.</font></font><br><br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the sheet came out pretty, but the concept is not so simple - especially for the reader who is not an electronic engineer. </font><font style="vertical-align: inherit;">I hope I managed to explain everything; </font><font style="vertical-align: inherit;">However, I tried to write as clearly as possible. </font><font style="vertical-align: inherit;">Therefore, to some of you, the article might seem rather boring. </font><font style="vertical-align: inherit;">Well, and if you are fumbling in electronics, then, most likely, you should not have read it at all;) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In any case, please </font></font><a href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let me know</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if the article turned out to be useful for you and whether it is worth writing a sequel. </font><font style="vertical-align: inherit;">If yes, then sit down for the next "series". </font></font><br><br> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Micha≈Ç Trybus </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">September 2, 2013</font></font></sub> </div><p>Source: <a href="https://habr.com/ru/post/394585/">https://habr.com/ru/post/394585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../394575/index.html">The Itseez team works again at Intel</a></li>
<li><a href="../394577/index.html">Project Kronos and a little-known Russian team from the Novosibirsk Academgorodok Kronos Research Group (KRG)</a></li>
<li><a href="../394579/index.html">Bionic hands: history, future and reality</a></li>
<li><a href="../394581/index.html">A crisis. The popularity of pirated software has grown in Russia for the first time.</a></li>
<li><a href="../394583/index.html">How we achieved energy savings in lighting and developed more energy with a luxmeter</a></li>
<li><a href="../394587/index.html">Facebook users prefer to watch videos without sound</a></li>
<li><a href="../394589/index.html">Crowdfunding for the smallest (part 1)</a></li>
<li><a href="../394591/index.html">Quick guide to creating fragment-based navigation</a></li>
<li><a href="../394595/index.html">As astronauts on the ISS, the BEAM module was inflated: time-lapse video</a></li>
<li><a href="../394597/index.html">World record of wireless data transmission: 6 Gbit / s at 37 kilometers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>