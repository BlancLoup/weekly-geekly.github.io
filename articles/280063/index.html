<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with C-unions (union) in Rust FFI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I bring to your attention the translation of the article " Working with C unions in Rust FFI " by Herman J. Radtke III. 

 Note: This article assumes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with C-unions (union) in Rust FFI</h1><div class="post__text post__text-html js-mediator-article">  <i>I bring to your attention the translation of the article " <a href="http://hermanradtke.com/2016/03/17/unions-rust-ffi.html">Working with C unions in Rust FFI</a> " by Herman J. Radtke III.</i> <i><br><br></i>  <i>Note: This article assumes that the reader is familiar with <a href="https://doc.rust-lang.org/book/ffi.html">Rust FFI</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">byte order</a> (endianess) and <a href="https://en.wikipedia.org/wiki/Ioctl">ioctl</a> .</i> <br><br>  When creating bindings to the C code, we will inevitably encounter a structure that contains the union.  In Rust there is no built-in support for associations, so we will have to work out a strategy on our own.  In C, a union is a type that stores different types of data in the same memory area.  There are many reasons why you can prefer union, such as: the conversion between binary representations of integers and floating point numbers, the implementation of pseudo-polymorphism and direct access to bits.  I will focus on pseudo-polymorphism. <br><a name="habracut"></a><br>  As an example, let's get a MAC address based on the interface name.  We list the steps necessary to obtain it: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Specify the type of request to be used with ioctl.  If I want to get a MAC (or hardware) address, I specify SIOCGIFHWADDR. </li><li>  Write the interface name (something like eth0) in the ifr_name. </li><li>  Make a request using ioctl.  As a result of a successful query, the data will be recorded in ifr_ifru. </li></ul><br>  If you are interested in details on obtaining a MAC address, look at these <a href="http://www.microhowto.info/howto/get_the_mac_address_of_an_ethernet_interface_in_c_using_siocgifhwaddr.html">instructions</a> . <br><br>  We need to use the function declared in C ioctl and pass the structure to thererereq.  Looking in /usr/include/net/if.h, we see that ifreq is defined as follows: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifreq</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ifr_name[IFNAMSIZ]; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifru_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifru_dstaddr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifru_broadaddr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ifru_flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ifru_metric; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ifru_mtu; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ifru_phys; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ifru_media; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ifru_intval; <span class="hljs-keyword"><span class="hljs-keyword">caddr_t</span></span> ifru_data; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifdevmtu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifru_devmtu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifkpi</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ifru_kpi</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">u_int32_t</span></span> ifru_wake_flags; <span class="hljs-keyword"><span class="hljs-keyword">u_int32_t</span></span> ifru_route_refcnt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ifru_cap[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } ifr_ifru; }</code> </pre> <br>  Difficulties arise with the union of ifr_ifru.  Looking at the possible types in ifr_ifru, we see that not all of them are the same size.  short is two bytes, and u_int32_t is four.  Further complicating the situation are several structures of unknown size.  To write the correct code on Rust, it is important to find out the exact size of the ifreq structure.  I created a small C program and found out that ifreq uses 16 bytes for ifr_name and 24 bytes for ifr_ifru. <br><br>  Armed with the knowledge of the correct size of the structure, we can begin to represent it in Rust.  One of the strategies is to create a specialized structure for all types of union. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfReqShort</span></span></span></span> { ifr_name: [c_char; <span class="hljs-number"><span class="hljs-number">16</span></span>], ifru_flags: c_short, }</code> </pre><br>  We can use IfReqShort to request a SIOCGIFINDEX.  This structure is smaller than the ifreq structure in C. Although we assume that only 2 bytes will be written, the external ioctl interface expects 24 bytes.  For security, let's add 22 bytes of padding at the end: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfReqShort</span></span></span></span> { ifr_name: [c_char; <span class="hljs-number"><span class="hljs-number">16</span></span>], ifru_flags: c_short, _padding: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">22</span></span>], }</code> </pre><br>  Then we will have to repeat this process for each type in the union.  I find it somewhat tedious, since we will have to create a lot of structures and be very careful not to be mistaken with their size.  Another way to represent a join is to have a buffer of raw bytes.  We can make a single representation of the ifreq structure in Rust as follows: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfReq</span></span></span></span> { ifr_name: [c_char; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u8</span></span></span></span>; <span class="hljs-number"><span class="hljs-number">24</span></span>], }</code> </pre><br>  This union buffer can hold any type of bytes.  Now we can define methods for converting raw bytes to the desired type.  We will avoid using unsafe code by not using transmute.  Let's create a method to get the MAC address by converting the raw bytes to sockaddr C-type. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> IfReq { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_hwaddr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; sockaddr { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s = sockaddr { sa_family: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>::from_be((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>)), sa_data: [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">14</span></span>], }; <span class="hljs-comment"><span class="hljs-comment">// basically a memcpy for (i, b) in self.data[2..16].iter().enumerate() { s.sa_data[i] = *b as i8; } s } }</span></span></code> </pre><br>  This approach leaves us with one structure and method for converting raw bytes to the desired type.  Looking again at our ifr_ifru union, we find that there are at least two other queries that also require the creation of sockaddr from raw bytes.  Applying the principle of DRY, we can implement the private method IfReq to convert raw bytes to sockaddr.  However, we can do better by abstracting the details of creating sockaddr, short, int, etc.  from IfReq.  All we need is to <i>tell the</i> union that we need a certain type.  Let's create an IfReqUnion for this: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfReqUnion</span></span></span></span> { data: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">24</span></span>], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> IfReqUnion { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_sockaddr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; sockaddr { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s = sockaddr { sa_family: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>::from_be((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>)), sa_data: [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">14</span></span>], }; <span class="hljs-comment"><span class="hljs-comment">// basically a memcpy for (i, b) in self.data[2..16].iter().enumerate() { s.sa_data[i] = *b as i8; } s } fn as_int(&amp;self) -&gt; c_int { c_int::from_be((self.data[0] as c_int) &lt;&lt; 24 | (self.data[1] as c_int) &lt;&lt; 16 | (self.data[2] as c_int) &lt;&lt; 8 | (self.data[3] as c_int)) } fn as_short(&amp;self) -&gt; c_short { c_short::from_be((self.data[0] as c_short) &lt;&lt; 8 | (self.data[1] as c_short)) } }</span></span></code> </pre><br>  We implemented methods for each of the types that make up the union.  Now that our transformations are managed by IfReqUnion, we can implement the IfReq methods as follows: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfReq</span></span></span></span> { ifr_name: [c_char; IFNAMESIZE], <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfReqUnion</span></span></span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> IfReq { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_hwaddr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; sockaddr { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.union.as_sockaddr() } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_dstaddr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; sockaddr { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.union.as_sockaddr() } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_broadaddr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; sockaddr { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.union.as_sockaddr() } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_ifindex</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; c_int { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.union.as_int() } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_media</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; c_int { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.union.as_int() } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifr_flags</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; c_short { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.union.as_short() } }</code> </pre><br>  As a result, we have two structures.  First, IfReq, which represents the memory structure of ifreq in the C language. In it, we implement a method for each type of ioctl request.  Second, we have IfRequnion, which manages the different types of ifr_ifru union.  We will create a method for each type we need.  This is less time consuming than creating a specialized structure for each type of union, and provides a better interface than type conversion in IfReq itself. <br><br>  Here is a more complete <a href="">example</a> ready.  There is still a little work to do, but the tests pass, and the code described above is implemented in the code. <br><br>  Be careful, this approach is not perfect.  In the case of ifreq, we are lucky that ifr_name contains 16 bytes and is aligned with the word boundary.  If ifr_name were not aligned to the four-byte word boundary, we would have a problem.  The type of our association [u8;  24], which is aligned on the border of one byte.  A type of 24 bytes would have a different alignment.  Here is a brief example illustrating the problem.  Suppose we have a C-structure containing the following union: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; } y; }</code> </pre><br>  This structure is 8 bytes in size.  Two bytes for x, two more for alignment, and four bytes for y.  Let's try to portray this in Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>, y: [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>], }</code> </pre><br>  The Foo structure is only 6 bytes in size: two bytes for x and the first two u8 elements placed in the same four-byte word as x.  This subtle difference can cause problems when passing to the C function, which expects an 8-byte size structure. <br><br>  Until Rust supports joins, it will be difficult to solve such problems correctly.  Good luck, but be careful! </div><p>Source: <a href="https://habr.com/ru/post/280063/">https://habr.com/ru/post/280063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280047/index.html">How we wanted to do something with iBeacons</a></li>
<li><a href="../280049/index.html">JPoint 2016 Student Day - the first reports</a></li>
<li><a href="../280051/index.html">Logical showcase for accessing big data</a></li>
<li><a href="../280057/index.html">We create package for Atom</a></li>
<li><a href="../280059/index.html">Model alignment: what you need to know about creating strategies for trading on the exchange. Part II</a></li>
<li><a href="../280065/index.html">Fbi Detected: How I Discovered FBI Agents</a></li>
<li><a href="../280071/index.html">Introduction to PHP 7: What's added, what's removed</a></li>
<li><a href="../280073/index.html">Damn! Cloud computers! Choosing a thin client for Parallels VDI</a></li>
<li><a href="../280075/index.html">Java "var" keyword: please, not this</a></li>
<li><a href="../280077/index.html">Oracle SPARC T7 and M7 Servers - A New Platform for Secure Computing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>