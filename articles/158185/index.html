<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web development on node.js and express. Chapter 2 - Testing the Application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Less than six months later I finally got to writing the second chapter of the textbook. I also reworked the first chapter a little, taking into accoun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web development on node.js and express. Chapter 2 - Testing the Application</h1><div class="post__text post__text-html js-mediator-article">  Less than six months later I finally got to writing the second chapter of the textbook.  I also reworked the first chapter a little, taking into account the wishes of the habragers, so you can review it again - <a href="http://habrahabr.ru/post/146983/">Web development on node.js and express.</a>  <a href="http://habrahabr.ru/post/146983/">We study node.js in practice</a> <br><br><h2>  Chapter 2. Demo application and first tests </h2><br><br>  In this chapter we will begin to develop our application, which we will use as an example throughout the tutorial, and begin with the simplest, namely the static pages.  We will also learn about testing applications on node.js and the tools that are used for this. <br><a name="habracut"></a><br><h3>  2.1 Model-View-Controller (MVC) </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before embarking on the actual development of the application, it is useful to talk about what constitutes the typical architecture of a web application at the highest level of abstraction.  The most popular architectural pattern for today is the <a href="http://ru.wikipedia.org/wiki/Model-View-Controller">model-view-controller</a> (MVC), the general meaning of the pattern is to separate the business logic of the application (it is tied to the models) and the view.  In addition, the models implement an interface to the database.  The controller plays a mediating role between the model and the view.  In the case of a web application, it looks like this: the user's browser sends a request to the server, the controller processes the request, receives the necessary data from the model and sends it to the view.  View receives data from the controller and turns it into a beautiful HTML page that the controller eventually sends to the user. <br><img src="https://habrastorage.org/storage2/64c/838/bb9/64c838bb9594c7e28ebbc5c8b355500c.jpg"><br><br><h3>  2.2 Demo application </h3><br><br>  It's time to start developing our demo application.  In the first chapter, we have already deployed a test application, but used the express generator and did not write a single line of code.  Now we will write our application ourselves and start with ‚ÄúHello, World‚Äù. <br><br><pre><code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/projects/node-tutorial $ mkdir node-demo-app $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> node-demo-app</code> </pre> <br><br><h4>  2.2.1 npm packages </h4><br><br>  What is npm?  It's simple, this is a node package manager (although the authors <a href="https://npmjs.org/doc/faq.html">dispute</a> this).  In general, the npm package is the directory containing the program and the package.json file describing this program, including in this file you can specify from which other packages our program depends, read the <a href="https://npmjs.org/doc/json.html">description of package.json</a> . <br>  In order to use all the charms that npm can give us, we will create a file in the root directory of our project: <br><br><pre> <code class="bash hljs">$ touch package.json</code> </pre><br><br>  package.json: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-demo-app"</span></span> , <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> , <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node server.js"</span></span> } , <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.0.x"</span></span> } }</code> </pre><br><br>  Now you can run <br><br><pre> <code class="bash hljs">$ npm install</code> </pre><br><br>  As a result, npm will create a node_modules directory in which it will place all the modules on which our project depends. <br><br><h4>  2.2.2 Hello, World! </h4><br><br>  The main file is server.js: <br><br><pre> <code class="bash hljs">$ touch server.js</code> </pre><br><br>  server.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) , app = express() , port = process.env.PORT || <span class="hljs-number"><span class="hljs-number">3000</span></span> app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.send(<span class="hljs-string"><span class="hljs-string">'Hello, World!'</span></span>) }) app.listen(port, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Listening on port '</span></span>, port) })</code> </pre><br><br>  Immediately determine the terminology and analyze this code.  Our <b>application</b> will be an <code>app</code> object, the function call <code>app.get</code> <b>mounts the</b> <b>action</b> (action), which in this case performs an anonymous function, to the <b>route</b> (route) '/'.  In fact, this means that every time an http GET / request is received, the application will execute the specified action.  The variable <code>port</code> in this example is initialized by the environment variable <code>PORT</code> if it exists, and if there is no such variable, it takes the value 3000. <code>app.listen</code> starts the http server on the specified port and starts listening to incoming requests. <br><br>  In order to admire the result of our work, there are two ways: <br><br><pre> <code class="bash hljs">$ node server.js</code> </pre><br><br>  or <br><br><pre> <code class="bash hljs">$ npm start</code> </pre><br><br>  The second method is available because we added the appropriate line to the configuration file package.json in the ‚Äúscripts‚Äù section. <br><br>  Now at <a href="http://localhost:3000/">http: // localhost: 3000 /</a> you can get the line 'Hello, World!'. <br><br>  It's time to upload something to GitHub.  Create a new repository on GitHub with the name node-demo-app and execute the following set of commands in the project directory, first create the README.md file (good tone rule) <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'# Node.js demo app'</span></span> &gt; README.md</code> </pre><br><br>  Create a .gitignore file in order not to commit extra files in git, namely the node_modules directory: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'node_modules'</span></span> &gt; .gitignore</code> </pre><br><br>  Maybe someone read the Mikeal Rogers <a href="http://www.mikealrogers.com/posts/nodemodules-in-git.html">article</a> and would like to argue against adding node_modules to .gitignore.  For those who are too lazy to read, in the projects on node.js this approach is recommended: <br><ul><li>  For projects that we <strong>deploy</strong> , such as web applications, node_modules are placed in the repository. </li><li>  For libraries and other reusable code, node_modules are not added to the repository. </li><li>  For deployment to production npm is not used. </li></ul><br><br>  But!  We use Heroku as the hosting and the deployment method is not selected, and there the node.js projects are deployed using npm, so we will not trash the repository. <br><br>  Create a repository, commit and upload everything on GitHub: <br><br><pre> <code class="bash hljs">$ git init $ git add . $ git commit -m <span class="hljs-string"><span class="hljs-string">'Hello, World'</span></span> $ git remote add origin git@github.com:&lt;username&gt;/node-demo-app.git $ git push -u origin master</code> </pre><br><br><h4>  2.2.3 Application structure </h4><br><br>  Express does not yet dictate a strict structure for the application files, so we will invent our own.  I suggest this option: <br><br><pre> <code class="bash hljs">/node-demo-app |- /app | |- /controllers -  | |- /models -  | |- /views - html  | |- config.js -     | |- main.js -    |- /public -  - ,  ,   .. |- /tests -   |- app.js -   |- server.js - http </code> </pre><br><br>  No one forces you to stick to just this kind of file layout, but it seems convenient to me, so just remember this picture and as we move through the tutorial we will create the necessary files and directories. <br><br><h3>  2.3 Testing the application </h3><br><br>  What is TDD and why you need to write tests have probably already been heard, and if not, you can read about it <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">here</a> .  In this tutorial, we‚Äôll use an approach called <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> (behavior-driven development) to test the application.  In tests, we will describe the intended behavior of the application.  The tests themselves will be divided into two categories: integration tests - they will simulate user behavior and test the entire system, and unit tests - to test individual application modules. <br><br><h4>  2.3.1 Automatic tests </h4><br><br>  As frameworks for writing tests, we will use the <a href="http://visionmedia.github.com/mocha/">mocha</a> libraries (read like mocha, coffee mocha :)), <a href="https://github.com/visionmedia/should.js/">should.js</a> , and <a href="https://github.com/visionmedia/supertest">supertest</a> .  Mocha is used to organize test case descriptions, should.js provides the syntax for performing various checks, and supertest is an add-on for a simple http client that allows you to check the results of http requests.  To connect libraries we will make the necessary changes in package.json <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-demo-app"</span></span> , <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> , <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node server.js"</span></span> } , <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.0.x"</span></span> } , <span class="hljs-string"><span class="hljs-string">"devDependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"mocha"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.7.0"</span></span> , <span class="hljs-string"><span class="hljs-string">"should"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.2.1"</span></span> , <span class="hljs-string"><span class="hljs-string">"supertest"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> } }</code> </pre><br><br>  We placed the dependencies in the ‚ÄúdevDependencies‚Äù section, since there is no need to drag these libraries to the production server.  To install the libraries run <br><br><pre> <code class="bash hljs">$ npm install</code> </pre><br><br>  In order to understand how this works, we will try to create our first test and run it through our framework. <br><br><pre> <code class="bash hljs">$ mkdir tests $ touch tests/test.js</code> </pre><br><br>  In test.js we put such a test <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'Truth'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ it(<span class="hljs-string"><span class="hljs-string">'should be true'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-literal"><span class="hljs-literal">true</span></span>.should.be.true }) it(<span class="hljs-string"><span class="hljs-string">'should not be false'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-literal"><span class="hljs-literal">true</span></span>.should.not.be.false }) })</code> </pre><br><br>  and run it <br><br><pre> <code class="bash hljs">$ ./node_modules/.bin/mocha --require should --reporter spec tests/test.js</code> </pre><br><br>  It is quite natural that such a test will pass, so replace it with something that does not work. <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'foo variable'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ it(<span class="hljs-string"><span class="hljs-string">'should equal bar'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ foo.should.equal(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) }) })</code> </pre><br><br>  run <br><br><pre> <code class="bash hljs">$ ./node_modules/.bin/mocha --require should --reporter spec tests</code> </pre><br><br>  and we see that the tests did not pass, we will have to repair the code, add the variable declaration <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-string"><span class="hljs-string">'bar'</span></span> describe(<span class="hljs-string"><span class="hljs-string">'foo variable'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ it(<span class="hljs-string"><span class="hljs-string">'should equal bar'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ foo.should.equal(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) }) })</code> </pre><br><br>  run <br><br><pre> <code class="bash hljs">$ ./node_modules/.bin/mocha --require should --reporter spec tests/test.js</code> </pre><br><br>  and see that the code is working. <br><br>  The basic principle of TDD is to write tests before writing the code, so we can make sure that the tests really test something, and not just run the code and do tests in the style of true.should.be. true  That is, the development process is as follows: <br><br><ol><li>  We write a test </li><li>  Perform a test and make sure that it falls. </li><li>  Write the code </li><li>  We carry out the test and make sure that it passes, if not, we return to step 3 </li></ol><br><br>  And so many times. <br><br>  To simplify the test run, add a task test runner to the Makefile <br><br><pre> <code class="bash hljs">$ touch Makefile</code> </pre><br><br>  Makefile Content: <br><br><pre> <code class="bash hljs">REPORTER=spec TESTS=$(shell find ./tests -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -name <span class="hljs-string"><span class="hljs-string">"*.js"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: @NODE_ENV=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./node_modules/.bin/mocha \ --require should \ --reporter $(REPORTER) \ $(TESTS) .PHONY: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre><br><br>  Traditionally, make was used to build a project, but it is convenient to use it and, in general, to automate routine tasks.  Read about using the Makefile <a href="http://mrbook.org/tutorials/make/">here</a> .  I draw attention to the fact that the indents after the title of task should be made tabs, not spaces. <br><br>  Now you can run the test suite with the command: <br><br><pre> <code class="bash hljs">$ make <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre><br><br>  Let's try to test http requests.  In order to make testing more convenient, we will conduct a small code refactoring and move the express application from the server.js file to a separate app / main.js module, and also create an app.js file that will export this module.  Now it may not seem appropriate, but this way of organizing the code will come in handy when we check the code coverage with tests. <br><br><pre> <code class="bash hljs">$ mkdir app $ touch app/main.js</code> </pre><br><br>  app / main.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) , app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.send(<span class="hljs-string"><span class="hljs-string">'Hello, World!'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = app</code> </pre><br><br><pre> <code class="bash hljs">$ touch app.js</code> </pre><br><br>  app.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(__dirname + <span class="hljs-string"><span class="hljs-string">'/app/main'</span></span>)</code> </pre><br><br>  server.js is replaced by <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(__dirname + <span class="hljs-string"><span class="hljs-string">'/app'</span></span>) , port = process.env.PORT || <span class="hljs-number"><span class="hljs-number">3000</span></span> app.listen(port, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Listening on port '</span></span>, port) })</code> </pre><br><br>  In order to understand how the node.js modules work, as well as what <code>require</code> and <code>module.exports</code> read the <a href="http://nodejs.org/docs/latest/api/modules.html">documentation.</a> <br><br>  In order to verify the correctness of the http request, we will write the following code in test.js <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'supertest'</span></span>) , app = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(__dirname + <span class="hljs-string"><span class="hljs-string">'/../app'</span></span>) describe(<span class="hljs-string"><span class="hljs-string">'GET /'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ it(<span class="hljs-string"><span class="hljs-string">'should contain text "Hello, Express!"'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function">) </span></span>{ request(app) .get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .expect(<span class="hljs-regexp"><span class="hljs-regexp">/Hello, Express!/</span></span>, done) }) })</code> </pre><br><br>  In this test, we verify that the server responds with the ‚ÄúHello, Express!‚Äù Line.  Since the server responds with ‚ÄúHello, World!‚Äù Instead, the test will drop.  An important point that you need to pay attention to, requests to the http server occur asynchronously, so we will need to assign a callback to complete the test.  Mocha provides this feature using the done function, which can optionally be passed to a function with a test case.  In order for the test to pass, you need to replace the ‚ÄúHello, World!‚Äù Line with ‚ÄúHello, Express!‚Äù In the app / main.js file and run <code>make test</code> . <br><br><h4>  2.3.2 Code Coverage Tests </h4><br><br>  In principle, this paragraph can be skipped, since it does not affect the process of writing a test application, but a report on the coverage of code with tests will be a nice addition to our test suite. <br><br>  To find out how completely our code <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25B0">is covered with</a> tests, we need another tool, it is called <a href="https://github.com/visionmedia/node-jscoverage">jscoverage</a> .  It should be compiled.  So if you have not yet installed the compiler, you should put it: <br><br><pre> <code class="bash hljs">$ sudo apt-get install g++</code> </pre><br><br>  Then install jscoverage: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /tmp $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/visionmedia/node-jscoverage.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> node-jscoverage $ ./configure &amp;&amp; make $ sudo make install</code> </pre><br><br>  Return to the project directory: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/projects/node-tutorial/node-demo-app/</code> </pre><br><br>  We will need to make some changes to the Makefile and app.js in order to be able to generate coverage reports. <br><br>  Makefile: <br><br><pre> <code class="bash hljs">REPORTER=spec TESTS=$(shell find ./tests -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -name <span class="hljs-string"><span class="hljs-string">"*.js"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: @NODE_ENV=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./node_modules/.bin/mocha \ --require should \ --reporter $(REPORTER) \ $(TESTS) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-cov: app-cov @APP_COV=1 $(MAKE) --quiet <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> REPORTER=html-cov &gt; coverage.html app-cov: @jscoverage app app-cov .PHONY: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre><br><br>  app.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = process.env.APP_COV ? <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(__dirname + <span class="hljs-string"><span class="hljs-string">'/app-cov/main'</span></span>) : <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(__dirname + <span class="hljs-string"><span class="hljs-string">'/app/main'</span></span>)</code> </pre><br><br>  We added the test-cov task to the Makefile so that now to generate the report coverage.js, it suffices to run <code>make test-cov</code> .  The changes in app.js are due to the fact that the report is generated using an instrumented copy of the application that jscoverage generates.  That is, we check the <code>APP_COV</code> environment <code>APP_COV</code> and if it is installed, load the application from the / app-cov directory, and if not, we take the regular version from / app. <br><br>  We generate the report: <br><br><pre> <code class="bash hljs">$ make <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-cov</code> </pre><br><br>  A coverage.html file should appear, which can be opened in a browser. <br><br>  It remains to add app-cov and coverage.html to .gitignore: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'app-cov'</span></span> &gt;&gt; .gitignore $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'coverage.html'</span></span> &gt;&gt; .gitignore</code> </pre><br><br>  We have dealt with the tests, so we remove the test test. <br><br><pre> <code class="bash hljs">$ rm tests/test.js</code> </pre><br><br>  And we commit <br><br><pre> <code class="bash hljs">$ git add . $ git ci -m <span class="hljs-string"><span class="hljs-string">"Added testing framework"</span></span> $ git push</code> </pre><br><br>  The source code of the demo application can be obtained here: <a href="https://github.com/DavidKlassen/node-demo-app/">github.com/DavidKlassen/node-demo-app</a> <br><br>  On the approach of the third chapter, in it we will write a full-fledged controller for the pages of the site and deal with the standardization of express. </div><p>Source: <a href="https://habr.com/ru/post/158185/">https://habr.com/ru/post/158185/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../158167/index.html">jQuery File Upload. Upload and add images to the database</a></li>
<li><a href="../158169/index.html">Running Gadgets: From Simple to Very Simple</a></li>
<li><a href="../158171/index.html">We make from the old ‚Äústupid‚Äù TV - new and ‚Äúsmart‚Äù and that ‚Äúbeautiful‚Äù was</a></li>
<li><a href="../158177/index.html">Ethernet physics for the smallest</a></li>
<li><a href="../158183/index.html">Audit users in AD through VBS, listed in SharePoint using PowerShell</a></li>
<li><a href="../158187/index.html">Completing the patent war between Apple and HTC</a></li>
<li><a href="../158189/index.html">FileCorrupter utility for testing products on broken input data</a></li>
<li><a href="../158193/index.html">Crash test of electric lamps at low temperatures (up to -145 degrees Celsius)</a></li>
<li><a href="../158195/index.html">Canonical launches new Ubuntu 13.04 Raring Ringtail builds every day.</a></li>
<li><a href="../158199/index.html">Meet filestream.me</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>