<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The problem of initializing objects in OOP applications in PHP. Finding a solution using the Registry, Factory Method, Service Locator and Dependency Injection templates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It so happened that programmers fix successful solutions in the form of design patterns. There are a lot of literature on patterns. The Gang of Four b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The problem of initializing objects in OOP applications in PHP. Finding a solution using the Registry, Factory Method, Service Locator and Dependency Injection templates</h1><div class="post__text post__text-html js-mediator-article">  It so happened that programmers fix successful solutions in the form of design patterns.  There are a lot of literature on patterns.  The Gang of Four <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">book Design Patterns by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides</a> and, perhaps, <a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">the Patterns of Enterprise Application Architecture by Martin Fowler are</a> definitely considered classics. The best I've read with examples in PHP - this is <a href="http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X">"PHP Objects, Patterns and Practice" by Matt Zandstra</a> . It so happened that all this literature is quite difficult for people who have just started to master the OOP. Therefore, I had an idea to present some patterns that I consider most useful, In simplified form. In other words, this article is my first attempt to interpret the design patterns  in <a href="http://en.wikipedia.org/wiki/KISS_principle">KISS</a> style. <br>  Today we will talk about what problems may arise with the initialization of objects in OOP application and how you can use some popular design patterns to solve these problems. <br><a name="habracut"></a><br><h3>  Example </h3><br>  Modern OOP application works with dozens, hundreds, and sometimes thousands of objects.  Well, let's take a close look at how these objects are initialized in our applications.  The initialization of objects is the only aspect that interests us in this article, so I decided to omit all the ‚Äúextra‚Äù implementation. <br>  Suppose we have created a super-duper useful class that can send a GET request to a specific URI and return the HTML from the server response.  So that our class does not seem too simple, let it also check the result and throw an exception in case of a ‚Äúwrong‚Äù server response. <br><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grabber</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/** returns HTML code or throws an exception */</span></span>} }</code> </pre> <br><br>  Let's create another class whose objects will be responsible for filtering the resulting HTML.  The filter method accepts HTML code and a CSS selector as arguments, and it returns an array of the found elements according to the given selector. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HtmlExtractor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($html, $selector)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/** returns array of filtered elements */</span></span>} }</code> </pre><br><br>  Now, imagine that we need to get Google search results for specific keywords.  To do this, we introduce another class that will use the Grabber class to send a request, and the HtmlExtractor class to retrieve the necessary content.  It will also contain the logic for building a URI, a selector for filtering the resulting HTML and processing the results. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleFinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $grabber; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $filter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;grabber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grabber(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlExtractor(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($searchString)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** returns array of founded results */</span></span>} }</code> </pre><br><br>  Have you noticed that the initialization of the Grabber and HtmlExtractor objects is in the constructor of the GoogleFinder class?  Let's think about how successful this solution is. <br>  Of course, hardcoding object creation in the constructor is not the best idea.  And that's why.  First, we cannot easily substitute the Grabber class in a test environment to avoid sending a real request.  In fairness, it is worth saying that this can be done using the <a href="http://php.net/manual/en/book.reflection.php">Reflection API</a> .  Those.  a technical possibility exists, but this is far from the most convenient and obvious way. <br>  Secondly, the same problem will arise if we want to reuse GoogleFinder logic with other implementations of Grabber and HtmlExtractor.  Creating dependencies is hard coded in the class constructor.  And in the best case, we can inherit GoogleFinder and override its constructor.  And then, only if the scope of the grabber and filter properties is protected or public. <br>  And the last moment, each time a new GoogleFinder object is created, a new pair of dependency objects will be created in memory, although we may well use one Grabber object and one HtmlExtractor object in several GoogleFinder objects. <br>  I think that you already understood that dependency initialization needs to be moved out of class.  We may require that already prepared dependencies are passed to the GoogleFinder class constructor. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleFinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $grabber; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $filter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Grabber $grabber, HtmlExtractor $filter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;grabber = $grabber; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;filter = $filter; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($searchString)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** returns array of founded results */</span></span>} }</code> </pre><br><br>  If we want to give other developers the ability to add and use their own Grabber and HtmlExtractor implementations, then we should consider introducing interfaces for them.  In this case, it is not only useful, but necessary.  I believe that if we use only one implementation in the project and do not assume the creation of new ones in the future, then we should abandon the creation of the interface.  It is better to act on the situation and do simple refactoring when there is a real need for it. <br>  Now we have all the necessary classes and we can use the GoogleFinder class in the controller. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some stuff */</span></span> $finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleFinder(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grabber(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlExtractor()); $results = $finder-&gt;find(<span class="hljs-string"><span class="hljs-string">'search string'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Do something with results */</span></span> } }</code> </pre><br><br>  Let's summarize the subtotal.  We wrote quite a bit of code, and at first glance, we didn‚Äôt do anything wrong.  But ... and what if we need to use an object like GoogleFinder elsewhere?  We will have to duplicate its creation.  In our example, this is just one line and the problem is not so noticeable.  In practice, the initialization of objects can be quite complicated and can take up to 10 lines, or even more.  There are also other problems typical for code duplication.  If in the process of refactoring you need to change the name of the used class or the logic of object initialization, you will have to manually change all the places.  I think you know how it happens :) <br>  Usually with a hardcode come simply.  Duplicate values ‚Äã‚Äãare usually put into configuration.  This allows you to centrally change values ‚Äã‚Äãin all places where they are used. <br><br><h3>  Registry template. </h3><br>  So, we decided to put the creation of objects in the configuration.  Let's do that. <br><br><pre> <code class="php hljs">$registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayObject(); $registry[<span class="hljs-string"><span class="hljs-string">'grabber'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grabber(); $registry[<span class="hljs-string"><span class="hljs-string">'filter'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlExtractor(); $registry[<span class="hljs-string"><span class="hljs-string">'google_finder'</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleFinder($registry[<span class="hljs-string"><span class="hljs-string">'grabber'</span></span>], $registry[<span class="hljs-string"><span class="hljs-string">'filter'</span></span>]);</code> </pre><br>  It remains only to transfer our ArrayObject to the controller and the problem is solved. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $registry; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayObject $registry)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;registry = $registry; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some stuff */</span></span> $results = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;registry[<span class="hljs-string"><span class="hljs-string">'google_finder'</span></span>]-&gt;find(<span class="hljs-string"><span class="hljs-string">'search string'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Do something with results */</span></span> } }</code> </pre><br><br>  You can further develop the idea of ‚Äã‚ÄãRegistry.  Inherit ArrayObject, encapsulate the creation of objects inside a new class, prohibit adding new objects after initialization, etc.  But in my opinion, the above code fully makes it clear what the Registry template is.  This template does not apply to generators, but it does allow us to solve our problems to some extent.  Registry is just a container in which we can store objects and transfer them within the application.  To make the objects available, we need to create them first and register them in this container.  Let's analyze the advantages and disadvantages of this approach. <br>  At first glance, we have achieved our goal.  We stopped hardcoding class names and create objects in one place.  We create objects in a single copy, which guarantees their reuse.  If the logic of creating objects changes, then only one place in the application will need to be edited.  As a bonus, we got the opportunity to centrally manage objects in the Registry.  We can easily get a list of all available objects, and carry out any manipulations with them.  Let's now see what might not suit us in this template. <br>  First, we must create an object before registering it with the Registry.  Accordingly, the probability of creating ‚Äúunnecessary objects‚Äù is high, i.e.  those that will be created in memory, but will not be used in the application.  Yes, we can add objects to the registry dynamically, i.e.  create only those objects that are needed to process a specific request.  One way or another, we‚Äôll have to control this manually.  Accordingly, over time it will become very difficult to maintain it. <br>  Secondly, we have a new dependency on the controller.  Yes, we can receive objects through a static method in the Registry, so as not to transfer the Registry to the constructor.  But in my opinion, do not do this.  Static methods are even tougher than creating dependencies within an object, and testing difficulties (this is a <a href="http://kore-nordmann.de/blog/0103_static_considered_harmful.html">good article</a> on this topic). <br>  Thirdly, the controller interface does not tell us what objects are used in it.  We can get in the controller any object available in the registry.  It will be hard for us to say exactly which objects the controller uses, until we check all its source code. <br><br><h3>  Factory Method </h3><br>  In the Registry, we are most uncomfortable with the fact that the object must first be initialized in order for it to become accessible.  Instead of initializing an object in a configuration, we can select the logic for creating objects into another class, from which it will be possible to ‚Äúask‚Äù to build the object we need.  Classes that are responsible for creating objects are called factories.  And the design pattern is called Factory Method.  Let's look at an example of a factory. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGoogleFinder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleFinder(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getGrabber(), <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getHtmlExtractor()); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGrabber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grabber(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHtmlExtractor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlFiletr(); } }</code> </pre><br><br>  As a rule, they make factories that are responsible for creating one type of objects.  Sometimes a factory can create a group of related objects.  We can use caching in a property to avoid re-creating objects. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $finder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGoogleFinder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> === <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;finder) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleFinder(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getGrabber(), <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getHtmlExtractor()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;finder; } }</code> </pre><br><br>  We can parameterize the factory method and delegate initialization to other factories depending on the input parameter.  This will be the Abstract Factory pattern. <br>  If it becomes necessary to split the application into modules, we can demand that each module provide its own factories.  We can further develop the theme of factories, but I think that the essence of this template is clear.  Let's see how we will use the factory in the controller. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $factory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Factory $factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;factory = $factory; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some stuff */</span></span> $results = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;factory-&gt;getGoogleFinder()-&gt;find(<span class="hljs-string"><span class="hljs-string">'search string'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Do something with results */</span></span> } }</code> </pre><br><br>  To the advantages of this approach, let's attribute it to simplicity.  Our objects are created explicitly, and your IDE will easily lead you to the place where it occurs.  We also solved the Registry problem and objects in memory will be created only when we ‚Äúask‚Äù the factory about it.  But we have not yet decided how to supply the necessary factories to the controllers.  There are several options.  You can use static methods.  You can let the controllers create the necessary factories themselves and negate all our attempts to get rid of copy-paste.  You can create a factory of factories and transfer only it to the controller.  But getting objects in the controller will be a little more difficult, and you will need to manage dependencies between the factories.  In addition, it is not entirely clear what to do if we want to use modules in our application, how to register module factories, how to manage connections between factories from different modules.  In general, we lost the main advantage of the factory - the explicit creation of objects.  And while still not solved the problem of the "implicit" controller interface. <br><br><h3>  Service Locator </h3><br>  The Service Locator template allows you to solve the lack of fragmentation of factories and manage the creation of objects automatically and centrally.  If we think about it, we can introduce an additional layer of abstraction, which will be responsible for creating objects in our application and manage the relations between these objects.  In order for this layer to be able to create objects for us, we will need to give it the knowledge of how to do it. <br>  Terms of Service Locator Template: <br><ul><li>  Service (Service) - the finished object, which can be obtained from the container. </li><li>  Service Description (Service Definition) - service initialization logic. </li><li>  Service Container is a central object that stores all descriptions and is able to create services using them. </li></ul>  Any module can register their service descriptions.  To get some service from the container we will need to request it by key.  There are many options for implementing a Service Locator; in the simplest version, we can use ArrayObject as a container and a closure, as a description of services. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_callable(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>[$key])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_user_func(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>[$key]); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can not find service definition under the key [ $key ]"</span></span>); } }</code> </pre><br><br>  Then registration Definitions will look like this: <br><br><pre> <code class="php hljs">$container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceContainer(); $container[<span class="hljs-string"><span class="hljs-string">'grabber'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grabber(); }; $container[<span class="hljs-string"><span class="hljs-string">'html_filter'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlExtractor(); }; $container[<span class="hljs-string"><span class="hljs-string">'google_finder'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleFinder($container-&gt;get(<span class="hljs-string"><span class="hljs-string">'grabber'</span></span>), $container-&gt;get(<span class="hljs-string"><span class="hljs-string">'html_filter'</span></span>)); };</code> </pre><br><br>  And use, in the controller as follows: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $container; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceContainer $container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;container = $container; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some stuff */</span></span> $results = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;container-&gt;get(<span class="hljs-string"><span class="hljs-string">'google_finder'</span></span>)-&gt;find(<span class="hljs-string"><span class="hljs-string">'search string'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Do something with results */</span></span> } }</code> </pre><br><br>  Service Container can be very simple, and can be very difficult.  For example, Symfony Service Container provides a lot of possibilities: parameters (parameters), services scope (scopes), search for services by tags (tags), aliases (aliases), closed services (private services), the ability to make changes to the container after adding all services (compiller passes) and whatnot.  DIExtraBundle further enhances the standard implementation. <br>  But back to our example.  As you can see, the Service Locator not only solves all the problems that the previous templates have, but also makes it easy to use modules with their own service definitions. <br>  In addition, at the framework level, we received an additional level of abstraction.  Namely, by changing the ServiceContainer :: get method we can, for example, replace an object with a proxy.  And the scope of proxy objects is limited only by the imagination of the developer.  Here you can implement the AOP paradigm, and LazyLoading, etc. <br>  But, most developers still consider Service Locator an anti-pattern.  Because, in theory, we can have any number of so-called.  Container Aware classes (i.e. such classes that contain a reference to the container).  For example, our Controller, within which we can get any service. <br>  Let's see why this is bad. <br>  First, again testing.  Instead of creating mocks only for the classes used in tests, you will have to make the whole container or use a real container.  The first option does not suit, because  you have to write a lot of unnecessary code in the tests, the second, because  it contradicts the principles of unit testing, and may lead to additional costs for test support. <br>  Secondly, it will be difficult for us to refactor.  By changing any service (or ServiceDefinition) in the container, we will have to check all dependent services as well.  And this problem is not solved with the help of IDE.  Finding such places throughout the application will not be so easy.  In addition to the dependent services, it will also be necessary to check all the places where the refactored service is obtained from the container. <br>  Well, the third reason is that uncontrolled tugging of services from a container will sooner or later lead to a mess in the code and unnecessary confusion.  It is difficult to explain, you just need to spend more and more time to understand how a particular service works, in other words, you can fully understand what a class is doing or how it works by only reading all its source code. <br><br><h3>  Dependency Injection </h3><br>  What else can be done to limit the use of the container in the application?  You can transfer to the framework the management of the creation of all user objects, including controllers.  In other words, user code should not call the get method on the container.  In our example, we can add a Definition for the controller to the container: <br><br><pre> <code class="php hljs">$container[<span class="hljs-string"><span class="hljs-string">'google_finder'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller(Grabber $grabber); };</code> </pre><br><br>  And get rid of the container in the controller: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $finder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleFinder $finder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;finder = $finder; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some stuff */</span></span> $results = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;finder-&gt;find(<span class="hljs-string"><span class="hljs-string">'search string'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Do something with results */</span></span> } }</code> </pre><br><br>  Such an approach (when access to the Service Container is not provided to client classes) is called Dependency Injection.  But this template has both advantages and disadvantages.  As long as we observe the principle of sole responsibility, the code looks very nice.  First of all, we got rid of the container in the client classes, thanks to which their code became much clearer and simpler.  We can easily test the controller by replacing the necessary dependencies.  We can create and test each class independently of others (including controller classes) using the TDD or BDD approach.  When creating tests, we will be able to abstract away from the container, and later add a Definition when we need to use specific instances.  All this will make our code easier and clearer, and testing is more transparent. <br>  But, it is necessary to mention the reverse side of the coin.  The point is that controllers are very specific classes.  To begin with, the controller, as a rule, contains a set of actions, which means it violates the principle of sole responsibility.  As a result, the controller class may have much more dependencies than is necessary to perform a particular action.  The use of deferred initialization (the object is instantiated at the time of first use, and before that a lightweight proxy is used) to some extent solves the issue of performance.  But from the point of view of architecture, creating many dependencies on a controller is also not entirely correct.  In addition, testing of controllers is usually an unnecessary operation.  Everything, of course, depends on how the testing is organized in your application and on how you yourself feel about it. <br>  From the previous paragraph, you realized that using Dependency Injection does not completely eliminate the problems with the architecture.  Therefore, think how it will be more convenient for you to store a link to the container in controllers or not.  There is no one right decision.  I believe that both approaches are good as long as the controller code remains simple.  But, definitely, you should not create Conatiner Aware services besides controllers. <br><br><h3>  findings </h3><br>  Well, it's time to beat all of the above.  And it was said a lot ... :) <br>  So, to structure the work on the creation of objects, we can use the following patterns: <br><ul><li>  <strong>Registry</strong> : The template has obvious flaws, the most basic of which is the need to create objects before putting them into a common container.  Obviously, we will get more problems rather than benefits from its use.  This is clearly not the best use of the template. </li><li>  <strong>Factory Method</strong> : The main advantage of the pattern: objects are created explicitly.  The main disadvantage is that the controllers must either worry about creating factories, which does not solve the problem of the hardcode class names completely, or the framework should be responsible for supplying controllers with all the necessary factories, which will not be so obvious.  There is no possibility to centrally manage the process of creating objects. </li><li>  <strong>Service Locator</strong> : A more ‚Äúadvanced‚Äù way to manage the creation of objects.  An additional level of abstraction can be used to automate typical tasks encountered when creating objects.  For example: <br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_callable(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>[$key])) { $obj = call_user_func(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>[$key]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> RequestAwareInterface) { $obj-&gt;setRequest(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;get(<span class="hljs-string"><span class="hljs-string">'request'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $obj; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can not find service definition under the key [ $key ]"</span></span>); } }</code> </pre><br>  The disadvantage of the Service Locator is that the public API of classes is no longer informative.  It is necessary to read the entire class code in order to understand which services it uses.  The class that contains the link to the container is harder to test. </li><li> <strong>Dependency Injection</strong> :        Service Container,     .   ,    .         ,      API . </li></ul>   ,           PHP .    Prototype,     Reflection API,             .    ,   :) <br>   ,  Dependency Injection        ,   . <br>    Dependency Injection,    KISS   ,  <a href="http://pimple.sensiolabs.org/">Pimple</a> ,         .    ,  <a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Symfony Dependency Injection Component</a> .      ,      . <br>  ,            . <br><br>  Have fun! <br><br> PS  ,           .       ;) </div><p>Source: <a href="https://habr.com/ru/post/183658/">https://habr.com/ru/post/183658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183642/index.html">The digest of interesting news and materials from the world of PHP over the last two weeks, No. 19 (06/03/2013 - 06/17/2013)</a></li>
<li><a href="../183646/index.html">Commit Naming Style</a></li>
<li><a href="../183648/index.html">Excursion to the new Supermicro plant</a></li>
<li><a href="../183650/index.html">Another way to get custom data in iOS</a></li>
<li><a href="../183654/index.html">Parsing command line arguments</a></li>
<li><a href="../183660/index.html">ToS; DR simplifies legal documents to key phrases</a></li>
<li><a href="../183664/index.html">Today at 10:00 (Moscow time) connect to the online broadcast of the first technology conference on Windows 8</a></li>
<li><a href="../183666/index.html">Recovery Electronics IM-22</a></li>
<li><a href="../183668/index.html">Two-faced REQUEST_URI or in search of a correct HTTP / 1.1 server</a></li>
<li><a href="../183670/index.html">Talk about ... flashlights?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>