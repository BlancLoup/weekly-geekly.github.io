<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>REST services on ASP.NET Core under Linux in production</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is based on the report by Denis Ivanov ( @DenisIvanov ) on RIT ++ 2017, in which he shared his experience in developing and launching a R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>REST services on ASP.NET Core under Linux in production</h1><div class="post__text post__text-html js-mediator-article">  This article is based on the report by <strong>Denis Ivanov</strong> ( <a href="https://habrahabr.ru/users/DenisIvanov/">@DenisIvanov</a> ) on RIT ++ 2017, in which he shared his experience in developing and launching a REST service on ASP.NET Core on Kubernetes.  At the moment, you can already do this without any particular problems and you should not be afraid to use .NET Core, judging by the experience of 2GIS. <br><br>  Configuration: <strong>ASP.NetCore on Linux</strong> allowed not only to use the existing on-premise platform, but also brought several additional advantages, in particular, in the form of full-fledged <strong>Docker and Kubernetes</strong> , which greatly simplify life. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eWrRzOUaSBQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="AboutService"></a><br><h2>  About service </h2><br>  From April 1, 2017, an icon appeared in 2GIS products, which you can click on and the video will start playing.  Advertisers who are placed in the directory, can now buy a new way of advertising, and all the products of our company (mobile, online, API), go to the service, which I will talk about today. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The topology of this service is shown in the picture below.  The service is marked with a cloud in the center, it is essentially a backend for products.  When a product comes in and says: ‚ÄúGive me all the information about video advertising for this advertiser,‚Äù the service obediently gives it to him.  This is the information of such a plan: such a cover lies on such and such a CDN, such and such a video file in such resolutions is there and there, the video itself lasts such an amount of time and so on. <br><br><img src="https://habrastorage.org/webt/ar/xl/zf/arxlzf2z5ie0hq6lach4aqtvhe8.png"><br>  <strong><em>Caution: a</em></strong> lot of information and code. <br><a name="habracut"></a><br>  <strong><em>About the speaker:</em></strong> <em>Denis Ivanov works at 2GIS and is the MVP (Most Valuable Professional) in the field of Visual Studio and Development Technologies, his main technology stack is from Microsoft.</em> <br><br><h2>  Content </h2><br><ul><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">Briefly about the service</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">On-premise platform</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">.NET Core, ASP.NET Core and basic features</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">Build</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">Deploy</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">Stress Testing</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">Means of increasing productivity</a> , including: <br><ul><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">caching</a> </li><li>  <a href="https://habr.com/ru/company/oleg-bunin/blog/352168/">asynchrony and multithreading</a> </li></ul></li></ul><br>  So, let's continue ... Based on this information, our final products decide which video file to display: if it is online, the user has a large screen and a wide communication channel, then a higher resolution video is played;  if the mobile device is smaller. <br><br>  In order to distribute videos and transcode them, we use a separate API.  We will not talk about it today, as well as about everything related to the processing of media files, their placement on the CDN, their availability.  So far this makes our partner, but maybe later we will start doing it ourselves. <br><br>  Our service has another component (that is marked with locks on the diagram), for which we also have our own API and it is closed for external access.  These are internal processes in the company that are needed so that the users - our sales managers - sell this advertisement: upload videos, images, choose covers, that is, fully customize how it will look in the final product.  It also has its own API for such processes.  It is closed for external access. <br><br>  <strong>Requirements for video advertising service:</strong> <br><br><ul><li>  <strong>99.99% Worldwide Availability</strong> </li></ul><br>  When we started to develop the service, the first requirement was high availability, and all over the world.  We have users in Russia, in the CIS countries and there are several international projects, even in Chile. <br><br><ul><li>  <strong>200ms response time</strong> </li></ul><br>  The response time should be as short as possible, including as much as the API we use provides.  We chose a figure of 200 ms simply because we do not want to have any problems - we need to respond very quickly. <br><a name="OnPremisePlatform"></a><br><h2>  Why linux </h2><br><img src="https://habrastorage.org/webt/lc/kz/je/lckzjepegae6y9dnv7rb8mzxjcy.png"><br><br>  Our development team at 2GIS, is engaged in just advertising services and make a sales system within the company.  This project is our first experience in developing services specifically for public access.  We, as a development team, know very well .NET, since we have been doing this for 10 years (I have been at the company for 7 years) and have been building applications on this stack for a long time. <br><br>  For this project we have chosen ASP.Net Core.  Due to the high availability requirements that I have already mentioned, we need to place the service exactly where our final products are located, that is, to use the same platform.  In addition to the fact that we were able to use the <strong>existing on-premise platform</strong> , which is in 2GIS, we also received several additional advantages: <br><br><ul><li>  <strong>Gitlab ci</strong> </li></ul><br>  In my opinion, this is a good solution that helps launch the processes of continuous integration and continuous deployment and store the entire infrastructure as code.  There is a YAML file in which you can describe all the steps of the assembly. <br><br><ul><li>  <strong>CI starting kit based on make</strong> </li></ul><br>  There is a CI starting kit in the company.  He, by the way, open-source.  On the basis of make, the guys inside the company have written many different scripts that simply make it easier to perform routine tasks. <br><br><ul><li>  <strong>Docker hub &amp; docker images</strong> </li></ul><br>  We can fully use Docker, since it is Linux.  It is clear that Docker also exists on Windows, but the technology is quite new, and so far there are few examples of production applications. <br><br><ul><li>  <strong>Components on any technology stack</strong> </li></ul><br>  In addition, if you use Linux, you can make your applications using any technological stack, microservice approach, etc.  We can do some components on .Net, others - on other platforms.  We used this advantage to perform load testing of our application. <br><br><ul><li>  <strong>Kubernetes</strong> </li></ul><br>  Kubernetes can also be used simply because Linux. <br><br>  Therefore, the following configuration was formed: <strong>ASP.Net Core on Linux.</strong>  We began to learn what Microsoft has for this and from the community.  At the beginning of last year, everything with this question was already good: .Net was released in version 1, the libraries that we would need were also there.  Therefore, we start. <br><br><h2>  The Twelve-Factor App </h2><br>  We came to our guys who are engaged in a platform for hosting applications, and asked what requirements the application must meet in order to be comfortable to use later.  They said that it should be at least 12-factor.  I'll tell you about it in more detail. <br><br>  There is a set of <a href="https://12factor.net/ru/">12 rules</a> .  It is believed that if you follow them, your application will be good, isolated, and it can be raised using all the tools that concern Docker, etc. <br><br>  <strong>The Twelve-Factor App:</strong> <br><br><ol><li>  One application - one repository; </li><li>  Dependencies - along with the application; </li><li>  Configuration through the environment; </li><li>  Services used as resources; </li><li>  The build, image creation and execution phases are separated; </li><li>  Services are separate stateless processes; </li><li>  Port binding; </li><li>  Scaling through processes; </li><li>  Quick stop and start processes; </li><li>  The environments are most similar; </li><li>  Logging to stdout; </li><li>  Administrative processes. </li></ol><br>  I would like to highlight some of them. <br><br>  <strong>Dependencies - with the application.</strong>  This means that the application should not require any pre-setting from the environment where we are deploying it.  For example, there should not be .Net of a certain version, as we like it on Windows.  We have to carry both the application, and runtime, and the libraries that we use, along with the application itself, so that we can simply copy and run it. <br><br>  <strong>Configuration through the environment.</strong>  We all use Config files to configure the application to run at runtime.  But we would like to have some preset values ‚Äã‚Äãin these Config-files, and we could pass through the environment variables some additional parameters of the environment itself so as to make the application work in certain modes: it is a dev environment, or a staging environment or production. <br><br>  But the application code and different configuration parameters should not change.  In classic .Net, which is on Windows, there is such a thing as the transformation of configs (XDT-transformation), which is no longer needed here, and everything is greatly simplified. <br><br>  Another important feature that introduces 12-factorality: we must be able to <strong>quickly stop and start new processes.</strong>  If we use the application in any environment, and suddenly something happened to it, we should not wait.  It is better that Wednesday itself extinguish our application and launch it again.  In particular, there may be reconfigurations of the environment itself, this should not affect the application. <br><br>  <strong>Logging to stdout</strong> is another important thing.  All the logs that our application produces should be logged to the console, and then the platform on which the application is running will figure out: take these logs and put them in a file, or in ELK in Elasticsearch or simply show the console. <br><a name="NETCore"></a><br><h2>  .NET Core </h2><br>  Microsoft has long been the good old .NET, which is on Windows, which has WPF, Windows Forms, ASP.Net, under it there is the Base Class Library, Runtime, and so on. <br><br><img src="https://habrastorage.org/webt/tx/a3/te/txa3teeokc1hjqf5ejrcuaq7vcs.png"><br><br>  But, on the other hand, there has always been an alternative approach - take mono and actually run the code written in C # on other platforms.  Microsoft made another stack called .NET Core, where they just implemented the ability to write applications that would be initially cross-platform. <br><br><img src="https://habrastorage.org/webt/ug/_h/j6/ug_hj6hjazncpqwkaibr3cwdz3m.png"><br><br>  They have done quite a lot in order to create a common infrastructure: compilers, languages ‚Äã‚Äãand runtime - all cross-platform. <br><br>  On the .NET Core there is a UWP block - this is a separate world.  It allows you to run .NET-applications under different platforms, from IoT-devices to the desktop.  For example, I have seen people running .NET Core applications on a Raspberry Pi. <br><br>  There were several base libraries: Base Class Library, Core Library and Mono Class Library.  Living with it was pretty hard.  Then the Portable Class Library appeared, etc.  Therefore, Microsoft went in the direction of unifying APIs that are cross-platform and work on all these stacks, and made the .Net Standard Library. <br><br><img src="https://habrastorage.org/webt/l7/4k/sv/l74ksvrbuu81dyrdmc8zvew30sk.png"><br><br>  Currently, this is .Net Standard version 2.0, in which practically everything that was in the old classic .NET works cross-platform. <br><br>  We will talk about .NET Core and about its part, which concerns ASP.Net Core. <br><br><h2>  .Net Core Self-contained deployment </h2><br>  What .Net Core gives us in terms of 12-factor?  In fact, the 12-factor is implemented here quite well. <br><br>  <strong>There is complete dependency control</strong> , i.e.  we have the ability to build the application and fully control its dependencies. <br><br>  We can configure the .NET application so that the <strong>platform is explicitly specified</strong> (win10-x64 / ubuntu.16.04-x64 / osx.10.12-x64) during the build, and in the final artifact folder we get everything related to the application, runtime, libraries , that is, all-all-all, collected under a specific platform.  To do this, we just need to choose it - be it Windows, Linux or OSX. <br><br>  As I said before, we need to select a framework (currently, it is <strong>netstandard1.6)</strong> and include 2 libraries: <br><br><ul><li>  <strong>Microsoft.NETCore.Runtime.CoreCLR</strong> in order to execute application code. </li><li>  <strong>Microsoft .NETCore.DotNetHostPolicy</strong> in order to run the application on the target system. </li></ul><br><h3>  How does ASP.Net Core work? </h3><br>  The whole ideology of ASP.Net Core is built on the principles of Middleware.  We have a certain number of layers, when a request comes into our application, the first Middleware becomes in its path, which executes its logic, and sends this request to the next one.  The next one executes, the next forwards, and so on until the pipeline has ended.  Back we send Response to the user. <br><br><img src="https://habrastorage.org/webt/hk/tw/id/hktwidyh5ygkmf_tfzskkf9fyrk.png"><br><br>  If we talk about the applied aspects of this all, then: <br><br><ol><li>  At the first stage, we can insert the Exception handler so that all exceptions are fully tracked, logged, and so on. </li><li>  The second middleware can be a security module. </li><li>  The third may be the MVC framework, which is engaged in routing and gives either data (in the case of REST services) or a page. </li></ol><br>  This is the simplest example of Middleware, which is what we did in order to host the application in Kubernetes.  Let's take a closer look at what is there. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HealthCheckMiddleware</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path = <span class="hljs-string"><span class="hljs-string">"/healthcheck"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> RequestDelegate _next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HealthCheckMiddleware</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RequestDelegate next</span></span></span><span class="hljs-function">)</span></span> { _next = next; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!context.Request.Path.Equals(Path, StringComparison.OrdinalIgnoreCase)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _next(context); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { context.Response.ContentType = <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>; context.Response.StatusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>; context.Response.Headers.Add(HeaderNames.Connection, <span class="hljs-string"><span class="hljs-string">"close"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"OK"</span></span>); } } }</code> </pre> <br>  Here in the constructor is <strong>RequestDelegate next</strong> .  This is the next Middleware that is inserted into the constructor, and we have the opportunity to send him a request.  Specifically, this Middleware is responsible for responding to all requests that came on / healthcheck. <br><br>  If the request did not come to this path (path), then we give control to the next Middleware, that is, forward it further.  If this, then we say 200, everything is fine, the sentence works, and we output OK to the console.  Further the request does not continue to be executed.  This is where it ends. <br><br>  This is a very fast thing.  In our tests, all this code works literally in 2-3 ms. <br><br><h3>  Basic features of REST services </h3><br>  Here are the basic features of the REST services that are usually needed when we make such applications: <br><br><ul><li>  <strong>Logging is</strong> necessary for everyone and it would be great for it to be structural. </li><li>  <strong>API versioning</strong> (SemVer, DateTime) - it would be nice if it was right out of the box. </li><li>  It is also great to have a <strong>formal description of the API</strong> (Swagger). </li></ul><br><h4>  Structural logging </h4><br>  If you visualize it, it looks like this. <br><br><img src="https://habrastorage.org/webt/0m/et/cn/0metcn1-y2dtajimhokgrsao29e.png"><br><br>  There is a console with multi-colored lines.  In fact, if you look in more detail, we will see that each message that is displayed in the log has Data, a level (error, warning, info) and so on.  But, in addition, there are some parameters that are highlighted in different colors. <br><br>  In addition to the text of the logs, we can still have some key / value pairs that can be explicitly indexed.  If we want, say, to log everything completely, which our application sends for a specific request, we can add the request id to the log, just like a key / value pair: request id is equal to so much.  Then there is an opportunity for this request id to be indexed by our logs somewhere.  In the end, simply by filtering all the logs for this request id, we can find all the messages that were generated by this request.  This wonderful thing gives us structural logging. <br><br>  In order to perform logging, ASP.Net Core has wonderful Serilog, log4net and NLog libraries.  We stopped on <a href="https://serilog.net/">Serilog</a> , because everything is out of the box, including the ability to output logs in any format, not only to any consoles or to the highlighted console, but also immediately, if you suddenly need it, to Elastic or to a file. <br><br><pre> <code class="hljs pgsql">appsettings.json { "Serilog": { "MinimumLevel": "Debug", "WriteTo": [ { "Name": "Console", "Args": { "formatter": "Serilog.Formatting.Compact.RenderedCompactJsonFormatter, Serilog.Formatting.Compact" } } ], "Enrich": [ "FromLogContext", "WithThreadId" ] } }</code> </pre><br>  So it is customizable.  We have a logging level.  Then we say that we want to display logs in the console, and then in what form these logs should be displayed in the console.  If our application is working on staging or in a production-environment, I would like these logs to be output in Json format, so that the environment can then pick them up and index them in some way.  Again, all this is <strong>out of the box</strong> and it is possible to enrich all these logs with some additional parameters, for example, to output ThreadId, RequestId, etc. in such a declarative way. <br><br><h4>  API Versioning </h4><br>  We would like the API of the service we are doing to support versioning out of the box.  When we work with public clients and do not know how many there are and what they are in principle, versioning is a very useful thing. <br><br>  In our case, it was just important, because we have different customers.  The life cycle of a specific version of the mobile application 2GIS can be up to six months, or even more.  That is, users may not update the application on the device for more than six months. <br><br>  But, nevertheless, if this particular version of the application comes to the backend, we have to give the data for exactly the contract that is supposed for this device and for this version of the application.  If later, over time (this usually happens), we took and changed something in the API - we added, or, even worse, deleted some data from the answer, or basically changed the interaction contract, we would not want it to break the old one. attachment. <br><br>  There is a wonderful library <a href="https://github.com/Microsoft/aspnet-api-versioning"><strong>ASP.NET API versioning</strong></a> from Microsoft.  It is fully open-source, works on the <a href="https://github.com/Microsoft/api-guidelines">guidelines</a> that Microsoft has publicly formulated for its services, and gives the opportunity to version the API in various ways, including using SemVer or on dates, like Netflix does. <br><br>  Again, there are various options for transferring information about the API version: via the query string, URL path, header ‚Äî everything is supported out of the box. <br><br>  Suppose we have such a controller. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ApiVersion(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1.0"</span></span></span><span class="hljs-meta">)</span></span>] [Route(<span class="hljs-string"><span class="hljs-string">"api/medias"</span></span>)] <span class="hljs-comment"><span class="hljs-comment">// /api/medias [Route("api/{version:apiVersion}/medias")] // /api/1.0/medias public sealed class MediasController : Controller { // /api/medias/id?api-version=1.0 or /api/1.0/medias/id [HttpGet("{id}")] public async Task&lt;IActionResult&gt; Get(long id) { ... } }</span></span></code> </pre><br>  All we have to do is first indicate that the version of the API that the controller provides is 1.0.  Next we need to write our requests to include information about the version of the API. <br><br>  In this configuration, there are two ways to include the API version in the request ‚Äî via the URL path, or via the query string.  Clients can choose a convenient way for them, but all requests will come to the same endpoint. <br><br>  If over time we have a second version of the API, we need to do a little - come to the same controller and say that we have a second version of the same API. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ApiVersion(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1.0"</span></span></span><span class="hljs-meta">)</span></span>] [ApiVersion(<span class="hljs-string"><span class="hljs-string">"2.0"</span></span>)] [Route(<span class="hljs-string"><span class="hljs-string">"api/medias"</span></span>)] [Route(<span class="hljs-string"><span class="hljs-string">"api/{version:apiVersion}/medias"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MediasController</span></span> : <span class="hljs-title"><span class="hljs-title">GatewayController</span></span> { <span class="hljs-comment"><span class="hljs-comment">// /api/medias/id?api-version=1.0 or /api/1.0/medias/id [HttpGet("{id}")] public async Task&lt;IActionResult&gt; Get(long id) { ... } // /api/medias/id?api-version=2.0 or /api/2.0/medias/id [MapToApiVersion("2.0")] [HttpGet("{id}")] public async Task&lt;IActionResult&gt; GetV2(long id) { ... } }</span></span></code> </pre><br>  In fact, all we need to do is to leave the method that was, without changing anything in it either.  It gives data to customers who knew about this version of the API at the time <br><br>  We can add a new controller method and tell all requests that come to API 2.0 to be redirected here.  Thus, we will not break old customers, and add functionality for new customers. <br><br>  It is not necessary to do this in one controller.  We can create a new controller and say that it is a controller for API version 2.0 (line <code>[MapToApiVersion("2.0")]</code> ).  In general, there are many different options, and everything is done very simply. <br><br><h4>  Swagger </h4><br>  I also want to talk about the library <a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">Swashbuckle.AspNetCore</a> , which allows you to enable Swagger. <br><br>  Many have heard about Swagger, so the only thing I would like to say is that by connecting Swashbuckle.AspNetCore for ASP.Net Core, we get this functionality out of the box again, and it knows how to be friends with versioning API. <br><br><pre> <code class="cs hljs">services.AddSwaggerGen( x =&gt; { IApiVersionDescriptionProvider provider; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> provider.ApiVersionDescriptions) { x.SwaggerDoc(description.GroupName, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Info { ... }); } }); ... app.UseSwagger(); app.UseSwaggerUI( c =&gt; { IApiVersionDescriptionProvider provider; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> provider.ApiVersionDescriptions) { options.SwaggerEndpoint( <span class="hljs-string"><span class="hljs-string">$"/swagger/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{description.GroupName}</span></span></span><span class="hljs-string">/swagger.json"</span></span>, description.GroupName.ToUpperInvariant()); } });</code> </pre><br>  That is, by configuring the application in this way, saying that we have a certain VersionDescriptionProvider, and just running through the foreach on ApiVersionDescriptions, we can add Swagger documents, that is, the very formal descriptions of our APIs. <br><br>  After that we can add SwaggerUI, saying that we have SwaggerEndpoint on such json'ah, again, depending on the version of the API that we have.  Thus, we will get API versioning, which Swagger knows about, there is a switch and an opportunity to see which of these API versions have these methods.  Everything is cool and all this is in the demo, you can see. <br><a name="Build"></a><br><h2>  Build </h2><br>  Gently move on.  We wrote an application in which there is all the necessary functionality, we even wrote business logic there.  How do we get this all down?  Yes, so that later zadeploit! <br><br>  In fact, everything is quite simple.  I said that we use GitLab CI.  Consider the example of one of the fragments of the GitLab CI file one build step. <br><br><pre> <code class="hljs sql">build:backend-conf-demo: image: $REGISTRY/microsoft/aspnetcore-build:1.1.2 stage: build:app script: - dotnet <span class="hljs-keyword"><span class="hljs-keyword">restore</span></span> <span class="hljs-comment"><span class="hljs-comment">--runtime ubuntu.16.04-x64 - dotnet test Demo.Tests/Demo.Tests.csproj --configuration Release - dotnet publish Demo --configuration Release --runtime ubuntu.16.04-x64 --output publish/backend-conf tags: [ 2gis, docker ] artifacts: paths: - publish/backend-conf/</span></span></code> </pre><br>  We have a build step, on which we want to build an application.  For this we need not so much again: the base image provided by Microsoft.  This image has everything you need: all the tools, the .Net command line, the .Net itself of a certain version, runtime, etc.  This image is quite large, so, of course, in no case should it be dragged into production.  It should be used only to build the application. <br><br>  This is just about that same 12-factor, when at the stage of assembly and operation of the application should be separated. <br><br>  We use this image, we say: ‚ÄúGather us, please, all the dependencies that exist in this application just for this platform, under which we want to build!‚Äù <br><br>  Next, of course, we want to run unit tests before building the application.  If the unit tests did not pass, then nothing is needed to collect because the application does not work.  If everything is fine, we say <code>dotnet publish</code> and indicate exactly the same runtime that interests us. <br><br>  We are talking about where it is necessary to deploy all this in terms of the artifacts that are obtained.  In this example, the folder <code>publish/backend-conf</code> will contain everything related to applications and its dependencies. <br><br>  After we have compiled the application, we need to collect the Docker image, and collect the image directly for each change, since  we have the same CI_TAG at the Gitlub CI level.  In fact, this is a step to the Continuous deployment mode. <br><br><pre> <code class="hljs perl">build:backend-conf-demo-image: stage: build:app script: - IMAGE=<span class="hljs-keyword"><span class="hljs-keyword">my</span></span>-namespace/backend-conf TAG=$CI_TAG DOCKER_FILE=publish/backend-conf/Dockerfile DOCKER_BUILD_CONTEXT=publish/backend-conf make docker-build - IMAGE=<span class="hljs-keyword"><span class="hljs-keyword">my</span></span>-namespace/backend-conf TAG=$CI_TAG make docker-<span class="hljs-keyword"><span class="hljs-keyword">push</span></span> tags: [ docker-engine, io ] dependencies: - build:app</code> </pre><br>  Next, we configure other parameters, take the artifacts that were generated in the last step, and call docker-build.  After the docker-build has passed, we got the image locally and can place it on the docker-hub - local, global - anywhere. <br><br>  Thus, we have an application compiled for the OS we need and there is an image of this application on the docker-hub. <br><a name="Deploy"></a><br><h2>  Deploy </h2><br>  All we need to do next is to deploy it, and it is time to talk about Kubernetes. <br><br><h3>  Kubernetes </h3><br>  This is a container orchestration tool that allows you not to bother too much about how to launch, lift, monitor their logs, etc.  Our company has deployed as many as four Kubernetes clusters that can be used. <br><br><img src="https://habrastorage.org/webt/mn/ph/ty/mnphtybob7bbgwldbb_rscbngja.png"><br><br>  There are basic concepts in Kubernetes. <br><br>  <strong>Pod</strong> <br><br>  This is a logical union of containers.  There may be one container, maybe several, and it is assumed that all containers that lie in the Pod are rigidly interconnected and use some kind of shared resources. <br><br><img src="https://habrastorage.org/webt/_s/wn/r_/_swnr_e3-bauqmzdd-f86m23-ps.png"><br><br>  Kubernetes out of the box checks our application: liveness check, readiness check, log fetching, and so on.  All these issues that concern container management, Kubernetes solves for us. <br><br>  <strong>Service</strong> <br><br>  The second thing that is important to know when we work with Kubernetes is service.  It allows you to receive external traffic to Kubernetes and say where this traffic should be redirected inside Kubernetes - to which Pods, to which containers. <br><br>  For this, he needs 2 things: <br><br><ul><li>  <strong>Selector</strong> .  The label that was set up for Pod is just needed to find out all the Pods that are for this application; <br></li><li>  <strong>Ports Mapping</strong> provides the ability to redirect containers to different ports. <br></li></ul><br><img src="https://habrastorage.org/webt/gd/ua/da/gduadaq7-lzg0t3a7sohp4ty_8o.png"><br><br>  The general picture in the figure above: there are users who come to the Kubernetes cluster from the outside;  we get this traffic, we understand by the domain name, who needs it;  on the selector we find those Pod'y;  we send this traffic to the corresponding ports in containers. <br><br>  <strong>Deployment</strong> <br><br>  Allows you to deploy Pods automatically across the entire Kubernetes cluster.  The whole picture looks like this. <br><br><img src="https://habrastorage.org/webt/cv/wf/45/cvwf45vfswsaufr8sdjrgzrsug4.png"><br><br>  As developers, we have to write Deployment, tell us how many replicas we need, what template, etc.  Next, put all the labels in order to associate them with the service.  Next, write a service that will just stand at the entrance to Kubernetes. <br><br>  In fact, everything - the user's path is defined. <br><br>  The only thing that is not in Kubernetes itself, and that we had to add on our own in order to close the application with a specific version on Kubernetes, is to write specific Deployment-files with an indication of a specific version of our application and a specific version of the image.  This is necessary in order to embed all this into the continuous deployment pipeline.  I think that not only we did it, because so far Kubernetes does not provide such an opportunity. <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_name }}</span></span><span class="xml"><span class="xml"> spec: replicas: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ replicas_count }}</span></span><span class="xml"><span class="xml"> template: metadata: labels: app: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_name }}</span></span><span class="xml"><span class="xml"> spec: containers: - name: backend-conf image: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ image_path }}</span></span><span class="xml"><span class="xml">:</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ image_version }}</span></span><span class="xml"><span class="xml"> ports: - containerPort: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_port }}</span></span><span class="xml"><span class="xml"> readinessProbe: httpGet: { path: '</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_probe_path }}</span></span><span class="xml"><span class="xml">', port: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_port }}</span></span><span class="xml"><span class="xml"> } initialDelaySeconds: 10 periodSeconds: 10 env: - name: ASPNETCORE_ENVIRONMENT value: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ env }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre><br>  The Deployment example is higher and has: <br><br><ul><li>  Label, about which I spoke, and which we can indicate somewhere on top through the template engine. </li><li>  An indication of where the image of our application and its version are. </li><li>  CI_TAG. </li><li>  An indication of which port to go to our application in this container. </li><li>  Checking readiness so that Kubernetes knows if our application works, whether everything is good or not very good to it. </li><li>  Environment variables </li></ul><br>  The service looks like this. <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">apiVersion: v1 kind: Service metadata: name: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_name }}</span></span><span class="xml"><span class="xml"> annotations: router.deis.io/domains: "</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_name }}</span></span><span class="xml"><span class="xml">" router.deis.io/ssl.enforce: "</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ ssl_enforce | default('False') }}</span></span><span class="xml"><span class="xml">" spec: ports: - name: http port: 80 targetPort: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_port }}</span></span><span class="xml"><span class="xml"> selector: app: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ app_name }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre><br>  We are talking about the fact that the external port is 8080, and the internal one will be transmitted through the template.  And, actually, the selector. <br><br>  That's the whole service. <br><br>  Next we need to specify the parameters in order to collect files for Kubernetes using these template engines. <br><br><pre> <code class="hljs pgsql">common: replicas_count: <span class="hljs-number"><span class="hljs-number">1</span></span> max_unavailable: <span class="hljs-number"><span class="hljs-number">0</span></span> k8s_master_uri: https://master.staging.dc-nsk1.hw:<span class="hljs-number"><span class="hljs-number">6443</span></span> k8s_token: "{{ env='K8S_TOKEN_STAGE' }}" k8s_ca_base64: "{{ env='K8S_CA' }}" k8s_namespace: my-namespace ssl_enforce: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> app_port: <span class="hljs-number"><span class="hljs-number">5000</span></span> app_probe_path: /healthcheck image_version: "{{ env='CI_TAG' }}" image_path: docker-hub<span class="hljs-number"><span class="hljs-number">.2</span></span>gis.ru/my-namespace/backend-conf env: Stage backend-conf-demo: app_name: "backend-conf-demo" app_limits_cpu: <span class="hljs-number"><span class="hljs-number">500</span></span>m app_requests_cpu: <span class="hljs-number"><span class="hljs-number">100</span></span>m app_limits_memory: <span class="hljs-number"><span class="hljs-number">800</span></span>Mi app_requests_memory: <span class="hljs-number"><span class="hljs-number">300</span></span>Mi kubectl: - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>: deployment.yaml.j2 - <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>: service-stage.yaml.j2</code> </pre><br>  Specify which cluster Kubernetes we will use;  application port 5000;  <code>app_probe_path</code> : <code>/healthcheck</code> (the same Middleware);  <code>image version</code> is taken from the environment variable;  These images lie there and the environment of env, for example, <code>Stage</code> .  For production there will be another variable.  Further we register resources for the application and templates which I gave above. <br><br>  After we have done all this, we are writing another build step for gitlub CI. <br><br><pre> <code class="hljs perl">deploy:backend-conf-demo-stage: stage: deploy:stage <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>: manual image: $REGISTRY/<span class="hljs-number"><span class="hljs-number">2</span></span>gis-io/k8s-handle:latest script: - export ENVIRONMENT=Stage - k8s-handle deploy --config config-stage.yaml --section backend-conf ‚Äîsync-mode True only: - tags tags: [ <span class="hljs-number"><span class="hljs-number">2</span></span>gis, docker ]</code> </pre><br>  In fact, we are talking about the fact that we have such a config file, raise the container from the image on the Docker hub and call the k8s-handle utility in it. <br><br>  This is enough to deploy <strong>any</strong> , not just ASP.Net Core application on Kubernetes.  So it works in 2GIS and does not cause any special problems. <br><br>  By the way, k8s-handle is also an open source thing. <br><a name="StressTesting"></a><br><h2>  Stress Testing </h2><br>  Now you need to make sure that the application that we have done, really fulfills the load, is fault-tolerant and is given for a certain time. <br><br>  We are developers, and especially in testing we do not understand, but in 2GIS there is a separate load testing team.  We came to them and said: <br><blockquote>  <em>- Guys, we made the application.</em>  <em>We have such and such requirements.</em>  <em>we</em> <em><br></em>  <em>locally tested, all is well.</em>  <em>Let's load it!</em> <br>  <em>- Yes, no problem!</em>  <em>Tomorrow we will come and do everything!</em> <br>  <em>- How do you do it at all?</em> <br>  <em>- We have our own tools.</em>  <em>What are you deploying the application to?</em> <br>  <em>- On Kubernetes.</em> <br>  <em>- Wonderful!</em>  <em>So everything will be cool!</em> <br></blockquote>  When they came to us, they asked what we wanted to test at all, we answered that the most critical for us is a public endpoint, and we have the following load loop: <br><br><ul><li>  There are some products that generate load. </li><li>  There is a service. </li><li>  There is a provider - API, which lies under our service. </li></ul><br><img src="https://habrastorage.org/webt/x1/pl/ya/x1plyakny9k8vocaifqcbeykb0k.png"><br><br>  Testers wrote us tests on Scala.  They use Gatling to perform stress tests. <br><br><img src="https://habrastorage.org/webt/5p/a5/wi/5pa5wio-3lzxdmtpunf2dpk2xdu.png"><br><br>  Everything is simple here.  It is written that we have some asserts, we want the number of requests per second to be more or less so much.  We want there to be no failed requests, so that the responseTime is so much. <br><br>  After that, we say how to conduct a stress test: <br><br><ol><li>  Raise the load from 1 to 20 users, for example, within 30 seconds. </li><li>  For another two minutes, keep a constant load of 20 users. </li></ol><br>  At the end, you need to specify that there is such a test, with such and such steps, HTTP, a runtime of 180 seconds in our case, and such and such asserts. <br><br>  This is one example of a load test. <br><br>  After that, they wrote us a template in gitlub CI. <br><br><pre> <code class="hljs mel">.perf:template: &amp;perf_template stage: test:perf environment: perf only: - master - /^perf.*$/ variables: PERF_TEST_PATH: <span class="hljs-string"><span class="hljs-string">"tests/perf"</span></span> PERF_ARTIFACTS: <span class="hljs-string"><span class="hljs-string">"target/gatling"</span></span> PERF_GRAPHITE_HOST: <span class="hljs-string"><span class="hljs-string">"graphite-exporter.perf.os-n3.hw"</span></span> PERF_GRAPHITE_ROOT_PATH_PREFIX: <span class="hljs-string"><span class="hljs-string">"gatling.service-prefix"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: $REGISTRY/perf/tools:<span class="hljs-number"><span class="hljs-number">1</span></span> artifacts: name: perf-reports when: always expire_in: <span class="hljs-number"><span class="hljs-number">7</span></span> day paths: - ${PERF_TEST_PATH}/${PERF_ARTIFACTS}<span class="hljs-comment"><span class="hljs-comment">/* tags: [perf-n3-1]</span></span></code> </pre><br>  Here is the code for configuring the tool, but the tool itself ( <code>image: $REGISTRY/perf/tools:1</code> ) is just in this image. <br><br><pre> <code class="hljs bash">perf:run-tests: &lt;&lt;: *perf_template script: - <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PERF_GRAPHITE_ROOT_PATH_PREFIX PERF_GRAPHITE_HOST - <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PERF_APP_HOST=http://<span class="hljs-variable"><span class="hljs-variable">${APP_PERF}</span></span>.web-staging.2gis.ru - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">${PERF_TEST_PATH}</span></span> - ./run_test.sh --capacity - ./run_test.sh --resp_time after_script: - perfberry-cli logs upload --dir <span class="hljs-variable"><span class="hljs-variable">${PERF_TEST_PATH}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PERF_ARTIFACTS}</span></span> --env <span class="hljs-variable"><span class="hljs-variable">${APP_PERF}</span></span>.web-staging.2gis.ru gatling <span class="hljs-variable"><span class="hljs-variable">${PERFBERRY_PROJECT_ID}</span></span></code> </pre><br>  We ran the test in 2 variants: <br><br><ol><li>  Capacity test, when we sent requests in turn: waited for a response, and only then sent the next request.  Thus, we calculated the capacity of our application, that is, how many requests per second it can work. </li><li>  This load test, when we did not wait for answers, but ran these requests in parallel. </li></ol><br>  In the first iteration, our results were not very good - not the ones we were waiting for.  And we went towards Performance. <br><a name="Performance"></a><br><h2>  Performance </h2><a name="Caching"></a><br><h3>  Caching </h3><br>  The first thing that comes to mind to increase the number of requests that we can handle, and reduce ResponseTime, is caching.  If we have resources that we can save in the cache, why go after them again each time. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AllowAnonymous</span></span>] [HttpGet(<span class="hljs-string"><span class="hljs-string">"{id}"</span></span>)] [ResponseCache( VaryByQueryKeys = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"api-version"</span></span> }, Duration = <span class="hljs-number"><span class="hljs-number">3600</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre><br>  To do this, we have a good old ResponseCache attribute in ASP.Net, but in ASP.Net Core it has acquired additional functionality. <br><br>  If we simply set ResponseCache and specify its Duration, then we get <a href="https://tools.ietf.org/html/rfc7234">caching on the client</a> by default.  That is, the client on his side saves the data that was given to him, and does not send more requests to us. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in ASP.Net Core also added server caching. </font><font style="vertical-align: inherit;">There is such a thing </font></font><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/middleware"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Response Caching Middleware</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows you to manage server caching quite well, that is, cache directly the responses from the services in the process memory. </font><font style="vertical-align: inherit;">And we can expose how we want to share these answers. </font><font style="vertical-align: inherit;">In our case, if there is a versioning, it would be nice, of course, to give different answers to each version of the API. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After we turned on server-side caching and client-side caching and started our test, everything went wrong, because somehow everything quickly began to arrive. </font><font style="vertical-align: inherit;">Therefore, then on the side of load tests, we turned off client caching, so that everything was more or less similar to real conditions when we have different clients.</font></font><br><a name="AsynchronyAndMultithreading"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asynchrony and multithreading </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second thing that comes to mind when we talk about performance is work with threads. Yes, we have .Net, in which everything is fine from the point of view of streams, so why not use it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 2 things here - asynchrony and multithreading, and this is not the same thing. </font></font><br><br><img src="https://habrastorage.org/webt/wz/jd/i5/wzjdi51iwfxzvjehedud0wnbbcs.png"><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrony</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is when there is one thread, one OS resource on which we can perform a series of tasks sequentially. If Task1 has sent a request to the database and is waiting for something, we can send this thread to the pool so that the next request from the client can be processed (Task2). If he is also thinking, we can change the context of the thread and execute Task1, if a response from the database has already come to him, etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, we can perform several asynchronous tasks on one physical OS resource. Async, Await in C # is just about asynchrony. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is when there are many different threads, many OS resources, no one bothers to run some processes in parallel, but no one says that these parallel processes within themselves cannot be asynchronous. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, Async / Await is not only about asynchrony, but also about multithreading, but you need to use it correctly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a simple example where you can use .Net multithreading right out of the box.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _remoteService.IOBoundOperationAsync(timeoutInSec: <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;[data.Count]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> detailed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _remoteService.IOBoundOperationAsync(timeoutInSec: <span class="hljs-number"><span class="hljs-number">5</span></span>); result.Add(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, detailed)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we have a service that gives us data in the form of a collection, on the basis of this data, we still need to iterate, cycle through to other services in order to get additional data based on the existing ones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an example straight from our lives. We have video advertising, and it can be in several formats, we need to find out what divisions, bit-rate, etc., are in all of these formats. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our first request to the API: ‚ÄúTell us, please, what media files are on your side?‚Äù She replies that there is a collection of data. Further on each of them we receive already detailed information. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In developing this all, we certainly didn‚Äôt think much about performance. Our load tests showed us that the response from our service was about a second, which is not very good.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we rewrote. This is the correct version.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _remoteService.IOBoundOperationAsync(timeoutInSec: <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[data.Count]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = data.Select( <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (item, index) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> detailed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _remoteService.IOBoundOperationAsync(timeoutInSec: <span class="hljs-number"><span class="hljs-number">5</span></span>); result[index] = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, detailed) }); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(tasks);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, it is not always possible to write the correct, efficient multi-threaded code the first time so that there are no deadlocks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we do almost the same thing, but we launch requests to the API already in parallel, and also asynchronously. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We receive a collection of Task'ov on an exit, and we launch one more which will wait for their performance. Thereby we get acceleration as many times as we have video files. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If, say, for each video ad there are 3 file resolutions, we get a reduction in time by as much as 4 times. We need to make 1 request to get all the metadata, and then another 3, 4 or 5 requests. They are executed in parallel, so the total time of their execution is about the same, and we can get a serious performance gain.</font></font><br><br><h4>  Testing </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After we implemented this, load testing showed other results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We realized that we have some limits on memory and processor, which, on the one hand, are dictated by the runtime, .Net, on the other hand, by the code that we wrote. </font><font style="vertical-align: inherit;">These are specific figures from the production:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 384Mb and 1.5 CPU - so much our application can consume at its peak. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Synchronous (capacity) test showed ~ 24 RPS (without cache). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With the use of server caching ~ 400 RPS, i.e., the response time is about 2.5 ms. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asynchronous (load) test passed. </font></font></li></ul><br><h2>  Instead of conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on our experience, we can say that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core can currently be used in production</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We did not have any freezes, incomprehensible nuances with the work of garbage collector or problems with stream orchestration, etc. Everything that is usual in .Net currently has the same quality in ASP.NET Core, and you should not be afraid to use it, judging by our experience. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There were no problems concerning Linux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If there are any problems, they are most likely yours. We had deadlocks with just the use of threads, but they depended not on Linux, but on programmers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have already shown, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker and Kubernetes greatly simplify life.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in terms of developing .Net applications, and, in principle, in terms of developing applications, and using different stack technologies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing I would like to say is that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you need to optimize applications</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">All this is out of the box, but </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you still need</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to </font><strong><font style="vertical-align: inherit;">think</font></strong><font style="vertical-align: inherit;"> so as not to get interesting effects. </font></font><br><br><img src="https://habrastorage.org/webt/89/kv/n4/89kvn4venwu9drtblhaoanpduee.jpeg"><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contacts:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code and presentation </font></font><a href="https://github.com/denisivan0v/backend-conf-2017"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E-mail: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denis@ivanovdenis.ru</font></font></a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Questions and answers</font></font></b> <div class="spoiler_text"><blockquote> ‚Äî   .Net Core        .  ,    Linux ‚Äî     ?    eventTracing,  PerformanceCounter   ? <br></blockquote>    ,   PerformanceCounter,  Windows     .       .     ? <br><br>      Linux   ,   .Net Core.         Linux    .       ,   ,      . <br><blockquote> ‚Äî ,     , ,    ,    Performance.    Linux  ? <br></blockquote>  Yes.  ,   ,   .           .    - .            -,     ,     ,      .        ,     ,   ,  !         ‚Äî      . <br><blockquote> ‚Äî         Performance   ?     ,  -, ,      - ,   ,   ,     ,  .     ,   . <br></blockquote>        ,      ,    ,    .           .   ,      PerformanceCounter  -,   . <br><br>  ,  ,     Prometheus Server.       runtime,   endpoint  Prometheus .    -      ,       . <br><br>     .  :          :     ;     . <br><blockquote> ‚Äî    ASP.Net Core   Linux          ? <br></blockquote>       Linux. ,     ,   ,     Linux.          Linux. <br><br>      .     ,          .Net,   Windows.    ,        Docker,  ,  ,    ,     .     - ‚Äî         . <br></div></div><br><blockquote>        <strong>HighLoad++ Junior</strong>  <strong>Backend Conf</strong> ‚Äî         <a href="http://backendconf.ru/">Backend Conf ++</a> .      ,    ,        9 . <a href="http://backendconf.ru/2018/abstracts/"></a>       ,          <a href="http://ritfest.ru/">++</a>   . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/352168/">https://habr.com/ru/post/352168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352156/index.html">Alan Kay (and Habr's collective intelligence): what books form the labor engineer's thinking</a></li>
<li><a href="../352158/index.html">CTF is not hard [NQ2K18]</a></li>
<li><a href="../352160/index.html">Thymeleaf Tutorial: Chapter 11. Comments and Blocks</a></li>
<li><a href="../352162/index.html">Thymeleaf Tutorial: Chapter 12. Embedding / Inlining</a></li>
<li><a href="../352166/index.html">How is the assessment of the state of the object?</a></li>
<li><a href="../352170/index.html">OpenStreetMap News Digest</a></li>
<li><a href="../352172/index.html">Link Building for Bing - Unlike Google and Important Nuances</a></li>
<li><a href="../352174/index.html">FPGA accelerators go to the clouds</a></li>
<li><a href="../352176/index.html">When the actor framework turns into a ‚Äúblack box‚Äù and what can we do about it?</a></li>
<li><a href="../352178/index.html">All according to GOST. Information security when using virtualization technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>