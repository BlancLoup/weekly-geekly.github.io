<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why do you need BEM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do you follow BEM, and how much is it needed outside of Yandex? 


 BEM stands for: block, element, modifier. This is such a set of abstractions, into...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why do you need BEM</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/ff7/296/11b/ff729611bcc2490bbbc360f4d7711051.jpg"></p><br><blockquote>  Do you follow BEM, and how much is it needed outside of Yandex? </blockquote><a name="habracut"></a><br><p>  BEM stands for: block, element, modifier.  This is such a set of abstractions, into which you can split the interface and develop everything in the same terms.  As the <a href="https://ru.bem.info/methodology/">site bem.info</a> says, BEM offers uniform rules for writing code, helps scale and reuse it, and also increases productivity and simplifies teamwork. </p><br><p>  Cool, yeah?  But why do you need scalability and teamwork, if you are one typesetter on a project that does not claim Yandex popularity?  To answer this question, you need to rewind the history of 10 years ago, when this approach was just started to be formulated. </p><br><p>  The basis of what we now call BEM was the idea of ‚Äã‚Äãindependent blocs, which Vitaly Kharisov formulated and presented in 2007 at the first Russian conference on the front end.  It was so long ago that even the word "frontend" was not yet there, then it was called client-side. </p><br><p>  The idea was to limit the possibilities of CSS for more predictable results.  Use a minimum of global styles and make each individual page element a block with its own unique class and styles that completely describe it.  Element and ID selectors, fragile nesting bundles - all this was replaced with simple class selectors.  Each class in styles is a block.  Thanks to this, the blocks can be easily reversed, put into each other and not be afraid of conflicts or influence. </p><br><pre><code class="css hljs"><span class="hljs-selector-id"><span class="hljs-selector-id">#menu</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ul</span></span> &gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">li</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: old; } <span class="hljs-selector-class"><span class="hljs-selector-class">.menu-item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: bem; }</code> </pre> <br><p>  Then there appeared completely independent blocks (NSA), where the elements inside have their prefix with the name of the parent, and the state of the blocks again duplicate the class, but with a postfix.  The approach acquired the features of modern BEM, one of which is the verbosity of classes. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.block</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.block_mod</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.block__element</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.block__element_mod</span></span> {}</code> </pre> <br><p>  This verbosity guarantees the uniqueness of elements and modifiers within a single project.  You follow the uniqueness of the block names yourself, but it is quite simple if each block is described in a separate file.  Looking at such a class in HTML or CSS, you can easily say what it is and what it refers to. </p><br><p>  Initially, the NSA, and then BEM, solved an important problem for the layout of any scale: predictable behavior and the creation of a reliable designer.  You want your layout to be predictable?  Here is Yandex too.  This is also called ‚Äúmodularity‚Äù - Philip Walton wrote about it well in ‚ÄúCSS Architecture‚Äù, a link to the translation in the description. </p><br><p>  A couple of years in Yandex finally formulated the BEM notation.  Any interface was proposed to be divided into blocks.  The inseparable parts of the blocks are the elements.  Both have modifiers. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"menu"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"menu__item"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"menu__item menu__item_current"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  For example, the block search site.  He can be in the cap and in the basement - it means a block.  It has the required parts: the search field and the "find" button are its elements.  If the field needs to be stretched to the full width, but only in the header, then the block or element that is responsible for this stretching is given a modifier. </p><br><p>  For the complete independence of the blocks, it is not enough to name the classes correctly or isolate styles; you need to collect everything that applies to it.  There is no common <em>script.js</em> or <em>images</em> folder with all site <em>images</em> in the BEM project.  In one folder with each block is all that is needed for his work.  This allows you to conveniently add, delete and transfer blocks between projects.  Then, of course, all the resources of the blocks in the assembly are combined depending on the tasks of the project. </p><br><p>  When BEM went beyond Yandex, at first it was perceived as magic and they tried to reproduce it literally, up to the prefixes <code>b-</code> in each block.  Such a funny cargo cult. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.b-block</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.b-block--mod</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.b-block__element</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.b-block__element--mod</span></span> {}</code> </pre> <br><p>  Some misunderstood the idea and even elements of the element appeared.  Then enthusiasts took up the notation and one of the most popular appeared: the block is separated by two underscores, and the modifier - by two hyphens.  Visually and simply - I write this myself. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.block</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.block--mod</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.block__element</span></span> {} <span class="hljs-selector-class"><span class="hljs-selector-class">.block__element--mod</span></span> {}</code> </pre> <br><p>  And why all these notations at all - I‚Äôm one coder on the project, remember?  I remember.  And I also remember how I used to make myself up to BEM: in each project I invented something so new.  And then he opened the code a year ago and was surprised - what kind of idiot wrote it? </p><br><p>  Take, for example, the Russian language.  We write with the capital names of people, names and stuff like that?  We write.  So that it was easy to read it later: is it Nadya or hope for the best?  Not to mention the punctuation marks and other useful agreements.  Here the letter "e", for example, softens ... so what are we talking about?  Yes, BEM. </p><br><p>  Before BEM, there were projects with footcloths styles that should not be touched.  They piled up over the years, layer upon layer, like wallpaper in an ancient communal flat.  They were simply plugged in first, and then overwritten, which interfered.  When you have a <code>div { font-size: 80% }</code> - it's not even funny anymore. </p><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">font-size</span></span>: <span class="hljs-number"><span class="hljs-number">80%</span></span>; }</code> </pre> <br><p>  BEM continued to develop in Yandex and grew beyond the limits of layout: there were redefinition levels, rich tools, a JS library for working with BEM classes, template engines and a whole BEM stack.  BEM even came up with a gesture, but this is a completely different story specific to Yandex. </p><br><p>  There were other methodologies: OOCSS Nicole Sullivan, Jonathan Snook SMACSS, BEM variations and whole frameworks.  Even with us <a href="https://htmlacademy.ru/intensive/adaptive/">at an advanced intensive</a> course, it was possible to choose any methodology for the layout of an educational project. </p><br><p>  But only BEM survived and it can be called <a href="https://web-standards.ru/articles/css-architecture/">the de facto standard of</a> modern interface design.  And what is the final stage of evolution?  Of course not.  No matter how you automate, much in BEM has to be done by hand, and conflicts are possible. </p><br><p>  Modularity and isolation of block styles can be solved even better.  There are web components, <a href="https://glenmaddern.com/articles/css-modules">CSS modules</a> , a bunch of <a href="https://habr.ru/p/334704/">CSS-in-JS</a> solutions and even, God forgive me, atomic CSS.  But there is no single solution to the accumulated problems for the next 10 years, as BEM once became.  What will it be?  We'll see.  I put on web components. </p><br><p>  In the meantime, if you describe the interface by BEM, the code will be organized, predictable, expandable and ready for reuse.  Not just for you, but for others. </p><br><h2 id="videoversiya">  Video version </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQPs20b3Ey8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Questions can be asked <a href="https://htmlacademy.ru/shorts">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337286/">https://habr.com/ru/post/337286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337272/index.html">How to create a racist AI, without even trying. Part 2</a></li>
<li><a href="../337274/index.html">Abbreviated Properties</a></li>
<li><a href="../337280/index.html">Software Asset Management at Raiffeisenbank - process and result</a></li>
<li><a href="../337282/index.html">Footer sections</a></li>
<li><a href="../337284/index.html">How to embed svg</a></li>
<li><a href="../337288/index.html">Using the KOMPAS-3D API ‚Üí Lesson 4 ‚Üí Title bar</a></li>
<li><a href="../337290/index.html">Fedora Linux is banned for distribution in the Crimea (and temporarily broken DNS)</a></li>
<li><a href="../337292/index.html">Custom properties</a></li>
<li><a href="../337294/index.html">About distinguishing objects by color</a></li>
<li><a href="../337298/index.html">In the wake of highloadcup: php vs node.js vs go, swoole vs workerman, splfixedarray vs array and more</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>