<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Little about lexical analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Long time ago, when the sky was blue, the grass was greener and dinosaurs roamed the Earth ... No, forget about dinosaurs. Well, in general, once the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Little about lexical analysis</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  Long time ago, when the sky was blue, the grass was greener and dinosaurs roamed the Earth ... No, forget about dinosaurs.  Well, in general, once the thought occurred to take a break from standard web programming and do something more insane.  It was possible, of course, anything, but the choice fell on the writing of his interpreter.  What can I say ... <i>Never write your programming languages</i> .  But I learned some experience from all this, so I decided to share it.  Let's start with the very basics - lexer. <br><a name="habracut"></a><br><h2>  Foreword </h2><br>  Before you begin to understand what kind of animal a ‚Äúlexer‚Äù is, it is worth figuring out what a PL consists of. <br><br>  In the modern world, each compiler / interpreter / transpiler / something-there-yet-like (let's, I just call it ‚Äúthe compiler‚Äù, without any distinctions on types) is divided into two pieces.  In the terminology of smart uncles, such pieces are called "frontend" and "backend".  No, it‚Äôs not at all working with the web that we used to call and the front is not written in JS with HTML.  Although ... Okay. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first task, the frontend, is to take the <b>text</b> and turn it into an <b>AST</b> (abstract syntax tree), checking the correctness of the syntax (and sometimes semantics) along the way.  The task of the second, backend - to make it all work.  If the code is collected inside the interpreter, then a set of commands for the virtual processor (virtual machine) is created from AST, if the compiler, then a set of commands for the real processor.  In life, everything is quite complicated and can be realized not quite.  For example, in the case of the GCC compiler, everything is intermixed, but Clang is more canonical, LLVM is a typical representative of the backend for compilers. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  And now let's get acquainted with the piece called the "frontend". <br><br><h2>  Lexical analysis </h2><br>  The task of the lexer and the stage of lexical analysis is to get a lot of letters to the input and group them into some categories - ‚Äútokens‚Äù.  Therefore, lexical analysis is also called ‚Äútokenization‚Äù.  This is the very first stage of text processing that each existing compiler produces. <br><br>  Like this: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  By the way, here we have already written a lot of tools to make life easier.  The same <i>preg</i> functions that we used to use to parse text cope well with this task.  However, there are more convenient tools for this business: <br><br><ul><li>  <a href="https://github.com/nikic/Phlexy">Phlexy</a> , written by Nikita Popov. </li><li>  <a href="https://github.com/hoaproject/Compiler">Hoa</a> is a toolkit consisting of Lexer + Parser + Grammar. </li><li>  <a href="https://github.com/ircmaxell/PHP-Yacc">The port of Yacc</a> , written by Anthony Ferrara, which is also a comprehensive toolkit, and on which is written the well-known <a href="https://github.com/nikic/PHP-Parser">PHP parser</a> Popov, used in tools that use code analysis. </li><li>  <a href="https://github.com/railt/lexer">Railt Lexer is</a> my implementation for PHP 7.1+ </li><li>  <a href="http://php.net/manual/ru/parle.examples.lexer.php">Parle</a> is an extension for PHP that allows a limited set of PCRE expressions (no lookahead and some other syntactic constructs). </li><li>  And finally, the standard function php <a href="http://php.net/manual/ru/function.token-get-all.php">token_get_all</a> , which is designed directly for lexical analysis of PHP. </li></ul><br>  Okay, it's clear that things that can divide text into tokens are plenty, maybe I even forgot something, like <a href="https://github.com/doctrine/lexer">Doctrine</a> lexer.  But what next? <br><br><h2>  Types of lexers </h2><br>  And as always, things are not as simple as they seemed.  There are at least two different categories of lexers.  There is the usual option, quite trivial, which you slip the rules, and he already divides everything into tokens.  The configuration of this is not much different from the example shown by me above.  However, there is another option called <b>multistate</b> .  Such lexers are a little harder to understand, so I want to talk about them in a bit more detail. <br><br>  The multistate lexer task is to display different tokens depending on the previous state.  Well, for example, in PHP such ‚Äútransitional‚Äù states are formed with the help of &lt;? Php +?&gt; Tags, within lines, comments, and <a href="http://php.net/manual/ru/language.types.string.php">HEREDOC</a> / <a href="http://php.net/manual/ru/language.types.string.php">NOWDOC</a> constructs. <br><br>  Remember the previous example with 4 tokens above?  Let's modify it a bit to understand what these states are: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  In this case, if we have the simplest lexer without the wide capabilities of PCRE, then we get the following set of tokens: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  As you can see, we got a completely banal jamb on elements 3-5: The comment was perceived quite unexpectedly and itself was divided into tokens, although it had to be considered as a solid piece. <br><br>  Of course, with the PCRE functional, such a token could be ripped out with the help of the simple regular " <i>// [^ \ n] * \ n</i> ", but if it is not?  Well, or do we want to gash with our hands?  In short, in the case of the multistate lexer, we can say that all tokens must be in group <b>No1</b> , as soon as the token " <i>//</i> " is found, then a transition to group <b>No2</b> should occur.  And inside the second group there is a reverse transition if the token " <i>\ n</i> " is found - the transition back to the first group. <br><br>  Something like this: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  I think now it becomes clearer how some HEREDOC is parsed, because even with all the power of PCRE, writing a regular schedule for this business is extremely problematic, given that this HEREDOC syntax supports interpolation of variables.  Just try parsing something with the built-in <i>token_get_all</i> function (note the&gt; 12 token): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Okay, it seems we are ready to begin the practice. <br><br><h2>  Practice </h2><br>  Let's remember what we have in PHP for such cases?  Well, of course, preg_match!  Okay, come down.  The preg_match based algorithm is implemented in <a href="https://github.com/hoaproject/Compiler/blob/master/Llk/Lexer.php">Hoa</a> and here <a href="https://github.com/nikic/Phlexy/blob/master/lib/Phlexy/Lexer/Stateless/WithoutCapturingGroups.php">in this Phelxy implementation</a> .  Its task is quite simple: <br><br><ol><li>  We have on hand the source text and an array of regularies. </li><li>  Match until something is right. </li><li>  Once found a piece, cut it out of the text and match it further. </li></ol><br>  As code, it will look something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Code sheet</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Using Code Sheets</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Such an approach is rather trivial and allows a pair of pokes on the keyboard to modify the lexer in the area of ‚Äã‚Äãthe next () method, adding the transition between states and turning this section of hand-hopping into a primitive multistate lexer.  In the <i>$ this-&gt; tokens area, it‚Äôs</i> enough to add something like <i>$ this-&gt; tokens [$ this-&gt; state]</i> . <br><br>  However, besides primitivism itself, there is one more drawback, not fatal as it could turn out to be, but still ... Such an implementation works incredibly slowly.  On i7 7600k, the owner of which I by chance turned out to be - a similar algorithm processes approximately 400 tokens per second, and with an increase in their variations (i.e. definitions that we passed to the designer) - it can slow down to the speed of changing presidents in the Russian Federation ... ahem , sorry.  I wanted to say, of course, that it would work <b>very slowly</b> . <br><br>  Okay, what can we do?  For a start, you can understand what is going wrong.  The fact is that every time we call <b>preg_match</b> , the compiler with its JIT, called PCRE, rises inside the wilds of the language (And since PHP 7.3 is already PCRE2).  Each time it parses the regulars itself and builds a parser for them, with which we parse the text to create tokens.  It sounds a bit strange and tautological.  But in short, each token requires a compilation of 1 to N regulars, where N is the number of definitions of these tokens.  In this case, it is worth noting that even the applied flag " <i>S</i> " and optimization with the help of " <i>\ G</i> " in the constructor, where regular expressions for tokens are formed, do not help. <br><br>  One way out of this situation suggests itself - it is necessary to parse all this text in one pass, i.e.  using just one <b>preg_match</b> function.  It remains to solve two problems: <br><br><ol><li>  How to indicate that the result of the regular expression N1 corresponds to the token N2?  Those.  how to denote that " <i>\ w +</i> ", for example - this is <i>T_CONST</i> . </li><li>  How to determine the sequence of tokens as a result.  As you know, the result of <b>preg_match</b> or <b>preg_match_all</b> will contain everything mixed up.  And even with the help of flags passed as the fourth argument, the situation will not change. </li></ol><br>  Here you can pause and think a little.  Well or not. <br><br>  The solution to the first problem is <a href="http://php.net/manual/ru/regexp.reference.subpatterns.php">PCRE named groups</a> , which are also referred to as ‚Äúsubmasks‚Äù.  With the help of the rules: " <i>(? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> " you can get all the tokens in one pass by matching them with their names.  As a result of the match, an associative array consisting of pairs " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> " will be formed. <br><br>  With the second a bit more complicated.  But here you can use tactical trick and use the function <a href="http://php.net/manual/ru/function.preg-replace-callback.php">preg_replace_callback</a> .  Its peculiarity is that the anonymous text passed as the second argument will be called strictly sequentially, for each token, from first to last. <br><br>  In order not to torment - the implementation is as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Another code footcloth</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  And its use is no different from the previous version.  At the same time, the speed of work increases from <b>400</b> to <b>57,000</b> tokens per second.  It is this algorithm that I applied <a href="https://github.com/railt/lexer/blob/master/src/Lexer/Iterator/RegexIterator.php">in my implementation</a> , taking up the rewriting of Hoa source codes.  By the way, if you use Parle, you can squeeze up to <b>600,000</b> tokens per second.  And the overall picture looks something like this (with XDebug enabled in PHP 7.1, so the numbers are lower here, but the ratio can be approximated). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  Yellow is the native extension of Parle. </li><li>  Blue - implementation via <i>preg_replace_callback</i> with a pre-assembled regular <i>schedule</i> . </li><li>  Red - all the same, but with the generated regular during the call to <i>preg_replace_callback</i> . </li><li>  Green - implementation via <i>preg_match</i> . </li></ul><br><h2>  What for? </h2><br>  Well, all this, of course, is wonderful, but impatient people are eager to ask the question: ‚ÄúWho needs this at all?‚Äù.  In the abstract world of PHP, where the principle of ‚Äúfigak-figak-and-site-ready‚Äù dominates - such libraries are not needed, let's be honest.  But if we talk about the ecosystem as a whole, then we can recall the well-known libraries, like <a href="https://github.com/symfony/yaml">symfony / yaml</a> or <a href="https://github.com/doctrine/doctrine2">Doctrine</a> .  Annotations in symfony are the same sublanguage inside PHP, requiring separate lexical and syntactic parsing.  In addition, there are a little less well-known transporters CoffeeScript, Less and Scss / Sass, written in PHP.  Well, or <a href="https://github.com/marcioAlmada/yay">Yay</a> and <a href="https://preprocess.io/">preprocess</a> based on it.  I will not even mention code analysis tools like phpmd or phpcs.  And the documentation generators, like phpDocumentnor or Sami, are pretty trivial.  Each of these projects to one degree or another uses lexical analysis at the first stage of text / code parsing. <br><br>  This is not a complete list of projects and maybe, I hope, my story will help you discover something new and replenish it. <br><br><h2>  Afterword </h2><br>  Looking ahead, if there is anyone interested in the subject of parsers and compilers, then there are some interesting reports on this topic, in particular from the guys from JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Also, of course, most of the speeches of Andrei Breslav ( <a href="https://habr.com/users/abreslav/" class="user_link">abreslav</a> ), which can be found on YouTube, I advise you to watch. <br><br>  Well, for lovers of reading, <a href="https://ps-group.github.io/compilers/">there is such a resource</a> that was personally extremely useful to me. <br><br>  Post Post Scriptum.  If somewhere it was sealed in the vastness of this epic, then you can safely inform the author in any form convenient for you. <br><br>  As a bonus, I would like to give <a href="https://gist.github.com/SerafimArts/bb9363fbd2d5cca8693cfcdc4631c2f7">an example of a simple PHP lexer</a> , it seems not so scary now, and now it‚Äôs even clear what it does, right?  Although whom I am deceiving, from the regulars the eyes bleed.  =) <br><br>  Thank! </div><p>Source: <a href="https://habr.com/ru/post/435102/">https://habr.com/ru/post/435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435088/index.html">Chinese streaming giant Tencent Music came out for an IPO - what it means and what to expect competitors</a></li>
<li><a href="../435090/index.html">Hyundai motor group introduced the concept of wireless charging and autonomous parking</a></li>
<li><a href="../435094/index.html">Gamepad from Sega Mega Drive and Raspberry Pi Part 2 (the final six-button)</a></li>
<li><a href="../435096/index.html">The effect of warm tube radio</a></li>
<li><a href="../435098/index.html">ADB vs Spy Cam & Mic</a></li>
<li><a href="../435106/index.html">Once again about passport.js</a></li>
<li><a href="../435108/index.html">Use Prolog</a></li>
<li><a href="../435112/index.html">Corporate Interview</a></li>
<li><a href="../435114/index.html">Spring Data JPA</a></li>
<li><a href="../435118/index.html">Save File Me - free client-side backup service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>