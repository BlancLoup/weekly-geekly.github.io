<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of cluster interaction. How we implemented ActiveMQ and Hazelcast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For the past 7 years, I have been working with the team to support and develop the core of the Miro product (ex-RealtimeBoard): client-server and clus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of cluster interaction. How we implemented ActiveMQ and Hazelcast</h1><div class="post__text post__text-html js-mediator-article">  For the past 7 years, I have been working with the team to support and develop the core of the Miro product (ex-RealtimeBoard): client-server and cluster interaction, work with the database. <br><br>  We have Java with different libraries on board.  Everything starts outside the container, through the Maven-plugin.  At the heart of it is the platform of our partners, which allows you to work with the database and streams, manage client-server interaction, etc.  DB - Redis and PostgreSQL (my colleague <a href="https://habr.com/ru/company/miro/blog/437826/">wrote about how we move from one database to another</a> ). <br><br>  From the point of view of business logic, the application contains: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  work with user boards and their content; </li><li>  functionality for user registration, creating and managing boards; </li><li>  user resource generator.  For example, he optimizes large images uploaded to the application so that they do not slow down on our clients; </li><li>  many integrations with third-party services. </li></ul><br>  In 2011, when we started, the whole Miro was on the same server.  It had everything: Nginx, on which php was spinning for the site, a Java application and databases. <br><br>  The product developed, the number of users and content that they added to the boards grew, so the load on the server also grew.  Due to the large number of applications on our server, we couldn‚Äôt understand at that moment what exactly the load gives and, accordingly, could not optimize it. To fix this, we spread everything to different servers, and we had a web server, server with our application and server with databases. <br><br>  Unfortunately, after a while, problems again arose, as the load on the application continued to grow.  Then we thought about how to scale the infrastructure. <br><br><img src="https://habrastorage.org/webt/_5/zq/_3/_5zq_3c16pydjklapiqamfzyxcg.png"><br><br>  Then I will talk about the difficulties that we faced in the development of clusters and the scaling of a Java application and infrastructure. <a name="habracut"></a><br><br><h2>  Horizontal scaling infrastructure </h2><br>  We started with collecting metrics: memory and CPU usage, time for user requests, system resources, work with the database.  By metrics, it was clear that the generation of user resources is an unpredictable process.  We can load the processor by 100% and wait tens of seconds until everything is done.  User requests for boards, too, sometimes gave an unexpected load.  For example, when a user selects a thousand widgets and starts spontaneously moving them. <br><br>  We started to think about how to scale these parts of the system and came up with obvious solutions. <br><br>  <b>Scale work with boards and content</b> .  Opening the board by the user looks like this: the user opens the client ‚Üí indicates which board he wants to open ‚Üí connects to the server ‚Üí a stream is created on the server ‚Üí all users of this board connect to one stream ‚Üí any change or widget creation occurs within this stream.  It turns out that all work with the board is strictly limited to the flow, which means we can spread these flows between servers. <br><br>  <b>Scale the generation of user resources</b> .  We can take out the server to generate resources separately, and it will receive messages to generate, and then respond that everything is generated. <br><br>  It seems simple.  But as soon as we began to explore this topic more deeply, it turned out that we needed to additionally solve some indirect problems.  For example, if users expire a paid subscription, then we must notify them about it, on whatever board they are.  Or, if the user has updated the version of the resource, you need to take care that the cache is correctly reset on all servers and we give the correct version. <br><br>  We defined the system requirements.  The next step is to understand how to put this into practice.  In fact, we needed a system that would allow servers in a cluster to communicate with each other and on the basis of which we would implement all our ideas. <br><br><h2>  The first cluster of the ‚Äúbox‚Äù </h2><br>  We did not choose the first version of the system, because it was already partially implemented in the partner platform that we used.  In it, all servers were connected to each other via TCP, and we could send RPC messages to one or all of the servers using this connection. <br><br>  For example, we have three servers, they are connected to each other via TCP, and in Redis we have a list of these servers.  We run a new server in the cluster ‚Üí it adds itself to the list in Redis ‚Üí reads the list to find out about all the servers in the cluster ‚Üí connects to all. <br><br><img src="https://habrastorage.org/webt/yj/9c/hv/yj9chvfavcbrixqnn_12jho2k7k.png"><br><br>  On the basis of RPC, support has already been implemented to flush the cache and redirect users to the correct server.  We had to make the generation of user resources and notify users that something happened (for example, the account has expired).  To generate resources, we chose an arbitrary server and sent it a generation request, and for notifications about subscription expiration, we sent a command to all servers in the hope that the message would reach the goal. <br><br><h3>  The server itself determines to whom to send the message. </h3><br>  Sounds like a feature, not a problem.  But the server focuses only on the availability of a connection to another server.  If there are connections, then there is a candidate for sending a message. <br><br>  The problem is that server number 1 does not know that server number 4 is under high load right now and cannot respond to it quickly enough.  As a result, server requests ‚Ññ1 are processed more slowly than they could. <br><br><img src="https://habrastorage.org/webt/g7/mw/ez/g7mwezzba78vsgcvx8mpa_fzdou.png"><br><br><h3>  The server does not know that the second server is frozen </h3><br>  And what if the server is not just heavily loaded, but generally frozen?  And it hovered so that it no longer comes to life.  For example, exhausted all available memory. <br><br>  In this case, server number 1 does not know what the problem is, so it continues to wait for an answer.  The rest of the servers in the cluster also do not know about the situation with server No. 4, so they will send many messages to server No. 4 and wait for a response.  So it will be up until the server number 4 will not die. <br><br><img src="https://habrastorage.org/webt/5y/et/pg/5yetpgodx1zi38he2nchwnnniiq.png"><br><br>  What to do?  We can independently add to the system a server status check.  Or we can redirect messages from ‚Äúsick‚Äù servers to ‚Äúhealthy‚Äù ones.  All this will take too much time for developers.  In 2012, we had little experience in this area, so we began to look for ready-made solutions to all our problems at once. <br><br><h2>  Message broker.  ActiveMQ </h2><br>  We decided to go in the direction of Message broker to correctly configure the communication between the servers.  We chose ActiveMQ because of the ability to customize the receipt of a message to a consumer at a certain time.  True, we never used this opportunity, so we could choose RabbitMQ, for example. <br><br>  As a result, we transferred our entire cluster system to ActiveMQ.  What it gave: <br><br><ol><li>  The server no longer determines to whom to send the message, because all messages go through the queue. </li><li>  Fault tolerance is configured.  To read the queue, you can run not one, but several servers.  Even if one of them falls, the system will continue to work. </li><li>  The servers had roles, which made it possible to divide the servers by load type.  For example, a resource generator can connect only to a queue for reading messages to generate resources, and a server with boards to a queue for opening boards. </li><li>  Made RPC communication, i.e.  each server has its own private queue, where other servers send events to it. </li><li>  You can send messages to all servers via Topic, which we use to reset subscriptions. </li></ol><br><br>  The scheme looks simple: all servers are connected to the broker, and it manages communication between them.  Everything works, messages are sent and received, resources are created.  But there were new problems. <br><br><h3>  What to do when all the necessary servers are? </h3><br>  Suppose server number 3 wants to send a message to generate resources on the queue.  He is waiting for his message to be processed.  But he does not know that for some reason there is not a single recipient of the message.  For example, recipients flew due to an error. <br><br>  For all the waiting time, the server sends a lot of messages with a request, which is why a queue of messages appears.  Therefore, when working servers appear, they must first process the accumulated queue, which takes time.  On the user's side, this leads to the fact that the image being uploaded by him does not appear immediately.  He is not ready to wait, so he leaves the board. <br><br>  As a result, we spend server power on the generation of resources, and the result is no longer needed. <br><br><img src="https://habrastorage.org/webt/oq/p8/fd/oqp8fd0mdctqarlauh84jdjn8rc.png"><br><br>  How can I solve the problem?  We can set up monitoring that will notify you of what is happening.  But from the moment when monitoring reports something, until the moment when we realize that our servers are bad, time will pass.  It does not suit us. <br><br>  Another option is to launch Service Discovery, or a registry of services, which will know which servers are running with which roles.  In this case, we will immediately receive an error message if there are no free servers. <br><br><h3>  Some services cannot scale horizontally. </h3><br>  This is the problem of our early code, not ActiveMQ.  I will show by example: <br><br><pre><code class="plaintext hljs">Permission ownerPermission = service.getOwnerPermission(board); Permission permission = service.getPermission(board,user); ownerPermission.setRole(EDITOR); permission.setRole(OWNER);</code> </pre> <br>  We have a user rights service on the board: the user can be the owner of the board or its editor.  The owner of the board can only be one.  Suppose we have a script when we want to transfer ownership of a board from one user to another.  On the first line, we get the current owner of the board, on the second - we take the user who was the editor, and now becomes the owner.  Then we put the role of the EDITOR on the current owner, and the role of the OWNER on the former editor. <br><br>  Consider how this will work in a multithreaded environment.  When the first thread sets the role of EDITOR, and the second thread tries to take the current OWNER, it may turn out that OWNER does not exist, but there are two EDITORs. <br><br>  The reason is the lack of synchronization.  We can solve the problem by adding a synchronize block on the board. <br><br><pre> <code class="plaintext hljs">synchronized (board) { Permission ownerPermission = service.getOwnerPermission(board); Permission permission = service.getPermission(board,user); ownerPermission.setRole(EDITOR); permission.setRole(OWNER); }</code> </pre><br>  This solution will not work in a cluster.  We could help with this SQL database with the help of transactions.  But we have Redis. <br><br>  Another solution is to add distributed locks to the cluster so that synchronization is inside the entire cluster, and not just a single server. <br><br><h2>  Single point of failure when entering the board </h2><br>  The model of interaction between the client and the server is stateful.  So we have to keep the state of the board on the server.  Therefore, we have made a separate role for the servers - BoardServer, which handles user requests related to the boards. <br><br>  Imagine that we have three BoardServer, one of which is the main one.  The user sends him a request ‚ÄúOpen a board with id = 123‚Äù ‚Üí the server looks in its database whether the board is open and on which server it is.  In this example, the board is open. <br><br><img src="https://habrastorage.org/webt/ej/kf/sd/ejkfsdptym30e-gdvkycc225zpw.png"><br><br>  The main server responds that you need to connect to server # 1 ‚Üí the user connects.  Obviously, if the main server dies, the user will not be able to access the new boards. <br><br>  Then why do we need a server that knows where the boards are open?  So that we have a single decision point.  If something happens to the servers, we need to understand whether the board is actually available in order to remove the board from the registry or rediscover it somewhere else.  It would be possible to organize this with the help of a quorum, when several servers solve a similar problem, but at that time we did not have the knowledge to implement the quorum on our own. <br><br><h2>  Switch to Hazelcast </h2><br>  Anyway, we coped with the problems that have arisen, but it may not be the most beautiful way.  Now we needed to understand how to solve them correctly, so we formulated a list of requirements for a new cluster solution: <br><br><ol><li>  We need something that will monitor the status of all servers and their roles.  Let's call this Service Discovery. </li><li>  We need cluster locks that will guarantee consistency when performing dangerous queries. </li><li>  We need a distributed data structure that will ensure that the boards lie on certain servers and inform you if something went wrong. </li></ol><br>  It was 2015.  We opted for Hazelcast - In-Memory Data Grid, a cluster system for storing information in RAM.  Then we thought that we had found a miracle solution, the holy grail of the world of cluster interaction, a miracle framework that can do everything and combines distributed data structures, locks, RPC messages and queues. <br><br><img src="https://habrastorage.org/webt/ce/ws/c9/cewsc9gdgzsmtebczs9jxbs4j2e.png"><br><br>  As is the case with ActiveMQ, we transferred almost everything to Hazelcast: <br><br><ul><li>  generation of user resources through ExecutorService; </li><li>  distributed blocking when rights are changed; </li><li>  server roles and attributes (Service Discovery); </li><li>  unified register of open boards, etc. </li></ul><br><h3>  Hazelcast Topologies </h3><br>  Hazelcast can be configured in two topologies.  The first option is the Client-Server, when the members are located separately from the main application, they themselves form a cluster, and all applications connect to them as a database. <br><br><img src="https://habrastorage.org/webt/r4/lg/vm/r4lgvmm7ni0dmyb6yp60cueklwm.png"><br><br>  The second topology is embedded when the Hazelcast members are embedded in the application itself.  In this case, we can use fewer instances, data access is faster, because the data and the business logic itself are in the same place. <br><br><img src="https://habrastorage.org/webt/gq/rz/fa/gqrzfappt3yspdlfpfe5sm3mhyg.png"><br><br>  We chose the second solution because we considered it more efficient and cost-effective in implementation.  Effective, because the speed of access to Hazelcast data will be lower, because  perhaps this data lies on the current server.  Economical, because we don‚Äôt need to spend money on additional instances. <br><br><h3>  Cluster hangs when member hangs </h3><br>  A couple of weeks after turning on the Hazelcast, problems appeared on the prode. <br><br>  At first, our monitoring showed that one of the servers began to gradually overload the memory.  While watching this server, the rest of the servers also began to load: the CPU grew, then the RAM, and in five minutes all the servers used all the available memory. <br><br>  At this point in the consoles, we saw the following messages: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">2015</span></span>-<span class="hljs-number"><span class="hljs-number">07</span></span>-<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">35</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>,<span class="hljs-number"><span class="hljs-number">466</span></span> [WARN] (cached18) com.hazelcast.spi.impl.operationservice.impl.Invocation: [my.host.address.com]:<span class="hljs-number"><span class="hljs-number">5701</span></span> [dev] [<span class="hljs-number"><span class="hljs-number">3.5</span></span>] Asking ifoperation execution has been started: com.hazelcast.spi.impl.operationservice.impl.IsStillRunningService$InvokeIsStillRunningOperationRunnable@<span class="hljs-number"><span class="hljs-number">6</span></span>d4274d7 <span class="hljs-number"><span class="hljs-number">2015</span></span>-<span class="hljs-number"><span class="hljs-number">07</span></span>-<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">35</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span>,<span class="hljs-number"><span class="hljs-number">467</span></span> [WARN] (hz._hzInstance_1_dev.async.thread-<span class="hljs-number"><span class="hljs-number">3</span></span>) com.hazelcast.spi.impl.operationservice.impl.Invocation:[my.host.address.com]:<span class="hljs-number"><span class="hljs-number">5701</span></span> [dev] [<span class="hljs-number"><span class="hljs-number">3.5</span></span>] <span class="hljs-string"><span class="hljs-string">'is-executing'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> -&gt; Invocation{ serviceName=<span class="hljs-string"><span class="hljs-string">'hz:impl:executorService'</span></span>, op=com.hazelcast.executor.impl.operations.MemberCallableTaskOperation{serviceName=<span class="hljs-string"><span class="hljs-string">'null'</span></span>, partitionId=-<span class="hljs-number"><span class="hljs-number">1</span></span>, callId=<span class="hljs-number"><span class="hljs-number">18062</span></span>, invocationTime=<span class="hljs-number"><span class="hljs-number">1436974430783</span></span>, waitTimeout=-<span class="hljs-number"><span class="hljs-number">1</span></span>,callTimeout=<span class="hljs-number"><span class="hljs-number">60000</span></span>}, partitionId=-<span class="hljs-number"><span class="hljs-number">1</span></span>, replicaIndex=<span class="hljs-number"><span class="hljs-number">0</span></span>, tryCount=<span class="hljs-number"><span class="hljs-number">250</span></span>, tryPauseMillis=<span class="hljs-number"><span class="hljs-number">500</span></span>, invokeCount=<span class="hljs-number"><span class="hljs-number">1</span></span>, callTimeout=<span class="hljs-number"><span class="hljs-number">60000</span></span>,target=Address[my.host2.address.com]:<span class="hljs-number"><span class="hljs-number">5701</span></span>, backupsExpected=<span class="hljs-number"><span class="hljs-number">0</span></span>, backupsCompleted=<span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre><br>  Here, Hazelcast checks whether the operation that was sent to the first ‚Äî ‚Äúdying‚Äù ‚Äîserver is running.  Hazelcast tried to keep a finger on the pulse and checked the status of the operation several times per second.  As a result, he spammed all the other servers with this operation, and after a few minutes they flew out of memory, and we collected several GB of logs from each of them. <br><br>  The situation was repeated several times.  It turned out that this is a bug in Hazelcast version 3.5, in which the heartbeating mechanism was implemented, checking the status of requests.  It did not check some of the boundary cases that we encountered.  I had to optimize the application in order not to fall into these cases, and after a few weeks Hazelcast fixed the error. <br><br><h3>  Frequent adding and deleting members from Hazelcast </h3><br>  The next problem we discovered is adding and removing members from Hazelcast. <br><br>  First, I will briefly describe how Hazelcast works with partitions.  For example, there are four servers, and each stores some part of the data (in the figure they are of a different color).  The unit is the primary partition, the two is the secondary partition, i.e.  backup of the main partition. <br><br><img src="https://habrastorage.org/webt/ex/qz/vj/exqzvjxs9rxlmfgssghnrnqxnn8.png"><br><br>  When you turn off any server partitions are sent to other servers.  In case the server dies, the partitions are distilled from it, and from those servers that are still alive and keep backup of these partitions. <br><br><img src="https://habrastorage.org/webt/eu/ds/-0/euds-0xurnqjlbhisjoj8k9ucis.png"><br><br>  This is a reliable mechanism.  The problem is that we often turn on and off servers for load balancing, and rebalancing the partitions also takes time.  And the more servers it works and the more data we store in Hazelcast, the more time it takes to rebalance the partitions. <br><br>  Of course, we can reduce the number of backups, i.e.  secondary partitions  But it is not safe, because something will definitely go wrong. <br><br>  Another solution is to switch to the Client-Server topology so that switching servers on and off does not affect the main Hazelcast cluster.  We tried to do this, and it turned out that RPC requests cannot be performed on clients.  Let's see why. <br><br>  To do this, consider an example of sending one RPC request to another server.  We take ExecutorService, which allows you to send RPC messages, and do submit with a new task. <br><br><pre> <code class="plaintext hljs">hazelcastInstance .getExecutorService(...) .submit(new Task(), ...);</code> </pre><br>  By itself, the task looks like a normal Java class that implements Callable. <br><pre> <code class="plaintext hljs">public class Task implements Callable&lt;Long&gt; { @Override public Long call() { return 42; } }</code> </pre><br>  The problem is that Hazelcast clients can be not only Java applications, but also with ++ applications, .NET and others.  Naturally, we cannot generate and convert our Java class to another platform. <br><br>  One option is to switch to using http requests in case we want to send something from one server to another and get an answer.  But then we have to partially abandon the Hazelcast. <br><br>  Therefore, we chose to use queues instead of ExecutorService as a solution.  To do this, we have independently implemented a mechanism to wait for the execution of an element in the queue, which processes boundary cases and returns the result to the requesting server. <br><br><h2>  What we have learned </h2><br>  <b>Lay flexibility in the system.</b>  The future is constantly changing, so there are no perfect solutions.  You can‚Äôt do it right away, but you can try to be flexible and put it in the system.  This allowed us to postpone important architectural decisions until the moment when they cannot be not taken any more. <br><br>  Robert Martin in Pure Architecture writes about this principle: <br><blockquote>  ‚ÄúThe goal of the architect is to create a form for the system that makes the policy the most important element, and the details - not related to the policy.  This will delay and delay decisions on the details. ‚Äù </blockquote><br><br>  <b>Universal tools and solutions do not exist.</b>  If it seems to you that some kind of framework solves all your problems, then most likely it is not.  Therefore, when implementing any framework, it is important to understand not only what problems it will solve, but also what it will bring with it. <br><br>  <b>Do not immediately rewrite everything.</b>  If you encounter a problem in architecture and it seems that the only right decision is to write everything from scratch, wait.  If the problem is really serious, find a quick fix and watch how the system will work in the future.  Most likely, it will not be the only problem in architecture, with time you will find more.  And only when you pick up a sufficient number of problem areas, you can begin to refactor.  Only in this case will there be more advantages from it than its cost. </div><p>Source: <a href="https://habr.com/ru/post/441590/">https://habr.com/ru/post/441590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441568/index.html">Python memory management</a></li>
<li><a href="../441570/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ353 (February 17 - 24, 2019)</a></li>
<li><a href="../441582/index.html">LQR control system optimization</a></li>
<li><a href="../441584/index.html">PHP Digest 150 (February 11 - 25, 2019)</a></li>
<li><a href="../441586/index.html">How to recommend music that almost no one listened to. Yandex report</a></li>
<li><a href="../441592/index.html">IT-companies want to reset export tax</a></li>
<li><a href="../441594/index.html">Corporate napalm</a></li>
<li><a href="../441596/index.html">The first private spaceport will be built in Russia</a></li>
<li><a href="../441598/index.html">Lunar mission "Bereshit" - online portal with a simulator trajectory and monitoring of current flight parameters</a></li>
<li><a href="../441602/index.html">Why a classic automatic car is impossible and has no commercial prospects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>