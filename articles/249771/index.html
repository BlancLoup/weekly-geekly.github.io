<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How and why we do TLS in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am engaged in Yandex product safety and it seems that now is the time for more details than I already had on YaC , to tell Habr√© how we implement TL...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How and why we do TLS in Yandex</h1><div class="post__text post__text-html js-mediator-article">  I am engaged in Yandex product safety and it seems that now is the time for more details than I <a href="https://events.yandex.ru/lib/talks/2434/">already had on YaC</a> , to tell Habr√© how we implement TLS. <br><br>  Using HTTPS connections is an important part of a secure web service, since it is HTTPS that ensures the confidentiality and integrity of data at the stage of transferring them between the client and the service.  We gradually transfer all our services only to an HTTPS connection.  Many of them are already working exclusively on it: Passport, Mail, Direct, Metric, Taxi, Yandex.Money, as well as all feedback forms dealing with personal data of users.  For more than a year, Yandex.Mail has <a href="http://habrahabr.ru/company/yandex/blog/203882/">even been communicating with other SSL / TLS mail services</a> that support this. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/249771/"><img src="https://habrastorage.org/files/b02/9bd/c3a/b029bdc3a6d64af4b580f689d0cde132.png"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We all know that HTTPS is HTTP wrapped in TLS.  Why TLS, not SSL?  Because in principle, <abbr title="Transport Layer SecurityTLS">TLS</abbr> is a newer <abbr title="Secure socket layer">SSL</abbr> , while the name of the new protocol most accurately describes its purpose.  And in the light of the <a href="http://en.wikipedia.org/wiki/POODLE">POODLE</a> vulnerability, we can officially assume that SSL can no longer be used. <br><a name="habracut"></a><br>  Along with HTTP in TLS, almost any application layer protocol can be wrapped.  For example, SMTP, IMAP, POP3, XMPP, etc.  But since the deployment of HTTPS is the most massive problem and due to the peculiarities of the behavior of browsers has a large number of subtleties, I will tell you about it.  However, with some assumptions, many things will be true for other protocols.  I will try to tell you about the necessary minimum, which will be useful to our colleagues. <br><br>  I will conditionally divide the story into two parts - infrastructure, where everything that is below HTTP will be, and part about changes at the application level. <br><br><h3>  Termination </h3><br>  The first thing the team that is going to deploy HTTPS will have to face is the choice of TLS termination method.  TLS termination is the process of encapsulating an application layer protocol in TLS.  There are usually three options to choose from: <br><br><ol><li>  <b>Use one of the many third-party services - <a href="http://aws.amazon.com/elasticloadbalancing/">Amazon ELB</a> , <a href="http://www.cloudflare.com/">Cloudflare</a> , <a href="http://www.akamai.com/">Akamai</a> and others.</b>  The main disadvantage of this method will be the need to protect the channels between third-party services and your servers.  Most likely, it will still require the deployment of TLS support in one form or another.  A big disadvantage will also be complete dependence on the service provider in terms of supporting the necessary functionality, speed of fixing vulnerabilities. A separate problem may be the need to disclose certificates.  Despite this, this method will be a good solution for startups or companies using <a href="http://en.wikipedia.org/wiki/Platform_as_a_service">PaaS</a> . </li><li>  <b>For companies using their own hardware and their data centers, a possible option is the Hardware load balancer with TLS termination functions.</b>  The only advantage here is performance.  Choosing such a solution, you become completely dependent on your vendor, and since the same hardware components are often used inside the products, then they are also from chip manufacturers.  As a result, the timing of adding any features is far from ideal.  The potential customs difficulties with the importation of such products will be left outside this material. </li><li>  <b>Software solutions - the "golden mean".</b>  Existing opensource solutions - <a href="http://nginx.org/">Nginx</a> , <a href="http://www.haproxy.org/">Haproxy</a> , <a href="https://github.com/indutny/bud">Bud</a> , etc.  - give you almost complete control over the situation, adding features, optimizations.  The downside is performance - it is lower than that of hardware solutions. </li></ol><br>  In Yandex, we use software solutions.  If you follow our path, then an important step in deploying TLS will be for you to unify the components. <br><br><h3>  Unification </h3><br>  Historically, at different times, our services used different web server software, so in order to unify everything, we decided to abandon most of the decisions in favor of Nginx, and where it is impossible to refuse - to ‚Äúhide‚Äù them behind Nginx.  An exception in this case was a search that uses its own development called - suddenly - Balancer. <br><br>  Balancer can do a lot of things that others, even commercial solutions, cannot.  One day, I think the guys will tell about it in more detail.  Having a talented development team, we can afford to support one of our own web server in addition to Nginx. <br><br>  As for cryptography itself, we use the <a href="https://openssl.org/">OpenSSL</a> library.  Today it is the most stable and productive implementation of TLS with an adequate license.  It is important to use OpenSSL version 1+, since it is optimized to work with memory, there is support for all the necessary modern ciphers and protocols.  All our further recommendations will be targeted at users of the Nginx web server. <br><br><h3>  Certificates </h3><br>  To use HTTPS on your service you will need a certificate.  A certificate is a public key and some kind of data in the <a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a> format, signed by a Certificate Authority.  Typically, such certificates are signed by intermediate certification authorities (Intermediate CA) and contain the domain name of your service in the Common Name, or the Alt Names extension. <br><br>  To check the validity of the certificate, the browser tries to verify the validity of the digital signature for the final certificate, and then for each of the intermediate certifying centers.  The certificate of the latter in the chain of certification centers must be signed by the so-called Root CA. <br><br>  Certificates of root authentication centers are stored in the operating system or in the user's browser (for example, in Firefox).  When setting up a web server, it is important to send the client not only the server certificate, but also all intermediate ones.  You do not need to send the root certificate - it already exists in the OS. <br><br><img src="https://habrastorage.org/files/fc2/f34/301/fc2f343018f04f72a58d0b20d8ba9425.png"><br><br>  Large companies can afford to have their own Intermediate CA.  For example, until 2012, all Yandex certificates were signed by YandexExternalCA.  Using your own <a href="http://en.wikipedia.org/wiki/Intermediate_certificate_authorities">Intermediate CA</a> gives you both additional opportunities for certificate optimization and pinning, and imposes additional responsibility, as it allows you to write out a certificate for almost any final domain name, and in the case of compromise it can lead to serious consequences, including revocation of the intermediate CA certificate. <br><br>  Maintaining your own CA can be too expensive and complicated, so some companies use them in the MPKI - Managed <a href="http://en.wikipedia.org/wiki/Public_key_infrastructure">PKI</a> mode.  Most consumers will be enough to buy certificates using one of the commercial suppliers. <br><br>  All certificates can be divided into the following characteristics: <br><ol><li>  Digital signature algorithm and hash function used; </li><li>  Type of certificate. </li></ol><br>  Digital signature algorithm - public-key cryptographic algorithms are used to sign certificates, most often <a href="https://ru.wikipedia.org/wiki/RSA">RSA</a> , <a href="https://ru.wikipedia.org/wiki/DSA">DSA</a> or <a href="https://ru.wikipedia.org/wiki/ECDSA">ECDSA</a> .  We will not dwell on the algorithms of the GOST family, since they have not yet received mass support in the client software. <br><br>  Certificates using RSA are the most widely used today and are supported by all versions of protocols and OC. <br><br>  The disadvantage of this algorithm is key size and comparable performance when generating and verifying a digital signature.  Since certificates with a key size of less than 2048 bits are unsafe, and operations with a larger key consume a large amount of processor resources. <br><br>  DSA-like schemes are faster than RSA when generating a signature (with the same parameter sizes), while ECDSA is much faster than the classical DSA, since all operations take place in a group of points on an elliptical curve.  According to our tests, one Xeon 5645 server allows you to make up to 3200 TLS handles per second on the Nginx web server using a certificate signed by RSA with a key size of 2048 bits (ECDHE-RSA-AES128-GCM-SHA256).  In this case, using the ECDSA-certificate (ECDHE-ECDSA-AES128-GCM-SHA256), you can already make 6300 handhelds - the difference in performance almost doubled. <br><br>  Unfortunately, Windows XP &lt;SP3 and some browsers, which share non-zero among the clients of large sites, do not support ECC certificates. <br><br>  The strength of the most common EDS algorithms is directly dependent on the strength (security) of the hash function used.  The main hashing algorithms used are: <br><ol><li> <code>MD5</code> - today is considered unsafe and is not used; </li><li>  <code>SHA-1</code> - used to sign most certificates until 2014, is now recognized as unsafe; </li><li>  <code>SHA-256</code> - an algorithm that has already come to replace <code>SHA-1</code> ; </li><li>  <code>SHA-512</code> - is rarely used today, so we will not dwell on it. </li></ol><br>  <code>SHA-1</code> already officially considered unsafe today and is gradually being phased out.  So Yandex.Browser and other browsers of the Chromium family in the coming months will begin to mark certificates that are signed using <code>SHA-1</code> and which expire after <a href="http://googleonlinesecurity.blogspot.ru/2014/09/gradually-sunsetting-sha-1.html">January 1, 2016</a> , as unsafe.  All new certificates are properly signed using <code>SHA-256</code> .  Unfortunately, not all browsers and OSs (WinXP &lt;sp3) support this hash function, and for truly large resources this may threaten the loss of customers. <br><br>  All server end certificates used for TLS can be conditionally divided according to the validation method - Extended Validated and others (most often Domain Validated). <br><br>  Technically, in the extended validated certificate, additional fields are added with the EV flag and often with the company address.  The presence of an EV certificate implies a legal verification of the existence of the certificate holder, while certificates of the Domain Validated type only confirm that the certificate holder really controls the domain name. <br><br>  In addition to the appearance of a beautiful green dash, the sign of the EV certificate also affects the behavior of browsers associated with checking their revocation status.  So even Chromium family browsers, which use neither OCSP nor CRL, but rely only on Google CRLsets, for EV, check the status using the OCSP protocol.  Below I will talk about the features of the work of these protocols in more detail. <br><br>  Now that we have dealt with the certificates, we need to understand which protocol versions will be used.  As we all remember, the SSLv2 and SSLv3 version protocols contain fundamental vulnerabilities.  Therefore, they must be disabled.  Almost all clients now have support for TLS 1.0.  We recommend using TLS versions 1.1 and 1.2. <br><br>  If you have a significant number of clients using SSLv3, you can only be allowed to use it with the RC4 algorithm as a compensation measure - we did just that for the transition period.  However, if you do not have the same number of users with old browsers as ours, I recommend completely disable SSLv3.  The correct configuration for Nginx in terms of protocols will look like this: <br> <code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</code> <br> <br>  Regarding the choice of ciphersuites or cipher suites and hash functions that will be used for TLS connections, web servers should use only secure ciphers.  Here it is important to strike a balance between security, speed, performance and compatibility. <br><br><h3>  Security vs.  Perfomance </h3><br>  It is considered that the use of HTTPS is very costly both in terms of server-side performance and speed of loading and rendering resources on the client side.  This is partly true - an incorrectly configured HTTPS can add 2 (and more) Round Trip Times (RTT) for a handshake. <br><br>  In order to offset the delays arising from the implementation of HTTPS, the following techniques are used: <br><br><ol><li>  <b>Content Delivery Networks (CDN).</b>  By placing the termination point closer to the client, RTT can be reduced.  Thus, making the delays arising from the implementation of HTTPS imperceptible.  Yandex successfully <a href="http://habrahabr.ru/company/yandex/blog/176893/">uses</a> this technique and constantly increases the number of points of presence. <br><br><img src="https://habrastorage.org/files/51a/9bf/2ba/51a9bf2ba466479a98379c5ead3dcee2.png" alt="image"></li><li>  <b>Optimization of certificate status checks.</b>  At the time of establishing a secure connection, some browsers check the revocation status of the server certificate.  Such checks allow you to make sure that the certificate has not been revoked by the owner. The need to revoke a server certificate may arise, for example, after the private keys are compromised.  So mass certificates were revoked after the discovery of the Heartbleed vulnerability. </li></ol><br>  To date, there are two main protocols used to check certificate statuses: <br><ul><li>  <b>Certificate Revocation Lists.</b>  When using this method, the HTTP browser downloads from the URL specified in the certificate a list of the serial numbers of the revoked certificates.  This list is monitored and signed by the CA.  Since the file with the list can be large, it is cached for a specified period (most often for 1 week). </li><li>  <b>Online Certificate Status Protocol.</b> </li></ul><br><br>  Since both protocols run on top of HTTP and at the same time checking the status of the certificate is a blocking procedure, where the servers distributing the CRL or OCSP are located, the responders can directly affect the speed of the TLS handheld. <br><br>  Different browsers check certificate statuses in different ways.  So Firefox uses only OCSP for regular certificates, but CRL is checked for EV.  IE and Opera check both CRL and OCSP, and Yandex Browser and other browsers of the Chromium family do not use traditional protocols, relying on CRLsets - lists of revoked certificates of popular resources that come with browser updates. <br><br>  To optimize the checks, a mechanism called <a href="http://en.wikipedia.org/wiki/OCSP_stapling">OCSP stapling</a> was also invented, which allows the client to send an OCSP response to the client in the form of a TLS extension along with a certificate.  All modern desktop browsers support OCSP stapling (except Safari). <br><br>  You can enable OCSP stapling in nginx with the following directive: <code>ssl_stapling on;</code>  .  It is necessary to specify a <a href="http_core_module.html">resolver</a> . <br><br>  But if you have a really large and loaded resource, most likely you will want to be sure that the OCSP responses that you cache (Nginx caches responses for 1 hour) are correct. <br><pre> <code class="hljs pgsql">ssl_stapling_verify <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; ssl_trusted_certificate /<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your_intermediate_CA_and_root_certs;</code> </pre> <br><br>  When using OCSP stapling, mass resources can face such a problem as the wrong time on the client system.  This happens due to the fact that, according to the standard, the response time of the responder is limited to a clearly defined time interval, and the time on the client machine may be 5-10-20 minutes behind.  To solve this problem for users, we had to teach the server to distribute answers about a day after they were generated (we do about the same when laying out new certificates). <br><br>  Thus, we have the opportunity to show a warning about the wrong time to people who have the system time shot down for a period of up to a day.  In order to randomly rotate OCSP responses, the " <a href="http_ssl_module.html">ssl_stapling_file</a> " directive is used.  For those customers who do not support OCSP stapling, we use the caching of OCSP response responders in our CDN, thereby reducing the response time. <br><br>  Another effective way to optimize checks is to use short-lived certificates, that is, those in which no status check points are specified.  But the period of life of such certificates is very short - from one to three months. <br><br>  The Certificate Authority can afford to use such certificates.  They are almost always used for OCSP responders, since if there are check points in the certificate, Internet Explorer can also check the certificate status of the OCSP responder itself, which will create additional delays. <br>  But even when using OCSP stapling or short-lived certificates, the standard TLS handshake (4 steps) will add 2 RTT delays. <br><br>  The <a href="https://tools.ietf.org/html/draft-bmoeller-tls-falsestart-00">TLS False Start</a> mechanism allows you to send application data after Stage 3, without waiting for a server response, thus saving 1 RTT.  TLS False Start is supported by browsers of the Chromium family and Yandex Browser, IE, Safari, Firefox. <br><br><img src="https://habrastorage.org/files/1b4/fb1/9d9/1b4fb19d9f0d411d897c18f9e3331de6.png"><br><br>  Unfortunately, unlike browsers, not all web servers support this mechanism.  Therefore, the following requirements are usually the signal for using TLS False Start: <br><ul><li>  Server announces <a href="http://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">NPN / ALPN</a> (not required for Safari and IE); </li><li>  The server uses Perfect Forward Secrecy ciphersuites. </li></ul><br><br><h4>  Perfect Forward Secrecy </h4><br>  Prior to SSLv3, an attacker who gained access to the server's private key could passively decrypt all communications that went through the server.  Later, the <a href="https://ru.wikipedia.org/wiki/Perfect_forward_secrecy">Forward Secrecy</a> mechanism (sometimes using the Perfect prefix) was invented, which uses key agreement protocols (usually based on the <a href="http://en.wikipedia.org/wiki/Diffie%25E2%2580%2593Hellman_key_exchange%5D">Diffie-Hellman scheme</a> and ensures that session keys cannot be recovered, even if the attacker gets access to the server's private key. <br><br>  A typical nginx configuration for a service running with user data looks like this: <br><pre> <code class="hljs erlang-repl">ssl_prefer_server_ciphers on; ssl_ciphers kEECDH+AES128:kEECDH:kEDH:-<span class="hljs-number"><span class="hljs-number">3</span></span>DES:kRSA+AES128:kEDH+<span class="hljs-number"><span class="hljs-number">3</span></span>DES:DES-CBC3-SHA:!RC4:!aNULL:!eNULL:!MD5:!EXPORT:!LOW:!SEED:!CAMELLIA:!IDEA:!PSK:!SRP:!SSLv2;</code> </pre> <br><br>  In this configuration, we set the highest priority AES with a 128-bit session key, which is formed by the Elliptic Curve Diffie Hellman (ECDH) algoritm.  Next come any other ciphers from ECDH.  The second ‚ÄúE‚Äù in the abbreviation stands for Ephemeral, i.e.  session key that exists within the same connection. <br>  Next, we allow the use of the usual Diffie Hellman (EDH).  It is important to note here that using Diffie Hellman with a key size of 2048 bits can be quite expensive. <br><br>  This part of the config provides us with PFS support.  If you use processors with <a href="http://en.wikipedia.org/wiki/AES-NI%5D">AES-NI</a> support, then AES will be free for you, in terms of resources.  Disable 3DES, enable AES128 in non-PFS mode.  We leave 3DES and EDH and 3DES in CBC mode for compatibility with very old customers.  Turning off the unsafe RC4 and so on.  It is important to use the latest version of OpenSSL, then "AES128" will be deployed, including the <a href="http://en.wikipedia.org/wiki/Authenticated_encryption">AEAD ciphers</a> . <br><br>  PFS has a single flaw - performance penalties.  Modern web servers (including Nginx) use the event-driven model.  In this case, asymmetric cryptography is most often a blocking operation, since the web server process is blocked and the clients it serves suffer.  What can we optimize in this place? <br><br><ol><li>  <b>SPDY.</b> <br><br><img src="https://habrastorage.org/files/982/9d3/dac/9829d3dac73a488b9e48f15585fadaa8.png"><br><br>  If you read <a href="http://habrahabr.ru/company/yandex/blog/222951/">about the experience of SPDY implementation in the Post</a> , then you noticed that SPDY allows you to reduce the number of connections, and hence the number of handshakes.  In nginx 1.5+, SPDY is enabled by adding 4 letters to the config (the server must be compiled with the spdy module - with-http_spdy_module). <br><br> <code>listen 443 default spdy ssl;</code> </li> <li>  <b>Use elliptical cryptography.</b>  Asymmetric cryptography algorithms using elliptic curves are more efficient than their classical prototypes, which is why we increase the priority for ECDH when setting up ciphersuites.  As I wrote earlier, in addition to using ECDH, you can use certificates with digital signature on elliptic curves (ECDSA), which will increase performance. <br><br>  Unfortunately, Windows XP &lt;SP3 and some other browsers, the share of which among clients of large sites is non-zero, do not support ECC certificates.  The solution could be to use different certificates for different customers, which will save resources at the expense of newer customers, which are the majority.  Openssl version 1.0.2 allows you to select a server certificate depending on client settings.  Unfortunately, Nginx out of the box does not allow using multiple certificates for one server. </li><li>  <b>Use session reuse.</b>  Session reuse not only saves server resources (excludes asymmetric cryptography) for PFS / False Start connections, but also reduces the TLS handleshield delay to 1 RTT for regular connections. </li></ol><br><br><img src="https://habrastorage.org/files/a7e/54c/efe/a7e54cefed6a4f7184acd2615eecde0c.png"><br><br>  Currently there are two session reuse mechanisms: <br><ol><li>  <b>SSL session cache.</b>  This mechanism is based on the fact that a unique identifier is given to each client, and a session key is stored on the server using this identifier.  The advantage is the support of almost all, including the old, browsers.  The downside is the need to synchronize cache containing critical data between physical servers and data centers, which can lead to security problems. <br><br><img src="https://habrastorage.org/files/c9d/601/ce1/c9d601ce179147af883482a565cb04d7.png"><br><br>  In the case of Nginx, the session cache will work only if the client gets on the same real world where the initial SSL handshake occurred.  We still recommend that you enable the SSL session cache, as it will be useful for configurations with a small number of Reals, where the probability of a user hitting the same real is higher. <br><br>  In nginx, the configuration will look something like this, where SOME_UNIQ_CACHE_NAME is the cache name, which is recommended to use different identifiers for different certificates (not necessarily in nginx 1.7.5+, 1.6.2+), 128Mb is the cache size, 28 hours is the session lifetime. <br> <code>ssl_session_cache shared:SOME_UNIQ_CACHE_NAME:128m; <br> <br> ssl_session_timeout 28h;</code> <br> <br>  With an increase in the lifetime of the session, you need to be prepared for the fact that in the error logs records may appear: <br>  <code>2014/03/18 13:36:08 [crit] 18730#0: ngx_slab_alloc() failed: no memory in SSL session shared cache "SSL"</code> . <br><br>  This is due to the peculiarity of displacing data from the session cache in nginx - an attempt is made to allocate memory for the session, if the limit is reached, one of the oldest sessions is killed and the operation is repeated again.  That is, the session is successfully added to the buffer, but an error is written to the log at the first call to the allocator function.  Such errors can be ignored - they do not affect the functionality (fixed in Nginx 1.4.7). </li><li>  <b>TLS session tickets</b> .  The mechanism is supported only by browsers of the Chromium family, including Yandex Browser, as well as Firefox.  In this case, the client is sent the session state, encrypted with a key known to the server, as well as the key identifier.  In this case, only keys are shared between servers. <br><br><img src="https://habrastorage.org/files/21f/196/4e3/21f1964e34684a93a94e44b0aebf46b5.png"><br><br>  In Nginx, support for static keys for session tickets has been added in versions 1.5.8+.  Setting up tls session tickets when working with multiple servers is done as follows: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ssl_session_ticket_key</span></span> current.key; <span class="hljs-attribute"><span class="hljs-attribute">ssl_session_ticket_key</span></span> prev.key; <span class="hljs-attribute"><span class="hljs-attribute">ssl_session_ticket_key</span></span> prevprev.key;</code> </pre> <br><br>  In this case, current.key is the key that is currently being used.  Prev.key is the key used by N hours before using current.key.  Prevprev.key is the key used by N hours before using prev.key.  The value of N must be equal to that specified in <a href="http_ssl_module.html">ssl_session_timeout</a> .  We recommend starting at 28 hours. <br><br>  The important point is the method of rotation of keys, since  The attacker who stole the key for encrypting tickets can decrypt all sessions (including PFS) within the key's lifetime. </li></ol><br><br>  In Yandex, there are special mechanisms for generating and securely delivering keys to destination servers. <br><br><h3>  Applications </h3><br><h4>  CSP </h4><br>  Once the infrastructure issues have been resolved, let‚Äôs go back to the applications.  The first thing you need to do is get rid of the so-called.  mixed content  It all depends on the scale of the project, the quantity and quality of the code.  Somewhere you can do with sed, or <a href="http_sub_module.html">nginx</a> , but somewhere you have to look for hard-coded http schemes in the DOM tree.  We came to the aid of the Content Security Policy, our colleagues from Mail <a href="http://habrahabr.ru/company/yandex/blog/206508/">wrote</a> about its implementation <a href="http://habrahabr.ru/company/yandex/blog/206508/">earlier</a> . <br><br>  By adding such a title to the test stand you will receive reports on any content that is loaded via protocols other than <code>data:</code> and <code>https:</code> <br> <code>Content-Security-Policy-Report-Only: default-src https:; script-src https: 'unsafe-eval' 'unsafe-inline'; style-src https: 'unsafe-inline'; img-src https: data:; font-src https: data:; report-uri /csp-report</code> <br> <br><h4>  Secure cookies </h4><br>  After you get rid of the mixed content, it is important to ensure that the Secure attribute is set for cookies.  He tells the browser that cookies cannot be sent over an unsecured connection.  So in Yandex, while there are two cookies - sessionid2 and Session_id, one of which is sent only through a secure connection, while the other is left "unsafe" for backward compatibility.  Without a ‚Äúsafe‚Äù cookie, you cannot get to Mail, Disc, and other important services. <br><br> <code>Set-Cookie: session=1234567890abcdef; HttpOnly; Secure;</code> <br> <br><h4>  HSTS </h4><br>  Finally, after you have verified that your service is working correctly over the HTTPS protocol, set up a redirect from the HTTP version to HTTPS, it is important to inform the browser that this resource can no longer be accessed using the unprotected HTTP protocol. <br><br>  For this, the HTTP Strict Transport Security Security header was invented. <br> <code>Strict-Transport-Security: max-age=31536000; includeSubdomains;</code> <br> <br>  The max-age parameter specifies the period (1 year) during which the protected protocol should be used.  The optional includeSubdomains flag says that all subdomains of this domain can also be accessed only through encrypted connections. <br><br>  In order for users of the Chromium and Firefox family of browsers to always use secure connections, even when they are first accessed, you can add your resource to the browser's HSTS list.  In addition to providing security, it will also save one redirect on first access. <br><br>  To do this, add the preload flag to the header and specify the domain here: <a href="https://hstspreload.appspot.com/">hstspreload.appspot.com</a> . <br> <code>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</code> <br> <br>  For example, Yandex.Passport has been added to the preload list of browsers. <br><br><h3>  Conclusion </h3><br>  The entire configuration of a single nginx server will look something like this: <br><br><pre> <code class="hljs erlang-repl">http { [...] ssl_stapling on; resolver <span class="hljs-number"><span class="hljs-number">77.88</span></span>.<span class="hljs-number"><span class="hljs-number">8.1</span></span>; #  <span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0.1</span></span>    keepalive_timeout <span class="hljs-number"><span class="hljs-number">120</span></span> <span class="hljs-number"><span class="hljs-number">120</span></span>; server { listen <span class="hljs-number"><span class="hljs-number">443</span></span> ssl spdy; server_name yourserver.com; ssl_certificate /etc/nginx/ssl/cert.pem; #   ssl_certificate_key /etc/nginx/ssl/key.pem; #   ssl_dhparam /etc/nginx/ssl/dhparam.pem; #   openssl dhparam <span class="hljs-number"><span class="hljs-number">2048</span></span> ssl_prefer_server_ciphers on; ssl_protocols TLSv1 TLSv1.<span class="hljs-number"><span class="hljs-number">1</span></span> TLSv1.<span class="hljs-number"><span class="hljs-number">2</span></span>; ssl_ciphers kEECDH+AES128:kEECDH:kEDH:-<span class="hljs-number"><span class="hljs-number">3</span></span>DES:kRSA+AES128:kEDH+<span class="hljs-number"><span class="hljs-number">3</span></span>DES:DES-CBC3-SHA:!RC4:!aNULL:!eNULL:!MD5:!EXPORT:!LOW:!SEED:!CAMELLIA:!IDEA:!PSK:!SRP:!SSLv2; ssl_session_cache shared:SSL:<span class="hljs-number"><span class="hljs-number">64</span></span>m; ssl_session_timeout <span class="hljs-number"><span class="hljs-number">28</span></span>h; add_header Strict-Transport-Security <span class="hljs-string"><span class="hljs-string">"max-age=31536000; includeSubDomains;"</span></span>; add_header Content-Security-Policy-Report-Only <span class="hljs-string"><span class="hljs-string">"default-src https:; script-src https: 'unsafe-eval' 'unsafe-inline'; style-src https: 'unsafe-inline'; img-src https: data:; font-src https: data:; report-uri /csp-report"</span></span>; location / { ... } }</code> </pre> <br><br>  In conclusion, I would like to add that HTTPS is gradually becoming the de facto standard for working with WEB, and is used not only by browsers - most of the mobile application APIs start to work using the HTTPS protocol.  You can learn about some features of the secure implementation of HTTPS in mobiles <a href="https://events.yandex.ru/lib/talks/2675/">from the report of</a> Yury <a href="https://habrahabr.ru/users/tracer0tong/" class="user_link">tracer0tong</a> Leonidchev on a clean-up day in Nizhny Novgorod. </div><p>Source: <a href="https://habr.com/ru/post/249771/">https://habr.com/ru/post/249771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249759/index.html">Sample Feature Engineering in Machine Learning</a></li>
<li><a href="../249761/index.html">Sberbank Online: find out personal data by phone</a></li>
<li><a href="../249765/index.html">How I fought adware on google play and lost</a></li>
<li><a href="../249767/index.html">Authoring Perl Modules</a></li>
<li><a href="../249769/index.html">The ‚ÄúUnread issues‚Äù plugin - as we notify employees in Redmine. General concept</a></li>
<li><a href="../249773/index.html">DevCon 2015: announcement of the first speakers and conference reports</a></li>
<li><a href="../249775/index.html">Zombies are attacking the App Store, Android is catching up with iOS, Liam Neeson is taking revenge on the offender - and other news of the week for a mobile developer</a></li>
<li><a href="../249777/index.html">Why did we make the Beeline application for Windows Phone and that there is something in this OS that is not in iOS and Android</a></li>
<li><a href="../249779/index.html">Blockchain Formation Algorithm</a></li>
<li><a href="../249781/index.html">Festival "City of Techno-Creativity" is held in Yekaterinburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>