<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three strategies for testing Terraform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I really like Terraform. 


 In addition to CloudFormation for AWS and OpenStack Heat, this is one of the most useful open source tools for deploying ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three strategies for testing Terraform</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/8c5/a88/c94/8c5a88c9436f483a9669a822ee99d469.png"><br><br><p>  I really like Terraform. </p><br><p>  In addition to CloudFormation for AWS and OpenStack Heat, this is one of the most useful open source tools for deploying and configuring infrastructure on any platform.  However, there is one way to work with Terraform that worries me: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">terraform</span></span> plan <span class="hljs-comment"><span class="hljs-comment"># ¬´ ;  !¬ª ‚Äî  . terraform apply</span></span></code> </pre> <br><p>  Maybe this is not a problem if you deploy software on the same rack in a data center or test an AWS account with limited rights.  In such a situation, harm is quite difficult. </p><br><p>  And if the deployment is done from under the all-seeing and all-powerful production-account or covers the entire data center?  It seems to me very risky. </p><br><p>  Integration and unit testing can solve this problem.  You probably ask: ‚ÄúUnit testing is like for programs?‚Äù Yes, that unit testing! </p><br><p>  In this article we will talk a little about what integration and unit testing are, as well as consider the problems and strategies for testing infrastructure used in practice.  We will also touch upon the deployment strategies of the infrastructure as they relate to testing.  Despite the fact that the article contains a sufficient amount of code, deep programming knowledge from readers is not required. </p><a name="habracut"></a><br><h2 id="vvedenie-v-testirovanie-programm">  Introduction to testing programs </h2><br><p>  <em>Unit testing is</em> used by developers to verify the correct operation of individual functions, and <em>integration testing</em> is used to test the function as part of an application.  Let's illustrate the difference with an example. </p><br><p>  Suppose I write a pseudo-language calculator and are now creating a function that adds two numbers.  It looks like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> addTwoNumbers(<span class="hljs-type"><span class="hljs-type">integer</span></span> firstNumber, <span class="hljs-type"><span class="hljs-type">integer</span></span> secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (firstNumber + secondNumber); }</code> </pre> <br><p>  The unit test of this function looks like this: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">function</span></span> testAddTwoNumbers() { <span class="hljs-attribute"><span class="hljs-attribute">firstNumber</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secondNumber</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">expected</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">actual</span></span> = addTwoNumbers(firstNumber, secondNumber); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( expectedResult != actualResult ) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> testFailed(<span class="hljs-string"><span class="hljs-string">"Expected %s but got %s"</span></span>, expected, actual); } <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> testPassed(); }</code> </pre> <br><p>  As you can see from the listing, the unit test verifies that the <em>addTwoNumbers</em> function can add two numbers.  Despite the seemingly triviality, such tests are very important, and their absence has led to the failure of many large projects! </p><br><p>  Making sure this feature works as part of the entire application is much more difficult.  The success of this process is affected by the complexity of the application itself and its dependencies.  In our case, the integration testing calculator looks quite simple: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Calculator</span></span> testCalculator = new Calculator(); <span class="hljs-attribute"><span class="hljs-attribute">firstNumber</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secondNumber</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">expected</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">actual</span></span> = testCalculator.addTwoNumbers(firstNumber, secondNumber); <span class="hljs-comment"><span class="hljs-comment"># add other tests here Test testAddTwoNumbers { if ( expected != actual ) { testFailed("Expected %s, but got %s.", expected, actual); } testPassed(); }</span></span></code> </pre> <br><p>  We create a Calculator class testCalculator object and check if the addition function of two numbers works.  If, during unit testing, this function was isolated from other components of the Calculator class, during integration testing, all components are put together to ensure that the changes to addCalculator have not broken the entire application. </p><br><blockquote>  ‚ÄúI deploy infrastructure, Carlos.  Why do I need all this? </blockquote><p>  I'll explain now. </p><br><p>  Have you ever written such scripts ... </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> increaseDiskSize(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> smbComputerName, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> driveLetter) { wmiQueryResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wmiObject(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM WIN32_LOGICALDISK WHERE DRIVELETTER = \"</span></span>%s\<span class="hljs-string"><span class="hljs-string">""</span></span>, driveLetter) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( wmiQuery != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) { # <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> stuff } }</code> </pre> <br><p>  ... in the hope that they will work properly?  Did you restart them several times on the test machine, making changes each time after the defects found?  Has it happened that after launching this procedure on a combat server, it did not work as it should?  Did you lose the evening or weekend for this reason? </p><br><p>  If so, then I think you perfectly understand the problems associated with this approach. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">terraform</span></span> plan <span class="hljs-comment"><span class="hljs-comment"># ¬´ ;  !¬ª ‚Äî  . terraform apply</span></span></code> </pre> <br><p>  This is the same! </p><br><h2 id="strategiya-testirovaniya-terraform--1-vizualnyy-kontrol">  Terraform Test Strategy # 1: Visual Inspection </h2><br><img src="https://habrastorage.org/web/04a/e22/230/04ae222306394f57a6e42538110c4244.jpg"><br><br><p>  <em>Terraform plan</em> is a great feature that gives you the opportunity to see what Terraform is going to do.  It was created for practitioners so that they could evaluate the upcoming actions, make sure that everything looks good, and then run <em>terraform apply</em> as the final touch. </p><br><p>  Let's say you are going to deploy a Kubernetes cluster in AWS using VPC and EC2 keys.  The corresponding code might look like this (without working hosts): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">provider</span></span> <span class="hljs-string"><span class="hljs-string">"aws"</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">region</span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.aws_region}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_vpc"</span></span> <span class="hljs-string"><span class="hljs-string">"infrastructure"</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">cidr_block</span></span> = <span class="hljs-string"><span class="hljs-string">"10.1.0.0/16"</span></span> tags = { <span class="hljs-attribute"><span class="hljs-attribute">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"vpc.domain.internal"</span></span> Environment = <span class="hljs-string"><span class="hljs-string">"dev"</span></span> } } resource <span class="hljs-string"><span class="hljs-string">"aws_key_pair"</span></span> <span class="hljs-string"><span class="hljs-string">"keypair"</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">key_name</span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.key_name}</span></span></span><span class="hljs-string">"</span></span> public_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.public_key}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_instance"</span></span> <span class="hljs-string"><span class="hljs-string">"kubernetes_controller"</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">ami</span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${data.aws_ami.kubernetes_instances.id}</span></span></span><span class="hljs-string">"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.kubernetes_controller_instance_size}</span></span></span><span class="hljs-string">"</span></span> count = <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre> <br><p>  When using visual controls, you run <em>terraform plan</em> , make sure everything is fine (by specifying the appropriate variables), and run <em>terraform apply</em> to apply the changes. </p><br><h3 id="preimuschestva">  Benefits </h3><br><p>  <strong>Development takes a little time</strong> </p><br><p>  This approach works well on a small scale or if you need to quickly write a configuration to test something new.  The feedback loop in this case works very quickly (we write the code, <em>terraform plan</em> , check, then, if everything is fine, <em>terraform apply</em> );  Over time, you can learn how to quickly stamp new configurations. </p><br><p>  <strong>Sloping learning curve</strong> </p><br><p>  This work can be performed by any person regardless of their level of Terraform knowledge, programming experience and system administration.  The plan has almost all the necessary information. </p><br><h3 id="nedostatki">  disadvantages </h3><br><p>  <strong>Error detection difficulty</strong> </p><br><p>  Let's say you read this <a href="https://pdos.csail.mit.edu/6.824/papers/borg.pdf">document on Borg</a> and wanted to deploy five replicas of the master Kubernetes instead of three.  You quickly check the plan and, being absolutely sure that everything is in order, you launch it for execution.  But then it suddenly turns out that you forgot about the most important thing and nevertheless three masters unfolded, and not five! </p><br><p>  In this example, to fix the situation is very simple: change the values ‚Äã‚Äãof variables in <code>variables.tf</code> and expand the cluster again.  However, things could be much worse if, for example, it was a battle cluster, and the teams responsible for the functionality had already deployed their services there. </p><br><p>  <strong>Scaling issues</strong> </p><br><p>  Visual control is good if you are not using Terraform very actively. </p><br><p>  The situation becomes more complicated when you begin to deploy dozens and hundreds of different infrastructure components on dozens and hundreds of servers each.  <a href="https://www.terraform.io/docs/modules/usage.html">The modules</a> will help us illustrate the situation.  Take a look at this configuration: </p><br><pre> <code class="hljs kotlin"># main.tf module <span class="hljs-string"><span class="hljs-string">"stack"</span></span> <span class="hljs-string"><span class="hljs-string">"standard"</span></span> { source = <span class="hljs-string"><span class="hljs-string">"git@github.com:team/terraform_modules/stack.git"</span></span> number_of_web_servers = <span class="hljs-number"><span class="hljs-number">2</span></span> number_of_db_servers = <span class="hljs-number"><span class="hljs-number">2</span></span> aws_account_to_use = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_account_number}</span></span></span><span class="hljs-string">"</span></span> aws_access_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_access_key}</span></span></span><span class="hljs-string">"</span></span> aws_secret_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_secret_key}</span></span></span><span class="hljs-string">"</span></span> aws_region_to_deploy_into = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_region}</span></span></span><span class="hljs-string">"</span></span> ‚Ä¶ }</code> </pre> <br><p>  It seems simple enough: it says where the module is and what variables it receives at the input.  You decide to see how this module works, open its code and see ... </p><br><pre> <code class="hljs kotlin"># team/terraform_modules/stack/main.tf module <span class="hljs-string"><span class="hljs-string">"web_server"</span></span> <span class="hljs-string"><span class="hljs-string">"web_servers_in_stack"</span></span> { source = <span class="hljs-string"><span class="hljs-string">"git@github.com:team/terraform_modules/core/web.git"</span></span> count = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.number_of_web_servers}</span></span></span><span class="hljs-string">"</span></span> type = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${coalesce(var.web_server_type, "IIS")}</span></span></span><span class="hljs-string">"</span></span> aws_access_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_access_key}</span></span></span><span class="hljs-string">"</span></span> aws_secret_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_secret_key}</span></span></span><span class="hljs-string">"</span></span> ‚Ä¶ } module <span class="hljs-string"><span class="hljs-string">"database_server"</span></span> <span class="hljs-string"><span class="hljs-string">"db_servers_in_stack"</span></span> { source = <span class="hljs-string"><span class="hljs-string">"git@github.com:team/terraform_modules/core/db.git"</span></span> count = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.number_of_db_servers}</span></span></span><span class="hljs-string">"</span></span> type = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${coalesce(var.web_server_type, "MSSQLServerExp2016")}</span></span></span><span class="hljs-string">"</span></span> aws_access_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_access_key}</span></span></span><span class="hljs-string">"</span></span> aws_secret_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${var.aws_secret_key}</span></span></span><span class="hljs-string">"</span></span> ‚Ä¶ }</code> </pre> <br><p>  ... <em>more modules</em> !  It is not hard to guess that wandering along chains of repositories or directories in order to find out what the current configuration of Terraform is doing is tedious at best, and fraught at worst;  and performing this exercise during a crash is also very expensive! </p><br><h2 id="strategiya-testirovaniya-terraform--2-snachala-integracionnoe-testirovanie">  Terraform # 2 Testing Strategy: Integration Testing First </h2><br><img src="https://habrastorage.org/web/420/db6/a35/420db6a3514244d2863b77d54b2195aa.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  To solve the problems associated with the test method described above, you can use serverspec, Goss and / or <a href="https://github.com/chef/inspec">InSpec tools</a> .  When using this approach, first your plans are executed in the sandbox with automatic verification of the success of the procedure.  If all tests are passed, you can proceed to the deployment in a production environment.  Otherwise, the analysis of errors and their correction. </p><br><p>  In the case of using a Jenkins or Bamboo CI chain, the process might look like this: </p><br><img src="https://habrastorage.org/web/730/62c/b6c/73062cb6c2024c96b5d34063ab5f7cfd.png"><br><p>  <strong>Scheme 1.</strong> An example of the procedure for deploying infrastructure with the use of integration testing.  Orange color marks the steps performed in the sandbox. </p><br><p>  This is a big step in the right direction, but there are pitfalls here that are worth talking about separately. </p><br><h3 id="preimuschestva-1">  Benefits </h3><br><p>  <strong>Allows you to get rid of long-lived development environments and encourages the use of immutable infrastructure</strong> </p><br><p>  A common practice is to create long-lived development environments or sandboxes designed to test software update procedures and script changes.  These environments usually have differences from production, enough so that what ‚Äúworks in dev‚Äù breaks in combat conditions.  This leads to "testing in production", which ultimately can result in service downtime due to human errors. </p><br><p>  Well-written integration tests allow you to abandon these unsafe practices. </p><br><p>  Each sandbox created during integration testing will be an exact copy of production, because <em>each sandbox will eventually become production</em> .  This is a key step to building a <a href="https://blog.codeship.com/immutable-infrastructure/">fixed infrastructure</a> , where any potential change in the combat system becomes part of the hotfix or future release fix package and <em>immediate changes in production are prohibited and not needed</em> . </p><br><p>  This <em>does not</em> mean that such an approach can get rid of the environments directly used by product developers (integration testing of software also calls into question the need to use such environments, but this topic is beyond the scope of this article). </p><br><p>  <strong>Documents the infrastructure</strong> </p><br><p>  You no longer need to wade through numerous modules to figure out the infrastructure deployment plan.  If there is a 100% coverage of the Terraform code (we will discuss this a bit later), the tests contain comprehensive information and act as a contract, the conditions of which the infrastructure must adhere to. </p><br><p>  <strong>Allows you to tag versions and "releases" of the infrastructure</strong> </p><br><p>  <a href="https://medium.com/android-testing-daily/unit-test-vs-integration-tes-fba13b92fbf6">Since integration tests are designed to test the system as a whole</a> , they allow you to tag Terraform code using git tags or similar tools.  This functionality can be used to roll back to previous states (especially when combined with <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/blue-green.html">a blue-green deployment strategy</a> ) or to allow developers to test how the functionality they develop will respond to different versions of the infrastructure. </p><br><p>  <strong>Can be the first line of defense</strong> </p><br><p>  Well-established integration tests serve as an early warning system for errors in third-party applications. </p><br><p>  Let's say you created a chain in Jenkins or Bamboo, within which the Terraform-infrastructure integration tests are run twice a day.  If errors occur, you receive the appropriate messages. </p><br><p>  A few days later, you receive a warning that the integration test ended with an error.  In the build log you see an error Chef, which says that it could not install IIS, because the installer was not found.  Next, it turns out that the URL required to install IIS is outdated and requires updating. </p><br><p>  After cloning the repository in which the corresponding cookbook resides, updating the URL, restarting the integration tests locally and waiting for them to complete, you create a pull request to the repository owner team asking you to accept the change. </p><br><p>  My congratulations!  You have just saved your weekend by correcting a mistake in the code in advance, instead of waiting for the release to start and reacting to its appearance as early as during this operation. </p><br><h3 id="nedostatki-1">  disadvantages </h3><br><p>  <strong>It may take a lot of time.</strong> </p><br><p>  Depending on the resources created by the Terraform configuration and the number of modules to which they refer, launching Terraform can be very costly.  As a result, feedback cycles are slowed down, in which the engineer makes a change, waits until the testing is completed, finds the cause of the error, and the cycle starts again.  After a certain number of iterations, the <em>engineer will eventually find a way around these tests</em> . </p><br><p>  <strong>It can be quite expensive.</strong> </p><br><p>  Performing full-fledged integration tests in the sandbox involves mirroring the entire infrastructure for a short period of time (albeit on a smaller scale).  Performing this procedure to check for small changes over time can result in a decent amount, especially if the mirror is large enough. </p><br><p>  This should not bother those who work on their own servers, as they can apply Terraform configurations on unused hardware, and then delete them using <em>terraform destroy</em> .  This, however, brings us to the next point, since cleaning and adjustment for the next test run may take some time. </p><br><p>  <strong>Difficult to determine code coverage</strong> </p><br><p>  Unlike most programming languages ‚Äã‚Äãor proven configuration management tools such <a href="https://github.com/chefspec/chefspec">as Chef</a> , Terraform does not have the means to get the configuration percentage that the integration tests correspond to.  This means that teams that decide to go along this path should closely monitor the maintenance of a high percentage of code coverage, and most likely they will have to write their own necessary tools, which, for example, will scan all references to modules and look for their respective definitions of specifications. </p><br><h3 id="instrumenty">  Instruments </h3><br><p>  <a href="https://github.com/newcontext-oss/kitchen-terraform">kitchen-terraform</a> is the most popular integration testing tool for Terraform at the moment.  This is the same Kitchen that you could use for Chef, and like test-kitchen, you can define the behavior of Terraform with <code>.kitchen.yml</code> - the kitchen will take care of everything else. </p><br><p>  <a href="https://github.com/aelsabbahy/goss">Goss</a> is a simple validation / status check tool that allows you to determine the desired state of the system and either compare with a given definition or provide an end point, <code>/health</code> , which contains information about what is going <br>  system check or not.  This tool is similar to <a href="https://github.com/mizzy/serverspec">serverspec</a> , which allows you to achieve a similar result (with the exception of a cool web-based state of health check) and works fine with Ruby. </p><br><h2 id="strategiya-testirovaniya-terraform--2-yunit-testy">  Terraform Test Strategy # 2: Unit Tests </h2><br><img src="https://habrastorage.org/web/5ea/4c2/90a/5ea4c290a6fc42eca215af14b5750c22.jpg"><br><br><p>  An experienced developer may ask: ‚ÄúUsually I write unit tests before integration.  Is it the same with Terraform? ‚ÄùThank you for reading this far! </p><br><p>  As noted earlier, integration testing allows you to check the correctness of the interaction of system components.  <em>Unit testing</em> allows you to test the performance of these components separately, in isolation from each other.  Unit tests should be quick, easy to understand and write.  Good unit tests should run everywhere, with <em>or without a</em> network connection. </p><br><p>  Returning to our Kubernetes cluster example, for the resources we defined above, a simple unit test for the popular Ruby <a href="https://github.com/rspec/rspec">RSpec</a> test framework will look like this: </p><br><pre> <code class="hljs kotlin"># spec/infrastructure/core/kubernetes_cluster_spec.rb require <span class="hljs-string"><span class="hljs-string">'spec_helper'</span></span> require <span class="hljs-string"><span class="hljs-string">'set'</span></span> describe <span class="hljs-string"><span class="hljs-string">"KubernetesCluster"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> before(:all) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-meta"><span class="hljs-meta">@vpc_details</span></span> = $terraform_plan[<span class="hljs-string"><span class="hljs-string">'aws_vpc.infrastructure'</span></span>] <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span> = $terraform_plan[<span class="hljs-string"><span class="hljs-string">'kubernetes-cluster'</span></span>].select <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |key,value| key.match /aws_instance\.kubernetes_controller/ end <span class="hljs-meta"><span class="hljs-meta">@coreos_amis</span></span> = obtain_latest_coreos_version_and_ami! end context <span class="hljs-string"><span class="hljs-string">"Controller"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> context <span class="hljs-string"><span class="hljs-string">"Metadata"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">"should have retrieved EC2 details"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>(<span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>).not_to be_nil end end context <span class="hljs-string"><span class="hljs-string">"Sizing"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">"should be defined"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>($terraform_tfvars[<span class="hljs-string"><span class="hljs-string">'kubernetes_controller_count'</span></span>]).not_to be_nil end it <span class="hljs-string"><span class="hljs-string">"should be replicated the correct number of times"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> expected_number_of_kube_controllers = \ $terraform_tfvars[<span class="hljs-string"><span class="hljs-string">'kubernetes_controller_count'</span></span>].to_i <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>(<span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>.count).to eq expected_number_of_kube_controllers end it <span class="hljs-string"><span class="hljs-string">"should use the same AZ across all Kubernetes controllers"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # We aren<span class="hljs-string"><span class="hljs-string">'t testing that these controllers actually have AZs # (it can be empty if not defined). We'</span></span>re solely testing that # they are the same within <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> AZ. azs_for_each_controller = <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>.values.map <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |controller_config| controller_config[<span class="hljs-string"><span class="hljs-string">'availability_zone'</span></span>] end deduplicated_az_set = Set.new(azs_for_each_controller) <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>(deduplicated_az_set.count).to eq <span class="hljs-number"><span class="hljs-number">1</span></span> end end it <span class="hljs-string"><span class="hljs-string">"should be fetching the latest stable release of CoreOS for region \ #{ENV['AWS_REGION']}"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>.keys.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |kube_controller_resource_name| this_controller_details = <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>[kube_controller_resource_name] expected_ami_id = <span class="hljs-meta"><span class="hljs-meta">@coreos_amis</span></span>[ENV[<span class="hljs-string"><span class="hljs-string">'AWS_REGION'</span></span>]][<span class="hljs-string"><span class="hljs-string">'hvm'</span></span>] actual_ami_id = this_controller_details[<span class="hljs-string"><span class="hljs-string">'ami'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>(expected_ami_id).to eq expected_ami_id end end it <span class="hljs-string"><span class="hljs-string">"should use the instance size requested"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>.keys.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |kube_controller_resource_name| this_controller_details = <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>[kube_controller_resource_name] actual_instance_size = this_controller_details[<span class="hljs-string"><span class="hljs-string">'instance_type'</span></span>] expected_instance_size = $terraform_tfvars[<span class="hljs-string"><span class="hljs-string">'kubernetes_controller_instance_size'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>(expected_instance_size).to eq actual_instance_size end end it <span class="hljs-string"><span class="hljs-string">"should use the key provided"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>.keys.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |kube_controller_resource_name| this_controller_details = <span class="hljs-meta"><span class="hljs-meta">@controllers_found</span></span>[kube_controller_resource_name] actual_ec2_instance_key_name = this_controller_details[<span class="hljs-string"><span class="hljs-string">'key_name'</span></span>] expected_ec2_instance_key_name = $terraform_tfvars[<span class="hljs-string"><span class="hljs-string">'kubernetes_controller_ec2_instance_key_name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span>(expected_ec2_instance_key_name).to eq actual_ec2_instance_key_name end end end end</code> </pre> <br><p>  Here are some important points to look out for: </p><br><p>  <strong>Easy to read</strong> </p><br><p>  To determine what a test is and what it should do, we use operators that are formulated in a language very close to ordinary English.  Look at this piece of code: </p><br><pre> <code class="hljs ruby">describe <span class="hljs-string"><span class="hljs-string">"KubernetesCluster"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> before(<span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @vpc_details = $terraform_plan[<span class="hljs-string"><span class="hljs-string">'aws_vpc.infrastructure'</span></span>] @controllers_found = $terraform_plan[<span class="hljs-string"><span class="hljs-string">'kubernetes-cluster'</span></span>].select <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|key,value|</span></span> key.match /aws_instance\.kubernetes_controller/ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @coreos_amis = obtain_latest_coreos_version_and_ami! <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> context <span class="hljs-string"><span class="hljs-string">"Controller"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> context <span class="hljs-string"><span class="hljs-string">"Metadata"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">"should have retrieved EC2 details"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> expect(@controllers_found).not_to be_nil <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here we <strong>describe</strong> (describe) the Kubernetes cluster by performing some operators <strong>before all</strong> other tests, before we perform a series of <strong>controller</strong> -related tests that focus on the Kubernetes cluster <strong>metadata</strong> .  We expect the <strong>details to be loaded from EC2</strong> and that these details are an array of <strong>controllers found</strong> . </p><br><p>  <strong>They are fast</strong> </p><br><p>  If you have a generated Terraform plan (we will touch on this topic soon), unit tests will be performed in less than a second.  There are no sandboxes to query, and no AWS API to call;  we simply compare what we wrote with what Terraform generated from it. </p><br><p>  <strong>Easy to write</strong> </p><br><p>  Apart from a few special cases (see the section <em>Disadvantages</em> ), all test examples are taken from the <a href="https://relishapp.com/rspec/rspec-core/v/3-4/docs">RSpec documentation</a> .  There are no hidden methods or pitfalls here, unless of course you have previously added them yourself. </p><br><p>  So why do we need unit-test Terraform code? </p><br><h3 id="preimuschestva-2">  Benefits </h3><br><p>  <strong>Allows you to use the development through testing (test-driven development)</strong> </p><br><p>  Test-driven development is a software development technique in which functionality is written <em>after</em> writing a test that determines what this functionality does.  Thus, all the important methods get the tests that describe them. <strong>     ,  -  </strong> ,                ,    . </p><br><p>   Terraform-  ,     -  ... </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">describe</span></span> <span class="hljs-string"><span class="hljs-string">"VPC"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">context</span></span> <span class="hljs-string"><span class="hljs-string">"Networking"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">"should use the right CIDR"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> expected_cidr_block = $terraform_tfvars[<span class="hljs-string"><span class="hljs-string">'cidr_block'</span></span>] expect($terraform_plan[<span class="hljs-string"><span class="hljs-string">'aws_vpc.vpc'</span></span>][<span class="hljs-string"><span class="hljs-string">'cidr_block'</span></span>]).to eq expected_cidr_block <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p> ‚Ä¶   <code>main.tf</code> ,  <code>rake unit_test</code> (  )  ,     ,    <code>main.tf</code>   ,      . ,     , : )  ; ) ,      ¬´ ¬ª. </p><br><p> <strong>  </strong> </p><br><p> - Terraform        Terraform.     .  ,        Terraform- ,    ,       ¬´¬ª. </p><br><p> <strong>  </strong> </p><br><p>  -      (    VPC CIDR      AWS),    <em></em> -.     ,     ,    ,     ,     . </p><br><h3 id="nedostatki-2">  disadvantages </h3><br><p>    , <strong>-   ,    .</strong>     : </p><br><p> <strong>  - Terraform    </strong> </p><br><p>   ¬´¬ª  ,  ,  ¬´ ¬ª,  . , ,  ,   - . </p><br><p> <strong>TDD  ,    </strong> </p><br><p>     ,   . ,   TDD, ,    .       ,           (      )    <em></em> . </p><br><p>   Terraform    ,          ,        Terraform .   ¬´  ¬ª       . </p><br><p> <strong>       </strong> </p><br><p>      DevOps   . ,    ,   Chef  Terraform,     .       - Terraform    . ,      Ruby. <a href="https://www.linkedin.com/pulse/getting-devops-carlos-nunez"> ,   , ,       </a> ,        . </p><br><h3 id="instrumenty-ili-ih-otsutstvie">  (  ) </h3><br><p> - Terraform    .      . </p><br><p> <a href="https://github.com/carlosonunez/infrastructure">   .</a> </p><br><p>        -.    .     Terraform-,    VPC, Kubernetes-    (     )   Route53.       <a href="http://blog.carlosnunez.me/"></a> , <a href="https://carlosnunez.me/"> </a>  ,    .     RSpec       (   ,      ,  ,  AWS-,  OpenStack-). </p><br><p>       <code>spec/spec_helper.rb</code> .     Terraform (   Jenkins   <em>Jenkinsfile</em>     S3     )             Terraform-.     ,  Terraform        .    ,         ,        Terraform,     . </p><br><p>   -  <em>tfplan</em>  ,   ,       .  ,    .    ,   <code>terraform show</code> ,  ,   ,   . .   .      ,       , ‚Äî  <a href="https://github.com/palantir/tfjson">tfjson</a>  Palantir,     Terraform  JSON. (    Terraform-   ,      .    Rakefile   ,    Terraform.) </p><br><p>         ,        (pull requests)! </p><br><p> <a href="https://github.com/eerkunt/terraform-compliance">Terraform-compliance</a> </p><br><p>      - Terraform-    <a href="https://www.linkedin.com/in/emreerkunt/">Emre Erkunt</a> .            <a href="https://medium.com/the-reading-room/behaviour-driven-development-a-better-agile-778d2d2a7ab5">business driven development</a> ,         -  AWS-. </p><br><p> <a href="https://github.com/bsnape/rspec-terraform">Rspec-terraform</a> </p><br><p>   AWS-   .   ,   ,        . </p><br><h2 id="v-zaklyuchenie-polnaya-cepochka-razvertyvaniya">  :    </h2><br><p>    -   ¬´  ¬ª       : </p><br><img src="https://habrastorage.org/web/730/62c/b6c/73062cb6c2024c96b5d34063ab5f7cfd.png"><br><p> <strong> 2.</strong>   . </p><br><p> -      .  Terraform-  ,    .      -     ,    ,    .          -  Git  SVN,  -      (pull request)   <em>master</em> . </p><br><p>   -   ,    serverspec  kitchen-terraform.         ,       CI-      ,       .      Terraform               ,     ,         . </p><br><p>            <em>master</em>  ¬´¬ª .   Terraform     CI-, ¬´¬ª ‚Äî       ,            .              DNS      ,          (  -)          ( ,    ¬´¬ª   ). </p><br><p>           ,                  . </p><br><p> : </p><br><ol><li> : <a href="https://www.contino.io/insights/top-3-terraform-testing-strategies-for-ultra-reliable-infrastructure-as-code">Top 3 Terraform Testing Strategies for Ultra-Reliable Infrastructure-as-Code</a> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/335678/">https://habr.com/ru/post/335678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335668/index.html">Visualization of latent semantic analysis results using Python tools</a></li>
<li><a href="../335670/index.html">The future of contact centers: omni-channel and customer experience</a></li>
<li><a href="../335672/index.html">The book "Theory and practice of programming languages. Textbook for universities. 2nd ed. Standard 3rd generation "</a></li>
<li><a href="../335674/index.html">Construction of wireless networks of all sizes based on TP-Link equipment</a></li>
<li><a href="../335676/index.html">Bug Bounty: Earn from the mistakes of others</a></li>
<li><a href="../335680/index.html">Debugging Xamarin projects from VirtualBox on the Android emulator</a></li>
<li><a href="../335684/index.html">PYCON RUSSIA 2017: video of all reports and presentations</a></li>
<li><a href="../335686/index.html">Add two-factor OTP authentication to SSH in 10 minutes</a></li>
<li><a href="../335688/index.html">Part 2. At first they steal, and when you win, they kill you</a></li>
<li><a href="../335690/index.html">Service out of the box: set up ServiceNow "in 60 seconds"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>