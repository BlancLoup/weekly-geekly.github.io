<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On anonymity in account-based blockchains</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have long been interested in the topic of anonymity in cryptocurrencies and try to follow the development of technologies in this area. In our arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On anonymity in account-based blockchains</h1><div class="post__text post__text-html js-mediator-article">  We have long been interested in the topic of anonymity in cryptocurrencies and try to follow the development of technologies in this area.  In our articles we have already analyzed in detail the principles of the operation of <a href="https://habr.com/ru/company/exante/blog/421913/">confidential transactions</a> in Monero, and also conducted a <a href="https://habr.com/ru/company/exante/blog/438346/">comparative review of the</a> technologies existing in this field.  However, all anonymous cryptocurrencies today are built on the data model proposed by Bitcoin - Unspent Transaction Output (hereinafter UTXO).  For account-based blockchains like Ethereum, existing solutions for implementing anonymity and confidentiality (for example, <a href="https://eprint.iacr.org/2017/881.pdf">Mobius</a> or <a href="https://www.aztecprotocol.com/">Aztec</a> ) attempted to replicate the UTXO model in smart contracts. <br><br>  In February 2019, a group of researchers from Stanford University and Visa Research <a name="habracut"></a>  released <a href="https://crypto.stanford.edu/~buenz/papers/zether.pdf">preprint</a> "Zether: Towards privacy in the world of smart contracts."  The authors for the first time proposed an approach to ensuring anonymity in account-based blockchains and presented two options for a smart contract: for confidential (hiding balances and transfer amounts) and anonymous (hiding the recipient and sender) transactions.  We find the proposed technology interesting and would like to share it with the device, as well as talk about why the anonymity problem in account-based blockchains is considered very complex and whether the authors managed to solve it fully. <br><br><h3>  About the device of these data models </h3><br>  In the UTXO model, the transaction consists of ‚Äúinputs‚Äù and ‚Äúoutputs‚Äù.  A direct counterpart to ‚Äúouts‚Äù is the bills in your wallet: each ‚Äúexit‚Äù has some kind of denomination.  When you pay with someone (form a transaction) you spend one or several "exits", at the same time they become the "inputs" of the transaction, and the blockchain marks them as spent.  In this case, the recipient of your payment (or you yourself, if you need a change) receives the newly generated ‚Äúexits‚Äù.  Schematically, this can be represented as: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/tj/ed/8o/tjed8olalcrirbjpupoms6bwejo.png" alt="image"><br><br>  Account-based blockchains are roughly like your bank account.  They operate only with the amount on your account and the amount of transfer.  When you transfer some amount from your account, you do not burn any ‚Äúexits‚Äù, the networks do not need to remember which coins are spent and which are not.  In the simplest case, verification of a transaction is reduced to verifying the sender's signature and the amount on his balance sheet: <br><br><img src="https://habrastorage.org/webt/kw/pg/zn/kwpgzn1wg1mmztznetqntcdfbca.png" alt="image"><br><br><h3>  Technology analysis </h3><br>  Next, we'll talk about how Zether hides the transaction amount, the recipient and the sender.  In the course of describing the principles of his work, we will note the differences in the confidential and anonymous version.  Since it is much easier to ensure confidentiality in account-based blockchains, some of the restrictions imposed by anonymization will be irrelevant for the confidential version of the technology. <br><br><h4>  Hiding balances and transfer amounts </h4><br>  To encrypt balances and transfer amounts, Zether uses an ElGamal encryption <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2585%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25AD%25D0%25BB%25D1%258C-%25D0%2593%25D0%25B0%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258F">scheme</a> .  It works as follows.  When Alice wants to send Bob the <i><b>b</b></i> coins to the address (his public key) <i><b>Y</b></i> , she chooses a random number <i><b>r</b></i> and encrypts the amount: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ky/t6/3x/kyt63xxqcoleppvesgfpoubyj8y.png" alt="image"></div><br>  where <i><b>C</b></i> is the encrypted amount, <i><b>D</b></i> is the auxiliary value needed to decrypt this amount, <i><b>G</b></i> is a fixed point on the elliptic curve, by multiplying the secret key by which the public key is obtained. <br><br>  When Bob receives these values, he simply adds them to his encrypted balance in the same way, and this scheme is convenient. <br><br>  Similarly, Alice subtracts the same values ‚Äã‚Äãfrom her balance, only using her public key as <i><b>Y.</b></i> <br><br><h4>  Hiding the addressee and sender </h4><br>  The mixing of ‚Äúexits‚Äù in UTXO appeared at the dawn of cryptocurrency and helps to hide the sender.  To do this, the sender himself, when making a transfer, enters random ‚Äúexits‚Äù in the blockchain and mixes them with his own.  Then he signs "exits" with a ring signature - a cryptographic mechanism, which allows convincing the verifier that the sender's coins are among the implicated "exits".  The coins themselves are, of course, not spent. <br><br>  However, to conceal the recipient, we will not be able to generate fake "exits."  Therefore, in UTXO, each ‚Äúexit‚Äù has its own unique address, and it is cryptographically connected with the recipient address of these coins.  At the moment there is no way to identify the connection between the unique address of the "exit" and the address of the recipient, without knowing his secret keys. <br><br>  In the account-based model, we cannot use one-time addresses (otherwise it will already be a ‚Äúexit‚Äù model).  Therefore, the recipient and the sender have to knead among other accounts in the blockchain.  At the same time, encrypted 0 coins are written off from the kneaded accounts (or 0 is added - in the case of mixing the recipient), without actually changing their real balance. <br><br>  Since both the sender and recipient always have a permanent address, here it becomes necessary to use the same groups for mixing to the same addresses.  It's easier to look at this with an example. <br><br>  Suppose Alice decided to make a contribution to Bob‚Äôs charitable foundation, but prefers that this translation remain anonymous for a casual observer.  Then, in order to disguise herself in the field of the sender, she enters more accounts of Adam and Adele.  And to hide Bob - in the field of the recipient in addition Ben and Bill accounts.  Making the next installment, Alice decided to type Alex and Amanda next to her, and Bruce and Bengen next to Bob.  In this case, when analyzing the blockchain, in these two transactions there will be only one intersecting pair of participants - Alice and Bob, which de-anonymizes these transactions. <br><br><img src="https://habrastorage.org/webt/dj/o6/x0/djo6x0r31q3_bzpa78t0cklzt_i.png" alt="image"><br><br><h4>  Transaction Racing </h4><br>  As we have already mentioned, in order to hide his balance in account-based systems, the user encrypts his balance and the amount of transfer.  However, he must prove that the balance on his account remains non-negative.  The problem is that by forming a transaction, the user builds a proof regarding his current account status.  And what will happen if Bob sends a transaction to Alice, and she will be accepted earlier than Alice sent?  Then Alice‚Äôs transaction will be considered invalid, since the proof of the balance was built before accepting the transaction by Bob. <br><br><img src="https://habrastorage.org/webt/bn/d0/7z/bnd07z43bu5m76fbbvjlvda7ek0.png" alt="image"><br><br>  The first decision that comes up in such a situation is to freeze the account before the transaction.  But this approach is not suitable, since in addition to the complexity of solving such a problem in a distributed system, it will not be clear in an anonymous scheme, whose account will be blocked. <br><br>  To solve this problem, the technology separates incoming and outgoing transactions: the expenditure of funds has an immediate effect on the state of balance, and receipts - deferred.  For this purpose, the concept of "epoch" is introduced - a group of blocks of fixed size.  The current "epoch" is determined by dividing the height of the block by the size of the group.  Processing the transaction, the network updates the balance of the sender immediately, and the recipient‚Äôs funds are put into the drive.  Accumulated funds are available to the payee only when a new ‚Äúera‚Äù arrives. <br><br>  As a result, the user can send transactions regardless of how often he receives funds (as far as his balance allows, of course).  The size of an epoch is determined based on how quickly the blocks propagate through the network and how quickly the transaction enters the block. <br><br>  This solution works well for confidential transfers, but with anonymous transactions, as we will see later, it creates serious problems. <br><br><h4>  Replay protection </h4><br>  In the account-based blockchains, each transaction is signed by the sender's private key, which convinces the verifier that the transaction has not been changed and created by the owner of this key.  But what if the attacker who listened to the transmission channel intercepts this message and sends the exact same second one?  The verifier will verify the signature of the transaction and will be convinced of its authorship, and the network will write off the same amount from the balance of the sender again. <br><br>  This attack is called a replay attack.  In the UTXO model, such attacks are not relevant, since the attacker will try to use the spent outputs, which in itself is not valid and is rejected by the network. <br><br>  To prevent this from happening, a field with random data, which is called nonce or simply "salt", is embedded in the transaction.  When resubmitting a transaction with a ‚Äúsalt‚Äù, the verifier checks whether the nonce has been used before and, if not, considers the transaction valid.  In order not to store the entire history of nonce-s in the blockchain, usually in the very first transaction it is taken equal to zero, and then increased by one.  The network only needs to check that the nonce of a new transaction differs from the previous one by one. <br><br>  In an anonymous translation scheme, the problem of validating transaction nonce arises.  We cannot bind nonce in an explicit way to the sender's address, since, obviously, this will de-anonymize the transfer.  We also cannot add one to the nonce of all participating accounts, since this may conflict with other transfers that are being processed. <br><br>  Zether authors propose to generate nonce cryptographically - depending on the "era".  For example: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5q/ku/zu/5qkuzus5hr-5168x4ieihiwtbjw.png" alt="image"></div><br>  Here, <b><i>x</i></b> is the sender's secret key, and <b><i>G <sub>epoch</sub></i></b> is an additional generator for the epoch, obtained by hashing a string like 'Zether +'.  Now the problem would seem to be solved - we do not reveal the nonce of the sender and do not interfere in the nonce of non-involved participants.  But this approach imposes a serious limitation: one account can send no more than one transaction per ‚Äúepoch‚Äù.  This problem, unfortunately, remains unresolved, and currently makes an anonymous version of Zether, in our opinion, hardly suitable for use. <br><br><h4>  The complexity of the evidence with zero disclosure </h4><br>  In UTXO, the sender must prove to the network that he does not spend a negative amount, otherwise it becomes possible to generate new coins from the air (why this is possible, we wrote in one of the previous <a href="https://habr.com/ru/company/exante/blog/421913/">articles</a> ).  And also to sign "entrances" with a ring signature to prove that among the kneaded coins there are funds belonging to him. <br><br>  In an anonymous version of the account-based blockchain, expressions for proof are much more complicated.  The sender proves that: <br><br><ol><li>  The amount sent is positive; </li><li>  The balance remains non-negative; </li><li>  The sender correctly encrypted the transfer amounts (including zero); </li><li>  The balance of the balance varies only with the sender and receiver; </li><li>  The sender owns the secret key of his account and he is indeed present in the list of senders (among those implicated); </li><li>  The nonce used in the transaction is correct. </li></ol><br>  For such a complex proof, the authors use a mixture of <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproof</a> (one of the authors, by the way, was involved in its creation) and the <a href="https://en.wikipedia.org/wiki/Proof_of_knowledge">Sigma protocol</a> , which is called Sigma-bullets.  Formal proof of such an assertion is a rather complicated task, and it severely limits the number of people who want to start implementing the technology. <br><br><h4>  What is the result? </h4><br>  In our opinion, the Zether part, which brings confidentiality to account-based blockchains, may well be used now.  But at the moment, an anonymous version of the technology imposes serious restrictions on its use, and its complexity - on implementation.  However, you shouldn‚Äôt discount the fact that the authors released it just a few months ago, and perhaps someone else will find a solution to the problems that exist today.  After all, this is how science is done. </div><p>Source: <a href="https://habr.com/ru/post/452184/">https://habr.com/ru/post/452184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452172/index.html">Complex systems. Critical level</a></li>
<li><a href="../452174/index.html">He does not give you a rook</a></li>
<li><a href="../452178/index.html">Parsing: 23 common mistakes in writing English and how to avoid them</a></li>
<li><a href="../452180/index.html">Raise the performance of SSD from the knees, where to click and why</a></li>
<li><a href="../452182/index.html">Employee survey. Main mistake</a></li>
<li><a href="../452186/index.html">The rarest and most expensive programming languages</a></li>
<li><a href="../452188/index.html">Unit Testing Json Serialization in Spring Boot</a></li>
<li><a href="../45219/index.html">Serial, however</a></li>
<li><a href="../452190/index.html">Using WebAssembly, we accelerated web application 20 times</a></li>
<li><a href="../452192/index.html">What is this here? The inner workings of JavaScript objects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>