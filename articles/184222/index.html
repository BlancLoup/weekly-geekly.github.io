<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elixir</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, today I will tell you about the modern programming language under BeamVM (or ErlangVM). 
 The first part is an incomplete introduction to the b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elixir</h1><div class="post__text post__text-html js-mediator-article">  Hello, today I will tell you about the modern programming language under BeamVM (or ErlangVM). <br>  The first part is an incomplete introduction to the basics, and the second part of the article shows with simple examples the main features of the language, which are new for the erlang developer. <br><br>  Two years ago, the 0.1 version of elixir was released, which was <a href="http://habrahabr.ru/post/115372/">presented to the</a> habrasoobschestvuyu earlier. <br><br>  Quote: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚ÄúErlang is a platform unique in its capabilities, and in spite of this, the language is still exotic.  There are several reasons.  For example, tight arithmetic, unusual syntax, functionality.  These are not flaws.  These are just things that most programmers don‚Äôt or don‚Äôt want to work with. ‚Äù <br><br>  At the moment, elixir has become the most popular programming language (of course, besides erlang-a), built on top of BeamVM.  To the point that the author of erlang Joe Armstrong devoted an article, and Dave Thomas wrote a book.  In two years, much has changed, the language has stabilized greatly and has found a more or less final version for version 1.0.  During this time, the object model disappeared from elixir, Ruby-like syntax remained, but metaprogramming and polymorphism were added, which organically, unlike the object-oriented paradigm, fit into the Beam VM. <br><br>  New in Elixir: <br><a name="habracut"></a><br><ul><li>  Ruby-like syntax (semantics not like in Ruby) </li><li>  Polymorphism using protocols </li><li>  Metaprogramming </li><li>  Standardized library </li><li>  "First class shell" </li><li>  And many more </li></ul><br>  At the same time, it is compiled as erlang beam;  elixir also allows you to call erlang modules without the need to convert data types, so there is no performance loss when calling erlang code. <br><br>  To try it out for yourself, you can download it from the githab: <br><br><pre><code class="hljs ruby">$ git clone <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/github.com/elixir</span></span>-lang/elixir.git $ cd elixir $ make test</code> </pre> <br><br>  Or install the <a href="http://elixir-lang.org/packages.html">precompiled version</a> . <br><br>  You can also install elixir for Fedora, Mac OS or Arch Linux owners via the package manager: <br><ul><li>  Homebrew for Mac OS X: <br><ol><li><pre> <code class="hljs ruby">$ brew tap homebrew/versions $ brew install erlang-r16</code> </pre></li><li>  If a previous version of erlang is installed, then you need to link a new version of erlang: <br><pre> <code class="hljs sql">$ brew <span class="hljs-keyword"><span class="hljs-keyword">uninstall</span></span> erlang $ brew <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> erlang-r16</code> </pre></li><li>  Installing elixir: <br><pre> <code class="hljs sql">$ brew <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> $ brew <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> elixir</code> </pre><br></li></ol><br></li><li>  Fedora 17+ and Fedora Rawhide: sudo yum -y install elixir </li><li>  Arch Linux: Elixir is available via AUR: yaourt -S elixir </li></ul><br><br>  There is an interactive iex console in elixir, where you can immediately try everything.  Unlike erlang, modules can be created in the elixir console, as will be shown below. <br><br>  Comment: <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta"># This is a commented </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span></span></code> </pre> <br><br>  Next, ‚Äú# =&gt;‚Äù shows the value of the expression: <br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># =&gt; 2</span></span></code> </pre> <br><br>  Console example: <br><br><pre> <code class="hljs sql">$ bin/iex defmodule Hello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Hello.world</code> </pre><br>  The data types in elixir are the same as in erlang: <br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span> # <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-number"><span class="hljs-number">0x1F</span></span> # <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> :atom # atom / symbol {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} # tuple [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] # list &lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&gt; # binary</code> </pre><br><br>  Strings in elixir, as in erlang-e, can be represented through lists or through binary: <br><br><pre> <code class="hljs ruby"><span class="hljs-string"><span class="hljs-string">'I am a list'</span></span> <span class="hljs-string"><span class="hljs-string">"I am a binary or a string"</span></span> name = <span class="hljs-string"><span class="hljs-string">"World"</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{name}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; string interpolation</span></span></code> </pre><br>  Unlike erlang, elixir uses binary everywhere, as the standard implementation of strings because of their speed and compactness in front of lists of letters. <br><br>  And there are also multi-line strings: <br><pre> <code class="hljs python"><span class="hljs-string"><span class="hljs-string">""" This is a binary spawning several lines. """</span></span></code> </pre><br><br>  The function call, we have already seen above for the module, but it is possible and so, omitting the brackets: <br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">div</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  A good programming style for elixir recommends that if you omit parentheses, then when using macro. <br>  Coding Style in the standard library says that brackets should be used to call functions. <br><br>  The variables in elixir are still immutable, but you can do reassigment: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">x</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  You can change variables only between expressions, and within the same expression it will still match.  At the same time, all pattern matching from erlang has been preserved and it is possible with the help of ^ to make them unchanged as in erlang: <br><pre> <code class="hljs pgsql">{x, x} = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>} # =&gt; ** (MatchError) <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> right hand side <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>} {a, b, [c | _]} = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,["a", "b", "c"]} # =&gt; a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> c = "a" a = <span class="hljs-number"><span class="hljs-number">1</span></span> # =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span> # =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ^a = <span class="hljs-number"><span class="hljs-number">3</span></span> # =&gt; ** (MatchError) <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> right hand side <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br>  You can learn more about the syntax, features and features of elixir here: <br>  <a href="http://elixir-lang.org/getting_started/1.html">Official tutorial</a> <br>  <a href="http://elixir-lang.org/crash-course.html">Crash Course for erlang developers</a> <br>  <a href="http://joearms.github.io/2013/05/31/a-week-with-elixir.html">Week with elixir.</a>  <a href="http://joearms.github.io/2013/05/31/a-week-with-elixir.html">Joe Armstrong article on elixir</a> <br>  <a href="http://pragprog.com/book/elixir/programming-elixir">The book Programming Elixir by Dave Thomas, there are two video tutorials and some excerpts from the book</a> <br>  <a href="http://elixir-lang.org/docs/">Official documentation</a> <br><br>  After I started programming on elixir myself, look at the erlang code, which is often created through copy-paste with a change in one value (and there is such a need in almost every project that I have encountered) or constant repetitions of a certain pattern, which increase the code, I just want to rewrite them correctly on elixir. <br><br>  And now I would like to show on simple examples of innovations for the erlang developer, namely, metaprogramming, polymorphism, and also syntactic sugar, which greatly simplify the code. <br><br>  Let's start with metaprogramming.  In elixir, everything is an expression, at least as far as possible (‚ÄúEverything is an expression‚Äù). <br>  First example, we take the most common module with a single function, like our experiment. <br><pre> <code class="hljs sql">defmodule Hello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Let's save it to the file and compile it like this: <br><br><pre> <code class="hljs ruby">$ elixirc hello.ex</code> </pre><br>  Or we copy in the console, and our module is compiled there.  In any case, carefully look at what happens at the time of compilation.  At the moment, nothing special. <br><br>  Let's change our example a bit: <br><pre> <code class="hljs sql">defmodule Hello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello Compiler"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Now, at compile time, we can see ‚ÄúHello compiler‚Äù. <br><br>  Now we will try to change something in our module, depending on the compilation: <br><pre> <code class="hljs sql">defmodule Hello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> System.get_env(<span class="hljs-string"><span class="hljs-string">"MY_ENV"</span></span>) == <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello World with my Variable = 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Now, if we compile the code, then depending on how we compile it, we can see: <br><pre> <code class="hljs ruby">$ elixirc hello.ex $ iex iex&gt; Hello.world <span class="hljs-comment"><span class="hljs-comment"># =&gt; "Hello World"</span></span></code> </pre><br><br>  Or, if we compile our module like this, we will get another action of our function: <br><pre> <code class="hljs ruby">$ MY_ENV=<span class="hljs-number"><span class="hljs-number">1</span></span> elixirc hello.ex $ iex iex&gt; Hello.world <span class="hljs-comment"><span class="hljs-comment"># =&gt; "Hello World with my Variable = 1"</span></span></code> </pre><br><br>  And now, let's try to do something more interesting, for example, generate code. <br>  In erlang code you can often come across such or similar code: <br><pre> <code class="hljs erlang-repl">my_function(bad_type) -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; my_function(bad_stat) -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ....... my_function(<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; bad_type; my_function(<span class="hljs-number"><span class="hljs-number">2</span></span>) -&gt; bad_stat; .....</code> </pre><br><br>  For example, we want to get a function that we will use as follows: <br><pre> <code class="hljs ruby">Hello.mapper(<span class="hljs-symbol"><span class="hljs-symbol">:bad_type</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1 Hello.mapper(:bad_stat) # =&gt; 2 Hello.mapper(1) # =&gt; :bad_type .....</span></span></code> </pre><br><br>  In elixir, we can get the same speed of the function, without repeating, if we generate the same functions at compile time: <br><pre> <code class="hljs ruby">list = [{<span class="hljs-symbol"><span class="hljs-symbol">:bad_type</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:bad_stat</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}] lc {type, num} inlist list <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unquote(type)</span></span></span></span>), <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> unquote(num) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unquote(num)</span></span></span></span>), <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> unquote(type) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre><br><br>  lc inlist do is a list compression in the elixir language, an example of use: <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">lc</span></span> a inlist [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: a * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; [2,4,6]</span></span></code> </pre><br><br>  Now with the help of list compression, we have generated two functions (or, more precisely, a match for a function). <br><br>  An example is taken from the real code: <br>  <a href="">one way</a> and <a href="">the other way</a> <br>  <a href="https://gist.github.com/liveforeverx/5697501">And in this and the other direction, on elixir</a> <br><br>  In elixir itself, you can also see, for example, here: <br>  <a href="">github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/string.ex#L478-L486</a> <br><br>  Macro in elixir-e act like in clojure (lisp programmers will feel at home), you can see its AST in any code: <br><pre> <code class="hljs kotlin">quote <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span> # =&gt; {:+,[context: Elixir, <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>: Kernel],[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]} quote <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>} # =&gt; {:<span class="hljs-string"><span class="hljs-string">"{}"</span></span>,[],[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]} quote <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) # =&gt; {:sum,[],[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]} quote <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) # =&gt; {:sum,[],[<span class="hljs-number"><span class="hljs-number">1</span></span>,{:+,[context: Elixir, <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>: Kernel],[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]},<span class="hljs-number"><span class="hljs-number">4</span></span>]}</code> </pre><br>  As you can see from the examples, AST consists of tuples with three elements: {name, meta, arguments} <br>  Now, let's try to write our first macro: <br><pre> <code class="hljs sql">defmodule MyMacro <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> defmacro unless(clause, options) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> quote <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!unquote(clause), unquote(options)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Now use our macro: <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> MyMacro MyMacro.unless <span class="hljs-number"><span class="hljs-number">2</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><br>  The following example will show how you can use this knowledge, for example for optimization. <br>  If we use somewhere regular expressions, it looks like this: <br><pre> <code class="hljs ruby">defmodule TestRegex <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myregex_test</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">re</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abc"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"([az]+)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, [{</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:capture</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:all_but_first</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:list</span></span></span></span><span class="hljs-function"><span class="hljs-params">}])</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  And now, using our knowledge above, we can take out the compilation of a regular expression, thereby making our runtime code faster: <br><pre> <code class="hljs ruby">defmodule TestRegexOptimized <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, regex} = <span class="hljs-symbol"><span class="hljs-symbol">:re</span></span>.compile(<span class="hljs-string"><span class="hljs-string">"([az]+)"</span></span>) escaped_regex = Macro.escape(regex) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myregex_test</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">re</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abc"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, unquote(escaped_regex)</span></span></span></span>, [{<span class="hljs-symbol"><span class="hljs-symbol">:capture</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:all_but_first</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:list</span></span>}]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  In this example, we have compiled a regular expression outside the function.  Using Macro.escape (there are many other useful functions in the Macro module) we inserted into our function the already compiled regular expression, having the readable version still in the code.  Actually, in the elixir with regular expressions, you do not need to do this, since the% r macro does this for you, depending on if you can compile the regular expression right away. <br><br>  Thus, we can compare the speed of our function: <br><pre> <code class="hljs ruby">Enum.map(<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">1000</span></span>, fn(<span class="hljs-number"><span class="hljs-number">_</span></span>) -&gt; elem(<span class="hljs-symbol"><span class="hljs-symbol">:timer</span></span>.tc(TestRegex, <span class="hljs-symbol"><span class="hljs-symbol">:myregex_test</span></span>, []), <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-params"><span class="hljs-params">|&gt; List.foldl(0, &amp;1 + &amp;2) # =&gt; 4613 Enum.map(1..1000, fn(_) -&gt; elem(:timer.tc(TestRegexOptimized, :myregex_test, []), 0) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span><span class="hljs-params">) |</span></span>&gt; List.foldl(<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;<span class="hljs-number"><span class="hljs-number">1</span></span> + &amp;<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; 3199</span></span></code> </pre><br><br>  Polymorphism: <br><pre> <code class="hljs ruby">list = [{<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:b</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:c</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:d</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:e</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:f</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:g</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:h</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:k</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}] Enum.map(list, fn({a, x}) -&gt; {a, x * <span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) dict = HashDict.New(list) Enum.map(dict, fn({a, x}) -&gt; {a, x * <span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) file = File.iterator!(<span class="hljs-string"><span class="hljs-string">"README.md"</span></span>) lines = Enum.map(file, fn(line) -&gt; Regex.replace(%r/<span class="hljs-string"><span class="hljs-string">"/, line, "</span></span><span class="hljs-string"><span class="hljs-string">'") end) File.write("README.md", lines)</span></span></code> </pre><br>  The example shows that we can use the Enum library on any data type that implements the Enumerable protocol. <br><br>  The implementation for the protocol can be located anywhere, regardless of the protocol itself: the main thing is that the compiled code is located where BeamVM can find it (that is, in: source.get_path).  Those.  for example, you can extend existing libraries without changing their code for your data types. <br><br>  Another interesting built-in protocol is the access protocol ‚Äî take the symbol-value list as an example of the top list: <br><pre> <code class="hljs ruby">list = [{<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:b</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:c</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:d</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:e</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:f</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:g</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:h</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, {<span class="hljs-symbol"><span class="hljs-symbol">:k</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}] list[<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span>] <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1</span></span></code> </pre><br><br>  We will make a very simple example with a binary tree that will be in the record (record) Tree and for our tree we will also implement the Access protocol. <br><pre> <code class="hljs sql">defmodule TreeM <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> has_value(nil, val), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: nil <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> has_value({{<span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, val}, _, _}, <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: val <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> has_value({_, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> has_value(<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>) || has_value(<span class="hljs-keyword"><span class="hljs-keyword">right</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defrecord Tree, first_node: nil defimpl <span class="hljs-keyword"><span class="hljs-keyword">Access</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: Tree <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>(tree, <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: TreeM.has_value(tree.first_node, <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Now, in the same way, we can find our values ‚Äã‚Äãthrough Access Protocol <br><pre> <code class="hljs ruby">tree = Tree.new(<span class="hljs-symbol"><span class="hljs-symbol">first_node:</span></span> {{<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {{<span class="hljs-symbol"><span class="hljs-symbol">:b</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>}, {{<span class="hljs-symbol"><span class="hljs-symbol">:c</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>}}) tree[<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span>] <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1</span></span></code> </pre><br>  Protocols give polymorphism. <br><br>  And now, a little bit of syntax sugar, which makes writing and reading code easier in certain situations. <br>  [{: a, 1}] can be written like this: [a: 1] <br><br>  In the same way, it is often necessary to write such constructions as: <br>  func3 (func2 (func1 (list))), despite the fact that the function call func1 occurs first, we write func3 first or we must enter variables, as in this case: <br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">file</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">File</span></span>.iterator!(<span class="hljs-string"><span class="hljs-string">"README.md"</span></span>) lines = Enum.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>, fn(<span class="hljs-literal"><span class="hljs-literal">line</span></span>) -&gt; Regex.replace(%r/<span class="hljs-string"><span class="hljs-string">"/, line, "</span></span>'<span class="hljs-string"><span class="hljs-string">") end) File.write("</span></span>README.md<span class="hljs-string"><span class="hljs-string">", lines)</span></span></code> </pre><br><br>  With the help of the pipeline operator (|&gt;) we can rewrite our example like this: <br><pre> <code class="hljs vhdl">lines = <span class="hljs-keyword"><span class="hljs-keyword">File</span></span>.iterator!(<span class="hljs-string"><span class="hljs-string">"README.md"</span></span>) |&gt; Enum.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(fn(<span class="hljs-literal"><span class="hljs-literal">line</span></span>) -&gt; Regex.replace(%r/<span class="hljs-string"><span class="hljs-string">"/, line, "</span></span>'<span class="hljs-string"><span class="hljs-string">") end) File.write("</span></span>README.md<span class="hljs-string"><span class="hljs-string">", lines)</span></span></code> </pre><br>  In the elixir library, the standardized subject goes with the first argument.  And this makes it possible with the help of the |&gt; operator, which substitutes the result of the previous action as the first argument of the function in the next call, to write more understandable, compact and consistent code. <br><br>  Also, we can simplify this example using curry or partials in simple cases: <br><pre> <code class="hljs vhdl">lines = <span class="hljs-keyword"><span class="hljs-keyword">File</span></span>.iterator!(<span class="hljs-string"><span class="hljs-string">"README.md"</span></span>) |&gt; Enum.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>( Regex.replace(%r/<span class="hljs-string"><span class="hljs-string">"/, &amp;1, "</span></span>'<span class="hljs-string"><span class="hljs-string">") ) File.write("</span></span>README.md<span class="hljs-string"><span class="hljs-string">", lines)</span></span></code> </pre><br><br>  I think Elixir will be interesting to erlang-developers who want to improve the quality of their code, productivity, and try out metaprogramming in action.  Similarly, developers from other languages ‚Äã‚Äãand platforms will also show interest in it.  For example, those who would like to try out BeamVM, but did not dare because of the erlang syntax or welter in its libraries.  Here an important advantage of elixir is the standardized and compact standard library (Standard Library). </div><p>Source: <a href="https://habr.com/ru/post/184222/">https://habr.com/ru/post/184222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184210/index.html">Yaxy - proxy server for web developer</a></li>
<li><a href="../184212/index.html">Channel 1 explained why the law on blocking sites is being introduced</a></li>
<li><a href="../184214/index.html">What do people actually do on the Internet?</a></li>
<li><a href="../184218/index.html">How to shoot a year-long TimeLapse video on an Android phone</a></li>
<li><a href="../184220/index.html">PHP 5.5 "Password Hashing API"</a></li>
<li><a href="../184224/index.html">vk.com - Saving audio recordings, documents, the contents of the wall</a></li>
<li><a href="../184228/index.html">VoIP telephony - how to estimate the real cost of a solution</a></li>
<li><a href="../184232/index.html">Feathers - Starling-based UI framework for mobile and desktop applications</a></li>
<li><a href="../184236/index.html">US Federal Aviation Agency (FAA) will revise the ban on the use of gadgets in aircraft</a></li>
<li><a href="../184238/index.html">Once again about the movie, or together with the water and throw out the child</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>