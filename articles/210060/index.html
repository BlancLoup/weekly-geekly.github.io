<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Treating tree structures and unified AST</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous article in the series was devoted to the theory of source parsing using ANTLR and Roslyn. It noted that the process of signature-based co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Treating tree structures and unified AST</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://habrahabr.ru/company/pt/blog/210772/">The previous article in the series</a> was devoted to the theory of source parsing using ANTLR and Roslyn.  It noted that the process of signature-based code analysis in our <a href="http://www.ptsecurity.ru/appsecurity/application-inspector/">PT Application Inspector</a> project is divided into the following steps: </p><br><ol><li>  parsing into a language dependent view (abstract syntax tree, AST); </li><li>  AST to language independent unified format (AST, UAST); </li><li>  direct comparison with the templates described on DSL. </li></ol><br><p>  This article is devoted to the second stage, namely: processing the AST using Visitor and Listener strategies, transforming the AST into a unified format, simplifying the AST, and also the algorithm of matching tree structures. <br></p><br><p> <a href="https://habrahabr.ru/company/pt/blog/210060/"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/031/d2d/4ca/031d2d4cab81a98a67c1962ee1d75f41.png"></a> </p><br><h2 id="soderzhanie">  Content </h2><br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">AST bypass</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Visitor and Listener</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Differences in Visitor at ANTLR and Roslyn</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Grammar and Visitor in ANTLR</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Alternative and elemental labels in ANTLR</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Types of Unified AST Nodes</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Converter testing</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Simplify uast</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Algorithm comparison of tree structures</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210060/">Conclusion</a> <a name="habracut"></a></li></ul><br><a name="ast-traverse"></a><br><h2 id="obhod-ast">  AST bypass </h2><br><p>  As you know, the parser converts the source code into a parse tree (into a tree in which all insignificant tokens are removed), called AST.  There are various ways to process such a tree.  The simplest is to process the tree using a recursive walk of the descendants in depth.  However, this method is applicable only for very simple cases, in which there are few types of nodes and the processing logic is simple.  In other cases, it is necessary to bring the processing logic of each type of node into separate methods.  This is done using two typical approaches (design patterns): Visitor and Listener. </p><br><a name="visitor-vs-listener"></a><br><h3 id="visitor-i-listener">  Visitor and Listener </h3><br><p>  In the Visitor, to handle the descendants of a node, you must manually call their crawl methods.  Moreover, if the parent has three children, and only methods for two nodes are called, then part of the subtree will not be processed at all.  In the Listener (Walker), the same methods of visiting all descendants are called automatically.  In the Listener, there is a method called at the beginning of a site visit (enterNode) and a method called after a site visit (exitNode).  These methods can also be implemented using an event mechanism.  Visitor methods, unlike Listener, can return objects and can even be typed, i.e.  when declaring CSharpSyntaxVisitor, each Visit method will return an AstNode object, which in our case is a common ancestor for all other nodes of the unified AST. <br><br></p><p>  Thus, when using the Visitor design pattern, the tree transformation code is more functional and concise due to the fact that it does not need to store information about visited nodes.  In the figure below you can see that, for example, when converting the PHP language, unnecessary HTML and CSS nodes are cut off.  The traversal order is indicated by numbers.  Listener is usually used for data aggregation (for example, from files of type CSV), conversion of one code to another (JSON -&gt; XML).  Read more about this in <a href="http://www.amazon.com/Definitive-ANTLR-4-Reference/dp/1934356999">The Definitive ANTLR 4 Reference</a> . <br></p><br><div style="text-align:center;"><img alt="Visitor &amp; Listener" src="https://habrastorage.org/files/bd1/69c/535/bd169c535e854f9681520f520d0db9c3.png"></div><br><a name="visitor-in-antlr-and-roslyn"></a><br><h3 id="razlichiya-v-visitor-v-antlr-i-roslyn">  Differences in Visitor at ANTLR and Roslyn. </h3><br><p>  The implementation of Visitor and Listener may vary in libraries.  For example, the table below describes the classes and methods of the Visitor and Listener in Roslyn and ANTLR. </p><br><table><thead><tr><th></th><th>  ANTLR </th><th>  Roslyn </th></tr></thead><tbody><tr><td>  Visitor </td><td>  AbstractParseTreeVisitor &lt;Result&gt; </td><td>  CSharpSyntaxVisitor &lt;Result&gt; </td></tr><tr><td>  Listener </td><td>  IParseTreeListener </td><td>  CSharpSyntaxWalker </td></tr><tr><td>  Default </td><td>  DefaultResult </td><td>  DefaultVisit (SyntaxNode node) </td></tr><tr><td>  Visit </td><td>  Visit (IParseTree tree) </td><td>  Visit (SyntaxNode node) </td></tr></tbody></table><br><p>  Both ANTLR and Roslyn have methods for returning the default result (if the Visitor method is not overridden for some syntax), as well as the generic Visit method, which itself determines which Visitor special method should be called. <br></p><br><p>  An ANTLR visitor generates its own Visitor for each syntax grammar rule.  There are also special types of methods: </p><br><ul><li> <code>VisitChild(IRuleNode node)</code> ;  used to implement a default site bypass. </li><li>  <code>VisitTerminal(IRuleNode node)</code> ;  used when traversing terminal nodes, i.e.  tokens. </li><li>  <code>VisitErrorNode(IErrorNode node)</code> ;  used when traversing tokens resulting from parsing code with lexical or syntactical errors.  For example, if the statement is missing a semicolon at the end, then the parser inserts such a token and indicates that it is erroneous.  More details about parsing errors are written <a href="https://habrahabr.ru/company/pt/blog/210772/">in the previous article</a> . </li><li>  <code>AggregateResult(AstNode aggregate, AstNode nextResult)</code> ;  A rarely used method designed to aggregate the results of the crawling of descendants </li><li>  <code>ShouldVisitNextChild(IRuleNode node, AstNode currentResult)</code> ;  A rarely used method designed to determine whether the next child of a <code>node</code> should be processed depending on the result of the <code>currentNode</code> . </li></ul><br><p>  Roslyn visitor has special methods for each syntactic construction and a generalized Visit method for all nodes.  However, there are no methods for bypassing "intermediate" constructs in it, unlike ANTLR.  For example, in Roslyn, there is no method for <code>VisitStatement</code> assertions, but there are special <code>VisitDoStatement</code> , <code>VisitExpressionStatement</code> , <code>VisitForStatement</code> , etc.  As <code>VisitStatement</code> it is possible to use the generalized <code>Visit</code> .  Another difference is that bypassing trivial (SyntaxTrivia) nodes, i.e.  Nodes that can be deleted without losing any information about the code (spaces, comments) are called along with methods of traversing basic nodes and tokens. <br></p><br><p>  The disadvantage of ANTLR visitors is that the names of the generated Visitor methods are directly dependent on the style of writing grammar rules, so they may not fit into the overall style of the code.  For example, in sql grammars it is customary to use the so-called <em>Snake case</em> , in which underscores are used to separate words.  Roslyn methods are written in the style of the C # code.  Despite the differences, the processing methods of tree structures in Roslyn and ANTLR with new versions are more and more unified, which is good news (in ANTLR version 3 and below, there was no Visitor and Listener mechanism). </p><br><a name="grammar-and-visitor-antlr"></a><br><h3 id="grammatika-i-visitor-v-antlr">  Grammar and Visitor in ANTLR. </h3><br><p>  In ANTLR for the rule </p><br><pre> <code class="hljs pgsql">ifStatement : <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> parenthesis <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> elseIfStatement* elseStatement? | <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> parenthesis <span class="hljs-string"><span class="hljs-string">':'</span></span> innerStatementList elseIfColonStatement* elseColonStatement? EndIf <span class="hljs-string"><span class="hljs-string">';'</span></span> ;</code> </pre> <br><p>  the <code>VisitIfStatement(PHPParser.IfStatementContext context)</code> method <code>VisitIfStatement(PHPParser.IfStatementContext context)</code> will be formed in which the context will have the following fields: </p><br><ul><li>  <code>parenthesis</code> is a single node; </li><li>  <code>elseIfStatement*</code> - array of nodes.  If there is no syntax, then the length of the array is zero; </li><li> <code>elseStatement?</code>  - optional node.  If there is no syntax, it is null; </li><li>  <code>If</code> , <code>EndIf</code> - terminal nodes, begin with a capital letter; </li><li>  <code>':'</code> , <code>';'</code>  - terminal nodes are not contained in context (available only through GetChild ()). </li></ul><br><p>  It should be noted that the fewer rules exist in grammar, the easier and faster Visitor is to write.  However, the duplicate syntax also needs to be put into separate rules. </p><br><a name="antlr-labels"></a><br><h3 id="alternativnye-i-elementnye-metki-v-antlr">  Alternative and elemental labels in ANTLR </h3><br><p>  Often there are situations in which a rule has several alternatives and it would be more logical to handle these alternatives in separate methods.  Fortunately, in ANTLR 4 for this, there are special <em>alternative</em> labels that begin with the <code>#</code> character and are added after each alternative rule.  When generating the parser code, a separate Visitor method is generated for each label, which allows to avoid a large amount of code if the rule has many alternatives.  It should be noted that either all alternatives or none should be marked.  You can also use a rule element label to denote a terminal that takes a set of values: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> : op=(<span class="hljs-string"><span class="hljs-string">'+'</span></span>|<span class="hljs-string"><span class="hljs-string">'-'</span></span>|<span class="hljs-string"><span class="hljs-string">'++'</span></span>|<span class="hljs-string"><span class="hljs-string">'--'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> #UnaryOperatorExpression | <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> op=(<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-string"><span class="hljs-string">'/'</span></span>|<span class="hljs-string"><span class="hljs-string">'%'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> #MultiplyExpression | <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> op=(<span class="hljs-string"><span class="hljs-string">'+'</span></span>|<span class="hljs-string"><span class="hljs-string">'-'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> #AdditionExpression | <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> op=<span class="hljs-string"><span class="hljs-string">'&amp;&amp;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> #LogicalAndExpression | <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> op=<span class="hljs-string"><span class="hljs-string">'?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> op2=<span class="hljs-string"><span class="hljs-string">':'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> #TernaryOperatorExpression ;</code> </pre> <br><p>  For this rule, ANTLR will be generated by <code>VisitExpression</code> , <code>VisitUnaryOperatorExpression</code> , <code>VisitMultiplyExpression</code> and so on. Each visitor will have an expression array consisting of 1 or 2 elements, as well as the literal op.  Thanks to the tags, the visitor code will be more clean and concise: </p><br><div class="spoiler">  <b class="spoiler_title">Code when using alternative and element labels</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> AstNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitUnaryOperatorExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TestParser.UnaryOperatorExpressionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> op = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyUnaryOperator(context.op().GetText()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyUnaryExpression(op, expr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> AstNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitMultiplyExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TestParser.MultiplyExpressionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> left = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> op = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyBinaryOpeartor(context.op().GetText()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> right = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyBinaryExpression(left, op, right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> AstNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitTernaryOperatorExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TestParser.TernaryOperatorExpressionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> third = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyTernaryExpression(first, second, third); } ...</code> </pre> </div></div><br><p>  Without alternative labels, Expression processing would be in the same method and the code would look like this: </p><br><div class="spoiler">  <b class="spoiler_title">Code without using alternative and element labels</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript">public override AstNode VisitExpression(TestParser.ExpressionContext context) { Expression expr, expr2, expr3; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.ChildCount == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Unary { var op = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyUnaryOperator(context.GetChild&lt;ITerminalNode&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetText()); expr = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyUnaryExpression(op, expr); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.ChildCount == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Binary { expr = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); var binaryOp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyBinaryOpeartor(context.GetChild&lt;ITerminalNode&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetText()); expr2 = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyBinaryExpression(expr, binaryOp, expr2); ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Ternary { var first = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); var second = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">1</span></span>)); var third = (Expression)VisitExpression(context.expression(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyTernaryExpression(first, second, third); } }</code> </pre> </div></div><br><p>  It should be noted that alternative labels exist not only in ANTLR, but also other means for describing grammars.  For example, in <a href="https://github.com/JetBrains/Nitra">Nitra, a</a> label with an assignment sign is placed to the left of the alternative, unlike ANTLR: </p><br><pre> <code class="hljs 1c">syntax Expression { <span class="hljs-string"><span class="hljs-string">| IntegerLiteral | BooleanLiteral | NullLiteral = "</span></span><span class="hljs-literal"><span class="hljs-literal">null</span></span><span class="hljs-string"><span class="hljs-string">"; | Parenthesized = "</span></span>(<span class="hljs-string"><span class="hljs-string">" Expression "</span></span>)<span class="hljs-string"><span class="hljs-string">"; | Cast1 = "</span></span>(<span class="hljs-string"><span class="hljs-string">" !Expression AnyType "</span></span>)<span class="hljs-string"><span class="hljs-string">" Expression; | ThisAccess = "</span></span>this<span class="hljs-string"><span class="hljs-string">"; | BaseAccessMember = "</span></span>base<span class="hljs-string"><span class="hljs-string">" "</span></span>.<span class="hljs-string"><span class="hljs-string">" QualifiedName; | RegularStringLiteral;</span></span></code> </pre> <br><a name="unified-ast-types"></a><br><h3 id="tipy-uzlov-unificirovannogo-ast">  Types of Unified AST Nodes </h3><br><p>  When developing the structure of the unified AST, we were guided by the structure of the AST from the <a href="https://github.com/icsharpcode/NRefactory">NRefactory</a> project in view of the fact that it is quite simple for us, and obtaining a reliable tree (fidelity reversible to the source code with an accuracy of a character) was not required.  Any node is an inheritor of AstNode and has its own NodeType type, which is also used at the template matching stage and when deserializing from JSON.  The structure of the nodes looked like this: </p><br><div style="text-align:center;"><img alt="UAST Types" src="https://habrastorage.org/files/13d/b83/ad5/13db83ad52fa491fbc89b8e0655912c3.png"></div><br><p>  In addition to the type, each node has a property that stores the location in the code (TextSpan), which is used to display it in the source code when matching with the template.  A non-terminal node stores a list of child nodes, and a terminal node holds a numeric, string, or other primitive value. <br></p><br><p>  In order to map the AST nodes of different languages, a table was compiled, in which the lines were the syntax of certain nodes, and the columns were their implementation in C #, Java, PHP, which looked like this: </p><br><table><thead><tr><th>  Node </th><th>  Args </th><th>  C # </th><th>  Java </th><th>  Php </th><th>  MCA </th><th>  MDA </th></tr></thead><tbody><tr><td>  While </td><td>  cond: Expression;  stmt: Statement </td><td>  while (cond) stmt </td><td>  while (cond) stmt </td><td>  while (cond) stmt </td><td>  While (cond, stmt) </td><td>  While (cond, stmt) </td></tr><tr><td>  Binary op </td><td>  l, r: Expression;  op: Literal </td><td>  l op r </td><td>  l op r </td><td>  l op r </td><td>  BinaryOp (l, op, r) </td><td>  BinaryOp (l, op, r) </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  Checked </td><td>  checked: Expression </td><td>  checked (checked) </td><td>  - </td><td>  - </td><td>  checked </td><td>  Checked (checked) </td></tr><tr><td>  NullConditional </td><td>  a: Expression, b: Literal </td><td>  a? .b </td><td>  - </td><td>  - </td><td>  a! = null?  ab: null </td><td>  a? .b </td></tr></tbody></table><br><p>  In this table: </p><br><ul><li>  <strong>Expression</strong> ;  expression, has a return value. </li><li>  <strong>Statement</strong> ;  The statement (instruction) has no return value. </li><li>  <strong>Literal</strong> ;  terminal node. </li><li>  <strong>Most Common Ast</strong> (MCA) is the most unified AST.  This node is constructed if all three languages ‚Äã‚Äãcontain the type of such or similar node (for example, IfStatement, AssignmentExpression); </li><li>  <strong>Most Detail Ast</strong> (MDA) most detailed AST.  This node is built if at least one language contains this type of node (for example, FixedStatenemt <code>fixed (a) { }</code> for C #).  These nodes are more relevant to SQL-like languages, due to the fact that the last declarative languages ‚Äã‚Äãand between T-SQL and C # the difference is much greater than, for example, between PHP and C #. </li></ul><br><p>  In addition to the nodes shown in the figure (and the ‚Äúpattern nodes‚Äù, which are described in the next section), there are also artificial nodes in order to still build the Most Common Ast node, ‚Äúlosing‚Äù as little syntax as possible.  These nodes are: </p><br><ul><li>  MultichildExpression;  inherited from Expression and contains a collection of other Expression; </li><li>  WrapperExpression;  inherited from Expression and contains a node with an arbitrary type AstNode; </li><li>  WrapperStatement;  inherited from Statement and contains a node with an arbitrary type AstNode. </li></ul><br><p>  In imperative languages, programming the basic constructs is the expression <strong>Expression</strong> and the statement <strong>Statement</strong> .  The former have a return value, the latter are used to perform any operations.  Therefore, in our module, we also focused mainly on them.  They are the basic building blocks for the implementation of <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25B0_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">CFG</a> and other source code representations necessary for the implementation of taint analysis in the future.  It is worth adding that knowledge of syntactic sugar, generics, and other language-specific things is not required to search for vulnerabilities in code.  Therefore, syntactic sugar can be disclosed in standard constructions, and information about specific things can be deleted altogether. <br></p><br><p>  Pattern nodes are artificial nodes representing custom patterns.  For example, ranges of numbers, regular expressions are used as literal patterns. </p><br><a name="converters-testing"></a><br><h3 id="testirovanie-konverterov">  Converter testing </h3><br><p>  For the code analyzer, the priority is to test the entire code, and not its individual parts.  To solve this problem, it was decided to redefine visiting methods for all types of nodes.  In this case, if the visitor is not used, then it generates an exception <code>new ShouldNotBeVisitedException(context)</code> .  This approach simplifies development because IntelliSense takes into account which methods are redefined and which are not, therefore it is easy to determine which methods visitors have already implemented. </p><br><p>  We also have some thoughts on how to improve testing of the coverage of the entire code.  Each node of the unified AST stores the coordinates of the corresponding source code.  Moreover, all terminals are connected with lexemes, i.e.  certain sequences of characters.  Since all lexemes should be processed as far as possible, the total coverage ratio can be expressed by the following formula, in which <code>uterms</code> are unified AST terminals and <code>terms</code> are ordinary Roslyn or ANTLR AST terminals: <br></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b4/c8c/be6/2b4c8cbe62735dc46011c49d4f9b631f.png" alt="cover factor"><br></p><br><p>  This metric expresses code coverage with a single coefficient, which should tend to unity.  Of course, the estimate for this coefficient is approximate, but it can be used for refactoring and improving the visitor code.  For a more reliable analysis, you can also use a graphical representation of the covered terminals. </p><br><a name="ast-simplify"></a><br><h2 id="uproschenie-ast">  Simplify AST </h2><br><p>  After converting a regular AST to UAST, the latter needs to be simplified.  The simplest and most useful optimization is constant folding.  For example, there is a lack of code associated with setting too long a cookie lifetime: <code>cookie.setMaxAge(2147483647);</code>  The argument in parentheses can be written as one number, for example <code>86400</code> , and some arithmetic expression, for example <code>60 * 60 * 24</code> .  Another example is string concatenation when searching for SQL injection and other vulnerabilities. <br></p><br><p>  To implement this task, a custom interface was implemented, and Visitor itself was implemented only for UAST.  Since the simplification of the AST simply reduces the number of tree nodes, the Visitor is typed, accepting and returning the same type.  Thanks to the support of reflection in .NET, it turned out to implement such a Visitor with a small amount of code.  Since each node contains other nodes or terminal primitive values, using reflection, it is possible to extract all members of a particular node and process them, causing other visitors to recursively. </p><br><a name="tree-matching-algorithm"></a><br><h2 id="algoritm-sopostavleniya-ast-i-shablonov">  Algorithm mapping AST and templates </h2><br><p>  The template search algorithm consists of enumerating all AST nodes and matching each node with a template represented as a tree structure.  Two nodes are comparable if they have the same types and, depending on the type, some of the conditions are met: </p><br><ul><li>  Recursive comparison of descendants. </li><li>  Comparison of simple literal types (identifier, strings, numbers). </li><li>  Comparison of extended literal types (regular expressions, ranges).  Comments are included in this group. </li><li>  Comparison of complex extended types (expressions, the sequence of the Statement). </li></ul><br><p>  This algorithm is based on simple principles that allow achieving high performance with a relatively small amount of code implementing them.  The latter is achieved due to the fact that the CompareTo method for comparing nodes is implemented for the base class, terminals, and a small number of other nodes.  More advanced matching algorithms, based on finite automata, have not yet been implemented to improve performance.  However, this algorithm is problematic (or even impossible) to use for more advanced analysis, for example, taking into account the semantics of the language, i.e.  communication between different AST nodes. </p><br><a name="conclusion"></a><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, we looked at the Visitor and Listener patterns for treating trees, and also talked about the structure of a unified AST.  In the following articles we will tell: </p><br><ul><li>  about approaches to storing templates (Hardcoded, Json, DSL); </li><li>  developing and using DSL to describe patterns; </li><li>  examples of real templates and their search in open source projects; </li><li>  CFG, DFG and taint analysis. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/210060/">https://habr.com/ru/post/210060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210046/index.html">Mobile development for the media. The basics you need to know</a></li>
<li><a href="../210048/index.html">Protection system for remote banking services and electronic payments</a></li>
<li><a href="../210050/index.html">Access iFrame content from another domain</a></li>
<li><a href="../210056/index.html">Once again about Intel contests. Memo to future participants</a></li>
<li><a href="../210058/index.html">Web Components - the future of the Web</a></li>
<li><a href="../210062/index.html">Smart cards for the smallest</a></li>
<li><a href="../210068/index.html">MySQL engine in 5 minutes</a></li>
<li><a href="../210074/index.html">Three personalization strategies for an online store</a></li>
<li><a href="../210076/index.html">Sony creates a human genome research company</a></li>
<li><a href="../210078/index.html">Recognize it! Native Speech Competition 2014</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>