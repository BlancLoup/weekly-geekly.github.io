<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operator preceding descending parser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Douglas Crockford 

 2007-02-21 
 Introduction 
 In 1973, at the first annual symposium ‚Äú Principles of Programming Languages ‚Äù ( Principles of Progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operator preceding descending parser</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://www.crockford.com/">Douglas Crockford</a> <br><br>  2007-02-21 <br><h2>  Introduction </h2><br>  In 1973, at the first annual symposium ‚Äú <a href="http://www.sigplan.org/conferences/popl/main">Principles of Programming Languages</a> ‚Äù ( <a href="http://www.sigplan.org/conferences/popl/main">Principles of Programming Languages ‚Äã‚ÄãSymposium</a> ), <a href="http://boole.stanford.edu/pratt.html">Von Pratt</a> introduced the article ‚Äú <a href="http://portal.acm.org/citation.cfm%3Fid%3D512931">Top-down Operator Precedence Parser</a> ‚Äù.  In this article, Pratt described a syntactic parsing method that combines the best of recursive descent and <a href="http://en.wikipedia.org/wiki/Robert_W._Floyd">Floyd's</a> operator precedence method.  The Pratt method is very similar to recursive descent, but requires less code and runs much faster.  Pratt said that his method is easy to learn, implement and use, extremely effective and very flexible.  Due to its dynamism, it can be used for extensible languages. <br><br>  But if the method is really flawless, why do compiler developers ignore it to this day?  In his article, Pratt suggested that BNF grammars and their numerous modifications, as well as related theorems and automata, occupied a niche earlier and now impede the development of the theory of syntactic analysis in other directions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is another explanation: this method is most effective for dynamic, functional programming languages ‚Äã‚Äãand it is much more difficult to use it in a static, procedural language.  Pratt illustrates his article with Lisp as an example and effortlessly builds syntax trees along a stream of tokens.  But parsing methods are not particularly appreciated in the community of Lisp programmers who preach a Spartan rejection of syntax.  Since the creation of Lisp, many attempts have been made to give this language a rich ALGOL style syntax: <a href="http://its.svensson.org/DOC%253BCGOL">Pratt's CGOL</a> , <a href="http://www.softwarepreservation.org/projects/LISP/lisp2_family/">Lisp-2</a> , <a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/68/92/CS-TR-68-92.pdf">MLISP</a> , <a href="http://www.opendylan.org/">Dylan</a> , <a href="http://www.researchgate.net/publication/220812814_CLISP_-_Conversational_LISP">Interlisp's Clisp</a> , the <a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">original McCarthy M-expressions,</a> and so on.  But they all failed.  For the Lisp community, consistency of programs and data turned out to be more important than expressive syntax.  On the other hand, the vast majority of programmers love syntax, so Lisp itself has never become popular.  The Pratt method needs a dynamic language, but the dynamic language community has historically not used the syntax that has been so conveniently implemented by the Pratt method. <br><a name="habracut"></a><br><h2>  Javascript </h2><br>  The situation has changed with the advent of javascript.  JavaScript is a dynamic, functional language, but syntactically it belongs to the C family.  It is a dynamic language, and its community loves syntax. <br><br>  JavaScript is also object-oriented.  Pratt's article anticipated the object-oriented approach, but it lacked expressive notation for that.  JavaScript is the ideal language for implementing Pratt's method.  I‚Äôll show you how to create JavaScript parsers quickly and efficiently. <br><br>  One article is not enough to deal with JavaScript completely and, perhaps, we don‚Äôt want to, because in this language the devil will break his leg.  But there are brilliant sides in it, quite worthy of consideration.  We will create a parser that can handle Simplified JavaScript.  And we will write this parser in Simplified JavaScript.  Simplified JavaScript is all the best of the language, including: <br><br><ul><li>  Functions as first class objects.  In Simplified JavaScript, functions are lambda expressions with a lexical scope. </li><li>  Dynamic objects with prototype inheritance.  There are no classes.  We can add a new member to the object using regular assignment.  An object can inherit members of another object. </li><li>  Literals for objects and arrays.  This notation is very convenient for creating new objects and arrays.  JavaScript literals provided inspiration for the <a href="http://www.json.org/">JSON format</a> . </li></ul><br>  We take advantage of JavaScript prototypes to create lexeme objects that inherit from characters.  Our implementation will need the <code>Object.create</code> method (creates a new object that inherits the members of an existing object) and a lexical analyzer, which, on the input line, creates an array of lexemes objects.  Moving along this array, we will build a syntax parsing tree. <br><br><h2>  table of symbols </h2><br>  Each token, for example, an operator or identifier, will be inherited from a character.  We will write all of our possible characters (which define the types of language tokens) into the <code>symbol_table</code> object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> symbol_table = {};</code> </pre> <br>  The <code>original_symbol</code> object is the prototype for all other characters.  His methods are usually overwhelmed.  The meaning of the <code>nud</code> and <code>led</code> methods, as well as the binding power, will be explained below in the ‚ÄúPriorities‚Äù section. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original_symbol = { <span class="hljs-attr"><span class="hljs-attr">nud</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error(<span class="hljs-string"><span class="hljs-string">"Undefined."</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">led</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error(<span class="hljs-string"><span class="hljs-string">"Missing operator."</span></span>); } };</code> </pre> <br>  Define the function that creates the characters.  It accepts a symbol identifier ( <code>id</code> ) and a binding strength (optional <code>bp</code> parameter, the default is zero), and returns a symbol object for the given <code>id</code> .  If the symbol is already in <code>symbol_table</code> , the function returns it.  Otherwise, it creates a new character that is inherited from <code>original_symbol</code> , stores it in the symbol table, and returns.  The character object initially contains the <code>id</code> , value, left binding power ( <code>lbp</code> ), and everything that came from <code>original_symbol</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> symbol = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, bp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = symbol_table[id]; bp = bp || <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp &gt;= s.lbp) { s.lbp = bp; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { s = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(original_symbol); s.id = s.value = id; s.lbp = bp; symbol_table[id] = s; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; };</code> </pre> <br>  We declare frequently occurring delimiters and trailing characters. <br><br><pre> <code class="javascript hljs">symbol(<span class="hljs-string"><span class="hljs-string">":"</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">";"</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">","</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">")"</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">"]"</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">"}"</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">"else"</span></span>);</code> </pre> <br>  The symbol <code>(end)</code> indicates the end of the stream of tokens.  The symbol <code>(name)</code> is a prototype for new names, for example, variable names.  I included brackets in their ids to avoid possible matches with custom lexemes. <br><br><pre> <code class="javascript hljs">symbol(<span class="hljs-string"><span class="hljs-string">"(end)"</span></span>); symbol(<span class="hljs-string"><span class="hljs-string">"(name)"</span></span>);</code> </pre> <br><h2>  Lexemes </h2><br>  We assume that the source text has already been converted into an array of <code>tokens</code> primitive lexemes containing the <code>type</code> field ( <code>"name"</code> , <code>"string"</code> , <code>"number"</code> , or <code>"operator"</code> ), and the <code>value</code> field (string or number).  The variable <code>token</code> always refers to the current token. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> token;</code> </pre> <br>  The <code>advance</code> function creates a new token object from the following primitive token and assigns it to the variable <code>token</code> .  If the optional <code>id</code> parameter is passed, the function checks that the token has the corresponding identifier.  The prototype of the new lexeme object is a symbol <code>(name)</code> in the current scope or a symbol from the symbol table.  The <code>arity</code> field of the new lexeme will be either <code>"name"</code> , or <code>"literal"</code> , or <code>"operator"</code> .  Subsequently, when we learn more about the role of a token in a program, this value may change to <code>"binary"</code> , <code>"unary"</code> or <code>"statement"</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> advance = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, o, t, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id &amp;&amp; token.id !== id) { token.error(<span class="hljs-string"><span class="hljs-string">"Expected '"</span></span> + id + <span class="hljs-string"><span class="hljs-string">"'."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token_nr &gt;= tokens.length) { token = symbol_table[<span class="hljs-string"><span class="hljs-string">"(end)"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } t = tokens[token_nr]; token_nr += <span class="hljs-number"><span class="hljs-number">1</span></span>; v = t.value; a = t.type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { o = scope.find(v); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-string"><span class="hljs-string">"operator"</span></span>) { o = symbol_table[v]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!o) { t.error(<span class="hljs-string"><span class="hljs-string">"Unknown operator."</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === <span class="hljs-string"><span class="hljs-string">"string"</span></span> || a === <span class="hljs-string"><span class="hljs-string">"number"</span></span>) { a = <span class="hljs-string"><span class="hljs-string">"literal"</span></span>; o = symbol_table[<span class="hljs-string"><span class="hljs-string">"(literal)"</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t.error(<span class="hljs-string"><span class="hljs-string">"Unexpected token."</span></span>); } token = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(o); token.value = v; token.arity = a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token; };</code> </pre> <br><h2>  Area of ‚Äã‚Äãvisibility </h2><br>  Most languages ‚Äã‚Äãhave a notation for defining new characters (for example, variable names).  In simple language, when we meet a new word, we automatically define it and put it in the symbol table.  In more complex languages, there is a scope that allows a programmer to control access to a variable and its lifetime. <br><br>  The scope is the part of the program in which the variable is defined and accessible.  Scopes can be nested.  A variable defined in a certain scope is not visible outside. <br><br>  We will store the current scope in a separate variable <code>scope</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope;</code> </pre> <br>  The <code>original_scope</code> object is the prototype for all objects that represent the scope.  It contains a <code>define</code> method that allows you to define new variables.  The <code>define</code> method converts a name token into a token variable.  It gives an error if the variable has already been defined in scope or the name is a reserved word. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itself = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original_scope = { <span class="hljs-attr"><span class="hljs-attr">define</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.def[n.value]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> t === <span class="hljs-string"><span class="hljs-string">"object"</span></span>) { n.error(t.reserved ? <span class="hljs-string"><span class="hljs-string">"Already reserved."</span></span> : <span class="hljs-string"><span class="hljs-string">"Already defined."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.def[n.value] = n; n.reserved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; n.nud = itself; n.led = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; n.std = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; n.lbp = <span class="hljs-number"><span class="hljs-number">0</span></span>; n.scope = scope; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; },</code> </pre> <br>  The <code>find</code> method is used to find a definition by name.  He begins the search from the current scope and goes, if necessary, up the chain, ending with a table of characters.  If the definition could not be found, it returns <code>symbol_table["(name)"]</code> .  The method checks that the value with the given name is not equal to <code>undefined</code> (which would mean referring to an undeclared name) and that this is not a function (which would indicate a conflict with the inherited method). <br><br><pre> <code class="javascript hljs"> find: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, o; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { o = e.def[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> o !== <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.def[n]; } e = e.parent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!e) { o = symbol_table[n]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> o !== <span class="hljs-string"><span class="hljs-string">'function'</span></span> ? o : symbol_table[<span class="hljs-string"><span class="hljs-string">"(name)"</span></span>]; } } },</code> </pre> <br>  The <code>pop</code> method closes the scope by replacing it with its parent. <br><br><pre> <code class="javascript hljs"> pop: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent; },</code> </pre> <br>  The <code>reserve</code> method is used to indicate that a given name is a reserved word in the current scope. <br><br><pre> <code class="javascript hljs"> reserve: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span> || n.reserved) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.def[n.value]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.reserved) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.arity === <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { n.error(<span class="hljs-string"><span class="hljs-string">"Already defined."</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.def[n.value] = n; n.reserved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br>  Now we need a strategy for processing reserved words.  In some languages, words describing the structure of a program (for example, <code>if</code> ) are reserved and cannot be used as variable names.  The flexibility of our parser allows you to achieve more.  For example, we can say that in any function any given name can be used either as a language operator or as a variable name.  We will reserve words locally only after they have been used as reserved.  This simplifies the life of the creator of the language, because the addition of new keywords will not break existing programs, and simplifies the life of programmers, because they do not interfere with unnecessary restrictions on the use of names. <br><br>  When we want to create a new scope for a function or block, we call the <code>new_scope</code> function, which creates a new prototype instance, <code>original_scope</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> new_scope = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = scope; scope = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(original_scope); scope.def = {}; scope.parent = s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; };</code> </pre> <br><h2>  A priority </h2><br>  The lexeme objects contain methods that allow you to make decisions about priorities, select other lexemes and build trees (and in more complex projects you can also check types, optimize and generate code).  The main task of priorities is as follows: for a given operand between two operators, determine whether the operand belongs to the left operator or to the right operator: <br><br>  <code>d</code> <i>A</i> <code>e</code> <i>B</i> <code>f</code> <br><br>  If <i>A</i> and <i>B</i> are operators, to which of them does operand <code>e</code> belong?  In other words, we have to choose between <code>(d</code> <i>A</i> <code>e)</code> <i>B</i> <code>f</code> <br>  and <code>d</code> <i>A</i> <code>(e</code> <i>B</i> <code>f)</code> . <br><br>  Ultimately, the main complexity of the syntactic analysis is to resolve this uncertainty.  The objects of the tokens from our method store the binding strength (or priority level), and the simple methods <code>nud</code> (null denotation, null-match) and <code>led</code> (left denotation, left-match).  The <code>nud</code> does not matter which lexemes are to the left, and the <code>led</code> method is important.  The <code>nud</code> method <code>nud</code> used by values ‚Äã‚Äã(variables and literals) and prefix operators.  The <code>led</code> method is used by infix and postfix operators.  A lexeme can have both <code>nud</code> and <code>led</code> methods <code>nud</code> .  For example, minus ( <code>-</code> ) can be either prefix (changing the sign of a number) or infix (subtraction), so both methods are defined for it. <br><br>  Our parser uses the following binding forces: <br><table><tbody><tr><td>  0 </td><td>  operators without communication <code>;</code>  etc. </td></tr><tr><td>  ten </td><td>  assignment operators: <code>=</code> , etc. </td></tr><tr><td>  20 </td><td> <code>?:</code> </td> </tr><tr><td>  thirty </td><td> <code>|| &amp;&amp;</code> </td> </tr><tr><td>  40 </td><td>  comparison operators: <code>===</code> , etc. </td></tr><tr><td>  50 </td><td> <code>+ -</code> </td> </tr><tr><td>  60 </td><td> <code>* /</code> </td> </tr><tr><td>  70 </td><td>  unary operators:!  etc. </td></tr><tr><td>  80 </td><td> <code>. [ (</code> </td> </tr></tbody></table><br><h2>  Expressions </h2><br>  The main component of the Pratt method is the function <code>expression</code> .  It takes as input the right binding force, which indicates how actively the expression is associated with the tokens on the right. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expression = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rbp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = token; advance(); left = t.nud(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (rbp &lt; token.lbp) { t = token; advance(); left = t.led(left); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; }</code> </pre> <br>  The <code>expression</code> function calls the <code>nud</code> method of the current token <code>token</code> , which processes literals, variables, and prefix operators.  Then, as long as the right binding power is less than the left binding power of the next lexeme, the <code>led</code> method is invoked.  This method handles infix and postfix operators.  The process can be recursive, since the <code>nud</code> and <code>led</code> methods themselves can call <code>expression</code> . <br><br><h2>  Infix operators </h2><br>  The <code>+</code> operator is an infix operator, so it has a <code>led</code> method that turns the lexeme object into a tree, whose two branches ( <code>first</code> and <code>second</code> ) are operands to the left and right of the <code>+</code> sign.  The <code>led</code> method accepts the left operand as a parameter and finds the right operand by calling <code>expression</code> . <br><br><pre> <code class="javascript hljs">symbol(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>).led = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; };</code> </pre> <br>  The <code>*</code> symbol is similar to <code>+</code> except for the <code>id</code> value and the binding strength.  It is more tightly bound to operands, so its binding power is higher. <br><br><pre> <code class="javascript hljs">symbol(<span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>).led = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(<span class="hljs-number"><span class="hljs-number">60</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; };</code> </pre> <br>  Not all infix operators will look the same, but many will.  Therefore, we can simplify our work by defining an <code>infix</code> function that helps us create infix operators.  The <code>infix</code> function takes <code>id</code> , binding strength, and optionally <code>led</code> function.  If the function is not specified, <code>infix</code> creates the default <code>led</code> function, which is suitable in most cases. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> infix = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, bp, led</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = symbol(id, bp); s.led = led || <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(bp); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }</code> </pre> <br>  Now we can describe infix operators in a more declarative style: <br><br><pre> <code class="javascript hljs">infix(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>);</code> </pre> <br>  <code>===</code> is an exact comparison operator in javascript. <br><br><pre> <code class="javascript hljs">infix(<span class="hljs-string"><span class="hljs-string">"==="</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"!=="</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"&lt;="</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); infix(<span class="hljs-string"><span class="hljs-string">"&gt;="</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>);</code> </pre> <br>  The ternary operator accepts three expressions separated by <code>?</code>  and <code>:</code>  This is not a regular infix operator, so you have to set the <code>led</code> function here. <br><br><pre> <code class="javascript hljs">infix(<span class="hljs-string"><span class="hljs-string">"?"</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); advance(<span class="hljs-string"><span class="hljs-string">":"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.third = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"ternary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The dot operator ( <code>.</code> ) Is used to refer to a member of an object.  To his right there must be a name, but it will be used as a literal. <br><br><pre> <code class="javascript hljs">infix(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { token.error(<span class="hljs-string"><span class="hljs-string">"Expected a property name."</span></span>); } token.arity = <span class="hljs-string"><span class="hljs-string">"literal"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = token; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; advance(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The operator <code>[</code> used to access a member of an object or an element of an array dynamically.  The expression on the right should be followed by a closing bracket <code>]</code> . <br><br><pre> <code class="javascript hljs">infix(<span class="hljs-string"><span class="hljs-string">"["</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; advance(<span class="hljs-string"><span class="hljs-string">"]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  All these infix operators are left associative.  We can also create right associative operators (for example, logical || and &amp;&amp;), reducing the right binding force. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> infixr = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, bp, led</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = symbol(id, bp); s.led = led || <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(bp - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }</code> </pre> <br>  The <code>&amp;&amp;</code> operator returns the first operand if it is false, otherwise it returns the second.  Operator <code>||</code>  returns the first operand if it is true, otherwise returns the second.  False value is <code>0</code> , the empty string is <code>""</code> , <code>false</code> or <code>null</code> .  Any other value (including any object) is considered true. <br><br><pre> <code class="javascript hljs">infixr(<span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); infixr(<span class="hljs-string"><span class="hljs-string">"||"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><h2>  Prefix Operators </h2><br>  The code that we used for right-associative infisk operators can be adapted for prefix operators.  Prefix operators are right associative.  The prefix has no left binding power, because it does not bind to anything on the left.  Sometimes prefix operators are reserved words. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefix = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, nud</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = symbol(id); s.nud = nud || <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scope.reserve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = expression(<span class="hljs-number"><span class="hljs-number">70</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"unary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } prefix(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); prefix(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); prefix(<span class="hljs-string"><span class="hljs-string">"typeof"</span></span>);</code> </pre> <br>  The <code>nud</code> method for the bracket <code>(</code> calls <code>advance(")")</code> to find the matching bracket <code>)</code> .  The lexeme itself <code>(</code> misses the syntax tree, because <code>nud</code> returns only the contents of the brackets. <br><br><pre> <code class="javascript hljs">prefix(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); advance(<span class="hljs-string"><span class="hljs-string">")"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; });</code> </pre> <br><h2>  Assignment operators </h2><br>  To define assignment operators, we could use the <code>infixr</code> function.  But better we will write a separate <code>assignment</code> function, because we want to do something else: make sure that the expression on the left is lvalue, that is, we can assign something to it, and set the field of <code>assignment</code> so that we can easily find all assignments in the future . <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assignment = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> infixr(id, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left.id !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; left.id !== <span class="hljs-string"><span class="hljs-string">"["</span></span> &amp;&amp; left.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { left.error(<span class="hljs-string"><span class="hljs-string">"Bad lvalue."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = expression(<span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.assignment = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }); }; assignment(<span class="hljs-string"><span class="hljs-string">"="</span></span>); assignment(<span class="hljs-string"><span class="hljs-string">"+="</span></span>); assignment(<span class="hljs-string"><span class="hljs-string">"-="</span></span>);</code> </pre> <br>  Notice: we implemented something like inheritance.  The <code>assignment</code> function returns the result of the <code>infixr</code> call, and <code>infixr</code> result of the <code>symbol</code> call. <br><br><h2>  Constants </h2><br>  The <code>constant</code> function creates language constants.  The <code>nud</code> method turns a name token into a literal token. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> constant = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = symbol(s); x.nud = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scope.reserve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = symbol_table[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id].value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"literal"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; x.value = v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; constant(<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); constant(<span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); constant(<span class="hljs-string"><span class="hljs-string">"null"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); constant(<span class="hljs-string"><span class="hljs-string">"pi"</span></span>, <span class="hljs-number"><span class="hljs-number">3.141592653589793</span></span>);</code> </pre> <br>  A character <code>(literal)</code> is a prototype for all string and numeric literals.  The <code>nud</code> method of a <code>nud</code> token returns the token itself. <br><br><pre> <code class="javascript hljs">symbol(<span class="hljs-string"><span class="hljs-string">"(literal)"</span></span>).nud = itself;</code> </pre> <br><h2>  suggestions </h2><br>  In the original, the Pratt method was created for functional languages, where there are only expressions.  Most popular languages ‚Äã‚Äãuse statements (statements), which are not so difficult to invest in each other as expressions.  We can easily process and proposals, if we add a new method to the tokens: <code>std</code> (statement denotation, matching the proposal).  The <code>std</code> method is similar to <code>nud</code> , but it is called only at the beginning of a sentence. <br><br>  The <code>statement</code> function parses one <code>statement</code> .  If the current token contains the <code>std</code> method, the token is reserved and this method is called.  Otherwise, we believe that a sentence is an expression ending in a semicolon.  For reliability, we will consider expressions that are not assignments or function calls for error. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statement = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = token, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n.std) { advance(); scope.reserve(n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.std(); } v = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!v.assignment &amp;&amp; v.id !== <span class="hljs-string"><span class="hljs-string">"("</span></span>) { v.error(<span class="hljs-string"><span class="hljs-string">"Bad expression statement."</span></span>); } advance(<span class="hljs-string"><span class="hljs-string">";"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; };</code> </pre> <br>  The <code>statements</code> function <code>statements</code> sentences until it encounters a token <code>(end)</code> or <code>}</code> , which marks the end of a block.  The function returns a sentence, an array of sentences, or <code>null</code> if no sentences are found. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statements = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [], s; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id === <span class="hljs-string"><span class="hljs-string">"}"</span></span> || token.id === <span class="hljs-string"><span class="hljs-string">"(end)"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } s = statement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s) { a.push(s); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.length === <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : a.length === <span class="hljs-number"><span class="hljs-number">1</span></span> ? a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : a; };</code> </pre> <br>  The <code>stmt</code> function is used to add sentence symbols to the symbol table.  It takes the <code>id</code> and the <code>std</code> function as parameters. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stmt = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = symbol(s); x.std = f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; };</code> </pre> <br>  A block clause is a list of sentences in curly braces for which a new scope is defined.  In normal JavaScript, there are no scope for blocks, but they will be in our Simplified JavaScript. <br><br><pre> <code class="javascript hljs">stmt(<span class="hljs-string"><span class="hljs-string">"{"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ new_scope(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = statements(); advance(<span class="hljs-string"><span class="hljs-string">"}"</span></span>); scope.pop(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; });</code> </pre> <br><br>  The <code>block</code> function parses a block. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = token; advance(<span class="hljs-string"><span class="hljs-string">"{"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.std(); };</code> </pre> <br>  The <code>var</code> clause defines one or more variables in the current block.  The variable name can be followed by the equal sign <code>=</code> and the initial value of the variable. <br><br><pre> <code class="javascript hljs">stmt(<span class="hljs-string"><span class="hljs-string">"var"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [], n, t; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { n = token; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { n.error(<span class="hljs-string"><span class="hljs-string">"Expected a new variable name."</span></span>); } scope.define(n); advance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id === <span class="hljs-string"><span class="hljs-string">"="</span></span>) { t = token; advance(<span class="hljs-string"><span class="hljs-string">"="</span></span>); t.first = n; t.second = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); t.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; a.push(t); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">","</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } advance(<span class="hljs-string"><span class="hljs-string">","</span></span>); } advance(<span class="hljs-string"><span class="hljs-string">";"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.length === <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : a.length === <span class="hljs-number"><span class="hljs-number">1</span></span> ? a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : a; });</code> </pre> <br>  The <code>while</code> clause defines a loop.  It includes an expression in brackets and a block. <br><br><pre> <code class="javascript hljs">stmt(<span class="hljs-string"><span class="hljs-string">"while"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ advance(<span class="hljs-string"><span class="hljs-string">"("</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); advance(<span class="hljs-string"><span class="hljs-string">")"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = block(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"statement"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The <code>if</code> clause creates a conditional construct.  If the block is followed by an <code>else</code> symbol, then we also analyze the next block or the next <code>if</code> . <br><br><pre> <code class="javascript hljs">stmt(<span class="hljs-string"><span class="hljs-string">"if"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ advance(<span class="hljs-string"><span class="hljs-string">"("</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); advance(<span class="hljs-string"><span class="hljs-string">")"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = block(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id === <span class="hljs-string"><span class="hljs-string">"else"</span></span>) { scope.reserve(token); advance(<span class="hljs-string"><span class="hljs-string">"else"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.third = token.id === <span class="hljs-string"><span class="hljs-string">"if"</span></span> ? statement() : block(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.third = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"statement"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The <code>break</code> clause is used to end the loop ahead of time <br><br><pre> <code class="javascript hljs">stmt(<span class="hljs-string"><span class="hljs-string">"break"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ advance(<span class="hljs-string"><span class="hljs-string">";"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">"}"</span></span>) { token.error(<span class="hljs-string"><span class="hljs-string">"Unreachable statement."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"statement"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The <code>return</code> clause is used to exit a function.  It may contain an optional expression (the return value of the function). <br><br><pre> <code class="javascript hljs">stmt(<span class="hljs-string"><span class="hljs-string">"return"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">";"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); } advance(<span class="hljs-string"><span class="hljs-string">";"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">"}"</span></span>) { token.error(<span class="hljs-string"><span class="hljs-string">"Unreachable statement."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"statement"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br><h2>  Functions </h2><br>  Functions are executable values.  A function may have an optional name (so that it can call itself recursively), a list of parameter names in brackets, and a body ‚Äî a list of sentences in curly braces.  The function has its own scope. <br><br><pre> <code class="javascript hljs">prefix(<span class="hljs-string"><span class="hljs-string">"function"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = []; new_scope(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.arity === <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { scope.define(token); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = token.value; advance(); } advance(<span class="hljs-string"><span class="hljs-string">"("</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">")"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span>) { token.error(<span class="hljs-string"><span class="hljs-string">"Expected a parameter name."</span></span>); } scope.define(token); a.push(token); advance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">","</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } advance(<span class="hljs-string"><span class="hljs-string">","</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = a; advance(<span class="hljs-string"><span class="hljs-string">")"</span></span>); advance(<span class="hljs-string"><span class="hljs-string">"{"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = statements(); advance(<span class="hljs-string"><span class="hljs-string">"}"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"function"</span></span>; scope.pop(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  Functions are performed using the operator <code>(</code> . When calling, you can specify a number of arguments. We will check the left operand to cut off situations where the value on the left cannot be a function. <br><br><pre> <code class="javascript hljs">infix(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left.id === <span class="hljs-string"><span class="hljs-string">"."</span></span> || left.id === <span class="hljs-string"><span class="hljs-string">"["</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"ternary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left.first; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = left.second; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.third = a; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"binary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((left.arity !== <span class="hljs-string"><span class="hljs-string">"unary"</span></span> || left.id !== <span class="hljs-string"><span class="hljs-string">"function"</span></span>) &amp;&amp; left.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span> &amp;&amp; left.id !== <span class="hljs-string"><span class="hljs-string">"("</span></span> &amp;&amp; left.id !== <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> &amp;&amp; left.id !== <span class="hljs-string"><span class="hljs-string">"||"</span></span> &amp;&amp; left.id !== <span class="hljs-string"><span class="hljs-string">"?"</span></span>) { left.error(<span class="hljs-string"><span class="hljs-string">"Expected a variable name."</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">")"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { a.push(expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">","</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } advance(<span class="hljs-string"><span class="hljs-string">","</span></span>); } } advance(<span class="hljs-string"><span class="hljs-string">")"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The <code>this</code> symbol is a special variable.  When calling a method, it contains a reference to the object. <br><br><pre> <code class="javascript hljs">symbol(<span class="hljs-string"><span class="hljs-string">"this"</span></span>).nud = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scope.reserve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"this"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; };</code> </pre> <br><h2>  Literals for objects and arrays </h2><br>  An array literal is a set of expressions in square brackets, separated by commas.  Each expression is evaluated, and all results form a new array. <br><br><pre> <code class="javascript hljs">prefix(<span class="hljs-string"><span class="hljs-string">"["</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">"]"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { a.push(expression(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">","</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } advance(<span class="hljs-string"><span class="hljs-string">","</span></span>); } } advance(<span class="hljs-string"><span class="hljs-string">"]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = a; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"unary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br>  The literal for an object is a set of pairs in curly braces, separated by commas.  A pair consists of a key and an expression, which are separated by a colon ( <code>:</code> .  The key is a literal or a name that is interpreted as a literal. <br><br><pre> <code class="javascript hljs">prefix(<span class="hljs-string"><span class="hljs-string">"{"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">"}"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = token; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n.arity !== <span class="hljs-string"><span class="hljs-string">"name"</span></span> &amp;&amp; n.arity !== <span class="hljs-string"><span class="hljs-string">"literal"</span></span>) { token.error(<span class="hljs-string"><span class="hljs-string">"Bad key."</span></span>); } advance(); advance(<span class="hljs-string"><span class="hljs-string">":"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = expression(<span class="hljs-number"><span class="hljs-number">0</span></span>); v.key = n.value; a.push(v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.id !== <span class="hljs-string"><span class="hljs-string">","</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } advance(<span class="hljs-string"><span class="hljs-string">","</span></span>); } } advance(<span class="hljs-string"><span class="hljs-string">"}"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = a; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arity = <span class="hljs-string"><span class="hljs-string">"unary"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; });</code> </pre> <br><h2>  What to think and what to do </h2><br>  The created tree can be transferred to a code generator or interpreter.  To create a tree requires a minimum of calculations.  And, as we see, it takes not so much effort from a programmer to write such a parser. <br><br>  We can add an operation code parameter to the <code>infix</code> function to help the code generator.  We can also pass in additional methods for <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D1%2582">convolving constants</a> and generating code. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can add other proposals (for example, </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), the label, more code to check for errors, error recovery, and a bunch of new operators. We can add task and type inference. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can make our language extensible. We can allow the programmer to declare new operators and sentences as easily as declare new variables. </font></font><br><br> <a href="http://javascript.crockford.com/tdop/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test yourself the parser described in this article.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can find another example of using this method of parsing in the </font></font><a href="http://jslint.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSLint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the translator:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> picked the source code for JSLint and decided that the Russian translation of this wonderful article would not hurt. The parser in JSLint is really exceptionally clear, powerful and easily extensible. Thank you very much</font></font><a href="https://habrahabr.ru/users/kvie/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for editing the translation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article was published as part of the book Beautiful Code (chapter nine). </font><font style="vertical-align: inherit;">Russian translation of the entire book in electronic form can be purchased on the </font></font><a href="http://www.piter.com/product/idealnyy-kod"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">website of the publishing house "Peter"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/227241/">https://habr.com/ru/post/227241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227229/index.html">Comprehensive Mailing List Guide</a></li>
<li><a href="../227233/index.html">Employees with experience in the company for more than 2 years earn 50% less</a></li>
<li><a href="../227235/index.html">iOS. Programming techniques</a></li>
<li><a href="../227237/index.html">Broadcast video from a mobile device to YouTube</a></li>
<li><a href="../227239/index.html">3 of 130. New Android tablets at Intel Atom</a></li>
<li><a href="../227243/index.html">Swift: problems and prospects</a></li>
<li><a href="../227245/index.html">Mad House on PHDays: cyber threats of an ordinary apartment</a></li>
<li><a href="../227247/index.html">Traffic Inspector in action: monitor network activity via VPN</a></li>
<li><a href="../227249/index.html">They want to send "computer microprobe" to Europe</a></li>
<li><a href="../227253/index.html">The model of the natural series of numbers (nrch). Ulam Spiral</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>