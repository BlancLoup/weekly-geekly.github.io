<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TextTest is a cross-platform python framework for GUI testing and more. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation of the story about the wonderful cross-platform framework for functional testing TextTest. The first part of the article. 


 GUI Testing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TextTest is a cross-platform python framework for GUI testing and more. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/bcb/2c3/848/bcb2c3848253ed2a77421e8bc8513dad.gif" alt="Logo" align="left">  Continuation of the story about the wonderful cross-platform framework for functional testing TextTest.  <a href="http://habrahabr.ru/post/165617/">The first part of the article.</a> <br><br clear="all"><a name="habracut"></a><br><h4>  GUI Testing Methods </h4><br>  Now the vast majority of GUI testing tools work in one of two ways: <br><ol><li>  Take screenshots after each screen change and then compare the changes. </li><li>  Provide functions that allow you to read widget parameters through the operating system API </li></ol><br>  Problems of the first - the instability of tests, it is worth changing the relative position of the buttons on the form, even a couple of pixels, a lot of tests will fall, the screen resolution will change - all tests will fall, switched to a new version of the GUI framework, for example, improved font rendering - again all tests will fall.  For each operating system, you need to do your own set of tests, you may have to redo it even after installing the next service pack, if it affected the graphics subsystem. <br>  I do not argue about the appearance of testing useful, but it should be tests only for the design, to test through them the logic of the GUI is a mockery of a person. <br><br>  The second approach has other problems - tests are written long and difficult, and in addition they are often completely incomprehensible to others, especially to non-programmers.  Footcloths code like this: <br><pre><code class="python hljs">ActivateWindow(<span class="hljs-string"><span class="hljs-string">"Unsaved Document 1 - gedit"</span></span>) SetEdit(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>) ClickButton(<span class="hljs-string"><span class="hljs-string">"Save"</span></span>) Wait(<span class="hljs-number"><span class="hljs-number">10</span></span>) VerifyLabel(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  They do not give an idea of ‚Äã‚Äãwhat is happening and what is actually being tested.  The programmer needs to explicitly write assertions, to the fact that after letting this button be pressed, this label has changed its value to this, but this one has not changed.  Also, the operating system API may not provide full access to the internals of widgets, and if it is a non-standard widget, then it becomes almost impossible to consider its properties. <br><br>  But then it is easier to test the logic of the GUI, we are not tied to a graphical representation of the elements, and with a good tool you can even try to write cross-platform tests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Finally, both approaches have a common problem with testing non-synchronous events.  Suppose you enter a URL into your browser, and when to check that the page has loaded? <br><br>  You can make a timeout, but here the problem is that if the page loads on average for 5 seconds, then you need to ‚Äúfor faithfulness‚Äù set a timeout of 5 times more, and it‚Äôs not a fact that everything will work.  This leads to a slowdown of tests and to the probabilistic nature of their implementation. <br><br>  Option two - ‚Äúsharpen‚Äù on some secret widgets and as soon as they accept the desired state, assume that the action has been completed.  This adds work to the programmer and makes the tests even more unreadable and incomprehensible. <br><br><h4>  What alternatives does TextTest offer? </h4><br>  He suggests using the StoryText library to solve the problems described above.  The latter, before launching your application, ‚Äúwraps‚Äù the GUI library reference interfaces, pushing its interface options to the program.  And this is done completely transparent.  In most cases, you do not have to change a single line of code in the application under test.  This makes it possible to save the user's actions and the program's response to these actions to the log when recording a test.  And when testing - to repeat the actions of the user and compare the reaction of the program with the reference. <br><br>  So what does this give us: <br><ul><li>  We abstract from the arrangement of elements on the form and their appearance, it does not matter to us that in different OS the buttons have a different appearance, we test only the logic.  If we need to check that after clicking on the button, the label values ‚Äã‚Äãhave changed, then no design changes to the form will break this test. <br><br></li><li>  We get full access to the widget, no WinApi will allow to get as much information about the widget as the native library that creates this widget. <br><br></li><li>  For asynchronous events, such a concept is introduced as <a href="http://texttest.sourceforge.net/index.php%3Fpage%3Dui_testing%26n%3Dappevents">Application Events,</a> which, although it causes a little modification of the code, is just one line for each asynchronous event.  In short, the essence of the latter is that upon completion of an asynchronous event, we call the code notifying StoryText that the operation has completed.  StoryText remembers this fact and during playback it will be honest to wait for this event from the application and only then continue the test.  Everything!  No timeouts, no hidden widgets and other perversions, everything is simple and as fast as possible. <br><br></li><li>  The ease of writing tests, allows them to create even a little familiar with programming person.  You don‚Äôt have to search for the necessary button with the code and click on it, then you don‚Äôt need to sort the values ‚Äã‚Äãof the changed elements, StoryText itself records all the events that the user has made and saves all the changes to the GUI, and, as you will see, does readable form. <br><br></li><li>  Easy to understand tests.  After recording the first test, StoryText offers to enter aliases for all events that have occurred, i.e.  automatically created test will not look like this: <br><pre> <code class="python hljs">entry_in = FindEditByName(<span class="hljs-string"><span class="hljs-string">"entry_in"</span></span>) SetValueForEdit(entry_in, <span class="hljs-number"><span class="hljs-number">5</span></span>) calc_async = FindButtonByName(<span class="hljs-string"><span class="hljs-string">"calc_async"</span></span>) SendEvent(calc_async, &lt;Enter&gt;) SendEvent(calc_async, &lt;Button<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;) SendEvent(calc_async, &lt;ButtonRelease<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;) WaitEvent(<span class="hljs-string"><span class="hljs-string">"data to be loaded"</span></span>) exit = FindButtonByName(<span class="hljs-string"><span class="hljs-string">"exit"</span></span>) SendEvent(exit, &lt;Enter&gt;) SendEvent(exit, &lt;Button<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;) SendEvent(exit, &lt;ButtonRelease<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;)</code> </pre><br>  that agree a little nice, and here it is: <br><pre> <code class="bash hljs">enter_data 5 run_calc_async <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> data to be loaded exit_from_form</code> </pre><br>  Where enter_data, run_calc_async and exit_from_form are user names that he entered after recording a test (the values ‚Äã‚Äãof aliases - you can always see the special settings file) </li></ul><br><br>  Agree ideology - a wonderful, tests are created quickly, conveniently, readable.  There are of course problems, not with ideology, but with implementation.  The author seems to have the main library for the GUI gtk, the rest are added in a certain experimental mode and not fully implemented, however, I will show below how easy it is to add new functionality. <br><br><h4>  Fourth example.  Test synchronous GUI on Tkinter </h4><br>  Test class will TestGUI.  The class creates a very simple form on which it is proposed to enter a value, and press one of the OnCalcSync or OnCalcAsync buttons, the first will display the value multiplied by two at once, the second will wait 10 seconds and will output the same.  Yes, and I apologize in advance for the terrible look of the form, but this is only an example. <br><div class="spoiler">  <b class="spoiler_title">class TestGUI</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestGUI</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root)</span></span></span><span class="hljs-function">:</span></span> self.root = root frame1 = Tkinter.Frame(self.root) frame1.pack(fill=<span class="hljs-string"><span class="hljs-string">"both"</span></span>) frame2 = Tkinter.Frame(self.root) frame2.pack(fill=<span class="hljs-string"><span class="hljs-string">"both"</span></span>) frame3 = Tkinter.Frame(self.root) frame3.pack(fill=<span class="hljs-string"><span class="hljs-string">"both"</span></span>) frame4 = Tkinter.Frame(self.root) frame4.pack(fill=<span class="hljs-string"><span class="hljs-string">"both"</span></span>) Tkinter.Label(frame1, text=<span class="hljs-string"><span class="hljs-string">"Input:"</span></span>).pack(side=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) self.var_in = Tkinter.StringVar(value=<span class="hljs-string"><span class="hljs-string">""</span></span>) Tkinter.Entry(frame1, name=<span class="hljs-string"><span class="hljs-string">"entry_in"</span></span>, textvariable=self.var_in).pack() Tkinter.Label(frame2, text=<span class="hljs-string"><span class="hljs-string">"Output:"</span></span>).pack(side=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) self.label_out = Tkinter.Label(frame2, name=<span class="hljs-string"><span class="hljs-string">"label_out"</span></span>) self.label_out.pack(side=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) Tkinter.Button(frame3, name=<span class="hljs-string"><span class="hljs-string">"entry_calc_sync"</span></span>, text=<span class="hljs-string"><span class="hljs-string">"OnCalcSync"</span></span>, width=<span class="hljs-number"><span class="hljs-number">15</span></span>, command=self.on_press_sync).pack(side=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) Tkinter.Button(frame4, name=<span class="hljs-string"><span class="hljs-string">"entry_calc_async"</span></span>, text=<span class="hljs-string"><span class="hljs-string">"OnCalcAsync"</span></span>, width=<span class="hljs-number"><span class="hljs-number">15</span></span>, command=self.on_press_async).pack(side=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) Tkinter.Button(frame4, name=<span class="hljs-string"><span class="hljs-string">"entry_exit"</span></span>, text=<span class="hljs-string"><span class="hljs-string">"OnExit"</span></span>, width=<span class="hljs-number"><span class="hljs-number">15</span></span>, command=self.on_exit).pack(side=<span class="hljs-string"><span class="hljs-string">"left"</span></span>) self.root.title(<span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>) self.root.mainloop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(int(self.var_in.get()) * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"error input"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_press_sync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.label_out[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = self._calc() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_operation_finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> storytext.applicationEvent(<span class="hljs-string"><span class="hljs-string">'data to be loaded'</span></span>) self.label_out[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = self._calc() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_press_async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.root.after(<span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, self._operation_finish) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.root.destroy()</code> </pre><br></div></div><br>  I want to note that when you run the test, the tkinter_ex module is imported (you can download it <a href="https://github.com/ReanGD/HabrArticle/blob/master/TextTest/simpletests/tkinter_ex.py">from here</a> and put it next to test.py).  He is needed because  tkinter support in the library is still ‚ÄúExperimental and rather basic support for Tkinter‚Äù as the author himself writes.  In particular, the standard module for tkinter is completely unable to track text changes in the Label class, but fortunately it is not difficult to fix it.  To do this, we replace the standard Tkinter.Label with our own while preserving the original name and functionality, and in functions that could change the text of the label - ‚Äúconfigure‚Äù and "__setitem__", we add the following type of logging: ‚ÄúUpdated Text for label '% s' ( set to% s) ".  Thanks to the dynamism of Python, the code is not complicated. <br><div class="spoiler">  <b class="spoiler_title">tkinter_ex.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- import Tkinter import logging origLabel = Tkinter.Label class Label(origLabel): def __init__(self, *args, **kw): origLabel.__init__(self, *args, **kw) self.logger = logging.getLogger("gui log") def _update_text(self, value): self.logger.info("Updated Text for label '%s' (set to %s)" % (self.winfo_name(), value)) def configure(self, *args, **kw): origLabel.configure(self, *args, **kw) if "text" in kw: self._update_text(kw["text"]) def __setitem__(self, key, value): origLabel.__setitem__(self, key, value) if key == "text": self._update_text(value) config = configure internal_configure = origLabel.configure Tkinter.Label = Label</span></span></code> </pre><br></div></div><br>  So, let's go: Add a new test-suite ‚ÄúSuite_GUI‚Äù and test it with ‚ÄúTest_GUI_Sync‚Äù with the parameter ‚Äúgui‚Äù.  in simpletests \ config.cfg we add settings indicating that we will be testing the GUI based on tkinter <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Mode for Use-case recording (GUI, console or disabled) use_case_record_mode:GUI # How long in seconds to wait between each GUI action slow_motion_replay_speed:3.0 # Which Use-case recorder is being used use_case_recorder:storytext # Single program to use as interpreter for the SUT interpreter:storytext -i tkinter virtual_display_count:0</span></span></code> </pre><br>  I will not decipher all the settings, you can read about them <a href="http://texttest.sourceforge.net/index.php%3Fpage%3Ddocumentation_3_24%26n%3Dconfigfile_default">here</a> .  I‚Äôll draw attention to only one: ‚Äúvirtual_display_count‚Äù, it should only make sense on UNIX systems and allows you to run tests on virtual displays via Xvfb.  But due to an implementation error, if this parameter is not set, StoryText attempts to create virtual displays on Windows, where Xvfb is missing.  Therefore, the setting must be explicitly added and set to 0. <br><br>  Do not forget to restart the IDE after making the settings.  After that, in the ‚ÄúTest_GUI_Sync‚Äù menu, the ‚ÄúRecord Use-Case‚Äù item will become available, we launch it, we do not change anything in the appeared window.  Our test-free form appears: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/faa/0fc/438/faa0fc4380b163bf772e8c003c81e8bf.png" alt="GUI form"></div><br>  in it, you need to perform the actions you want to test, enter a value in the "Input" field, click "OnCalcSync" and then "Exit".  After this, StoryText will ask us to give human names for the actions performed, fill them in, for example like this: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/a37/bba/4a6/a37bba4a63299010a054e40c2a9f0658.png" alt="Action setup"></div><br>  As usual, we save and try to run the test again, everything works fine. <br>  To understand what happened, you can look at what appeared on the disc: simpletests \ storytext_files \ ui_map.conf, where the aliases we just entered are described.  It is also worth looking in the folder with the test (Test_GUI_Sync) on the file usecase.cfg, in which the resulting actions are described in completely human language: <br><pre> <code class="bash hljs">enter_data 5 run_calc_sync exit_from_form</code> </pre><br>  in stdout.cfg, you can see all the changes in the form state that occurred after user actions.  In the same place, we will see the line generated by our class in response to a change in the Label value ‚ÄúUpdated Text for label 'label_out' (set to 10)‚Äù.  So it works.  Excellent move on to the next example. <br><br><h4>  Fifth example.  Test the asynchronous GUI on Tkinter </h4><br>  Add a new test ‚ÄúTest_GUI_Async‚Äù to ‚ÄúSuite_GUI‚Äù and write it as last time, only instead of ‚ÄúOnCalcSync‚Äù press the button ‚ÄúOnCalcAsync‚Äù and the results of the calculation will have to wait for this time for 10 seconds.  Upon completion, you will need to somehow call the action of clicking on a new button, for example, for example, the path will be ‚Äúrun_calc_async‚Äù.  All other actions we called last time and StoryText remembered them. <br><br>  This test is interesting because the actions on the form now occur asynchronously and after clicking on the button it takes ten seconds before the ‚ÄúTestGUI._operation_finish‚Äù is called from the test.py module.  In this function, in addition to calculating the result, the line is added: <br><pre> <code class="python hljs">storytext.applicationEvent(<span class="hljs-string"><span class="hljs-string">'data to be loaded'</span></span>)</code> </pre><br>  which tells StoryText that some kind of asynchronous operation has completed its work and it needs to be reflected in the test, and when automatically executed, you should stop at the same place and wait for the event to occur. <br>  If you look at usecase.cfg for a new test, you will see: <br><pre> <code class="bash hljs">enter_data 5 run_calc_async <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> data to be loaded exit_from_form</code> </pre><br>  those.  the difference from the previous example is only that after pressing the button we expect the ‚Äúdata to be loaded‚Äù event and only after it close the form.  Save the results, run again, we see that StoryText patiently waits for the required 10 seconds before completing the test. <br>  As you can see, testing asynchronous events is not at all difficult. <br><br><h4>  Batch execution </h4><br>  Everyone knows that if the launch of tests requires a lot of time and effort, no one will do it, so tests should be run with one button or even run on a separate server in a fully automatic mode.  TextTest for this function provides batch execution with the subsequent formation of the report and either uploading it to a format (html, JUnit, Jenkins), or sending it by e-mail. <br><br>  We will upload everything in html.  You only need to configure the folder path to store the results of the tests and the path to store the html reports.  To do this, add in the main config.cfg these lines to the end of the file: <br><pre> <code class="bash hljs">[batch_result_repository] default:batchresult [historical_report_location] default:historicalreport</code> </pre><br>  There you can specify quite a few additional parameters, I will not dwell on them, here is a <a href="http://texttest.sourceforge.net/index.php%3Fpage%3Ddocumentation_3_24%26n%3Drunning_texttest_unattended">link</a> to the documentation on the batch mode. <br>  To run the tests automatically, you need to start the texttest.py module with the "-b nightjob" parameters, like this: <br><pre> <code class="bash hljs">python c:\TextTest\texttest-3.24\<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>\bin\texttest.py -b nightjob</code> </pre><br>  Again, for the command line, there are also a bunch of parameters, <a href="http://texttest.sourceforge.net/index.php%3Fpage%3Ddocumentation_3_24%26n%3Doptions_default">here</a> you can read more. <br>  After the execution, a new batchresult with the results will appear next to the simpletests folder, of which it is already possible to generate a report in the form of html by adding the "-coll web" parameter: <br><pre> <code class="bash hljs">python c:\TextTest\texttest-3.24\<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>\bin\texttest.py -b nightjob -coll web</code> </pre><br>  now there will be another historicalreport folder in which lies the html page with the results.  After several days of work, it may look like this: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/9ce/bee/148/9cebee1482f46280744fdb6e43010747.png" alt="Test results"></div><br>  Well, or you can look at the test results of <a href="http://texttest.sourceforge.net/index.php%3Fpage%3Dnightjob">TextTest</a> itself.  So, by the way, quite interesting statistics - about 4,000 tests are run daily, and the test coverage, almost all modules approach 100% (although I certainly understand that the percentage of coverage in itself means little). <br><br><h4>  Let's sum up </h4><br><h5>  pros </h5><br>  Let's try to sum up the positive aspects of the framework, mainly from the point of view of GUI testing: <br><ul><li>  Cross-platform, cross-library (meaning GUI libraries PyGTK, Tkinter, etc.), even partially cross-language support (the author often mentions working with Java, though I don‚Äôt know how convenient it is) <br><br></li><li>  Free and open source. <br><br></li><li>  The activity of the author in the development of the framework, which is surprising for a 10-year project. <br><br></li><li>  After initial setup - easy to use. <br><br></li><li>  A lot of work has been done to make it possible for non-programmers to use the product, and to make the tests themselves human-readable. <br><br></li><li>  To test the GUI, not the operating system API is used, but the toolkit API itself (PyGTK, Tkinter, etc.), which makes integration as complete as possible and at the same time simple. <br><br></li><li>  Allows you to test the logic of work, abstracting from the appearance. <br><br></li><li>  Quite flexible, when faced with a problem, you can almost always climb through the documentation and find how to fix everything by setting it up. <br><br></li><li>  Allows you to integrate with popular bugtrackers (Bugzilla, Jira, Trac), version control systems (CVS, Bazaar, Mercurial), and upload work results in formats (html, JUnit, Jenkins) or send by mail.  And add integration with other systems, it seems not very difficult.  Although I confess, I have not tried yet how well he knows how to work with all these systems. </li></ul><br><br><h5>  Minuses </h5><br>  It would be wrong not to mention the cons, especially since they are: <br><ul><li>  The first is a GUI, it is quite a bit functional, the settings for the parameters are mainly made not through it, but through the documentation + manual editing of configs.  For the sake of fairness, it‚Äôs necessary to say that the adjustment is performed once, and then we only rivet the type tests.  But at the initial stage of the study there is very little opportunity to quickly arrange the checkboxes and start working to understand what's what. <br><br></li><li>  The stability of the GUI, sometimes it falls, I don‚Äôt even know where it belongs, either to the work of PyGTK, or to the weak testing under Windows, but the fact remains.  But again, the GUI is used only when creating a test, and then it is run many times and I did not observe any problems with the latter. <br><br></li><li>  Sometimes there are errors and you have to go into the code to understand what happened (I gave an example with the virtual_display_count parameter.) However, everything that I came across in one way or another is solved, especially since the source is open and you can always see what needs to be corrected.  Here again, I sin on Windows, it seems the author is more interested in working under UNIX systems, I hope there are no such problems. <br><br></li><li>  Documentation.  Maybe it's me, but I have to read the documentation very, very thoughtfully, several times to understand how the next thing works.  Some understandable things are painted very well, and in complex ones nuances are missed.  The available documentation is quite convenient to use as a reference book, but only after you understand how this or that thing works. <br><br></li><li>  Community  Here things are really bad, on the Russian Internet in general, everyone is silent about the framework, the maximum mention that it exists.  In English, all I found was stories about ideology and how good it is.  Any sensible descriptions, manuals, articles, etc.  I did not find everything on the author‚Äôs site.  I can‚Äôt explain this fact in any way, the framework looks very mature, interesting and ‚Äútasty‚Äù, there are practically no alternatives, I don‚Äôt understand what‚Äôs wrong with it. <br><br></li><li>  It is hosted on a launchpad, and not on the popular GitHub today, I am afraid that this fact will alienate many who have the desire and ability to help the author in writing the code. </li></ul><br><br><h5>  Alternatives </h5><br>  The description would not be complete if you did not specify alternatives for testing the GUI in python, this is what was found: <br><br>  <a href="http://code.google.com/p/robotframework/">robotframework</a> say <a href="http://code.google.com/p/robotframework/">something</a> definite about him is difficult, it is very extensive and you need to read the documentation and try for a long time and thoughtfully.  Apparently, this is a cross-platform framework for testing the TextTest level and it is definitely worth seeing for everyone who chooses a tool for himself. <br><br>  <a href="http://ldtp.freedesktop.org/wiki/">ldtp is the</a> next GUI testing tool.  It has three implementations. <br>  LDTP / Cobra / PyATOM for Linux / Windows / OS X respectively.  It supports a bunch of languages ‚Äã‚Äã(Java / Ruby / C #, etc.) including the Python we need.  I liked the documentation.  Actively developing. <br>  Not only liked the principle, judging by the description of the tests are written something like this: <br><pre> <code class="python hljs">selectmenuitem(<span class="hljs-string"><span class="hljs-string">'frmUnsavedDocument1-gedit'</span></span>, <span class="hljs-string"><span class="hljs-string">'mnuFile;mnuOpen'</span></span>) settextvalue(<span class="hljs-string"><span class="hljs-string">'frmUnsavedDocument1-gedit'</span></span>, <span class="hljs-string"><span class="hljs-string">'txt0'</span></span>, <span class="hljs-string"><span class="hljs-string">'Testing editing'</span></span>) setcontext(<span class="hljs-string"><span class="hljs-string">'Unsaved Document 1 - gedit'</span></span>, <span class="hljs-string"><span class="hljs-string">'*Unsaved Document 1 - gedit'</span></span>) verifytoggled(<span class="hljs-string"><span class="hljs-string">'dlgOpenFile...'</span></span>, <span class="hljs-string"><span class="hljs-string">'tbtnTypeafilename'</span></span>)</code> </pre><br>  those.  the element with the necessary heading is searched for and the necessary action is performed on it or the state is read.  That after TextTest seems to be a step backwards, but if something does not work out with the latter, then ldtp will be one of the first candidates for the transition. <br><br>  <a href="http://pywinauto.sourceforge.net/">pywinauto</a> about him and in Habr√© you can find a <a href="http://habrahabr.ru/post/138963/">few words</a> .  The principle is the same as in ldtp - we find the element we need and do something with it.  Yes, and it works only under Windows. <br><br>  <a href="https://fedorahosted.org/dogtail/">Dogtail</a> judging by the description is very tied to Unix, there are even separate versions for ‚ÄúGNOME 3, KDE4.8‚Äù and for ‚ÄúGnome 2‚Äù, so it looks like it uses the graphical shells for testing the API, which means it is not cross-platform.  However, it is still evolving, so if something needs to be tested under Unix, it is probably worth looking in its direction. <br><br>  <a href="http://pypi.python.org/pypi/guitest">The guitest</a> library for testing GUI applications in python applications, mainly for pyGTK.  Last release date is 13/11/2005.  I'm afraid that after spending so many years without development, she will not be able to test the applications announced by pyGTK, not to mention the required Tkinter.  Did not even look. <br><br>  <a href="http://sourceforge.net/projects/uncassist/files/">pyAA is</a> another abandoned project, abandoned since 2005, and it‚Äôs scary to get involved in it, and it works only with Windows ... <br><br>  <a href="http://sourceforge.net/projects/pyguiunit/">pyGUIUnit</a> by reference states that the library can test PyQt applications.  If you go to the documentation, we see that the whole framework consists of one class and two functions, skimming through which - you can understand that nothing good can be expected. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus, there is still a fairly large number of common testing frameworks that allow you to test any application through screenshots, I described above what they are uncomfortable and therefore did not even consider, besides most of them work only on Windows. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total: cross-platform frameworks for testing GUI logic in python with Tkinter support are surprisingly few, most of them are abandoned and forgotten. </font><font style="vertical-align: inherit;">Those 2-3, which are worth it to look at them, not a fact that fit. </font><font style="vertical-align: inherit;">TextTest so far, in my opinion - the perfect choice, let's see what happens next.</font></font></div><p>Source: <a href="https://habr.com/ru/post/165833/">https://habr.com/ru/post/165833/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165813/index.html">Browser online game with jQuery, CoffeeScript, SVG and node.JS</a></li>
<li><a href="../165819/index.html">Sawing Adblock</a></li>
<li><a href="../165823/index.html">Prevent reading model properties in ASP.NET MVC</a></li>
<li><a href="../165825/index.html">We place up to 2000 units (XNA)</a></li>
<li><a href="../165829/index.html">Media cafe (PureView-cafe) as a model of small film distribution</a></li>
<li><a href="../165837/index.html">Google has invested 200 million dollars in a wind farm</a></li>
<li><a href="../165839/index.html">Licensed software for educational institutions. Free and not quite</a></li>
<li><a href="../165841/index.html">Interested in the brain / AI: links to read</a></li>
<li><a href="../165843/index.html">I'll give you a phone</a></li>
<li><a href="../165845/index.html">Click-n-fire interface - sniper rifle with Linux on board</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>