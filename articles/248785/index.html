<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fundamentals of graphics programming on Apple Metal: Getting started</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My post today is a guide for beginners to program graphics on the Apple Metal API. When I started to deal with this topic, it turned out tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fundamentals of graphics programming on Apple Metal: Getting started</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/525/22b/fce/52522bfce5b143139d8d6b111c19a684.png" alt="image" align="right">  Hi, Habr!  My post today is a guide for beginners to program graphics on the Apple Metal API.  When I started to deal with this topic, it turned out that in addition to Apple‚Äôs documentation and examples from them, there‚Äôs really nothing to watch.  Today I will talk about how to create a simple application on Metal, which displays a three-dimensional cube with lighting.  Then we will draw several cubes using one of the main Metal chips - rendering in several streams.  Interested please under the cat. <br><a name="habracut"></a><br><br><h4>  Demo application </h4><br>  In order to run the <a href="https://github.com/rokuz/MetalDemo">demo</a> , we need a Mac, Xcode 6, as well as a device with an A7 processor (starting with iPad Air 2013 and iPhone 5S).  Unfortunately, the launch of the application for Metal is impossible on the emulator.  The last limitation implies the need to have a valid subscription to an iOS developer program.  I understand that these are not small requirements for the simple curious, and, of course, I do not urge you to buy any of the above.  However, if the stars are such that you have everything you need, I will be glad to learn about forks from my repository and your own experiments with Metal. <br>  In addition, when reading this manual, I strongly recommend in parallel to look at the code of the demo, it will greatly improve the understanding of what is happening. <br><br><h4>  Introduction </h4><br>  I am not in favor of adding <a href="https://developer.apple.com/metal/">official documents</a> to posts, so let's talk about the nature of Metal in simple words.  Apple talked a lot about why Metal is cooler than OpenGL ES (there was a bit of that in <a href="http://habrahabr.ru/post/226329/">Habr√©</a> ).  From all this, I would single out only 2 key advantages: <br><ol><li>  In Metal, the amount of command-line runtime validations for the GPU was significantly reduced by transferring validation at the time the application was loaded or at the time of compilation.  This is how cached state objects appeared.  The idea, frankly, is not new, state objects we saw back in Direct3D 10. Thus, in the Metal API, you can pre-prepare and cache almost any states of the graphics pipeline. </li><li>  Possibility of parallel calculation and filling of command buffers.  The idea here is to pass on to the application developer the process of filling in the command queue for the GPU, since no one better than the developer knows how his scene is rendered, what can be done in parallel and what cannot.  At the same time, when working with Metal API in several threads, you should not be afraid to get bogged down in the threads synchronization processes, the API is designed to simplify the developer‚Äôs life as much as possible (or at least not cause an instant panic attack). </li></ol><br>  To start working with Metal, you can create a new project like ‚ÄúGame‚Äù in Xcode 6, then select Metal as the rendering method in the project creation wizard and ... everything.  Xcode will generate a template project that will draw the cube.  That's how I started creating my demo, since the standard template project did not suit me. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Step 1. We draw a cube with lighting. </h4><br>  The result of this step will be an application in which a single-color cube will be displayed, lit using the Blin model.  The application will also have an arcball camera that will allow us to rotate around an object with the <i>Swipe</i> gesture and zoom in / out with the <i>Zoom</i> gesture. <br>  In the standard Apple template, all the application logic is concentrated in the custom ViewController.  I selected 2 classes: <i>RenderView</i> and <i>RenderViewContoller</i> .  The first class is a successor from <i>UIView</i> and is responsible for the initialization of Metal and its bundle with Core Animation.  The second class contains the graphical demo itself and a certain amount of infrastructure code for handling the minimization / deployment situations of the application and user input.  It would be more appropriate to create a <i>RenderModel</i> class and render the logic of the graphic demo there.  Perhaps we will do so when the complexity of the program increases. <br>  It is appropriate to mention in what language we will create the application.  I chose Objective-C ++, which allowed me to include in classes written in pure C ++ into the project.  There is also the possibility to use Swift (a good article in English about this can be read <a href="http://www.raywenderlich.com/81399/ios-8-metal-tutorial-swift-moving-to-3d">here</a> ). <br><br><h5>  RenderView implementation </h5><br>  It is unlikely that anyone will be surprised to learn that Metal is closely connected with Core Animation, the system that controls graphics and animation in iOS.  Apple has prepared a special <i>CAMetalLayer</i> layer for embedding Metal in iOS <i>apps</i> .  This layer will be used by our <i>RenderView</i> .  The RenderView will initialize as follows: <br><br><pre><code class="objectivec hljs">+ (Class)layerClass { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">CAMetalLayer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)initCommon { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.opaque = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.backgroundColor = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; _metalLayer = (<span class="hljs-built_in"><span class="hljs-built_in">CAMetalLayer</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer; _device = <span class="hljs-built_in"><span class="hljs-built_in">MTLCreateSystemDefaultDevice</span></span>(); _metalLayer.device = _device; _metalLayer.pixelFormat = <span class="hljs-built_in"><span class="hljs-built_in">MTLPixelFormatBGRA8Unorm</span></span>; _metalLayer.framebufferOnly = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; _sampleCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; _depthPixelFormat = <span class="hljs-built_in"><span class="hljs-built_in">MTLPixelFormatDepth32Float</span></span>; _stencilPixelFormat = <span class="hljs-built_in"><span class="hljs-built_in">MTLPixelFormatInvalid</span></span>; }</code> </pre> <br>  In this code, it is easy to find the common with other graphic APIs: create the root API class ( <i>MTLDevice</i> in this case), choose the formats of the back buffer and the depth buffer, choose the number of samples for multisampling.  Directly creating the back buffer and depth buffer textures is done on request.  This is due to the peculiarity of the Metal and Core Animation bundles.  When Core Animation allows drawing on the device‚Äôs screen, it returns a non-zero <i>CAMetalDrawable</i> that is associated with the device‚Äôs screen.  If the user minimizes the application, then we must take care to stop any rendering, since in this case <i>CAMetalDrawable</i> for this application will be zero (hello, Direct3D 9 and <i>D3DERR_DEVICELOST</i> ).  In addition, when the device transitions from Portrait to Landscape and vice versa, it is necessary to reinitialize textures for the back buffer, depth buffer, and stencil. <br>  At each frame, the <i>MTLRenderPassDescriptor</i> object is re- <i>formed</i> .  This object links the back buffer texture obtained from the current <i>CAMetalDrawable</i> with the desired rendering parameters.  Also in this object are specified actions that can be additionally carried out before and after rendering.  For example, <i>MTLStoreActionMultisampleResolve</i> says that after rendering to a texture with multisampling it is necessary to transform this texture (resolve) to the usual form.  <i>MTLLoadActionClear</i> allows you to clear the back buffer / depth buffer / stencil buffer before drawing a new frame. <br>  The code for creating and re-initializing the back buffer, depth buffer and stencil buffer can be found under the cut. <br><br><div class="spoiler">  <b class="spoiler_title">Code to create and re-initialize textures</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setupRenderPassDescriptorForTexture:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLTexture</span></span>&gt;)texture { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_renderPassDescriptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) _renderPassDescriptor = [<span class="hljs-built_in"><span class="hljs-built_in">MTLRenderPassDescriptor</span></span> renderPassDescriptor]; <span class="hljs-comment"><span class="hljs-comment">// init/update default render target MTLRenderPassColorAttachmentDescriptor* colorAttachment = _renderPassDescriptor.colorAttachments[0]; colorAttachment.texture = texture; colorAttachment.loadAction = MTLLoadActionClear; colorAttachment.clearColor = MTLClearColorMake(0.0f, 0.0f, 0.0f, 1.0f); if(_sampleCount &gt; 1) { BOOL doUpdate = (_msaaTexture.width != texture.width) || ( _msaaTexture.height != texture.height) || ( _msaaTexture.sampleCount != _sampleCount); if(!_msaaTexture || (_msaaTexture &amp;&amp; doUpdate)) { MTLTextureDescriptor* desc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat: MTLPixelFormatBGRA8Unorm width: texture.width height: texture.height mipmapped: NO]; desc.textureType = MTLTextureType2DMultisample; desc.sampleCount = _sampleCount; _msaaTexture = [_device newTextureWithDescriptor: desc]; _msaaTexture.label = @"Default MSAA render target"; } colorAttachment.texture = _msaaTexture; colorAttachment.resolveTexture = texture; colorAttachment.storeAction = MTLStoreActionMultisampleResolve; } else { colorAttachment.storeAction = MTLStoreActionStore; } // init/update default depth buffer if(_depthPixelFormat != MTLPixelFormatInvalid) { BOOL doUpdate = (_depthTexture.width != texture.width) || (_depthTexture.height != texture.height) || (_depthTexture.sampleCount != _sampleCount); if(!_depthTexture || doUpdate) { MTLTextureDescriptor* desc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat: _depthPixelFormat width: texture.width height: texture.height mipmapped: NO]; desc.textureType = (_sampleCount &gt; 1) ? MTLTextureType2DMultisample : MTLTextureType2D; desc.sampleCount = _sampleCount; _depthTexture = [_device newTextureWithDescriptor: desc]; _depthTexture.label = @"Default depth buffer"; MTLRenderPassDepthAttachmentDescriptor* depthAttachment = _renderPassDescriptor.depthAttachment; depthAttachment.texture = _depthTexture; depthAttachment.loadAction = MTLLoadActionClear; depthAttachment.storeAction = MTLStoreActionDontCare; depthAttachment.clearDepth = 1.0; } } // init/update default stencil buffer if(_stencilPixelFormat != MTLPixelFormatInvalid) { BOOL doUpdate = (_stencilTexture.width != texture.width) || (_stencilTexture.height != texture.height) || (_stencilTexture.sampleCount != _sampleCount); if (!_stencilTexture || doUpdate) { MTLTextureDescriptor* desc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat: _stencilPixelFormat width: texture.width height: texture.height mipmapped: NO]; desc.textureType = (_sampleCount &gt; 1) ? MTLTextureType2DMultisample : MTLTextureType2D; desc.sampleCount = _sampleCount; _stencilTexture = [_device newTextureWithDescriptor: desc]; _stencilTexture.label = @"Default stencil buffer"; MTLRenderPassStencilAttachmentDescriptor* stencilAttachment = _renderPassDescriptor.stencilAttachment; stencilAttachment.texture = _stencilTexture; stencilAttachment.loadAction = MTLLoadActionClear; stencilAttachment.storeAction = MTLStoreActionDontCare; stencilAttachment.clearStencil = 0; } } }</span></span></code> </pre></div></div><br>  The <i>render</i> method of the <i>RenderView</i> class will be called per frame from the <i>RenderViewController</i> . <br><br><h5>  RenderViewController implementation </h5><br>  The description of the implementation of this class will begin with the infrastructure part.  In order to call the method for rendering a frame from the <i>RenderView</i> , we need a timer, a <i>CADisplayLink</i> object of the class, which we initialize as follows: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)startTimer { _timer = [<span class="hljs-built_in"><span class="hljs-built_in">CADisplayLink</span></span> displayLinkWithTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(_renderloop)]; [_timer addToRunLoop:[<span class="hljs-built_in"><span class="hljs-built_in">NSRunLoop</span></span> mainRunLoop] forMode:<span class="hljs-built_in"><span class="hljs-built_in">NSDefaultRunLoopMode</span></span>]; }</code> </pre><br>  It is important to note that we will stop the timer when the application is minimized and resume when expanded.  To do this, I forward calls to <i>applicationDidEnterBackground</i> and <i>applicationWillEnterForeground</i> from the <i>AppDelegate</i> in the <i>RenderViewContoller</i> .  This ensures that our application does not attempt to render anything when it is minimized and does not fall for this reason. <br>  In addition, we initialize a special semaphore ( <i>dispatch_semaphore_t _inflightSemaphore</i> ).  This will allow us to avoid the so-called GPU Bound, that is, a situation when the CPU is waiting for the graphics processor to form the next frame.  We will allow our CPU to prepare several frames in advance (up to 3 frames in our case) to minimize our idle time while waiting for the GPU.  The semaphore technique will be discussed further. <br>  We will intercept user input using the implementation of the <i>touchesBegan</i> , <i>touchesMoved</i> and <i>touchesEnded methods</i> .  The movements of one or several fingers across the screen will be transmitted to the <i>ArcballCamera</i> class, which will convert these movements into turns and movements of the camera. <br>  Reaction code for user input under the cat. <br><br><div class="spoiler">  <b class="spoiler_title">Reaction to user input</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)touchesBegan:(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *)touches withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>* touchesArray = [touches allObjects]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touches.count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!camera.isRotatingNow()) { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> pos = [touchesArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] locationInView: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view]; camera.startRotation(pos.x, pos.y); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// here we put second finger simd::float2 lastPos = camera.getLastFingerPosition(); camera.stopRotation(); CGPoint pos = [touchesArray[0] locationInView: self.view]; float d = vector_distance(simd::float2 { (float)pos.x, (float)pos.y }, lastPos); camera.startZooming(d); } } else if (touches.count == 2) { CGPoint pos1 = [touchesArray[0] locationInView: self.view]; CGPoint pos2 = [touchesArray[1] locationInView: self.view]; float d = vector_distance(simd::float2 { (float)pos1.x, (float)pos1.y }, simd::float2 { (float)pos2.x, (float)pos2.y }); camera.startZooming(d); } } - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { NSArray* touchesArray = [touches allObjects]; if (touches.count != 0 &amp;&amp; camera.isRotatingNow()) { CGPoint pos = [touchesArray[0] locationInView: self.view]; camera.updateRotation(pos.x, pos.y); } else if (touches.count == 2 &amp;&amp; camera.isZoomingNow()) { CGPoint pos1 = [touchesArray[0] locationInView: self.view]; CGPoint pos2 = [touchesArray[1] locationInView: self.view]; float d = vector_distance(simd::float2 { (float)pos1.x, (float)pos1.y }, simd::float2 { (float)pos2.x, (float)pos2.y }); camera.updateZooming(d); } } - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { camera.stopRotation(); camera.stopZooming(); }</span></span></code> </pre></div></div><br>  You can read about the theory of the implementation of arcball cameras <a href="http://en.wikibooks.org/wiki/OpenGL_Programming/Modern_OpenGL_Tutorial_Arcball">here</a> . <br>  Finally, we turn to the logic of the graphical application itself, which is contained in 5 main methods: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)configure:(RenderView*)renderView</code> </pre><br>  Here we configure the view by specifying, for example, the number of samples for multisampling, the formats of the back buffer, the depth buffer, and the stencil. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setupMetal:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLDevice</span></span>&gt;)device</code> </pre><br>  In this method, we create a queue of commands, initialize resources, load shaders, prepare state objects. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)update</code> </pre><br>  Here the frame is updated, the matrices and other parameters for shaders are calculated. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)render:(RenderView*)renderView</code> </pre><br>  Here, obviously, the frame itself is rendered. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)resize:(RenderView*)renderView</code> </pre><br>  This method is called when the screen is resized, for example, when turning the device, when the length and width are swapped.  Here it is convenient to calculate, for example, the projection matrix. <br><br>  What are the features when initializing resources and state objects in Metal?  For me, accustomed to the Direct3D 11 API, there was only one serious one.  Since the CPU can manage to send up to 3 frames for rendering before synchronization with the GPU, the buffer size for the constants should be three times larger than usual.  Each of the three frames works with its own piece of constant buffer to eliminate the possibility of data rubbing.  In practice, it looks like this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  uint8_t* bufferPointer = (uint8_t*)[_dynamicUniformBuffer contents] + (sizeof(uniforms_t) * _currentUniformBufferIndex); memcpy(bufferPointer, &amp;_uniform_buffer, sizeof(uniforms_t)); //  [renderEncoder setVertexBuffer:_dynamicUniformBuffer offset:(sizeof(uniforms_t) * _currentUniformBufferIndex) atIndex:1 ];</span></span></code> </pre><br>  Perhaps, it is worth mentioning about the <i>MTLRenderPipelineDescriptor</i> and <i>MTLRenderPipelineState classes</i> , which are defined by the state of the graphics pipeline and the state object itself.  This object includes links to the vertex and pixel shaders, the number of multisample samples, the format of the back buffer and the depth buffer.  Stop, it seems, we have already asked it somewhere.  Everything is exactly as it seems.  This state is sharpened for quite specific rendering parameters, and under other circumstances it cannot be used.  By creating such an object in advance (and validating) we eliminate the graphic pipeline from having to check parameter compatibility errors during rendering, the pipeline either accepts the entire state or completely rejects it. <br>  The initialization code for Metal is shown below. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setupMetal:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLDevice</span></span>&gt;)device { _commandQueue = [device newCommandQueue]; _defaultLibrary = [device newDefaultLibrary]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> loadAssets: device]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)loadAssets:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLDevice</span></span>&gt;)device { _dynamicUniformBuffer = [device newBufferWithLength:MAX_UNIFORM_BUFFER_SIZE options:<span class="hljs-number"><span class="hljs-number">0</span></span>]; _dynamicUniformBuffer.label = <span class="hljs-string"><span class="hljs-string">@"Uniform buffer"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLFunction</span></span>&gt; fragmentProgram = [_defaultLibrary newFunctionWithName:<span class="hljs-string"><span class="hljs-string">@"psLighting"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLFunction</span></span>&gt; vertexProgram = [_defaultLibrary newFunctionWithName:<span class="hljs-string"><span class="hljs-string">@"vsLighting"</span></span>]; _vertexBuffer = [device newBufferWithBytes:(Primitives::cube()) length:(Primitives::cubeSizeInBytes()) options:<span class="hljs-built_in"><span class="hljs-built_in">MTLResourceOptionCPUCacheModeDefault</span></span>]; _vertexBuffer.label = <span class="hljs-string"><span class="hljs-string">@"Cube vertex buffer"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// pipeline state MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init]; pipelineStateDescriptor.label = @"Simple pipeline"; [pipelineStateDescriptor setSampleCount: ((RenderView*)self.view).sampleCount]; [pipelineStateDescriptor setVertexFunction:vertexProgram]; [pipelineStateDescriptor setFragmentFunction:fragmentProgram]; pipelineStateDescriptor.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm; pipelineStateDescriptor.depthAttachmentPixelFormat = MTLPixelFormatDepth32Float; NSError* error = NULL; _pipelineState = [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:&amp;error]; if (!_pipelineState) { NSLog(@"Failed to created pipeline state, error %@", error); } MTLDepthStencilDescriptor *depthStateDesc = [[MTLDepthStencilDescriptor alloc] init]; depthStateDesc.depthCompareFunction = MTLCompareFunctionLess; depthStateDesc.depthWriteEnabled = YES; _depthState = [device newDepthStencilStateWithDescriptor:depthStateDesc]; }</span></span></code> </pre><br>  Finally, consider the most intriguing part of the code rendering frame. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)render:(RenderView*)renderView { dispatch_semaphore_wait(_inflightSemaphore, DISPATCH_TIME_FOREVER); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> update]; <span class="hljs-built_in"><span class="hljs-built_in">MTLRenderPassDescriptor</span></span>* renderPassDescriptor = renderView.renderPassDescriptor; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">CAMetalDrawable</span></span>&gt; drawable = renderView.currentDrawable; <span class="hljs-comment"><span class="hljs-comment">// new command buffer id &lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer]; commandBuffer.label = @"Simple command buffer"; // simple render encoder id &lt;MTLRenderCommandEncoder&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor: renderPassDescriptor]; renderEncoder.label = @"Simple render encoder"; [renderEncoder setDepthStencilState:_depthState]; [renderEncoder pushDebugGroup:@"Draw cube"]; [renderEncoder setRenderPipelineState:_pipelineState]; [renderEncoder setVertexBuffer:_vertexBuffer offset:0 atIndex:0 ]; [renderEncoder setVertexBuffer:_dynamicUniformBuffer offset:(sizeof(uniforms_t) * _currentUniformBufferIndex) atIndex:1 ]; [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:36 instanceCount:1]; [renderEncoder popDebugGroup]; [renderEncoder endEncoding]; __block dispatch_semaphore_t block_sema = _inflightSemaphore; [commandBuffer addCompletedHandler:^(id&lt;MTLCommandBuffer&gt; buffer) { dispatch_semaphore_signal(block_sema); }]; _currentUniformBufferIndex = (_currentUniformBufferIndex + 1) % MAX_INFLIGHT_BUFFERS; [commandBuffer presentDrawable:drawable]; [commandBuffer commit]; }</span></span></code> </pre><br>  At the beginning of the method, <i>dispatch_semaphore_wait</i> is called, which stops the frame calculation on the CPU until the GPU finishes with one of the current frames.  As I said, in our CPU demo it is allowed to count up to 3 frames while the GPU is busy.  The semaphore is released in the <i>addCompletedHandler</i> method of the <i>commandBuffer</i> command <i>buffer</i> .  The command buffer is designed as a lightweight (transient) object, that is, it must be created every frame and cannot be reused. <br>  Each frame for a specific buffer creates a so-called render instruction encoder (in this case, an object of class <i>MTLRenderCommandEncoder</i> ).  When creating it, an object of the <i>MTLRenderPassDescriptor</i> class is <i>used</i> , which we discussed above.  This object allows you to fill the buffer with commands of various kinds (setting states, vertex buffers, calls to primitive drawing methods, i.e., everything that is familiar from other graphical APIs).  Upon completion of the filling for the command buffer, the <i>commit</i> method is called, which sends this buffer to the queue. <br>  There is nothing unusual in shader code, an elementary implementation of Blinn lighting.  For Metal, Apple engineers came up with their own shader language, which is not very different from HLSL, GLSL and Cg.  Those who have written shaders at least once in one of the languages ‚Äã‚Äãlisted will easily use this language as well, for the rest I recommend the <a href="https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/Introduction/Introduction.html">Apple language guide</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Shader Code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#include &lt;metal_stdlib&gt; #include &lt;simd/simd.h&gt; using namespace metal; constant float3 lightDirection = float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.7</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>); constant float3 ambientColor = float3(<span class="hljs-number"><span class="hljs-number">0.18</span></span>, <span class="hljs-number"><span class="hljs-number">0.24</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); constant float3 diffuseColor = float3(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); constant float3 specularColor = float3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>); constant float specularPower = <span class="hljs-number"><span class="hljs-number">30.0</span></span>; typedef struct { float4x4 modelViewProjection; float4x4 model; float3 viewPosition; } uniforms_t; typedef struct { packed_float3 position; packed_float3 normal; packed_float3 tangent; } vertex_t; typedef struct { float4 position <span class="hljs-string"><span class="hljs-string">[[position]]</span></span>; float3 tangent; float3 normal; float3 viewDirection; } ColorInOut; // Vertex shader <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertex</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorInOut</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vsLighting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device vertex_t* vertex_array [[ buffer(0)</span></span></span></span> ]], constant uniforms_t&amp; uniforms <span class="hljs-string"><span class="hljs-string">[[ buffer(1) ]]</span></span>, unsigned int vid <span class="hljs-string"><span class="hljs-string">[[ vertex_id ]]</span></span>) { ColorInOut out; float4 in_position = float4(float3(vertex_array[vid].position), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); out.position = uniforms.modelViewProjection * in_position; float4x4 m = uniforms.model; m[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = m[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = m[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; // suppress translation component out.normal = (m * float4(normalize(vertex_array[vid].normal), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).xyz; out.tangent = (m * float4(normalize(vertex_array[vid].tangent), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).xyz; float3 worldPos = (uniforms.model * in_position).xyz; out.viewDirection = normalize(worldPos - uniforms.viewPosition); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out; } // Fragment shader <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">half4</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">psLighting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ColorInOut in [[stage_in]])</span></span></span></span> { float3 normalTS = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); float3 lightDir = normalize(lightDirection); float3x3 ts = float3x3(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.tangent, cross(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.normal, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.tangent), <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.normal); float3 normal = -normalize(ts * normalTS); float ndotl = fmax(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(lightDir, normal)); float3 diffuse = diffuseColor * ndotl; float3 h = normalize(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.viewDirection + lightDir); float3 specular = specularColor * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span> (fmax(dot(normal, h), <span class="hljs-number"><span class="hljs-number">0.0</span></span>), specularPower); float3 finalColor = saturate(ambientColor + diffuse + specular); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> half4(float4(finalColor, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); }</code> </pre> </div></div><br>  As a result, the following can be seen on the screen of our device. <br><br><img src="https://habrastorage.org/files/1be/528/541/1be52854189247e591e904e73086a4fb.png"><br><br>  This concludes the first step of the guide.  The code for this step is available in the git repository under the <i>tutorial_1_1</i> tag. <br><br><h4>  Step 2. We draw some cubes. </h4><br>  In order to draw several cubes, you need to change our constant buffer.  Previously, it stored the parameters (the matrix of the world-view-projection, the matrix of the world and the camera position) for only one object, now this data must be set for all objects.  Obviously, the camera position is enough to transfer once, for this you need an additional constant buffer for parameters that are calculated 1 time per frame.  However, I have not yet started a separate buffer for one vector, we will do it the next time when the number of parameters increases.  You can try to do it yourself now.  Thus, for 5 cubes, we will have 5 sets of parameters for each of the 3 frames, which the CPU can manage to calculate, until it is synchronized with the GPU. <br>  We will change the rendering method as follows: <br><br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">MTLRenderCommandEncoder</span></span>&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor: renderPassDescriptor]; renderEncoder.label = <span class="hljs-string"><span class="hljs-string">@"Simple render encoder"</span></span>; [renderEncoder setDepthStencilState:_depthState]; [renderEncoder pushDebugGroup:<span class="hljs-string"><span class="hljs-string">@"Draw cubes"</span></span>]; [renderEncoder setRenderPipelineState:_pipelineState]; [renderEncoder setVertexBuffer:_vertexBuffer offset:<span class="hljs-number"><span class="hljs-number">0</span></span> atIndex:<span class="hljs-number"><span class="hljs-number">0</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; CUBE_COUNTS; i++) { [renderEncoder setVertexBuffer:_dynamicUniformBuffer offset:(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_uniform_buffer) * _currentUniformBufferIndex + i * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(uniforms_t)) atIndex:<span class="hljs-number"><span class="hljs-number">1</span></span> ]; [renderEncoder drawPrimitives:<span class="hljs-built_in"><span class="hljs-built_in">MTLPrimitiveTypeTriangle</span></span> vertexStart:<span class="hljs-number"><span class="hljs-number">0</span></span> vertexCount:<span class="hljs-number"><span class="hljs-number">36</span></span> instanceCount:<span class="hljs-number"><span class="hljs-number">1</span></span>]; } [renderEncoder popDebugGroup]; [renderEncoder endEncoding];</code> </pre><br><br>  I want to draw your attention to the calculation of the displacement in a constant buffer ( <i>sizeof (_uniform_buffer) * _currentUniformBufferIndex + i * sizeof (uniforms_t)</i> ).  The <i>_currentUniformBufferIndex</i> variable determines the block corresponding to the current frame, and the counter <i>i</i> determines where the data for a specific cube is located. <br>  As a result, we get something like this. <br><br><img src="//habrastorage.org/files/56d/9e1/352/56d9e13523c54daa961d74beb67246df.png"><br><br>  The code for this step is available in the git repository under the <i>tutorial_1_2</i> tag. <br><br><h4>  Step 3. We draw several cubes in several streams. </h4><br>  We can also draw cubes in one stream on OpenGL ES, now we will add to the demo the filling of the command buffer in several streams.  Let half the dice be rendered in one stream and the other half in the other.  An example, of course, purely academic, we will not get any performance gain from this. <br>  For multi-threaded command buffer filling in Metal API there is a special class <i>MTLParallelRenderCommandEncoder</i> .  This class allows you to create as many objects of the <i>MTLRenderCommandEncoder</i> class, which we already know from the previous steps.  Each of these objects allows you to execute code by filling the buffer with commands in a separate thread. <br>  Using <i>dispatch_async</i> , we will start rendering half of the cubes in a separate stream, the second half will be rendered in the main stream.  As a result, we get the following code: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)render:(RenderView*)renderView { dispatch_semaphore_wait(_inflightSemaphore, DISPATCH_TIME_FOREVER); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> update]; <span class="hljs-built_in"><span class="hljs-built_in">MTLRenderPassDescriptor</span></span>* renderPassDescriptor = renderView.renderPassDescriptor; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">CAMetalDrawable</span></span>&gt; drawable = renderView.currentDrawable; <span class="hljs-comment"><span class="hljs-comment">// new command buffer id &lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer]; commandBuffer.label = @"Simple command buffer"; // parallel render encoder id &lt;MTLParallelRenderCommandEncoder&gt; parallelRCE = [commandBuffer parallelRenderCommandEncoderWithDescriptor:renderPassDescriptor]; parallelRCE.label = @"Parallel render encoder"; id &lt;MTLRenderCommandEncoder&gt; rCE1 = [parallelRCE renderCommandEncoder]; id &lt;MTLRenderCommandEncoder&gt; rCE2 = [parallelRCE renderCommandEncoder]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^ { @autoreleasepool { [self encodeRenderCommands: rCE2 Comment: @"Draw cubes in additional thread" StartIndex: CUBE_COUNTS / 2 EndIndex: CUBE_COUNTS]; } dispatch_semaphore_signal(_renderThreadSemaphore); }); [self encodeRenderCommands: rCE1 Comment: @"Draw cubes" StartIndex: 0 EndIndex: CUBE_COUNTS / 2]; // wait additional thread and finish encoding dispatch_semaphore_wait(_renderThreadSemaphore, DISPATCH_TIME_FOREVER); [parallelRCE endEncoding]; __block dispatch_semaphore_t block_sema = _inflightSemaphore; [commandBuffer addCompletedHandler:^(id&lt;MTLCommandBuffer&gt; buffer) { dispatch_semaphore_signal(block_sema); }]; _currentUniformBufferIndex = (_currentUniformBufferIndex + 1) % MAX_INFLIGHT_BUFFERS; [commandBuffer presentDrawable:drawable]; [commandBuffer commit]; } - (void)encodeRenderCommands:(id &lt;MTLRenderCommandEncoder&gt;)renderEncoder Comment:(NSString*)comment StartIndex:(int)startIndex EndIndex:(int)endIndex { [renderEncoder setDepthStencilState:_depthState]; [renderEncoder pushDebugGroup:comment]; [renderEncoder setRenderPipelineState:_pipelineState]; [renderEncoder setVertexBuffer:_vertexBuffer offset:0 atIndex:0 ]; for (int i = startIndex; i &lt; endIndex; i++) { [renderEncoder setVertexBuffer:_dynamicUniformBuffer offset:(sizeof(_uniform_buffer) * _currentUniformBufferIndex + i * sizeof(uniforms_t)) atIndex:1 ]; [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:36 instanceCount:1]; } [renderEncoder popDebugGroup]; [renderEncoder endEncoding]; }</span></span></code> </pre><br>  To synchronize the main and additional threads, I used the <i>_renderThreadSemaphore</i> semaphore, which synchronizes the two threads just before the <i>endEncoding</i> call on the <i>MTLParallelRenderCommandEncoder</i> class <i>object</i> .  <i>MTLParallelRenderCommandEncoder</i> requires that the <i>endEncoding</i> method be called guaranteed after <i>endEncoding</i> calls on objects of the <i>MTLRenderCommandEncoder</i> class generated by it. <br>  If everything was done correctly, then the result will be the same on the device screen as in the previous step. <br><br>  The code for this step is available in the git repository under the <i>tutorial_1_3</i> tag. <br><br><h4>  Conclusion </h4><br>  Today we looked at the very first steps in graphics programming using the Apple Metal API.  If this topic and this format will be interesting to the community, we will continue further.  In the next series, I plan to draw a more interesting model, we use the index buffer and texture it.  As a ‚Äútrick‚Äù of the lesson there will be something like an instance.  Waiting for your feedback, thank you for your attention. </div><p>Source: <a href="https://habr.com/ru/post/248785/">https://habr.com/ru/post/248785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248769/index.html">Wordpress</a></li>
<li><a href="../248775/index.html">Age of JIT compiling. Part I. Genesis</a></li>
<li><a href="../248777/index.html">Patent Wars. Episode 1. Hidden threat</a></li>
<li><a href="../248779/index.html">When data is really a lot: Vowpal Wabbit</a></li>
<li><a href="../248783/index.html">HTML5 canvas karaoke</a></li>
<li><a href="../248787/index.html">WRL and BindableAttribute</a></li>
<li><a href="../248789/index.html">Developer Stories: Microblink PhotoMath</a></li>
<li><a href="../248793/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ32 (January 19 - 25, 2015)</a></li>
<li><a href="../248797/index.html">When ID is not ID or Mongolian vowel separator attacks</a></li>
<li><a href="../248799/index.html">React JS Quick Start Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>