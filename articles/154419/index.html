<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code injection into .NET CLR: IL code change during program execution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 

 Changing the .NET method of MSIL code during application execution is very cool. This is so cool that you can hook functions, hook up your...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code injection into .NET CLR: IL code change during program execution</h1><div class="post__text post__text-html js-mediator-article"><h1>  Foreword </h1><br><img src="https://habrastorage.org/storage2/98c/bf6/c81/98cbf6c81df8c1c83aa01acf135b16a7.jpg"><br>  Changing the .NET method of MSIL code during application execution is very cool.  This is so cool that you can hook functions, hook up your software and other amazing things.  That is why I have long wanted to accomplish this, but there was one problem - the MSIL code is compiled into machine code using JIT before we can do anything with this code.  And since the .NET CLR is not documented and changes from version to version, we will look for a stable and reliable path, independent of the exact location of addresses in memory. <br><a name="habracut"></a><br>  Finally, after a week of research, I did it.  Your attention is given a simple method: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareOneAndTwo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Number 1 is less than 2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Number 1 is greater than 2 (O_o)"</span></span>; } }</code> </pre> <br>  As you can see, it returns "Number 1 is less than 2".  Let's try to correct this misunderstanding and try to change this method so that the returned result is ‚ÄúNumber 1 is greater than 2 (O_o)‚Äù. <br>  By looking at the MSIL code for this method, we can achieve our goal by replacing the Bge_S opcode with Blt_S. <br><img src="http://habrastorage.org/storage2/f4b/73d/7ba/f4b73d7ba1130866e8aa9b1bcb9b9746.png"><br>  And if you run the demo application, it will show you the wrong result. <br><img src="http://habrastorage.org/storage2/f9d/6be/c2e/f9d6bec2ee0d1c476920deab0cf76806.png"><br>  Below is the code to replace IL.  I think that there is enough comments to understand the code. <br><pre> <code class="hljs pgsql">//    <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=this.GetType(); MethodInfo methodInfo=<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>.GetMethod("CompareOneAndTwo", BindingFlags.NonPublic|BindingFlags.Instance); // ,   ,  //     ,   ,  JIT //     ,       JIT-  :) RuntimeHelpers.PrepareMethod(methodInfo.MethodHandle); //  IL-   byte[] ilCodes=methodInfo.GetMethodBody().GetILAsByteArray(); //       //      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;ilCodes.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ilCodes[i]==OpCodes.Bge_S.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) { // Bge_S  Blt_S ilCodes[i]=(byte)OpCodes.Blt_S.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; } } // IL- InjectionHelper.UpdateILCodes(methodInfo, ilCodes);</code> </pre><br>  You can download the demo program and try it. <br><ul><li>  Supports .NET from 2.0 to 4.0 </li><li>  Supports many types of methods, including dynamic and generic methods. </li><li>  Supports release versions of .NET applications </li><li>  Supports x86 and x64 </li></ul><br><br><h1>  Code use </h1><br>  Copy the InjectionHelper.cs, which contains the necessary methods, into your project. <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> InjectionHelper { // <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> the unmanaged injection.dll, the initlaization happens <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a background thread // you can <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the initialization <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> completed <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GetStatus() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Initialize() // Unload the unmanaged injection.dll <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Uninitialize() // <span class="hljs-keyword"><span class="hljs-keyword">Update</span></span> the IL Code <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> UpdateILCodes(MethodInfo <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>, byte[] ilCodes) // The <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> the initialization <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> completed <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Status WaitForIntializationCompletion() // Query the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> status <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the unmanaged dll, <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> immediately. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Status GetStatus() }</code> </pre><br>  The Injectionhelper :: Initialize method loads injection.dll, consisting of unmanaged code, from the directory in which the assembly resides, so all the files you want to modify should be in the same place.  Or you can fix the source, as you prefer :) <br>  List of files: <br><table><tbody><tr><td>  File name </td><td>  Description </td></tr><tr><td>  Injection32.dll </td><td>  Unmanaged dll performing our task (x86 version) </td></tr><tr><td>  Injection64.dll </td><td>  Unmanaged dll performing our task (version x64) </td></tr><tr><td>  EasyHook32.dll </td><td>  x86 EasyHook DLL (http://easyhook.codeplex.com/) (using Injection32.dll) </td></tr><tr><td>  EasyHook64.dll </td><td>  X64 EasyHook DLL (http://easyhook.codeplex.com/) (used by Injection64.dll) </td></tr><tr><td>  x86 / * </td><td>  Windows Debug Tool for x86 </td></tr><tr><td>  x64 / * </td><td>  Windows Debug Tool for x64 </td></tr><tr><td>  PDB_symbols / * </td><td>  PDB files.  They can be removed, but this will slow initialization. </td></tr></tbody></table><br><br><h1>  Behind the scenes </h1><br>  Let's first take a look at how the CLR and JIT work. <br><img src="http://habrastorage.org/storage2/02f/6a9/bdc/02f6a9bdc2a1d08b20f59e2f4c7491c6.png"><br>  The library describing JIT (clr.dll for .NET 4.0 / mscorwks.dll for .NET 2.0+) provides the _stdcall getJit method, which returns the ICorJitCompiler interface. <br>  A library describing the CLR (clr.dll for .NET 4.0 / mscorwks.dll for .NET 2.0+) calls the getJit method to get the ICorJitCompiler interface <br><pre> <code class="hljs lisp">CorJitResult compileMethod(<span class="hljs-name"><span class="hljs-name">ICorJitInfo</span></span> * pJitInfo, CORINFO_METHOD_INFO * pMethodInfo, UINT nFlags, LPBYTE * pEntryAddress, ULONG * pSizeOfCode)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  This part is easy, you just need to find the address of the compileMethod method and replace it with EasyHook. <br><pre> <code class="hljs markdown">// ICorJitCompiler interface from JIT dll class ICorJitCompiler { public: typedef CorJitResult (<span class="hljs-strong"><span class="hljs-strong">__stdcall ICorJitCompiler::*PFN_compileMethod)(ICorJitInfo * pJitInfo, CORINFO_METHOD_INFO * pMethodInfo, UINT nFlags, LPBYTE * pEntryAddress, ULONG * pSizeOfCode); CorJitResult compileMethod(ICorJitInfo * pJitInfo, CORINFO_METHOD_INFO * pMethodInfo, UINT nFlags, LPBYTE * pEntryAddress, ULONG * pSizeOfCode) { return (this-&gt;*s_pfnComplieMethod)( pJitInfo, pMethodInfo, nFlags, pEntryAddress, pSizeOfCode); } private: static PFN_compileMethod s_pfnComplieMethod; }; //    LPVOID pAddr = tPdbHelper.GetJitCompileMethodAddress(); LPVOID* pDest = (LPVOID*)&amp;ICorJitCompiler::s_pfnComplieMethod; *pDest = pAddr; //    compileMethod CorJitResult __</span></span>stdcall CInjection::compileMethod(ICorJitInfo <span class="hljs-bullet"><span class="hljs-bullet">* pJitInfo , CORINFO_METHOD_INFO *</span></span> pCorMethodInfo , UINT nFlags , LPBYTE <span class="hljs-bullet"><span class="hljs-bullet">* pEntryAddress , ULONG *</span></span> pSizeOfCode ) { ICorJitCompiler <span class="hljs-bullet"><span class="hljs-bullet">* pCorJitCompiler = (ICorJitCompiler *</span></span>)this; // TO DO:  IL-     CorJitResult result = pCorJitCompiler-&gt;compileMethod( pJitInfo, pCorMethodInfo, nFlags, pEntryAddress, pSizeOfCode); return result; } //    JIT-    NTSTATUS ntStatus = LhInstallHook( (PVOID&amp;)ICorJitCompiler::s<span class="hljs-emphasis"><span class="hljs-emphasis">_pfnComplieMethod , &amp;(PVOID&amp;)CInjection::compileMethod , NULL , &amp;s_</span></span>hHookCompileMethod );</code> </pre><br><h1>  Change IL-code for JIT-compiled methods </h1><br>  The compileMethod method described above will not be called by the CLR for the JIT-compiled method.  To solve this problem, I made saving CLR data structures and then restoring them before JIT compilation.  And in this case, as soon as compileMethod is called again, we can replace IL. <br>  Thus, we need to look a little at the implementation of CLR, SSCLI (Shared Source Common Language Infrastructure / Common Language Infrastructure) is a good source of information, but since it is rather outdated, we cannot use it in our code. <br><img src="http://habrastorage.org/storage2/478/0d9/e24/4780d9e24d327883f4ad75e443bb1178.png"><br>  Yes, it is this diagram that is outdated, but the overall structure has been preserved.  Each class in .NET has at least one MethodTable in memory.  And each MethodTable structure is associated with an EEClass that stores runtime information for reflection and other purposes. <br>  For each method, there is at least one MethodDesc structure containing information about flags, slot addresses, input addresses, etc. <br>  Before the method is JIT-compliant, the slot points to the JMI converter, which switches the JIT compilation;  When the IL code is compiled, a pointer to the JMI will be written into the slot, and the code will run directly on the compiled code when executed. <br>  To restore the structure of information, you must first clear the flags, then modify the address of the entry point to a temporary one, etc.  During testing, I did this by changing memory directly.  But this is dirty, at least, because there is a dependence on the addresses of data structures and the code of different .NET versions is different. <br>  I was looking for the right way, and fortunately, I found the MethodDesc :: Reset method in the SSCLI source code (vm / method.cpp). <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> MethodDesc::<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>() { CONTRACTL { THROWS; GC_NOTRIGGER; } CONTRACTL_END //      ,      . //            _ASSERTE(IsEnCMethod() || //     IsDynamicMethod() || GetLoaderModule()-&gt;IsReflection()); //    ClearFlagsOnUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HasPrecode()) { GetPrecode()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //      Reflection- _ASSERTE(GetLoaderModule()-&gt;IsReflection()); InterlockedUpdateFlags2(enum_flag2_HasStableEntryPoint | enum_flag2_HasPrecode, <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>); *GetAddrOfSlotUnchecked() = GetTemporaryEntryPoint(); } _ASSERTE(!HasNativeCode()); }</code> </pre><br>  As you can see, this code does what it takes.  So I just need to call it for MethodDesc before JIT compilation. <br>  Strictly speaking, I cannot use MethodDesc from SSCLI, since MethodDesc is used inside Microsoft, and no one knows what could be causing it. <br>  Fortunately, the address of this internal method exists in the PDB from the Microsoft Symbol server, and this solves my problem.  The address of the Reset () method in the CLR DLL can be found simply by parsing the PDB! <br>  Now one important parameter remains - this is the pointer this to MethodDesc.  Getting it is not so difficult.  In general, MethodBase.MethodHandle.Value == CORINFO_METHOD_HANDLE == address MethodDesc == this pointer to MethodDesc. <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodDesc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodDesc::*PFN_Reset)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOOL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodDesc::*PFN_IsGenericMethodDefinition)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ULONG</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodDesc::*PFN_GetNumGenericMethodArgs)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> MethodDesc * (MethodDesc::*PFN_StripMethodInstantiation)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOOL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodDesc::*PFN_HasClassOrMethodInstantiation)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOOL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodDesc::*PFN_ContainsGenericVariables)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> MethodDesc * (MethodDesc::*PFN_GetWrappedMethodDesc)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> AppDomain * (MethodDesc::*PFN_GetDomain)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Module * (MethodDesc::*PFN_GetLoaderModule)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnReset)(); } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsGenericMethodDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnIsGenericMethodDefinition)(); } <span class="hljs-function"><span class="hljs-function">ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumGenericMethodArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnGetNumGenericMethodArgs)(); } <span class="hljs-function"><span class="hljs-function">MethodDesc * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StripMethodInstantiation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnStripMethodInstantiation)(); } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasClassOrMethodInstantiation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnHasClassOrMethodInstantiation)(); } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsGenericVariables</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnContainsGenericVariables)(); } <span class="hljs-function"><span class="hljs-function">MethodDesc * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWrappedMethodDesc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnGetWrappedMethodDesc)(); } <span class="hljs-function"><span class="hljs-function">AppDomain * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDomain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnGetDomain)(); } <span class="hljs-function"><span class="hljs-function">Module * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLoaderModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnGetLoaderModule)(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_Reset s_pfnReset; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_IsGenericMethodDefinition s_pfnIsGenericMethodDefinition; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_GetNumGenericMethodArgs s_pfnGetNumGenericMethodArgs; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_StripMethodInstantiation s_pfnStripMethodInstantiation; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_HasClassOrMethodInstantiation s_pfnHasClassOrMethodInstantiation; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_ContainsGenericVariables s_pfnContainsGenericVariables; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_GetWrappedMethodDesc s_pfnGetWrappedMethodDesc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_GetDomain s_pfnGetDomain; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PFN_GetLoaderModule s_pfnGetLoaderModule; };</code> </pre><br>  Static variables store the addresses of the internal MethodDesc methods and they are initialized when the unmanaged DLL is loaded.  And public methods just call internal methods. <br>  Now we can easily call Microsoft internal methods: <br><pre> <code class="hljs lisp">MethodDesc * pMethodDesc = (<span class="hljs-name"><span class="hljs-name">MethodDesc*</span></span>)pMethodHandle<span class="hljs-comment"><span class="hljs-comment">; pMethodDesc-&gt;Reset();</span></span></code> </pre><br><h1>  Finding addresses of internal methods in the PDB file </h1><br>  When the unmanaged DLL loads, it checks the version of the CLR / JIT environment in which it is loaded.  And it also tries to get the addresses of the internal methods from the PDB file.  If they could not be found, she will try to start symchk.exe from the Windows Debug Tools in order to download the corresponding PDB files from the Microsoft Symbol server.  This procedure takes quite a long time, from a few seconds to a few minutes.  Perhaps we can speed up this process by caching the address of the CLR / JIT libraries by counting their hashes. <br><h1>  Recovery method to non-JIT compiled </h1><br>  Now everything is ready.  The unmanaged library exports the methods for the managed code, accepts IL codes and MethodBase.MethodHandle.Value from the managed code. <br><pre> <code class="hljs pgsql">// structure <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> store the IL code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> replacement typedef struct _ILCodeBuffer { LPBYTE pBuffer; DWORD dwSize; } ILCodeBuffer, *LPILCodeBuffer; // <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> managed code <span class="hljs-type"><span class="hljs-type">BOOL</span></span> CInjection::StartUpdateILCodes( MethodTable * pMethodTable , CORINFO_METHOD_HANDLE pMethodHandle , mdMethodDef md , LPBYTE pBuffer , DWORD dwSize ) { MethodDesc * pMethodDesc = (MethodDesc*)pMethodHandle; // <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> this MethodDesc pMethodDesc-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(); ILCodeBuffer tILCodeBuffer; tILCodeBuffer.pBuffer = pBuffer; tILCodeBuffer.dwSize = dwSize; tILCodeBuffer.bIsGeneric = <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; // save the IL code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> s_mpILBuffers.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>( std::pair&lt; CORINFO_METHOD_HANDLE, ILCodeBuffer&gt;( pMethodHandle, tILCodeBuffer) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>; }</code> </pre><br>  This code simply calls Reset () and saves the IL codes in the map that the compileMethod will use when the method is compiled. <br>  And in the compileMethod, just replace the IL code: <br><pre> <code class="hljs erlang-repl">CorJitResult __stdcall CInjection::compileMethod(ICorJitInfo * pJitInfo , CORINFO_METHOD_INFO * pCorMethodInfo , UINT nFlags , LPBYTE * pEntryAddress , ULONG * pSizeOfCode ) { ICorJitCompiler * pCorJitCompiler = (ICorJitCompiler *)this; LPBYTE pOriginalILCode = pCorMethodInfo-&gt;ILCode; unsigned int nOriginalSize = pCorMethodInfo-&gt;ILCodeSize; ILCodeBuffer tILCodeBuffer = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; MethodDesc * pMethodDesc = (MethodDesc*)pCorMethodInfo-&gt;ftn; // find the method to be replaced std::map&lt; CORINFO_METHOD_HANDLE, ILCodeBuffer&gt;::iterator iter = s_mpILBuffers.find((CORINFO_METHOD_HANDLE)pMethodDesc); if( iter != s_mpILBuffers.end() ) { tILCodeBuffer = iter-&gt;second; pCorMethodInfo-&gt;ILCode = tILCodeBuffer.pBuffer; pCorMethodInfo-&gt;ILCodeSize = tILCodeBuffer.dwSize; } CorJitResult result = pCorJitCompiler-&gt;compileMethod( pJitInfo, pCorMethodInfo, nFlags, pEntryAddress, pSizeOfCode); return result; }</code> </pre><br><h1>  Generic method </h1><br>  The generic method is mapped in memory in MethodDesc.  But calling the Generic method with different types of parameters can force the CLR to create different entities of the same method. <br>  The line below is a simple generic from the demo program. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> GenericMethodToBeReplaced&lt;T, K&gt;(T t, K k)</code> </pre> <br>  By calling GenericMethodToBeReplaced &lt;string, int&gt; (‚Äú11‚Äù, 2) for the first time, the CLR creates an object of type InstantiatedMethodDesc (child of MethodDesc, and its flag is marked as mcInstantied), which stores in the InstMethodHashTable method data structure. <br>  And by calling GenericMethodToBeReplaced &lt;long, int&gt; (1, 2), the CLR creates another InstantiatedMethodDesc object. <br>  Therefore, we need to find all the InstantiatedMethodDesc generic method and reset it. <br>  In the SSCLI source code (vm / proftoeeinterfaceimpl.cpp) there is a LoadedMethodDescIterator class that we can use.  It takes three parameters as input and searches for methods by method ID (MethodToken). <br><pre> <code class="hljs php">LoadedMethodDescIterator MDIter(ADIter.GetDomain(), pModule, methodId); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(MDIter.Next()) { MethodDesc * pMD = MDIter.Current(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pMD) { _ASSERTE(pMD-&gt;IsIL()); pMD-&gt;SetRVA(rva); } }</code> </pre><br>  Note that the addresses of the constructor, the methods Next, Current we can get from the PDB file. <br><img src="http://habrastorage.org/storage2/a16/745/932/a16745932c0aa4a3295d450dfc5c289b.png"><br>  Not so scary that we do not know the exact size of the LoadedMethodDescIterator, just allocate a large block of memory for its storage. <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LoadedMethodDescIterator</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">private</span></span>: BYTE dummy[<span class="hljs-number"><span class="hljs-number">10240</span></span>]; };</code> </pre><br>  I would also like to note that there have been minor changes in the Next () method when the .NET transitions from version 2.0 to 4.5. <br><pre> <code class="hljs dos">// .<span class="hljs-built_in"><span class="hljs-built_in">Net</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp; <span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LoadedMethodDescIterator(AppDomain * pAppDomain, Module *pModule, mdMethodDef <span class="hljs-built_in"><span class="hljs-built_in">md</span></span>) BOOL LoadedMethodDescIterator::Next(void) // .<span class="hljs-built_in"><span class="hljs-built_in">Net</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> LoadedMethodDescIterator(AppDomain * pAppDomain, Module *pModule, mdMethodDef <span class="hljs-built_in"><span class="hljs-built_in">md</span></span>,enum AssemblyIterationMode <span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>) BOOL LoadedMethodDescIterator::Next(CollectibleAssemblyHolder&lt;DomainAssembly *&gt; *)</code> </pre><br>  Therefore, we need to define the current version of the .NET framework in order to correctly call the method. <br><pre> <code class="hljs pgsql">// detect the <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> CLR <span class="hljs-type"><span class="hljs-type">BOOL</span></span> DetermineDotNetVersion(<span class="hljs-type"><span class="hljs-type">void</span></span>) { WCHAR wszPath[MAX_PATH] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; ::GetModuleFileNameW( g_hClrModule, wszPath, MAX_PATH); CStringW strPath(wszPath); <span class="hljs-type"><span class="hljs-type">int</span></span> nIndex = strPath.ReverseFind(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( nIndex &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; nIndex++; CStringW strFilename = strPath.Mid( nIndex, strPath.GetLength() - nIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( strFilename.CompareNoCase(L"mscorwks.dll") == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { g_tDotNetVersion = DotNetVersion_20; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( strFilename.CompareNoCase(L"clr.dll") == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { DWORD dwHandle = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; UINT nSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; LPBYTE lpBuffer = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; BYTE szTempBuf[<span class="hljs-number"><span class="hljs-number">2048</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; DWORD dwSize = GetFileVersionInfoSizeW( wszPath, &amp;dwHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dwSize != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { LPVOID pData = szTempBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetFileVersionInfo( wszPath, dwHandle, dwSize, pData)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (VerQueryValueW( pData, L"\\",(<span class="hljs-type"><span class="hljs-type">VOID</span></span> FAR* FAR*)&amp;lpBuffer,&amp;nSize)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nSize) { VS_FIXEDFILEINFO * pVerInfo = (VS_FIXEDFILEINFO *)lpBuffer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pVerInfo-&gt;dwSignature == <span class="hljs-number"><span class="hljs-number">0xfeef04bd</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> nMajor = HIWORD(pVerInfo-&gt;dwFileVersionMS); <span class="hljs-type"><span class="hljs-type">int</span></span> nMinor = LOWORD(pVerInfo-&gt;dwFileVersionMS); <span class="hljs-type"><span class="hljs-type">int</span></span> nBuildMajor = HIWORD(pVerInfo-&gt;dwFileVersionLS); <span class="hljs-type"><span class="hljs-type">int</span></span> nBuildMinor = LOWORD(pVerInfo-&gt;dwFileVersionLS); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( nMajor == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; nMinor == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; nBuildMajor == <span class="hljs-number"><span class="hljs-number">30319</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( nBuildMinor &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> ) g_tDotNetVersion = DotNetVersion_40; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> g_tDotNetVersion = DotNetVersion_45; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>; } } } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; }</code> </pre><br>  Now we can declare our LoadMethodDescIterator, which will work with the CLR. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AssemblyIterationMode { AssemblyIterationMode_Default = <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadedMethodDescIterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadedMethodDescIterator::*PFN_LoadedMethodDescIteratorConstructor)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppDomain * pAppDomain, Module *pModule, mdMethodDef md)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadedMethodDescIterator::*PFN_LoadedMethodDescIteratorConstructor_v45)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppDomain * pAppDomain, Module *pModule, mdMethodDef md, AssemblyIterationMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadedMethodDescIterator::*PFN_Start)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppDomain * pAppDomain, Module *pModule, mdMethodDef md)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOOL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadedMethodDescIterator::*PFN_Next_v4)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPVOID pParam)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOOL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoadedMethodDescIterator::*PFN_Next_v2)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> MethodDesc* (LoadedMethodDescIterator::*PFN_Current)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LoadedMethodDescIterator(AppDomain * pAppDomain, Module *pModule, mdMethodDef md) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( dummy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dummy)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( dummy2, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dummy2)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s_pfnConstructor ) (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnConstructor)( pAppDomain, pModule, md); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s_pfnConstructor_v45 ) (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnConstructor_v45)( pAppDomain, pModule, md, AssemblyIterationMode_Default); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppDomain * pAppDomain, Module *pModule, mdMethodDef md)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnStart)( pAppDomain, pModule, md); } <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s_pfnNext_v4 ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnNext_v4)(dummy2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s_pfnNext_v2 ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnNext_v2)(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } <span class="hljs-function"><span class="hljs-function">MethodDesc* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Current</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;*s_pfnCurrent)(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// we don't know the exact size of LoadedMethodDescIterator, so add enough memory here BYTE dummy[10240]; // class CollectibleAssemblyHolder&lt;class DomainAssembly *&gt; parameter for Next() in .Net4.0 and above BYTE dummy2[10240]; // constructor for .Net2.0 &amp; .Net 4.0 static PFN_LoadedMethodDescIteratorConstructor s_pfnConstructor; // constructor for .Net4.5 static PFN_LoadedMethodDescIteratorConstructor_v45 s_pfnConstructor_v45; static PFN_Start s_pfnStart; static PFN_Next_v4 s_pfnNext_v4; static PFN_Next_v2 s_pfnNext_v2; static PFN_Current s_pfnCurrent; public: static void MatchAddress(PSYMBOL_INFOW pSymbolInfo) { LPVOID* pDest = NULL; if( wcscmp( L"LoadedMethodDescIterator::LoadedMethodDescIterator", pSymbolInfo-&gt;Name) == 0 ) { switch(g_tDotNetVersion) { case DotNetVersion_20: case DotNetVersion_40: pDest = (LPVOID*)&amp;(LoadedMethodDescIterator::s_pfnConstructor); break; case DotNetVersion_45: pDest = (LPVOID*)&amp;(LoadedMethodDescIterator::s_pfnConstructor_v45); break; default: ATLASSERT(FALSE); return; } } else if( wcscmp( L"LoadedMethodDescIterator::Next", pSymbolInfo-&gt;Name) == 0 ) { switch(g_tDotNetVersion) { case DotNetVersion_20: pDest = (LPVOID*)&amp;(LoadedMethodDescIterator::s_pfnNext_v2); break; case DotNetVersion_40: case DotNetVersion_45: pDest = (LPVOID*)&amp;(LoadedMethodDescIterator::s_pfnNext_v4); break; default: ATLASSERT(FALSE); return; } } else if( wcscmp( L"LoadedMethodDescIterator::Start", pSymbolInfo-&gt;Name) == 0 ) pDest = (LPVOID*)&amp;(LoadedMethodDescIterator::s_pfnStart); else if( wcscmp( L"LoadedMethodDescIterator::Current", pSymbolInfo-&gt;Name) == 0 ) pDest = (LPVOID*)&amp;(LoadedMethodDescIterator::s_pfnCurrent); if( pDest ) *pDest = (LPVOID)pSymbolInfo-&gt;Address; } };</span></span></code> </pre><br>  Finally, use a LoadedMethodDescIterator to call Reset () on MethodDesc for generic methods. <br><pre> <code class="hljs php">Module * pModule = pMethodDesc-&gt;GetLoaderModule(); AppDomain * pAppDomain = pMethodDesc-&gt;GetDomain(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pModule ) { LoadedMethodDescIterator * pLoadedMethodDescIter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoadedMethodDescIterator( pAppDomain, pModule, md); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(pLoadedMethodDescIter-&gt;Next()) { MethodDesc * pMD = pLoadedMethodDescIter-&gt;Current(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pMD ) pMD-&gt;Reset(); } delete pLoadedMethodDescIter; }</code> </pre><br><h1>  Compilation and optimization </h1><br>  I found that if a method is very small and its size is only a few bytes, it will be compiled in inline mode.  Therefore, MethodDesc :: Reset () does not help, because at run time, it will not even get to call this method.  A little more information can be found in CEEInfo :: canInline (vm. \ / Jitinterface.cpp in SSCLI) <br><h1>  Dynamic methods </h1><br>  When adding dynamic methods to the IL code, you need to be very careful.  Adding invalid IL code to other types of methods will only cause an InvalidApplicationException, but adding invalid IL code to a dynamic method can lead to a complete failure of the CLR and our process.  Dynamic IL is different than others.  The best way out is to generate the IL code from another dynamic method, and then copy and paste. <br><h1>  Source files </h1><br><ul><li>  <a href="">Binary files</a> </li><li>  <a href="">Source files</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/154419/">https://habr.com/ru/post/154419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154407/index.html">Gmail Show M. Later</a></li>
<li><a href="../154409/index.html">HP Wireless Networks</a></li>
<li><a href="../154411/index.html">Ruby meetings in St. Petersburg are back in fashion</a></li>
<li><a href="../154413/index.html">Editing comments</a></li>
<li><a href="../154417/index.html">3 days until the end of the submission of applications for the competition of Web Ready Internet projects!</a></li>
<li><a href="../154425/index.html">We transfer the entire office to the "cloud": not a byte on local machines</a></li>
<li><a href="../154437/index.html">November 6th is the best day of the calendar! Student Day 3.0 with Steve Ballmer!</a></li>
<li><a href="../154443/index.html">Sony has opened API Floating touch</a></li>
<li><a href="../154445/index.html">SDS-TWR Distance Measurement without Roulette and Sync</a></li>
<li><a href="../154449/index.html">Fluid Data: A ‚Äúsmall‚Äù win in storing ‚Äúbig‚Äù data - part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>