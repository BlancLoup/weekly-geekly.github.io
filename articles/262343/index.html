<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We recognize Morse codes using Rx.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task: input signals from the keyboard (keyup, keydown) - output letters and words decoded according to Morse code. On how to declaratively solve t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We recognize Morse codes using Rx.js</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/885/7d1/da8/8857d1da8c9347eeb430c9c2c5ccbfa1.png"></div><br><br>  The task: input signals from the keyboard (keyup, keydown) - output letters and words decoded according to Morse code.  On how to declaratively solve this problem using the FRP approach, in particular Rx.js - below under the cut.  (Why? Because we can) <br><a name="habracut"></a><br><br>  <b>For non-patient:</b> <br><ul><li>  demo - <a href="http://alexmost.github.io/morse/">http://alexmost.github.io/morse/</a> </li><li>  source - <a href="https://github.com/AlexMost/morse">https://github.com/AlexMost/morse</a> </li></ul><br><h4>  main idea </h4><br>  This demo is intended to demonstrate the power of the <s>Jedi</s> reactive programming to solve the problem of the composition of asynchronous computing.  Rx makes you look at asynchronous code differently, treating events as collections.  A lot of articles about Rx and functional programming look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/734/f51/149/734f51149b4f0b1ec570fbddddbd78cc.jpg"></div><br><br>  Therefore, I will try to describe in more detail one of the functional parts of the application (with live examples and diagrams). <br><br><h4>  Morse logic </h4><br>  The letter in Morse code is a set of long and short signals (dots and dashes) separated by a certain time interval. <br><br>  <i>Basic rules (ideal):</i> <br><ol><li>  Per unit of time is taken as the duration of one point. </li><li>  The duration of the dash is equal to three points. </li><li>  Pause between elements of the same sign - one point. </li><li>  Pause between characters in the word - 3 points. </li><li>  Pause between words - 7 points. </li></ol><br>  Looking ahead, I want to warn you that I didn‚Äôt bother much about the dimension and took the length of 400 ms ‚Äúby eye‚Äù.  This project does not claim 100% compliance with the real Morse code (do not try to use it in military conditions), but the principle of operation remains the same.  With respect to 400 ms, the remaining time intervals are calculated (the size of the dashes, the pause between letters and words).  The interface is constructed in such a way that it makes it clear when it expects a character (point, dash) from a letter, a new letter, or the next word. <br><br>  <i>- What?</i>  <i>Yes, I'm on my knee in 5 minutes and without Rx</i> <br><br><h4>  What is the main difficulty? </h4><br>  The main difficulty lies in the fact that we are dealing with asynchronous logic.  The number of signals in the letter is non-deterministic.  For example, the letter 'A' consists of two characters - a dot and a dash (.-), while a '0' is five dashes (-----).  It is also not easy to imagine how to count the time from one letter to another.  How between this whole thing still understand that there was an interval between words? .. This problem can be solved by a standard imperative approach with a bunch of callbacks or promises and setTimeout or newfangled async / await.  I do not want to convince you that this is wrong, I just want to show another approach that I like. <br><br><h4>  Task decomposition and different layers of abstraction </h4><br>  <i>- Divide et impera !!!</i> <br><br>  To solve a complex problem, it is necessary to divide it into smaller and simpler subtasks and solve each of them separately.  In this case, we have low-level signals at the input (DOM event), and letters and words at the output.  This task can be compared with the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">OSI</a> network model.  The model is represented by different levels, each of which performs its task and provides data for the higher layer.  The main similarity lies in the fact that each of the levels has its own clear logic, but does not know about the whole model as a whole.  Let's select the main layers of abstractions in our task: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/656/bc3/0a1/656bc30a13614cb88d7c0e7b5ac1979b.png"></div><br>  As you can see, each layer operates with its own logic, providing the data above to the standing layer and does not know about the whole system as a whole. <br><br><h4>  Sequence of events as a first class object </h4><br>  Rx allows you to treat any asynchronous sequence as an object of the first class.  This means we can save all arising keyup-s and keydown-s in a certain collection (Observable) and operate with it as with a regular data array. <br><br><h4>  We analyze the problem "point or dash" </h4><br>  Next, I will try to describe in detail the process of getting a stream in which dots or dashes will come.  To begin with, we will receive collections of all keystrokes: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUps = Rx.Observable.fromEvent(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyDowns = Rx.Observable.fromEvent(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, <span class="hljs-string"><span class="hljs-string">'keydown'</span></span>);</code> </pre> <br>  <a href="http://jsfiddle.net/AlexMost/h8yoodpu/">jsfiddle example</a> <br><br>  Having received arrays of kyeup and keydown events, we are only interested in pressing space.  We can get them using the filter operation - this will be our first level of abstraction with DOM-event-ami: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spaceKeyUps = keyUps.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> data.keyCode === <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spaceKeyDowns = keyDowns.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> data.keyCode === <span class="hljs-number"><span class="hljs-number">32</span></span>);</code> </pre><br>  <a href="http://jsfiddle.net/AlexMost/66frLx5r/3/">jsfiddle example</a> <br><br>  Schematically it looks like this: <br><img src="https://habrastorage.org/files/def/733/2d7/def7332d7ed648bb8103d8b15ff8c737.png"><br>  In the picture above we see 2 streams.  The top one includes all keydown events.  The bottom one is based on the top one, but as you can see, the filter function has been applied to it, which filters the key code.  As a result, we have a new stream with the keydown space.  Have you ever seen the spaceKeyDown event in the DOM api?  We have just created it based on the existing DOM event and will continue to use it. <br><br>  We are not particularly interested in where the signal was received (mouse, keystroke, microphone, camera), abstracting and transmitting further just the fact that the signal started or ended: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signalStarts = spaceKeyDowns.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"start"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signalEnds = spaceKeyUps.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"end"</span></span>);</code> </pre><br>  <a href="http://jsfiddle.net/AlexMost/e25h4hmc/4/">jsfiddle example</a> <br><div class="spoiler">  <b class="spoiler_title">But not everything is so simple with signalStarts :)</b> <div class="spoiler_text">  There is a small problem with the keydown event.  DOM api works in such a way that the keydown event is triggered many times when the key is pressed.  We can easily overcome this by adding some code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signalStartsRaw = spaceKeyDowns.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"start"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signalEndsRaw = spaceKeyUps.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"end"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     start  end. const signalStartsEnds = Rx.Observable.merge(signalStartsRaw, signalEndsRaw).distinctUntilChanged(); // signal star/end with toggle logic const signalStarts = signalStartsEnds.filter((ev) =&gt; ev === "start"); const signalEnds = signalStartsEnds.filter((ev) =&gt; ev === "end");</span></span></code> </pre><br>  Let's see what happened here.  The main problem is the occurrence of two identical successive events.  In this case, you can get a common stream from start and end (signalStartsEnds) and apply the <b>distinctUntilChanged</b> function to it.  She will ensure that the events will not be repeated.  (more about distinctUntilChanged - <a href="">here</a> ) <br><br>  <a href="http://jsfiddle.net/AlexMost/mop8qhgu/1/">jsfiddle working example</a> <br></div></div><br><br>  Next, we need to calculate the time between the beginning and the end of the signal, for this, let's add time stamps to our collections: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signalStarts = signalStartsEnds.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">) =&gt;</span></span> ev === <span class="hljs-string"><span class="hljs-string">"start"</span></span>).timestamp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signalEnds = signalStartsEnds.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">) =&gt;</span></span> ev === <span class="hljs-string"><span class="hljs-string">"end"</span></span>).timestamp();</code> </pre><br>  After that, you must return the time difference between keydown and keyup.  Let's create a separate stream for this.  Since the occurrence of keyup events is not deterministic.  That is, if keydown is viewed as stream and you note the time of each keystroke, each event should return another stream that returns the first keyup value.  It sounds very difficult, it's easier to see how it looks in the code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spanStream = signalStarts.flatMap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> signalEnds.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">end</span></span></span><span class="hljs-function">) =&gt;</span></span> end.timestamp - start.timestamp).first(); });</code> </pre><br>  <a href="http://jsfiddle.net/AlexMost/r8djtfpg/1/">jsfiddle example</a> <br><br>  Schematically it looks like this: <br><img src="https://habrastorage.org/files/c52/ae5/f2b/c52ae5f2b51e4fb49a99ea27d40dd402.png"><br><br>  In the image of t1, t2, t3 ... this is the time when the event occurred.  t2 - t1 - time difference.  You can say this as: ‚ÄúAt each beginning of the signal, we create a stream of signals from the end of the signal, we wait for the 1st signal from it, then we transmit the time difference between the beginning and the end of the signals‚Äù.  Thus, we received a stream from time intervals, and using them we can determine points and dashes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SPAN = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dotsStream = spanStream.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) =&gt;</span></span> v &lt;= SPAN).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lineStream = spanStream.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) =&gt;</span></span> v &gt; SPAN).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span>);</code> </pre><br>  The full code of the example looks like this - <a href="http://jsfiddle.net/AlexMost/uv4yh11k/1/">an example on jsfiddle</a> .  Remove some noise and get a more beautiful <a href="http://jsfiddle.net/AlexMost/myxgubz5/">code</a> (subjective opinion, but if you do not like it - you do not have a soul). <br><br>  And here is our promised stream of dots and dashes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dotsAndLines = Rx.Observable.merge(dotsStream, lineStream);</code> </pre><br>  Next, we operate with higher-level streams and create even higher levels of them.  For example, applying some Rx transformations, we can get a stream of spaces between letters and then a letter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> letterCodes = dotsAndLines.buffer(letterWhitespaces) <span class="hljs-comment"><span class="hljs-comment">//   [['.', '.', '-'], ['-', '.', '-'] ... ] const lettersStream = letterCodes.map((codes) =&gt; morse.decode(codes.join(""))).share() //   ['A', 'B' ...]</span></span></code> </pre><br>  <a href="">Link to the source</a> <br>  Beautiful isn't it?  Not?  Then this is how we can display a cat image, if the user has coded the word "CAT": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setCatImgStream = wordsStream.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function">) =&gt;</span></span> word == <span class="hljs-string"><span class="hljs-string">"CAT"</span></span>).map(setCatImg)</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Proof</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d9a/9f8/51b/d9a9f851bc454237a41bd71b7a177443.png"><br></div></div><br><h4>  Conclusion </h4><br>  Thus, we see that from ordinary DOM events we have come to more meaningful things (streams with letters and words).  In the future, this can be compiled further into sentences, paragraphs, books, etc. The main idea is that Rx makes it possible to compose your existing functionality to get a new one.  All your logic turns into a kind of API for building a new, more complex one and that, in turn, can also be put together.  In this article, I missed many more benefits that Rx out of the box gives you (testing asynchronous chains, cleaning resources, error handling).  I hope I managed to interest those who wanted to try but did not dare. <br><br>  <i>Thanks for attention!</i>  <i>All OP =)</i> </div><p>Source: <a href="https://habr.com/ru/post/262343/">https://habr.com/ru/post/262343/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262327/index.html">Dojo 2</a></li>
<li><a href="../262333/index.html">Tekla Structures API (Delphi): Connection and Simple Examples</a></li>
<li><a href="../262335/index.html">Garbage collector in Go: solving the problem of responsiveness in Go 1.5</a></li>
<li><a href="../262339/index.html">2 Pi or not 2 Pi - that is the question</a></li>
<li><a href="../262341/index.html">We sign data: HMAC in practice in API and Web-forms</a></li>
<li><a href="../262345/index.html">Generating and solving a maze using the depth-depth search method</a></li>
<li><a href="../262349/index.html">The end is only the beginning.</a></li>
<li><a href="../262351/index.html">Translation of RivetsJS documentation</a></li>
<li><a href="../262357/index.html">Neural interfaces for people (2003-2016). Buy or develop yourself?</a></li>
<li><a href="../262361/index.html">Spring without XML. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>