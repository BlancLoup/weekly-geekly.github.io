<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing the Spring Framework API from scratch. Step-by-step guide for beginners. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Spring Framework is one of the most difficult frameworks to understand and learn. Most developers learn it slowly through practical tasks and Goog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing the Spring Framework API from scratch. Step-by-step guide for beginners. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  The Spring Framework is one of the most difficult frameworks to understand and learn.  Most developers learn it slowly through practical tasks and Google.  This approach is not effective, since it does not provide a complete picture and at the same time is costly. <br><br>  I would like to offer you a fundamentally new approach to the study of Spring.  It lies in the fact that a person goes through a series of specially prepared tutorials and independently implements the functionality of the spring.  The peculiarity of this approach is that, in addition to a 100% understanding of the aspects of Spring being studied, there is still a big increase in Java Core (Annotations, Reflection, Files, Generics). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The article will give you an unforgettable experience and will allow you to feel like a Pivotal developer.  Step by step, you will make your classes bean and organize their life cycle (the same as in real spring).  The classes you will implement are <b>BeanFactory</b> , <b>Component</b> , <b>Service</b> , <b>BeanPostProcessor</b> , <b>BeanNameAware</b> , <b>BeanFactoryAware</b> , <b>InitializingBean</b> , <b>PostConstruct</b> , <b>PreDestroy</b> , <b>DisposableBean</b> , <b>ApplicationContext</b> , <b>ApplicationListener</b> , <b>ContextClosedEvent</b> . <br><a name="habracut"></a><br><h2>  A little bit about yourself </h2><br>  My name is Jaroslav, and I am Java Developer with 4 years of experience.  At the moment I work in the company EPAM Systems (SPB), and with interest I delve into the technologies that we use.  Quite often, we have to deal with spring, and I see in it a certain middle ground in which you can develop (Java knows everything well, and too specific tools and technologies can come and go). <br><br>  A couple of months ago, I passed the certification Spring Professional v5.0 (without passing courses).  After that, I thought about how to teach other people to spring.  Unfortunately, at the moment there is no effective teaching methodology.  Most developers have a very superficial understanding of the framework and its features.  Debugging the source code of the spring is too hard and absolutely not effective from the point of view of training (I was somehow into it).  Make 10 projects?  Yes, you will be able to deepen your knowledge somewhere and get a lot of practical experience, but much of what is ‚Äúunder the hood‚Äù will not open up to you.  Read the book Spring in Action?  Cool, but costly in effort.  I've worked for her 40% (during preparation for certification), but it was not easy. <br><br>  The only way to fully understand something is to develop it yourself.  Recently, I had the idea that you can take a person through an interesting tutorial that will oversee the development of your DI framework.  Its main feature will be that the API will coincide with the studied API.  Awesome of this approach is that in addition to a deep (without gaps) understanding of the spring, a person will receive a HUGE amount of experience in Java Core.  I admit honestly, I myself learned a lot of new things during the preparation of the article, both in Spring and in Java Core.  Let's start developing! <br><br><h2>  Project from scratch </h2><br>  So, the first thing to do is open your favorite IDE and create a project from scratch.  No Maven, no third-party libraries, we will not connect.  Even Spring-dependencies will not connect.  Our goal is to develop an API that is as close to Spring as possible, and implement it yourself. <br><br>  In a clean project, create 2 main packages.  The first package is your application ( <code>com.kciray</code> ), and the <code>Main.java</code> class inside it.  The second package is org.springframework.  Yes, we will duplicate the structure of the packages of the original spring, the name of its classes and their methods.  There is such an interesting effect - when you create something of your own, it starts to seem simple and clear.  Then, when you work in large projects, it will seem to you that everything is created on the basis of your workpiece.  Such an approach can have a very positive effect on the understanding of the operation of the system as a whole, its improvement, correction of bugs, problem solving, and so on. <br><br>  If you have some problems, you can <a href="https://github.com/kciray8/MyOwnSpring">take a</a> working project <a href="https://github.com/kciray8/MyOwnSpring">here</a> . <br><br><h2>  Create a container </h2><br>  To begin with, we set the task.  Imagine that we have 2 classes - <code>ProductFacade</code> and <code>PromotionService</code> .  Now imagine that you want to connect these classes with each other, but so that the classes themselves do not know about each other (Pattern DI).  We need a separate class that will manage all these classes and determine the dependencies between them.  Let's call it a container.  Create a class <code>Container</code> ... But no, wait!  In Spring, there is no single container class.  We have many container implementations, and all of these implementations can be divided into 2 types - bean factories and contexts.  The bean factory creates bins and binds them together (dependency injection, DI), and the context does roughly the same thing, plus adds some additional functions (for example, internationalizing messages).  But we do not need these additional functions now, so we will work with the bins factory. <br><br>  Create a new <code>BeanFactory</code> class and place it in the <code>org.springframework.beans.factory</code> package.  Let the <code>Map&lt;String, Object&gt; singletons</code> stored inside this class, in which the <code>id</code> bean is mapped onto the bean itself.  Add the <code>Object getBean(String beanName)</code> method to it, which pulls the beans by ID. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br>  Note that <code>BeanFactory</code> and <code>FactoryBean</code> are different things.  The first is the bins factory (container), and the second is the bin factory, which sits inside the container and also produces bins.  Factory inside the factory.  If you are confused between these definitions, you can remember that in English the second noun is the leading one, and the first is something like an adjective.  In the word Bean <b>Factory</b> The main word is the factory, and in the Factory <b>Bean</b> - bin. <br><br>  Now, let's create the <code>ProductService</code> and <code>PromotionsService</code> classes.  <code>ProductService</code> will return the product from the database, but before that you need to check whether any discounts (Promotions) apply to this product.  In e-commerce, work with discounts is often allocated to a separate class-service (and sometimes to a third-party web service). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br>  Now we need to make our container ( <code>BeanFactory</code> ) discover our classes, create them for us and inject one into the other.  Operations of type <code>new ProductService()</code> must be inside the container and be done for the developer.  Let's use the most modern approach (scanning classes and annotations).  To do this, we need to use pens to create the <code>@Component</code> annotation ( <code> org.springframework.beans.factory.stereotype</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br>  By default, annotations are not loaded into memory during program operation ( <code>RetentionPolicy.CLASS</code> ).  We changed this behavior through a new retention policy ( <code>RetentionPolicy.RUNTIME</code> ). <br><br>  Now add <code>@Component</code> before the <code>ProductService</code> classes and before the <code>PromotionService</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br>  We need <code>BeanFactory</code> scan our package ( <code>com.kciray</code> ) and find in it classes that are annotated with <code>@Component</code> .  This task is not trivial at all.  In Java Core <a href="https://stackoverflow.com/questions/520328/can-you-find-all-classes-in-a-package-using-reflection">there is no ready solution</a> , and we should make a crutch most.  Thousands of applications in spring use component scanning through this crutch.  You have learned the terrible truth.  You will have to extract <code>ClassLoader</code> names from <code>ClassLoader</code> and check <code>ClassLoader</code> they end in ".class" or not, and then build their full name and pull class objects out of it! <br><br>  I just want to warn you that there will be a lot of checked exceptions, so be prepared to wrap them.  But first, let's define what we want.  We want to add a special method in the <code>BeanFactory</code> and call it in <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br>  Next, we need to get a <code>ClassLoader</code> .  It is responsible for loading the classes, and it‚Äôs pretty simple to mine: <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br>  Probably you have already noticed that the packages are separated by a dot, and the files - straight forward slash.  We need to convert the batch path to the folder path, and get something like a <code>List&lt;URL&gt;</code> (paths in your file system that can be used to search for class files). <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br>  So wait!  <code>Enumeration&lt;URL&gt;</code> is not a <code>List&lt;URL&gt;</code> .  What is it all about?  Oh horror, this is the old progenitor <code>Iterator</code> , available since the days of Java 1.0.  This is the legacy we have to deal with.  If you can walk through <code>Iterable</code> with for (all collections implement it), then in the case of <code>Enumeration</code> you will have to do a walk around with handles, through <code>while(resources.hasMoreElements())</code> and <code>nextElement()</code> .  And yet there is no possibility to remove items from the collection.  Only 1996, only hardcore.  Oh yes, in Java 9, we added the <code>Enumeration.asIterator()</code> method, so you can work through it. <br><br>  Let's go further.  We need to extract the folders and work out the contents of each.  Convert the URL to a file, and then get its name.  Here it should be noted that we will not scan nested packages in order not to complicate the code.  You can complicate your task and make recursion, if you want. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br>  Next, we need to get the file name without the extension.  In the courtyard of 2018, Java has developed File I / O (NIO 2) for many years, but still cannot separate the extension from the file name.  You have to create your bike, because  we decided not to use third-party libraries like Apache Commons.  Let's use the old old-fashioned method <code>lastIndexOf(".")</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br>  Next, we can get a class object by the full name of the class (for this we call the class <code>Class</code> : <code>Class</code> ): <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br>  Ok, now our classes are in our hands.  Further, it remains only to highlight among them those that have the <code>@Component</code> annotation: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br>  Run and check.  The console should have something like this: <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br>  Now we need to create our bin.  We need to do something like <code>new ProductService()</code> , but for each bin we have our own class.  Reflection in Java provides us with a universal solution (the default constructor is called): <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br>  Next, we need to put this bean in <code>Map&lt;String, Object&gt; singletons</code> .  To do this, select the name of the bean (its id).  In Java, we call variables like classes (only the first lowercase letter).  This approach can be applicable to bins too, because Spring is a Java framework!  Transform the name of the bin so that the first letter is small, and add it to the map: <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br>  Now make sure everything works.  The container must create the beans, and they must be retrieved by name.  Note that the name of your method is <code>instantiate()</code> and the name of the method <code>classObject.newInstance();</code>  have a common root.  Moreover, <code>instantiate()</code> is part of the bin's life cycle.  In Java, everything is interconnected! <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br>  Also try implementing the <code>org.springframework.beans.factory.stereotype.Service</code> annotation.  It performs exactly the same function as <code>@Component</code> , but is called differently.  The whole point is in the title - you demonstrate that the class is a service, not just a component.  This is something like conceptual typing.  In the certification for the spring there was a question ‚ÄúWhat annotations are stereotyped?  (of the listed).  So, stereotypical annotations are those that are in the <code>stereotype</code> package. <br><br><h2>  We fill properties </h2><br>  Look at the diagram below for the beginning of the life cycle of a bin.  What we did before this is Instantiate (creating bins via <code>newInstance()</code> ).  The next step is the cross injection of the bins (dependency injection, also known as control inversion (IoC)).  You need to go through the properties of the bins and understand exactly what properties you need to inject.  If you call <code>productService.getPromotionsService()</code> , you will get <code>null</code> , because  dependency not yet added. <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br>  First, create the <code>org.springframework.beans.factory.annotation</code> package and add the <code>@Autowired</code> annotation to <code>@Autowired</code> .  The idea is to mark with this annotation those fields that are dependencies. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br>  Next, add it to the property: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Now we need to teach our <code>BeanFactory</code> find these annotations and inject dependencies on them.  Add a separate method for this, and call it from <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br>  Next, we just need to just go through all our bins in the <code>singletons</code> map, and for each bean go through all its fields ( <code>object.getClass().getDeclaredFields()</code> returns all fields, including private ones).  And check if the field has <code>@Autowired</code> annotation: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br>  Next, we need to go through all the bins one more time and see their type - suddenly this is the type who wants to take our bean.  Yes, we have a three-dimensional cycle! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br>  Further, when we find a dependency, we need to inject it.  The first thing you can think of is to write down the field of <code>promotionsService</code> using reflection directly.  But spring doesn't work that way.  After all, if a field has a <code>private</code> modifier, we will first have to set it as <code>public</code> , then write our value, then set it to <code>private</code> again (to preserve integrity).  Sounds like a big crutch.  Let's make a small crutch instead of a large crutch (we will form the name of the setter and call it): <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br>  Now start your project and make sure that when you call <code>productService.getPromotionsService()</code> our bean is returned instead of <code>null</code> . <br><br>  What we have implemented is type injection.  There is another injection by name (annotation <code>javax.annotation.Resource</code> ).  It differs in the fact that instead of the field type, its name will be extracted, and according to it - dependence from mapy.  It's all the same, even in something easier.  I recommend that you experiment and create some kind of your own bin, and then inject it with <code>@Resource</code> and extend the <code>populateProperties()</code> method. <br><br><h2>  Supporting beans that know their name </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br>  There are cases when inside a bin you need to get its name.  Such a need does not arise often, because  Bins, in essence, should not know about each other and that they are bins.  In the first versions of the spring, it was assumed that the bean is a POJO (Plain Old Java Objec, good old Java object), and the entire configuration is rendered into XML files and separated from the implementation.  But we implement this functionality, since the injection of a name is part of the life cycle of a bean. <br><br>  How do we know which bean wants to know his name, and which one does not want?  The first thing that comes to mind is to make a new annotation like <code>@InjectName</code> and sculpt it into fields of type String.  But this solution will be too general and allows you to shoot yourself in the foot many times (place this annotation on the fields of unsuitable types (not String), or try to inject the name into several fields in the same class).  There is another solution, more accurate - to create a special interface with one setter method.  All the bins that implement it get their name.  Create a <code>BeanNameAware</code> class in the <code>org.springframework.beans.factory</code> package: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br>  Next, let our <code>PromotionsService</code> implement it: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br>  Finally, add a new method to the bins factory.  Everything is simple - we go through our bin-singletons, check if the bean implements our interface, and call the setter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br>  Run and make sure everything works: <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br>  It should be noted that there are other similar interfaces in the spring.  I recommend that you independently implement the <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactoryAware.html">BeanFactoryAware</a> interface, which allows bins to get a link to the bean factory.  It is implemented similarly. <br><br><h2>  We initialize bins </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br>  Imagine that you have a situation where you need to run some code after the dependencies have been injected (the properties of the bean are set).  In simple terms, we need to give Bina the ability to initialize himself.  Alternatively, we can create an <code>InitializingBean</code> interface, and put the signature of the <code>void afterPropertiesSet()</code> method in it.  The implementation of this mechanism is absolutely similar to that presented for the <code>BeanNameAware</code> interface, so the solution is under the spoiler.  Practice and do it yourself in a minute: <br><br><div class="spoiler">  <b class="spoiler_title">Bean Initialization Solution</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2>  Add post processors </h2><br>  Imagine yourself in the place of the first developers of the spring.  Your framework is growing and is very popular among developers, every day we receive emails with requests to add this or that useful feature.  If for each such feature you add your own interface and check it in the life cycle of a bin, then it (the life cycle) will be clogged with unnecessary information.  Instead, we can create one universal interface that will allow you to add some logic to the execution (absolutely any, be it an annotation check, replace a bin with another bin, set some special properties, and so on). <br><br>  Let's think about what this interface is for.  It should do some post-processing of the bins, hence it can be called a BeanPostProcessor.  But we are faced with a difficult question - when should logic be executed?  After all, we can execute it before initialization, and we can execute it after.  For some tasks, the first option is better, for others - the second ... How to be? <br><br>  We can allow both options at once.  Let one post-processor carry two logic, two methods.  One is executed before initialization (before the <code>afterPropertiesSet()</code> method), and the other after.  Now let's think about the methods themselves - what parameters should they have?  Obviously, there must be a bin itself ( <code>Object bean</code> ).  For convenience, in addition to the bean, you can pass the name of this bean.  You remember that bin itself does not know its name.  And we do not want to force all beans to implement the BeanNameAware interface.  But, at the post processor level, the name of the bean can be very useful.  So we add it as the second parameter. <br><br>  And what should the method return when post processing a bean?  Let's make it so that it returns the bin itself.  This gives us super-flexibility, because instead of Bina, you can slip a proxy object that wraps its calls (and adds security).  Or you can return another object altogether, recreating the bin again.  Developers are given a very large freedom of action.  Below is the final version of the designed interface: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br>  Next, we need to add a list of simple processors to our bins factory and the ability to add new ones.  Yes, this is the usual ArrayList. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br>  Now we will change the <code>initializeBeans</code> method so that it takes into account post-processors: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br>  Let's create a small post-processor that simply traces calls to the console, and add it to our bean factory: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br>  Now run and make sure everything works.  As a training task, create a post-processor that will provide the <code>@PostConstruct (javax.annotation.PostConstruct)</code> annotation <code>@PostConstruct (javax.annotation.PostConstruct)</code> .  It provides an alternative method of initialization (having roots in Java, and not in the spring).  Its essence is that you place an annotation on a method, and this method will be called BEFORE standard spring initialization (InitializingBean). <br><br>  Be sure to create all annotations and packages (even javax.annotation) manually, do not connect dependencies!  This will help you see the difference between the core of the spring and its extensions (javax support), and remember it.  This will allow you to stick to one style in the future. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will be interested in the fact that in a real spring the abstract </font></font><code>@PostConstruct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is implemented exactly this way, through the post-processor CommonAnnotationBeanPostProcessor. </font><font style="vertical-align: inherit;">But do not peek there, write your implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lastly, I recommend that you add a method </font></font><code>void close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the class </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and work out two more mechanisms. </font><font style="vertical-align: inherit;">The first is the abstract </font></font><code>@PreDestroy (javax.annotation.PreDestroy)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, intended for methods that must be called when the container is closed. </font><font style="vertical-align: inherit;">The second is the interface </font></font><code>org.springframework.beans.factory.DisposableBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that contains the method </font></font><code>void destroy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">All bins that execute this interface will be able to destroy themselves (free up resources, for example).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@PreDestroy + DisposableBean</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Full life cycle bean </font></font></h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we implemented the full life cycle of Bina, in its modern form. </font><font style="vertical-align: inherit;">I hope that this approach will help you to remember it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Our favorite context </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmers often use the term context, but not everyone understands what it really means. </font><font style="vertical-align: inherit;">Now we will put everything in shelves. </font><font style="vertical-align: inherit;">As I noted at the beginning of the article, the context is a container implementation, as well as </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But, besides the basic functions (DI), it also adds some cool features. </font><font style="vertical-align: inherit;">One of these features is sending and processing events between bins. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article was too big and the content was cut off, so I put the information on the context under the spoiler.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We realize context</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     ¬´ ¬ª     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br>  But no.   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   ‚Äî   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, I planned this article for Baeldung in English, but then I thought that the audience could positively evaluate this approach to learning. </font><font style="vertical-align: inherit;">If you like my ideas, be sure to support the article. </font><font style="vertical-align: inherit;">If she scores a rating of more than 30, then I promise to continue. </font><font style="vertical-align: inherit;">When writing this article, I tried to show exactly the knowledge of Spring Core that is used most often, and also based on </font></font><a href="https://d1fto35gcfffzn.cloudfront.net/academy/Core-Spring-5.0-Certification-Study-Guide.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core Spring 5.0 Certification Study Guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the future, using such tutorials, you can cover all the certification and make the spring more accessible to Java developers.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Update 10/05/2018 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I constantly receive letters with questions "and when the continuation, we are waiting for him." </font><font style="vertical-align: inherit;">But there is no time at all, and other personal projects are in priority. </font><font style="vertical-align: inherit;">However, if some of you really liked the idea, you can study the narrow section of the spring and write an article-sequel. </font><font style="vertical-align: inherit;">If you do not have a habry account, then I can publish an article from my acca or help you get an invite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topics distribution: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Container - [username] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring AOP - [username] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Web - [username] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud - [username]</font></font></div><p>Source: <a href="https://habr.com/ru/post/419679/">https://habr.com/ru/post/419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419667/index.html">Selection of useful materials on Azure. Part 1 - Books</a></li>
<li><a href="../419671/index.html">Restrictions that need to be violated or how we accelerated the functional tests three times</a></li>
<li><a href="../419673/index.html">Early Universe 6. The Dynamics of a Homogeneous Expanding Universe, Part 2</a></li>
<li><a href="../419675/index.html">Review of per minute rental of electric scooters in Moscow, summer 2018</a></li>
<li><a href="../419677/index.html">How to sniff HTTPS traffic on an iOS device</a></li>
<li><a href="../419683/index.html">What do the metrics mean for Agile teams?</a></li>
<li><a href="../419685/index.html">Key data structures you should know about your programming interview.</a></li>
<li><a href="../419687/index.html">Mystery Keyboard Level 3 or how to type a long dash</a></li>
<li><a href="../419689/index.html">I. Disadaptation. Ii. ADHD or lazy moron?</a></li>
<li><a href="../419693/index.html">Mikrotik: reset settings, backups and DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>