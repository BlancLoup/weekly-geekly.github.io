<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL performance scaling with table partitioning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Classic script 

 You are working on a project where transactional data is stored in a database. Then you deploy the application in a production envir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL performance scaling with table partitioning</h1><div class="post__text post__text-html js-mediator-article"><h4>  Classic script <br></h4><img src="https://habrastorage.org/storage2/e82/215/a5d/e82215a5dd26b261d38923a87c42e652.png" align="right"><br>  You are working on a project where transactional data is stored in a database.  Then you deploy the application in a production environment, and the performance is great!  Requests pass quickly, and the delay in entering them is almost imperceptible.  After a few days / weeks / months, the database becomes more and more, and the speed of requests slows down. <br><br>  There are several approaches with which you can speed up your application and database. <br><br>  The database administrator (DBA) will look and make sure that the database is optimally configured.  He will offer to add certain indexes, remove logging to a separate partition, correct the parameters of the database engine and make sure that the database is healthy.  You can also add highlighted Input / Output Operations Per second on an <a href="http://en.wikipedia.org/wiki/Amazon_Web_Services_Elastic_Block_Store">EBS</a> disk to increase the speed of the disk partitions.  This will give you time and give you the opportunity to solve the main problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i><b>Sooner or later you will realize that the data in your database is a bottleneck (botleneck).</b></i> <i><b><br></b></i>  In many application databases, the importance of information decreases with time.  If you can think of a way to get rid of this information, your requests will pass faster, the time to create backups will decrease, and you will save a lot of space.  You can delete this information, but then it will disappear permanently.  You can send many DELETE requests, triggering tons of logs, and use a bunch of database engine resources.  So how do we get rid of old information effectively, but not losing it forever? <br>  <b><i>In the examples, we will use PostgreSQL 9.2 on Engine Yard.</i></b>  <b><i>You also need git to install plsh.</i></b> <b><i><br></i></b> <br><a name="habracut"></a><br><h4>  Partitioning tables </h4><br>  Partitioning tables is a good solution to this problem.  Take one giant table and break it into a bunch of small ones - these small tables are called partitions and child tables.  Actions such as creating backups, SELECT and DELETE operations can be performed with individual or all partitions.  Partitions can also be deleted or exported by a single request, which will keep logging to a minimum. <br><br><h4>  Terminology <br></h4><br>  Let's start with the terminology that will be used in this article. <br><br><h5>  Master Table <br></h5><br>  Also called the Master Partition Table, this is the template by which child tables are created.  This is a regular table, but it does not store any information and needs a trigger (more on that later).  The type of relationship between the master and child tables is one-to-many (one-to-many), that is, there is one main table and many children. <br><br><h5>  Child Table <br></h5><br>  These tables inherit their structure (or in other words, their <a href="http://ru.wikipedia.org/wiki/Data_Definition_Language">data description language ‚Äî Data Definition Language or <b>DDL</b></a> ) from the main table and belong to the same main table.  It is in the child tables that all data is stored.  These tables are often called <b>partition tables</b> . <br><br><h5>  Partition function <br></h5><br>  Partition function is a stored procedure that determines which of the child tables will accept the new record.  The main table contains a trigger that calls the partition function.  There are two methodologies for routing records to child tables: <br>  According to data values ‚Äã‚Äã- an example of this is the date of the order of purchase.  When purchase orders arrive in the main table, this function is called by a trigger.  If you create partitions by day, each subsidiary part will represent all orders that came on a particular day.  This method is described in this article. <br>  For fixed values ‚Äã‚Äã‚Äî an example of this is geography, such as states.  In this case, you can have 50 child tables, one for each US state.  When INSERT requests come into the main table, the function sorts each new row into one of the child tables.  This methodology is not described in this article, as it will not help us get rid of old data. <br><br><h4>  It's time to customize these partitions. <br></h4><br>  This solution demonstrates the following: <br><ul><li>  Automatic creation of partition databases based on date </li><li>  Planning to export old partitions to compressed files </li><li>  Disposal of old partitions without sacrificing performance. </li><li>  Reload the old partitions so that they are again available for the main partition. </li></ul><br>  Most of the parting documentation I read is simply used to keep the database clean and tidy.  If you need old data, you would have to keep a backup of the old database.  I will show you how you can keep your database healthy using partitioning, but with access to old information if necessary without the need to create backup copies. <br><br><h5>  Assumptions (Conventions) <br></h5><br>  The commands executed from under the shell, by the root user have the following prefix: <br><pre><code class="hljs objectivec">root<span class="hljs-meta"><span class="hljs-meta">#</span></span></code> </pre>  Commands executed from under the shell, by a non-root user, for example postgres, have the following prefix: <br><pre> <code class="hljs">postgres$</code> </pre>  Commands executed inside the PostgreSQL database will look like this: <br><pre> <code class="hljs">my_database&gt;</code> </pre> <br><br><h4>  What you need <br></h4><br>  In the examples, we will use <a href="https://blog.engineyard.com/2013/upgrade-postgresql-9-2">PostgreSQL 9.2 on Engine Yard</a> .  You also need git to install plsh. <br><br><h5>  Summary <br></h5><br>  Here is a brief description of what we are going to do: <br><ul><li>  create master table </li><li>  create trigger function </li><li>  create table trigger </li><li>  create a partition maintenance function </li><li>  schedule partitions </li><li>  reload old partitions when needed </li></ul><br><br><h5>  Creating the main table <br></h5><br>  For this example, we will create a table to store basic performance information (cpu, memory, disk) server groups (server_id) every minute. <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> myschema.server_master ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> BIGSERIAL <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, server_id <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>, cpu <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>, disk <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) );</code> </pre> <br><br>  Note that the name time is enclosed in quotes.  This is necessary because time is a keyword in PostgreSQL.  You can learn more about the Date / Time keywords and their functions in the <a href="http://www.postgresql.org/docs/9.2/static/functions-datetime.html">PostgreSQL documentation</a> . <br><br><h5>  Create a trigger function <br></h5><br>  The trigger function does the following: <br><ul><li>  Creates a child partition of tables with dynamically generated ‚ÄúCREATE TABLE‚Äù parameters if it does not already exist </li><li>  Parameters (child tables) are determined by the values ‚Äã‚Äãof the ‚Äútime‚Äù column, creating a partition for each calendar day </li><li>  The time is stored in the epoch format, which is a representation of the number of seconds elapsed since midnight (00:00:00 UTC) on January 1, 1970, as an integer </li><li>  Each day contains 86400 seconds, the midnight of each day is the epoch date, which is divided by 86400 without a balance. </li><li>  The name of each child table will be in the format of myschema.server_YYYY-MM-DD. </li></ul><br><br><pre> <code class="hljs ruby">CREATE OR REPLACE FUNCTION myschema.server_partition_function() RETURNS TRIGGER AS $BODY$ DECLARE _new_time int; _tablename text; _startdate text; _enddate text; _result record; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> --Takes the current inbound <span class="hljs-string"><span class="hljs-string">"time"</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determines <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> midnight is <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the given date _new_time <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= ((NEW.<span class="hljs-string"><span class="hljs-string">"time"</span></span>/<span class="hljs-number"><span class="hljs-number">86400</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:int</span></span>)*<span class="hljs-number"><span class="hljs-number">86400</span></span>; _startdate <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= to_char(to_timestamp(_new_time), <span class="hljs-string"><span class="hljs-string">'YYYY-MM-DD'</span></span>); _tablename <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-string"><span class="hljs-string">'server_'</span></span><span class="hljs-params"><span class="hljs-params">||</span></span>_startdate; -- Check <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the partition needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the current record exists PERFORM <span class="hljs-number"><span class="hljs-number">1</span></span> FROM pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> AND c.relname = _tablename AND n.nspname = <span class="hljs-string"><span class="hljs-string">'myschema'</span></span>; -- If the partition needed does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> yet exist, <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> we create <span class="hljs-symbol"><span class="hljs-symbol">it:</span></span> -- Note that <span class="hljs-params"><span class="hljs-params">||</span></span> is string concatenation (joining two strings to make one) IF NOT FOUND THEN <span class="hljs-symbol"><span class="hljs-symbol">_enddate:</span></span>=<span class="hljs-symbol"><span class="hljs-symbol">_startdate:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:timestamp</span></span> + INTERVAL <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>; EXECUTE <span class="hljs-string"><span class="hljs-string">'CREATE TABLE myschema.'</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_ident(_tablename) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">' ( CHECK ( "time" &gt;= EXTRACT(EPOCH FROM DATE '</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_literal(_startdate) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">') AND "time" &lt; EXTRACT(EPOCH FROM DATE '</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_literal(_enddate) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">') ) ) INHERITS (myschema.server_master)'</span></span>; -- Table permissions are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> inherited from the parent. -- If permissions change on the master be sure to change them on the child also. EXECUTE <span class="hljs-string"><span class="hljs-string">'ALTER TABLE myschema.'</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_ident(_tablename) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">' OWNER TO postgres'</span></span>; EXECUTE <span class="hljs-string"><span class="hljs-string">'GRANT ALL ON TABLE myschema.'</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_ident(_tablename) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">' TO my_role'</span></span>; -- Indexes are <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span> per child, so we assign a default index that uses the partition columns EXECUTE <span class="hljs-string"><span class="hljs-string">'CREATE INDEX '</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_ident(_tablename<span class="hljs-params"><span class="hljs-params">||</span></span><span class="hljs-string"><span class="hljs-string">'_indx1'</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">' ON myschema.'</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_ident(_tablename) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">' (time, id)'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> IF; -- Insert the current record into the correct partition, which we are sure will now exist. EXECUTE <span class="hljs-string"><span class="hljs-string">'INSERT INTO myschema.'</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> quote_ident(_tablename) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">' VALUES ($1.*)'</span></span> USING NEW; RETURN NULL; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $BODY$ LANGUAGE plpgsql;</code> </pre> <br><br><h5>  Creating a trigger for a table <br></h5><br>  When the partition function is created, you need to add an input trigger to the main table.  It will call the partition function when new entries arrive. <br><br><pre> <code class="hljs delphi">CREATE TRIGGER server_master_trigger BEFORE INSERT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> myschema.server_master <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> EACH ROW EXECUTE <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myschema</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server_partition_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre><br>  Now you can send rows to the main table and watch how they will fit into the corresponding child tables. <br><br><h5>  Creating the partition maintenance function <br></h5><br>  Now we put the main table on a diet.  The function below was created to collectively handle the maintenance of the partition.  That is why you will not see any specific syntax for the server. <br>  <b>How it works:</b> <b><br></b> <br><ul><li>  All child tables for a particular master table are scanned for partitions, where the name of the partition corresponds to a date greater than 15 days. </li><li>  Each ‚Äútoo old‚Äù partition is exported to the local file system by calling the database function myschema.export_partition (text, text).  More on this in the next section. </li><li>  Only if the export to the local file system was successful, the child table will be dropped. </li><li>  This function assumes the presence of the / db / partition_dump folder on the local database server.  More on this in the next section.  If you're wondering where these partitions will be exported, then you should go there! </li></ul><br><pre> <code class="hljs mel">CREATE OR REPLACE FUNCTION myschema.partition_maintenance(in_tablename_prefix <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, in_master_tablename <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, in_asof <span class="hljs-keyword"><span class="hljs-keyword">date</span></span>) RETURNS <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> AS $BODY$ DECLARE _result record; _current_time_without_special_characters <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; _out_filename <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; _return_message <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; return_message <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; BEGIN -- Get the current <span class="hljs-keyword"><span class="hljs-keyword">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> YYYYMMDD_HHMMSS.ssssss <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> _current_time_without_special_characters := REPLACE(REPLACE(REPLACE(NOW()::TIMESTAMP WITHOUT TIME ZONE::TEXT, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">':'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>); -- Initialize the return_message to empty to indicate no errors hit _return_message := <span class="hljs-string"><span class="hljs-string">''</span></span>; --Validate input to function IF in_tablename_prefix IS NULL THEN RETURN <span class="hljs-string"><span class="hljs-string">'Child table name prefix must be provided'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; ELSIF in_master_tablename IS NULL THEN RETURN <span class="hljs-string"><span class="hljs-string">'Master table name must be provided'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; ELSIF in_asof IS NULL THEN RETURN <span class="hljs-string"><span class="hljs-string">'You must provide the as-of date, NOW() is the typical value'</span></span>; END IF; FOR _result IN SELECT * FROM pg_tables WHERE schemaname=<span class="hljs-string"><span class="hljs-string">'myschema'</span></span> LOOP IF POSITION(in_tablename_prefix <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _result.tablename) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> AND char_length(<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(_result.tablename from <span class="hljs-string"><span class="hljs-string">'[0-9-]*$'</span></span>)) &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> AND (in_asof - interval <span class="hljs-string"><span class="hljs-string">'15 days'</span></span>) &gt; to_timestamp(<span class="hljs-keyword"><span class="hljs-keyword">substring</span></span>(_result.tablename from <span class="hljs-string"><span class="hljs-string">'[0-9-]*$'</span></span>),<span class="hljs-string"><span class="hljs-string">'YYYY-MM-DD'</span></span>) THEN _out_filename := <span class="hljs-string"><span class="hljs-string">'/db/partition_dump/'</span></span> || _result.tablename || <span class="hljs-string"><span class="hljs-string">'_'</span></span> || _current_time_without_special_characters || <span class="hljs-string"><span class="hljs-string">'.sql.gz'</span></span>; BEGIN -- Call function export_partition(child_table <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) to export the <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> PERFORM myschema.export_partition(_result.tablename::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, _out_filename::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>); -- If the export was successful drop the child <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> EXECUTE <span class="hljs-string"><span class="hljs-string">'DROP TABLE myschema.'</span></span> || quote_ident(_result.tablename); _return_message := return_message || <span class="hljs-string"><span class="hljs-string">'Dumped table: '</span></span> || _result.tablename::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span> || <span class="hljs-string"><span class="hljs-string">', '</span></span>; RAISE NOTICE <span class="hljs-string"><span class="hljs-string">'Dumped table %'</span></span>, _result.tablename::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; EXCEPTION WHEN OTHERS THEN _return_message := return_message || <span class="hljs-string"><span class="hljs-string">'ERROR dumping table: '</span></span> || _result.tablename::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span> || <span class="hljs-string"><span class="hljs-string">', '</span></span>; RAISE NOTICE <span class="hljs-string"><span class="hljs-string">'ERROR DUMPING %'</span></span>, _result.tablename::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; END; END IF; END LOOP; RETURN _return_message || <span class="hljs-string"><span class="hljs-string">'Done'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>; END; $BODY$ LANGUAGE plpgsql VOLATILE COST <span class="hljs-number"><span class="hljs-number">100</span></span>; ALTER FUNCTION myschema.partition_maintenance(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">date</span></span>) OWNER TO postgres; GRANT EXECUTE ON FUNCTION myschema.partition_maintenance(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">date</span></span>) TO postgres; GRANT EXECUTE ON FUNCTION myschema.partition_maintenance(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">date</span></span>) TO my_role;</code> </pre> <br><br>  The function you see below is also generic and allows you to pass the name of the table you want to export to the OS and the name <br>  compressed file that will contain this table. <br><br><pre> <code class="hljs mel">-- Helper Function <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> maintenance CREATE OR REPLACE FUNCTION myschema.export_partition(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) RETURNS <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> AS $BASH$ #!/bin/bash tablename=${1} filename=${2} # NOTE: pg_dump must be available <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the path. pg_dump -U postgres -t myschema.<span class="hljs-string"><span class="hljs-string">"${tablename}"</span></span> my_database| gzip -c &gt; ${filename} ; $BASH$ LANGUAGE plsh; ALTER FUNCTION myschema.export_partition(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) OWNER TO postgres; GRANT EXECUTE ON FUNCTION myschema.export_partition(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) TO postgres; GRANT EXECUTE ON FUNCTION myschema.export_partition(<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) TO my_role;</code> </pre> <br><br>  Please note that the code above uses the plsh language extension as explained below.  It should also be noted that in our system bash is located in / bin / bash. <br><br><h4>  Interesting, isn't it? <br></h4><br>  Everything is almost done.  So far we have made all the necessary changes inside the database to place the table partitions: <br><ul><li>  Created a new master table </li><li>  Created trigger and trigger function for main table </li><li>  Created a partition maintenance function to export old partitions and lower them. </li></ul><br><br>  What we need to do to automate the service: <br><ul><li>  Install the plsh extension </li><li>  Configure the OS to store the partition dumps </li><li>  Create a cron job to automate the call to the partition service function </li></ul><br><br><h4>  PostgreSQL and OS configuration <br></h4><br>  <b>Enable <a href="http://plsh.projects.pgfoundry.org/">PLSH</a> in PostgreSQL</b> <br>  The PLSH extension is needed in PostgreSQL to run shell commands.  It is used in myschema.export_partition (text, text) to dynamically create shell lines to run pg_dump.  From as root, run the following commands <br><br><pre> <code class="hljs pgsql">root# cd /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/src #    .so  postgresql root# curl -L href="https://github.com/petere/plsh/archive/9a429a4bb9ed98e80d12a931f90458a712d0adbd.tar.gz"&gt;https://github.com/petere/plsh/archive/<span class="hljs-number"><span class="hljs-number">9</span></span>a429a4bb9ed98e80d12a931f90458a712d0adbd.tar.gz -o plsh.tar.gz root# tar zxf plsh.tar.gz root# cd plsh-*/ root# make <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> install # ! postgres <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>     root# su - postgres #       postgresql postgres$ psql my_database #         my_database&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> plsh; # :       </code> </pre><br><br><h5>  Create a folder <br></h5><br><pre> <code class="hljs objectivec">root<span class="hljs-meta"><span class="hljs-meta"># mkdir -p /db/partition_dump</span></span></code> </pre><br>  Make sure that the postgres user owns the folder, and that the user's deployment group has access to read these files.  The user for the default deployment in Engine Yard Cloud is the user 'deploy'. <br><br><pre> <code class="hljs objectivec">root<span class="hljs-meta"><span class="hljs-meta"># chown postgres:deploy /db/partition_dump</span></span></code> </pre><br>  More information about PL / SH can be found in the plsh project documentation. <br><br><h4>  Partition scheduling <br></h4><br>  The command below will schedule partition_maintenance every day at midnight. <br><br><pre> <code class="hljs mel">root# su - postgres ##   ,   cron job postgres$ mkdir -p $HOME/bin/pg_jobs ##      postgres$ cat &gt; $HOME/bin/pg_jobs/myschema_partition_maintenance #!/bin/bash # : psql      . psql -U postgres glimpse &lt;&lt;SQL SELECT myschema.partition_maintenance(<span class="hljs-string"><span class="hljs-string">'server'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, <span class="hljs-string"><span class="hljs-string">'server_master'</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>, now()::<span class="hljs-keyword"><span class="hljs-keyword">date</span></span> ); SQL ##   &lt;ctrl+d&gt;     ‚Äúcat‚Äù postgres$ exit ##   postgres    : root# chmod +x /home/postgres/bin/pg_jobs/myschema_partition_maintenance # Make script executable root# crontab -u postgres -e ##  : <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> * * * /home/postgres/bin/pg_jobs/myschema_partition_maintenance</code> </pre><br><br>  Check the cron jobs for the postgres user to verify that the crontab line is correct: <br><pre> <code class="hljs objectivec">root<span class="hljs-meta"><span class="hljs-meta"># crontab -u postgres -l</span></span></code> </pre> <br>  0 0 * * * / home / postgres / bin / pg_jobs / myschema_partition_maintenance <br><br>  Make sure that you have a backup copy of the <i>/ db / partition_dump</i> folder if you are not using an instance on Engine Yard Cloud.  If you need this information again, you will need these files to restore old partitions.  This can be done using rsyncing (copying) these files to another server for greater certainty.  We believe that <a href="http://ru.wikipedia.org/wiki/Amazon_S3">S3</a> is great for such archiving. <br>  So, we have planned that the maintenance of your main table will be performed at a certain time, and you can relax, knowing that you have done something special: an agile database that will follow the diet itself! <br><br><h4>  We load old partitions <br></h4><br>  If you are tormented by separation from old data, or there may be a request for <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B0%25D0%25B5%25D0%25BD%25D1%2581-%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D1%258C">compliance control</a> found on your desktop, you can still load old partitions from system files. <br>  To do this, we will go to the / db / partition_dump folder on your local db server and identify the required file.  The postgres user then imports this file into the database. <br><br><pre> <code class="bash hljs">postgres$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /db/partition_dump postgres$ ls <span class="hljs-comment"><span class="hljs-comment">#      postgres$ psql my_database &lt; name_of_partition_dump_file</span></span></code> </pre><br><br>  After the file is uploaded, you can again send requests from the main table to it.  Do not forget that the next time the scheduler starts processing a partition, this old partition will be exported again. <br><br><h4>  Let's see it in work <br></h4><br><h5>  Creating child tables <br></h5><br>  Let's load two lines of information to look at the new subsidiary partition in action.  Open the psql session and run the following command: <br><br><pre> <code class="bash hljs">postgres$ psql my_database my_database&gt; INSERT INTO myschema.server_master (server_id, cpu, memory, disk, time) VALUES (123, 20.14, 4086000, <span class="hljs-string"><span class="hljs-string">'{sda1:510000}'</span></span>, 1359457620); --Will create <span class="hljs-string"><span class="hljs-string">"myschema"</span></span>.<span class="hljs-string"><span class="hljs-string">"servers_2013-01-29"</span></span> my_database&gt; INSERT INTO myschema.server_master (server_id, cpu, memory, disk, time) VALUES (123, 50.25, 4086000, <span class="hljs-string"><span class="hljs-string">'{sda1:500000}'</span></span>, 1359547500); --Will create <span class="hljs-string"><span class="hljs-string">"myschema"</span></span>.<span class="hljs-string"><span class="hljs-string">"servers_2013-01-30"</span></span></code> </pre><br><br>  So what happened?  Assuming you run this for the first time, two child tables were created.  See the comments in the sql message for creating child tables.  The first insert can be seen by choosing from the main or from the child table: <br><br><pre> <code class="bash hljs">SELECT * FROM myschema.server_master; --   SELECT * FROM myschema.<span class="hljs-string"><span class="hljs-string">"server_2013-01-29"</span></span>; --   </code> </pre><br><br>  Notice that we use double quotes around the table name of the child partition.  We do this not because it is an inherited table, but because of the hyphen used between year-month-day. <br><br><h5>  We start service of tables <br></h5><br>  Two lines that we have made more than 15 days.  After manually starting the partition service (as it would be started via cron), two partitions will be exported to the OS, and these partitions will be dropped. <br>  postgres $ / home / postgres / bin / pg_jobs / myschema_partition_maintenance <br><br>  Upon completion, we will be able to see two exported files: <br><br><pre> <code class="bash hljs">postgres$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /db/partition_dump postgres$ ls -alh ‚Ä¶ -rw------- 1 postgres postgres 1.0K Feb 16 00:00 servers_2013-01-29_20130216_000000.000000.sql.gz -rw------- 1 postgres postgres 1.0K Feb 16 00:00 servers_2013-01-30_20130216_000000.000000.sql.gz</code> </pre><br><br>  If you try to select the main table, it will return 0 rows to you, so that the two child tables no longer exist. <br><br><h5>  Loading old partitions <br></h5><br>  if you want to load old child tables, first gunzip and then load with psql: <br><br><pre> <code class="bash hljs">postgres$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /db/partition_dump postgres$ gunzip servers_2013-01-29_20130216_000000.000000.sql.gz postgres$ psql my_database &lt; servers_2013-01-29_20130216_000000.000000.sql</code> </pre><br><br>  If you send a select to the main table, the result will be 1 row - the child table is restored. <br><br><h4>  Notes <br></h4><br>  Our database files are on a partition on / db which is separated from our root ('/') partition. <br>  To learn more about PostgreSQL extensions, read the following <a href="http://www.postgresql.org/docs/current/static/extend.html">documentation</a> . <br>  The database engine will not return the correct number of rows of the affected tables (always 0 affected tables) after sending INSERT or UPDATE to the main table.  If you use Ruby, do not forget to tweak the code, given that pg jam will not correctly display the correct values ‚Äã‚Äãwhen reporting cmd_tuples.  If you use ORM, then hopefully they fix it accordingly. <br>  Do not forget to backup exported partitions to / db / partition_dump, these files lie outside the standard path to create database backups. <br>  The database user who performs INSERT into the main table must also have <a href="http://www.postgresql.org/docs/9.2/static/sql-grant.html">DDL</a> permissions to create child tables. <br>  When implementing INSERT into the main table, a slight change in performance will be noticeable, since the trigger function will be launched. <br>  Be sure to use the latest version of PostgreSQL.  This ensures that you are working with the most stable and secure version. <br>  This solution works for my situation, your requirements may be different, so feel free to change, add to, cripple, laugh hysterically or copy it for your own purposes. <br><br>  Ps my translation  I hope the article will be useful. </div><p>Source: <a href="https://habr.com/ru/post/171745/">https://habr.com/ru/post/171745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171729/index.html">CeBIT 2013: SMI Augmented Eyewear Goggles</a></li>
<li><a href="../171731/index.html">JavaScript Prototypes for C / C ++ / C # / Java Programmers</a></li>
<li><a href="../171733/index.html">Nirvana for Testers - Nerrvana</a></li>
<li><a href="../171735/index.html">Animation UIView: moving along an arbitrary trajectory on the example of a circle</a></li>
<li><a href="../171743/index.html">Arbitrary view of the file field in html-form, the same in all browsers</a></li>
<li><a href="../171747/index.html">CeBIT'13. The first day</a></li>
<li><a href="../171749/index.html">Caution: Intruders</a></li>
<li><a href="../171751/index.html">Differential Evolution: Genetic Function Optimization Algorithm</a></li>
<li><a href="../171757/index.html">Nginx and Websockets</a></li>
<li><a href="../171759/index.html">Entropy and decision trees</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>