<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java 9 tutorial for those who have to work with legacy code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good evening, colleagues. Exactly one month ago we received a contract for the translation of the book " Modern Java " from the publishing house Manni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java 9 tutorial for those who have to work with legacy code</h1><div class="post__text post__text-html js-mediator-article"> Good evening, colleagues.  Exactly one month ago we received a contract for the translation of the book " <a href="https://www.amazon.com/Modern-Java-Action-functional-programming/dp/1617293563/">Modern Java</a> " from the publishing house Manning, which should be one of our most notable new products in the coming year.  The problem of "Modern" and "Legacy" in Java is so acute that the need for such a book is quite overdue.  The scale of the disaster and how to solve problems in Java 9 are briefly described in the article by Wayne Citrin, the translation of which we want to offer you today. <br><a name="habracut"></a><br>  Every few years, with the release of a new version of Java, speakers at JavaOne begin to savor new language constructs and APIs, praise their merits.  And zealous developers in the meantime can not wait to introduce new features.  Such a picture is far from reality - it does not take into account at all that most programmers are busy <a href="https://techbeacon.com/why-you-need-software-lifecycle-virtualization">supporting and refining existing applications</a> , rather than writing new applications from scratch. <br><br>  Most applications ‚Äî especially commercial ones ‚Äî must be backward compatible with earlier versions of Java, which do not support all of these new super-duper features.  Finally, the majority of customers and end users, especially in the segment of large enterprises, are wary of a radical update of the Java platform, preferring to wait until it gets stronger. <br><br>  Therefore, as soon as the developer is going to try a new opportunity, he faces problems.  Would you use default interface methods in your code?  Maybe - if you're lucky, and your application does not need to interact with Java 7 or lower.  Want to use the <code>java.util.concurrent.ThreadLocalRandom</code> class to generate pseudo-random numbers in a multi-threaded application?  It will not work if your application should work simultaneously on Java 6, 7, 8 or 9. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With the release of the new release, developers who are engaged in supporting the inherited code feel like children who are forced to stare at the window of a pastry shop.  They are not allowed inside, therefore their destiny is disappointment and frustration. <br><br>  So, is there anything in the new release of Java 9 for programmers involved in supporting legacy code?  Something that could make their lives easier?  Fortunately, yes. <br><br>  <b>What had to be done with the support of the legacy code, the appearance of Java 9</b> <br><br>  Of course, you can cram the capabilities of the new platform into <a href="https://techbeacon.com/containers-microservices-how-modernize-legacy-applications">legacy applications</a> , in which you need to maintain backward compatibility.  In particular, there is always the opportunity to take advantage of the new APIs.  However, it may turn out a bit ugly. <br><br>  For example, you can use late binding if you want to access the new API when your application also needs to work with older versions of Java that do not support this API.  Suppose you need to use the <code>java.util.stream.LongStream</code> class, introduced in Java 8, and you want to use the <code>anyMatch(LongPredicate)</code> method of this class, but your application must be compatible with Java 7. You can create an auxiliary class like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> classLongStreamHelper { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longStreamClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longPredicateClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Method anyMatchMethod; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { longStreamClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.stream.LongStream"</span></span>); longPredicateClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.function.LongPredicate"</span></span>); anyMatchMethod = longStreamClass.getMethod(<span class="hljs-string"><span class="hljs-string">"anyMatch"</span></span>, longPredicateClass): } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchMethodException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object theLongStream, Object thePredicate)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NotImplementedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (longStreamClass == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Boolean result = (Boolean) anyMatchMethod.invoke(theLongStream, thePredicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.booleanValue(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-comment"><span class="hljs-comment">// lots of potential exceptions to handle. Let's simplify. throw new NotImplementedException(); } } }</span></span></code> </pre> <br>  There are ways to simplify this operation, or make it more general, or more effective - you get the idea. <br><br>  Instead of calling <code>theLongStream.anyMatch(thePredicate)</code> , as you would in Java 8, you can call <code>LongStreamHelper.anyMatch(theLongStream, thePredicate)</code> in any version of Java.  If you are dealing with Java 8, it will work, but if with Java 7, the program will throw a <code>NotImplementedException</code> exception. <br><br>  Why is it ugly?  Because the code may become overly complicated if you need to access a set of APIs (in fact, even now, with a single API, this is already inconvenient).  In addition, this practice is not type safe, since the code cannot directly mention <code>LongStream</code> or <code>LongPredicate</code> .  Finally, this practice is much less efficient, due to the costs of reflection, and also because of the additional <code>try-catch</code> blocks.  Consequently, although it is possible to do so, it is not too interesting, and is fraught with inadvertent errors. <br><br>  Yes, you can access the new API, and your code still maintains backward compatibility, but with new language constructs you will not succeed.  For example, suppose we need to use lambda expressions in code that must remain backward compatible and work in Java 7. You are not lucky.  The Java compiler does not allow specifying the source version above target.  So, if you set the level of compliance with source code 1.8 (i.e., Java 8), and the target level of compliance is 1.7 (Java 7), the compiler will not allow you to do this. <br><br>  <b>JAR-files of different versions will help you.</b> <br><br>  Relatively recently, another great opportunity to use the latest features of Java, while allowing applications to work with older versions of Java, where such applications were not supported, appeared.  In Java 9, this feature is provided for both new APIs and new Java language constructs: talking about <a href="http://openjdk.java.net/jeps/238">multi-variance JAR files</a> . <br><br>  Different JAR files are almost the same as the good old JAR files, but with one important caveat: the new JAR files have a kind of ‚Äúniche‚Äù where you can write classes that use the latest features of Java 9. If you work with Java 9, then The JVM will find this ‚Äúniche‚Äù, use the classes from it and ignore the classes of the same name from the main part of the JAR file. <br><br>  However, when working with Java 8 or lower, the JVM is not aware of the existence of this ‚Äúniche‚Äù.  It ignores it and uses classes from the main part of the JAR file.  With the release of Java 10, a new, similar ‚Äúniche‚Äù will appear for classes using the most current features of Java 10 and so on. <br><br>  In <a href="http://openjdk.java.net/jeps/238">JEP 238</a> , the Java revision clause, which describes the JAR files, is a simple example.  Suppose we have a JAR file with four classes running in Java 8 or lower: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class</code> </pre> <br>  Now imagine that after Java 9 comes out, we rewrite classes A and B so that they can use the new features specific to Java 9. Then Java 10 comes out, and we rewrite class A again so that it can use the new Java 10 features. , the application should still work fine with Java 8. The new JAR file of different versions looks like this: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class - META-INF Versions - <span class="hljs-number"><span class="hljs-number">9</span></span> - A.class - B.class - <span class="hljs-number"><span class="hljs-number">10</span></span> - A.class</code> </pre> <br>  The JAR file has not only acquired a new structure;  now in its manifest it is indicated that this file is of different versions. <br><br>  When you run this Java 8 JVM JAR file, it ignores the <code>\META-INF\Versions</code> section, because it does not even know about it and does not search for it.  Only original classes A, B, C and D are used. <br><br>  When running under Java 9, the classes in <code>\META-INF\Versions\9</code> are used, and they are used instead of the original classes A and B, but the classes in <code>\META-INF\Versions\10</code> ignored. <br><br>  When running under Java 10, both <code>\META-INF\Versions</code> branches are used;  in particular, version A of Java 10, version B of Java 9, and the default versions of C and D. <br><br>  So, if you need a new ProcessBuilder API from Java 9 in your application, but you need to ensure that the application continues to work under Java 8, just write new versions of your classes using ProcessBuilder into the <code>\META-INF\Versions\9</code> section of the JAR file , and leave the old classes in the main part of the archive used by default.  This is the easiest way to use new Java 9 features without sacrificing backward compatibility. <br><br>  In Java 9 JDK, there is a version of the jar.exe tool that supports the creation of multi-version JAR files.  Other non-JDK tools also provide this support. <br><br>  <b>Java 9: ‚Äã‚Äãmodules, modules everywhere</b> <br><br>  <a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/">The Java 9 module system</a> (also known as Project Jigsaw) is undoubtedly the biggest change in Java 9. One of the goals of modularization is to strengthen the Java encapsulation mechanism so the developer can specify which APIs are provided to other components and can be calculated that the JVM will impose encapsulation.  With modularization, encapsulation is stronger than with the use of <code>public/protected/private</code> access modifiers for classes or class members. <br><br>  The second goal of modularization is to indicate which modules other modules need to work and, before launching the application, make sure in advance that all the necessary modules are in place.  In this sense, modules are stronger than the traditional classpath mechanism, since the classpath paths are not checked in advance, and errors are possible due to the lack of necessary classes.  Thus, an incorrect classpath can be detected already when the application has time to work long enough, or after it has been launched many times. <br>  The whole system of modules is large and complex, and its detailed discussion is beyond the scope of this article (Here is a good, <a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/">detailed explanation</a> ).  Here I will focus on those aspects of modularization that help the developer with the support of legacy applications. <br><br>  Modularization is a good thing, and the developer should try to break the new code into modules whenever possible, even if the rest of the application is (yet) not modularized.  Fortunately, this is easy to do thanks to the specification for working with modules. <br><br>  First, the JAR file becomes modularized (and turns into a module) when the module-info.class file (compiled from module-info.java) appears at the root of the JAR file.  <code>module-info.java</code> contains metadata, in particular, the name of the module whose packages are exported (that is, visible from the outside), which modules this module requires and some other information. <br><br>  The information in <code>module-info.class</code> is visible only in cases where the JVM is looking for it ‚Äî that is, the system treats modularized JAR files exactly as usual if it works with older versions of Java (it is assumed that the code was compiled to work with an older version of Java Strictly speaking, it requires a little pohimichit, and still specify Java 9 as the target version of module-info.class, but this is real). <br><br>  Thus, you should be able to run modularized JAR files with Java 8 and below, provided that in other respects they are also compatible with earlier versions of Java.  Also note that the <code>module-info.class</code> can, with reservations, <a href="https://www.voxxed.com/blog/2016/11/java-9-series-multi-release-jar-files/">be placed in versioned areas of different JAR-files</a> . <br><br>  In Java 9, there is a classpath as well as a module path.  and a module path.  Classpath works as usual.  If you put a modularized JAR file in the classpath, it is wasted like any other JAR file.  That is, if you modularized the JAR file, and your application is not yet ready to treat it as a module, you can put it in the classpath, it will work as always.  Your inherited code should handle it quite successfully. <br><br>  Also note that the collection of all JAR files in the classpath is considered part of the only unnamed module.  Such a module is considered the most common, however, it exports all the information to other modules, and can refer to any other modules.  Thus, if you do not have a modularized Java application, but there are some old libraries that are not yet modularized (and probably never will be), you can simply put all these libraries in the classpath and the whole system will work fine. <br><br>  Java 9 has a module path that works along with the classpath.  When using modules from this path, the JVM can check (both at compile time and at run time) whether all the necessary modules are in place, and report an error if there are not enough modules.  All JAR files in the classpath, as members of a nameless module, are available to modules listed in a modular path ‚Äî and vice versa. <br><br>  It is easy to transfer the JAR file from the classpath to the module path - and take full advantage of modularization.  First, you can add the <code>module-info.class</code> file to the JAR file, and then put the modular JAR file in the module path.  Such a new module will still be able to access all the remaining JAR files in the JAR classpath, since they are included in an unnamed module and remain in access. <br><br>  It is also possible that you do not want to modularize the JAR file, or that the JAR file does not belong to you, but to someone else, so you cannot modularize it yourself.  In this case, the JAR file can still be put in the path of the modules; it will become an automatic module. <br><br>  An automatic module is considered a module, even if it does not have a <code>module-info.class</code> .  This module is named after the JAR file in which it is contained, and other modules can explicitly request it.  It automatically exports all of its publicly available APIs and reads (that is, requires) all other named modules, as well as unnamed modules. <br><br>  Thus, an unmodularized JAR file from the classpath can be turned into a module without doing anything at all.  Inherited JAR files are automatically converted into modules, they simply lack some information that would allow to determine if all the necessary modules are in place, or to determine what is missing. <br><br>  Not every non-modularized JAR file can be moved to the module path and turned into an automatic module.  There is a rule: a <a href="http://openjdk.java.net/projects/jigsaw/spec/sotms/">package can be part of just one named module</a> .  That is, if the package is in more than one JAR file, then only one JAR file with this package in composition can be turned into an automatic module.  The rest can remain in the classpath and become part of a nameless module. <br><br>  At first glance, the mechanism described here seems complicated, but in practice it is very simple.  In fact, in this case, the only thing is that you can leave the old JAR-files in the classpath or move them to the module path.  You can break them into modules or not.  And when your old JAR files are modularized, you can leave them in the classpath or move them to the modules path. <br><br>  In most cases, everything should simply work as before.  Your inherited JAR files should take root in a new modular system.  The more you modularize the code, the more dependency information you need to check, and the missing modules and APIs will be detected at much earlier stages of development and may save you from large chunks of work. <br><br>  <b>Java 9 "does it yourself": Modular JDK and Jlink</b> <br><br>  One of the problems with legacy Java applications is that the end user may not work with a suitable Java environment.  One way to ensure that a Java application is operational is to provide a runtime environment with the application.  Java allows you to create private (re-distributed) JREs that can be distributed within an application.  <a href="http://www.oracle.com/technetwork/java/javase/jre-8-readme-2095710.html">Here</a> 's how to create a private JRE.  As a rule, the hierarchy of the JRE files that is installed along with the JDK is taken, the necessary files are saved, and optional files are saved with the functionality that your application may need. <br><br>  The process is a bit troublesome: it is necessary to maintain the hierarchy of installation files, but be careful, so you don‚Äôt miss a single file, not a single directory.  In itself, this does not hurt, however, I still want to get rid of all the excess, because these files take up space.  Yes, it is easy to give in and make such a mistake. <br><br>  So why not reassign this work to the JDK? <br><br>  In Java 9, you can create a self-contained environment added to the application ‚Äî and in this environment you will have everything you need to run the application.  You no longer have to worry about the wrong Java environment on the user's computer, you do not have to worry about the wrong JRE you have built yourself. <br><br>  The key resource for creating such <a href="http://openjdk.java.net/jeps/220">self-sufficient executable images</a> is a modular system.  Now it is possible to modularize not only your own code, but also Java 9 JDK itself.  Now the Java class library is a collection of modules, and the JDK tools also consist of modules.  The module system requires you to specify the base class modules that are needed in your code, and you specify the necessary JDK elements. <br><br>  To put it all together, Java 9 has a special tool called <a href="http://openjdk.java.net/jeps/282">jlink</a> .  By running jlink, you get a hierarchy of files ‚Äî exactly the ones you need to run your application, no more, no less.  Such a set will be much smaller than the standard JRE, moreover, it will be platform-specific (that is, chosen for a specific operating system and machine).  Therefore, if you want to create such executable images for other platforms, you will need to run jlink in the context of the installation on each specific platform for which you need such an image. <br><br>  Also note that if you run jlink with an application in which nothing is modularized, the tool simply does not have the necessary information to compress the JRE, so there is nothing left for jlink except to pack the whole JRE.  Even in this case, you will be a little more comfortable: jlink will pack the JRE for you, so you need not worry about how to copy the file hierarchy correctly. <br><br>  With jlink, it becomes easy to pack an application and all that is needed to run it ‚Äî and you need not worry about doing something wrong.  The tool will pack only that part of the execution environment that is required for the operation of the application.  That is, a legacy Java application is guaranteed to receive an environment in which it will be operational. <br><br>  <b>Meeting old and new</b> <br><br>   ,     Java-   ,      ,     .  Java 9,     ,      API   ,   (  )  ,      ,         Java. <br><br>     Java 9: -,      ,        ,      Java. <br><br>  JAR-      Java 9       JAR-,     Java   .  ,      Java 9,     Java 8        ‚Äì     . <br><br>   Java,    ,     JAR-   ,     .   ,             ,  ¬´  ¬ª   . <br><br>   JDK  jlink,             ,       .       ,    Java    ‚Äì    . <br><br>      Java,  Java 9       ,             ‚Äì       ,   ,          Java. </div><p>Source: <a href="https://habr.com/ru/post/417733/">https://habr.com/ru/post/417733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417723/index.html">Using the KOMPAS-3D API ‚Üí Lesson 11 ‚Üí Simple Text Labels</a></li>
<li><a href="../417725/index.html">How ‚ÄúFlant‚Äù Hires Employees</a></li>
<li><a href="../417727/index.html">Blue Origin has returned to Earth and reusable level, and the crew capsule</a></li>
<li><a href="../417729/index.html">The Intel Core i7-8086K (Part 2)</a></li>
<li><a href="../417731/index.html">Story of a single t61</a></li>
<li><a href="../417735/index.html">Public key infrastructure: GnuPG / SMIME and PKCS # 11 tokens with Russian cryptography support</a></li>
<li><a href="../417737/index.html">Here it is, our summer</a></li>
<li><a href="../417739/index.html">Machine learning against credit risk, or "come on, Gini, come on"</a></li>
<li><a href="../417741/index.html">July 27, 2018 - total lunar eclipse and the great opposition of Mars</a></li>
<li><a href="../417743/index.html">Legendary amplifiers ‚Äî historical anatomy of trends: ‚Äúcold‚Äù transistor sound</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>