<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What follows the web?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, I argued that it was time to think about how to replace a modern web platform for applications. The reasons are its low productivit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What follows the web?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/59/cd/b7/59cdb7d5a156d589025469.jpeg" align="left">  In the <a href="https://habrahabr.ru/post/338880/">first part,</a> I argued that it was time to think about how to replace a modern web platform for applications.  The reasons are its low productivity and, in principle, unsolvable security problems. <br><br>  Some have decided that I am writing too negatively and not paying attention to the positive aspects of the web.  So it is: the first part was in the style of ‚ÄúLet's discuss the fact that we fell into a deep hole‚Äù, and the second part - ‚ÄúHow to develop something better?‚Äù This is a huge topic, so in fact it will not be limited to two parts. <br><br>  Let's call our competitor the web NewWeb (er, you can do branding later).  First you need to understand why the web initially became successful.  The web has bypassed other application creation technologies with the best GUI development tools, so it clearly has some qualities that outweigh the disadvantages.  If we do not meet these qualities, we are doomed. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8CI718A8OUI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>  <i><font color="gray">GUI creation in Matisse, UI editor with auto-alignment and delimiters.</font></i>  <i><font color="gray">Long live the (new stylish) king?</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is also necessary to concentrate on cheapness.  The web has numerous development teams.  Most of their work is duplicated or discarded, some can be reused.  A new development in a small amount is also possible ... but by and large any NewWeb technology will have to be assembled from pieces of existing software.  The poor do not have to choose. <br><br><hr><br>  Here is my personal list of the top five web properties: <br><br><ul><li>  Sandbox Deployment and Isolation </li><li>  Easy to learn users and developers </li><li>  Eliminate document / application dichotomy </li><li>  Advanced styling and branding </li><li>  Open source and free use </li></ul><br>  This is not exactly what is generally considered the main principles of the architecture: if you interview the developers, most of them are likely to be called the essence of the architecture of the Web URL, viewing the source code, cross-platform, HTTP, and so on.  But these are all just implementation details.  The Web has got the upper hand over Delphi and Visual Basic not because JavaScript is so cool.  There are deeper reasons. <br><br>  The above things are, in principle, quite understandable.  I will analyze them in more detail during the article.  To defeat the web, it is not enough just to repeat its strengths, we must go further and offer unique improvements that the web is not able to integrate easily.  Otherwise it makes no sense: instead of our project, we will simply work on improving the web. <br><br>  In this article, I propose two things: certain principles of architecture, which, in my opinion, should be followed by any serious competitor of the web, and a concrete example compiled from various open source projects.  Many readers will not like a specific example, because they like other projects or programming languages, there is nothing to worry about.  I do not care.  This is just an illustration - the principles are really important.  I call specific code bases just to illustrate that these dreams are not completely unrealistic. <br><br><h1>  Principles of architecture </h1><br>  The web lacks an intelligible philosophy of architecture, at least in terms of applications.  Here are some of the necessary things he lacks, in my opinion: <br><br><ol><li>  <b>Clear concept of application ids.</b> </li><li>  <b>Single view of data from backend to frontend.</b> </li><li>  <b>Binary protocols and APIs.</b> </li><li>  <b>User authentication at the platform level.</b> </li><li>  IDE oriented development. </li><li>  Components, modules, and a great UI layout system - just like in the usual development for desktop computers or mobile devices. </li><li>  You will also need things that the web does well: instantly launching streaming applications without installation or the need for manual updates, isolating these applications in the sandbox, complicated UI styling, a combination of and alignment of ‚Äúdocumentary‚Äù and ‚Äúsoftware‚Äù material (such as the ability to link certain types of applications), the possibility of gradual learning and architecture, which does not make it difficult for developers to create too complex UIs. </li></ol><br>  The first four points highlighted in bold are related to security, because it was security issues that forced me to take such a radical position.  Perhaps the poor performance of the web can be fixed with a new JavaScript framework - maybe.  But I do not think that you can fix security problems.  In subsequent articles, I will consider items that are not bold. <br><br><h1>  Application IDs and Links </h1><br>  To get the benefits of the web in deploying and isolating in a sandbox, you need some kind of browser for applications.  It would be nice to be able to refer to parts of the application as parts of a hypertext document.  This is a key element of web success: the Amazon search results page looks like an application, but we can link to it, so this is also a document. <br><br>  But our application browser should not physically resemble a web browser.  Take a fresh look: Web browser UI is not perfect. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b8e/eb3/d21/b8eeb3d21a75cfc47c39f0867b508040.png"><br><br>  The URL is the main part of the design of any browser, but sometimes it causes confusion! <br><br>  The first problem is that URLs get into the UI everywhere.  The address bar constantly contains random bits from the browser's memory, encoded in a form that is difficult for both people and machines to understand, which leads to a parade of exploits.  If the desktop application would unload random internal variables into the header row, we would consider this a serious bug that threatens the company's reputation, so why do we have to endure it here? <br><br>  The second problem is that it is also difficult for machines to perceive URLs ( <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf">it is possible to create crazy exploits here</a> ).  Without even considering clever coding tricks like this, there are various ways on the web to establish the identity of an application.  The browser requires a certain notion of the identity of the application for separating cookie stores and for tracking issued permissions.  This is the "origin".  Over time, the concept of the source on the web has evolved, and now it is essentially impossible to formulate.  <a href="https://tools.ietf.org/html/rfc6454">RFC 6454</a> attempts to do this, but the document itself says: <br><br><blockquote>  Over time, many technologies converged on the concept of a source as a convenient isolation unit.  However, many of the technologies currently used, such as cookies [RFC6265], were created earlier than the modern concept of a source on the web.  <b>These technologies often have different isolation units, leading to vulnerabilities.</b> </blockquote><br>  For example, consider what prevents your server from setting cookies for a .com domain.  What about kamagaya.chiba.jp?  (this is not a website, but just a <a href="https://publicsuffix.org/list/">section of the hierarchy</a> , like. com!) <br><br>  The ability to unexpectedly put a link to a part of an application that does not receive any benefit from it and does not expect this is one of the sources of the ‚Äúdangerous links‚Äù problem.  Strongly URL-based design puts your <i>entire</i> application in danger of data injection by unauthorized intruders.  This is a design limitation that is known to be almost impossible to fight against it, but it is carelessly encouraged by the web architecture itself. <br><br>  However, the ability to put a link to the middle of an application from documents and vice versa would be very pleasant if everything works as intended by the developers.  So, we formulate a couple of requirements: <br><br>  <b>Requirement: The application's identity (isolation) must be simple and predictable.</b> <b><br><br></b>  <b>Requirement: we should be able to put a deep link to the application, but not always.</b> <br><br>  To their credit, Android architects understood these requirements and offered solutions.  From here we can start: <br><br><ul><li>  The identity of the application determines the public key.  All documents signed with one key are isolated in the same domain.  To determine isolation, no line breaks are used. </li><li>  Applications can subscribe to receive strongly typed data packets that ask them to open in some state.  Android calls this concept ‚Äúintents‚Äù (intents).  Intentions are not really very strongly typed in Android, but they could be.  They can also be used for internal navigation, but to allow links from some other application, the intent must be published in the application manifest.  By default, applications do not respond to links. </li><li>  Where to find the application for download?  A domain name is a good enough position to start with.  Although we can support and download via HTTP [S], but we find the NewWeb server on a well-known port and retrieve the code from there.  So the domain name becomes the starting point for getting the application, but otherwise not so important. </li></ul><br>  To distinguish between URLs and other people's intentions from our own, let's call someone else's <i>link packages</i> . <br><br>  Disabling the reception of external links by default will lower the link connectivity of NewWeb, but will improve security.  Maybe this is a bad compromise and it will be fatal.  But many links that people can theoretically create in the modern web are essentially useless either because of authentication requirements, or because they do not contain any meaningful initial state (many SPAs).  Therefore, applications minimize the attack area.  Malicious link, which is the starting point of such a large number of exploits, immediately becomes less dangerous.  This seems like a valuable accomplishment. <br><br>  But there are other advantages - the importance of a domain name for web applications makes it tempting for providers to <a href="http://www.telegraph.co.uk/technology/2017/08/29/worlds-oldest-neo-nazi-website-stormfront-shut/">confiscate domains that their leadership does not like</a> .  Although simple sites can be transferred to another domain without any problems, more complex sites can value the established reputation of postal addresses, OAuth tokens, and so on, for them this is a more painful procedure.  Secret keys can be lost or stolen, but the same with domain names.  If you have lost the secret key - at least it is only your fault. <br><br>  As for the rest of the browser UI, you can probably get rid of them.  Tabs can be useful, but the page reload button should never be used, and the return button to the previous state can be embedded in the application itself, if it makes sense, a la iOS. <br><br>  How to create an application browser?  Although NewWeb is quite different from the web, the basic UI of full-screen applications is quite standard, and users will want to switch back and forth.  So why not fork Chromium and add a tab in the new mode? <br><br>  <i>(Edit: some have understood the above as ‚Äúusing Chrome for everything listed here‚Äù - this is not what I meant. I meant using its tabbed UI implementation so that you can have NewWeb and OldWeb open next to you. But a tabbed UI is easy to do, and it‚Äôs not necessary to use Chromium (the application browser can also be an application created from scratch).</i> <br><br><h1>  Single view of data </h1><br>  Maybe the link package concept sounds a bit vague.  What it is?  For a clearer definition, we need data structures. <br><br>  There are many ways to do this on the Web, but they are all text based.  I recall the thesis from my previous article: text protocols (not only JSON) have a fundamental vulnerability: this is ‚Äúin-band‚Äù signaling of the buffer, that is, to find out where the data ends, you need to read them all in search of a specific sequence of characters.  These sequences may be a legal part of the data, that is, you need a screening mechanism.  And then, since these protocols are supposed to be human-readable or at least unreadable, we often have strange borderline cases with handling spaces or canonized Unicode, which leads to exploits, like HTTP header splitting attacks. <br><br>  In the old days, text protocols helped web developers.  Browsing the source definitely helped me so many times that I can't count.  But now the average web <i>page</i> size is <a href="https://www.soasta.com/blog/page-bloat-average-web-page-2-mb/">over 2 megabytes</a> , not to mention web applications.  Even boring web pages with static text often contain a lot of minified scripts that you cannot even begin to understand without machine assistance.  The benefits of text protocols seem less than in past times. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc6/cc4/115/bc6cc41159d24e47e38748ab7b37a5f5.gif"><br>  <i><font color="gray">Primitive decompiler</font></i> <br><br>  To be honest, in recent years, the web has been slowly rejecting text protocols.  HTTP / 2 binary.  And the advertised ‚ÄúWebAssembly‚Äù is a binary way of expressing code, although it doesn't really solve the problems we talked about.  But nonetheless. <br><br>  <b>Requirement: data serialization should be automatic typed, binary and unchanged from data storage to fronted.</b> <br><br>  Serialization code is not only tedious to write, but it is also a serious attack vector.  A good platform should take on the challenge.  Let's define in the most primitive form the syntax for expressing data structures: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SortBy { Featured, Relevance, PriceLowToHigh, PriceHighToLow, Reviews } <span class="hljs-meta"><span class="hljs-meta">@PermazenType</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AmazonSearch</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sortBy: SortBy? ) : LinkPacket</code> </pre> <br>  On the web, the equivalent of this is the URL on amazon.com.  It defines the data structure of an immutable type to indicate a request to open an application in a certain state. <br><br>  This data structure is marked as <code>@PermazenType</code> .  What does it mean? <br><br>  If we are serious about the code with the prefixed length, the strict typification of protection against injections throughout the stack, then we have to do something with SQL.  Structured query language is a pleasant and well-understood way to express complex queries to a variety of extremely powerful database engines, so it is a pity.  But SQL is a text API.  Although SQL injections are one of the easiest types of exploits that are easy to understand and fix, they are also one of the most common bugs on websites.  No wonder: if you use SQL on the web server in the most obvious way, it will work fine, but quietly make the server vulnerable to hacking.  Parameterized queries help, but this is a screwed-up solution from the side, which not every situation can be used.  The technological stack creates a well-disguised bear trap for all of us, and our goal is to minimize the balance of risks and functionality. <br><br>  SQL has some other problems.  You will quickly encounter the problem of object-relational mapping.  The results of executing a SQL query cannot be natively sent over an HTTP connection or embedded in a web page, so you always need some kind of transformation to another format.  SQL hides the performance of the underlying queries from you.  Backend is difficult to scale.  Schema changes often require table freezing, so that they cannot be deployed without unacceptable downtime. <br><br>  NoSQL engines are not much better: they usually fix one or two of these problems, but at the expense of discarding SQL solutions for everything else.  In the end, you often get stuck with a solution that is different, but not necessarily the best.  As a result, the largest companies like Google and Bloomberg spend a lot of time trying to find a way to scale SQL databases ( <a href="https://research.google.com/pubs/pub41344.html">F1</a> , <a href="https://github.com/bloomberg/comdb2">ComDB2</a> ). <br><br>  <b><a href="https://github.com/permazen/permazen">Permazen</a></b> is a new data storage approach that delights me at the moment.  Quote from their site: <br><br><blockquote>  <i>Permazen is a completely new approach to robust programming.</i>  <i>Instead of starting development from the storage technology side, he starts from the programming language side, asking a simple question: ‚ÄúWhat problems are inherent in robust programming, regardless of the programming language or DBMS technology, and how can they be solved at the language level with the simplest, most correct? and in the most natural way from the point of view of language? "</i> </blockquote><br>  Permazen is a Java library.  However, its architecture and technology can be used on any platform or language.  She needs a sorted key-value repository of the type that many cloud providers can provide (she can also use RDBMS as K / V storage), but everything else is done inside the library.  It does not have tables or SQL.  Instead, she: <br><br><ul><li>  Uses host language operators to implement joins and intersections (connections). </li><li>  Schemas are directly defined by classes; you do not need to set an object-relational mapping. </li><li>  It can produce a step-by-step evolution of the ‚Äújust-in-time‚Äù scheme, eliminating the need to freeze the table to change the presentation of data in the repository. </li><li>  Transactions are established unequivocally, and copying data from a transaction and back is clearly controlled by the developer. </li><li>  Tracking changes so that you can receive callbacks when the underlying data changes, including between processes (if the K / V repository supports it, and often it does). </li><li>  There is a command line interface that allows you to query and work with the data store (for example, to initiate data migration if you are not satisfied with the schedule migration), and the GUI. </li></ul><br>  In fact, you just need to read a great <a href="https://cdn.rawgit.com/permazen/permazen/master/permazen-language-driven.pdf">report</a> or <a href="https://s3.amazonaws.com/archie-public/jsimpledb/JSimpleDB-BJUG-Slides2016-05-05.pdf">watch the slides</a> (the slides use the old library name, but this is the same software).  Permazen is not very well known, but it is the smartest and clever approach to closely integrating a data warehouse with an object-oriented language I have ever seen. <br><br>  One of the interesting features of Permazen is that you can use ‚Äútransaction snapshots‚Äù to serialize and deserialize the object graph.  This snapshot even includes indexes, that is, you can broadcast data to the local storage if the memory is low and you can already perform queries on the index.  It should now become clear how this library unifies data storage with support for offline synchronization.  Conflict resolution can be done transactionally, since all Permazen operations can be performed inside serializable transactions (if you want conflict-free work in the style of Google Docs, which requires an operational conversion library). <br><br>  It is not necessary to use this approach in NewWeb.  You can choose something a bit more traditional, like protobuf, but then you have to use a special IDL, which is equally inconvenient in all languages, and tag the fields.  You could use CBOR or ASN1.  In my current project, <a href="https://www.corda.net/">Corda,</a> we created our own object serialization engine built on AMQP / 1.0.  In it, by default, the messages describe themselves, so for each particular binary package you always get a schema - and therefore the source view function is available there, as in XML or JSON.  AMQP is preferred because it is an open standard, and the basic type system is pretty good (for example, it recognizes dates and annotations). <br><br>  The point is that it is risky to take data from potentially harmful sources, so that within the format it is desirable to get as many degrees of freedom as possible and the maximum number of integrity checks.  All buffers must be prefixed with length, so users cannot attempt to inject malicious data into the field ‚Äî such attempts will stop at an early stage.  The data must be carefully checked at boot time, and the best place for such a check is the type system and the constructors of the data structures themselves, a way that you might have forgotten about.  Schemes help to understand what the structure should be, preventing intruders from using type mixing. <br><br>  Despite the absolutely binary nature of the proposed scheme, it is possible to make a one-way conversion to text for debugging and educational purposes.  In fact, Permazen and it can. <br><br><h1>  Simplicity and phased learning </h1><br>  Type systems have one problem - they add extra complexity.  To developers who have not encountered types, they seem to be some sort of meaningless bureaucracy.  And without the proper tools, binary protocols can be more difficult to learn and debug. <br><br>  <b>Requirement: easy to learn</b> <br><br>  I am sure that a significant part of the success of the web is explained by the fact that it is not typed in essence.  Everything here is just strings.  Bad for safety, performance and ease of maintenance, but <i>very</i> good for training. <br><br>  One way to deal with such a structure in the world of the web is a gradual typing in JavaScript versions.  This is a good and valuable research work, but such dialects are not widely used, and most new languages ‚Äã‚Äãare at least partially strictly typed (Rust, Swift, Go, Kotlin, Ceylon, Idris ...). <br><br>  Another way to fulfill this requirement can be a smart IDE: if you allow developers to first work with untyped structures (all defined as <code>Any</code> ), the runtime can try to determine what the original types should be and translate this information back to the IDE.  She can then suggest a replacement for the best type annotations.  If the developer encounters type conversion errors while the program is running, then the IDE may offer to relax the restriction again. <br><br>  Of course, this approach provides less security and ease of maintenance than if you force the developer to think over the types in advance, but even relatively weak heuristically exposed types, which often lead to runtime errors, still protect against a large number of exploits.  Runtimes like JVM and V8 already collect information about these types.  Java 9 has a new API that allows you to control the virtual machine at a low level (JVMCI), it is engaged in such profiling - now it would be much easier to experiment with such tools. <br><br><h1>  Languages ‚Äã‚Äãand virtual machines </h1><br>  What language should NewWeb use?  Of course, this is a difficult question: the platform should not become fanciful. <br><br>  Over the past years, there have been many attempts to introduce other languages ‚Äã‚Äãto the web, except JavaScript, but all of them were unsuccessful without receiving consensus from browser developers (mostly from Mozilla).  In fact, in this respect, the web goes back in time - you could run Java, ActionScript, VBScript, and other languages, but browser vendors systematically removed all non-JavaScript plugins from the platform.  This is a shame.  Of course, it was possible to keep the competition.  The sad verdict to the web platform is that WebAssembly is the only attempt to add a new language, and that language is C ... in which I hope you don‚Äôt want to write web applications!  XSS is enough for us to add top-level vulnerabilities like double-freeing the same memory. <br><br>  It is always easier to agree with a problem than with a solution, but that's okay - the time has come to put forward a (more) contradictory thesis.  The core of my personal NewWeb design would be the JVM.  It will not surprise those who know me.  Why JVM? <br><br><ul><li>  HotSpot supports more different programming languages ‚Äã‚Äãthan any other virtual machine, and the low cost principle dictates the maximum possible use of open source code. <br><br>  Yes, it means that I want to leave the possibility to use <a href="https://www.youtube.com/watch%3Fv%3DOUo3BFMwQFo">JavaScript</a> (at high speed), in addition to <a href="http://chrisseaton.com/rubytruffle/">Ruby</a> , <a href="http://www.jython.org/">Python</a> , <a href="http://eta-lang.org/">Haskell</a> , and yes - <a href="https://llvm.org/devmtg/2016-01/slides/Sulong.pdf">C, C ++ and Rust will also remain in the game</a> .  All this is possible thanks to two really cool projects called Graal and Truffle, <a href="https://blog.plan99.net/graal-truffle-134d8f28fb69">which I talked about in detail</a> .  These projects allow the JVM to even run code in unexpected languages ‚Äã‚Äã(such as Rust) in a virtualized environment, quickly and interoperably.  I do not know of any other virtual machine that organically blends together so many languages ‚Äã‚Äãand does so with such high performance. </li><li>  Over the years, the OpenJDK sandbox has undergone stubborn attacks, and browser developers have learned a number of painful lessons.  The last 0-day exploit is dated 2015, and the previous one was in 2013.  Only two 0-day sandbox exploits in five years are not bad, in my opinion, especially given the fact that after each of them lessons were learned and fundamental safety improvements were made over time.  No sandbox has an ideal reputation, so in reality it all comes down to personal preferences - what level of security should be considered <i>sufficient</i> ? </li><li>  There are a huge number of high-quality libraries that stack key puzzle pieces, such as Permazen and JavaFX. </li><li>  It so happened that I know the JVM quite well and I like Kotlin, which is suitable for the JVM backend. </li></ul><br>  I understand that many will disagree with my choice.  No problem - the same ideas of architecture can be implemented on the basis of Python, or V8, or Go, or Haskell, or whatever you are swimming into.  It is better to choose something with open specifications and the presence of competing implementations (like the JVM). <br><br>  Oracle policy does not bother me, because Java has open source.  Among the high-quality and high-performance open source runtimes there is a small selection.  Existing projects are created by large corporations that have messed themselves with controversial decisions in the past.  At various stages of its development, the web was influenced or directly controlled by Microsoft, Google, Mozilla and Apple.  All of them committed acts that I consider reprehensible: this is typical of large companies.  You do not want to always agree with their actions.  Oracle is unlikely to win the popularity contest, but the advantage of open source is that it will not have to participate in it. <br><br>  Specifically, from Google Chrome, I would have borrowed something.  My application browser should support the equivalent of WebGL (i.e. eGL), and <a href="https://chromium.googlesource.com/angle/angle/%2B/master/src/">the Chromium ANGLE project</a> is suitable for this purpose.  The application browser should be automatically updated invisibly, as Chrome does, and Google's automatic update engines are also distributed under a free license.  In the end, although the Pack200 format strongly compresses the code, using quality codecs like <a href="https://en.wikipedia.org/wiki/Zopfli">Zopfli</a> would not hurt. <br><br><h1>  RPC </h1><br>  Binary data structures are not enough.  Binary protocols are also needed.  The standard way to associate a client with a server is RPC. <br><br>  Currently, one of the coolest British startups is <a href="https://improbable.io/company/about-us">Improbable</a> .  Recently, developers have published <a href="https://improbable.io/games/blog/grpc-web-moving-past-restjson-towards-type-safe-web-apis">an excellent blog post about how they switched from REST + JSON to gRPC + protobuf from browser to server</a> .  Improbable describes the result as "safe typing nirvana."  Browsers do not do it as easily as with HTTP + XML or JSON, but using the necessary JavaScript libraries, you can tie the required stack on top.  It's a good idea.  If you return to the real world, where we all write web applications, you definitely should consider this option. <br><br>  Existing experience should be used in the development of RPC protocols.  My perfect RPC supports: <br><br><ul><li>  Return of futures (promises) and <a href="http://reactivex.io/">ReactiveX Observables</a> , so that you can broadcast push events in a natural way. </li><li>  Returning large or infinite byte streams (for example, for live video feeds). </li><li>  Flow control when transmitting traffic with low / high priority. </li><li>  Versioning, interface evolution, type checking. </li></ul><br>  Again, in the Corda project, we design <a href="https://docs.corda.net/clientrpc.html">the RPC stack</a> with exactly these properties.  We have not released it as a separate library yet, but we hope to do it in the future. <br>  HTTP / 2 is one of the most recent and most developed parts of the web; it is quite a decent frame transport protocol.  But he inherited a lot of trash from HTTP.  Just <a href="https://www.owasp.org/index.php/Test_HTTP_Methods_%2528OTG-CONFIG-006%2529">imagine what hacks become possible if you refuse HTTP methods that are never used anyway</a> .  HTTP's weird approach to state descriptions is not needed.  HTTP itself does not change the state in the execution process, but applications need state-storing sessions, so application developers have to add their own implementation over the protocol, using a mix of easily stolen cookies, tokens, and so on.  This leads to problems like <a href="https://en.wikipedia.org/wiki/Session_fixation">session commit attacks</a> . <br><br>  It is better to divide everything by layers more clearly: <br><br><ul><li>  Encryption, authentication and session management.  TLS copes well.  You can just use it. </li><li>  Transport and flow control.  HTTP / 2 does this, but messaging protocols like AMQP also do the job, and without the burden of legacy of the past. </li><li>  RPC </li></ul><br>  Obviously, the RPC stack is integrated with the data structure framework, so all data transfers are typed.  Developers will never need to parse manually.  <i>Naming</i> in RPC is a simple string comparison.  Therefore, there are no vulnerabilities going beyond the current directory (path traversal). <br><br><h1>  User Authentication and Sessions </h1><br>  NewWeb will not use cookies.  For identification of sessions, pairs of public and private keys are better suited.  <a href="https://www.ietf.org/proceedings/90/slides/slides-90-uta-0.pdf">The web is moving in this direction</a> , but to maintain compatibility with existing web applications a complicated ‚Äúbinding‚Äù stage is required, in which the owner's tokens, such as cookies, are connected to the carrier cryptographic session, and this adds additional complexity to an important security component - this stage can be abandoned. full redesign  Sessions are identified on the server side only by the public key. <br><br>  User authentication is one of the most difficult things that is difficult to implement correctly in a web application.  I <a href="https://blog.plan99.net/building-account-systems-f790bf5fdbe0">previously expressed a few thoughts on this matter</a> , so I will not repeat.  Suffice it to say that the binding of the session to the postal address is better to perform on the side of the basic platform, and not to constantly reinvent the wheel at the application level.  The TLS certificate on the client side is enough to implement a basic single sign-on system, where the workflow like ‚Äúsend a letter and sign a certificate if received‚Äù is so cheap that providers of free certificates in Let's Encrypt style will become quite real. <br><br>  This approach is based on existing technologies, but it will seriously reduce the number of phishing, password cracking, brute-force, and many other security-related issues. <br><br><h1>  Conclusion </h1><br>  A platform that wants to compete with the web should seriously bother with security issues, since this is the most important rationale for its creation and a competitive advantage.  This is the main thing that cannot be easily fixed on the web.  That is, we need: binary data structures with secure typing and binary APIs, RPC, cryptographic sessions and user identification. <br><br>  The new web also has code isolation in the sandbox and streaming of content, a UI with good prototyping, but at the same time well responsive and with style support, some way to mix documents and applications together, as the web does, and a very productive development environment.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We should also consider the new web policy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will discuss these issues in the next article.</font></font></div><p>Source: <a href="https://habr.com/ru/post/339112/">https://habr.com/ru/post/339112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339102/index.html">Ethereum Smart Contracts: What to do when you make a mistake in a smart contract or migration technique</a></li>
<li><a href="../339104/index.html">The tale of well-built business processes, or how one problem hacked a perfectly working development system</a></li>
<li><a href="../339106/index.html">How to work effectively with the advertising format Playable ads: five common mistakes</a></li>
<li><a href="../339108/index.html">Profiling PL / SQL code with IDE PL / SQL Developer</a></li>
<li><a href="../339110/index.html">In the paragraph, everything should be fine</a></li>
<li><a href="../339116/index.html">3 cases of real estate data analysis. Data Science Week 2017. Review. Part 1</a></li>
<li><a href="../339118/index.html">Three career paths in IT: founder, leader or employee</a></li>
<li><a href="../339120/index.html">What will happen in Rancher 2.0 and why does it switch to Kubernetes?</a></li>
<li><a href="../339122/index.html">Debugging PL / SQL code for an external DB session</a></li>
<li><a href="../339124/index.html">We write the generator of ip-addresses in Python with whistles, dudels and Tkinter GUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>