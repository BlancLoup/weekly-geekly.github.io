<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React HoC in TypeScript. Typing without pain</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many times when talking about translating React-projects into TypeScript, I often heard that the creation of HoCs (Higher-Order Components - wrapper c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React HoC in TypeScript. Typing without pain</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/jk/qe/1e/jkqe1e3fmylukqnxku5qejd-jwq.jpeg"><br><br>  Many times when talking about translating React-projects into TypeScript, I often heard that the creation of HoCs (Higher-Order Components - wrapper components) caused the most pain.  Today I will show you how to do it painlessly and quite easily.  This trick will be useful not only for TS projects, but also for ES6 + projects. <br><a name="habracut"></a><br>  As an example, take the HoC that wraps the standard HTMLInput, and in the first argument onChange, instead of the Event object, passes the actual value of the text field.  Consider 2 options for implementing this adapter: as a function, the host component, and as a wrapper. <br><br>  Many newcomers solve this problem head-on - using a React.cloneElement, they create a clone of the item, passed on as a child, with new Props.  But this leads to difficulties in maintaining this code.  Let's look at this example to never do this again.  Let's start with ES6 code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       const onChangeHandler = event =&gt; onChange &amp;&amp; onChange(event.target.value); export const OnChange = ({ onChange, children }) =&gt; { //   ,    //      children const Child = React.Children.only(children); //        props return React.cloneElement(Child, {onChange: onChangeHandler}); }</span></span></code> </pre> <br>  If we neglect the test for the uniqueness of the child and the transfer of the <code>onChange</code> property, then this example can be written even shorter: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       const onChangeHandler = event =&gt; onChange(event.target.value); export const OnChange = ({ onChange, children }) =&gt; React.cloneElement(children, {...children.props, onChange: onChangeHandler});</span></span></code> </pre><br>  Note that the callback for the transfer to the internal component is set outside the wrapper function, this will allow not re-creating the function during each component render cycle.  But we are talking about TypeScript, so add some types and get the following component: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface Props { <span class="hljs-attr"><span class="hljs-attr">onChange</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value: string</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; children: JSX.Element; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OnChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange, children }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChangeHandler = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> ( onChange(event.target.value) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Child = React.Children.only(children); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.cloneElement(Child, {...children.props, <span class="hljs-attr"><span class="hljs-attr">onChange</span></span>: onChangeHandler}); }</code> </pre><br>  We added a description of Props for the component and typed onChange: in it we indicated that we expect the event argument to be input, which coincides by signature with the event object passed from HTMLInput.  In this case, we specified in the external properties that in onChange, the first argument instead of the event object is a string.  On this bad example is over, it's time to move on. <br><br><h2>  Hoc </h2><br>  Now let's look at a good example of writing HoC: a function that returns a new component, wrapping the original one.  Thus, the connect function from the react-redux package works.  What is needed for this?  In simple terms, we need a function that returns an anonymous class, which is a HoC for the component.  A key problem with TypeScript is the need to use generics for strong typing of HoCs.  But more about that later, let's start with an example on ES6 +. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withOnChange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Child</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChange</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ onChangeHandler = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onChange(event.target.value); render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...this.props</span></span></span></span><span class="xml"><span class="hljs-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onChangeHandler}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; } } }</span></span></code> </pre><br>  The first argument passed to us is the declaration of the component class, which is used to create the component instance.  In the render method in the instance of the wrapped component, we pass the modified callback onChange and all other properties unchanged.  As in the first example, we brought the onChangeHandler function initialization outside the render method and passed the reference to the function instance to the internal component.  In any more or less complex React project, the use of HoCs provides better code portability, since common handlers are put into separate files and connected as needed. <br><br>  It is worth noting that in this example, the anonymous class can be replaced with the stateless function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChangeHandler = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">onChange</span></span></span><span class="hljs-function"> =&gt;</span></span> event =&gt; onChange(event.target.value); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withOnChange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Child</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ onChange, ...props }) =&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="hljs-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onChangeHandler(onChange)}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span></code> </pre><br>  Here we have created a function with a component-class argument that returns a stateless function that accepts the props of this component.  A function was created in the onChange handler that creates a new onChangeHandler when passing an event handler from the internal component. <br><br>  Now back to TypeScript.  By performing such actions, we will not be able to take full advantage of strong typing, since by default the passed-in component and the return value will take the type any.  When the strict mode is enabled, TS will display an error about the implicit type any in the function argument.  Well, let's proceed to typing.  First of all, let's declare the onChange properties in the received and sent components: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     export interface OnChangeHoFProps { onChange?: (value: string) =&gt; void; } //  ,    export interface OnChangeNative { onChange?: React.ChangeEventHandler&lt;HTMLInputElement&gt;; }</span></span></code> </pre><br>  Now we have clearly indicated which Props the wrapped component should have and which Props are the result of the composition.  Now we will declare the component itself: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withOnChangeString</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnChangeNative</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Child: React.ComponentType&lt;T&gt;</span></span></span><span class="hljs-function">) </span></span>{ . . . }</code> </pre><br>  Here we have indicated that the argument is a component that has the onChange property of a certain signature in the properties, i.e.  having native onChange.  For the HoC to work, it is necessary to return a React component from it, which already has the same external properties as the component itself, but with a modified onChange.  This is done by the expression <code>OnChangeHoCProps &amp; T</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withOnChangeString</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnChangeNative</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Child: React.ComponentType&lt;T&gt;</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChangeHoCProps</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span></span>{}&gt; { . . . } }</code> </pre><br>  Now we have a typed HoC that takes a callback onChange, which expects to receive a string as a parameter, returns the wrapped component and sets onChange to an internal component that gives the Event as an argument. <br><br>  When debugging code in React DevTools, we may not see the names of the components.  The displayName static property is responsible for displaying component names: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> displayName = <span class="hljs-string"><span class="hljs-string">`withOnChangeString(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Child.displayName || Child.name}</span></span></span><span class="hljs-string">)`</span></span>;</code> </pre><br>  We are trying to get a similar property from the internal component and wrap it with the name of our HoC in the form of a string.  If there is no such property, then you can use the ES2015 specification, to which all the functions have the name property added, indicating the name of the function itself.  However, TypeScript, when compiled in ES5, will generate an error stating that the function does not have this property.  To solve this problem, you need to add the following line to tsconfig.json: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [<span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.core"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>],</code> </pre><br>  In this line, we told the compiler that we can use the basic set of the ES2015, ES5 specification and API for working with the DOM in the code.  The full code of our HoC'a: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withOnChangeString</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnChangeNative</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Child: React.ComponentType&lt;T&gt;</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChangeHoFProps</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span></span>{}&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> displayName = <span class="hljs-string"><span class="hljs-string">`withOnChangeString(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Child.displayName || Child.name}</span></span></span><span class="hljs-string">)`</span></span>; onChangeHandler = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onChange(event.target.value); render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...this.props</span></span></span></span><span class="xml"><span class="hljs-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onChangeHandler}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; } } }</span></span></code> </pre><br>  Now our HoC is ready for battle, use the following test to check its operation: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Props   HTMLInputElement type InputProps = React.DetailedHTMLProps&lt;React.InputHTMLAttributes&lt;HTMLInputElement&gt;, HTMLInputElement&gt;; //   ,  HTMLInputElement const SimpleInput: React.StatelessComponent&lt;InputProps&gt; = ({...props}: InputProps) =&gt; &lt;input className="input" {...props} /&gt;; //    HoC' const SimplerInput = withOnChangeString&lt;InputProps&gt;(SimpleInput); describe('HoC', () =&gt; { it('simulates input events', () =&gt; { const onChange = jasmine.createSpy('onChange'); const wrapper = mount(&lt;SimplerInput onChange={onChange} /&gt;); wrapper.find(SimplerInput).simulate('change', { target: {value: 'hi'} }); expect(onChange).toHaveBeenCalledWith('hi'); }); });</span></span></code> </pre><br><h2>  Finally </h2><br>  Today we reviewed the basic techniques for writing HoCs on React.  However, in real life it happens that not one, not two, but a whole chain of HoCs is used.  In order not to turn the code into noodles, there is a <code>compose</code> function, but we'll talk about it next time. <br><br>  That's all, the source code of the project is available on <a href="https://github.com/Luanre/hoc-article">GitHub</a> .  Subscribe to our blog and stay tuned! </div><p>Source: <a href="https://habr.com/ru/post/354104/">https://habr.com/ru/post/354104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354086/index.html">Hall Effect Sensors for a Brushless Motor: Returning Quadrature Encoders</a></li>
<li><a href="../354090/index.html">Overview of the new line of home antivirus Panda Dome</a></li>
<li><a href="../354092/index.html">Another article about the recognition of workers without helmets neural networks</a></li>
<li><a href="../354096/index.html">How to prove the importance of tests for each project participant</a></li>
<li><a href="../354098/index.html">How data sharing affects the quality of recommendations</a></li>
<li><a href="../354106/index.html">How to get rid of the difficulty in managing a state in React - report on the results of a trip to React Amsterdam</a></li>
<li><a href="../354108/index.html">How to create a neural network with just 30 lines of JavaScript code</a></li>
<li><a href="../354110/index.html">Urgent Relocation from Amazon Web Services - Two Customer Stories</a></li>
<li><a href="../354112/index.html">Own Goal We are testing DDoS protection.</a></li>
<li><a href="../354114/index.html">Java 10 migration notes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>