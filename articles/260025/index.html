<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fun starts or C ++ and STL: who is faster?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Formulation of the problem 
 We are interested in the speed of various standard C ++ tools for performing similar operations on a large number of elem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fun starts or C ++ and STL: who is faster?</h1><div class="post__text post__text-html js-mediator-article"><h4>  Formulation of the problem </h4><br>  We are interested in the speed of various standard C ++ tools for performing similar operations on a large number of elements (loops, STL algorithms, iterators, pointers, etc.).  For simplicity, we will consider the original problem of calculating the sum of a large number of integers.  ( <a href="http://www.youtube.com/watch%3Fv%3D0RVN7FGoxnQ%26index%3D3%26list%3DPLYdecRA4eeHbAOcSvC7JFn-Os7Vm3Efer">Link</a> for those who do not like to read, and loves to watch.) <br><a name="habracut"></a><br><h4>  Prepare </h4><br>  First, we write the code that will evaluate the speed of the cycle: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sys/time.h&gt; #include &lt;iomanip&gt; using namespace std; const int COUNT = 1000 * 1000 * 1000; int main () { struct timespec tm1, tm2; clock_gettime(CLOCK_REALTIME, &amp;tm1); // Our code to estimate clock_gettime(CLOCK_REALTIME, &amp;tm2); double t1 = 1000.0 * tm1.tv_sec + tm1.tv_nsec / (1000.0 * 1000); double t2 = 1000.0 * tm2.tv_sec + tm2.tv_nsec / (1000.0 * 1000); cout &lt;&lt; "t=" &lt;&lt; setprecision(5) &lt;&lt; t2 -t1 &lt;&lt; " ms" &lt;&lt; endl; return 0; };</span></span></span></span></code> </pre> <br>  Not very accurate, but simple and straightforward. <br><br>  With sequential enumeration of elements in STL, the fastest container is a vector, since its elements are arranged sequentially.  So create a vector of size COUNT and fill it with (almost) random integer values: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;algorithm&gt; ‚Ä¶ int RandomNumber () { static int s = 0; return (s++ % 100); } int main () { vector&lt;int&gt; vec(COUNT); generate(vec.begin(), vec.end(), RandomNumber); ... // Our code to estimate</span></span></span></span></code> </pre><br><h4>  Accumulate </h4><br>  <b>The most kosher way to</b> solve our problem is to use the <b>accumulate</b> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;numeric&gt; ‚Ä¶ // Our code to estimate accumulate(vec.begin(), vec.end(), 0, [](int sum, int i) { return sum + i; });</span></span></span></span></code> </pre><br>  Compile and run: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 349.29 mseconds</code> </pre><br>  Not a little ... <br><h4>  for_each </h4><br>  Let's try for_each? <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Our code to estimate int sum = 0; for_each(vec.begin(), vec.end(), [&amp;sum](int i) { sum += i; });</span></span></code> </pre><br>  We look: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 417.64 mseconds</code> </pre><br>  Interestingly, if you use an object with a state, it will turn out a little faster: <b>passing by reference to the lambda bit slows us down</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sum() : sum(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ sum += i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } }; ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// Our code to estimate for_each(vec.begin(), vec.end(), Sum());</span></span></code> </pre><br>  Drumroll‚Ä¶ <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 371.64 mseconds</code> </pre><br>  You can also make a lambda with a state and get a <b>result comparable to accumulate</b> , but the game is not worth the trouble: the result still does not suit us. <br><br><h4>  for </h4><br>  Let's return to the good old cycles: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Our code to estimate int sum = 0; for(auto i = vec.begin(); i != vec.end(); i++) { sum += *i; };</span></span></code> </pre><br>  So what? <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 520.66 mseconds</code> </pre><br>  Well, it is clear why, change a little code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> end = vec.end(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = vec.begin(); i != end; i++) {</code> </pre><br>  Compile and run again: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 403.68 mseconds</code> </pre><br>  Already better!  We also know that the <b>prefix increment is slightly faster than postfix</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = vec.begin(); i != end; ++i) {</code> </pre><br>  This is because a temporary object + copy is used in the postfix-increment operation. <br><br>  Compile and run: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 327.05 mseconds</code> </pre><br>  The best result for today!  But it's not over yet ... <br>  Why was the <b>cycle a little faster</b> ?  Basically, because there is no function call, and there are no unnecessary copies of an object (in our case, an integer) amount. <br><br><h4>  iterator or not </h4><br>  We will refuse iterators in general: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; COUNT; ++i) { sum += vec[i]; };</code> </pre><br>  Compile and run: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 110.52 mseconds</code> </pre><br>  This is the result. <br><br>  Here we won at once on two operations - the <b>increment of the inta is faster</b> than the increment operator of the iterator, and <b>the dereferencing operator is slower</b> than access by index. <br><br><h4>  Arrays </h4><br>  What happens if we use a regular array?  More precisely, we will take elements by the offset of the pointer, and not by the index (replacing a vector with an array is meaningless - the vector stores its data in an array): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = &amp;vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; COUNT; ++i) { sum += <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]; };</code> </pre><br>  And it was worth it: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 81.219 mseconds</code> </pre><br>  <b>Access by signpost is much faster!</b> <br>  And if you iterate directly on the index, without indices, it will be released much faster: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> end = &amp;vec[vec.size () - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = &amp;vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]; i != end; ++i) { sum += *i; };</code> </pre><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 24.494 mseconds</code> </pre><br><br><h4>  Hardcore </h4><br>  What else can we do with the loop?  Accurately - "register": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = &amp;vec[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != COUNT; ++i) { sum += <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]; };</code> </pre><br>  And what do we get? <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 10.456 mseconds</code> </pre><br>  The result is good, but it should be remembered that the <b>abuse of the register modifier negates it</b> : the compiler stops paying attention to it when there are not enough registers, but there are always not enough) So the above result is more of academic interest than practical. <br><br>  You can experiment with algorithms, for example, this change: <br><br><pre> <code class="cpp hljs">sum += <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] + <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[++i];</code> </pre><br>  Speed ‚Äã‚Äãup our code in two more: <br><br><pre> <code class="bash hljs">$ g++ -std=c++11 main.cpp -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> &amp;&amp; ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ duration 4.8562 mseconds</code> </pre><br>  <b>UPDATE</b> : and lead to undefined behavior!  Thank you alexac for the comment. <br>  The compiler optimization also went beyond the scope of the article, we do not use them.  But this is the topic of a <a href="http://habrahabr.ru/post/260193/">separate article</a> ... <br><br><h4>  Conclusion </h4><br>  The speed of our cycle <b>has increased by an order</b> !  At the same time, we did not even think about multithreaded algorithms (and algorithms in general).  We also did not use anything other than native C ++: we acted strictly according to the standard and did not use any third-party libraries. <br><br><img src="https://lh5.googleusercontent.com/QqoPCQSjJ-Lsa7tH9oz1LTuGasPR1f_BI3SwZAdWOZtkTiuwaa19Fk-4EEh5Zzml7Gm0a2oFCovhCThCEnOojMoWWR6f0bwnqmuluFMlA9EH7P4z3erQi_mwbGtJKgLvmnY7r1s" alt="image"><br><br>  So, if the speed of our cycle is important to us - <b>the STL algorithms are not suitable</b> .  Iterators are flexible, but not too fast - the fastest access is through normal pointers. </div><p>Source: <a href="https://habr.com/ru/post/260025/">https://habr.com/ru/post/260025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260013/index.html">Unit tests, BDD and the power of fluid statements (fluent assertions) in 1C</a></li>
<li><a href="../260017/index.html">Automated xkcd-style diagram creation: from serious to funny</a></li>
<li><a href="../260019/index.html">Mobile App Distribution Services for iOS. Part 4 (final): Fabric (Crashlytics)</a></li>
<li><a href="../260021/index.html">How to check your sites for getting into the Blacklist or why the newsletter gets into spam</a></li>
<li><a href="../260023/index.html">Application Migration - Code Examples</a></li>
<li><a href="../260027/index.html">Passing Stored Arguments to a Function</a></li>
<li><a href="../260029/index.html">Detector of UI locks in WPF with notification</a></li>
<li><a href="../260031/index.html">Windows and Mac OS Integration with Acronis Access Connect</a></li>
<li><a href="../260033/index.html">Is it true that Go is faster than Ruby?</a></li>
<li><a href="../260045/index.html">Material Design and Search by the example of a reference application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>