<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust: & and ref in patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="( continued ) 

 As you, I think, know, Rast is one of the languages ‚Äã‚Äãthat implement pattern matching (pattern matching). If you are unfamiliar with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust: & and ref in patterns</h1><div class="post__text post__text-html js-mediator-article">  ( <a href="https://habrahabr.ru/post/306702/">continued</a> ) <br><img src="https://habrastorage.org/files/afc/ae4/dad/afcae4dad2184b1da76e3b23cf53a9bb.png" align="right"><br>  As you, I think, know, Rast is one of the languages ‚Äã‚Äãthat implement pattern matching (pattern matching).  If you are unfamiliar with this term, you can think of it as a generalized <b>switch</b> expression in which we compare objects not only by value, but also by <i>structure</i> : <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> hashmap.get(&amp;key) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(value) =&gt; do_something_with(value), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Oh noes!"</span></span>); }, }</code> </pre> <br>  Of course the comparison is not limited to the case.  As you can see in the example above, the objects can also be <i>destructured</i> during matching ( <b>Some (value)</b> ) and their parts are assigned to other variables ( <b>value</b> ), which can be further used in the corresponding branch of the expression. <br><br>  Elegant, isn't it?  In Rast√©, pattern matching is bread and butter not only for <b>match</b> , but also for <b>for</b> , ( <b>if</b> ) <b>let</b> and even for ordinary function arguments. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, for a long time I had a rather vague idea of ‚Äã‚Äãwhat was happening in the case when we added links and borrowing to the mapping.  <b>&amp;</b> and <b>ref</b> are two ‚Äúoperators‚Äù often used for this.  This article will be devoted to the difference between them. <br><a name="habracut"></a><br>  Probably you are already quite familiar with the first "operator" used to create links and types with links.  <b>ref</b> also very transparently hints at a link to links.  However, these two expressions play <i>very</i> different roles when used internally. <br><br>  In order to add confusion, they are often used together: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> hyper::Url; <span class="hljs-comment"><span class="hljs-comment">//     URL  let url = Url::parse(some_url).unwrap(); let query_params: Vec&lt;(String, String)&gt; = url.query_pairs().unwrap_or(vec![]); for &amp;(ref name, ref value) in &amp;query_params { println!("{}={}", name, value); }</span></span></code> </pre><br>  At best, the absence of one of them will be noted by the compiler along with the sentence where to add one or another expression, which of course does not always happen.  Therefore, it is highly desirable to understand what is actually happening here. <br><br><h1>  Link part and match part </h1><br>  Rast is very flexible in terms of what values ‚Äã‚Äãcan be part of the comparison.  You will have to make an effort to find something that cannot be part of the <b>match</b> expression.  Both objects and links to them can be used without problems in it: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... let foo = &amp;Foo(42); match foo { x =&gt; println!("Matched!"), }</span></span></code> </pre><br>  However, in the previous example we are usually not interested in the link itself, but then where it <i>points</i> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> foo { &amp;Foo(num) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Matched with number {}"</span></span>, num), }</code> </pre><br>  As you can see, ampersand is used for this purpose.  As well as types ( <b>Some</b> , <b>Ok</b> or the above-indicated <b>Foo</b> ), <b>&amp;</b> indicates what value we expect when matching.  Seeing the ampersand, the program knows that we want to match <i>references</i> to certain objects, not the objects themselves. <br><br>  But why is this distinction between an object and a link to it so important?  In other places, Rast is quite flexible in blurring the border between the links and the objects themselves, for example, in the case of invoking object methods.  (the mechanism for this is called " <a href="http://rurust.github.io/rust_book_ru/src/deref-coercions.html">conversion by dereference</a> " or in English " <b>Deref</b> coercion") <br><br>  However, pattern matching, due to the possibility of unpacking values ‚Äã‚Äãinto their component parts, is a <i>destructive</i> operation.  Everything to which we apply <b>match</b> (or another similar expression) will by default be <i>moved</i> to this block: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybe_name = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"Alice"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ... match maybe_name { Some(n) =&gt; println!("Hello, {}", n), _ =&gt; {}, } do_something_with(maybe_name)</span></span></code> </pre><br>  In full accordance with the semantics of <a href="http://rurust.github.io/rust_book_ru/src/ownership.html">ownership</a> , the <b>match</b> expression will prevent subsequent attempts to move and in essence absorb the object.  Thus, the code above will give the following error message: <br><br><pre> <code class="rust hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of partially moved value: `maybe_name` [E0382] do_something_with(maybe_name); ^~~~~~~~~~</code> </pre><br>  So, like <b>Some, an</b> ampersand is essentially just a <i>part of the pattern</i> with which we are matching.  And just like with <b>Some</b> and other types, we have an obvious symmetry: if we used <b>&amp;</b> to create value, we would need to use an ampersand and to unpack it. <br><br><blockquote>  The syntax used in the patterns for unpacking an object is similar to that used to create it. </blockquote><br><br><h1>  Prevent moving </h1><br>  Errors similar to the above, often contain useful notes: <br><br><pre> <code class="rust hljs">note: `(maybe_name:core::option::<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>::<span class="hljs-literal"><span class="hljs-literal">Some</span></span>).<span class="hljs-number"><span class="hljs-number">0</span></span>` moved here because it has <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collections</span></span></span></span>::string::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>`, which is moved by <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {}"</span></span>, n), ^</code> </pre><br>  And ways to potentially correct the error: <br><br><pre> <code class="rust hljs">help: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you would like to borrow the value instead, <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> a `<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>` binding <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> shown: <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> n) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {}"</span></span>, n),</code> </pre><br>  It is here that goes on the scene <b>ref</b> . <br><br>  The message tells us that if we add the <b>ref</b> keyword to the proposed location, we will change the move to <i>borrow</i> for the variable used in this match.  (in our case it is <b>n</b> ) As before, this variable will capture the required value, but this time without <i>owning</i> it. <br><br>  And this distinction is extremely important. <br><br>  Unlike ampersand, <b>ref</b> does not mean something with which we produce a comparison.  It does not in any way affect whether the value will be matched to this pattern or not. <br><br>  The only thing that it changes is how parts of the associated value will be <i>captured by the</i> pattern variables: <br><br><ul><li>  By default, without <b>ref,</b> they are <i>moved</i> to the <b>match</b> branch </li><li>  If there is a <b>ref</b> , they are <i>borrowed</i> and presented as links. </li></ul><br>  In our example, the variable <b>n</b> in the pattern <b>Some (n)</b> is of type <b>String</b> , i.e.  the same type as in the associated structure.  In contrast, the other <b>n</b> in the <b>Some</b> pattern <b>(ref n)</b> is of type <b>&amp; String</b> , i.e.  reference to the field of the object. <br><br>  The first is moving, the second is borrowing. <br><br><blockquote>  The <b>ref</b> keyword means that a variable inside a matching pattern should borrow a value, not move it.  This is <b>not</b> part of the pattern in terms of the mapping itself. </blockquote><br><h1>  We use them together </h1><br>  Let's now analyze what exactly happens in that confusing example from the beginning of the article: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &amp;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &amp;query_params { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}={}"</span></span>, name, value); }</code> </pre><br>  Since  we know that <b>ref</b> does not in any way affect whether a pattern is matched or not, we could just insert something like <b>&amp; (a, b)</b> , this option is much more readable: it is clear that we expect a link to an object that is a two-element tuple .  Of course, it is just such tuples that are members of the vector by which the iteration occurs. <br><br>  The problem is that without <b>refs</b> we are trying to <i>move the</i> values ‚Äã‚Äãof the tuple into the loop, but since  we iterate over <b>&amp; query_params</b> , we just borrow each of the tuples, so such a move is actually impossible.  In essence, this would be a classic attempt to move a value out of the borrowing context. <br><br>  But we do not need this movement.  The only thing that our cycle does is that it prints the values, so access to them via links will be more than enough. <br><br>  And this is exactly what the <b>ref</b> gives us.  Having returned this keyword, we will move from moving to borrowing. <br><br><h1>  Summing up </h1><br><ul><li>  <b>&amp;</b> indicates that the pattern <b>expects</b> an object <b>reference</b> .  Thus <b>&amp;</b> is part of the pattern.  From here <b>&amp; Foo</b> will be matched differently than <b>Foo.</b> </li><li>  <b>ref</b> notes that you want to get a <b>link to the unpacked value</b> .  It does not directly participate in pattern matching.  Therefore, <b>Foo (ref foo)</b> will be mapped to the same object as <b>Foo (foo)</b> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/306582/">https://habr.com/ru/post/306582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306568/index.html">Learning machines - fun stuff: modern face recognition with deep learning</a></li>
<li><a href="../306570/index.html">Low cost VDS hosting in Russia and its technical support</a></li>
<li><a href="../306572/index.html">iOS 10: Notification Content Extension</a></li>
<li><a href="../306574/index.html">Study: What will happen if you tell users how you target advertising?</a></li>
<li><a href="../306580/index.html">Docker Volume plugin for Nutanix on AOS 4.7</a></li>
<li><a href="../306584/index.html">Node.js and JavaScript instead of the old web</a></li>
<li><a href="../306586/index.html">Rating of countries in which it is more favorable to deploy a server farm</a></li>
<li><a href="../306588/index.html">Our development centers around the country with "teleports" to any city</a></li>
<li><a href="../306590/index.html">Fast TCP Sockets on Erlang</a></li>
<li><a href="../306592/index.html">How to sell: how the seller should work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>