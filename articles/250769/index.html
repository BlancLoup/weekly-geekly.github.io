<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A short course in computer graphics, addendum: ambient occlusion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The official translation (with a bit of polishing) is available here. 

 In a brief course on computer graphics that I submitted to your review a coup...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A short course in computer graphics, addendum: ambient occlusion</h1><div class="post__text post__text-html js-mediator-article"><hr><h3>  The official translation (with a bit of polishing) is available <a href="https://github.com/ssloy/tinyrenderer/wiki">here.</a> </h3><hr><br><br>  In a brief course on computer graphics that I submitted to your review a couple of weeks ago, we used local lighting techniques.  What does it mean?  This means that we chose the intensity of illumination of each point independently of its neighbors. <br><br>  Phong's lighting model is a classic example of local choice: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/comment_images/e37/20a/5df/e3720a5dfedc49edb0bf70f8bc64204a.png"><br><br>  The final intensity consists of three components: ambient lighting, constant value for all points of the scene.  Diffuse lighting and glare depend on the normal vector to a given point and the direction of light, but do not depend on the geometry of the rest of the scene.  Let's think, why, in fact, was the ambient lighting chosen constant for the whole scene? <br><a name="habracut"></a><br><h1>  The second approach to global illumination: ambient occlusion </h1><br>  Well, actually, I was a little wrong when I said that in that course we had local lighting.  In the sixth part, we considered the construction of the shadow cast by our object.  And this is one of the techniques of global illumination.  In this article, I propose to consider a few simple approaches to the calculation of ambient light.  Here is an example of a model in which I used <b>only the</b> ambient component of the Phong model's lighting, no diffuse light, no glare. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45d/82a/d9f/45d82ad9f666f7068488dc3f1e5c9da1.png"><br><br>  So, the task is set as follows: calculate the value of ambient lighting for each point of the visible part of our scene. <br><br>  When Phong said that the environment around is so velvety and fluffy that reflects equally light in all directions, it was a somewhat powerful simplification.  Of course, this was done in favor of local lighting methods, which are much faster than global ones.  Recall that to build the shadow, we had to render in two passes.  However, with modern iron, we can afford to be able to give a little more attention in order to get a more believable picture.  In real life, if you see the entrance to the tunnel, then quite clearly it will be less illuminated by sunlight than the surrounding mountain. <br><br>  Enough plausible images are obtained if we assume that our object is surrounded by a uniformly luminous hemisphere (for example, an overcast sky).  But this does not mean that the tunnel also glows inside, which means that we will have to do additional work, calculating how each point of the object is visible from our luminous hemisphere. <br><br><h2>  We go to the forehead </h2><br>  Accompanying source code to take <a href="https://github.com/ssloy/tinyrenderer/tree/631386c5ab1987d4cfa097e8f89894cadd593c2d">here</a> . <br><br>  The easiest way is to randomly select, say, a thousand different points on a hemisphere around an object, render the scene a thousand times with a camera set at these points, and calculate which parts of the model we saw.  It is appropriate to ask a couple of questions. <br><br>  Question 1: Do you know how to choose with a uniform distribution a thousand points on a sphere without accumulation around the poles? <br><br>  Something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/48b/9ff/483/48b9ff4834579809cc61362360995b98.png"></div></div><br>  After all, if we simply randomly (uniformly) choose latitude and longitude, then at the pole we will have a wonderful clot, which means that our assumption that the light reflected by the world of light is not true.  Examples of ready-made calculations can be found <a href="http://mathworld.wolfram.com/SpherePointPicking.html">here</a> . <br><br>  Question 2: where to store information about which piece of the luminous hemisphere is visible from this point of the object?  As we walk in the forehead, the answer is almost obvious: in the texture of the object! <br><br>  So, we write two shaders and render two times for each point.  Here is the first (fragmentary) shader and the result of its work: <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vec3f gl_FragCoord, Vec3f bar, TGAColor &amp;color</span></span></span><span class="hljs-function">)</span></span> { color = TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)*((gl_FragCoord.z+<span class="hljs-number"><span class="hljs-number">1.f</span></span>)/<span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/d63/934/124/d6393412463267f66a15c48e2816b5cc.png"></div></div><br>  The picture itself doesn‚Äôt particularly interest us, we are interested in the z-buffer as a result of the operation of this shader. <br><br>  Then we make the second pass with this fragmentary shader: <br><br><pre> <code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec3f gl_FragCoord, Vec3f bar, TGAColor &amp;color)</span></span></span><span class="hljs-function"> </span></span>{ Vec2f uv = varying_uv*bar; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(shadowbuffer[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(gl_FragCoord.x+gl_FragCoord.y*width)]-gl_FragCoord.z)&lt;<span class="hljs-number"><span class="hljs-number">1e-2</span></span>) { occl.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(uv.x*<span class="hljs-number"><span class="hljs-number">1024</span></span>, uv.y*<span class="hljs-number"><span class="hljs-number">1024</span></span>, TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>)); } color = TGAColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  It is absolutely not important for us that it will display a red picture.  This line is interesting here: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">occl</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.set</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">uv</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>*1024, <span class="hljs-selector-tag"><span class="hljs-selector-tag">uv</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span>*1024, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TGAColor</span></span>(255));</code> </pre><br>  occl is a 1024x1024 image that was initially filled with black.  And this line says that if we see this fragment, then we will mark it in the occl texture map.  This is what the occl picture looks like after the rendering is finished: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://hsto.org/files/05c/950/df6/05c950df6f1b4bac904bc309068ba260.png"></div></div><br><br>  An exercise in understanding what is happening: why do we have clearly visible triangles with holes?  More precisely, why are only isolated points of no hidden triangles marked? <br><br>  Exercise 2: why do some triangles have a dotting density greater than others? <br><br>  In general, we repeat the procedure a thousand times, count the average of the thousands of resulting occl pictures, and get the following texture: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://hsto.org/files/5ef/745/4c7/5ef7454c7294416fa7fa3b80c3663a71.png"></div></div><br><br>  ABOUT!  This already looks like something worthwhile, let's render the model using only the color of this texture, without additional illumination miscalculations. <br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vec3f gl_FragCoord, Vec3f bar, TGAColor &amp;color</span></span></span><span class="hljs-function">)</span></span> { Vec2f uv = varying_uv*bar; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = aoimage.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(uv.x*<span class="hljs-number"><span class="hljs-number">1024</span></span>, uv.y*<span class="hljs-number"><span class="hljs-number">1024</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; color = TGAColor(t, t, t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><br>  aoimage here is the texture that was just counted.  Here is the result of this shader: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://hsto.org/files/603/1c8/b2c/6031c8b2ccd84e2d8e15584a3b91c8a2.png"></div></div><br>  Exercise 3: oh, why is he darker than a cloud? <br><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text">  This is half the answer to Exercise 2. Did you notice that there is only one hand in the texture of Diablo?  An economical artist, he said that his hands are the same, placing a grid of textural coordinates of two hands on the same place of texture.  And this means (roughly) that the zone where the hand is drawn will be highlighted twice as strong as the zone where the face is drawn, since  it is only one. </div></div><br><br><h3>  Summarize </h3><br>  This method allows (pre-) to calculate the ambient occlusion texture for scenes where the geometry is static.  The time of the calculation depends on the number of points you choose, but usually time is of little interest to us, because  it is almost a scene creation, and not the process of the game itself, such a texture is counted once, and then simply used.  The advantage is that using such a texture is cheap; it can be calculated with more complex lighting conditions than just a uniformly glowing hemisphere.  The disadvantage is that if we have overlays in the texture space, then there will be a gentle bummer. <br><br><h1>  Where, where to put the tape to make it work? </h1><br>  Since the textural space for diablo is not suitable, you can use a regular framebuffer.  Render will turn out in several passes: we simply render the z-buffer from the usual camera position, then we illuminate the model from (we put) thousands of different light sources, counting the shadow mapping a thousand times, and calculate the average for each pixel.  Everything would be fine, we got rid of the problem of imposing information on ourselves, but we got a wild amount of render time.  If in the previous approach we calculated the texture once for the entire lifetime of the model, now it depends on the position of the camera in space ... <br><br><h1>  Screen space ambient occlusion </h1><br>  So, we conclude that global illumination is an expensive thing, we need a lot of expensive calculations about the visibility of the surface from different places.  Let's try to find a compromise between speed and quality of the result.  Here is a picture at once which we will consider: <br><br><img src="http://hsto.org/files/1ba/93f/a5a/1ba93fa5a48646e2a9614271c943b4da.png"><br><br>  We draw a picture in one pass, here is the used shader: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZShader</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IShader { mat&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; varying_tri; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Vec4f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iface, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nthvert)</span></span></span><span class="hljs-function"> </span></span>{ Vec4f gl_Vertex = Projection*ModelView*embed&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;(model-&gt;vert(iface, nthvert)); varying_tri.set_col(nthvert, gl_Vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gl_Vertex; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec3f gl_FragCoord, Vec3f bar, TGAColor &amp;color)</span></span></span><span class="hljs-function"> </span></span>{ color = TGAColor(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } };</code> </pre><br><br>  Eeee ... color = TGAColor (0, 0, 0);  ?!  That's right, we now consider only ambient lighting, and the only thing really interesting to us from this shader is the depth buffer, nothing that the framebuffer will remain completely black after the shader ends, the model will manifest as a result of the post-processing scene. <br><br>  Here is the used drawing code with our empty shader and post-processing of the image: <br><br><pre> <code class="hljs matlab"> ZShader zshader; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;model-&gt;nfaces(); <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) { zshader.vertex(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>); } triangle(zshader.varying_tri, zshader, frame, zbuffer); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int x=<span class="hljs-number"><span class="hljs-number">0</span></span>; x&lt;width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int y=<span class="hljs-number"><span class="hljs-number">0</span></span>; y&lt;height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zbuffer[x+y*width] &lt; <span class="hljs-number"><span class="hljs-number">-1e5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; float total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (float a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;M_PI*<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1e-4</span></span>; a += M_PI/<span class="hljs-number"><span class="hljs-number">4</span></span>) { total += M_PI/<span class="hljs-number"><span class="hljs-number">2</span></span> - max_elevation_angle(zbuffer, Vec2f(x, y), Vec2f(<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(a), <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a))); } total /= (M_PI/<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-number"><span class="hljs-number">8</span></span>; total = pow(total, <span class="hljs-number"><span class="hljs-number">100.</span></span>f); frame.set(x, y, TGAColor(total*<span class="hljs-number"><span class="hljs-number">255</span></span>, total*<span class="hljs-number"><span class="hljs-number">255</span></span>, total*<span class="hljs-number"><span class="hljs-number">255</span></span>)); } }</code> </pre><br>  Drawing with an empty shader gives us a filled depth buffer.  Postprocessing is as follows: for each pixel on the screen, we emit a certain number (here, eight) of rays in different directions.  The depth buffer for us can be represented as a hilly terrain.  What interests us is how much we will rise if we go in the direction of each ray.  The max_elevation_angle function and gives the maximum lift that we will encounter on the path of the current beam. <br><br>  If all eight rays have an elevation angle of zero, then this means that the given point (x, y) is clearly visible from everywhere.  If the angle is about 90 ¬∞, then the point is very weakly visible from the surrounding celestial sphere, and, as a result, should be poorly lit. <br><br>  In an amicable way, it would be necessary to calculate the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BB%25D0%25B5%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB">solid angle of the</a> resulting figure, but for our purposes it would be enough to take (90 ¬∞ the angle of elevation) and divide by 8 to get an approximation of the solid angle.  Raising the resulting solid angle to the power of one hundred simply raises the contrast of the picture. <br><br>  This is what happens on the head of an old Negro: <br><br><img src="http://hsto.org/files/ea0/db4/51f/ea0db451f6934992a7a4a04f6dbe0bd8.png"><br><br>  As usual, the code is available <a href="https://github.com/ssloy/tinyrenderer/tree/d7c806bc3d598fc54dd446b6c81b94f723728205">here</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="http://hsto.org/files/fec/eed/3f2/feceed3f2a964e2fb79926a167f15500.png"></div></div><br><h2>  Communication outside Habr </h2><br>  If you have questions and do not want to ask them in the comments, or simply do not have the opportunity to write in the comments, join the xmpp jabber conference: 3d@conference.sudouser.ru </div><p>Source: <a href="https://habr.com/ru/post/250769/">https://habr.com/ru/post/250769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250759/index.html">Interesting moments of work Linq to Sql</a></li>
<li><a href="../250761/index.html">Brakes ng-repeat? No - just ngAnimate + transition to css</a></li>
<li><a href="../250763/index.html">Analysis of the problem ‚ÄúMirror in the corridor‚Äù and outrage</a></li>
<li><a href="../250765/index.html">Navigation Drawer in Material Design style in 5 minutes</a></li>
<li><a href="../250767/index.html">TLS1.1 + support for legacy CommuniGate versions</a></li>
<li><a href="../250771/index.html">Improving JavaScript code using the StarWars API</a></li>
<li><a href="../250773/index.html">ASP.NET Day: Ballmer Peak, Pluralsight and the future of ASP.NET</a></li>
<li><a href="../250775/index.html">Mom said: do not trust the firmware of hard drives</a></li>
<li><a href="../250779/index.html">Radio Magazine Electronic Magazine - Issue 34. Arduino Guide</a></li>
<li><a href="../250781/index.html">CLR and .Net Framework Anatomy Workshop. Roslyn, CoreCLR, CoreFx, Nitra, RyuJIT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>