<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithms for fast calculation of factorial</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The concept of factorial is known to all. This is a function that calculates the product of consecutive positive integers from 1 to N inclusive: N! = ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithms for fast calculation of factorial</h1><div class="post__text post__text-html js-mediator-article">  The concept of factorial is known to all.  This is a function that calculates the product of consecutive positive integers from 1 to N inclusive: N!  = 1 * 2 * 3 * ... * N. Factorial is a fast-growing function, already for small values ‚Äã‚Äãof N the value of N!  has a lot of meaningful numbers. <br><br>  Let's try to implement this function in a programming language.  Obviously, we need a language that supports long arithmetic.  I will use C #, but you might as well take Java or Python. <br><br>  <b>Naive algorithm</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the simplest implementation (let's call it naive) is obtained directly from the definition of factorial: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactNaive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { BigInteger r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= n; ++i) r *= i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  On my machine, this implementation runs for about 1.6 seconds for N = 50,000. <br><br>  Next, we consider algorithms that work much faster than a naive implementation. <br><a name="habracut"></a><br>  <b>Tree calculation algorithm</b> <br><br>  The first algorithm is based on the consideration that long numbers of approximately the same length are more efficient to multiply than a long number to multiply by a short one (as in the naive implementation).  That is, we need to ensure that, when calculating factorial, the factors are always approximately the same length. <br><br>  Suppose we need to find the product of consecutive numbers from L to R, denote it as P (L, R).  Divide the interval from L to R in half and count P (L, R) as P (L, M) * P (M + 1, R), where M is midway between L and R, M = (L + R) / 2 Note that the multipliers will be about the same length.  Similarly, we divide P (L, M) and P (M + 1, R).  We will perform this operation until no more than two factors remain in each interval.  It is obvious that P (L, R) = L, if L and R are equal, and P (L, R) = L * R, if L and R differ by one.  To find N!  you need to calculate P (2, N). <br><br>  Let's see how our algorithm will work for N = 10, find P (2, 10): <br><br>  P (2, 10) <br>  P (2, 6) * P (7, 10) <br>  (P (2, 4) * P (5, 6)) * (P (7, 8) * P (9, 10)) <br>  ((P (2, 3) * P (4)) * P (5, 6)) * (P (7, 8) * P (9, 10)) <br>  (((2 * 3) * (4)) * (5 * 6)) * ((7 * 8) * (9 * 10)) <br>  ((6 * 4) * 30) * (56 * 90) <br>  (24 * 30) * (5,040) <br>  720 * 5,040 <br>  3,628,800 <br><br>  It turns out a kind of tree, where the factors are located in the nodes, and the result is obtained in the root <br><img src="http://habrastorage.org/files/292/9a7/c6f/2929a7c6f0e04cccb1e30b9417b1492b.png" alt="Factorial tree"><br><br>  We implement the described algorithm: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProdTree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &gt; r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l == r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (BigInteger)l * r; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = (l + r) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProdTree(l, m) * ProdTree(m + <span class="hljs-number"><span class="hljs-number">1</span></span>, r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactTree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span> || n == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProdTree(<span class="hljs-number"><span class="hljs-number">2</span></span>, n); }</code> </pre><br>  For N = 50,000, factorial is calculated in 0.9 seconds, which is almost twice as fast as in a naive implementation. <br><br>  <b>Algorithm for calculating factorization</b> <br><br>  The second fast calculation algorithm uses factorial factorization (factorization).  Obviously, in the decomposition of N!  only simple factors from 2 to N are involved. Let us try to calculate how many times the simple factor K is contained in N !, that is, we find out the degree of the factor K in the decomposition.  Each K-th member of the product 1 * 2 * 3 * ... * N increases the index by one, that is, the exponent will be equal to N / K. But each K <sup>2</sup> -th term increases the degree by one more, that is, the indicator becomes N / K + N / K <sup>2</sup> .  Similarly for K <sup>3</sup> , K <sup>4</sup> and so on.  As a result, we obtain that the exponent with a simple multiplier K will be N / K + N / K <sup>2</sup> + N / K <sup>3</sup> + N / K <sup>4</sup> + ... <br><br>  For clarity, we calculate how many times a deuce is in 10!  Every second gives a factor of two (2, 4, 6, 8 and 10), a total of 10/2 = 5 of such factors. Every fourth gives a four (2 <sup>2</sup> ), a total of 10/4 = 2 (4 and 8).  Every eighth gives an eight (2 <sup>3</sup> ), such a factor is only one 10/8 = 1 (8).  Sixteen (2 <sup>4</sup> ) and more are not given by any factor, which means that the calculation can be completed.  Summing up, we get that the exponent with two in the decomposition of 10!  for prime factors will be 10/2 + 10/4 + 10/8 = 5 + 2 + 1 = 8. <br><br>  If you act in the same way, you can find the indicators at 3, 5 and 7 in the decomposition of 10!, After which it remains only to calculate the value of the product: <br><br>  ten!  = 2 <sup>8</sup> * 3 <sup>4</sup> * 5 <sup>2</sup> * 7 <sup>1</sup> = 3 628 800 <br><br>  It remains to find the prime numbers from 2 to N, for this you can use the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D1%2588%25D0%25B5%25D1%2582%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2581%25D1%2584%25D0%25B5%25D0%25BD%25D0%25B0">sieve of Eratosthenes</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span> || n == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] u = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     List&lt;Tuple&lt;int, int&gt;&gt; p = new List&lt;Tuple&lt;int, int&gt;&gt;(); //      for (int i = 2; i &lt;= n; ++i) if (!u[i]) //  i -    { //      int k = n / i; int c = 0; while (k &gt; 0) { c += k; k /= i; } //       p.Add(new Tuple&lt;int, int&gt;(i, c)); //      int j = 2; while (i * j &lt;= n) { u[i * j] = true; ++j; } } //   BigInteger r = 1; for (int i = p.Count() - 1; i &gt;= 0; --i) r *= BigInteger.Pow(p[i].Item1, p[i].Item2); return r; }</span></span></code> </pre><br>  This implementation also takes about 0.9 seconds to compute 50,000! <br><br>  <b>GMP Library</b> <br><br>  As <a href="http://habrahabr.ru/users/pomme/" class="user_link">pomme</a> rightly noted, the factorial calculation speed is 98% dependent on the speed of multiplication.  Let's try to test our algorithms by implementing them in C ++ using the <a href="https://gmplib.org/">GMP</a> library.  The test results are given below, it turns out that the multiplication algorithm in C # has a rather strange asymptotics, so the optimization gives a relatively small gain in C # and a huge one in C ++ with GMP.  However, this issue is probably worth a separate article. <br><br>  <b>Performance comparison</b> <br><br>  All algorithms were tested for N equal to 1,000, 2,000, 5,000, 10,000, 20,000, 50,000, and 100,000 with ten iterations.  The table shows the average time in milliseconds. <br><img src="//habrastorage.org/files/429/ca8/3e5/429ca83e597a48a4b01145ce5f9d396f.png" alt="Result table"><br><br>  Linear graph <br><img src="//habrastorage.org/files/90b/508/b84/90b508b84fb24fd1ab962451c7ea2013.png" alt="Linear graph"><br><br>  Graph with logarithmic scale <br><img src="//habrastorage.org/files/0f6/b6a/7de/0f6b6a7de9c74902b8096c764e4f82a3.png" alt="Graph with logarithmic scale"><br><br>  <b>Ideas and algorithms from comments</b> <br><br>  Habrazhiteli offered a lot of interesting ideas and algorithms in response to my article, here I will leave links to the best of them <br><br>  <a href="http://habrahabr.ru/users/lany/" class="user_link">lany</a> <a href="http://habrahabr.ru/post/255813">parallelized the tree in Java using the Stream API and received acceleration 18 times</a> <br>  <a href="http://habrahabr.ru/users/mrrl/" class="user_link">Mrrl</a> <a href="http://habrahabr.ru/post/255761/">proposed factoring optimization by 15-20%</a> <br>  <a href="http://habrahabr.ru/users/psyhaste/" class="user_link">PsyHaSTe</a> <a href="http://habrahabr.ru/post/255761/">proposed improving naive implementation</a> <br>  <a href="http://habrahabr.ru/users/krypt/" class="user_link">Krypt</a> <a href="http://habrahabr.ru/post/255761/">offered a parallelized version on C #</a> <br>  <a href="http://habrahabr.ru/users/semenovvv/" class="user_link">SemenovVV</a> <a href="http://habrahabr.ru/post/255761/">proposed implementation on Go</a> <br>  <a href="http://habrahabr.ru/users/pomme/" class="user_link">pomme</a> <a href="http://habrahabr.ru/post/255761/">suggested using GMP</a> <br>  <a href="http://habrahabr.ru/users/shashkovs/" class="user_link">ShashkovS</a> <a href="http://habrahabr.ru/post/255761/">proposed a fast Python algorithm.</a> <br><br>  <b>Source codes</b> <br><br>  The source codes of the implemented algorithms are listed under the spoilers. <br><div class="spoiler">  <b class="spoiler_title">C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Specialized; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">BigInt</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactNaive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { BigInteger r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= n; ++i) r *= i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProdTree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &gt; r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l == r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r - l == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (BigInteger)l * r; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = (l + r) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProdTree(l, m) * ProdTree(m + <span class="hljs-number"><span class="hljs-number">1</span></span>, r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactTree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span> || n == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProdTree(<span class="hljs-number"><span class="hljs-number">2</span></span>, n); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactFactor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span> || n == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] u = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[n + <span class="hljs-number"><span class="hljs-number">1</span></span>]; List&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= n; ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!u[i]) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = n / i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { c += k; k /= i; } p.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i, c)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i * j &lt;= n) { u[i * j] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ++j; } } BigInteger r = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = p.Count() - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) r *= BigInteger.Pow(p[i].Item1, p[i].Item2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t; Console.Write(<span class="hljs-string"><span class="hljs-string">"n = "</span></span>); n = Convert.ToInt32(Console.ReadLine()); t = Environment.TickCount; BigInteger fn = FactNaive(n); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Naive time: {0} ms"</span></span>, Environment.TickCount - t); t = Environment.TickCount; BigInteger ft = FactTree(n); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Tree time: {0} ms"</span></span>, Environment.TickCount - t); t = Environment.TickCount; BigInteger ff = FactFactor(n); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Factor time: {0} ms"</span></span>, Environment.TickCount - t); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Check: {0}"</span></span>, fn == ft &amp;&amp; ft == ff ? <span class="hljs-string"><span class="hljs-string">"ok"</span></span> : <span class="hljs-string"><span class="hljs-string">"fail"</span></span>); } } }</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">C ++ with GMP</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;ctime&gt; #include &lt;vector&gt; #include &lt;utility&gt; #include &lt;gmpxx.h&gt; using namespace std; mpz_class FactNaive(int n) { mpz_class r = 1; for (int i = 2; i &lt;= n; ++i) r *= i; return r; } mpz_class ProdTree(int l, int r) { if (l &gt; r) return 1; if (l == r) return l; if (r - l == 1) return (mpz_class)r * l; int m = (l + r) / 2; return ProdTree(l, m) * ProdTree(m + 1, r); } mpz_class FactTree(int n) { if (n &lt; 0) return 0; if (n == 0) return 1; if (n == 1 || n == 2) return n; return ProdTree(2, n); } mpz_class FactFactor(int n) { if (n &lt; 0) return 0; if (n == 0) return 1; if (n == 1 || n == 2) return n; vector&lt;bool&gt; u(n + 1, false); vector&lt;pair&lt;int, int&gt; &gt; p; for (int i = 2; i &lt;= n; ++i) if (!u[i]) { int k = n / i; int c = 0; while (k &gt; 0) { c += k; k /= i; } p.push_back(make_pair(i, c)); int j = 2; while (i * j &lt;= n) { u[i * j] = true; ++j; } } mpz_class r = 1; for (int i = p.size() - 1; i &gt;= 0; --i) { mpz_class w; mpz_pow_ui(w.get_mpz_t(), mpz_class(p[i].first).get_mpz_t(), p[i].second); r *= w; } return r; } mpz_class FactNative(int n) { mpz_class r; mpz_fac_ui(r.get_mpz_t(), n); return r; } int main() { int n; unsigned int t; cout &lt;&lt; "n = "; cin &gt;&gt; n; t = clock(); mpz_class fn = FactNaive(n); cout &lt;&lt; "Naive: " &lt;&lt; (clock() - t) * 1000 / CLOCKS_PER_SEC &lt;&lt; " ms" &lt;&lt; endl; t = clock(); mpz_class ft = FactTree(n); cout &lt;&lt; "Tree: " &lt;&lt; (clock() - t) * 1000 / CLOCKS_PER_SEC &lt;&lt; " ms" &lt;&lt; endl; t = clock(); mpz_class ff = FactFactor(n); cout &lt;&lt; "Factor: " &lt;&lt; (clock() - t) * 1000 / CLOCKS_PER_SEC &lt;&lt; " ms" &lt;&lt; endl; t = clock(); mpz_class fz = FactNative(n); cout &lt;&lt; "Native: " &lt;&lt; (clock() - t) * 1000 / CLOCKS_PER_SEC &lt;&lt; " ms" &lt;&lt; endl; cout &lt;&lt; "Check: " &lt;&lt; (fn == ft &amp;&amp; ft == ff &amp;&amp; ff == fz ? "ok" : "fail") &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/255761/">https://habr.com/ru/post/255761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255747/index.html">Interview with James Bach for DUMP2015</a></li>
<li><a href="../255751/index.html">Moscow Atlassian Meetup in Moscow on April 21</a></li>
<li><a href="../255753/index.html">Creating dials for Android Wear on OpenGL ES 2.0</a></li>
<li><a href="../255757/index.html">1C: Enterprise Development Tools, or Eclipse in Russian</a></li>
<li><a href="../255759/index.html">Sugar injections in C #</a></li>
<li><a href="../255763/index.html">Coffee with cucumbers (Espresso + Cucumber)</a></li>
<li><a href="../255767/index.html">Study protection Artmoney. Part one</a></li>
<li><a href="../255769/index.html">Very subjective review of JS frameworks. AmpersandJS, part 0</a></li>
<li><a href="../255773/index.html">Java-based configuration of embedded Jetty / Spring MVC / Spring Security</a></li>
<li><a href="../255775/index.html">Algorithms of intellectual autogeneration of levels in iOS game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>