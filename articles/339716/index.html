<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java XML API: we select correctly. StAX: we work with pleasure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 Despite the decline in the popularity of the XML format since the early 2000s, it has firmly occupied its niche. I came across XML processing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java XML API: we select correctly. StAX: we work with pleasure</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/db/ec/59dbece690fcb200469874.png"></div>  Hello! <br>  Despite the decline in the popularity of the XML format since the early 2000s, it has firmly occupied its niche.  I came across XML processing in 60% of the projects and dedicated my internship to Masterjava to it.  Its most frequent applications are: XHTML, SOAP, various configurations (for example, Tomcat, SoapUI, IntelliJ IDEA, Spring XML configuration), data import and export. <br><br>  In Java, there are several APIs for working with XML and it is important for a developer to understand which API to choose in each specific situation.  In this article, I will briefly list all the Java XML API, their purpose and examples of use, and I‚Äôll dwell more on the work with a rather rare, but in some cases the only true <a href="https://en.wikipedia.org/wiki/StAX">StAX</a> technology.  It is assumed that you are already familiar <a href="http://genberm.narod.ru/xml/lections/xml/introduction.html">with the elements of XML</a> . <a name="habracut"></a><br><br><h2>  Java XML API: choosing the right </h2><br><ul><li>  <a href="https://www.ibm.com/developerworks/ru/library/x-jaxp/">JAXP (Java API for XML Processing)</a> is a set of APIs (SAX + DOM + DTD + XSLT validation).  <a href="https://ru.wikipedia.org/wiki/Xerces">Xerces</a> and <a href="https://ru.wikipedia.org/wiki/Xalan">Xalan</a> are standard implementations of these APIs.  In addition to XSLT, all APIs are outdated: StAX came to replace SAX, DOM replaced JAXB, DTD replaced XSD. </li><li>  <a href="https://ru.wikipedia.org/wiki/Document_Object_Model">DOM</a> and <a href="https://ru.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">JAXB</a> - API for reading XML <b>completely</b> and getting its application in Java ready objects.  For DOM, these are collections of <a href="https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Node.html">org.w3c.dom.Node interface</a> implementations (attributes, elements, text, ..).  For JAXB, a mapping is set, similar to how ORM defines mappings of database tables to Java objects.  Those.  XML makes ready-made and easy-to-use Java beans.  JAXB is the most convenient and frequently used API for working with XML when you need to read all the XML (it should fit in the JVM memory) and perform the required actions with it. </li><li>  <a href="https://ru.wikipedia.org/wiki/DTD">DTD</a> (deprecated) and <a href="https://ru.wikipedia.org/wiki/XML_Schema_(W3C)">XSD</a> are schemas that specify the validation of the XML structure (the order of the elements, the binding or optional element, the presence of attributes on the element).  You can bind a schema of the structure verification to XML, and then tools that work with XML (for example, IntelliJ IDEA) can do auto-completion and show schema errors.  You can also validate an XML document from within an application.  The XSD format is more modern and is itself an XML document. </li><li>  <a href="https://ru.wikipedia.org/wiki/XPath">XPath</a> query language to XML.  Roughly, you can compare it with a SQL query to a database, the code we need to get some specific element (or elements) from XML or <a href="https://stackoverflow.com/questions/7393541/count-of-element-in-xpath">count their number</a> .  I saw their use, for example, in <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BF%25D1%2580%25D0%25B8%25D1%258F%25D1%2582%25D0%25B8%25D1%258F">ESB</a> : data between systems is transmitted in XML format and in the configuration each system through XPath "bites out" from XML the data it needs.  XPath is most commonly used when transforming XML. </li><li>  <a href="https://ru.wikipedia.org/wiki/XSL">XSL, XSLT</a> - convert XML to any other format.  One of the applications, for example, is <a href="https://habrahabr.ru/post/43356/">to send a response from the server to the browser in the form of XML and set its XSL transformation to HTML</a> .  All modern browsers support XSLT transformations, i.e.  on the client side, they themselves transform XML in a given XSL to the required form. </li><li>  <a href="https://ru.wikipedia.org/wiki/SAX">SAX</a> and <a href="https://en.wikipedia.org/wiki/StAX">StAX</a> are sequential reads from an XML source. The document is read sequentially in chunks (events).  The APIs differ from each other in that SAX is based on the push model, and Stax on the pull model.  If you once made several consecutive AJAX requests on javascript, then come across a <a href="http://callbackhell.ru/">callback hell</a> .  Execution of the code is done asynchronously and the code is written not sequentially, but in steps in the return functions.  When using SAX, something like this happens: you need to set functions for processing certain events in XML (the beginning of the tag, the end of the tag, the text inside the tag, a comment), and inside these handlers, set new handlers.  Working with StAX is much more convenient.  We consistently read events from the document, analyze them and process suitable ones.  These APIs are used for very large documents, from which lists of objects are read out one by one as they appear in the document, or when we are not interested in the whole document, but its specific part and model of the entire document is not needed. </li></ul><br>  In the <a href="http://www.duct-tape-architect.ru/%3Fp%3D315">comparative API label on their capabilities,</a> <code>Easy of Use</code> for SAX / StAX says that the author does not know how to work with StAX and the rest of the article will be about how to ‚Äúprepare it correctly‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  StAX: we work with pleasure </h2><br>  First of all, I want to note that you can work with StAX through 2 APIs: a low-level <a href="https://www.ibm.com/developerworks/ru/library/x-stax1/">XMLStreamReader</a> , which returns primitives and a high-level <a href="https://www.ibm.com/developerworks/ru/library/x-stax2/">XMLEventReader</a> , which returns objects and consumes more memory.  Further I will work with XMLStreamReader.  Making a wrapper on it will make working with XML simple and convenient. Let's look at a small example: there is a simple XML with cities and users: <pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Payload</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Cities</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">City</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"spb"</span></span></span><span class="hljs-tag">&gt;</span></span>-<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">City</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">City</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"mow"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">City</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Cities</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">User</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">city</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"mow"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">email</span></span></span><span class="hljs-tag">&gt;</span></span>gmail@gmail.com<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">email</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fullName</span></span></span><span class="hljs-tag">&gt;</span></span>Gmail User<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fullName</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">User</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">User</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">city</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"spb"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">email</span></span></span><span class="hljs-tag">&gt;</span></span>admin@javaops.ru<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">email</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fullName</span></span></span><span class="hljs-tag">&gt;</span></span>Admin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fullName</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">User</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Payload</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre>  In reality, this XML may contain hundreds of cities and hundreds of thousands / millions of users.  All that is required: print a list of cities.  In this case, the StAX API is the only right choice.  Add the <code>StaxStreamProcessor</code> helper class to the <code>StaxStreamProcessor</code> : <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaxStreamProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> XMLInputFactory FACTORY = XMLInputFactory.newInstance(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> XMLStreamReader reader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StaxStreamProcessor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream is)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> XMLStreamException </span></span>{ reader = FACTORY.createXMLStreamReader(is); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> XMLStreamReader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reader; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { reader.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (XMLStreamException e) { <span class="hljs-comment"><span class="hljs-comment">// empty } } } }</span></span></code> </pre>  Next, we go through XML sequentially, read all the events that are interesting to us and output the required information: <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (StaxStreamProcessor processor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaxStreamProcessor(Files.newInputStream(Paths.get(<span class="hljs-string"><span class="hljs-string">"payload.xml"</span></span>)))) { XMLStreamReader reader = processor.getReader(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-comment"><span class="hljs-comment">// while not end of XML int event = reader.next(); // read next event if (event == XMLEvent.START_ELEMENT &amp;&amp; "City".equals(reader.getLocalName())) { System.out.println(reader.getElementText()); } } }</span></span></code> </pre>  In order not to constantly duplicate in the program the often repeated code for finding the desired event in XML, we can add it to <code>StaxStreamProcessor</code> : <pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doUntil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stopEvent, String value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> XMLStreamException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = reader.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == stopEvent &amp;&amp; value.equals(reader.getLocalName())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre>  It will not be easy, but very easy to use the utility class: <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (processor.doUntil(XMLEvent.START_ELEMENT, <span class="hljs-string"><span class="hljs-string">"City"</span></span>)){ System.out.println(reader.getElementText()); }</code> </pre>  The disadvantage of this code is that we absolutely uselessly spend resources on passing hundreds of thousands of unnecessary users to us instead of completing the program.  You need to add a condition to stop scanning XML.  This is usually the end of the tag of the parent element (in our case <code>Cities</code> ).  Add another utility method to StaxStreamProcessor that scans XML either to the end of the parent tag or to a specified element: <pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String element, String parent)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> XMLStreamException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = reader.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; event == XMLEvent.END_ELEMENT &amp;&amp; parent.equals(reader.getLocalName())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == XMLEvent.START_ELEMENT &amp;&amp; element.equals(reader.getLocalName())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre>  Add attribute and text reading methods: <pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> XMLStreamException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reader.getAttributeValue(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> XMLStreamException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reader.getElementText(); }</code> </pre>  The call code will remain super simple and we will stop processing XML immediately after the end of the <code>Cities</code> tag: <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (processor.startElement(<span class="hljs-string"><span class="hljs-string">"City"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cities"</span></span>)) { System.out.println(processor.getAttribute(<span class="hljs-string"><span class="hljs-string">"id"</span></span>) +<span class="hljs-string"><span class="hljs-string">":"</span></span> + processor.getText()); }</code> </pre>  StAX API requires accuracy when reading events.  If in the output we memorize reading the attribute and text, but the code becomes inoperative: after reading the city name from the XML, the attribute will be left behind and will be unavailable.  It should also be remembered that, depending on the current position of the XML, some API read methods from XML are available and others are not available. Using <code>startElement</code> you can get to XML elements of any nesting level and, as necessary, add other utilities to StaxStreamProcessor.  I hope that with this approach, working with StAX will seem easy and convenient. <br><br>  Thank you for your attention and pleasant coding! </div><p>Source: <a href="https://habr.com/ru/post/339716/">https://habr.com/ru/post/339716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339704/index.html">Telegram: sending messages to a mobile number to chat with a bot</a></li>
<li><a href="../339708/index.html">FrontFest.Vyorstka: let's talk about accessibility, saving traffic and future CSS</a></li>
<li><a href="../339710/index.html">Announcement: Veeam Backup & Replication 9.5 (and beyond) new features</a></li>
<li><a href="../339712/index.html">44 lesson control technicians</a></li>
<li><a href="../339714/index.html">Two pictures with the customer</a></li>
<li><a href="../339718/index.html">Optimize ES2015 Proxy in V8</a></li>
<li><a href="../339720/index.html">How to interview software engineers</a></li>
<li><a href="../339722/index.html">Battle of applications: am.ru, auto.ru, drom.ru</a></li>
<li><a href="../339724/index.html">Kubernetes success stories in production. Part 4: SoundCloud (by Prometheus)</a></li>
<li><a href="../339730/index.html">Indie's main headache: how to make sales before you go bust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>