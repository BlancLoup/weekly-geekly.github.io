<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The true power of regular expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a frequent visitor to the PHP tag on StackOverflow , I often encounter questions about how to parse some specific aspects of HTML using regular exp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The true power of regular expressions</h1><div class="post__text post__text-html js-mediator-article">  As a frequent visitor to the <a href="http://stackoverflow.com/questions/tagged/php">PHP tag on StackOverflow</a> , I often encounter questions about how to parse some specific aspects of HTML using regular expressions.  The most common answer to this is: <br><blockquote>  ‚ÄúYou cannot parse HTML using regular expressions, because HTML is not regular.  Use XML parser, and you will be happy " </blockquote><br>  This statement - in the context of the question - lies somewhere between much misleading and completely wrong.  What I want to try to demonstrate in this article is how powerful modern regular expressions <i>really are</i> . <br><a name="habracut"></a><br><h4>  What does ‚Äúregular‚Äù really mean? </h4><br>  In the context of the <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">theory of formal languages</a> , something is called ‚Äúregular‚Äù when it has a grammar in which any inference rule has one of the following forms: <br><br> <code>B -&gt; a</code> <br> <code>B -&gt; aC</code> <br> <code>B -&gt; Œµ</code> <br> <br>  Here the symbol <code>-&gt;</code> can be read as "the left side can be replaced with the right side."  Those.  The first rule will sound like this: " <code>B</code> can be replaced by <code>a</code> ", the second - " <code>B</code> can be replaced by <code>aC</code> ", and the third - " <code>B</code> can be replaced by an empty string" ( <code>Œµ</code> is the empty string character). <br><br>  But what are <code>B</code> , <code>C</code> and <code>a</code> ?  It is agreed that the letters in uppercase denote the so-called " <i>non-terminals</i> " ( <i>non-terminals</i> ) - symbols that <i>can be</i> disassembled into components - and the letters in lowercase denote "terminals" ( <i>terminals</i> ) - symbols that <i>can not be</i> broken further. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All of this may sound somewhat abstract, so let's look at an example: the definition of natural numbers as a grammar. <br><br> <code>N -&gt; 0</code> <br> <code>N -&gt; 1</code> <br> <code>N -&gt; 2</code> <br> <code>N -&gt; 3</code> <br> <code>N -&gt; 4</code> <br> <code>N -&gt; 5</code> <br> <code>N -&gt; 6</code> <br> <code>N -&gt; 7</code> <br> <code>N -&gt; 8</code> <br> <code>N -&gt; 9</code> <br> <code>N -&gt; 0N</code> <br> <code>N -&gt; 1N</code> <br> <code>N -&gt; 2N</code> <br> <code>N -&gt; 3N</code> <br> <code>N -&gt; 4N</code> <br> <code>N -&gt; 5N</code> <br> <code>N -&gt; 6N</code> <br> <code>N -&gt; 7N</code> <br> <code>N -&gt; 8N</code> <br> <code>N -&gt; 9N</code> <br> <br>  This grammar says that: <br><br> <code>  (N) - </code> <br> <code>...     0  9</code> <br> <code></code> <br> <code>...     0  9,       (N)</code> <br> <br>  In this example, the numbers from 0 to 9 will be terminals (since they cannot be broken into components), and N will be the only non-terminal (since it can be divided further). <br><br>  If you look at the rules again and compare them with the definition of regular grammatical forms above, you will see that they meet the specified criteria: the first ten rules are of the form <code>B -&gt; a</code> , and the second ten are of the form of <code>B -&gt; aC</code> .  Consequently, the grammar for natural numbers is <i>regular</i> . <br><br>  Another point you could notice is that, despite the grammar description of such simple things, it is already quite bloated.  Wouldn't it be better if we could express the same concept, but in a more concise form? <br><br>  And here regular expressions come on the scene: the grammar above is equivalent to the regexp <code>[0-9]+</code> (which is damn simpler).  And this type of conversion can be applied to <i>any</i> regular grammar: each of them has a corresponding regular expression that describes all the valid lines for it. <br><br><h4>  What regular expressions can describe </h4><br>  So, a natural question arises: can regular expressions only describe regular grammars, or are they capable of more?  The answer to it will be yes <i>and</i> no. <br><br>  Regular expressions in the sense of formal grammars can (by definition) describe only regular grammars and nothing more. <br><br>  But when programmers talk about ‚Äúregular expressions,‚Äù they don't mean formal grammars.  They talk about <i>derived</i> regular expressions implemented in their programming languages.  And these implementations of regexp are very superficially connected with the initial concept of regularity. <br><br>  Any modern type of regexp can describe <i>much more</i> than just regular languages.  Clarifying how much more is the subject of further narration. <br><br>  To preserve simplicity, I will focus only on the PCRE implementation of regexps.  Just because I know it best (because it is used in PHP).  Many other implementations are very similar to it, so most of the following can be applied to them too. <br><br><h4>  Language hierarchy </h4><br>  To analyze what is possible and what cannot be described using regular expressions, we first consider what types of languages ‚Äã‚Äãstill exist.  A good starting point for this is <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B5%25D1%2580%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25BE%25D0%25BC%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">Chomsky's hierarchy</a> : <br><br><img src="https://habrastorage.org/storage2/f18/75d/546/f1875d546c3e1ca108720e5b9275b59e.jpg"><br><br>  As you can see, it divides formal languages ‚Äã‚Äãinto four types: regular languages ‚Äã‚Äã(type 3) - the least powerful, followed by context-free languages ‚Äã‚Äã(type 2), context-dependent languages ‚Äã‚Äã(type 1) and, finally, omnipotent unlimited languages ‚Äã‚Äã(type 0). <br><br>  Chomsky's hierarchy is container, so the small boxes in the picture are completely enclosed in large boxes.  Those.  any regular language is also context-free (but not vice versa!). <br><br>  So let's go up a step up the hierarchy.  We already know that a regular expression can describe any regular language.  Is it possible for context-free languages? <br><br>  (Reminder: when I say ‚Äúregular expressions‚Äù, I mean them in the programmer sense, not in the sense of the theory of formal languages). <br><br><h4>  Context-free language description </h4><br>  The answer to the question above: yes, it is possible! <br><br>  Consider the classic example of a context-free grammar <code>{a^nb^n, n&gt;0}</code> , which means "The number of characters <code>a</code> followed by the same number of characters <code>b</code> ".  (PCRE) regexp for this language will be: <br><br> <code>/^(a(?1)?b)$/</code> <br> <br>  This regular expression is very simple: <code>(?1)</code> refers to the first mask - <code>(a(?1)?b)</code> .  Therefore, in principle, you can replace <code>(?1)</code> submasks, thus forming a recursive relationship: <br><br> <code>/^(a(?1)?b)$/</code> <br> <code>/^(a(a(?1)?b)?b)$/</code> <br> <code>/^(a(a(a(?1)?b)?b)?b)$/</code> <br> <code>/^(a(a(a(a(?1)?b)?b)?b)?b)$/</code> <br> <code># and so on</code> <br> <br>  From the above considerations, it should be clear that this expression is capable of describing any string with the same number of <code>a</code> and <code>b</code> . <br><br>  Therefore, regular expressions are able to describe at least some irregular, context-free grammars.  But can they describe them all?  To answer this question, let us first look at the definition of context-free grammars. <br><br>  In a context-free grammar, all inference rules are: <br><br> <code>A -&gt; Œ≤</code> <br> <br>  Here, <code>A</code> is again a non-terminal symbol, and <code>Œ≤</code> is an arbitrary string of terminals and non-terminals.  Thus, each rule of a context-free grammar has a nonterminal on the left and a string of arbitrary characters on the right. <br><br>  As an example, consider the following grammar: <br><br><pre> <code class="php hljs">function_declaration -&gt; T_FUNCTION is_ref T_STRING <span class="hljs-string"><span class="hljs-string">'('</span></span> parameter_list <span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-string"><span class="hljs-string">'{'</span></span> inner_statement_list <span class="hljs-string"><span class="hljs-string">'}'</span></span> is_ref -&gt; <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> is_ref -&gt; Œµ parameter_list -&gt; non_empty_parameter_list parameter_list -&gt; Œµ non_empty_parameter_list -&gt; parameter non_empty_parameter_list -&gt; non_empty_parameter_list <span class="hljs-string"><span class="hljs-string">','</span></span> parameter <span class="hljs-comment"><span class="hljs-comment">// ... ... ...</span></span></code> </pre><br><br>  This is an excerpt from a PHP grammar (just a few simple rules).  The syntax is slightly different from what we used before, but it can be easily understood.  One aspect worth noting is that the T_SOMETHING names here are also terminal symbols.  Such characters are usually called <i>tokens</i> , they encode a more abstract concepts.  For example, T_FUNCTION is the function keyword, and T_STRING is the token tag (like getUserById or some_other_name). <br><br>  I use this example to demonstrate one thing: context-free grammars are already powerful enough to encode fairly complex languages.  That is why almost all programming languages ‚Äã‚Äãhave context-free grammars.  This list also includes syntactically correct HTML. <br><br>  Coming back to the actual question: can regular expressions link all context-free grammars?  Again the answer: yes! <br><br>  This is extremely easy to prove, since regular expressions (at least PCRE and others like it) provide a grammar syntax for building grammars that is very similar to the above: <br><br><pre> <code class="php hljs">/ (?(DEFINE) (?&lt;addr_spec&gt; (?&amp;local_part) @ (?&amp;domain) ) (?&lt;local_part&gt; (?&amp;dot_atom) | (?<span class="hljs-string"><span class="hljs-string">"ed_string) | (?&amp;obs_local_part) ) (?&lt;domain&gt; (?&amp;dot_atom) | (?&amp;domain_literal) | (?&amp;obs_domain) ) (?&lt;domain_literal&gt; (?&amp;CFWS)? \[ (?: (?&amp;FWS)? (?&amp;dtext) )* (?&amp;FWS)? \] (?&amp;CFWS)? ) (?&lt;dtext&gt; [\x21-\x5a] | [\x5e-\x7e] | (?&amp;obs_dtext) ) (?&lt;quoted_pair&gt; \\ (?: (?&amp;VCHAR) | (?&amp;WSP) ) | (?&amp;obs_qp) ) (?&lt;dot_atom&gt; (?&amp;CFWS)? (?&amp;dot_atom_text) (?&amp;CFWS)? ) (?&lt;dot_atom_text&gt; (?&amp;atext) (?: \. (?&amp;atext) )* ) (?&lt;atext&gt; [a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+ ) (?&lt;atom&gt; (?&amp;CFWS)? (?&amp;atext) (?&amp;CFWS)? ) (?&lt;word&gt; (?&amp;atom) | (?"</span></span>ed_string) ) (?&lt;quoted_string&gt; (?&amp;CFWS)? <span class="hljs-string"><span class="hljs-string">" (?: (?&amp;FWS)? (?&amp;qcontent) )* (?&amp;FWS)? "</span></span> (?&amp;CFWS)? ) (?&lt;qcontent&gt; (?&amp;qtext) | (?<span class="hljs-string"><span class="hljs-string">"ed_pair) ) (?&lt;qtext&gt; \x21 | [\x23-\x5b] | [\x5d-\x7e] | (?&amp;obs_qtext) ) # comments and whitespace (?&lt;FWS&gt; (?: (?&amp;WSP)* \r\n )? (?&amp;WSP)+ | (?&amp;obs_FWS) ) (?&lt;CFWS&gt; (?: (?&amp;FWS)? (?&amp;comment) )+ (?&amp;FWS)? | (?&amp;FWS) ) (?&lt;comment&gt; \( (?: (?&amp;FWS)? (?&amp;ccontent) )* (?&amp;FWS)? \) ) (?&lt;ccontent&gt; (?&amp;ctext) | (?"</span></span>ed_pair) | (?&amp;comment) ) (?&lt;ctext&gt; [\x21-\x27] | [\x2a-\x5b] | [\x5d-\x7e] | (?&amp;obs_ctext) ) <span class="hljs-comment"><span class="hljs-comment"># obsolete tokens (?&lt;obs_domain&gt; (?&amp;atom) (?: \. (?&amp;atom) )* ) (?&lt;obs_local_part&gt; (?&amp;word) (?: \. (?&amp;word) )* ) (?&lt;obs_dtext&gt; (?&amp;obs_NO_WS_CTL) | (?"ed_pair) ) (?&lt;obs_qp&gt; \\ (?: \x00 | (?&amp;obs_NO_WS_CTL) | \n | \r ) ) (?&lt;obs_FWS&gt; (?&amp;WSP)+ (?: \r\n (?&amp;WSP)+ )* ) (?&lt;obs_ctext&gt; (?&amp;obs_NO_WS_CTL) ) (?&lt;obs_qtext&gt; (?&amp;obs_NO_WS_CTL) ) (?&lt;obs_NO_WS_CTL&gt; [\x01-\x08] | \x0b | \x0c | [\x0e-\x1f] | \x7f ) # character class definitions (?&lt;VCHAR&gt; [\x21-\x7E] ) (?&lt;WSP&gt; [ \t] ) ) ^(?&amp;addr_spec)$ /x</span></span></code> </pre><br><br>  What you see above is a regular expression for describing an e-mail address using <a href="http://tools.ietf.org/html/rfc5322">RFC 5322</a> .  It is built using a simple BNF rule mapping from RFC to notation, which PCRE understands. <br><br>  The syntax is extremely simple: all definitions of rules are wrapped in a DEFINE statement, which basically means that all these rules do not have to directly correspond to something, they simply need to be declared.  Only a part of <code>^(?&amp;addr_spec)$</code> at the very end determines what is described here at the end. <br><br>  The definitions of the rules, in general, are not real "rules", but rather subtleties.  In the first example <code>(a(?1)?b)</code> <code>1</code> referred to the first mask.  With a lot of submasks, this kind of naming is impractical, so they are given clear names.  So <code>(?&lt;xyz&gt; ...)</code> defines a template named <code>xyz</code> .  <code>(?&amp;xyz)</code> - link to it. <br><br>  Also note the following fact: the regular expression above uses an <code>x</code> modifier.  He instructs the engine to ignore spaces and stick to <code>#</code> -style comments.  This way you can better format your regexp so that other people can understand it properly.  (Unlike <a href="http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html">this</a> regexpa RFC 822 for an e-mail address ...) <br><br>  Thus, the above syntax allows you to simply map the grammar to a regular expression: <br><br> <code>A -&gt; BC</code> <br> <code>A -&gt; CD</code> <br> <code>// becomes</code> <br> <code>(?&lt;A&gt; (?&amp;B) (?&amp;C)</code> <br> <code>| (?&amp;C) (?&amp;D)</code> <br> <code>)</code> <br> <br>  The only catch is that regular expressions do not support left-sided recursion.  That is, if you take the above definition of the parameter list: <br><br><pre> <code class="php hljs">non_empty_parameter_list -&gt; parameter non_empty_parameter_list -&gt; non_empty_parameter_list <span class="hljs-string"><span class="hljs-string">','</span></span> parameter</code> </pre><br><br>  You <i>cannot</i> convert it to grammar-based regexp exactly.  The following will not work: <br><br> <code>(?&lt;non_empty_parameter_list&gt;</code> <br> <code>(?¬∂meter)</code> <br> <code>| (?&amp;non_empty_parameter_list) , (?¬∂meter)</code> <br> <code>)</code> <br> <br>  The reason for this is that the <code>non_empty_parameter_list</code> appears in the far left side of its own definition.  This is called left-sided recursion and is very often found in grammar definitions.  The reason is that LALR (1) parsers, which are most often used for parsing, usually handle left-sided recursion better than right-sided. <br><br>  But do not worry, this does not in any way affect the power of regular expressions.  Each left-recursive grammar can be converted to right-recursive.  In the example above, simply swap the two parts: <br><br><pre> <code class="php hljs">non_empty_parameter_list -&gt; parameter non_empty_parameter_list -&gt; parameter <span class="hljs-string"><span class="hljs-string">','</span></span> non_empty_parameter_list</code> </pre><br><br>  Now it should be absolutely clear that regular expressions are capable of describing any context-free language (and, therefore, almost all languages ‚Äã‚Äãencountered by programmers).  The only problem is that although regular expressions can <i>describe</i> context-free grammars, they usually cannot <i>parse</i> them.  Parsing involves converting a string to an abstract syntax tree.  For this, it is impossible to use regular expressions, at least PCRE (although, of course, in Perl, where you can insert arbitrary code into a regular expression, you can do almost everything ...). <br><br>  However, the above <code>DEFINE</code> forexp was <i>very</i> useful for me.  In the end, you usually do not need full support for parsing, you just want to describe something (for example, an e-mail address) or extract small pieces of data (rather than build a whole parse tree).  Most of the complex processing tasks can be made much easier using regexp-based grammars :) <br><br>  And now let me again focus on what I mentioned earlier in passing: syntactically correct HTML is context-free.  Therefore, you <i>can</i> describe it using regular expressions, as opposed to popular opinion.  Just do not forget about two things: first, most of the HTML you encounter is <i>not</i> syntactically correct (usually, it is not even closed).  And secondly, just because you <i>can</i> , does not mean that you <i>should</i> .  You can write your software on Brainfuck, but there are reasons why you don‚Äôt, right? <br><br>  My opinion on the subject is this: wherever you need general HTML processing, use the DOM library to your taste.  It will correctly process incorrect HTML and take upon itself the brunt of the parsing.  On the other hand, if you are dealing with specific cases, then fast regular expressions are often the best solution.  And I have to admit: although I usually tell people not to parse HTML using regular expressions, I myself, as we know, do this often.  Just because I often come across specific situations when using regexps is elementary easier. <br><br><h4>  Context-sensitive grammar </h4><br>  Now that we have examined context-free languages ‚Äã‚Äãin detail, let's go up one more step in the Chomsky hierarchy: to context-dependent languages. <br><br>  For them, the structural rules will have the following form: <br><br> <code>Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤</code> <br> <br>  This mixture of characters initially looks quite complicated, but in fact everything is simple.  The core is still the <code>A ‚Üí Œ≥</code> pattern, which we defined for context-free grammars.  To it, <code>Œ±</code> and <code>Œ≤</code> were simply added in both directions.  These two form the context (which also gave the name to this class of grammar).  So, <code>A</code> can now be replaced by <code>Œ≥</code> only if it has <code>Œ±</code> on the left and <code>Œ≤</code> on the right. <br><br>  To make the above more understandable, we try to interpret the following rules: <br><br> <code>ab A -&gt; abc</code> <br> <code>a B c -&gt; a QH c</code> <br> <code>HB -&gt; HC</code> <br> <br>  In Russian it will sound like this: <br><br> <code> `A`  `c`,     ,     `ab` .</code> <br> <code> `B`  `QH`,     ,     `a`   `c` .</code> <br> <code> `B`  `C`,       `H` .</code> <br> <br>  Context-sensitive languages ‚Äã‚Äãare something you rarely see in ‚Äúnormal‚Äù programming.  They are more important in the field of natural language processing (since natural languages ‚Äã‚Äãare definitely not context-free. Words have different meanings depending on the context).  But even people engaged in the processing of natural languages ‚Äã‚Äãwork with so-called ‚Äúsoft context-dependent languages‚Äù, since they are sufficient for modeling, and analysis is much faster. <br><br>  To understand how powerful context-sensitive grammars are, let's look at another class of grammars with exactly the same expressive power as context-dependent grammars: non-shortening grammars. <br><br>  For non-shortening grammars, each inference rule has the form <code>Œ± -&gt;Œ≤</code> , where <code>Œ±</code> and <code>Œ≤</code> are arbitrary strings of characters with a single restriction: the number of characters on the right must be no less than the number of characters on the left.  Formally, this is expressed by the formula <code>|Œ±| &lt;= |Œ≤|</code> <code>|Œ±| &lt;= |Œ≤|</code>  where <code>|x|</code>  denotes the length of a string of characters. <br><br>  So, non-shortening grammars allow any rules until they start shortening the input string.  Those.  <code>ABC -&gt; HQ</code> will be an invalid rule, since its left part contains three characters, and the right - only two.  Therefore, this rule will be shortening.  On the other hand, the opposite rule <code>HQ -&gt; ABC</code> appropriate because it has more characters to the right than to the left, which lengthens the string. <br><br>  These relationships (equivalent for context-sensitive and non-extending grammars) make it absolutely clear that with the help of context-dependent grammars you can do almost everything.  Just do not shorten :) <br><br>  To get a notion of why both grammars have the same expressive power, look at the following example of transformations: <br><br> <code>//  </code> <br> <code>AB -&gt; CD</code> <br> <code>//      - </code> <br> <code>AB -&gt; AX</code> <br> <code>AX -&gt; YX</code> <br> <code>YX -&gt; YD</code> <br> <code>YD -&gt; CD</code> <br> <br>  Okay, back to regular expressions.  Can they also describe context-sensitive languages? <br><br>  This time I can‚Äôt give you a definite answer.  Of course, they can describe <i>some</i> context-sensitive languages, but I have no idea if they can describe them <i>all</i> . <br><br>  As an example of a context-sensitive language, which can be easily described using regexps, let us take the context-free language modification <code>{a^nb^n, n&gt;0}</code> , which we discussed above.  When you change it to <code>{a^nb^nc^n, n&gt;0}</code> , i.e.  If some quantity <code>a</code> precedes the same quantity <code>b</code> and <code>c</code> , then it becomes context-sensitive. <br><br>  PCRE-regexp for this language is as follows: <br><br><pre> <code class="php hljs">/^ (?=(a(?<span class="hljs-number"><span class="hljs-number">-1</span></span>)?b)c) a+(b(?<span class="hljs-number"><span class="hljs-number">-1</span></span>)?c) $/x</code> </pre><br><br>  If we ignore the statement <code>(?=...)</code> , then we will only have <code>a+(b(?-1)?c)</code> left on our left.  It checks that an arbitrary number <code>a</code> followed by the same number <code>b</code> and <code>c</code> .  <code>(?-1)</code> - relative reference to a mask, meaning "the last defined mask."  In this case, it is <code>(b(?-1)?c)</code> . <br><br>  A new entity for us is <code>(?=...)</code> .  It is called the ‚Äúconditional expression of zero width‚Äù and checks that the text following it is described by a mask, but the check itself is carried out by its subexpression.  Thus, there is a check for compliance with both templates simultaneously.  Part <code>a+(b(?-1)?)</code> <code>c</code> <code>a+(b(?-1)?)</code> checks that the number of <code>b</code> and <code>c</code> same, and <code>(a(?-1)?b)c</code> - that the number of <code>a</code> and <code>b</code> same.  Both masks together provide confirmation that all three characters are contained in the same quantity. <br><br>  In the above regexp, you can also see how the concept of context is implemented in regular expressions using assertions.  If we now return to the definition of a context-dependent grammar, then you can say that the output rule of the form <br><br> <code>Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤</code> <br> <br>  can be converted to the following DEFINE regexp rule: <br><br> <code>(?&lt;A&gt; (?&lt;= Œ± ) Œ≥ (?= Œ≤ ) )</code> <br> <br>  This is the same as saying that <code>A</code> is <code>Œ≥</code> , but only if it has <code>Œ±</code> left and <code>Œ≤</code> right of itself. <br><br>  Looking at the above, you might think that you can now easily convert context-sensitive grammar into a regular expression, but in fact it is not.  The reason is that the retrospective statement <code>((?&lt;= ... ))</code> has one significant limitation: it must be of a fixed length.  This means that the length of the text described by the statement must be known in advance.  Those.  you can write <code>(?&lt;= a(bc|cd) )</code> , but you cannot write <code>(?&lt;= ab+)</code> .  In the first case, the statement binds exactly three characters in all cases and, therefore, has a fixed length.  In the second case, the statement may link <code>ab</code> , <code>abb</code> , <code>abbbb</code> , etc.  They all have different lengths, and the engine does not know when it should begin to match them.  So they are simply banned. <br><br>  This is a serious blow to the ease of converting context-dependent grammars into regexps.  Virtually all such grammars require variable widths for retrospective statements. <br><br>  But the fact that it is impossible to directly convert a context-dependent grammar to regexp does not in itself mean that regular expressions can not describe them all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the above language </font></font><code>{a^nb^nc^n, n&gt;0}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also has a grammar that requires retrospective statement of variable width. </font><font style="vertical-align: inherit;">Perhaps something similar is possible for other context-sensitive grammars. </font><font style="vertical-align: inherit;">I honestly do not know. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So what can we say in the end? </font><font style="vertical-align: inherit;">Regexps can describe at least </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context-dependent languages, but it is not known whether they are able to describe them </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unlimited Grammar </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next class of grammars in the Chomsky hierarchy is unlimited grammars. The set of languages ‚Äã‚Äãthat can be formed with their help includes all recursively-enumerable languages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little can be said about unlimited grammars, since they, uh, unlimited. Their inference rules have the form </font></font><code>Œ± -&gt; Œ≤</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, where </font></font><code>Œ±</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Œ≤</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are character strings with no restrictions at all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, unlimited grammars simply remove the ‚Äúnon-shortening‚Äù part of the non-shortening grammars. Therefore, it </font></font><code>ABC -&gt; HQ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be a valid rule </font><font style="vertical-align: inherit;">for them </font><font style="vertical-align: inherit;">, although it was not previously a rule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How strong are unlimited grammars exactly? So much so that they cannot be stronger: they are Turing-full. There is even a "programming language" based on unlimited grammars: </font></font><a href="http://en.wikipedia.org/wiki/Thue_%2528programming_language%2529"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since it is Turing-complete, it can do everything that other programming languages ‚Äã‚Äãare capable of. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the consequences of Turing completeness is that the problem of checking for belonging to a certain string to a certain grammar is generally undecidable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, I can't tell you anything else about how regular expressions and unlimited grammars are related. </font><font style="vertical-align: inherit;">Damn, I could not even find an example of an adequate unlimited grammar (which would not be non-shortening). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But now, since we are talking about Turing completeness, let's move on to the next point:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regular expressions with backlinks are NP-complete </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is another very powerful regular expression property that I didn‚Äôt mention earlier: backlinks. </font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containing such a very simple regexp: </font></font><br><br> <code>/^(.+)\1$/</code> <br> <br> <code>(.+)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>\1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describe the same arbitrary text. </font><font style="vertical-align: inherit;">In general, </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means "something there, described by the n-th submask."</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if it </font></font><code>(.+)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describes </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then it </font></font><code>\1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will also describe </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nothing more. </font><font style="vertical-align: inherit;">Therefore, the expression </font></font><code>(.+)\1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means "some text, followed by a copy of it". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What this regexp describes is called ‚Äúcopy language‚Äù and is another typical example of context-dependent languages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the same way, you can describe other examples of grammars listed above using backlinks:</font></font><br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment"># {a^nb^n, n&gt;0} (context-free) /^ (?: a (?= a* (\1?+ b) ) )+ \1 $/x # {a^nb^nc^n, n&gt;0} (context-sensitive) /^ (?: a (?= a* (\1?+ b) b* (\2?+ c) ) )+ \1 \2 $/x</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explaining how this works is beyond the scope of this article, but you can read about this wonderful </font></font><a href="http://stackoverflow.com/a/3644267/385378"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topic on StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, simply adding a backlink (without the support of recursive submasks) already increases the power of regular expressions. It is in principle so powerful that it makes the description of regular expressions NP-complete task. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does NP-full mean? NP-completeness is one of the classes in the theory of computational complexity for solving problems, into which many "hard" problems fall. Examples of NP-complete tasks are </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BC%25D0%25B8%25D0%25B2%25D0%25BE%25D1%258F%25D0%25B6%25D0%25B5%25D1%2580%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the traveling salesman problem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (TSP), the </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25B2%25D1%258B%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_%25D0%25B1%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D1%258B%25D1%2585_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolean formula satisfiability problem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SAT), and </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586%25D0%25B5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the knapsack problem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BKP).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important condition for calling a task NP-complete is the ability to reduce to it any other NP-task. Thus, all NP-complete tasks are basically interchangeable. If you find a quick solution to one of them, then you will have a quick solution for them all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So if someone finds a quick solution for the NP-complete problem, then almost all the complex computational problems of mankind will be solved in one fell swoop. That, as we know, will mean the end of civilization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To prove that regular expressions with backlinks are exactly NP-complete, you can simply take one of the well-known NP-complete problems and prove that it can be solved using regular expressions. As an example, I chose the 3-CNF SAT task.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The 3-CNF SAT stands for ‚ÄúThe task of satisfying Boolean formulas in 3-conjunctive normal form‚Äù and is simple enough to understand. There is a Boolean formula of the following form: </font></font><br><br> <code>(!$a || $b || $d)</code> <br> <code>&amp;&amp; ( $a || !$c || $d)</code> <br> <code>&amp;&amp; ( $a || !$b || !$d)</code> <br> <code>&amp;&amp; ( $b || !$c || !$d)</code> <br> <code>&amp;&amp; (!$a || $c || !$d)</code> <br> <code>&amp;&amp; ( $a || $b || $c)</code> <br> <code>&amp;&amp; (!$a || !$b || !$c)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It consists of a series of conditions separated by the operators I. Each of these conditions consists of three variables (or their negations) separated by the operators OR. 3-CNF SAT asks: Is there a solution to this boolean formula (for example, true)? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above boolean formula can be converted to the following regular expression:</font></font><br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $regex = <span class="hljs-string"><span class="hljs-string">'/^ (x?)(x?)(x?)(x?) .* ; (?: x\1 | \2 | \4 ), (?: \1 | x\3 | \4 ), (?: \1 | x\2 | x\4 ), (?: \2 | x\3 | x\4 ), (?: x\1 | \3 | x\4 ), (?: \1 | \2 | \3 ), (?: x\1 | x\2 | x\3 ), $/x'</span></span>; $string = <span class="hljs-string"><span class="hljs-string">'xxxx;x,x,x,x,x,x,x,'</span></span>; var_dump(preg_match($regex, $string, $matches)); var_dump($matches);</code> </pre><br><br>     ,     <code>$matches</code> : <br><br> <code>array(5) {</code> <br> <code>[0]=&gt; string(19) "xxxx;x,x,x,x,x,x,x,"</code> <br> <code>[1]=&gt; string(1) "x"</code> <br> <code>[2]=&gt; string(1) "x"</code> <br> <code>[3]=&gt; string(0) ""</code> <br> <code>[4]=&gt; string(0) ""</code> <br> <code>}</code> <br> <br>  ,     ,  <code>$a = true</code> , <code>$b = true</code> , <code>$c = false</code>  <code>$d = false</code> . <br><br>      :       <code>x</code> ,    .       -  <code>(?: \1 | x\3 | \4 )</code>  ,        <code>\1</code> ‚Äî  <code>x</code> (),  <code>\3</code> ‚Äî   (),  <code>\4</code> ‚Äî  <code>x</code> (). <br><br>    .          ,      ,    . <br><br><h4>  Summarizing </h4><br>     ,      : <br><ul><li>  ,  ,             . </li><li>   (  PCRE)    - .       HTML,       . </li><li>        - . </li><li>    NP .        NP ,   . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But do not forget: from what you </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it does not follow that you </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">HTML processing with regular expressions is a really bad idea in some cases. </font><font style="vertical-align: inherit;">And in others, it is perhaps the best thing to do. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just think for what the simplest solution is for your specific task, and use it. </font><font style="vertical-align: inherit;">If you choose to solve a problem using regular expressions, do not forget about the x-modifier, which allows you to make the format of your regexps more beautiful. </font><font style="vertical-align: inherit;">For complex regular expressions, just remember to use DEFINE statements and named submasks to keep your code clean and readable.</font></font><br><br>  That's all. <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the translator: possible comments on the translation, please write in a personal. </font><font style="vertical-align: inherit;">I will be very grateful for them.</font></font></i> </div><p>Source: <a href="https://habr.com/ru/post/171667/">https://habr.com/ru/post/171667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171653/index.html">We are looking for beta testers mobile application Payoneer</a></li>
<li><a href="../171655/index.html">CRM for work with clients and information partners to replace the current AMO CRM</a></li>
<li><a href="../171657/index.html">Startup team Yandex.Money: Twym service - money transfers between Twitter users</a></li>
<li><a href="../171663/index.html">Open lecture by Don Field, director of Microsoft Learning: certification opportunities for career growth</a></li>
<li><a href="../171665/index.html">Cyto: our trial and error method</a></li>
<li><a href="../171669/index.html">Blue Raspberry Cake Free</a></li>
<li><a href="../171671/index.html">Testing cars with paintball, drones and Lunapark, ugh, big hangar</a></li>
<li><a href="../171673/index.html">Poll. Are you ready to change the programming language and platform at the suggestion of the customer?</a></li>
<li><a href="../171675/index.html">The iceberg underwater part: reconciliation of business goals and consumer desires</a></li>
<li><a href="../171681/index.html">Automatically saving Cisco device configurations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>