<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compare Java 8, RxJava, Reactor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: 
 I have prepared an adapted translation for you with some additions and corrections. I have kept a few propaganda style of the o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compare Java 8, RxJava, Reactor</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <em>From the translator:</em> <em><br></em>  <em>I have prepared an adapted translation for you with some additions and corrections.</em>  <em>I have kept a few propaganda style of the original article, but, in itself, the information in it is interesting, so I decided, nevertheless, to translate.</em> </blockquote><p>  People often ask me: <br>  Why would I need to use RxJava or Reactor at all if the same can be done with Streams, CompletableFutures and Optionals? </p><br><p><img src="https://habrastorage.org/files/737/a5e/39a/737a5e39a3ab481dbdf4715788c9aeb8.jpg" alt="image"></p><br><p>  The problem, in fact, is that most of the time you are engaged in solving simple problems and you really do not need these libraries.  But when things get complicated, you have to write some ugly piece of code.  Then this piece of code becomes more and more complex and difficult to maintain.  RxJava and Reactor have many convenient features that will satisfy your needs for many years to come. </p><br><p>  Let's define 8 criteria that will help us understand the difference between these libraries and standard Java features: </p><a name="habracut"></a><br><ol><li>  Composable </li><li>  Lazy (Delayed / Lazy) </li><li>  Reusable </li><li>  Asynchronous </li><li>  Cacheable (Cached) </li><li>  Push or Pull (Recipients or Takers) </li><li>  Backpressure </li><li>  Operator fusion (Supporting operator fusion) </li></ol><br><p>  And let's choose the classes that we will compare: </p><br><ol><li>  CompletableFuture </li><li>  Stream </li><li>  Optional </li><li>  Observable (RxJava 1) </li><li>  Observable (RxJava 2) </li><li>  Flowable (RxJava 2) </li><li>  Flux (Reactor Core) </li></ol><br><p>  Ready?  Gathered, drove! </p><br><h2 id="composable">  Composable </h2><br><p>  All these classes are composable and allow you to think functionally ( <em>corrected by the author's typo - comment. Per.</em> ).  For this we love them. </p><br><p> <strong>CompletableFuture</strong> is a set of <code>.then*()</code> methods that allow you to build a chain in which either nothing or a single + throwable value is passed from stage to stage. </p><br><p>  <strong>Stream</strong> - a bunch of concatenated operators that allow you to convert input data.  Can transmit N values ‚Äã‚Äãfrom stage to stage. </p><br><p>  <strong>Optional</strong> is a pair of intermediate operators: <code>.map()</code> , <code>.flatMap()</code> , <code>.filter()</code> . </p><br><p>  <strong>Observable, Flowable, Flux</strong> - similar to <strong>Stream</strong> . </p><br><h2 id="lazy">  Lazy </h2><br><p>  <strong>CompletableFuture</strong> is not lazy, as it simply stores asynchronous results.  Such objects are created to represent work that has already begun.  ( <em>Corrected on the numbers - approx. per.</em> ) <em>.</em> They know nothing about the work, but the result is known.  Thus, there is no way to go upstream and run the chain from top to bottom.  The next stage starts when the value is set in the <code>CompletableFuture</code> . <br>  (the <em>conclusion is correct, but the reasoning is controversial. In fact, the <code>CompletableFuture</code> not lazy, because the search and setting its values ‚Äã‚Äãbegin even before we turn to it for the result - comment. per.</em> ) </p><br><p>  <strong>Stream</strong> - all intermediate operations are lazy.  All final operations start the computational process. </p><br><p>  <strong>Optional</strong> - not lazy, all operations take place immediately. </p><br><p>  <strong>Observable, Flowable, Flux</strong> - nothing happens until there is a subscriber (Subscriber). </p><br><h2 id="reusable">  Reusable </h2><br><p>  <strong>CompletableFuture</strong> can be reusable, as it is just a wrapper over the value.  But you need to use it carefully, as this wrapper is mutable.  If you are sure that no one will call <code>.obtrude*()</code> , then it is safe. </p><br><p>  <strong>Stream</strong> is not reusable.  As <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">stated in JavaDoc</a> : </p><br><blockquote>  Flow operations (intermediate or final) should be performed only once.  An implementation of a thread can throw an IllegalStateException if it detects that the thread is being reused.  However, since some stream operations can return their recipient, rather than a new object of the Stream class, it is not possible to detect reuse in all cases. </blockquote><p>  <strong>Optional</strong> is completely reusable because it is immutable and all work happens immediately. </p><br><p>  <strong>Observable, Flowable, Flux</strong> - are designed to be reused.  All stages start from the starting point and only when there is a subscriber. </p><br><h2 id="asynchronous">  Asynchronous </h2><br><p>  <strong>CompletableFuture</strong> - well, the whole point of this class is to link operations asynchronously.  <code>CompletableFuture</code> personifies the work associated with some <code>Executor</code> .  If you do not explicitly specify <code>Executor</code> when creating the task, the usual <code>ForkJoinPool</code> .  This pool can be obtained using <code>ForkJoinPool.commonPool()</code> , and by default it creates as many threads as there are hardware threads in your system (as a rule, the number of cores, and twice as many if the kernel supports HyperThreading).  However, you can set the number of threads in this pool with the jvm parameter <br> <code>-Djava.util.concurrent.ForkJoinPool.common.parallelism=?</code> <br>  or use the new <code>Executor</code> every time you create a work step. </p><br><p>  <strong>Stream</strong> - there is no possibility of asynchronous processing, but it can perform computations in parallel, creating a parallelized stream ‚Äî <code>stream.parallel()</code> . </p><br><p>  <strong>Optional</strong> - Nope, this is just a container. </p><br><p>  <strong>Observable, Flowable, Flux</strong> - although aimed at building asynchronous systems, but synchronous by default.  The <code>subscribeOn</code> and <code>observeOn</code> allow you to control the subscription registration and the receipt of notifications (i.e. which thread will call <code>onNext</code> / <code>OnError</code> / <code>OnCompleted</code> with an observer). </p><br><p>  With <code>subscribeOn</code> you decide on which <code>Scheduler</code> <code>Observable.create</code> run.  Even if you do not call <code>create</code> yourself, there is an internal equivalent.  Example: </p><br><pre> <code class="java hljs">Observable .fromCallable(() -&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"Reading on thread: "</span></span> + currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readFile(<span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>); }) .map(text -&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"Map on thread: "</span></span> + currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.length(); }) .subscribeOn(Schedulers.io()) <span class="hljs-comment"><span class="hljs-comment">// &lt;-- setting scheduler .subscribe(value -&gt; { log.info("Result on thread: " + currentThread().getName()); });</span></span></code> </pre> <br><p>  At the exit: </p><br><pre> <code class="java hljs">Reading file on thread: RxIoScheduler-<span class="hljs-number"><span class="hljs-number">2</span></span> Map on thread: RxIoScheduler-<span class="hljs-number"><span class="hljs-number">2</span></span> Result on thread: RxIoScheduler-<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  On the other hand, <code>observeOn()</code> controls which <code>Scheduler</code> used to invoke subsequent steps following <code>observeOn()</code> .  Example: </p><br><pre> <code class="java hljs">Observable .fromCallable(() -&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"Reading on thread: "</span></span> + currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readFile(<span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>); }) .observeOn(Schedulers.computation()) <span class="hljs-comment"><span class="hljs-comment">// &lt;-- setting scheduler .map(text -&gt; { log.info("Map on thread: " + currentThread().getName()); return text.length(); }) .subscribeOn(Schedulers.io()) // &lt;-- setting scheduler .subscribe(value -&gt; { log.info("Result on thread: " + currentThread().getName()); });</span></span></code> </pre> <br><p>  At the exit: </p><br><pre> <code class="java hljs">Reading file on thread: RxIoScheduler-<span class="hljs-number"><span class="hljs-number">2</span></span> Map on thread: RxComputationScheduler-<span class="hljs-number"><span class="hljs-number">1</span></span> Result on thread: RxComputationScheduler-<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2 id="cacheable">  Cacheable </h2><br><p>  What is the difference between reusable and cached?  Suppose we have the chain <code>A</code> , and we reuse it twice to create the chains <code>B = A + O</code> and <code>C = A + O</code> </p><br><p>  If <code>B</code> &amp; <code>C</code> succeeds, then the class is reused. <br>  If the <code>B</code> &amp; <code>C</code> completed successfully and each stage of the chain <code>A</code> is called only once, then the class is cached.  To be cached, the class must be reusable. </p><br><p>  <strong>CompletableFuture</strong> is the same answer as for reusability. </p><br><p>  <strong>Stream</strong> - there is no possibility to cache the intermediate result until the final statement is called. </p><br><p>  <strong>Optional</strong> is ‚Äúcacheable‚Äù because all the work happens right away. </p><br><p>  <strong>Observable, Flowable, Flux</strong> - not cached by default.  But you can make <code>A</code> cachable by calling it <code>.cache()</code> . </p><br><pre> <code class="java hljs">Observable&lt;Integer&gt; work = Observable.fromCallable(() -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Doing some work"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; }); work.subscribe(System.out::println); work.map(i -&gt; i * <span class="hljs-number"><span class="hljs-number">2</span></span>).subscribe(System.out::println);</code> </pre> <br><p>  At the exit: </p><br><pre> <code class="java hljs">Doing some work <span class="hljs-number"><span class="hljs-number">10</span></span> Doing some work <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br><p>  With <code>.cache()</code> : </p><br><pre> <code class="java hljs">Observable&lt;Integer&gt; work = Observable.fromCallable(() -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Doing some work"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; }).cache(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- apply caching work.subscribe(System.out::println); work.map(i -&gt; i * 2).subscribe(System.out::println);</span></span></code> </pre> <br><p>  At the exit: </p><br><pre> <code class="java hljs">Doing some work <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br><h2 id="push-or-pull">  Push or pull </h2><br><p>  <strong>Stream</strong> &amp; <strong>Optional</strong> work on the Pull principle.  The result is taken from the chain by calling various methods ( <code>.get()</code> , <code>.collect()</code> , etc.).  Pull is often associated with blocking, synchronous execution, and this is true.  You call a method and the thread starts waiting for the data to arrive.  Until then, the thread is blocked. </p><br><p>  <strong>CompletableFuture, Observable, Flowable, Flux</strong> work on the principle of Push.  The chain is signed and then notified when something needs to be processed.  Push is often associated with non-blocking asynchronous execution.  You can do anything, while the chain runs in any thread.  You have already described the code for execution, so the notification will trigger the execution of this code in the next step. </p><br><h2 id="backpressure">  Backpressure </h2><br><blockquote>  <strong><em>In order to be able to restrain the flow, the chain must be built on the principle of Push.</em></strong> </blockquote><p>  <strong>Constraining a flow</strong> is a situation in a chain where some asynchronous stages cannot process values ‚Äã‚Äãquickly enough and they need a way to turn up the chain, asking them to be slower.  The situation is unacceptable when a failure occurs at some stage, because there is too much data ( <em>the ambiguity of the author‚Äôs wording is preserved</em> ). </p><br><p><img src="https://habrastorage.org/files/e1a/633/0be/e1a6330be4cc48bea174c2a24c0921ac.jpg" alt="image"></p><br><ul><li>  <strong>Stream</strong> &amp; <strong>Optional</strong> do not support this mechanism, since they are built on the Pull principle. </li><li>  <strong>CompletableFuture</strong> does not need to solve this problem, since it gives 0 or 1 as a result. </li></ul><br><p>  <strong>Observable (RxJava 1), Flowable, Flux</strong> - solve this problem.  The main strategies are: </p><br><ul><li>  <strong>Buffering</strong> ‚Äî saves all <code>onNext</code> values ‚Äã‚Äãto the buffer until they are required downstream. </li><li>  <strong>Discarding new</strong> - the last value of <code>onNext</code> discarded if the next element of the chain fails. </li><li>  <strong>Storing the last</strong> - providing only the last <code>onNext</code> value, overwriting any previous value, if the next element of the chain does not cope. </li><li>  <strong>No containment</strong> - <code>onNext</code> events are recorded without buffering or dropping. </li><li>  <strong>Exception</strong> - an <strong>exception</strong> is thrown if the next element of the chain fails. </li></ul><br><p>  <strong>Observable (RxJava 2)</strong> - does not solve this problem.  Many users of RxJava 1 used <code>Observable</code> for events that are unreasonable to restrain, or did not use any strategies, which caused unexpected exceptions.  Therefore, in <strong><em>RxJava 2,</em></strong> there is a clear separation between the <code>Flowable</code> and <code>Observable</code> classes. </p><br><h2 id="operator-fusion">  Operator Fusion </h2><br><p>  The idea is to change the chain at different points in the entire life cycle in order to reduce the complexity created by the library architecture.  All these optimizations are done internally, so for the end user everything remains clear. </p><br><p>  Only <strong>RxJava 2</strong> &amp; <strong>Reactor</strong> supports operator merging, but in a slightly different way.  In general, there are 2 types of optimizations: </p><br><ul><li>  Macro-fusion - replacement of 2+ operators following each other by one operator. </li></ul><br><p><img src="https://habrastorage.org/files/f0a/ce0/6a6/f0ace06a613846c080359e08e771c365.png" alt="image"></p><br><ul><li>  Micro-fusion - operators who have an output queue at the end, and operators starting from the front queue can use the same instance of the queue.  As an example, instead of calling request (1) and further processing onNext () ... </li></ul><br><p><img src="https://habrastorage.org/files/406/d8e/c1a/406d8ec1a88541cd87fcfb90a4f6a2e4.png" alt="image"></p><br><p>  ... the subscriber may request the value from the parent Observable: </p><br><p><img src="https://habrastorage.org/files/e21/093/5e6/e210935e61c048b28f3b70fd49f7164a.png" alt="image"></p><br><p>  More information can be found here: <a href="http://akarnokd.blogspot.com/2016/03/operator-fusion-part-1.html">Part 1</a> &amp; <a href="http://akarnokd.blogspot.com/2016/04/operator-fusion-part-2-final.html">Part 2</a> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p><img src="https://habrastorage.org/files/62c/489/590/62c48959025849f0a8086b977a3b2cfc.png" alt="imagecomparison"></p><br><p>  <code>Stream</code> , <code>CompletableFuture</code> and <code>Optional</code> were created to solve specific problems.  And they are really good at solving these problems.  If they are enough to meet your needs, go ahead. </p><br><p>  However, different problems have different complexity and some of them require new approaches.  <strong>RxJava &amp; Reactor</strong> are versatile tools to help you solve your tasks in a declarative style, rather than creating <strong><em>‚Äúhacks‚Äù</em></strong> using tools that were not designed to solve such problems. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/327460/">https://habr.com/ru/post/327460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327450/index.html">Operator overloading in freepascal on the example of ordinary fractions</a></li>
<li><a href="../327452/index.html">Mobile application prototyping: from idea to desktop</a></li>
<li><a href="../327454/index.html">Everything is not so simple with Ctrl + Z: about undo in fast editing ONLYOFFICE</a></li>
<li><a href="../327456/index.html">Container lsp</a></li>
<li><a href="../327458/index.html">Revision # 1. The key to start</a></li>
<li><a href="../327464/index.html">Do you need video calls in VR?</a></li>
<li><a href="../327466/index.html">Several lines of JS code to call from browser to mobile phone</a></li>
<li><a href="../327468/index.html">Consensus Algorithms: Proof of Share and Proof of Work</a></li>
<li><a href="../327470/index.html">DevExtreme: now on GitHub and with a free license</a></li>
<li><a href="../327472/index.html">Vivaldi 1.9 - plant not transplant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>