<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CoffeeScript: Methods for working with objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the 5th edition of ECMAScript for working with objects, many new methods have appeared, but their detailed description and internal implementation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CoffeeScript: Methods for working with objects</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/818/834/865/8188348652d8d4027dd265cc94df6a77.jpg" align="left" alt="CoffeeScript Object methods"><br><br>  In the 5th edition of <i>ECMAScript</i> for working with objects, many new methods have appeared, but their detailed description and internal implementation in Russian (often in English) is not so easy to find.  It is for this reason that this article will examine and describe in detail all the methods of the Object <i>object</i> according to the 3rd and 5th editions of the <i>ECMAScript</i> specification. <br><br><h5>  Content </h5><br>  1. Object.create (proto [, properties]) <br>  2. Object.defineProperty (object, property, descriptor) <br>  3. Object.defineProperties (object, properties) <br>  4. Object.getOwnPropertyDescriptor (object, properties) <br>  5. Object.keys (object) <br>  6. Object.getOwnPropertyNames (object) <br>  7. Data descriptor <br>  8. Accessor descriptor <br>  9. Object.getPrototypeOf (object) <br>  10. Object.preventExtensions (object) <br>  11. Object.isExtensible (object) <br>  12. Object.seal (object) <br>  13. Object.isSealed (object) <br>  14. Object.freeze (object) <br>  15. Object.deepFreeze (object) (non-standard) <br>  16. Object.prototype.hasOwnProperty (property) <br>  17. Object.prototype.isPrototypeOf (object) <br>  18. Object.prototype.propertyIsEnumerable (object) <br>  19. Conclusion <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><h3>  Object.create (proto [, properties]) </h3><br>  <i>Object.create ()</i> creates a new object with the specified prototype object and properties: <br><br><pre><code class="coffeescript hljs">object = Object.create property: <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre> <br>  The method can take two initializing parameters. <br>  The first parameter is required, it specifies the prototype of the object and must be <i>null</i> or an object. <br>  The second parameter is optional, it initializes the properties of the object. <br><br>  Consider an example: <br><br><pre> <code class="coffeescript hljs">object = Object.create {}, property: value: <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  In this example, we set the first parameter to an empty object, which will be the prototype object for the properties defined in the second parameter. <br><br><blockquote>  Do not be confused by the mysterious <i>value</i> property, a little later we will look at this topic in more detail. <br></blockquote><br>  So what is the difference between the first and second option? <br>  I think that the answer to this question can clarify the following example: <br><br><pre> <code class="coffeescript hljs">object = Object.create property: <span class="hljs-number"><span class="hljs-number">1</span></span> object.property = <span class="hljs-number"><span class="hljs-number">2</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 2 object = Object.create {}, property: value: 1 object.property = 2 object.property # 1</span></span></code> </pre><br>  What the hell you ask? <br>  Simply, the second form of writing by default implies that properties are read-only, they cannot be deleted and they cannot be listed! <br><br>  Let's look at an example: <br><br><pre> <code class="coffeescript hljs">object = Object.create {} property: value: <span class="hljs-number"><span class="hljs-number">1</span></span> object.property = <span class="hljs-number"><span class="hljs-number">2</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1 object.method = -&gt; object.property do object.method # 1 key for key of object # method delete object.property # false</span></span></code> </pre><br>  As you can see, we failed to set a new value for the property, neither to list, nor to delete. <br><br>  And now I would like to draw attention to the way prototype inheritance is implemented using <i>Object.create ()</i> : <br><br><pre> <code class="coffeescript hljs">A = a: <span class="hljs-number"><span class="hljs-number">1</span></span> b: <span class="hljs-number"><span class="hljs-number">2</span></span> B = Object.create A, c: value: <span class="hljs-number"><span class="hljs-number">3</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> B <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log <span class="hljs-string"><span class="hljs-string">" # {key}: # {value}"</span></span> <span class="hljs-comment"><span class="hljs-comment"># c:3, a:1, b:2</span></span></code> </pre><br>  In this example, we implemented property inheritance from object <i>A</i> , and added an <i>enumerable</i> attribute so that the property defined in object B can be listed in the <i>for-of</i> loop. <br><br>  I want to note that the presence of the operator in the <i>for-of</i> statement avoids the use of the <i>hasOwnProperty</i> method in the body of the loop and <i>prevents</i> checking the properties in the object's prototype chain. <br>  A more detailed description of this operator can be found in my previous <a href="http://habrahabr.ru/post/140764/">article</a> . <br><br>  If you are interested in how the <i>create ()</i> method <i>works</i> from the inside, then as a task to consolidate the read, I quote its implementation according to the <a href="http://es5.github.com/">specification</a> : <br><br><pre> <code class="coffeescript hljs">Object.create = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object, properties)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If Type(O) is not Object or Null throw a TypeError exception. if typeof object is not 'object' throw new TypeError "Object.create: # {object.toString()} is not an Object or Null" # 2. Let obj be the result of creating a new object as if by the expression new Object() # where Object is the standard built-in constructor with that name __new__ = new Object # 3. Set the [[Prototype]] internal property of obj to O. if '__proto__' of init __new__.__proto__ = object; else __new__.constructor:: = object # 4. If the argument Properties is present and not undefined, add own properties # to obj as if by calling the standard built-in function Object.defineProperties # with arguments obj and Properties. if typeof props is not 'undefined' Object.defineProperties object, props # 5. Return obj. object</span></span></code> </pre><br><br><h3>  Object.defineProperty (object, property, descriptor) </h3><br>  The <i>Object.defineProperty ()</i> method allows you to define a new property of an object and / or modify the attributes of an existing property.  A new object is returned as a result. <br><br>  <i>object</i> - the object for which you want to define properties <br>  <i>property</i> - the name of the property to be defined or modified. <br>  <i>descriptor</i> - descriptor <br><br>  Consider an example: <br><br><pre> <code class="coffeescript hljs">object = {} Object.defineProperty object, <span class="hljs-string"><span class="hljs-string">'property'</span></span> value: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  At the same time, you probably already have questions regarding the use of the <i>value</i> property.  Now we will try to highlight this issue in more detail. <br><br>  With new methods in <i>ECMAScript 5</i> , new terms have appeared, in particular, a <i>user descriptor</i> . <br><br>  A descriptor is a simple object ( <i>plain object</i> ) that allows you to set values ‚Äã‚Äãand access level for your own properties, as well as store their description. <br><br>  In other words, descriptors allow you to control the attributes of properties. <br>  Before the advent of <i>ECMAScript 5</i> , much more modest tools were available to us to work with the attributes of objects: <i>Object.prototype.propertyIsEnumerable ()</i> and <i>Object.prototype.hasOwnProperty ()</i> . <br><br>  Formally, descriptors are divided into three types: <a href="http://es5.github.com/">data descriptors</a> ( <i>Data descriptors</i> ), <a href="http://es5.github.com/">access descriptors</a> ( <i>Accessor descriptors</i> ), and <a href="http://es5.github.com/">general descriptors</a> ( <i>Generic descriptors</i> ). <br>  However, we will not consider the last type of descriptors, since  their description is more theoretical at the level of implementation than practical. <br><br><h4>  Data descriptor </h4><br>  This property is created if the descriptor is empty or the descriptor has one of two attributes: <i>value</i> or <i>writable</i> . <br>  The internal method <a href="http://es5.github.com/">[[IsDataDescriptor]]</a> is responsible for checking the presence of attributes: <br><br><pre> <code class="coffeescript hljs">IsDataDescriptor (Descriptor): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Descriptor <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !Descriptor.[[Value]] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> !Descriptor.[[Writable]] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span></code> </pre><br>  In addition to the required attributes, there are optional attributes in the data descriptor: <i>configurable</i> and <i>enumerable</i> . <br><br><pre> <code class="coffeescript hljs">{ configurable: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, enumerable: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  Now let's look at all the attributes individually: <br><br>  <i>value</i> - sets the value of the object property. <br>  <i>writable</i> - defines the possibility of changing the property. <br>  <i>configurable</i> - defines the ability to delete a property. <br>  <i>enumerable</i> - determines the accessibility of listing properties <br><br>  Inside the implementation, these attributes have the following names: <i>[[Value]]</i> , <i>[[Writable]]</i> , <i>[[Enumerable]]</i> , <i>[[Configurable]]</i> . <br><br>  By default, all data descriptor attributes are <i>false</i> , except for the <i>value</i> attribute, its value is set to <i>undefined</i> . <br><br>  Note: formally, in <i>ECMAScript 3 there</i> are no user descriptors, but there are internal attributes <i>DontEnum</i> , <i>ReadOnly</i> and <i>DontDelete</i> . <br><br>  Thus, we ourselves can set similar attributes for object properties: <br><br><pre> <code class="coffeescript hljs">Object.defineProperty {}, <span class="hljs-string"><span class="hljs-string">'property'</span></span> value: <span class="hljs-number"><span class="hljs-number">1</span></span> writable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> configurable: <span class="hljs-literal"><span class="hljs-literal">on</span></span></code> </pre><br>  And now let's imagine that we needed to expand the <i>Object</i> prototype: <br><br><pre> <code class="coffeescript hljs">Object::method = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> @</code> </pre><br>  So we added a new method to the <i>Object</i> prototype and can continue to use it. <br>  In fact, this solution has a lot of disadvantages. <br><br>  Firstly, there is a possibility that a method with the same name may appear in a future standard and our method will override it.  As an option, you can give the method some intricate name and sleep well. <br><br>  For example: <br><br><pre> <code class="coffeescript hljs">Object::my_super_method = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> @</code> </pre><br>  It is unlikely that a method with this name will ever fall into the specification. <br><br>  Secondly, everything that we add to the prototype <i>Object</i> gets into other objects: <br><br><pre> <code class="coffeescript hljs">Object::method = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> list = [] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> list.method <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  Third, such a method will have a value of <i>true for</i> the <i>enumerable</i> attribute: <br><br><pre> <code class="coffeescript hljs">Object::method = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> object = {}; i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-comment"><span class="hljs-comment"># method</span></span></code> </pre><br>  You can prevent the enumeration of the method <i>method</i> in an <i>object</i> as follows: <br><br><pre> <code class="coffeescript hljs">i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object</code> </pre><br>  Despite the fact that this solution works well, it can be improved at the stage of adding a method to the <i>Object</i> prototype: <br><br><pre> <code class="coffeescript hljs">Object.defineProperty Object::, <span class="hljs-string"><span class="hljs-string">'method'</span></span> value: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">false</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-comment"><span class="hljs-comment">#</span></span></code> </pre><br>  As you can see, the <i>method was</i> not listed in the <i>for-of</i> statement. <br><br>  Although the expansion of prototype base types is not always good practice, this need sometimes arises.  Therefore, for your part, try to take all reasonable measures so that you do not step on your own rake, especially if other people will work with your code. <br><br><h4>  Accessor descriptors </h4><br>  An access descriptor is one in which the <i>get</i> or <i>set</i> attribute is present.  In this case, the presence of these attributes together.  However, the presence of the attributes <i>value</i> and <i>writable is unacceptable</i> : <br><br><pre> <code class="coffeescript hljs">IsDataDescriptor (Descriptor): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Descriptor <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !Descriptor.[[Get]] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> !Descriptor.[[Set]] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span></code> </pre><br>  Then the internal method <i>[[DefineOwnProperty]] is called</i> <br>  Inside the implementation, the descriptor attributes have the following names: <i>[[Get]]</i> and <i>[[Set]]</i> . <br><br>  The attributes <i>configurable</i> and <i>enumerable</i> are also available in the data descriptor: <br><br><pre> <code class="coffeescript hljs">property = <span class="hljs-number"><span class="hljs-number">0</span></span> object = Object.defineProperty {}, <span class="hljs-string"><span class="hljs-string">'property'</span></span> get: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> property set: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> -&gt;</span></span> property = value configurable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> object.property = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># set object.property # 1, get</span></span></code> </pre><br>  I also want to note that the simultaneous use of data descriptors and access is not allowed: <br><br><pre> <code class="coffeescript hljs">Object.defineProperty {}, <span class="hljs-string"><span class="hljs-string">'property'</span></span> get: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> value: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># TypeError: property descriptors must not specify a value or be writable when a getter or setter has been specified 'value: 1"</span></span></code> </pre><br>  As in the case of <i>Object.create ()</i> , inheritance is performed on the same principle: <br><br><pre> <code class="coffeescript hljs">A = a: <span class="hljs-number"><span class="hljs-number">1</span></span> b: <span class="hljs-number"><span class="hljs-number">2</span></span> B = Object.defineProperty A, <span class="hljs-string"><span class="hljs-string">'c'</span></span> value: <span class="hljs-number"><span class="hljs-number">3</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> B <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log <span class="hljs-string"><span class="hljs-string">" # {key}: # {value}"</span></span> <span class="hljs-comment"><span class="hljs-comment"># a:1, b:2, c:3</span></span></code> </pre><br><br><h3>  Object.defineProperties (object, properties) </h3><br>  Allows you to define new properties of the object and / or modify the attributes of existing properties.  A new object is returned as a result.  In other words, <i>Object.defineProperties ()</i> does the same as <i>Object.defineProperty ()</i> only with a lot of properties. <br><br><pre> <code class="coffeescript hljs">object = Object.defineProperties {}, a: value: <span class="hljs-number"><span class="hljs-number">1</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> b: value: <span class="hljs-number"><span class="hljs-number">2</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log <span class="hljs-string"><span class="hljs-string">" # {key}: # {value}"</span></span> <span class="hljs-comment"><span class="hljs-comment"># a:1, b:2</span></span></code> </pre><br>  If the names of the defined properties coincide with the inherited, then the inherited are overridden: <br><br><pre> <code class="coffeescript hljs">A = a: <span class="hljs-number"><span class="hljs-number">1</span></span> b: <span class="hljs-number"><span class="hljs-number">2</span></span> object = Object.defineProperties {} a: value: <span class="hljs-number"><span class="hljs-number">3</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> b: value: <span class="hljs-number"><span class="hljs-number">4</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log <span class="hljs-string"><span class="hljs-string">" # {key}: # {value}"</span></span> <span class="hljs-comment"><span class="hljs-comment"># a:3, b:4</span></span></code> </pre><br>  It should be remembered that redefining an accessor simply will not work: <br><br><pre> <code class="coffeescript hljs">object = Object.defineProperty {}, <span class="hljs-string"><span class="hljs-string">'property'</span></span> get: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Object.defineProperty object, <span class="hljs-string"><span class="hljs-string">'property'</span></span> get: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 0</span></span></code> </pre><br>  Obviously, to override a property, you need to change the value of the <i>configurable</i> attribute: <br><br><pre> <code class="coffeescript hljs">object = Object.defineProperty {}, <span class="hljs-string"><span class="hljs-string">'property'</span></span> get: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> configurable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> Object.defineProperty object, <span class="hljs-string"><span class="hljs-string">'property'</span></span> get: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  Unfortunately, <i>IE</i> does not support this method below version 9.  However, not everything is so bad, because  in the 8th version there is the <i>Object.defineProperty ()</i> method, on the basis of which <i>Object.defineProperties ()</i> can be implemented: <br><br><pre> <code class="coffeescript hljs">Object.defineProperties = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object, properties)</span></span></span><span class="hljs-function"> -&gt;</span></span> type = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> Object::toString.call object <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">'[object Object]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !type object <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> !type properties <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeError <span class="hljs-string"><span class="hljs-string">'Object.defineProperties(Object object, properties Object)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !Object.defineProperty <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> properties Object.defineProperty object, key, value object</code> </pre><br><br><h3>  Object.getOwnPropertyDescriptor (object, properties) </h3><br>  This method allows access to the descriptor properties. <br><br><pre> <code class="coffeescript hljs">object = {} Object.defineProperty object, <span class="hljs-string"><span class="hljs-string">'property'</span></span> value: <span class="hljs-number"><span class="hljs-number">1</span></span> writable: <span class="hljs-literal"><span class="hljs-literal">off</span></span> enumerable: <span class="hljs-literal"><span class="hljs-literal">off</span></span> configurable: <span class="hljs-literal"><span class="hljs-literal">on</span></span> Object.getOwnPropertyDescriptor object, <span class="hljs-string"><span class="hljs-string">'property'</span></span> <span class="hljs-comment"><span class="hljs-comment">### { value: 1, writable: true, enumerable: true, configurable: true } ###</span></span></code> </pre><br>  Because  descriptor properties are internal properties of <i>ECMAScript</i> , <i>Object.getOwnPropertyDescriptor () is the</i> only method by which such information can be obtained.  It is worth noting that <i>Object.getOwnPropertyDescriptor ()</i> works only with its own properties: <br><br><pre> <code class="coffeescript hljs">Object.getOwnPropertyDescriptor {}, <span class="hljs-string"><span class="hljs-string">'valueOf'</span></span> <span class="hljs-comment"><span class="hljs-comment"># undefined</span></span></code> </pre><br>  Because the <i>valueOf</i> property is inherited and is in the prototype chain: <br><br><pre> <code class="coffeescript hljs">{}.hasOwnProperty <span class="hljs-string"><span class="hljs-string">'valueOf'</span></span> <span class="hljs-comment"><span class="hljs-comment"># false 'valueOf' of {} # true</span></span></code> </pre><br>  As I have already noted, the <i>hasOwnProperty ()</i> method, in contrast to the of operator, only checks the object's own properties. <br><br>  You can access the <i>valueOf</i> property directly, like this: <br><br><pre> <code class="coffeescript hljs">{}.constructor::valueOf <span class="hljs-comment"><span class="hljs-comment"># function</span></span></code> </pre><br>  For more clarity, I would like to consider the following example: <br><br><pre> <code class="coffeescript hljs">object = {} object.constructor::valueOf = <span class="hljs-number"><span class="hljs-number">1</span></span> object.valueOf <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  At first glance, there is no difference between explicitly adding a property to an object and through a prototype object, and these record forms can replace each other.  However, this is not quite true: <br><br><pre> <code class="coffeescript hljs">object = {} object.valueOf = <span class="hljs-number"><span class="hljs-number">1</span></span> object.constructor::valueOf = <span class="hljs-number"><span class="hljs-number">2</span></span> object.toString <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  As you can see, if a property is given to an object explicitly ( <i>own property</i> ), then its value ‚Äúoverlaps‚Äù the property specified through the prototype object.  More precisely, the value of the property in the prototype object does not disappear anywhere, it simply does not resolve and is always accessible directly: <br><br><pre> <code class="coffeescript hljs">object = {} object.toString = <span class="hljs-number"><span class="hljs-number">1</span></span> object.constructor::valueOf = <span class="hljs-number"><span class="hljs-number">2</span></span> object.toString <span class="hljs-comment"><span class="hljs-comment"># 1 object.constructor::valueOf # 2 'valueOf' of object # true object.hasOwnProperty 'valueOf' # false</span></span></code> </pre><br>  In other words, if an object's property is not explicitly specified, the search continues in the prototype chain: <br><br><pre> <code class="coffeescript hljs">object = {} object.constructor::constructor::constructor::property = <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  As a "home" assignment, I suggest you consider the following example: <br><br><pre> <code class="coffeescript hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> -&gt;</span></span> x * x fn <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment"># 4 fn::constructor 4 # 8</span></span></code> </pre><br><br><h3>  Object.keys (object) </h3><br>  Returns an array containing the names of the enumerated proper properties of the object. <br><br>  Consider a typical example: <br><br><pre> <code class="coffeescript hljs">Object.keys a: <span class="hljs-number"><span class="hljs-number">1</span></span> b: <span class="hljs-number"><span class="hljs-number">2</span></span> .length <span class="hljs-comment"><span class="hljs-comment"># 2</span></span></code> </pre><br>  Quite often <i>Object.keys</i> is used in conjunction with other methods of the <i>Array</i> object: <br><br><pre> <code class="coffeescript hljs">object = a: <span class="hljs-number"><span class="hljs-number">1</span></span> b: <span class="hljs-number"><span class="hljs-number">2</span></span> Object.keys(object).filter (i) -&gt; i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> object[i] &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># 2</span></span></code> </pre><br>  Implementing the <i>Object.keys ()</i> method is pretty simple: <br><br><pre> <code class="coffeescript hljs">Object.keys = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object</code> </pre><br>  However, I strongly recommend that you always use input argument checking. <br>  After minor corrections, a typical implementation of <i>Object.keys ()</i> should look something like this: <br><br><pre> <code class="coffeescript hljs">Object.keys = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Object::toString.call(object) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'[object Object]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeError <span class="hljs-string"><span class="hljs-string">"Object.keys: # {object.toString()} is not an Object"</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object</code> </pre><br>  The implementation of <i>Object.keys ()</i> according to the <a href="http://es5.github.com/">specification</a> : <br><br><pre> <code class="coffeescript hljs">Object.keys = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If the Type(O) is not Object, throw a TypeError exception if Object::toString.call(object) is not '[object Object]' throw new TypeError "Object.keys: # {object.toString()} is not an Object" # 2. Let count be the number of own enumerable properties of O count = Object.getOwnPropertyNames(object).length # 3. Let array be the result of creating a new Object as if by the expression new Array(n) # where Array is the standard built-in constructor with that name array = new Array count # 4. Let index be 0 index = 0; # 5. For each own enumerable property of O whose name String is P for own property of object if !object.propertyIsEnumerable property continue # a. Call the [[DefineOwnProperty]] internal method of array with arguments # ToString(index), the PropertyDescriptor # {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false # b. Increment index by 1 Object.defineProperty array, index++, value: property writable: on enumerable: on configurable: on # 6. Return array array</span></span></code> </pre><br><br><h3>  Object.getOwnPropertyNames (object) </h3><br>  Returns an array containing the names of the object's own properties. <br>  Unlike <i>Object.keys (object),</i> this method does not take into account the value of the <i>enumerable</i> attribute: <br><br><pre> <code class="coffeescript hljs">object = a: <span class="hljs-number"><span class="hljs-number">1</span></span> b: <span class="hljs-number"><span class="hljs-number">2</span></span> Object.defineProperty object, <span class="hljs-string"><span class="hljs-string">''</span></span> value: <span class="hljs-number"><span class="hljs-number">3</span></span>, enumerable: <span class="hljs-literal"><span class="hljs-literal">off</span></span>, Object.keys(object).length <span class="hljs-comment"><span class="hljs-comment"># 2 Object.getOwnPropertyNames(object).length # 3</span></span></code> </pre><br>  The implementation of <i>Object.getOwnPropertyNames ()</i> according to the <a href="http://es5.github.com/">specification</a> : <br><br><pre> <code class="coffeescript hljs">Object.getOwnPropertyNames = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If the Type(O) is not Object, throw a TypeError exception if Object::toString.call(object) is not '[object Object]' throw new TypeError "Object.getOwnPropertyNames: # {object.toString()} is not an Object" # 2. Let array be the result of creating a new Object as if by the expression new Array(n) # where Array is the standard built-in constructor with that name array = new Array # 3. Let index be 0 index = 0; # 4. For each named own property P of O for own name of object # a. Let name be the String value that is the name of P. # b. Call the [[DefineOwnProperty]] internal method of array with arguments # ToString(n), the PropertyDescriptor {[[Value]]: name, [[Writable]]: true, # [[Enumerable]]: true, [[Configurable]]: true}, and false. # c. Increment n by 1. Object.defineProperty array, index++, value: name writable: on enumerable: on configurable: on # console.log array # 5. Return array array</span></span></code> </pre><br><br><h3>  Object.getPrototypeOf (object) </h3><br>  Returns a reference to the <i>[[Prototype]]</i> property of the specified object. <br><br><pre> <code class="coffeescript hljs">object = {} Object.getPrototypeOf(object).property = <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  Method implementation: <br><br><pre> <code class="coffeescript hljs">Object.getPrototypeOf = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Object::toString.call(object) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'[object Object]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeError <span class="hljs-string"><span class="hljs-string">"Object.getPrototypeOf: # {object.toString()} is not an Object"</span></span> object.__proto__ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> object.constructor::</code> </pre><br><br><h3>  Object.preventExtensions (object) </h3><br>  Blocks an object extension. <br><br><pre> <code class="coffeescript hljs">object = a: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.preventExtensions object object.b = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-comment"><span class="hljs-comment"># false Object.getOwnPropertyDescriptor object, 'a' # { configurable: true, enumerable: true, value: 1, writable: true }</span></span></code> </pre><br>  I want to pay special attention to the fact that an attempt to extend a blocked object using the methods: <i>Object.defineProperty and Object.defineProperties</i> will <i>throw a TypeError</i> exception! <br><br><pre> <code class="coffeescript hljs">object = {} Object.preventExtensions object Object.defineProperty object, <span class="hljs-string"><span class="hljs-string">'property'</span></span> value: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># TypeError: Object.defineProperties(object, 'property', ...) is not extensible</span></span></code> </pre><br>  Also, <i>TypeError is</i> always thrown in strict mode: <br><br><pre> <code class="coffeescript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'use strict'</span></span> object = {} Object.preventExtensions object object.property = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># "TypeError: object.property is not extensible</span></span></code> </pre><br>  In this case, be especially careful, because if you do not intercept <i>TypeError</i> , the application will stop working! <br><br><br><h3>  Object.isExtensible (object) </h3><br>  Specifies the availability of the object extension.  Returns a boolean value. <br><br><pre> <code class="coffeescript hljs">object = {} Object.preventExtensions object Object.isExtensible object <span class="hljs-comment"><span class="hljs-comment"># false</span></span></code> </pre><br><br><h3>  Object.seal (object) </h3><br>  Seals the properties of the object. <br><br><pre> <code class="coffeescript hljs">Object.seal = Object.preventExtensions + {[[Configurable]]: <span class="hljs-literal"><span class="hljs-literal">off</span></span>}</code> </pre><br>  Consider an example: <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.seal object <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># false Object.getOwnPropertyDescriptor object, 'property' # { configurable: false, enumerable: true, value: 1, writable: true }</span></span></code> </pre><br>  <i>Object.seal ()</i> sets the <i>configurable</i> attribute to <i>false</i> for all object properties: <br><br><pre> <code class="coffeescript hljs">Object.getOwnPropertyDescriptor(Object.seal property: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'property'</span></span>).configurable <span class="hljs-comment"><span class="hljs-comment"># false</span></span></code> </pre><br>  It is worth noting that it is not the object itself that is sealed, but only its properties: <br><br><pre> <code class="coffeescript hljs">object = {} Object.defineProperty, <span class="hljs-string"><span class="hljs-string">'property'</span></span> value: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.seal object <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># false delete object # false object.property # 1 object # Object</span></span></code> </pre><br>  As you can see, deleting an <i>object</i> does not work, because the <i><a href="http://es5.github.com/">delete [[Delete]]</a></i> operator deletes only the properties of an object. <br>  This happens because at the stage of translation into <i>JavaScript</i> code all variables are preceded by the var keyword. <br><br>  To delete an object itself, you need to make it a property of a global global object: <br><br><pre> <code class="coffeescript hljs"><span class="hljs-built_in"><span class="hljs-built_in">global</span></span>.object = {} <span class="hljs-comment"><span class="hljs-comment">#  @object,     Object.seal object delete object object # ReferenceError: object is not defined 'object'</span></span></code> </pre><br>  However, this definition of objects is not a good practice, because <i>object</i> falls into the global scope: <br><br><pre> <code class="coffeescript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">global</span></span>.object = {} object <span class="hljs-comment"><span class="hljs-comment"># Object</span></span></code> </pre><br>  If you want to delete an object, just give it an undefined value: <br><br><pre> <code class="coffeescript hljs">object = {} object = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> object <span class="hljs-comment"><span class="hljs-comment"># undefined</span></span></code> </pre><br>  If at some point you need to refer to this variable again, then you should use the <i>null</i> operator, which will signal that the variable once contained a reference to the object. <br><br><blockquote>  1. There is no <i>void</i> operator in <i>CoffeeScript</i> , you should use <i>undefined</i> instead, which is translated to <i>void 0</i> . <br>  2. There is no clear rule about deleting predefined properties. <br>  For example, it is perfectly possible to remove the <i>Date</i> property of the <i>Date</i> object, but at the same time, you cannot delete the <i>call</i> method of the <i>Function</i> object: <br><br><pre> <code class="coffeescript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Date.now <span class="hljs-comment"><span class="hljs-comment"># true Date.now # undefined delete Function.call Function.call # [Function: call]</span></span></code> </pre><br>  In this case, it is allowed to delete the designer itself, incl.  and <i>Object ([Configurable]]: true)</i> : <br><br><pre> <code class="coffeescript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Object <span class="hljs-comment"><span class="hljs-comment"># true typeof Object # undefined Object # ReferenceError: Object is not defined</span></span></code> </pre><br>  2. I did not consider the operator delete in more detail, because  This is a fairly large topic to include in this article.  If you are still interested in this question, I recommend reading the article <i>kangax</i> 'a <i><a href="http://perfectionkills.com/understanding-delete/">Understanding delete</a></i> <br></blockquote><br>  Besides the fact that <i>Object.seal ()</i> prohibits the deletion of properties of an object, it also blocks the addition of new ones: <br><br><pre> <code class="coffeescript hljs">object = {} Object.seal object object.property = <span class="hljs-number"><span class="hljs-number">1</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># undefined</span></span></code> </pre><br>  Note: server implementation will throw <i>TypeError</i> ! <br><br>  However, the seal does not apply to the modification of the values ‚Äã‚Äãof the properties of the object: <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.seal object object.property = <span class="hljs-number"><span class="hljs-number">2</span></span> object.property <span class="hljs-comment"><span class="hljs-comment"># 1</span></span></code> </pre><br>  As in the case of <i>Object.preventExtensions ()</i> , an attempt to modify the properties of an object in strict mode or using <i>Object.defineProperty / Object.defineProperties</i> will <i>throw a TypeError</i> exception! <br><br>  The implementation of <i>Object.seal ()</i> according to the <a href="http://es5.github.com/">specification</a> : <br><br><pre> <code class="coffeescript hljs">Object.seal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If Type(O) is not Object throw a TypeError exception if Object::toString.call(object) is not '[object Object]' throw new TypeError "Object.seal: # {object} is not callable!" # 2. For each named own property name P of O, Object.getOwnPropertyNames(object).forEach (property) -&gt; # a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P __desc__ = Object.getOwnPropertyDescriptor object, property # b. If desc.[[Configurable]] is true, set desc.[[Configurable]] to false. if __desc__.configurable is on __desc__.configurable = off # c. Call the [[DefineOwnProperty]] internal method of O with P, desc, and true as arguments Object.defineProperty object, property, __desc__ # 3. Set the [[Extensible]] internal property of O to false # 4. Return O. Object.preventExtensions object</span></span></code> </pre><br><br><h3>  Object.isSealed (object) </h3><br>  Determines whether the object is sealed.  Returns a boolean value. <br><br><pre> <code class="coffeescript hljs">object = {} Object.seal object Object.isSealed object <span class="hljs-comment"><span class="hljs-comment"># true</span></span></code> </pre><br>  If an empty object is made non-expandable, it will become sealed: <br><br><pre> <code class="coffeescript hljs">object = {} Object.preventExtensions object Object.isSealed object <span class="hljs-comment"><span class="hljs-comment"># true</span></span></code> </pre><br>  However, if you now add a property to an object, it will cease to be sealed: <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.preventExtensions object Object.isSealed object <span class="hljs-comment"><span class="hljs-comment"># false</span></span></code> </pre><br>  The implementation of <i>Object.isSealed ()</i> according to the <a href="http://es5.github.com/%2520">specification</a> : <br><br><pre> <code class="coffeescript hljs">Object.isSealed = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If Type(O) is not Object throw a TypeError exception. if Object::toString.call(object) is not '[object Object]' throw new TypeError "Object.isSealed: # {object} is not callable!" # 2. For each named own property name P of O then Object.getOwnPropertyNames(object).forEach (property) -&gt; # a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. __desc__ = Object.getOwnPropertyDescriptor object, property # b. If desc.[[Configurable]] is true, then return false. if __desc__.configurable is on return off # 3. If the [[Extensible]] internal property of O is false, then return true. # 4. Otherwise, return false. if !Object.isExtensible(object) then on else off</span></span></code> </pre><br><br><h3>  Object.freeze (object) </h3><br>  Freezes the object. <br><br><pre> <code class="coffeescript hljs">Object.freeze = Object.preventExtensions + Object.seal + {[[Writable]]: <span class="hljs-literal"><span class="hljs-literal">off</span></span>}</code> </pre><br>  In other words, <i>Object.freeze ()</i> prevents adding new properties to an object, modifying and deleting existing ones. <br><br><pre> <code class="coffeescript hljs">object = a: <span class="hljs-number"><span class="hljs-number">1</span></span> object.a = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment"># false    object.b = 0 # false     delete object.a # false    Object.getOwnPropertyDescriptor object, 'a' # { configurable: false, enumerable: true, value: 1, writable: false}</span></span></code> </pre><br>  Because  we have already examined in detail <i>Object.preventExtensions ()</i> and <i>Object.seal ()</i> there is no point in repeating. <br>  The only thing I would like to draw your attention to is the depth of the "freezing": <br><br><pre> <code class="coffeescript hljs">object = property: internal: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.freeze object object.property = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment"># false object.property.internal = 0 # true Object.getOwnPropertyDescriptor(object.property, 'internal').writable # true</span></span></code> </pre><br>  As you can see, only the first level child properties are blocked! <br>  Actually, there is no deep freezing method in <i>ECMASctipt 5,</i> nothing terrible.  Let's try to implement <i>Object.deepFreeze () by</i> ourselves: <br><br><pre> <code class="coffeescript hljs">Object.deepFreeze = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> isObject = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> -&gt;</span></span> Object::toString.call(value) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">'[object Object]'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isObject object <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeError <span class="hljs-string"><span class="hljs-string">"Object.deepFreeze: # {object} is not callable!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isObject(value) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> !Object.isFrozen value Object.deepFreeze(value) Object.freeze object object = property: internal: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.deepFreeze object Object.getOwnPropertyDescriptor(object.property, <span class="hljs-string"><span class="hljs-string">'internal'</span></span>).writable <span class="hljs-comment"><span class="hljs-comment"># false</span></span></code> </pre><br>  The implementation of <i>Object.freeze ()</i> according to the <a href="http://es5.github.com/">specification</a> : <br><br><pre> <code class="coffeescript hljs">Object.freeze = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If Type(O) is not Object throw a TypeError exception if Object::toString.call(object) is not '[object Object]' throw new TypeError "Object.freeze: # {object} is not callable!" # 2. For each named own property name P of O, Object.getOwnPropertyNames(object).forEach (property) -&gt; # a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P __desc__ = Object.getOwnPropertyDescriptor object, property # b. If IsDataDescriptor(desc) is true, then # If desc.[[Writable]] is true, set desc.[[Writable]] to false if __desc__.value and __desc__.writable is on __desc__.writable = off # c. If desc.[[Configurable]] is true, set desc.[[Configurable]] to false if __desc__.configurable is on __desc__.configurable = off # d. Call the [[DefineOwnProperty]] internal method of O with P, desc, and true as arguments Object.defineProperty object, property, __desc__ # 3. Set the [[Extensible]] internal property of O to false # 4. Return O. Object.preventExtensions object</span></span></code> </pre><br><br><h3> Object.isFrozen(object) </h3><br>    . <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> Object.isFrozen object <span class="hljs-comment"><span class="hljs-comment"># false Object.freeze object Object.isFrozen object # true</span></span></code> </pre><br>  <i>Object.isFrozen()</i>  <a href="http://es5.github.com/%2520"></a> : <br><br><pre> <code class="coffeescript hljs">Object.isFrozen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment"># 1. If Type(O) is not Object throw a TypeError exception. if Object::toString.call(object) is not '[object Object]' throw new TypeError "Object.isFrozen: # {object} is not callable!" # 2. For each named own property name P of O then Object.getOwnPropertyNames(object).forEach (property) -&gt; # a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. __desc__ = Object.getOwnPropertyDescriptor object, property # b. If IsDataDescriptor(desc) is true then # i. If desc.[[Writable]] is true, return false. if __desc__.value and __desc__.writable is on return off # c. If desc.[[Configurable]] is true, then return false. if __desc__.configurable is on return off # 3. If the [[Extensible]] internal property of O is false, then return true. # 4. Otherwise, return false. if !Object.isExtensible(object) then on else off</span></span></code> </pre><br><br><h3> Object.prototype.hasOwnProperty(property) </h3><br>      .   . <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> object.hasOwnProperty <span class="hljs-string"><span class="hljs-string">'property'</span></span> <span class="hljs-comment"><span class="hljs-comment"># true object.hasOwnProperty 'toString' # false</span></span></code> </pre><br>       ,   ,   ,    <i>of</i> ,    : <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">'property'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-comment"><span class="hljs-comment"># true 'toString' of object # true</span></span></code> </pre><br>  <i>.hasOwnProperty()</i>       <i>for-of</i> : <br><br><pre> <code class="coffeescript hljs">Object::inherited = <span class="hljs-number"><span class="hljs-number">0</span></span> object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object) <span class="hljs-comment"><span class="hljs-comment"># [inherited, property] for i of object i if object.hasOwnProperty i # property</span></span></code> </pre><br>  ,  <i>hasOwnProperty()</i>         . <br>   ,   ,           <i>hasOwnProperty</i> : <br><br><pre> <code class="coffeescript hljs">Object::inherited = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> object = own: <span class="hljs-number"><span class="hljs-number">1</span></span> hasOwnProperty: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> @ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> object.hasOwnProperty i <span class="hljs-comment"><span class="hljs-comment"># inherited, own, hasOwnProperty</span></span></code> </pre><br>         .    ? <br><br>      ,      <i>hasOwnProperty</i>  <i>Object.prototype</i>    : <br><br><pre> <code class="coffeescript hljs">Object::inherited = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> object = own: <span class="hljs-number"><span class="hljs-number">1</span></span> hasOwnProperty: <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> @ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Object::hasOwnProperty.call object, i <span class="hljs-comment"><span class="hljs-comment"># own, hasOwnProperty</span></span></code> </pre><br>     .hasOwnProperty   . -,     ,  -,    ,      . <br><br>    ,         ,       . <br>          .  And since  <i>hasOwnProperty()</i>  ,         : <br><br><pre> <code class="coffeescript hljs">Object.getOwnPropertyNames Object.prototype [ <span class="hljs-string"><span class="hljs-string">'toString'</span></span>, <span class="hljs-string"><span class="hljs-string">'toLocaleString'</span></span>, <span class="hljs-string"><span class="hljs-string">'hasOwnProperty'</span></span>, <span class="hljs-string"><span class="hljs-string">'valueOf'</span></span>, <span class="hljs-string"><span class="hljs-string">'constructor'</span></span>, <span class="hljs-string"><span class="hljs-string">'propertyIsEnumerable'</span></span>, <span class="hljs-string"><span class="hljs-string">'isPrototypeOf'</span></span>, ]</code> </pre><br>         .     <i>V8</i> , <i>Presto</i> , <i>Gecko</i>    : <br><br><pre> <code class="coffeescript hljs"> <span class="hljs-string"><span class="hljs-string">'__lookupGetter__'</span></span>, <span class="hljs-string"><span class="hljs-string">'__defineGetter__'</span></span>, <span class="hljs-string"><span class="hljs-string">'__defineSetter__'</span></span>, <span class="hljs-string"><span class="hljs-string">'__lookupSetter__'</span></span></code> </pre><br>  <i>Gecko</i>     <i>watch</i>  <i>unwatch</i> . <br><br> ,        ,                  : <br><br><pre> <code class="coffeescript hljs">object = {} own = Object::hasOwnProperty <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> own.call object, i</code> </pre><br>    <i>hasOwnProperty()</i>       <i>for-of</i> ,  <i>CoffeeScript</i>    <i>own</i> : <br><br><pre> <code class="coffeescript hljs">alert i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object</code> </pre><br>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, __hasProp = {}.hasOwnProperty; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!__hasProp.call(object, i)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; alert(i); }</code> </pre><br><blockquote>     <i>own</i>   <i>for-of</i>   : <i><a href="http://habrahabr.ru/post/140764/">CoffeeScript:    </a></i> . <br></blockquote><br>           <i>Object.keys()</i>  <i>Object.getOwnPropertyNames()</i> ,         <i>for-own-of</i> . <br><br><h3> Object.prototype.isPrototypeOf(object) </h3><br>        .   . <br><br><pre> <code class="coffeescript hljs">object = {} Object::isPrototypeOf object <span class="hljs-comment"><span class="hljs-comment"># true Object.isPrototypeOf object # false Function::isPrototypeOf Object # true Function::isPrototypeOf (new -&gt;).constructor # true fn = -&gt; instance = new fn fn::.isPrototypeOf instance # true</span></span></code> </pre><br><br><h3> Object.prototype.propertyIsEnumerable(object) </h3><br>      .   . <br><br><pre> <code class="coffeescript hljs">object = property: <span class="hljs-number"><span class="hljs-number">1</span></span> object.propertyIsEnumerable <span class="hljs-string"><span class="hljs-string">'property'</span></span> <span class="hljs-comment"><span class="hljs-comment"># true object.propertyIsEnumerable 'toString' # false object.propertyIsEnumerable 'prototype' # false object.propertyIsEnumerable 'constructor' # false list = [''] list.propertyIsEnumerable 0 # true list.propertyIsEnumerable 'length' # false</span></span></code> </pre><br><br><h3> : </h3><br>       <i>Object</i>      .       <i>ECMAScript 5</i>  ,      .        <i><a href="">githab</a></i> 'e  <a href=""></a> <br><br> E       <i>JavaScript</i> ,       <a href="http://kangax.github.com/es5-compat-table/"></a>  . </div><p>Source: <a href="https://habr.com/ru/post/146440/">https://habr.com/ru/post/146440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146432/index.html">Elementary OS Luna: when already?</a></li>
<li><a href="../146433/index.html">Facebook provides the ability to edit comments.</a></li>
<li><a href="../146434/index.html">A brief history of the project OpenCV</a></li>
<li><a href="../146436/index.html">Installing Linux on cheap ARM netbooks</a></li>
<li><a href="../146438/index.html">RIM plans to sell BlackBerry</a></li>
<li><a href="../146441/index.html">Some Rails Tricks</a></li>
<li><a href="../146442/index.html">Moose: OOP in Perl</a></li>
<li><a href="../146443/index.html">Danny Sullivan told how he tried to touch the Microsoft Surface</a></li>
<li><a href="../146444/index.html">Turing machine restored from compressed code</a></li>
<li><a href="../146445/index.html">Nokia 808 PureView smartphone review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>