<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing a PHP module in C ++. Part 1: Excursion into the world of Zend Engine 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear Harbocommunity! 

 Under the cat there is some information about writing extensions for PHP using C ++, which I obtained from various s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing a PHP module in C ++. Part 1: Excursion into the world of Zend Engine 2</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear Harbocommunity! <br><br>  Under the cat there is some information about writing extensions for PHP using C ++, which I obtained from various sources (mostly English-speaking) and picking the source code of Zend Engine 2 during the development of one module for my own needs.  Since its volume is large enough, then I tried to be brief. <br><br>  So, in this part: <br><ul><li>  <a href="https://habr.com/ru/post/144582/">Inner world of Zend Engine 2</a> </li><li>  <a href="https://habr.com/ru/post/144582/">ZE data type hierarchy and expansion module structure</a> </li></ul><br>  But we will not get to C ++ in this part ... =) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i><u>Little disclaimer: the</u> content of the article is not the truth in the first instance, it is not based on official documentation (is there any?) And is my subjective view on ZE 2. Nevertheless, in due time I would be happy to find something similar on the Runet in order to save time in the initial stages of development.</i> <i><br></i> <br><a name="habracut"></a><br><br><h4><a name="anch1"></a>  Inner world of Zend Engine 2 </h4><br><h5>  Basic data types </h5><br>  Zend Engine 2 is written in C. This has greatly influenced its internal ecosystem.  In the absence of a class-object paradigm within ZE 2, global variables, free functions, and similarities of user-defined data types ‚Äî structures ‚Äî sprang up.  For all occasions, there are combinations of simple and composite data types and procedures for processing them. <br><br>  The most common structure is <b>zval</b> (zend-value?).  The structure is a representation of the PHP variable on the opposite side from <i>userspace</i> (by userspace, hereinafter, we understand code written in PHP, which ZE does, and the reverse side of <i>userspace</i> is C code). <br>  PHP is a language with weak dynamic typing and automatic memory management, variables in this language can change their type during their life cycle and do not require explicit removal by the programmer after the need for them disappears (the garbage collector will take care of this independently).  For these whims, in part, you have to take the rap and zval.  Currently ( <a href="http://ru.php.net/releases/">PHP 5.3.3</a> ), this structure is defined as follows (zend.h): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Variable information */</span></span> zvalue_value value; <span class="hljs-comment"><span class="hljs-comment">/* value */</span></span> zend_uint refcount__gc; zend_uchar type; <span class="hljs-comment"><span class="hljs-comment">/* active type */</span></span> zend_uchar is_ref__gc; };</code> </pre> <br>  What do we see here?  Not surprisingly, the zend value (zval) is not directly the value of a variable.  The value of the variable is stored in the value field, the type of which is <b><a href="https://habr.com/ru/post/144582/">zvalue_value</a></b> (below).  The type of the value stored in value is determined by the type field and can be one of the following (zend.h): <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_NULL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_LONG 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_DOUBLE 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_BOOL 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_ARRAY 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_OBJECT 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_STRING 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_RESOURCE 7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_CONSTANT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_CONSTANT_ARRAY 9</span></span></code> </pre><br>  Yeah, here they are - the very 8 types of PHP data that people so often cannot enumerate during interviews!  Plus two separately standing values ‚Äã‚ÄãIS_CONSTANT and IS_CONSTANT_ARRAY. <br><br>  The structure also contains information on the number of references to this variable (refcount__gc) and a flag that determines whether this variable is a reference (is_ref__gc).  This information is needed to organize efficient work with memory inside the ZE.  For example, the following situation in userspace: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $foo = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 $bar = $foo; // 2</span></span></code> </pre><br>  will create a zval val object of type IS_LONG (all integers in userspace correspond to C long on the other side of userspace), setting its is_ref_gc to 0 and refcount_gc to 1 (first line) and registering the symbol ‚Äúfoo‚Äù (about this in the following series) in the current symbol table of the process (actually just an associative array of variable names and their values) with val as the value.  On the second line, a new instance of zval will not be created.  In the symbol table that has just been placed in the symbol table, the reference counter will be increased by 1, and the symbol ‚Äúbar‚Äù will be registered in the symbol table with the same val  ªom.  Due to this, the number of required memory allocations for creating new variables will be reduced. <br>  When the interpreter will meet the code: <br><br><pre> <code class="php hljs">... $bar = <span class="hljs-string"><span class="hljs-string">'42'</span></span>;</code> </pre><br>  it will extract the corresponding symbol ‚Äúbar‚Äù from the current symbol table of the zval process, and, first of all, check the number of references to this value.  If it is greater than 1 and zval is not a link (is_ref_gc == 0), the interpreter will create a copy of the current $ bar value, perform actions on it (in our case, equate to the string value '42') and place the ‚Äúbar‚Äù characters with new value.  In case, if refcoun_gc == 1 or is_ref_gc == 1, the actions will be performed directly on the value obtained from the symbol table.  Thus, in the following (rather artificial, but having the right to life) situation: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $foo = <span class="hljs-number"><span class="hljs-number">100500</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 $bar = $foo; //2 echo $bar; unset($bar); $foo = '42'; //3</span></span></code> </pre><br>  an interpreter will cost only one zval, but two characters corresponding to it.  This is possible, because on the line with comment 1 a zval val will be created with the number of links equal to 1. On the line with comment 2, a new character ‚Äúbar‚Äù will be registered with the value val, which will have 2 in the refcoun_gc, but on the line with comment 3, a new zval will not be created, since after calling unset ($ bar) the number of references to val will again be reduced to 1. <br>  As it is not difficult to guess, is_ref_gc becomes equal to 1, when constructs of the form $ b = &amp; $ a are encountered in userspace. <br>  The approach described above can be called ‚Äúseparation upon modification‚Äù (separate on write). <br><br>  Now look at the type <a name="zvalue_value_anch"></a>  zvalue_value (zend.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zvalue_value { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> lval; <span class="hljs-comment"><span class="hljs-comment">/* long value */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dval; <span class="hljs-comment"><span class="hljs-comment">/* double value */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *val; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; } str; HashTable *ht; <span class="hljs-comment"><span class="hljs-comment">/* hash table value */</span></span> zend_object_value obj; } zvalue_value;</code> </pre><br>  It is not difficult to notice that this is a <a href="http://en.wikipedia.org/wiki/Union_(computer_science)">union</a> .  This means that the data stored in the memory at the address of a variable of type zvalue_value can be interpreted by the programmer in a convenient way both at the design stage and at the execution stage as any of the data types included in the combination.  It is this feature of zvalue_value that allows PHP userspace variables to change their type so easily throughout their lives (recall that the current type of the zval variable can be found out by referring to its type field). <br>  However, you can say that you see here only 5 unique fields, and data types are 8. The mapping of PHP types to the zvalue_value union is as follows: <br><ul><li>  long lval - integer (integer), boolean type (boolean) and resources (resource) </li><li>  double dval - here is unique (double) </li><li>  struct ... str - PHP strings (string) </li><li>  HashTable * ht - arrays (array) </li><li>  zend_object_value obj - PHP objects (object) - both SPL, and user. </li><li>  null - the value has no value (zval.type == IS_NULL). </li></ul><br>  So what can be useful to take from consideration of the zvalue_value structure? <br><ol><li>  The resource type is represented only by an integer identifier, and therefore in userspace it looks like a dark horse.  On the other side of userspace, such an identifier can be associated with an open file descriptor, TCP socket, database connection object, etc.  The mapping takes place through a special resource repository (on the C side, of course). </li><li>  All real in PHP have double precision and occupy 8 bytes. </li><li>  Strings in principle can be binary safe, i.e.  use null characters inside.  Reached due to the fact that the length of the string is stored together with a pointer to the memory where this line is located.  The strlen operation is fast in userspace.  The null character at the end of the line is optional.  In fact, many extensions use exactly null-terminated strings and do not squeamish srishnoy strlen. </li><li>  Arrays are represented by the internal type HashTable.  HashTable is another structure, but its consideration and principles of working with it are beyond the scope of this article. </li><li>  Objects in PHP are represented by the <a href="https://habr.com/ru/post/144582/"><b>zend_object_value</b></a> structure.  We will talk about it further, since the development of our extension is connected with the creation of our own data type. </li><li>  Creating a variable in PHP will spend at least 16 bytes on a 32-bit architecture, no matter what type the variable is (add up the size of the zval fields, taking into account that the size of the union is equal to the size of the maximum field in its composition). </li></ol><br><br>  So we got to the objects.  The zend_object_value structure is intended to represent userspace variables containing objects.  And what is an object in a class-object paradigm?  An object is a symbiosis of data and methods for their processing.  Now let's look at the structure <a name="zend_object_value_arch"></a>  <b>zend_object_value</b> (zend_type.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zend_object_handle; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_handlers</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_handlers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_value</span></span></span><span class="hljs-class"> {</span></span> zend_object_handle handle; zend_object_handlers *handlers; } zend_object_value;</code> </pre><br>  The structure is the union of some integer identifier (handle) and another structure (zend_object_handlers * handlers), which contains pointers to functions that will be called by the ZE 2 engine upon the occurrence of certain events related to the object.  Such events include: equating a variable with a variable containing an object (zend_object_add_ref_t add_ref), going beyond the scope, initializing with another value or calling unset for a variable containing an object (zend_object_del_ref_t del_ref), cloning an object with a call to __clone (zend_object_t_ clone_obj), referring to the property of the object (zend_object_read_property_t read_property), writing the property of the object (zend_object_write_property_t write_property), etc.  The <b>zend_object_handlers</b> structure <b>itself</b> looks like this (zend_object_handlers.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object_handlers</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* general object functions */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">zend_object_add_ref_t</span></span> add_ref; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_del_ref_t</span></span> del_ref; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_clone_obj_t</span></span> clone_obj; <span class="hljs-comment"><span class="hljs-comment">/* individual object functions */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">zend_object_read_property_t</span></span> read_property; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_write_property_t</span></span> write_property; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_read_dimension_t</span></span> read_dimension; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_write_dimension_t</span></span> write_dimension; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_property_ptr_ptr_t</span></span> get_property_ptr_ptr; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_t</span></span> get; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_set_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_has_property_t</span></span> has_property; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_unset_property_t</span></span> unset_property; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_has_dimension_t</span></span> has_dimension; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_unset_dimension_t</span></span> unset_dimension; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_properties_t</span></span> get_properties; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_method_t</span></span> get_method; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_call_method_t</span></span> call_method; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_constructor_t</span></span> get_constructor; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_class_entry_t</span></span> get_class_entry; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_class_name_t</span></span> get_class_name; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_compare_t</span></span> compare_objects; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_cast_t</span></span> cast_object; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_count_elements_t</span></span> count_elements; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_debug_info_t</span></span> get_debug_info; <span class="hljs-keyword"><span class="hljs-keyword">zend_object_get_closure_t</span></span> get_closure; };</code> </pre><br>  and read about it in detail <a href="https://wiki.php.net/internals/engine/objects">here</a> . <br><br>  Distracted, back to zend_object_value.  So, what does it contain besides pointers to event handler functions?  And nothing!  If we saw some kind of attempt to determine the behavior of an object in _zend_object_handlers, then apart from some strange identifier (handle), no data specific to a particular instance is observed in it.  But the identifier itself (spherical in vacuum) has no meaning.  So there must be some kind of repository of homogeneous entities, where this identifier will distinguish one entity from another. <br>  Such storage in ZE is <b>Zend Object Storage</b> .  The keys to it are object descriptors (zend_object_value.handle), and the values ‚Äã‚Äã... Yes, yes, you probably already guessed - another type of structure is <b>zend_object</b> (zend.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_object</span></span></span><span class="hljs-class"> {</span></span> zend_class_entry *ce; HashTable *properties; HashTable *guards; <span class="hljs-comment"><span class="hljs-comment">/* protects from __get/__set ... recursion */</span></span> } zend_object;</code> </pre><br>  Here, an <s>oil</s> painting is already beginning to form from scattered pieces.  HashTable * properties - this is where you can keep data specific to a particular instance.  The properties field is a standard associative array for ZE, the keys of which should be the names of the fields of the class of the current object, and the values ‚Äã‚Äãthe current values ‚Äã‚Äãof the fields (properties) of this object. <br><br>  So, at the moment we have the following possibilities for working with objects - we can redefine the standard behavior of an object in certain situations (by redefining the corresponding functions in zend_object_handlers) and can store data in instance fields, writing them to HashTable * properties related to current object.  Something is missing ... Oh, yes, but how to add custom behavior to the object (create new methods)?  Since methods are something common for all objects of one class, it would be logical to place them in some structure, shared access to which would be for all objects of a class.  This structure is <b>zend_class_entry</b> (zend.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_class_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; zend_uint name_length; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_class_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parent</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> refcount; zend_bool constants_updated; zend_uint ce_flags; HashTable function_table; HashTable default_properties; HashTable properties_info; HashTable default_static_members; HashTable *static_members; HashTable constants_table; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_function_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">builtin_functions</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//  union _zend_function *constructor; //,    union _zend_function *destructor; //    union _zend_function *clone; union _zend_function *__get; union _zend_function *__set; union _zend_function *__unset; union _zend_function *__isset; union _zend_function *__call; union _zend_function *__callstatic; union _zend_function *__tostring; union _zend_function *serialize_func; union _zend_function *unserialize_func; zend_class_iterator_funcs iterator_funcs; /* handlers */ zend_object_value (*create_object)(zend_class_entry *class_type TSRMLS_DC); zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC); int (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type TSRMLS_DC); /* a class implements this interface */ union _zend_function *(*get_static_method)(zend_class_entry *ce, char* method, int method_len TSRMLS_DC); /* serializer callbacks */ int (*serialize)(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data TSRMLS_DC); int (*unserialize)(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC); zend_class_entry **interfaces; zend_uint num_interfaces; char *filename; zend_uint line_start; zend_uint line_end; char *doc_comment; zend_uint doc_comment_len; struct _zend_module_entry *module; };</span></span></code> </pre><br>  The purpose of the zend_class_entry structure is to represent the general aspects of all objects of the same class.  zend_class_entry is actually the class itself.  The structure, as you see, is not small and it is not the task of this article to consider the purpose of each of its fields.  Let's stop our attention in the fields that I have marked with comments. <br><br>  const struct <b>_zend_function_entry</b> * builtin_functions - pointer to an array of _zend_function_entry structures.  It is not difficult to guess that these are the methods of our future class.  Since it is marked with the const modifier, changing the elements of this array (ie, overriding methods of an instantiated class object) is not possible (unlike zend_object_value.handlers). <br><br>  Fields starting from the constructor by unserialize_func are <a href="http://www.php.net/manual/ru/language.oop5.magic.php">PHP</a> 's <a href="http://www.php.net/manual/ru/language.oop5.magic.php">magic methods</a> (it's not hard to guess that unserialize_func is __wakeup, and serialize_func is __sleep, the other methods have similar mnemonics). <br><br>  In the process of creating your own extension, you can either add entries to builtin_functions or override the magic methods of the future class. <br><br>  The last, but not the least, hero of this excursion into the fascinating world of ZE structures will be the structure that deals with the representation of the expansion module itself - <b>zend_module_entry</b> (zend_modules.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_module_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zend_api; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> zend_debug; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> zts; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_ini_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ini_entry</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_module_dep</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deps</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_function_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functions</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*module_startup_func)(INIT_FUNC_ARGS); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*request_startup_func)(INIT_FUNC_ARGS); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *version; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> globals_size; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ZTS ts_rsrc_id* globals_id_ptr; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> void* globals_ptr; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> void (*globals_ctor)(void *global TSRMLS_DC); void (*globals_dtor)(void *global TSRMLS_DC); int (*post_deactivate_func)(void); int module_started; unsigned char type; void *handle; int module_number; char *build_id; };</span></span></code> </pre><br>  Since, in the general case, an extension can implement not one, but several classes at once, or vice versa, export functions alone (the OOP has no wedges, as they say), consider how this affected the design of the above structure: <br><br><ol><li>  const struct _zend_function_entry * functions - a pointer to an array of functions exported by the extension.  Similar to zend_class_entry.builtin_functions. </li><li>  int (* module_startup_func) (INIT_FUNC_ARGS) - pointer to the function that will be called when the extension is connected.  In particular, if an extension exports classes, it is in this function that classes must be registered in the internal register of classes ZE 2. </li><li>  int (* module_shutdown_func) (SHUTDOWN_FUNC_ARGS) is a pointer to a function that is called when the extension is unloaded.  Here we have to wipe ourselves. </li></ol><br><br><h4><a name="anch2"></a>  Data type hierarchy </h4><br><br>  In the previous paragraph, we looked at the path from the ordinary zval to the general zend_module_entry.  Skillfully operating with these types, you can create your own PHP extension and organize a coherent factory for the production of objects.  In fact, the PHP plug-in is similar to the userpace training school.  First you need to build it (call PHP_MINIT_FUNCTION) and register it at the labor exchange (by declaring exported classes or functions in PHP_MINIT_FUNCTION) as a recruitment agency with a certain focus, and then, upon the first request for an employee (new instance of the class), start the fighter training cycle (creating object).  Preparation consists in allocating memory for the created object, associating it with specific event handlers (zend_object_handlers) and own class (zend_class_entry), which contains the methods of the future object, and registering the object with Zend Object Storage and then assigning it a unique identifier.  Such preparation is usually placed in the function extension_objects_new and is associated with the field zend_class_entry.create_object. <br><br>  Schematically, the structure of the extension can be represented as follows: <br><br><img src="http://habrastorage.org/storage2/a2e/d70/738/a2ed70738d9cdfc753a3a36bff6242f8.png"><br><br>  And in order to more clearly visualize the data type hierarchy in the extension, I‚Äôll give the following schema: <br><br><img src="http://habrastorage.org/storage2/630/b60/f9e/630b60f9e789f34fa2c7534503c36f49.png"><br><br><h4>  Conclusion </h4><br>  The article got a lot of text and very little code, but without an excursion into the world of data types ZE 2, trying to understand the purpose of the calls of certain functions would be quite difficult.  In the next part I will give an explanation of the first steps that need to be done to create your own PHP expansion module, but before that I‚Äôll touch on the topic of working with zvals and memory allocation management. <br><br>  <b>PS</b> An excellent selection of articles for those interested is <a href="https://wiki.php.net/internals/references">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/144582/">https://habr.com/ru/post/144582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144572/index.html">Leaked PS4 specs</a></li>
<li><a href="../144573/index.html">Large images on the site for users with Retina Display - retina.js</a></li>
<li><a href="../144574/index.html">Auto-update of stock deadline in Yandex.Direct</a></li>
<li><a href="../144575/index.html">BIOS update on Dell PowerEdge R510 server</a></li>
<li><a href="../144580/index.html">User identification by voice</a></li>
<li><a href="../144586/index.html">Happy Birthday, Habr!</a></li>
<li><a href="../144587/index.html">PocketLint: Opera intends to buy Facebook?</a></li>
<li><a href="../144588/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ7 (May 19 - 25, 2012)</a></li>
<li><a href="../144593/index.html">Demonstrated capabilities of the Camera Project Glass from Google</a></li>
<li><a href="../144594/index.html">Google reported on the fight against pirated links in the search results</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>