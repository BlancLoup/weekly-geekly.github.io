<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make a context switch on STM32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 Flows ... Context Switching ... Basic OS Essence. And of course, when developing libraries and applications, we always rely on the fact t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make a context switch on STM32</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/243/7a4/22c/2437a422ca614eaa8524f06617712576.png" align="right" width="320">  Good day! <br><br>  Flows ... Context Switching ... Basic OS Essence.  And of course, when developing libraries and applications, we always rely on the fact that the implementation of threads is infallible.  Therefore, it was unexpected to find a gross error in switching streams for STM32 to <a href="https://ru.wikipedia.org/wiki/Embox">Embox RTOS</a> , when the network, the file system and many third-party libraries were already working for a long time.  And we even managed to brag about our achievements on <a href="https://habrahabr.ru/company/embox/blog/259721/">Habr√©</a> . <br><br>  I would like to talk about how we did thread switching for the Cortex-M, and tested it on STM32.  In addition, I will try to talk about how this is done in other operating systems - NuttX and FreeRTOS. <br><a name="habracut"></a><br>  Well, first a couple of words about how the problem was discovered.  At that moment I was collecting another craft - a robot with different sensors.  At some point I wanted to control two stepper motors, with each controlled from a separate stream (the streams are absolutely identical).  The result is that until one motor finishes the rotation, the second one does not even start. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I sat down to debug.  It turned out that all interrupts are simply disabled in threads!  You say, how could something work then?  Everything is simple - there are many places where there is <code>sleep()</code> , <code>mutex_lock()</code> and other ‚Äúwait‚Äù, and at the expense of them the threads naturally switched.  The problem was obviously related to context switching for the STM32F4, where I discovered it. <br><br>  Let's take a closer look at the problem.  Switching of contexts of streams occurs including by timer, that is, by interrupts.  Schematically, interrupt handling in Embox can be represented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pt_regs_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *regs)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq = get_irq_number(regs); { ipl_enable(); irq_dispatch(irq); ipl_disable(); } irqctrl_eoi(irq); ... critical_dispatch_pending(); }</code> </pre><br>  The whole point is that the <code>irq_dispatch</code> interrupt handler is first called, then the interrupt processing ‚Äúends‚Äù, and the context switches to another thread if the scheduler requires it inside <code>critical_dispatch_pending</code> .  And here it is very important that the state of the processor in this thread should be the same as before it was interrupted, including enabling or disabling interrupts.  For the resolution of interrupts, the bit in <code>xPSR</code> , which is placed on the stack by the processor itself at the time of entry into the interrupt, when it exits the interrupt it goes from the stack.  The problem is that since we have preemptive multitasking, we can, having entered into an interrupt on one thread, want to exit on a stack of another thread, in which of course there is no <code>xPSR</code> stored.  Moreover, like most OSs, we have synchronization primitives, for example, <code>pthread_mutex_lock()</code> , which can lead to context switching not from an interrupt.  In general, we began to doubt whether it is possible to organize preemptive multitasking on cortex-m, because this architecture is well optimized for small tasks.  But stop!  But how then do other operating systems work? <br><br><h3>  Interrupt handling on Cortex-M </h3><br>  Let's first understand how the interrupt handling on the Cortex-M is arranged. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2e2/c3c/650/2e2c3c6501a44b8d8e0da4f6df2c4d77.png"></div><br>  The picture shows stacks in two modes - with and without a floating point.  When an interrupt occurs, the processor saves the corresponding registers to the stack, and places one of the following values ‚Äã‚Äãin the table below into the <code>LR</code> register.  That is, if the interrupt is nested, then there will be 0xFFFFFFF1. <br><br><img src="https://habrastorage.org/web/e8d/580/345/e8d58034579b475fb1222163b04d6d4a.png"><br><br>  Next, the OS interrupt handler is called, at the end of which the ‚Äúbx lr‚Äù is usually executed (recall that the LR contains 0xFFFFFFXX).  After this, the automatically saved registers are restored, and the execution of the program continues. <br><br>  Now let's look at how context switching takes place in different operating systems. <br><br><h3>  FreeRTOS </h3><br>  Let's start with <a href="https://ru.wikipedia.org/wiki/FreeRTOS">FreeRTOS</a> .  To do this, look at the <code>portable/GCC/ARM_CM4F/port.c</code>  Below is the function code <code>xPortSysTickHandler</code> : <br><br><div class="spoiler">  <b class="spoiler_title">xPortSysTickHandler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xPortSysTickHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* The SysTick runs at the lowest interrupt priority, so when this interrupt executes all interrupts must be unmasked. There is therefore no need to save and then restore the interrupt mask value as its value is already known. */</span></span> portDISABLE_INTERRUPTS(); { <span class="hljs-comment"><span class="hljs-comment">/* Increment the RTOS tick. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( xTaskIncrementTick() != pdFALSE ) { <span class="hljs-comment"><span class="hljs-comment">/* A context switch is required. Context switching is performed in the PendSV interrupt. Pend the PendSV interrupt. */</span></span> portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; } } portENABLE_INTERRUPTS(); }</code> </pre><br></div></div><br>  This is a hardware timer handler.  Here we see that if you need to do a context switch, then some PendSV interrupt is triggered.  As the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0553a/BABBGBEC.htm">documentation</a> says - ‚ÄúPendSV is an interrupt-driven request for system-level service.  For example, the situation is active. ‚ÄùInside the <code>xPortPendSVHandler</code> interrupt handler, the context switches: <br><br><div class="spoiler">  <b class="spoiler_title">xPortPendSVHandler</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xPortPendSVHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* This is a naked function. */</span></span> __<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" mrs r0, psp \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" isb \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldr r3, pxCurrentTCBConst \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Get the location of the current TCB. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldr r2, [r3] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" tst r14, #0x10 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Is the task using the FPU context? If so, push high vfp registers. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" it eq \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" vstmdbeq r0!, {s16-s31} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" stmdb r0!, {r4-r11, r14} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Save the core registers. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" str r0, [r2] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Save the new top of stack into the first member of the TCB. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" stmdb sp!, {r3} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" mov r0, %0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" msr basepri, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" dsb \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" isb \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" bl vTaskSwitchContext \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" mov r0, #0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" msr basepri, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldmia sp!, {r3} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldr r1, [r3] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldr r0, [r1] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldmia r0!, {r4-r11, r14} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Pop the core registers. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" tst r14, #0x10 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Is the task using the FPU context? If so, pop the high vfp registers too. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" it eq \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" vstmdbeq r0!, {s16-s31} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" stmdb r0!, {r4-r11, r14} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Save the core registers. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" str r0, [r2] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Save the new top of stack into the first member of the TCB. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" stmdb sp!, {r3} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" mov r0, %0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" msr basepri, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" dsb \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" isb \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" bl vTaskSwitchContext \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" mov r0, #0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" msr basepri, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldmia sp!, {r3} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldr r1, [r3] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldr r0, [r1] \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" ldmia r0!, {r4-r11, r14} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Pop the core registers. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" tst r14, #0x10 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Is the task using the FPU context? If so, pop the high vfp registers too. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" it eq \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" vldmiaeq r0!, {s16-s31} \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" msr psp, r0 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" isb \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> #ifdef WORKAROUND_PMU_CM001 </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* XMC4000 specific errata workaround. */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> #</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span></span><span class="hljs-function"><span class="hljs-params"> WORKAROUND_PMU_CM001 == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" push { r14 } \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" pop { pc } \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> #endif #endif </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" bx r14 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" .align 4 \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pxCurrentTCBConst: .word pxCurrentTCB \n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ::</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(configMAX_SYSCALL_INTERRUPT_PRIORITY) )</span></span></span></span>; }</code> </pre><br></div></div><br>  But now let's imagine that we are switching to a new thread that will execute, say, a certain function <code>fn</code> .  That is, if we simply put the address of the <code>fn</code> function in the <code>PC</code> , we will immediately get to the right place, but with the wrong context - we did not leave the interruption!  FreeRTOS offers the following solution.  Let's initially initialize the thread being created as if we were going out of the interrupt - <code>/* Simulate the stack frame as it would be created by a context switch interrupt. */</code>  <code>/* Simulate the stack frame as it would be created by a context switch interrupt. */</code> .  In this case, we will first ‚Äú <code>xPortPendSVHandler</code> handler, that is, we will be in the right context, after which, following the prepared stack, we end up in <code>fn</code> .  Below is the code for this stream preparation: <br><br><div class="spoiler">  <b class="spoiler_title">pxPortInitialiseStack</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">StackType_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pxPortInitialiseStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StackType_t *pxTopOfStack, TaskFunction_t pxCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Simulate the stack frame as it would be created by a context switch interrupt. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts, and to ensure alignment. */</span></span> pxTopOfStack--; *pxTopOfStack = portINITIAL_XPSR; <span class="hljs-comment"><span class="hljs-comment">/* xPSR */</span></span> pxTopOfStack--; *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment"><span class="hljs-comment">/* PC */</span></span> pxTopOfStack--; *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; <span class="hljs-comment"><span class="hljs-comment">/* LR */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save code space by skipping register initialisation. */</span></span> pxTopOfStack -= <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* R12, R3, R2 and R1. */</span></span> *pxTopOfStack = ( StackType_t ) pvParameters; <span class="hljs-comment"><span class="hljs-comment">/* R0 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A save method is being used that requires each task to maintain its own exec return value. */</span></span> pxTopOfStack--; *pxTopOfStack = portINITIAL_EXEC_RETURN; pxTopOfStack -= <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pxTopOfStack; }</code> </pre><br></div></div><br>  So, this was one of the ways suggested by FreeRTOS. <br><br><h3>  Nuttx </h3><br>  Let's now look at another method suggested by <a href="https://en.wikipedia.org/wiki/NuttX">NuttX</a> .  This is another relative known OS for various small glands. <br><br>  The main part of the interrupt processing occurs inside the <code>up_doirq</code> function; this is essentially a second-level interrupt handler, called from the assembler code.  It is the decision whether to switch to another stream.  This function will return the necessary context of the new thread. <br><br><div class="spoiler">  <b class="spoiler_title">up_doirq</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *up_doirq(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *regs) { board_autoled_on(LED_INIRQ); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_SUPPRESS_INTERRUPTS PANIC(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> uint32_t *savestate; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Nested interrupts are not supported in this implementation. If you want * to implement nested interrupts, you would have to (1) change the way that * CURRENT_REGS is handled and (2) the design associated with * CONFIG_ARCH_INTERRUPTSTACK. The savestate variable will not work for * that purpose as implemented here because only the outermost nested * interrupt can result in a context switch. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Current regs non-zero indicates that we are processing an interrupt; * CURRENT_REGS is also used to manage interrupt level context switches. */</span></span></span><span class="hljs-meta"> savestate = (uint32_t *)CURRENT_REGS; CURRENT_REGS = regs; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Acknowledge the interrupt */</span></span></span><span class="hljs-meta"> up_ack_irq(irq); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Deliver the IRQ */</span></span></span><span class="hljs-meta"> irq_dispatch(irq, regs); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* If a context switch occurred while processing the interrupt then * CURRENT_REGS may have change value. If we return any value different * from the input regs, then the lower level will know that a context * switch occurred during interrupt processing. */</span></span></span><span class="hljs-meta"> regs = (uint32_t *)CURRENT_REGS; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Restore the previous value of CURRENT_REGS. NULL would indicate that * we are no longer in an interrupt handler. It will be non-NULL if we * are returning from a nested interrupt. */</span></span></span><span class="hljs-meta"> CURRENT_REGS = savestate; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> board_autoled_off(LED_INIRQ); return regs; }</span></span></code> </pre><br></div></div><br>  After returning from the function, we again find ourselves in the first level handler.  And if you need to switch to a new thread, then we modify the registers automatically saved on entry into the interrupt so that, when the interrupt processing is completed, it will fall into the necessary stream.  Below is a snippet of code. <br><br><pre> <code class="hljs pgsql"> bl up_doirq <span class="hljs-comment"><span class="hljs-comment">/* R0=IRQ, R1=register save (msp) */</span></span> mov r1, r4 <span class="hljs-comment"><span class="hljs-comment">/* Recover R1=main stack pointer */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* On return from up_doirq, R0 will hold a pointer to register context * array to use for the interrupt return. If that return value is the same * as current stack pointer, then things are relatively easy. */</span></span> cmp r0, r1 <span class="hljs-comment"><span class="hljs-comment">/* Context switch? */</span></span> beq l2 <span class="hljs-comment"><span class="hljs-comment">/* Branch if no context switch */</span></span> //   ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/* We are returning with a pending context switch. This case is different * because in this case, the register save structure does not lie in the * stack but, rather, within a TCB structure. We'll have to copy some * values to the stack. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r1, r0, #SW_XCPT_SIZE <span class="hljs-comment"><span class="hljs-comment">/* R1=Address of HW save area in reg array */</span></span> ldmia r1, {r4-r11} <span class="hljs-comment"><span class="hljs-comment">/* Fetch eight registers in HW save area */</span></span> ldr r1, [r0, #(<span class="hljs-number"><span class="hljs-number">4</span></span>*REG_SP)] <span class="hljs-comment"><span class="hljs-comment">/* R1=Value of SP before interrupt */</span></span> stmdb r1!, {r4-r11} <span class="hljs-comment"><span class="hljs-comment">/* Store eight registers in HW save area */</span></span> #ifdef CONFIG_BUILD_PROTECTED ldmia r0, {r2-r11,r14} <span class="hljs-comment"><span class="hljs-comment">/* Recover R4-R11, r14 + 2 temp values */</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ldmia r0, {r2-r11} <span class="hljs-comment"><span class="hljs-comment">/* Recover R4-R11 + 2 temp values */</span></span> #endif ‚Ä¶</code> </pre><br>  That is, in Nuttx (as opposed to FreeRTOS), the register values ‚Äã‚Äãautomatically saved on the stack are already modified.  This is perhaps the main difference.  In addition, you can see that they do well without PendSV (although ARM recommends :)).  And finally, the very switching of contexts in them is deferred, going through the interrupt stack, and not according to the principle - ‚Äúthey saved the old values ‚Äã‚Äãand immediately loaded them into new registers‚Äù. <br><br><h3>  Embox </h3><br>  Finally, how it is done in Embox.  The main idea is to add some additional function (let's call it <code>__irq_trampoline</code> ), in which the context switching is done ‚Äúin the usual mode‚Äù and not in the interrupt handling mode, and after that you really get out of the interrupt handler.  That is, in other words, we tried to fully preserve the logic described at the beginning of the article: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pt_regs_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *regs)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq = get_irq_number(regs); { ipl_enable(); irq_dispatch(irq); ipl_disable(); } irqctrl_eoi(irq); <span class="hljs-comment"><span class="hljs-comment">//      ,     ... }</span></span></code> </pre><br>  To begin with, I will give a picture that shows the whole picture.  And then I will explain in parts what is what. <br><br><img src="https://habrastorage.org/web/9d1/e6b/ca7/9d1e6bca7a294087bc9e4612f8750ed3.png"><br><br>  How it's done?  The idea is as follows.  The interrupt handler is first executed in the usual way, as on other platforms.  But when we exit the handler, we actually modify the stack and exit to a completely different place - at <code>__pending_handle</code> !  When this happens, it is as if the interrupt actually happened at the input of the <code>__pending_handle</code> function.  Below is the code that modifies the stack to go into <code>__pending_handle</code> .  I tried to write comments to especially important places in Russian. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        struct cpu_saved_ctx { uint32_t r[5]; uint32_t lr; uint32_t pc; uint32_t psr; }; void interrupt_handle(struct context *regs) { uint32_t source; struct irq_saved_state state; struct cpu_saved_ctx *ctx; ... //    ,  state.sp = regs-&gt;sp; state.lr = regs-&gt;lr; assert(!interrupted_from_fpu_mode(state.lr)); ctx = (struct cpu_saved_ctx*) state.sp; memcpy(&amp;state.ctx, ctx, sizeof *ctx); //        /* It does not matter what value of psr is, just set up sime correct value. * This value is only used to go further, after return from interrupt_handle. * 0x01000000 is a default value of psr and (ctx-&gt;psr &amp; 0xFF) is irq number if any. */ ctx-&gt;psr = 0x01000000 | (ctx-&gt;psr &amp; 0xFF); ctx-&gt;r[0] = (uint32_t) &amp;state; // we want pass the state to __pending_handle() ctx-&gt;r[1] = (uint32_t) regs; // we want pass the registers to __pending_handle() ctx-&gt;lr = (uint32_t) __pending_handle; ctx-&gt;pc = ctx-&gt;lr; /* Now return from interrupt context into __pending_handle */ __irq_trampoline(state.sp, state.lr); }</span></span></code> </pre><br>  We also give the function code <code>__irq_trampoline</code> .  The comments to the function indicate a pro with SP, but in order not to overload the article I skip it.  The main thing is ‚Äúbx r1‚Äù at the end of the function.  I recall that in the register r1 is the second argument of the function <code>__irq_trampoline</code> .  If we look at the code above, we will see the call ‚Äú <code>__irq_trampoline(state.sp, state.lr)</code> ‚Äù, which means that the register r1 contains the value state.lr, which is equal to the value 0xFFFFFXX (see the first section) <br><br><div class="spoiler">  <b class="spoiler_title">__irq_trampoline</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">.<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> __irq_trampoline __irq_trampoline: cpsid i # r0 contains SP stored <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> interrupt <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> entry. So we keep <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> data # behind SP <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>, but interrupts are disabled <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-string"><span class="hljs-string">'cpsid i'</span></span> mov sp, r0 # <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> interrupt handling <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> usual mode bx r1</code> </pre><br></div></div><br>  In short, after exiting the <code>__irq_trampoline</code> function <code>__irq_trampoline</code> we unwind along the stack, exit the interrupt, and fall into <code>__pending_handle</code> .  In this function, we do all the remaining operations (such as the context switch).  In this case, when exiting this function, we need to return to the stack the initially saved values ‚Äã‚Äãof the registers, after which we enter the interrupt again and exit it, but in the original place!  For this is done the next thing.  We first prepare the stack, then initiate the PendSV interrupt, and then find <code>__pendsv_handle</code> in the <code>__pendsv_handle</code> handler.  And then in the usual way we honestly exit the handler, but already in the original old stack.  The function code <code>__pending_handle</code> and <code>__pendsv_handle</code> shown below: <br><br><div class="spoiler">  <b class="spoiler_title">__pending_handle and __pendsv_handle</b> <div class="spoiler_text"><pre> <code class="hljs ruby">.global __pending_handle <span class="hljs-symbol"><span class="hljs-symbol">__pending_handle:</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/     ‚Äú‚Äù ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -,       . # Push initial saved context (state.ctx) on top of the stack add r0, #32 ldmdb r0, {r4 - r11} push {r4 - r11} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    .      , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      , . ... cpsie i /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   bl critical_dispatch_pending cpsid i # Generate PendSV interrupt /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    PendSV,    bl nvic_set_pendsv cpsie i # DO NOT RETURN 1: b 1 .global __pendsv_handle __pendsv_handle: # 32 == sizeof (struct cpu_saved_ctx) add sp, #32 # Return to the place we were interrupted at, # ie before interrupt_handle_enter bx r14</span></span></code> </pre><br></div></div><br>  In conclusion, I will say a couple of phrases about the reviewed versions of the context_switch implementation.  Each of the considered methods is working, has its advantages and disadvantages.  The FreeRTOS variant is not very suitable for us, since this OS is primarily aimed at microcontrollers, which entails a certain ‚Äúhard work‚Äù context_switch for a specific chip.  And we are trying to offer in our OS even for microcontrollers to use the principles of a ‚Äúbig‚Äù OS, with all the consequences ... Approximately the same approach is in NuttX, and maybe we can either implement a similar approach or improve ours using the idea of ‚Äã‚Äãmodifying the stack.  But at the moment our version copes with its tasks, which can be seen if you take the code from the <a href="https://github.com/embox/embox/">repository</a> . </div><p>Source: <a href="https://habr.com/ru/post/330236/">https://habr.com/ru/post/330236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330224/index.html">‚ÄúThis is not about money and development‚Äù: 5 misconceptions about the work of the community manager</a></li>
<li><a href="../330226/index.html">Global DevOps Bootcamp + video compilation</a></li>
<li><a href="../330228/index.html">What are interactive systems, or something about elise</a></li>
<li><a href="../330230/index.html">Another ex-employee sued Forbes 4 million rubles for unlawful dismissal</a></li>
<li><a href="../330232/index.html">How to deploy customer support in 5 minutes</a></li>
<li><a href="../330240/index.html">Methods of working with "heavy" XML</a></li>
<li><a href="../330244/index.html">The fee for publishing the game via Steam Direct is set at $ 100</a></li>
<li><a href="../330248/index.html">Welcome</a></li>
<li><a href="../330250/index.html">IBM Watson and Cybersecurity: A Rapid Response Service That Works Round the Clock</a></li>
<li><a href="../330252/index.html">Must-Have 3: Game Interfaces and Assets for Designer and Artist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>