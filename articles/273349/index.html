<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the complexity of growing sakura: how I participated in Ludum Dare 34</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 This post will discuss my participation in the Ludum Dare 34 competition, which was about three weeks ago. 

 The result was a puzzle cal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the complexity of growing sakura: how I participated in Ludum Dare 34</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  This post will discuss my participation in the Ludum Dare 34 competition, which was about three weeks ago. <br><br>  The result was a puzzle called Growing Sakura, the gameplay of which can be seen on the gif (do not worry, it weighs only 300Kb): <br><div style="text-align:center;"><img src="https://habrastorage.org/files/47b/489/8f9/47b4898f9d9c46b5a46e5f1bf2557ded.gif"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Briefly about the rules of the game: initially we have a hexagonal field and several root buds (or one, as in the gif above).  From it you can make 3 branches (in two ways - by clicking the left or right mouse button).  From each bud on a branch, you can make a Y-fork for the left click of the mouse, and just continue the branch further (I-fork) for the right one.  If a branch cannot grow in any direction (the corresponding cell is busy or there is no cell in the desired direction), then the branch does not grow.  In accordance with the last condition, it is necessary to choose the order of "unfolding" the branches.  The result will be a tree (or several trees) such that there are no sharp corners between two adjacent branches.  The goal of the game is to cover all the cells of the playing field. <br><br>  Without looking under the cut try to think about 10 seconds and estimate how difficult this game can be. <br><a name="habracut"></a><br><h1>  What is Ludum Dare? </h1><br>  This competition is held once every 4 months and this time it was already the 34th event in a row.  The essence of the competition (in the Compo nomination): it takes 48 hours to create a computer game on a given topic.  The theme becomes known in the first minutes of the competition.  The game should be created solo and from scratch (everything from scratch: code, graphics, sounds, etc.), however, third-party programs and code developments are allowed, but they must be announced in advance (say, in my blog on Ludum Dare website). I will use Paint, Unity, C ++ and Delphi, here‚Äôs a link to the start project template ‚Äù).  There is also a simplified relaxing nomination Jam, where you can play a game with the team for as much as 72 hours, use old practices and even (oh, horror!) You do not need to publish the source code at the end with the game.  However, for me personally, the nomination Jam is not interesting, I sometimes go into it only if I do not have time to meet the 48 hours. <br><br>  The topic of the competition is determined by voting, and this time the largest number of votes were cast at once by two topics: ‚ÄúGrowing‚Äù and ‚ÄúTwo Button Controls‚Äù.  You could use either of these topics, or both.  Interpretation of the topic is left to the discretion of the participant: for example, the first topic could be interpreted as ‚ÄúGrowth‚Äù, ‚ÄúGrowing Up‚Äù or ‚ÄúGrowing Up‚Äù, and the second one - ‚ÄúControl of two buttons‚Äù or ‚ÄúPower of two buttons‚Äù.  As can be seen from the description of the game above, I have in a sense connected the two topics together. <br><br><h1>  The first day </h1><br>  When I woke up, the contest was already going on for a couple of hours.  The topic of obvious solutions is not offered.  Slowly having breakfast and pouring coffee, I thought about something that would fit the interesting under this topic.  Of course, I wanted to combine both topics together.  Several concepts have surfaced: <br><ul><li>  A puzzle that emulates a window manager: there are a lot of windows on the screen (with two buttons each!), They all need to be closed, but everything is complicated by the fact that both available buttons sometimes perform very tricky actions (say, close the window to the right of this).  As a joke, there was an idea to make windows with the title ‚ÄúAgreement‚Äù filled with text like ‚ÄúBla-bla-bla-bla‚Äù with two buttons ‚ÄúAgree‚Äù and ‚ÄúDisagree‚Äù, which simply close this window. </li><li>  Strategy-bagel: the development of an underground base.  The base consists of square tiles, with each of which you can do one of two actions, thus expanding (growing!) The base. </li><li>  Some strange mechanism, consisting of a heap of units, on each unit there are two buttons "On" and "Off". </li><li>  Again a strategy, this time a minimalistic clone of Settlers II.  Hexagonal tiles, again, you can do one of two actions (more roads or build a house).  The idea was that in order to build steeper buildings, several roads had to be led to the tile.  But experiments on a piece of paper showed that the roads somehow ended quickly, which stopped the growth of the settlement. </li></ul><br>  All these concepts were either boring or too difficult to implement (and before this contest I had a month of hard labor for work and study, so I didn‚Äôt want to strain myself).  There was also an idea to make a clone of Super Hexagon (there are two buttons on it!), But I scored on this idea, because there was no ‚ÄúGrowing‚Äù.  By the middle of the day, the following concept emerged, which was obtained by simplifying the idea of ‚Äã‚Äãthe settlers: <br><ul><li>  There is a hexagonal field, in some cells - stones, in some - beans.  And we have to grow the roots of some plants from beans.  The roots are grown according to the rules that were described at the very beginning of this post.  For each bean, it is known how many cells the root system has to cover in order for the bean tree to grow large and healthy.  Well, the player's task is to grow the roots so that all the beans grow. </li></ul><br><br>  The rules of the game arose from the following mathematical problem: <br><br><div class="spoiler">  <b class="spoiler_title">Math problem</b> <div class="spoiler_text">  The plane is tiled with equal regular triangles (or, in other words, a <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B5%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25B0%25D1%2580%25D0%25BA%25D0%25B5%25D1%2582">triangular parquet is</a> given).  The points where the vertices of the triangles meet are called nodes, 6 edges emanate from each node.  Some edges are colored red, and between any two adjacent red edges on the top is either 120 degrees or 180 (there are no sharp corners).  Prove that there are two nodes such that one of them cannot get into the other, moving along the red edges. </div></div><br><br>  So, I just assumed that by following such rules you can make some rather complicated puzzle. <br><br>  Quickly sketched a prototype of game mechanics: <br><img src="https://habrastorage.org/files/906/3b3/6f7/9063b36f7ca240d3a52c9a9df243423d.gif"><br>  And he saw that it was good! <br><br>  At the end of the first day, the idea of ‚Äã‚Äãgrowing roots was transformed into the idea of ‚Äã‚Äãgrowing branches of sakura (but in the game code all objects are still named according to the roots!).  To simplify the game, all the numbers were thrown out and the goal was reduced to the simplest form: simply cover the entire playing field.  The prototype of the game has grown to the following: <br><img src="https://habrastorage.org/files/c43/da2/bf5/c43da2bf5b3a49bfa5fced396693e861.gif"><br>  There was an idea to make the branches of the tree become thicker in accordance with the distance to the farthest leaf (and this can be seen on the gif).  However, for long branches, the stretching became so large that their appearance deteriorated.  I spent quite a lot of time on making everything beautiful.  In the end, he scored - many more things had to be done.  From now on, all branches remained the same thickness. <br><br>  At this point I decided to finish the first day and went to bed. <br><br><h1>  Second day </h1><br>  As usual, in the dream after the first day I decided not to save, and instead not to sleep the second night.  In the morning I was sitting inventing levels.  He even sketched a hexagonal grid in the Word and unpacked it, waving further with a pencil and an eraser.  It became clear that without an automatic solver it would be difficult to continue. <br><br>  No sooner said than done.  Sketched a simple puzzle solver in C ++.  He recursively sorts through all the possible actions of the player and looks at whether the puzzle is solved or not.  At each iteration of iteration, the current state of the game is stored in std :: set.  If later there is the same state of the game - then the search is rolled back.  Thus, the solver does not consider the same scenarios of events a hundred times. <br><br>  It turned out that the puzzle mentioned above on two gifs (let's call it puzzle A) has already 47 different solutions.  It took 93 seconds to complete a search, at that 10810446 game states were examined.  This solver helped greatly in the future. <br><br>  An example of the work of a solver for another level: <br><br><img src="https://habrastorage.org/files/0ce/39e/606/0ce39e606ada4b1f8c55106cc2228362.png"><br><br>  This level was resolved in 7 seconds, 711211 states were saved in std :: set and exactly one solution was found.  The strange line at the very bottom is the level description, which is inserted into the game itself. <br><br>  A little later, the solver was optimized by the ‚Äúsingle cell‚Äù heuristic.  Namely: if at some step one of the free cells was surrounded by occupied cells ("walls" or cells into which the sakura branches had already sprouted), and it was impossible to put a branch into this cell from neighboring ones - then it became clear that there were no solutions and bust rolled back.  After adding this heuristic, puzzle A began to be processed in 5 seconds with the number of considered states only 723225. <br><br>  Until the end of the second day, I used to draw interesting game grids and solve them with my program.  In the meantime, I added a menu to the game (well, what else to do when the solver enumerates the solutions?), Redraw the icons.  The game began to look like this: <br><br><img src="https://habrastorage.org/files/f04/e36/eba/f04e36eba8cd406fa39425831d9fb8ee.gif"><br><br>  As you can see from the gif, I set myself a rather ambitious task: to develop as many as 40 puzzles.  By the time of the creation of the gifs, only 17 levels out of 40 were ready. By the end of the competition, the night remained, namely, about 10 hours. <br><br>  Some of the levels were generated as follows: some symmetrical figure was drawn, a root bud poked into its random cell.  After that, the solver was launched.  If the resulting solutions produced too much or none at all, the level was slightly modified (slightly change the shape or transplant the root sprout somewhere else) and the solver started again, and so on until the appropriate level was built. <br><br>  For other levels, the figure was intentionally asymmetric, usually there several branches of sakura converged into a common ‚Äúcom‚Äù, after which it was necessary to weave them carefully with each other.  These levels were also created using a solver. <br><br>  Next, I began to add levels that had several root buds.  The game immediately became much more diverse!  An example of a level with several buds: <br><img src="https://habrastorage.org/files/a7e/e89/d8d/a7ee89d8d1724dbaa0e477bb61747e5c.gif"><br>  Yes, sometimes for the passage of the level can not cover just one cell ... <br><br>  At night, I added a game screen to the game with the rules of the game, created a few sounds with the help of the wonderful program Bosca Ceoil and finally finished off all 40 levels (forty, Karl!) As planned.  The last levels are so complex that they are not completely amenable to my solver: he finds several solutions before him, how his memory ends, and he crashes.  Therefore, I do not know exactly how many solutions are there, although it can be said with confidence that all the puzzles in the game have a solution. <br><br>  The game was over at the last hour and with weak hands was withdrawn on the competition website. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5b4/799/e17/5b4799e17d914c059610d9668ee8222d.png"></div><br><br>  After the end of the competition, the organizers allocate 3 weeks to the vote.  Ludum Dare members download games from other members and rate them.  I also did this for about a week, and at the same time everyone thought how much the Growing Sakura game can be difficult.  As a result, everything resulted in the following: <br><br><h1>  Growing Sakura is NP-hard </h1><br>  Here I will try to present my evidence (I hope I did not screw it up anywhere in it!). <br><br>  In <a href="http://www.cs.umd.edu/~gasarch/BLOGPAPERS/PlanarHCnpc.pdf">this article,</a> you can find evidence that the problem of checking the existence of a Hamiltonian cycle in a planar cubic 3-connected graph is NP-complete (let's call its problem X for brevity).  Immediately decipher all incomprehensible words: <br><br>  <i>A graph</i> is a few points (they are called vertices), some pairs of which are connected by lines (they are called edges).  A graph is called <i>planar</i> if it can be positioned on a plane so that the edges do not intersect.  A graph is called <i>cubic</i> if exactly 3 edges emanate from each of its vertices.  A graph is called <i>3-connected</i> , if in order to annoy it at least into 2 parts, at least 3 edges must be removed.  <i>A Hamiltonian cycle</i> in a graph is a sequence of pairwise distinct vertices v <sub>1</sub> , v <sub>2</sub> , ..., v <sub>n</sub> such that v <sub>i</sub> and v <sub>i + 1</sub> are connected by an edge for any 1 &lt;= i &lt;n, and also by an edge are connected the vertices of v <sub>n</sub> and v <sub>1</sub> , where n is the number of vertices in the graph.  For example, the following picture shows a Hamiltonian cycle in a planar cubic 3-connected graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c71/7b3/724/c717b3724f2a49a3842610c4071eec9c.png"></div><br><br>  The definition of NP-difficulty and NP-completeness is not so simple.  But I will try to briefly clarify the case under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Argument about all NP</b> <div class="spoiler_text">  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B5%25D1%2588%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">The problem of solvability</a> ( <a href="https://en.wikipedia.org/wiki/Decision_problem">decision problem</a> ) is a question formulated within the framework of a formal system, to which you can answer "yes" or "no."  For example, the question ‚ÄúGiven x and y, is it true that x is divisible by y?‚Äù Is a solvability problem.  But the question ‚ÄúHow much is A + B?‚Äù Is not a solvability problem. <br><br><blockquote>  She: answer me, honestly, yes or no, ok? <br>  He: ask <br>  She: Why do men laugh at blondes? <br>  He: yes <br>  ( <a href="http://bash.im/quote/397136">bash about decision problem</a> ) </blockquote><br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581_NP">The NP class</a> is a set of such solvability problems for which the ‚Äúyes‚Äù answer can be checked in polynomial time with some additional information (the so-called <i>certificate</i> ).  Moreover, for any input parameters, if the answer is "yes", the certificate must necessarily exist (and not so that for some input data when the answer is "yes" it is, and for some it is not).  For example, for the solvability problem ‚ÄúThere is a graph G for n vertices, is it true that there is a Hamiltonian cycle in it?‚Äù The certificate is (for example!) The Hamiltonian cycle itself is a sequence of n numbers indicating in what order this Hamiltonian graph is bypassed.  So it lies in the class NP. <br><br>  Very similar to the NP class, the so-called <a href="https://en.wikipedia.org/wiki/Co-NP">co-NP class</a> ‚Äî a set of such solvability problems, for which the answer ‚Äúno‚Äù can be checked in polynomial time if there is additional information (the so-called <i>counter</i> - <i>example</i> ).  For example, for the solvability problem ‚ÄúHere is the number X, is it true that it is simple?‚Äù The counterexample is a divisor of the number X, different from 1 and X. So this problem lies in the class co-NP.  Again, for each ‚Äúno‚Äù, a counterexample is necessarily needed. <br><br>  There is also a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581_P">class P</a> - the set of all solvability problems that can be solved in polynomial time.  Note that formally in P exactly the solvability problems lie, i.e.  the question "How many will be A + B?" is not included!  (He enters a slightly different <a href="https://en.wikipedia.org/wiki/FP_%2528complexity%2529">FP class</a> ).  But problems of this kind can always be reformulated into a series of solvability problems by adding another parameter k: ‚ÄúIs it true that the k-th bit of the A + B expression is 1?‚Äù.  Having made a series of such queries, we, in fact, <i>polynomially reduce, according to Cook, the</i> question ‚ÄúHow many are A + B?‚Äù To the solvability problem.  But more about that below. <br><br>  Any task from class P lies in class NP, since the answer ‚Äúyes‚Äù can be checked in polynomial time using any certificate in general (for example, the certificate ‚Äú <i>I swear by my mother!</i> ‚Äù).  The verification algorithm is as follows: throw out the certificate and just find the answer to the original question from scratch in polynomial time.  For the same reason, any problem from the class P also lies in the class co-NP. <br><br>  Once again about the intricacies of belonging to classes.  The question ‚ÄúIs it true that the number X is simple?‚Äù Belongs to co-NP, and the question ‚ÄúIs it true that the number X is composite?‚Äù Belongs to NP.  According to <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2581%25D1%2582_%25D0%2590%25D0%25B3%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B0%25D0%25BB%25D0%25B0_%25E2%2580%2594_%25D0%259A%25D0%25B0%25D1%258F%25D0%25BB%25D0%25B0_%25E2%2580%2594_%25D0%25A1%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B5%25D0%25BD%25D1%258B">the three Hindus algorithm</a> , both of these questions can be answered in polynomial time.  So both of these questions, among other things, belong to the class P!  However, these two questions have little in common with the following very similar <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D1%2586%25D0%25B5%25D0%25BB%25D1%258B%25D1%2585_%25D1%2587%25D0%25B8%25D1%2581%25D0%25B5%25D0%25BB">question:</a> ‚ÄúWhat is the smallest divisor of X, greater than 1?‚Äù (Which is not included in either NP or co-NP, and no one can answer for polynomial time for it (and <a href="https://ru.wikipedia.org/wiki/RSA">RSA encryption</a> is good!)).  Those.  Look, the question ‚ÄúIs it true that X is composite?‚Äù lies in NP, because for the answer ‚Äúyes‚Äù there is a certificate - a divisor X between 1 and X, which allows you to check in polynomial time that the answer is really ‚Äúyes‚Äù.  But, thanks to the algorithm of the three Indians, the " <i>Mom swear!</i> " Is also a suitable certificate, i.e.  the algorithm that solves the problem should not provide the certificate that indicates that the task belongs to the class NP! <br><br>  By the way, there are solvability problems that do not belong to either P or NP or co-NP.  For example, the classic <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">problem of stopping</a> : ‚ÄúThe program code is given, is it true that it will be executed in a finite time?‚Äù.  But that's another story ... <br><br>  Now for polynomial reducibility.  There are several schemes for reducing problems to each other. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%259A%25D0%25B0%25D1%2580%25D0%25BF%25D1%2583">According to Karp</a> , problem U is considered polynomially reducible to problem V, if for any input data u for task U we can convert them into polynomial time into input data v for task V, feed them to V, and get an answer (which is "yes" or " no ", remember?), which will be the answer to the original task of U. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%259A%25D1%2583%25D0%25BA%25D1%2583">According to Cook</a> , problem U is considered polynomially reducible to problem V if there exists an algorithm polynomial in time that solves problem U, while using problem V as an <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D1%2581_%25D0%25BE%25D1%2580%25D0%25B0%25D0%25BA%25D1%2583%25D0%25BB%25D0%25BE%25D0%25BC">oracle</a> , i.e.  the algorithm can build as many (but a polynomial number!) sets of input data for task V and find out the answer for one iteration. <br><br>  Both of these data show that, in a sense, task U is no more complicated than task V. That is,  if we are able to solve V in a certain sense quickly, then we can also solve U in a certain sense quickly.  And if we are not able to solve U in a certain sense quickly, then we cannot solve quickly in a certain sense either.  Thus, the above-mentioned question ‚ÄúHow much is A + B?‚Äù Is not more difficult than the question ‚ÄúIs it true that the k-th bit of A + B expression is 1?‚Äù, And since the second one is in P, the first question is <i>easy</i> to answer ( in polynomial time!), although it does not lie in P. <br><br>  In essence, Karp information is a special case of Cook information, i.e.  in the case of information on Karp, the oracle is called only once at the very end and his answer without any changes is considered to be the answer to the original problem.  Well and also, in the case of information on Cook, problems U and V do not necessarily have to be problems of solvability. <br><br>  A problem from the NP class is called <a href="https://ru.wikipedia.org/wiki/NP-%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0">NP-complete</a> if any problem from the NP class (that is, any!) Polynomially reduces to it.  <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25B2%25D1%258B%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_%25D0%25B1%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D1%258B%25D1%2585_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB">The task of satisfiability of Boolean formulas</a> (SAT) is the first problem for which NP-completeness was <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%259A%25D1%2583%25D0%25BA%25D0%25B0_%25E2%2580%2594_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B8%25D0%25BD%25D0%25B0">proved by</a> <i>explicitly</i> reducing <i>any</i> problem from the class NP to the SAT.  Those.  SAT is a kind of universal task, which, <i>being an oracle</i> , allows you to <i>quickly</i> solve any problem from the class NP.  Later it was discovered that a huge number of other tasks from the NP class are also NP-complete!  Usually, this is easily proved by polynomial mixing of some other NP-complete problem (as a rule, SAT, possibly through a chain of other tasks) to this one. <br><br>  A task is called NP-hard if any NP-complete problem reduces to it.  If this NP-hard problem also belongs to the class NP itself, then it is obviously an NP-complete problem.  An example of an NP-hard task that does not belong to the NP class is the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE%25D0%25B1_%25D1%2583%25D0%25BF%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B5_%25D0%25B2_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B5%25D1%2580%25D1%258B">problem of packing into containers</a> ‚ÄúWhat is the smallest number of containers you can pack all these items?‚Äù, Because the NP-complete <a href="https://en.wikipedia.org/wiki/Partition_problem">problem of sharing</a> ‚ÄúCan you divide all these items into two equal by the total weight of the heap? <br><br>  The biggest question in all this demagogy is this: is any NP-complete problem solved in polynomial time?  If so, then P = NP and any task from the NP class can be solved in polynomial time and this is very good for many applied combinatorial problems and very bad for some encryption algorithms. <br></div></div><br><br>  For formality, we formulate Problem X and the Growing Sakura game as a solvability problem. <br><br>  Problem X: ‚ÄúGiven a cubic planar 3-connected graph G, is it true that there exists a Hamiltonian cycle in it?‚Äù. <br><br>  Growing Sakura game: ‚ÄúThe level from the Growing Sakura game is given, is it true that he has a solution?‚Äù. <br><br>  Well, we will reduce the NP-complete task X to the game Growing Sakura.  Those.  according to the input data of problem X, we construct such a level for Growing Sakura that its solution will also give an answer for the initial problem X. In this way we will show that task X is no more difficult than the game Growing Sakura. <br><br>  For this we need the following constructions: <br><br><h3>  AND-gadget </h3><br>  Everything is simple here - a branch of sakura that comes from any of the three sides can grow further in both directions simultaneously. <br><img src="https://habrastorage.org/files/11c/4dd/8f0/11c4dd8f0aef4b399174353894a7ccc7.png"><img src="https://habrastorage.org/files/979/c47/a93/979c47a93fa04878aaf98dcadc9511d7.png"><br><br><h3>  OR-gadget </h3><br>  For a given element, a sakura branch should choose exactly one direction out of two (in fact, no more than one, but this action is meaningless).  The second direction will have to be covered later and on the other side. <br><img src="https://habrastorage.org/files/67e/db0/6fe/67edb06fea184da5900d5813669b17a4.png"><img src="https://habrastorage.org/files/817/7ac/de8/8177acde81ae4a0eb45f8d83827729b2.png"><br><br><h3>  ONE-WAY-gadget </h3><br>  This design is a kind of diode.  She skips the sakura branch in one direction only. <br><img src="https://habrastorage.org/files/d8b/5a9/ebb/d8b5a9ebbb7247cd84241beda4edc2e7.png"><img src="https://habrastorage.org/files/06b/14b/896/06b14b896ef74b209c72e272a2cfe2af.png"><br><br>  Those.  in this direction skips: <br><img src="https://habrastorage.org/files/a44/571/da6/a44571da6d084e9a828b8cc44dace545.png"><img src="https://habrastorage.org/files/ada/b22/456/adab22456160462ca03fd9d28bc3e3be.png"><br><br>  But this is not: <br><img src="https://habrastorage.org/files/742/21f/3c7/74221f3c773441898e2fae3fb0f270be.png"><br><br>  I was not able to come up with the same construction without additional root points, maybe you can? <br><br><h3>  LOCK-gadget </h3><br>  The most complex element, its construction took quite a lot of time. <br><img src="https://habrastorage.org/files/fc1/c2d/d2c/fc1c2dd2cca34aec94a6329cc27f457a.png"><img src="https://habrastorage.org/files/5ad/d72/86c/5add7286cb554fc6a2ef3ac7da1e6024.png"><br><br>  The essence of this element is as follows.  It has solutions only in the following configurations: <br>  but) <br><img src="https://habrastorage.org/files/320/38c/eab/32038ceab1fc4bd9b8eef6a8945f03b4.png"><img src="https://habrastorage.org/files/d00/5de/7a1/d005de7a1e564a38919c89c4a7f42b6e.png"><br><br>  b) <br><img src="https://habrastorage.org/files/732/fb2/a14/732fb2a145a84323967504b1af0c796d.png"><img src="https://habrastorage.org/files/0ff/98a/65f/0ff98a65fc4e4ee192c3407524a39b49.png"><br><br>  However, there are no solutions in the following configuration: <br><img src="https://habrastorage.org/files/351/e9d/3e4/351e9d3e4d46407b9aaae7db1f1fc777.png"><br><br>  Moreover, it is impossible even to cover any of the crosses without obtaining the situation of a ‚Äúsingle cell‚Äù. <br><br><h3>  Now connect all together! </h3><br>  From the OR-gadgets it is already possible to collect the first approximation to a planar cubic 3-connected graph.  But, the rules of the game require that the ribs, which are not included in the Hamiltonian cycle, also be covered.  And to ensure this, we need a more cumbersome design.  Here she is: <br><img src="https://habrastorage.org/files/807/b21/f97/807b21f97aab4cf3bfc931ac7af72f5e.png"><br>  This construction corresponds to one vertex in our cubic graph. <br><br>  Let's now look at how it works.  Without loss of generality, let the sakura branch come from the bottom left (in two ways at once).  Then the next part of the scheme will be covered: <br><img src="https://habrastorage.org/files/e83/739/0ba/e837390ba44946e6a3faeab014d20557.png"><br><br>  Now, depending on which of the two options we choose, we get the following developments: <br><img src="https://habrastorage.org/files/02e/c04/d95/02ec04d959804ccda63da7e931b1091c.png"><img src="https://habrastorage.org/files/0cf/9e7/d8c/0cf9e7d8c3a94d9bb2223dd73de43ee1.png"><br>  Note that in both cases we sent two sakura branches in one of the directions and exactly one of them in the other direction.  Those.  we painted one edge in the graph in one direction, but not in the other.  Now, when our Hamiltonian path reaches the top of the graph where we haven‚Äôt painted the edge now, another branch will come from there (marked below in green), which unlocks the LOCK gadget and covers everything that needs to be covered: <br><img src="https://habrastorage.org/files/1c6/d4b/3c0/1c6d4b3c07ae437b94989bc4ce52c225.png"><img src="https://habrastorage.org/files/bad/965/30e/bad96530effa42b5a90e642c74254f77.png"><br><br>  Cases when we came to the summit, for which one or two adjacent peaks have already been visited by our way, are invited to analyze the reader independently. <br><br>  Well, now just for the entire planar cubic 3-connected graph, we will build a huge level, check if it has a solution.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is - then it is easy to restore the cycle for the original graph - just look at how the branch of sakura grows in OR-gadgets (although, formally, it is not required to restore it explicitly). It is always possible to build such a level - all gadgets can be rotated and connected by a chain of cells of sufficient length. Since initially the graph is planar, there is no need to solve the problem of crossing paths. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would seem that all proved? No, not proven. At the constructed level, there will be no solution at all - we have not initiated the process of "chain reaction" - the Hamiltonian path has no place to start. This is solved very simply. We take any edge (or rather, the corresponding LOCK gadget) and do this: The </font></font><br><img src="https://habrastorage.org/files/780/ae1/397/780ae139725745baa7fa992529ffaa61.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">red circle is where we begin to grow our branch. And we definitely need to cover the terminating end so that the Hamiltonian cycle closes!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now proved? No! Suddenly, in the graph there is a Hamiltonian cycle that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass along the edge from which we began to look for it!</font></font> What to do?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is necessary to try to search for a cycle starting from another edge. </font><font style="vertical-align: inherit;">Obviously, for any two edges emerging from one vertex, at least one of them will pass the desired Hamiltonian path, if it exists. </font><font style="vertical-align: inherit;">Therefore, to solve problem X, no more than two levels of Growing Sakura will be needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúAllow me!‚Äù - you will say, ‚Äúit was written a little higher that we will solve only one level of the Growing Sakura game, equivalent to the column in Problem X!‚Äù That's right, I deceived you brazenly! </font><font style="vertical-align: inherit;">However, the proof of this does not spoil - I just used the </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%259A%25D1%2583%25D0%25BA%25D1%2583"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuk data</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and not </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%259A%25D0%25B0%25D1%2580%25D0%25BF%25D1%2583"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karp data</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the NP-difficulty of Growing Sakura is proven!</font></font> Cheers, comrades! <br><img src="https://habrastorage.org/files/ce2/8a3/c5b/ce28a3c5b70141368ad2ffc49976523a.jpg"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Growing Sakura NP-complete </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As is known, an NP-complete problem, if it is NP-hard and lies in the class NP. The first point we proved a little higher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The affiliation of this problem to the NP is quite obvious. Recall that a task belongs to the NP class, if the solution to this problem is one of the ‚Äúyes‚Äù or ‚Äúno‚Äù answers, and there is a certificate for the ‚Äúyes‚Äù answer, which allows you to verify that the answer is indeed ‚Äúyes‚Äù in polynomial time. Well, indeed, for the Growing Sakura game, the certificate can be written as a string of length O (n), saving in what order and button we clicked on the corresponding cells, where n is the number of cells in the field. Well, for O (n), you can verify that the certificate is ‚Äúvalid‚Äù by simply expanding branches according to the certificate and the rules of the game.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheers, Growing Sakura NP is full! If suddenly someone writes a solver for this game that works in polynomial time, you can pick up your </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B8_%25D1%2582%25D1%258B%25D1%2581%25D1%258F%25D1%2587%25D0%25B5%25D0%25BB%25D0%25B5%25D1%2582%25D0%25B8%25D1%258F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">million</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact that Growing Sakura is NP-complete does not mean that all levels in this game will be prohibitively difficult. </font><font style="vertical-align: inherit;">It simply means that such levels </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> created. </font><font style="vertical-align: inherit;">And the rest is already dependent on the design levels. </font><font style="vertical-align: inherit;">Many of the classic Nintendo games are </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">known</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to be NP-hard, and that doesn‚Äôt stop them from enjoying them. </font><font style="vertical-align: inherit;">Even such a kazualka like </font></font><a href="http://candycrush.isnphard.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candy Crush is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NP-hard </font><font style="vertical-align: inherit;">, not to mention </font></font><a href="http://arxiv.org/abs/cs/0210020"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://simon.bailey.at/random/kaye.minesweeper.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sapper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and other </font></font><a href="http://www.cs.ox.ac.uk/people/paul.goldberg/FCS/sudoku.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudoku</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voting on Ludum Dare will end tomorrow, in the update I will publish what place I managed to get. </font><font style="vertical-align: inherit;">I hope to enter the hundred best games. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links: </font></font><a href="http://ludumdare.com/compo/ludum-dare-34/%3Faction%3Dpreview%26uid%3D15853"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">game page on Ludum Dare</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dropbox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://ripatti.itch.io/growing-sakura"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itch.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br>  UPD.    ,   .    Compo   1232 . Growing Sakura   10  ( <a href="http://ludumdare.com/compo/ludum-dare-34/%3Faction%3Dtop"> </a> ).    : #4 Theme, #5 Innovation, #22 Fun. </div><p>Source: <a href="https://habr.com/ru/post/273349/">https://habr.com/ru/post/273349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273335/index.html">Lectures Technopark. Master class "20 mistakes in creating an IT-company"</a></li>
<li><a href="../273337/index.html">Detection of insider trading: Algorithms for identifying and patterns of illegal transactions</a></li>
<li><a href="../273339/index.html">Windows 10 Digest. November-December 2015</a></li>
<li><a href="../273341/index.html">How to choose a programming language?</a></li>
<li><a href="../273345/index.html">ScaleIO Testing Experience</a></li>
<li><a href="../273351/index.html">Recipe for systemd: forced restart of the service on the file flag</a></li>
<li><a href="../273353/index.html">How to draw graphs and charts in Atlassian Confluence</a></li>
<li><a href="../273357/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 25. Hostile Takeover</a></li>
<li><a href="../273359/index.html">Stop using jQuery, you can do better without it.</a></li>
<li><a href="../273363/index.html">Build XGBoost for Python under Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>