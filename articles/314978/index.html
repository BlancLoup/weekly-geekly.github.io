<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Jasmine vs. Mocha, Chai and Sinon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testing in JS is becoming an increasingly common practice. But where to start? There are many frameworks that provide an API for writing JS tests. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Jasmine vs. Mocha, Chai and Sinon</h1><div class="post__text post__text-html js-mediator-article">  Testing in JS is becoming an increasingly common practice.  But where to start?  There are many frameworks that provide an API for writing JS tests. <br><br>  This article is a brief overview of the differences between two popular JS testing frameworks: Jasmine 2 and Mocha.  We will also discuss the most common Chai and Sinon libraries that are often used in conjunction with Jasmine and Mocha. <br><br><h3>  <b>1.</b> API (application programming interface) </h3><br>  The APIs in Jasmine and Mocha are very similar.  They both support writing tests using the BDD (Behavior Driven Development) approach.  You may ask: ‚Äúwhat is BDD‚Äù?  In short, this is an approach to writing tests that provides the ability to describe the functionality in a spoken language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'calculator'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ describe(<span class="hljs-string"><span class="hljs-string">'add()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ it(<span class="hljs-string"><span class="hljs-string">'should add 2 numbers together'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// assertions here }); }); });</span></span></code> </pre> <br><a name="habracut"></a><br>  Assertions, or expectations, as they are often called, differ in the frameworks presented.  Mocha does not have a built-in <i>assertion</i> library.  There are several options for use in the Node.js environment for browsers: Chai, should.js, expect.js, and better-assert.  Most developers choose Chai as the <i>assertion</i> library.  Since none of the <i>assertion</i> libraries are included with Mocha, you will need to plug it into your test environment.  In Chai, there are three types of <i>assertions</i> : <br><br>  1) should <br>  2) expect <br>  3) assert (approve) <br><br>  The type of <i>expect is</i> similar to <i>expect</i> which provides us with the Jasmine framework.  For example, if you want to write a check of the add method and your expectation that calculator.add (1, 4) will be 5, then this check will look similar to using both Jasmine and Chai. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Jasmine expect(calculator.add(1, 4)).toEqual(5);</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Chai expect(calculator.add(1, 4)).to.equal(5);</span></span></code> </pre><br>  Very similar, right?  If you move from Jasmine to Mocha, the path is pretty simple - use Chai with the type of <i>expect</i> . <br><br><h3>  <b>2.</b> Test Doubles (Understudies) </h3><br>  <i>Test Doubles</i> replace one object for another for test purposes.  In Jasmine, the role of <i>test doubles is</i> performed by <i>spies</i> (spies).  <i>Spy</i> is a function that replaces the original function, the logic of which we want to change and describes how this function will be used as part of the test. <br><br>  <i>Spies</i> allow: <br><br>  1) Find out the number of times the <i>spy</i> function was called <br>  2) Specify the return value in order for the code under test to continue to work according to the desired algorithm. <br>  3) Indicate that the <i>spy</i> function throws an error. <br>  4) Find out with which arguments the <i>spy</i> function was called. <br>  5) Indicate that the <i>spy</i> function calls the original function.  (Which she replaced) <br><br>  In Jasmine, creating a <i>spy</i> for an existing method is possible like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userSaveSpy = spyOn(User.prototype, <span class="hljs-string"><span class="hljs-string">'save'</span></span>);</code> </pre><br>  It is also possible to create a <i>spy</i> , even if you do not have a method that you want to replace. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spy = jasmine.createSpy();</code> </pre><br>  Mocha does not have a built-in <i>test doubles</i> library so you need to download and connect <i>Sinon</i> to your test environment.  <i>Sinon is a</i> very powerful <i>Test Doubles</i> library which provides equivalent <i>Jiesmine spies</i> functionality and a bit more.  It is worth noting that <i>Sinon</i> breaks <i>test doubles</i> into three different categories: <i>spies</i> , <i>stubs</i> and <i>mocks</i> , between which there are subtle differences. <br><br>  <i>The spy</i> function in <i>Simon</i> is invoked using the original method, while in Jasmine this behavior must be specified.  For example: <br><br><pre> <code class="javascript hljs">spyOn(user, <span class="hljs-string"><span class="hljs-string">'isValid'</span></span>).andCallThrough() <span class="hljs-comment"><span class="hljs-comment">// Jasmine // is equivalent to sinon.spy(user, 'isValid') // Sinon</span></span></code> </pre><br>  In this example, the original user.isValid will be called. <br><br>  The next type of <i>test doubles</i> is <i>stubs</i> which replaces the original method.  The <i>stubs</i> behavior is similar to the default <i>spies behavior</i> in Jasmine, in which the original method is not called. <br><br><pre> <code class="javascript hljs">sinon.stub(user, <span class="hljs-string"><span class="hljs-string">'isValid'</span></span>).returns(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Sinon // is equivalent to spyOn(user, 'isValid').andReturns(true) // Jasmine</span></span></code> </pre><br>  In this example, if the user.isValid method is called, the original user.isValid method will not be called, but its fake version will be called which should return the result ‚Äútrue‚Äù. <br><br>  From your experience, <i>spies</i> in Jasmine cover almost everything that is required for <i>test doubles</i> , so in most cases you will not need <i>Sinon</i> if you use Jasmine, however, if you want, you have the opportunity to use them together.  The main reason I use <i>Sinon</i> with Jasmine is its <i>fake server</i> . <br><br><h3>  <b>3.</b> Asynchronous tests (Asynchronous Tests) </h3><br>  Asynchronous testing in Jasmine 2.x and Mocha is implemented similarly. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should resolve with the User object'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dfd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $.Deferred(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise = dfd.promise(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stub = sinon.stub(User.prototype, <span class="hljs-string"><span class="hljs-string">'fetch'</span></span>).returns(promise); dfd.resolve({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'David'</span></span> }); User.get().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ expect(user <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> User).toBe(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); done(); }); });</code> </pre><br>  In this example, User is a constructor function that has a static get method.  The get method internally uses the fetch method which executes the XHR request.  I want to check that when the get method gets a value, this value will be an instance of User.  Since I used the ‚Äústub‚Äù for the User.prototype.fetch method and told it to return a predefined <i>promise</i> , the real XHR request is not executed.  Coverage of this code continues to be asynchronous. <br><br>  It is very simple to indicate that the <i>callback</i> function in the it construct is waiting for an argument (in this case done) and the <i>test runner</i> will wait until the function is executed before it finishes the test.  The test will be suspended and an error will be displayed if the argument is not called within a certain time.  This gives you complete control over when tests complete.  The test written above will work in both Jasmine and Mocha. <br><br>  If you work with Jasmine 1.3, asynchronous testing does not look so ‚Äúclean‚Äù. <br><br>  An example of asynchronous testing in Jasmine 1.3: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should resolve with the User object'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> david; runs(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dfd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $.Deferred(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise = dfd.promise(); dfd.resolve({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'David'</span></span> }); spyOn(User.prototype, <span class="hljs-string"><span class="hljs-string">'fetch'</span></span>).andReturn(promise); User.get().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; david = user; }); }); waitsFor(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; }, <span class="hljs-string"><span class="hljs-string">'get should resolve with the model'</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); runs(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ expect(david <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> User).toBe(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }); });</code> </pre><br>  In this example, the test will wait for a maximum of 500 milliseconds to complete an asynchronous operation; otherwise, the test will fail.  The waitsFor () function constantly checks the flag as soon as the flag becomes true, execution will continue and the next runs block will be called. <br><br><h3>  <b>4.</b> Sinon Fake Server </h3><br>  One feature that <i>Sinon</i> has in comparison with Jasmine is a <i>fake server</i> (fake server).  This allows you to set fake responses to certain AJAX requests. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should return a collection object containing all users'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = sinon.fakeServer.create(); server.respondWith(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"/users"</span></span>, [ <span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> }, <span class="hljs-string"><span class="hljs-string">'[{ "id": 1, "name": "Gwen" }, { "id": 2, "name": "John" }]'</span></span> ]); Users.all().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">collection</span></span></span><span class="hljs-function">) </span></span>{ expect(collection.toJSON()).to.eql([ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Gwen"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"John"</span></span> } ]); done(); }); server.respond(); server.restore(); });</code> </pre><br>  In this example, sending a GET request to / users, we get a response 200, containing data about two users - Gwen and John.  This can be very convenient for several reasons.  First, you can test the code that makes AJAX requests, no matter which AJAX library you use.  Second, you can test the function that makes the AJAX request and pre-processes the returned data before fulfilling the promise ( <i>resolve promise</i> ).  Thirdly, there is an opportunity to announce several answers to a successful request.  For example, in the following cases: successful withdrawal of funds from a credit card, outdated card, incorrect CVV code, etc.  different answers will come.  If you worked with AngularJs, then <i>Sinon Fake Server</i> is similar to the $ httpBackend service. <br><br><h3>  Total: </h3><br>  Jasmine framework includes almost everything that is needed, including <i>assertions</i> , <i>test doubles</i> (implemented through <i>spies</i> ) functionality.  Mocha does not have this functionality, but offers a choice of libraries for <i>assertions</i> (the most popular <i>Chai</i> ).  For <i>test doubles,</i> Mocha also requires connecting an additional library, in most cases, this is sinon.js.  <i>Sinon</i> can also be a great addition by providing your <i>fake server</i> (fake server). <br><br>  Choosing a test framework for JS can be a difficult task, I hope that this article helped you make the right choice.  In any case, whatever you use, you can‚Äôt go wrong.  Have a good test! <br><br>  <a href="http://thejsguy.com/2015/01/12/jasmine-vs-mocha-chai-and-sinon.html">Original article</a> </div><p>Source: <a href="https://habr.com/ru/post/314978/">https://habr.com/ru/post/314978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314968/index.html">Problems that we encountered when updating the PVS-Studio interface</a></li>
<li><a href="../314970/index.html">Taking PHP seriously</a></li>
<li><a href="../314972/index.html">Is there a future for InfiniBand on Hadoop?</a></li>
<li><a href="../314974/index.html">How IT professionals work. Andrey Domas - the leading system administrator in the social network "Odnoklassniki"</a></li>
<li><a href="../314976/index.html">Competition for ZeroNights 2016 from Mail.Ru Group</a></li>
<li><a href="../314980/index.html">Friday format: ‚ÄúYou can‚Äôt just take it and explain it to a non-programmer ...‚Äù</a></li>
<li><a href="../314984/index.html">Qt / QML REST Client</a></li>
<li><a href="../314986/index.html">Finally, a decent domestic processor DSP - 1967BH28</a></li>
<li><a href="../314990/index.html">Posh-SSH module for easy access to SSH and SCP from PowerShell</a></li>
<li><a href="../314992/index.html">Six stages of the player in social f2p-games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>