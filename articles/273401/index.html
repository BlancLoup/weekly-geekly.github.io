<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python-> Cython-> C ++, and COM to boot: writing a framework for autotests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think everyone is aware of the benefits of autotests. They help to keep the code in working condition, even with significant changes. It can also sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python-> Cython-> C ++, and COM to boot: writing a framework for autotests</h1><div class="post__text post__text-html js-mediator-article">  I think everyone is aware of the benefits of autotests.  They help to keep the code in working condition, even with significant changes.  It can also save testers from tedious manual work and allows you to focus on more interesting types of testing. <br><br>  Despite the fact that some parts of our project are over 25 years old, we are only at the very beginning of the introduction of automatic testing.  Nevertheless, we already have some successes, which I want to tell about in this article. <br><br>  How to write good autotests is a topic for a separate article.  And probably not one.  I will tell you how we have implemented testing of individual components.  Components are written in C ++ and have interfaces very similar to COM.  We chose python as the test language and use the very powerful PyTest test framework.  In the article I will tell you about the complexity of the C ++ / COM and python bundles, the pitfalls that we stumbled upon and how to solve these problems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Disclaimer </h4><br><ul><li>  I can not just copy the code of our project because of the NDA.  Therefore, all the examples in the article are written from scratch and never compiled.  Therefore, there may be minor inaccuracies, syntax errors or non-compliance with the code design rules.  But I tried to convey the main meaning. </li><li>  I am not an expert in python.  To tell you the truth, I started learning python around the middle of working on a project.  Therefore, some statements regarding python may be either not entirely correct, or not fully worked out. </li><li>  The Python code in the examples may not correspond to pep8, since  often reflects the SOMI prototype and borrows its style. </li><li>  This article is not a manual on cython, many things were left overs </li></ul><br><br><h4>  Prehistory </h4><br>  In the project I'm working on, we are developing a large and complex module.  Several million lines of C ++ code, a dozen large components and a hundred dll under the hood.  This module is used in several huge applications. <br><br>  Historically, this is all tested only through the UI, and mostly manually.  It often happens that a change in one area gets out of a bug somewhere in a completely different place.  And they find this bug only in a few days, or even weeks.  And sometimes something pops up in a few months, when another product decides to integrate a new version of our module. <br><br>  We have unit tests that chase CI by commits.  But the code was over 15 years old when we started talking about TDD.  The code is monolithic and it will not work out just to launch it separately.  We need a great refactoring for which no resources are given.  Therefore, we only have unit tests for simple functions or individual classes. <br><br>  But since the module has some API, then this module can be tested through this API.  You can collect the use cases of all applications that use us and write autotests for this.  Then it would be possible to drive these tests directly to CI by commits.  So the idea of ‚Äã‚Äãcomponent testing was born. <br><br>  But who will write the tests?  Testers could come up with good test scenarios and prepare test data, but testers do not know C ++ (and those who know quickly dumped into developers).  Programmers could code such tests, but usually fantasy is only enough for a couple of positive scenarios.  To cover all negative cases, patience is usually not enough. <br><br>  We decided to adopt the experience of colleagues from the neighboring team.  They made vrappers for their component using cython and put into the python a simplified interface that is used for tests.  The threshold for entering the python is much lower than in C ++.  Testers can easily master the python in a couple of days and begin to write good autotests. <br><br><h4>  What does the COM? </h4><br>  Before you begin to describe our torment you need to say a few words about our interfaces.  We use the technology slicked with COM and ported to Linux, poppy and fryu.  There are some infrastructural differences associated with the lack of a registry, but for the article it doesn‚Äôt matter. <br><br>  COM-like technology gives us a bunch of buns, like a ready-made plug-in component infrastructure.  We can easily dock modules written by different teams in different countries (including third party plugins).  At the same time, we are not concerned with the compatibility issues of different compilers, runtimes, and standard libraries.  The same style of interfaces of all modules, agreements on the transfer of parameters and return values, the lifetime of objects - all this is governed by agreements as with COM. <br><br>  There is a downside.  Inside the modules we can use any buns of modern C ++ standards.  But in public interfaces, we must adhere to the rules of SOM, only simple types or interfaces inherited from IUnknown.  No stl.  No exceptions, only HRESULT.  Because of this, the code on the borders of the modules is quite cumbersome and not very readable. <br><br><h4>  The first experience with cython </h4><br>  To begin with, we identified a dozen interfaces to our module, with which we could implement a small but complete workflow. <br><br>  But even though these interfaces are part of a public API, in reality they are quite low-level.  In order to make a certain operation it is impossible to simply take and call a single function or method.  You need to create five objects, connect them with each other, run for execution and wait for the result through the future.  All this complexity is needed to organize transactional, asynchronous, Undo / Redo, to organize access to thread-safe insides and even heaps of other things.  In short, 2 screens of C ++ code in COM style. <br><br>  We decided to follow the recommendations of our colleagues and write a small layer that would hide low-level interfaces.  In the python, it was proposed to expose several high-level functions. <br><br>  A cython vrapper just was forwarding calls to c ++: <br><pre><code class="python hljs">cdef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModuleObject</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> cdef CMyModuleObject * thisptr <span class="hljs-comment"><span class="hljs-comment"># wrapped C++ object def __init__(self): self.thisptr = new CMyModuleObject() def __dealloc__(self): del self.thisptr def DoSomething1(self): self.thisptr.DoSomething1() def DoSomething2(self): self.thisptr.DoSomething2() def GetResult(self): return self.thisptr.GetResult()</span></span></code> </pre> <br><br>  The C ++ implementation of the CMyModuleObject class was already involved in useful actions: it created objects of our module and called some useful methods (the same 2 screens of code). <br><br>  Cython is essentially a translator.  Based on the source code above, cython generates a ton of generic code.  If we compile it as dll / so (and rename it to pyd), we get a Python module.  With ++ implementation CMyModuleObject also needs to be lodged in this dll.  Now our Python module can be imported from Python (continuing from the import paths first).  You can run using the usual Python interpreter, the main thing is that the architecture coincides.  When executing the import string, the python will raise our dll itself, initialize and import everything it needs. <br><br>  The python script looked something like this: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * obj1 = MyModuleObject() obj1.DoSomething1() obj1.DoSomething2() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> obj1.GetResult()</code> </pre><br><br>  Cool!  Much easier than C ++! <br><br>  At the first stage, we decided not to bother with the test frameworks, but first to work out the approach on ordinary scripts.  In this form, you can already write something, But this approach did not differ in flexibility.  If you had to change something in the interlayer, then you had to change the code in C ++. <br><br><h4>  We wound COM interfaces </h4><br>  I insisted on trying to wrap up low-level interfaces directly, and write a layer, if necessary, on python.  The idea was sold to the authorities that we can wring 1 to 1 interfaces and test at the level of our public API. <br><br>  No sooner said than done.  We quickly came to this scheme.  The constructor of the Python object creates the SOM object and owns the link to it.  Links, of course, are considered a smart copy of CComPtr. <br><br><pre> <code class="python hljs">cdef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PyComponent</span></span></span><span class="hljs-class">:</span></span> cdef CComPtr[IComponent] thisptr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__cinit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Get the COM host cdef CComPtr[IComHost] com_host result = GetCOMHost(IID_IComHost, &lt;IUnknown**&gt;&amp;(com_host)) hresultcheck (result) # Create an instance of the component result = com_host.inArg().CoCreateInstance( CLSID_Component, NULL, IID_IComponent, &lt;void**&gt;self.thisptr.outArg() ) hresultcheck( result ) def SomeMethodWithParam(self, param): result = self.thisptr.inArg().SomeMethodWithParam(param) hresultcheck (result) def GetStringFromComponent(self): cdef char [1024] buf result = self.thisptr.inArg().GetStringFromComponent(buf, sizeof(buf)-1) hresultcheck(result) return string (buf)</span></span></code> </pre><br><br>  Usually HRESULT functions are not interesting to us.  If the function is successful - well, nice.  If you zafeilas, then most likely you do not need to go further.  Therefore, we simply check the error code and throw a Python exception.  Processing return codes is not made to the level of the client Python code, which makes the client code much more compact and readable. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HRESULT_EXCEPTION</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, result)</span></span></span><span class="hljs-function">:</span></span> super(HRESULT_EXCEPTION, self).__init__(<span class="hljs-string"><span class="hljs-string">"Exception code: "</span></span> + str(hex(result &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>))) cpdef hresultcheck(HRESULT result): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result != S_OK: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> HRESULT_EXCEPTION(result)</code> </pre><br><br>  Note that the hresultcheck function is declared as cpdef.  This means that it can be caused by both Python (sometimes hresult is checked in python) and native sish.  The second property significantly reduces the error-handling code generated by the siton and speeds up the execution.  We have not mastered the call to the SUCCEEDED macro, so we are comparing it with S_OK - for now. <br><br>  Sometimes we still departed from 1 to 1 vrapping, when it was clear that certain interfaces and their methods should be used only in one particular way and in no other way.  For example, if it is assumed that the COM object will be created empty, and then parameters will be crammed into it via the Set * () methods or a call to some Initialize (), in this case, at the python level, we simply made a convenient constructor with parameters. <br><br>  Or another example.  It happens that a request to one object conceptually returns a link to another object (or just a new object).  In COM, you have to use output parameters, but in a python you can return an object humanly. <br><br><pre> <code class="python hljs">cdef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class2</span></span></span><span class="hljs-class">:</span></span> cdef CComPtr[IClass2] thisptr cdef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class1</span></span></span><span class="hljs-class">:</span></span> cdef CComPtr[IClass1] thisptr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetClass2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> class2 = Class2() result = self.thisptr.inArg().GetClass2( class2.thisptr.outArg() ) hresultcheck ( result ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> class2</code> </pre><br><br>  From the point of view of encapsulation, the code is not very good - one object climbs into the guts of another.  But in python with encapsulation (or rather, with privacy) and so not very good.  But we have not yet come up with a more beautiful way.  There is a risk that someone will try to create Class2 with his hands in the client code; nothing good will probably come out.  I would be glad if someone tells you the option of a private constructor in python. <br><br>  The code examples above are located in files with the pyx extension (by the way, you can do a lot of them, rather than shoving everything in one).  It's like cpp in the pros - a file with the implementation.  But in a siton you still need a file with ads - pxd - a place where all the names that are considered sishnye will be described. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> libcpp cimport bool <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> libcpp.vector cimport vector <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> libcpp.string cimport string <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> libc.stdlib cimport malloc, free cdef extern <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mytypes.h"</span></span>: ctypedef unsigned short int myUInt16 ctypedef unsigned long int myUInt32 ctypedef myUInt32 HRESULT ctypedef struct GUID: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ctypedef enum myBool: kMyFalse kMyTrue kMyBool_Max cdef extern <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"hresult.h"</span></span>: cdef HRESULT S_OK cdef HRESULT S_FALSE cdef extern <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"Iunknown.h"</span></span>: cdef cppclass IUnknown: HRESULT QueryInterface (const IID &amp; iid, void ** ppOut) HRESULT AddRef () HRESULT Release () cdef extern <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"CComPtr.h"</span></span>: cdef cppclass CComPtr [T]: <span class="hljs-comment"><span class="hljs-comment"># this is trick, to assign pointer into wrapper T&amp; assign "operator="(T*) T* inArg() T** outArg() cdef extern from "comhost.h": cdef extern IID IID_IComHost cdef cppclass IComHost(IUnknown): HRESULT CoCreateInstance ( const GUID&amp; classid, IUnknown* pUnkOuter, const IID&amp; iid, void** x )</span></span></code> </pre><br><br>  Pay attention to CComPtr :: operator = ().  If in the Siton code you try to assign CComPtr directly, nothing happens.  He simply can not really parse this syntax.  I had to resort to the trick of renaming characters.  So assign is how a character will look in a siton, and in quotes it is set what exactly needs to be called in a sish code. <br><br>  The trick is useful if you need to call the Python class or function in the same way as a sishin. <br><br>  pxd: <br><pre> <code class="python hljs">cdef extern <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"MyFunc.h"</span></span>: int CMyFunc <span class="hljs-string"><span class="hljs-string">"MyFunc"</span></span> ()</code> </pre><br><br>  pyx: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> CMyFunc()</code> </pre><br><br>  Returning to our project.  Python code is simpler and more compact, but still too low-level for most users.  Therefore, we still decided to leave the interlayer, rewriting it in python.  As a result, those 2 pages of cumbersome COM code have turned into this. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1, param2)</span></span></span><span class="hljs-function">:</span></span> operation = DoSomethingOperation(param1, param2) engine = TransactionEngine() future = engine.Submit(operation) future.Wait() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.GetResult()</code> </pre><br><br>  So our code has become much more compact and clearer, it was possible to use both high-level interfaces like do_operation (), and, if necessary, go down to "sishnyh" interfaces. <br><br>  There was a feeling of flexibility, it was not necessary to recompile the C ++ part each time.  Moreover, to start, we needed to build up only 10 interfaces, and for each subsequent feature, it was necessary to do some 1-2, which really added strength and faith to the chosen approach. <br><br><h4>  Problems begin </h4><br>  In this form, the technology may already be suitable for most projects, but we have come up against several fundamental limitations. <br><br>  So, our COM host (the object that provides the COM infrastructure, everyones CoCreateInstance there, etc.) is a normal plus object.  So, someone must create it (analogous to CoInitialize) and then delete it (CoFinalize).  But here's the problem, the Python module has no main ().  In any case, in the form as we needed. <br><br>  Therefore, we created a plus Application object and put the initialization / finalization of the host into this object.  We wrote a wrapper who allowed us to create this object from a python (at the beginning of each script). <br><br>  But very quickly we began to catch kreshi at the exit.  It turned out that, unlike C ++ (the first created object will be removed last), the order of destruction of objects in python is not defined.  Well, in any case, there is no way to influence it.  Depending on the phase of the moon, the python nailed the Application object first, it put out the COM infrastructure and forcibly unloaded all the components.  Then the python deleted some other object that had a reference to some COM object.  An attempt to call Release () from a dll that has already been unloaded resulted in a crash. <br><br>  The second problem is the location of the executable file.  It turned out that in our large component there are a lot of places that are trying to open files with data along a certain path relative to the executable file.  This is normal if the final application is installed in the system in some known way.  This is also normal if we work with the application compiled in the working directory.  But this method stops working if the executable file suddenly becomes a python in the system directory. <br><br>  There was even a function that allows you to override the application directory.  It worked in most cases.  But, unfortunately, there were cyclists who ignored this redefinition and continued to calculate the path independently relative to the executable.  It would be correct to take it and fix it, but it would require considerable labor costs.  We decided that this is still lying in backlog. <br><br>  Finally, the third problem is the event loop.  The fact is that our module is very complex and interactive.  This is not just a ‚Äúcall function - get result‚Äù library.  This is a huge combine.  Inside, there are a couple of hundreds of threads that exchange messages.  Some parts of the code were written in the time of the Mesozoic and are intended for execution only in the main thread (otherwise it will not work).  In other places, a hardcode is sent to the main thread, expecting there to know how to process this message.  And we also have our own subsystem of threads and messages, which also implies that the message processing cycle will necessarily spin in the main thread and conduct all of this.  Without it in any way. <br><br>  The easiest solution at the start was to insert the run_event_loop () method into our Application class, which twisted the message loop.  The process stopped when our useful work was completed (as I understand it now, it was by coincidence :)) <br><br>  In general, scripts of the following type worked normally for us: we start some work using a non-blocking function (which does not wait for the end), after which we head off to the event loop <br><pre> <code class="python hljs">app = Application() start_some_processing_async() app.run_event_loop()</code> </pre><br><br>  But with the scenarios that required some interactivity, there was a problem.  We could not, for example, start the work, and then after a couple of seconds, try to stop it.  In fact, the work did not start until the message loop in the main thread started.  And if the cycle has started, then we will not return to the python. <br><br>  Of course, it would be possible to fence something asynchronous at the python level, but this is clearly not what we would like.  After all, the approach was supposed to push people who are not tempted by asynchronous systems.  They would like to write just like that and not to bathe in some event loops <br><pre> <code class="python hljs">start_some_processing_async() time.sleep(<span class="hljs-number"><span class="hljs-number">3</span></span>) cancel_processing()</code> </pre><br><br>  Without thinking, we tried to start processing in another thread, and in the main thing, to twist the message loop.  But we immediately came up against the following problem - <a href="https://ru.wikipedia.org/wiki/Global_Interpreter_Lock">GIL (Global Interpreter Lock)</a> .  It turned out that Python threads are not actually running in parallel.  Only one stream is running at a time, and the streams are switched every 100 commands.  All this regulates this very GIL, stopping all threads except one. <br><br>  It turned out that if the main thread went to the app.run_event_loop () function and did not return (it should hang there by design), then other Python commands in other threads are not executed.  It‚Äôs just that there were not 100 more teams in the main thread, and the interpreter decided that it was too early to switch. <br><br>  The solution was found in the nogil seedon keyword.  A piece of code tagged nogil first releases the GIL, then performs a sish call.  At the end of the GIL is captured again.  So  the main thread released GIL and went into the message loop.  The second thread got control and did everything it needed there. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span> cdef IComponent * component = self.thisptr.inArg() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nogil: result = component.Func() hresultcheck(result)</code> </pre><br><br>  Cython, by the way, is a very capricious thing.  It does not always allow to interfere with the Python and C code in one line.  It also does not allow you to call some Python constructions and create new variables in the nogil sections (logically, this requires access to the python intestines, which are protected by GIL).  It is necessary to be perverted like this, in order to correctly declare variables and make the necessary calls. <br><br>  Everything seems to start working, but very unstable.  We constantly caught some kind of crashes and hangs, and also constantly ran across a non-working functional (the file did not open in a relative path, but no one threw the error). <br><br><h4>  Design opposite </h4><br>  For several weeks we tried to defeat these 3 problems, tried different approaches.  But every time there was another insoluble problem.  Most of all delivered GIL, but we didn‚Äôt even imagine how to defeat the unloading of a COM host. <br><br>  We even thought about jumping onto lua, but some of the restrictions would still remain.  Only in this case would still have to go all the way from scratch. <br><br>  But here came a bold idea.  And what if we run not a code from a python, but rather a python from a code?  Let's write your application that will do the following: <br><ul><li>  Initialize COM host </li><li>  Start the second thread </li><li>  In the main thread, run the event loop </li><li>  In the second thread, run the python interpreter (it has an appropriate API for embedding in other applications) </li></ul><br><br>  This approach solves all 3 problems in one fell swoop: <br><ol><li>  We control the life of the COM host and can guarantee its destruction after the Python thread has finished its work. </li><li>  Our test application will live next to the main product, which means that all relative paths will work. </li><li>  Finally, no problems with GIL.  Python executes a single-threaded script, which means you don‚Äôt need to share resources with anyone. </li></ol><br><br>  And you know?  This approach worked!  There were, however, a few minor problems that were eventually solved. <br><ul><li>  some calls must still be made in the main thread.  Well, nothing, we started the message in the main thread, with a request to perform what is needed. </li><li>  I had to tinker with the installation of PYTHON_HOME and PYTHON_PATH.  The nontrivial moment was that neither the Python function Py_SetPythonHome (), nor the standard setenv () copy the passed string to itself, but simply remember the pointer.  In our case, it was a pointer to a temporary variable. </li><li>  in order not to depend on the version of the python, they decided to carry all the entrails with them.  Including the standard library (which, as it turned out, is perfectly readable directly from the zip) and several additional libraries </li></ul><br><br>  Another problem that had to be tricky was the sys.exit () function.  We needed it to catch the return code from unittest and pass it to the output, and then process it with CI. <br><br>  It works like this.  If someone in the script calls sys.exit (), a SystemExit exception is actually generated.  This exception is caught by the python itself and, like any other exception globally, must be printed to the console along with the stack trace.  But the Py_PrintEx function knows that there is such a special case, and if we are offered to print a SystemExit exception, then we need to call the exit exit () <br><br>  Yes, yes, like this!  A function called Print makes an exit () call.  And this exit honestly works out - just takes and cuts down the entire application.  And he didn‚Äôt want to spit that the application has unallocated handles, unfinished threads, unclosed files, unfinalized modules, a million active threads and all that jazz. <br><br>  But the python (in any case, 2.7.6. Old time, I know) does not allow it to turn at the API level.  I had to just copy several functions from the python sources (starting with PyRun_SimpleFileExFlags () and a few private ones that it calls) to my project and finish them by myself.  So, our version in the case of SystemExit correctly exits and returns a return code.  So  after the completion of the Python part, the test application can properly clean and extinguish itself. <br><br>  At first we had 2 projectors - one build test application with built-in python, and the second, as before, loadable module for python.  But later we combined it all into one projector.  The test application initialized the python, after which it called the initialization function of our python module (generated by a siton).  So  Python already at the start already knew about our module (although I still had to make imports). <br><br><h4>  Callbacks </h4><br>  In this form, the test application showed itself very well.  We screwed the test framework (standard unittest) and testers began to write tests little by little.  We ourselves, meanwhile, continued to drag the interfaces. <br><br>  Screwing another piece of functionality, we stumbled upon the fact that in some cases we need to be able to accept callbacks.  Those.  Python synchronously calls a function, and in its interior it calls a callback to a python. <br><br>  Positive interface looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IUnknown { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallbackFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Class IComponent : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IUnknown { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodWithCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ICallback * cb)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><br>  The Python class cannot be inherited from the plus interface under any sauce.  Therefore, in the project part of the project we had to do our own implementation, which threw calls to the python. <br><br>  .h <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Forward declaration struct _object; typedef struct _object PyObject; class CCallback : public ICallback { //COM stuff ... CCallback * Create(); // ICallback virtual HRESULT CallbackFunc(); public: void SetPythonCallbackObject(PyObject * callback_handler); private: PyObject * m_pPythonCallbackObject; };</span></span></code> </pre><br><br>  .cpp <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> PythonMethodName[] = <span class="hljs-string"><span class="hljs-string">"PythonCallbackMethod"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCallback::SetPythonCallbackObject(PyObject * callback_handler) { <span class="hljs-comment"><span class="hljs-comment">// Do not addref to avoid cyclic dependency m_pPythonCallbackObject = callback_handler; } HRESULT CCallback::CallbackFunc() { if(!m_pPythonCallbackObject) return S_OK; // Acquire GIL PyGILState_STATE gstate = PyGILState_Ensure(); if ( gstate == PyGILState_UNLOCKED ) { // Call the python method char * methodName = const_cast&lt;char *&gt;(PythonMethodName); //Py_Api doesn't work with constant char * PyObject * ret = PyObject_CallMethod(m_pPythonCallbackObject, methodName, NULL); if (!ret) { if (PyErr_Occurred()) { PyErr_Print(); } std::cout&lt;&lt;"cannot call"&lt;&lt;PythonMethodName&lt;&lt;std::endl; } else Py_DecRef(ret); } // Release the GIL PyGILState_Release(gstate); return S_OK; }</span></span></code> </pre><br><br>  A special moment in this code is the capture of GIL.  Otherwise, at best, the python will break on checking that the GIL is captured, but most likely it will either hang or cross. <br><br>  We have a console application, so the error output to the console is the same.  Even if the Python code throws an exception, our handler will catch it and print out the traceback. <br><br>  From the side of the siton it looks like this: <br><pre> <code class="python hljs">cdef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PyCallback</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> cdef CComPtr[ICallback] callback <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__cinit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.callback.assign( CCallback.Create() ) self.callback.inArg().SetPythonCallbackObject(&lt;PyObject *&gt; self) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PythonCallbackMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PythonCallbackMethod called"</span></span> cdef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">:</span></span> cdef CComPtr[IComponent] thisptr <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__cinit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> // Create IComponent instance ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMethodWithCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, PyCallback callback)</span></span></span><span class="hljs-function">:</span></span> cdef IComponent * component = self.thisptr.inArg() cdef ICallback * cb = callback.callback.inArg() hresult = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nogil: hresult = component.MethodWithCallback(cb) hresultcheck(hresult)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When calling the MethodWithCallback () method, you must release the GIL, otherwise the callback will not be able to capture it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the client Python code, everything should be simple and clear.</font></font><br><pre> <code class="python hljs">component = Component() callback = PyCallback() component.CallMethodWithCallback(callback)</code> </pre><br><br>       ,        . ,        API,      cython. <br><br>    ,             . ,         ,      .        ,   GIL (  ,     ),       .   PyGILState_Ensure()  ,     ,   ,      . <br><br>  , ,   ,       .     ,    ,        ,       .    . <br><br>   .   ,    ,     .     PyRun_FileExFlags(),          ,   PyArena_Free()    <br><pre> <code class="cpp hljs"> PyThreadState *_save = PyEval_SaveThread(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (GetCurrentlyActiveCallbacks() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">// semicolon here is correct PyEval_RestoreThread(_save);</span></span></code> </pre><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The python-&gt; cython-&gt; C ++ sandwich has been very successful as a framework for the AutoTest API. The threshold for entering the python is very small compared to other programming languages. Any competent tester in a couple of days will master the python at a level sufficient for writing autotests. The main thing in this matter is to figure out how to test this or that functional, and it is a matter of technology to express it in code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We managed to build a user-friendly layer that exposes a simple and intuitive interface to the python. Calls of the low-level C ++ / COM code are hidden behind the wrappers and understanding of this code is not necessary for most tasks. But if necessary, it is easy to go down there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recently we screwed PyTest as a framework for writing tests. Very taxis! Tests have become even easier, clearer and faster.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now there are no serious architectural flaws in sight, but there are still some bugs. </font><font style="vertical-align: inherit;">For example, now there are a couple of cyclic dependencies, which is why several key objects do not want to collapse. </font><font style="vertical-align: inherit;">But where to break the cyclical dependence correctly, we have not yet invented. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for the siton himself. </font><font style="vertical-align: inherit;">The developers of cython go to contact and have already fixed a couple of bugs for us. </font><font style="vertical-align: inherit;">They release releases regularly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cython is quite capricious. </font><font style="vertical-align: inherit;">It does not always intelligibly explain what exactly is not true in the source file, and sometimes also indicates the wrong place. </font><font style="vertical-align: inherit;">Some things we have not mastered.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also screwed the interactive python mode. </font><font style="vertical-align: inherit;">Sometimes it is more convenient to debug Python code directly in the python console than to edit the script and run it again and again. </font><font style="vertical-align: inherit;">It turned out all simple - just call it:</font></font><br><pre> <code class="cpp hljs">PyRun_InteractiveLoop(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>);</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Developers of the C ++ module actively launch tests directly from the IDE. </font><font style="vertical-align: inherit;">You can simply take a test that fell on the CI and otdebezhit. </font><font style="vertical-align: inherit;">All breakpoints in C ++ code work as needed. </font><font style="vertical-align: inherit;">But we have not yet invented how to debug the Python part. </font><font style="vertical-align: inherit;">However, there was no special need - with PyTest, the tests are very simple and there is practically nothing to debug there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it is the realization that the technology has taken place. </font><font style="vertical-align: inherit;">Extend functionality easily and conveniently. </font><font style="vertical-align: inherit;">People liked to write autotests, although for now they are treated with suspicion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope the article will be useful, and you too can organize something like this.</font></font></div><p>Source: <a href="https://habr.com/ru/post/273401/">https://habr.com/ru/post/273401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273389/index.html">Critical vulnerability in the Grub2 loader allows to bypass password protection</a></li>
<li><a href="../273391/index.html">Proxmox VE 4 install root partition on unsupported installer soft raid1</a></li>
<li><a href="../273393/index.html">The simplest cellular automata and their practical application</a></li>
<li><a href="../273395/index.html">Jedi Escape: May the gyroscope arrive with you</a></li>
<li><a href="../273397/index.html">Let the scrolling be with you: theory and practice on the camera in the platform [2/2]</a></li>
<li><a href="../273403/index.html">Some CSS CSS Tips</a></li>
<li><a href="../273405/index.html">Node.JS Get rid of require () forever</a></li>
<li><a href="../273407/index.html">Birthday of the founder of the oldest hacker club Chaos Computer Club</a></li>
<li><a href="../273411/index.html">How not to present the results of the static analyzer</a></li>
<li><a href="../273413/index.html">The algorithm for choosing the size of the image for social networks: Guide from the expert Buffer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>