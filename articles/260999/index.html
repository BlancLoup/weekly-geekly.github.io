<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional DDS generator on the FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I saw a signal generator project on an AVR microcontroller. The principle of generation is DDS , based on the Jesper library, the maximum fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional DDS generator on the FPGA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cd8/e6b/473/cd8e6b473d24439fbf7faa3b87f3fc89.jpg" align="left">  Recently, I saw a signal generator project on an AVR microcontroller.  The principle of generation is <a href="http://ra3ggi.qrz.ru/UZLY/dds.htm">DDS</a> , based on the <a href="http://www.myplace.nu/avr/minidds/">Jesper</a> library, the maximum frequency is 65534 Hz ‚Äã‚Äã(and up to 8 MHz HS output with a square wave).  And then I thought that the generator is an excellent task, where the FPGA can show itself in the best possible way.  As a sports interest, I decided to repeat the project on the FPGA, while meeting the deadlines on two days off, and the parameters to get are not strictly defined, but the maximum possible.  What came out of this can be found under the cut <br clear="right"><br clear="left"><a name="habracut"></a><br><br><h4>  <b>Day zero</b> </h4><br><img src="https://habrastorage.org/files/3cb/fdd/29f/3cbfdd29fd944a0fa8be594778569bb5.jpg" align="right">  Before the weekend came, I had a little time to think about the implementation.  To simplify my task, I decided to make the generator not as a separate device with buttons and an LCD screen, but as a device that connects to a PC via USB.  For this, I have <a href="http://www.dx.com/p/pl2303hx-usb-to-rs232-ttl-converter-adapter-module-164590">a USB2RS232 board</a> .  The driver board does not require (CDC), so I think it will work under Linux (for some, this is important).  Also, I will not hide that I already worked with the reception of messages on RS232.  I will take <a href="http://opencores.org/project,uart2bus">modules for work with RS232</a> ready with <a href="http://opencores.com/">opencores.com</a> . <br clear="right"><br>  To generate a sinusoidal signal, you will need a DAC.  I chose the type of DAC, as in the initial project - <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D1%258B">R2R</a> on 8 bits.  It will allow to work at high frequencies, of the order of megahertz.  I am convinced that the FPGA must cope with this <br><br><img src="https://habrastorage.org/files/cf1/532/086/cf1532086504422286febc0edbfcd0c0.jpg" align="left">  About what to write a program for data transmission through the COM port, I was thinking.  On the one hand, you can write on Delphi7, the experience of writing such a program already exists, besides, the size of the executable file will not be large.  I also tried to sketch something to work with Serial in the form of a java script in the html page, but more or less earned only through the Chrome serial API, but for this you need to install the plugin ... in general, too, disappears.  As an innovation, I tried PyQt5 for myself, but when distributing such a project, you need to drag a bunch of libraries.  Having tried to build a PyQt project in an exe file, it turned out more than 10 MB.  That is, there will be nothing better than an application written in c ++ \ Qt5.  I should also take into account that I don‚Äôt have any development experience in python, but I do have Qt5.  Therefore, the choice fell on Qt5.  From the fifth version there appeared a module for working with serial and I already worked with it.  And the application on Qt5 can be transferred to Linux and Mac (for some, this is important), and from version 5.2, applications on QWidgets can be transferred even to a smartphone! <br clear="left"><br>  What else is needed?  Naturally board with FPGA.  I have two of them (Cyclone iv EP4CE10E22C8N for 10 thousand cells, and Cyclone ii EP2C5 for 5 thousand cells).  I will choose the one on the left, solely because of the more convenient connector.  In terms of volume, the project does not intend to be large, so it fits in either of the two.  In terms of speed, they do not differ.  Both boards have ‚Äúon board‚Äù 50 MHz generators, and inside the FPGA there is a <a href="http://marsohod.org/index.php/11-blog/212-pll">PLL</a> , with which I can increase the frequency to the planned 200 MHz. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/fe3/961/a3a/fe3961a3a89c41c2b86bae86b1ccf27f.jpg"></div><br><br><h4>  <b>The first day</b> </h4><br>  Due to the fact that I already did the DDS module in my synthesizer project, I immediately took up the soldering iron and began to solder the DAC on the resistors.  He took a mockup.  Installation did with the use of <a href="http://habrahabr.ru/post/238675/">cheating</a> .  The only change that affected the technology was that I abandoned the acid <a href="">F38N</a> for tinning the racks in favor of <a href="">the TT indicator flux gel</a> .  The essence of the technology is simple: I solder racks to the PCB, solder resistors on them from the PCB side.  Missing connections are performed by wrap.  Still, the racks are convenient because I can insert them directly into the FPGA board. <br><br>  Unfortunately, at home there were no resistors 1 and 2 kilooma.  There was no time to go to the store.  I had to sacrifice one of their rules, and remove the resistors from the old unnecessary board.  They used resistors 15K and 30K.  The result is such a Frankenstein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d9/8e3/b71/4d98e3b718db4983950b760c80f716bf.jpg"></div><br><div class="spoiler">  <b class="spoiler_title">Then I launched Quartus, created a project.</b> <div class="spoiler_text">  After creating the project, you need to set the target device: Assigments menu -&gt; Device <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/208/419/c17/208419c173a44b709980aea89c4f726b.png"></div><br><br>  Further, in the same place I press the button ‚ÄúDevice and Pin options‚Äù because some pins are configured so that they will not work.  I configure everything as "Use as regular I / O" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/818/3e9/68b/8183e968bc0d40ec9ea9f3c045dbc3ce.png"></div></div></div><br>  In the project, I "nahadrkodil" unmanaged main module DDS at a fixed frequency. <br><br><div class="spoiler">  <b class="spoiler_title">1000 Hz Generator Module</b> <div class="spoiler_text"><pre><code class="vhdl hljs">module signal_generator(clk50M, signal_out); input wire clk50M; output wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] signal_out; wire clk200M; osc osc_200M reg [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] accumulator; assign signal_out = accumulator[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span>]; //  <span class="hljs-number"><span class="hljs-number">1000</span></span>  //<span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> Hz -     //<span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">32</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">294</span></span> <span class="hljs-number"><span class="hljs-number">967</span></span> <span class="hljs-number"><span class="hljs-number">296</span></span> -  DDS - <span class="hljs-number"><span class="hljs-number">32</span></span>  // <span class="hljs-number"><span class="hljs-number">1000</span></span>Hz / <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> Hz / <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4294967296</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">42949</span></span>,<span class="hljs-number"><span class="hljs-number">67296</span></span> always @(posedge clk50M) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> accumulator &lt;= accumulator + <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d42949</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> </div></div><br>  After that, I clicked ‚ÄúStart Compilation‚Äù so that the development environment wondered what our input / output lines are in the main project module and what physical PIN's they are connected to.  You can connect to almost any.  After compilation, assign the appeared lines to the real PIN of the FPGA chip: <br><br><div class="spoiler">  <b class="spoiler_title">Assigments menu item -&gt; Pin Planner</b> <div class="spoiler_text">  On the HS_OUT, key0 and key1 lines, I ask you not to pay attention yet, they appear in the project afterwards, but I didn‚Äôt manage to make the screen at the very beginning. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/73e/f0e/883/73ef0e883f914a18a1e18948cd37ad5b.png"></div><br><br>  In principle, it is enough to ‚Äúregister‚Äù only PIN_nn in the Location column, and the remaining parameters (I / O standart, Current Strench and Slew Rate) can be left by default, or you can choose the same options that are suggested by default (default) so that there is no warning 's. <br><br><div class="spoiler">  <b class="spoiler_title">How to find out what PIN corresponds to the slot number on the board?</b> <div class="spoiler_text">  Socket pin numbers are on board <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/53e/74a/048/53e74a0480f7400eae14dbc41e09d04e.jpg"></div><br>  And the FPGA pins, to which the connector pins are connected, are described in the documentation that comes with the FPGA board. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c55/d6d/005/c55d6d00574a45cd91badbda1bc81cec.jpg"></div><br></div></div><br></div></div><br>  After the pins are assigned, I compile the project again and flash it with the help of a USB programmer.  If the drivers for the USB Byte blaster programmer are not installed, then indicate to Windows that they are located in the folder where you installed Quartus.  Then she will find herself. <br><br>  Connect the programmer to the JTAG connector.  A menu item for programming "Tools -&gt; Programmer" (or click the icon on the toolbar).  The ‚ÄúStart‚Äù button, joyful ‚ÄúSuccess‚Äù and the firmware are already inside the FPGA and are already working.  Just do not turn off the FPGA, otherwise she will forget everything. <br><br><div class="spoiler">  <b class="spoiler_title">Tools -&gt; Programmer</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/e6e/bcb/594/e6ebcb594ab845b9b8c058e7246f85d9.png"></div></div></div><br>  The DAC is connected to the FPGA board connector.  I connect the oscilloscope S1-112A to the DAC output.  As a result, the ‚Äúsaw‚Äù should turn out because the high bit of the word DDS of the battery of the phase is output on 8 bits.  And it always increases until it overflows. <br><br>  Some 1.5 hours and for a frequency of 1000 Hz, I see the following waveform: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ccd/401/f26/ccd401f2672e4ff285c026fdd9e6484c.jpg"></div><br><br>  I want to note that the "saw" in the middle has a small fracture.  It is due to the fact that the resistors have a spread of values. <br><br>  Another important point that needed to be clarified is the maximum possible frequency with which the DDS generator will work.  With correctly configured TimeQuest parameters, after compilation in the Compilation Report, you can see that the speed of the circuit is above 200 MHz with a margin.  And this means that I will multiply the frequency of the 50 MHz oscillator with the help of PLL by 4. I will increase the value of the battery of the DDS phase with a frequency of 200 MHz.  The final frequency range that can be obtained in our conditions is 0 - 100 MHz.  Frequency setting accuracy: <br><br><pre> <code class="vhdl hljs"> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>  (clk) / <span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">32</span></span> (DDS) = <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">047</span></span> </code> </pre> <br>  That is, it is better than ~ 0.05 Hz.  I consider the accuracy in the Hertz fraction for a generator with such a range of operating frequencies (0 ... 100 MHz) to be sufficient.  If someone needs to increase accuracy, then for this you can increase the DDS bit (do not forget to check the TimeQuest Timing Analyzer, that the speed of the logic is within CLK = 200 MHz, because it is an accumulator), or simply reduce the clock frequency, if such A wide range of frequencies is required. <br><br><div class="spoiler">  <b class="spoiler_title">TimeQuest Timing Analyzer</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/8bd/df2/4e7/8bddf24e721c4ef8b27664d5e42ce83a.png"></div></div></div><br>  After I saw the ‚Äúsaw‚Äù on the screen, family matters forced me to go to the country (the same day off).  There I mowed, cooked, grilled kebabs and did not know about the surprise that I was waiting for in the evening.  Already closer to the night before bedtime, I decided to look at the waveform for other frequencies. <br><br><div class="spoiler">  <b class="spoiler_title">For a frequency of 100 kHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/179/013/c89/179013c89e96487eac058b86d51354b9.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">For a frequency of 250 kHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/47d/bd3/b19/47dbd3b1983d4a388373be6df6b20d86.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">For the frequency of 500 KHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b72/c1c/d0e/b72c1cd0e8094b898528b965747475d2.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">For frequency 1 MHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/e07/937/f68/e07937f684e441309f144e0569d053b7.jpg"></div></div><br>  I will not hide that the shape of the signals has upset me, especially at 1 MHz (pathetic, useless megahertz!).  I planned to get the frequencies of several other orders.  After reading about the R2R DAC, the cause of the problem became clear - stray capacitances.  Therefore, the plans for the next day, it was decided to make a DAC on 100 and 200 Ohm resistors, which I have in stock, and leave this DAC for future developments that do not require working at such high frequencies, because the smoothness of the saw also has its plus. <br><br><h4>  <b>Second day</b> </h4><br>  Due to the fact that it was interesting how the DAC will work on resistors of 100 and 200 Ohms, I immediately took up the soldering iron.  This time, the DAC turned out to be more accurate, and it took less time to assemble it. <br><br><img src="https://habrastorage.org/files/0ca/c46/7bb/0cac467bb4f145ae8b727db6ee31e5ac.jpg"><br><br><img src="https://habrastorage.org/files/97f/801/685/97f8016853a545d48be0038d1e5d9842.jpg"><br><br>  We put the DAC on the FPGA board and connect it to the oscilloscope <br><br><img src="https://habrastorage.org/files/4b9/873/56b/4b987356b5484650b188709653002767.jpg"><br><br>  Checking 1 MHz - IN!  It is quite another matter! <br><br><img src="https://habrastorage.org/files/332/3c9/e20/3323c9e20dc749ccac4a422bc23d07bb.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">Saw 10 MHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ed7/e0d/df1/ed7e0ddf119945e6add223e7886659f1.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">Saw 25 MHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/581/098/88b/58109888b2e342b9a7b75c9da1a69685.jpg"></div></div><br>  The shape of the saw at 10 MHz is still similar to the correct one.  But at 25 MHz, it is already quite "not beautiful."  However, C1-112a has a bandwidth of 10 MHz, so in this case the reason may already be in the oscilloscope. <br><br>  In principle, this issue with the DAC can be considered closed.  Now remove the high-speed waveform.  To do this, we will output the most significant bit to a separate PIN FPGA.  The data for this line will be taken from the high bit of the DDS battery. <br><br><pre> <code class="vhdl hljs">assign hs_out = accumulator[<span class="hljs-number"><span class="hljs-number">31</span></span>];</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">1 MHz square wave</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f9b/488/c7c/f9b488c7c1de41f29b593b1c2e78f6c8.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">5 MHz meander</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/2b8/b48/6fc/2b8b486fcae54072aaeb5fe6e5f94749.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">Meander 25 MHz</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f9b/e52/781/f9be5278162e47ba863083ec2cec9d9b.jpg"></div></div><div class="spoiler">  <b class="spoiler_title">50 MHz meander is almost not visible</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/291/d1d/75b/291d1d75bc344c9dbf76b9bc6c856c74.jpg"></div></div><br>  But I think that the output of the FPGA would be worth the load on the resistance.  Perhaps the fronts would be cooler. <br><br>  Sine is done on the table.  The size of the table is 256 values ‚Äã‚Äãof 8 bits each.  It would be possible to take more, but I already had a ready mif file.  Using the wizard, create a ROM element with the sine table data from the mif file. <br><br><div class="spoiler">  <b class="spoiler_title">Creating a ROM - Tools -&gt; Mega Wizard Plugin manager</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/30f/d23/599/30fd2359902041c78086210ba7d24aa1.png"></div><br>  Select 1 port ROM and set the name for the module. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f1c/875/788/f1c875788d80417d92725d017cd5f317.png"></div><br><br>  Agree <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/520/510/681/520510681437440ea1fd654b4cdef4d7.png"></div><br><br>  Here we also agree <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7a6/0c3/540/7a60c354018a4edaaf93d0090a29641f.png"></div><br><br>  Using browse we find our mif file with sine table <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/82e/b8d/cb3/82eb8dcb3a084c41b2e385fe5cc1bb92.png"></div><br><br>  Here, too, do not change anything <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e9c/aa9/9c2/e9caa99c2cf947259f772b5c1c5c3aeb.png"></div><br><br>  We uncheck the sine_rom_bb.v module - it is not needed.  Next finish.  Quartus will ask you to add a module to the project - we agree.  After that, the module can be used just like any other module in Verilog. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/118/767/182/118767182df64592a9e8d5cfe6a0c30b.png"></div></div></div><br>  The upper 8 bits of the DDS battery word will be used as the ROM address, and the data output will be the sine value. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">//sine rom wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] sine_out; sine_rom sine1(.clock(clk200M), .address(accumulator[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span>]), .q(sine_out));</code> </pre> </div></div><br>  The sine waveform at different frequencies looks ... the same. <br><br><img src="https://habrastorage.org/files/280/f1d/414/280f1d4148cd4134b4c6d813051c3c69.jpg"><br><br>  If desired, you can consider the problems of the DAC associated with the scatter of resistors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fb5/e67/5e7/fb5e675e77fb45738e7400fe0f634ee6.jpg"></div><br><br>  Well, this weekend is over.  But not yet written software for PC control.  I am compelled to state the fact that I did not meet the planned deadlines. <br><br><h4>  <b>Third day</b> </h4><br>  There is very little time, so we are writing a program in haste (in the best traditions).  In some places, in order to reduce the number of letters and the convenience of entering information from the keyboard, an event filter by the name of the widget is used.  Please understand and forgive. <br><br>  Interface <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aee/794/cbe/aee794cbe1c14b31a899937eb0dd250d.png"></div><br><br>  <a href="https://github.com/UA3MQJ/fpga-signal-generator/tree/master/Qt_project/signal_generator">GitHub</a> source code.  There is also an application already compiled under windows. <br><br>  The code is as simple as 5 kopecks.  Among other things, you need to add the serialport module to the project file. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">QT</span></span> += core gui serialport</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Opening COM port</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QSerialPort</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span>; ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setPortName</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ui-</span></span>&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">lbSerialPortInfo-</span></span>&gt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">currentText</span></span>()); <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBaudRate</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QSerialPort</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Baud115200)</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setDataBits</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QSerialPort</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Data8)</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setParity</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QSerialPort</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::NoParity)</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setStopBits</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QSerialPort</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::OneStop)</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setFlowControl</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QSerialPort</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::NoFlowControl)</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">serial</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.open</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QIODevice</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::ReadWrite)</span></span>;</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Forming and sending a message</b> <div class="spoiler_text"><pre> <code class="hljs bash"> QByteArray <span class="hljs-built_in"><span class="hljs-built_in">source</span></span>; QDataStream stream(&amp;<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>, QIODevice::ReadWrite); stream &lt;&lt; (qint8)(01); // <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> freq msg stream &lt;&lt; waveform; stream &lt;&lt; adder32; serial.write(<span class="hljs-built_in"><span class="hljs-built_in">source</span></span>);</code> </pre> </div></div><br><h4>  <b>Day four</b> </h4><br>  In a hurry, we finish receiving data on the UART.  To receive messages on the UART you need to put a couple of modules.  One Baud generator, the second - the receiver.  In order for the receiver to work at 115200, you need to make some calculations, assuming that the main clock frequency is 200 MHz. <br><br><div class="spoiler">  <b class="spoiler_title">Baud_gen module</b> <div class="spoiler_text"><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> global_clock_freq = <span class="hljs-number"><span class="hljs-number">200000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> baud_rate = <span class="hljs-number"><span class="hljs-number">115200</span></span>; // -     UART // first <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>: // baud_freq = <span class="hljs-number"><span class="hljs-number">16</span></span>*baud_rate / gcd(global_clock_freq, <span class="hljs-number"><span class="hljs-number">16</span></span>*baud_rate) //Greatest Common Divisor -   . http://www.alcula.com/calculators/math/gcd/ // second <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>: // baud_limit = (global_clock_freq / gcd(global_clock_freq, <span class="hljs-number"><span class="hljs-number">16</span></span>*baud_rate)) - baud_freq //      <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> GCD = (baud_rate==<span class="hljs-number"><span class="hljs-number">115200</span></span>) ? <span class="hljs-number"><span class="hljs-number">12800</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> baud_freq = <span class="hljs-number"><span class="hljs-number">16</span></span>*baud_rate / GCD; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> baud_limit = (global_clock_freq / GCD) - baud_freq; wire uart_clk; baud_gen BG(.clock(clk), .reset(rst), .ce_16(uart_clk), .baud_freq(baud_freq), .baud_limit(baud_limit));</code> </pre> </div></div><br>  I put the message receiving module, uart_clk is sent to it and the signal is from the physical input of the FPGA. <br><br><div class="spoiler">  <b class="spoiler_title">Uart_rx module</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">//RCV wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] uart_command; wire uart_data_ready; uart_rx URX(.clock(clk), .reset(rst), .ce_16(uart_clk), .ser_in(rx), .rx_data(uart_command), .new_rx_data(uart_data_ready) );</code> </pre> </div></div><br>  Then I put all this in a separate module, which gives only the number of the waveform and the increment value to the register of the battery of the DDS phase. <br><br><div class="spoiler">  <b class="spoiler_title">Ctrl.v module</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module ctrl(clk, rst, rx, wf, adder); input wire clk, rst, rx; output wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] wf; //wave form output wire [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adder;// adder value reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] wf_reg; initial wf_reg &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adder_reg; initial adder_reg &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1073741</span></span>;</code> </pre> </div></div><br>  When the uart_rx module received a byte of information, it puts the uart_data_ready line into one unit.  At this time on the line uart_command is received bytes.  To receive a message I am writing a steytmashin. <br><br><div class="spoiler">  <b class="spoiler_title">State machine</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">//rcv state machine <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SM_READY = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SM_FRQ_WF = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SM_FRQ_DDS1 = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SM_FRQ_DDS2 = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SM_FRQ_DDS3 = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SM_FRQ_DDS4 = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d5</span></span>; //messages <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CMD_SETFREQ = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] rcv_state; initial rcv_state &lt;= SM_READY; always @ (posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uart_data_ready==<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rcv_state==SM_READY) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rcv_state = (uart_command==CMD_SETFREQ) ? SM_FRQ_WF : rcv_state; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rcv_state==SM_FRQ_WF) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> wf_reg &lt;= uart_command; rcv_state &lt;= rcv_state + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rcv_state==SM_FRQ_DDS1) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adder_reg &lt;= (adder_reg &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + uart_command; rcv_state &lt;= rcv_state + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rcv_state==SM_FRQ_DDS2) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adder_reg &lt;= (adder_reg &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + uart_command; rcv_state &lt;= rcv_state + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rcv_state==SM_FRQ_DDS3) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adder_reg &lt;= (adder_reg &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + uart_command; rcv_state &lt;= rcv_state + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rcv_state==SM_FRQ_DDS4) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> adder_reg &lt;= (adder_reg &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + uart_command; rcv_state &lt;= SM_READY; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rcv_state &lt;= SM_READY; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //ucom_ready <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br>  Output data to the outputs of the module <br><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">assign adder = adder_reg; assign wf = wf_reg;</code> </pre> </div></div><br><br>  Add the receiving module to the main module. <br><br><div class="spoiler">  <b class="spoiler_title">Add ctrl module to the main module</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">//rs232 rcvr wire [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] adder_value; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] waveform; ctrl ctrl_0(.clk(clk200M), .rst(rst), .rx(RS232in), .wf(waveform), .adder(adder_value));</code> </pre> </div></div><br>  Increment value added to the battery phase <br><br><div class="spoiler">  <b class="spoiler_title">Increase the value of the battery with each beat</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">always @(posedge clk200M) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> accumulator &lt;= accumulator + adder_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br>  From the highest part of the value of the battery phase, we obtain the remaining waveforms.  And depending on the selected form - connect it to the output. <br><br><div class="spoiler">  <b class="spoiler_title">Waveforms</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">// wave_forms <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SINE = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SAW = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> RAMP = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> TRIA = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SQUARE = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> SAWTRI = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> NOISE = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d6</span></span>; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] saw_out = accumulator[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">31</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span>]; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] noise_out = <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span>; //! wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] ramp_out = -saw_out; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] square_out = (saw_out &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) ? <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b11111111</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b00000000</span></span>; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] saw_tri_out = (saw_out &gt; <span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span>) ? -saw_out : <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span> + saw_out; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] tri_out = (saw_out&gt;<span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d191</span></span>) ? <span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span> + ((saw_out &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d511</span></span>) : (saw_out&gt;<span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d063</span></span>) ? <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d255</span></span> - ((saw_out &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span>) : <span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span> + (saw_out &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>); //sine rom wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] sine_out; sine_rom sine1(.clock(clk200M), .address(saw_out), .q(sine_out)); wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> = (waveform == SINE) ? sine_out : (waveform == SAW) ? saw_out : (waveform == RAMP) ? ramp_out : (waveform == TRIA) ? tri_out : (waveform == SQUARE) ? square_out : (waveform == SAWTRI) ? saw_tri_out : (waveform == NOISE) ? noise_out : <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d127</span></span>; //TODO</code> </pre> </div></div><br><br>  I was almost not surprised that it immediately worked.  The only mistake I found was in the calculations: I divided the desired frequency into CLK, then by two more, then multiplied by the battery capacity.  But this is not necessary, because we get 1 period when the value of the battery changes from 0 to MAX.  It is necessary to divide an additional 2 only if taking the most significant bit of the battery frequency as the output of the meander (in this case the frequency is 2 times lower).  But getting the meander I redid. <br><br><h4>  <b>Day four</b> </h4><br>  It can include the time spent on each day in the design of the article. <br><br>  We proceed to check.  First with an oscilloscope. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/eDHQYtqhRGM%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhguZX1U2NhDlC5qEkRcXTXrvgp4Rg" frameborder="0" allowfullscreen=""></iframe><br><br>  At radio frequencies from 28 to 100 MHz, I decided to listen to the generator using an SDR receiver, placing the antenna next to the board. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/08d/406/e91/08d406e9163e4294a39bb779dddf8196.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/94a/8e2/f8e/94a8e2f8e9d84c428853c2e223d0b694.JPG"></div><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/-XqECAIpqfw%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjegagCBrQKlJ462ZtlynuMIKX_Gw" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  <b>findings</b> </h4><br>  As is often the case in IT, there was an error of 2‚Äì2.5 times with the time estimate.  The goal has been achieved: a generator up to 100 MHz is assembled on the knee.  However, so that this work could be called a full-fledged generator, it will take more work.  Therefore, there are great prospects for development.  Due to the deadlines, I did not add what I could in principle: 1) a noise generator;  2) a wave generator that the user draws himself;  3) digital sequence generator.  There is no amplitude and offset adjustment in the generator. <br><br>  227 cells out of 10,000 were used. A list of what else can be added to the project: <br><ul><li>  Expand the bit width of the DAC </li><li>  Increase the number of outputs with generated signals </li><li>  Apply the DAC chip in a higher bit depth </li><li>  Implement amplitude and offset control </li><li>  Add controls, LCD screen, for portability </li><li>  Add noise generator and other simple waveforms </li><li>  Add the ability to download arbitrary waveforms </li></ul><br>  I think that anyone can do this on their own by expanding the project with the necessary functionality.  Add is easier than from scratch.  The format of the control command is very simple, so the generator can be controlled from a microcontroller. <br><br>  Source codes: <a href="https://github.com/UA3MQJ/fpga-signal-generator">https://github.com/UA3MQJ/fpga-signal-generator</a> <br><br><h4>  <b>Links with analogues</b> </h4><br>  Far from complete list <br>  <a href="http://cxem.net/izmer/izmer76.php">Functional DDS generator.</a>  Created database AVR.  Frequencies 0 ... 65534 Hz. <br>  <a href="http://cxem.net/review/review15.php">Overview of the DDS-generator GK101.</a>  Created using FPGA Altera MAX240.  Frequencies up to 10 MHz. <br>  <a href="http://cxem.net/izmer/izmer88.php">Multifunctional generator on the PIC16F870.</a>  Frequency range: 11 Hz - 60 kHz. <br>  <a href="http://cxem.net/izmer/izmer136.php">Analog function generator.</a>  Frequency range ranges from 20 Hz to 300 kHz. <br>  <a href="http://cxem.net/izmer/izmer112.php">USB function generator on AD9833.</a>  Based on the DDS chip. <br>  <a href="http://qsl.net/ew6gb/mini_dds.html">Mini DDS is the simplest transmitter for the 137 kHz range and not only.</a>  The frequency is 136 kHz. <br>  <a href="http://www.cqham.ru/ddsfunc.html">DDS is a functional generator with ‚Äújumper‚Äù control on the PLA.</a> </div><p>Source: <a href="https://habr.com/ru/post/260999/">https://habr.com/ru/post/260999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260987/index.html">Go away HTML, go away</a></li>
<li><a href="../260989/index.html">Messenger spam: is the law broken?</a></li>
<li><a href="../260991/index.html">Getting rid of "historical causes" in cmd.exe</a></li>
<li><a href="../260993/index.html">Solving sparse SLAEs of large dimensions using ManagedCuda in .NET</a></li>
<li><a href="../260995/index.html">The general concept of the direction SafeCityNET</a></li>
<li><a href="../261001/index.html">Product or service</a></li>
<li><a href="../261003/index.html">Linux Profiling Mechanisms</a></li>
<li><a href="../261005/index.html">TKGate - an open-source digital circuit simulator: the project is alive again</a></li>
<li><a href="../261007/index.html">How to pass "test free data recovery software" (part 2)</a></li>
<li><a href="../261011/index.html">About interviews (by Eric Lippert)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>