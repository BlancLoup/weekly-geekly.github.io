<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Under the hood Redis: Hash table (part 2) and List</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, I said that the hash table is a bit of a LIST , SET, and SORTED SET . Judge for yourself - LIST consists of ziplist / linkedlist, S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Under the hood Redis: Hash table (part 2) and List</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/271205/">first part,</a> I said that the hash table is a bit of a <i>LIST</i> , <i>SET,</i> and <i>SORTED SET</i> .  Judge for yourself - <i>LIST</i> consists of ziplist / linkedlist, <i>SET</i> consists of dict / intset, and <i>SORTED SET</i> is ziplist / skiplist.  We have already reviewed the dictionary (dict), and in the second part of the article we will consider the structure of the ziplist - the second most frequently applicable structure under the hood of Redis.  Let's look at <i>LIST</i> - the second part of its ‚Äúkitchen‚Äù is a simple implementation of a linked list.  This is useful to us to carefully consider the frequently mentioned advice on optimizing hash tables through their replacement with lists.  Calculate how much memory is required for overhead when using these structures, what price you pay for saving memory.  Let's summarize when working with hash tables, when using encoding in a ziplist. <br><br>  Last time we ended up with the fact that 1,000,000 keys saved using ziplist occupied <b>16 MB</b> of RAM, while in dict the same data required <b>104 MB</b> (ziplist is 6 times less!).  Let's figure out what price: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/480/885/4d9/4808854d974943468c8a710a62ee563f.jpg"></div><br><a name="habracut"></a><br>  So a ziplist is a doubly linked list.  Unlike a regular linked list, here the links in each node point to the previous one and to the next node in the list.  With a doubly linked list, you can efficiently move in any direction, either towards the beginning or towards the end.  In this list, it is easier to remove and rearrange elements, since the addresses of those elements of the list whose pointer points to the variable element are easily accessible.  The Redis developers are positioning their implementation as efficient in terms of memory.  The list is able to store strings and integers, while the numbers are stored in the form of numbers, and not redisObject with a value.  And if you want to save the string ‚Äú123,‚Äù it will save as the number 123, and not the sequence of characters `1`,` 2`, `3`. <br><blockquote>  In the 1.x Redis branch, instead of dict, a zipmap was used in the dictionary - a straightforward (~ 140 lines) implementation of a linked list, optimized for memory savings, where all operations occupy O (n).  This structure is not used in Redis (although it is in its source code and is maintained up to date), while some of the zipmap ideas formed the basis of the ziplist. </blockquote><br>  The key and values ‚Äã‚Äãare stored as one after the other in the list.  Operations on the list is a search for a key, through enumeration and work with the value that is located in the next element of the list.  Theoretically, insert and change operations are performed in constant <b>O (1)</b> .  In fact, any such operation in the implementation of Redis requires the allocation and redistribution of memory and the real complexity directly depends on the amount of memory already used.  In this case, we remember about <i>O (1)</i> as an ideal case and <b>O (n)</b> - as the worst. <br><pre><code class="bash hljs">+-------------+------+-----+-------+-----+-------+-----+ | Total Bytes | Tail | Len | Entry | ... | Entry | End | +-------------+------+-----+-------+-----+-------+-----+ ^ | +-------------------+--------------+----------+------+-------------+----------+-------+ | Prev raw len size | Prev raw len | Len size | Len | Header size | Encoding | Value | +-------------------+--------------+----------+------+-------------+----------+-------+</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Look at this structure in the source code.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZIPLIST_HEADER_SIZE (sizeof(uint32_t)*2+sizeof(uint16_t)) typedef struct zlentry { unsigned int prevrawlensize, prevrawlen; unsigned int lensize, len; unsigned int headersize; unsigned char encoding; unsigned char *p; } zlentry;</span></span></code> </pre><br></div></div><br>  Let's calculate its size. <br><blockquote>  The answer to the question how much memory will actually be used depends on the operating system, the compiler, the type of your process and the allocator used (in redis, by default, jemalloc).  All further calculations I cite for redis 3.0.5 compiled on a 64 bit server running centos 7. </blockquote><br>  Everything is simple with the header - this is <i>ZIPLIST_HEADER_SIZE</i> (constant, defined in ziplist.c and equal to <b>sizeof (uint32_t) * 2 + sizeof (uint16_t) + 1</b> ).  The element size is <b>5 * size_of (unsigned int) + 1 + 1 <sup>at least 1 byte per value</sup></b> .  Total overhead for storing data in this encoding for <b>n</b> elements (not including the value): <br><blockquote>  <b>12 + 21 * n</b> </blockquote><br>  Each element begins with a fixed header consisting of several pieces of information.  The first is the size of the previous item and is used to go back through the doubly linked list.  The second is the encoding with the optional length of the structure itself in bytes.  The length of the previous element works as follows: if the length does not exceed 254 bytes (it is the constant <i>ZIP_BIGLEN</i> ), then 1 byte will be used to store the length of the value.  If the length is greater than or equal to 254, 5 bytes will be used.  In this case, the first byte will be set to the constant value ZIP_BIGLEN, so that we understand that we have a long value.  The remaining 4 bytes store the length of the previous value.  The third is the header, which depends on the value contained in the node.  If the value is a string - the first 2 bits of the header field of the header will store the type of encoding for the length of the string, followed by a number with the length of the string.  If the values ‚Äã‚Äãare integer, the first 2 bits will be set to one.  For numbers, another 2 bits are used, which determine what dimension the integer is stored in it. <br><div class="spoiler">  <b class="spoiler_title">Decryption of the title, for those who want to be confused</b> <div class="spoiler_text"><table><tbody><tr><th>  How lies </th><th>  <nobr>Byte</nobr> </th><th>  What lies </th></tr><tr><td>  | 00pppppp | </td><td>  one </td><td>  A string that is less than or equal to <b>63 bytes</b> (i.e., sds with <i>REDIS_ENCODING_EMBSTR</i> , see the <a href="http://habrahabr.ru/post/271487/">first part of the series</a> ) </td></tr><tr><td>  | 01pppppp | B <sup>1 byte</sup> | </td><td>  2 </td><td>  A string that is less than or equal to <b>16383 bytes</b> (14 bits) </td></tr><tr><td>  <nobr>| 10 ______ | BBBBB</nobr> <sup>4 bytes</sup> | </td><td>  five </td><td>  A string whose value is greater than or equal to <b>16384 bytes</b> </td></tr><tr><td>  | 11000000 | </td><td>  one </td><td>  Integer, int16_t ( <b>2 bytes</b> ) </td></tr><tr><td>  | 11010000 | </td><td>  one </td><td>  Integer, int32_t ( <b>4 bytes</b> ) </td></tr><tr><td>  | 11100000 | </td><td>  one </td><td>  Integer, int64_t ( <b>8 bytes</b> ) </td></tr><tr><td>  | 11110000 | </td><td>  one </td><td>  Integer with a sign that will fit in 24 bits ( <b>3 bytes</b> ) </td></tr><tr><td>  | 11111110 | </td><td>  one </td><td>  An integer with a sign that ‚Äúfits‚Äù into 8 bits ( <b>1 byte</b> ) </td></tr><tr><td>  | 1111xxxx | </td><td>  one </td><td>  Where xxxx is between 0000 and 1101, it means an integer that ‚Äúfits‚Äù into 4 bits.  Without a signed integer from 0 to 12. The decoded value is in fact from 1 to 13, because 0000 and 1111 are already occupied and we always subtract 1 from the decoded value to get the desired value. </td></tr><tr><td>  | 11111111 | </td><td>  one </td><td>  End of list marker </td></tr></tbody></table><br></div></div><br>  Check and look at the reverse side of the coin.  We will use LUA, so you do not need anything other than Redis to repeat this test yourself.  At first we look that turns out when using dict. <br>  Will execute <br><pre> <code class="bash hljs">multi time <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> <span class="hljs-string"><span class="hljs-string">"for i=0,10000,1 do redis.call('hset', 'test', i, i) end"</span></span> 0 time</code> </pre><br>  and <br><pre> <code class="bash hljs">multi time <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> <span class="hljs-string"><span class="hljs-string">"for i=0,10000,1 do redis.call('hget', 'test', i) end"</span></span> 0 time</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Output from redis = cli</b> <div class="spoiler_text"><pre> <code class="bash hljs">config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-max-ziplist-entries 1 +OK config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>-max-ziplist-value 1000000 +OK flushall +OK info memory <span class="hljs-variable"><span class="hljs-variable">$225</span></span> <span class="hljs-comment"><span class="hljs-comment"># Memory used_memory:508536 multi +OK time +QUEUED eval "for i=0,10000,1 do redis.call('hset', 'test', i, i) end" 0 +QUEUED time +QUEUED exec *3 *2 $10 1449161639 $6 948389 $-1 *2 $10 1449161639 $6 967383 debug object test +Value at:0x7fd9864d6470 refcount:1 encoding:hashtable serializedlength:59752 lru:6321063 lru_seconds_idle:23 info memory $226 # Memory used_memory:1025432 multi +OK time +QUEUED eval "for i=0,10000,1 do redis.call('hget', 'test', i) end" 0 +QUEUED time +QUEUED exec *3 *2 $10 1449161872 $6 834303 $-1 *2 $10 1449161872 $6 841819 flushall +OK info memory $226 # Memory used_memory:510152 config set hash-max-ziplist-entries 100000 +OK multi +OK time +QUEUED eval "for i=0,10000,1 do redis.call('hset', 'test', i, i) end" 0 +QUEUED time +QUEUED exec *3 *2 $10 1449162574 $6 501852 $-1 *2 $10 1449162575 $6 212671 debug object test +Value at:0x7fd9864d6510 refcount:1 encoding:ziplist serializedlength:59730 lru:6322040 lru_seconds_idle:19 info memory $226 # Memory used_memory:592440 multi +OK time +QUEUED eval "for i=0,10000,1 do redis.call('hget', 'test', i) end" 0 +QUEUED time +QUEUED exec *3 *2 $10 1449162616 $6 269561 $-1 *2 $10 1449162616 $6 975149</span></span></code> </pre><br></div></div><br>  In the case of encoding: hashtable (dict) spent ~ 516 kb of memory and 18.9 ms to save 10,000 values, 7.5 ms to read them.  With encoding: ziplist we get ~ 81 kb of memory and 710 ms to save, 705 ms to read.  For the test of 10,000 records received: <br><blockquote>  <b>The <u>memory</u> gain <u>is 6 times the</u> cost of a write speed of <u>37.5 times</u> and <u>94 times</u> of reading.</b> </blockquote><br>  It is important to understand that the drop in performance is not linear, and already for 1,000,000 you risk simply not waiting for the results.  Who will add 10,000 items to the ziplist?  This, unfortunately, is one of the first recommendations from most consultants.  When is the game worth the candle?  I would say that while the number of elements is in the range of 1 - 3500 elements you can choose, remembering that ziplist always wins 6 times or more from memory.  Anything more is measured on your real data, but it will have nothing to do with loaded real-time systems.  Here is what happens with the read / write performance depending on the size of the hash on dict and ziplist ( <a href="https://gist.github.com/misterion/78793fe1f536332dc0e0">gist per test</a> ): <br><img src="https://habrastorage.org/files/5c7/3d9/92a/5c73d992a5d94b4d96a9ee9b038c20c8.png"><br>  Why is that?  The price of insertion, changing the length of elements and deleting a ziplist is monstrous - this is either realloc (all work falls on the allocator's shoulders) or a complete rebuilding of the list from <b>n + 1</b> from the modified element to the end of the list.  Rebuilding is a lot of small realloc, memmove, memcpy (see <i>__ziplistCascadeUpdate</i> in ziplist.c). <br><br>  Why is it important to talk about LIST in an article about HASH?  The point is one very important advice about optimizing structured data.  Went it seems from <a href="https://www.datadoghq.com/">DataDog</a> , I find it difficult to say exactly.  Translated as follows <a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-Memory-Optimization">(original)</a> : <br><blockquote>  You store your users' data in Redis, for example, `hmset user: 123 id 123 firstname Ivan lastname Ivanov location Tomsk twitter ivashka`.  Now, if you create another user, you will spend empty memory on the field names - id, firstname, lastname, etc.  If there are many such users, this is a lot of memory that has been dropped (we already have to count how many - for this set of fields, 384 bytes per user). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So if you have <br><ol><li>  You have a lot of objects, say 50,000 or more. </li><li>  Your objects have a regular structure (in fact, always all the fields) </li></ol><br>  You can use the concept of <a href="http://docs.python.org/library/collections.html">named</a> python <a href="http://docs.python.org/library/collections.html">tuples</a> - a linear list with read-only access, around which you can build a hash table with your hands.  Roughly speaking ‚Äúfisrtname‚Äù is the value of the 0 index of the list, ‚Äúlastname‚Äù of the first, and so on.  Then the creation of the user will look like `lpush user: 123 Ivan Ivanov Tomsk ivashka`. </blockquote><br>  And this is a very useful tip.  Obviously, the list (LIST) will help you save a lot - at least 2 times. <br><blockquote>  As in HASH, with the help of list-max-ziplist-entries / list-max-ziplist-val you control which internal data type the specific list key will be represented.  For example, if list-max-ziplist-entries = 100, your LIST will be represented as <i>REDIS_ENCODING_ZIPLIST</i> , as long as it contains less than 100 items.  As soon as there are more items, it will be converted to <i>REDIS_ENCODING_LINKEDLIST</i> .  The list-max-ziplist-val setting works in the same way as hash-max-ziplist-val (see the <a href="http://habrahabr.ru/post/271205/">first part</a> ). <br></blockquote><br>  We have already figured out the <i>ziplist</i> , let's watch <i>REDIS_ENCODING_LINKEDLIST</i> .  In the implementation of Redis, this is a very simple (~ 270 lines of code) not sorted singly-linked list ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA">just like in wikipedia</a> ).  With all its advantages and disadvantages: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">listNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">listNode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">listNode</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *value; } listNode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> {</span></span> listNode *head; listNode *tail; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *(*dup)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*match)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *key); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> len; } <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>;</code> </pre><br>  Nothing complicated - each LIST in this encoding is 5 pointers and 1 unsigned long.  So the overhead is <b>5 * size_of (pointer) + 8 bytes</b> .  And each node is 3 pointers.  The overhead for storing data in this encoding for <b>n</b> elements is: <br><blockquote>  <b>5 * size_of (pointer) + 8 + n * 3 * size_of (pointer)</b> </blockquote><br>  There is no realloc in the linkedlist implementation - only memory allocation for the fragment you need, in the meanings - redisObect without any tricks or optimizations.  According to the memory overhead, the difference in service costs between the ziplist and the linkedlist is about 15%.  If we consider the service data plus values ‚Äã‚Äã- at times (from 2 and above), depending on the type of value.  So for a list of 10,000 items, consisting only of numbers in a ziplist, you will spend about 41 kb of memory; the linkedlist contains 360 kb of real memory: <br><pre> <code class="bash hljs">config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> list-max-ziplist-entries 1 +OK flushall +OK info memory <span class="hljs-variable"><span class="hljs-variable">$226</span></span> <span class="hljs-comment"><span class="hljs-comment"># Memory used_memory:511544 eval "for i=0,10000,1 do redis.call('lpush', 'test', i) end" 0 $-1 debug object test +Value at:0x7fd9864d6530 refcount:1 encoding:linkedlist serializedlength:29877 lru:6387397 lru_seconds_idle:5 info memory $226 # Memory used_memory:832024 config set list-max-ziplist-entries 10000000 +OK flushall +OK info memory $226 # Memory used_memory:553144 eval "for i=0,10000,1 do redis.call('lpush', 'test', i) end" 0 $-1 info memory $226 # Memory used_memory:594376 debug object test +Value at:0x7fd9864d65e0 refcount:1 encoding:ziplist serializedlength:79681 lru:6387467 lru_seconds_idle:16</span></span></code> </pre><br>  Let's look at the difference in performance when writing and receiving an item through LPOP (read and delete).  Why not <a href="http://redis.io/commands/lrange">LRANGE</a> - its complexity is designated as <b>O (S + N)</b> and for both implementations of the list this time is constant.  With <a href="http://redis.io/commands/lpop">LPOP</a> , everything is not quite as written in the documentation - complexity is indicated as O (1).  But what happens if I need sequential reading to read everything: <br><img src="https://habrastorage.org/files/2e4/4b7/f47/2e44b7f477d34cd8a576b96f8a0a9dd1.png"><br>  What is wrong with reading speed when using ziplist?  Each `LPOP` is an extraction of the element c at the beginning of the list with its complete rebuilding.  By the way, if we use RPOP in reading, instead of LPOP, the situation will not change much (hello to realloc from the list refresh function in ziplist.c).  Why is it important?  The <a href="http://redis.io/commands/rpoplpush">RPOPLPUSH</a> / <a href="http://redis.io/commands/brpoplpush">BRPOPLPUSH commands are a</a> popular solution for queuing based on Redis (for example, Sidekiq, Resque).  When in such a queue with a ziplist encoding, a large number of values ‚Äã‚Äã(from several thousand) is provided - the receipt of one element is no longer constant and the system begins to ‚Äúfever‚Äù. <br><br>  At the end it is time to formulate several conclusions: <br><ul><li>  It will not work for you to use ziplist in hash tables with a large number of values ‚Äã‚Äã(from 1000), if performance is still important for you with a large write volume. </li><li>  If the data in your hash table has a regular structure - forget about the hash table and proceed to storing data in lists. </li><li>  Whatever type of encoding you use - Redis is ideal for numbers, acceptable for strings with a length of up to 63 bytes and not unique when storing larger strings. </li><li>  If there are a lot of lists in your system, remember that while they are small (before list-max-ziplist-entries), you spend little memory and everything is generally acceptable in terms of performance, but as soon as they start to grow, memory can grow dramatically from 2 times and higher jumps, and the process of changing the encoding will take considerable time (re-creation with sequential insertion + deletion). </li><li>  Be careful with the list view (list-max- * settings) if you use a list for building queues or active writing / reading and deleting.  Or otherwise, if you use Redis to build queues based on lists, set list-max-ziplist-entries = 1 (you will still spend just a little more memory) </li><li>  Redis never gives away the memory already allocated by the system.  Consider the overhead of service information and strategy for resizing - with active recording, you can greatly increase memory fragmentation due to this feature and spend up to 2 times more RAM than you expect.  This is especially important when you run N instances of Redis on the same physical server. </li><li>  If it is important for you to store data that is heterogeneous in terms of volume and access speed on one Redis - think about adding a little Redis code and go to setting up list-max- * parameters for each key, instead of a server. </li><li>  The encodings of the same type of data on the master / slave may vary, which allows you to be more flexible in meeting the requirements ‚Äî for example, quickly and with a large memory consumption for reading, slower and more economical in memory on the slave or vice versa. </li><li>  Overhead when using a ziplist is minimal, storing lines is cheaper in a ziplist than in any other structure (the top zedry is only 21 bytes per line, while the traditional representation of redisObject + sds line is 56 bytes). </li></ul><br>  Table of contents: <br><ul><li>  <a href="http://habrahabr.ru/post/271487/">Under the hood Redis: Strings</a> <br></li><li>  <a href="http://habrahabr.ru/post/271205/">Under the hood Redis: Hash table (part 1)</a> <br></li><li>  Under the hood Redis: Hash table (part 2) and List <br></li></ul><br>  The materials used in writing the article: <br><ul><li>  <a href="https://github.com/antirez/redis/tree/3.0.5/src">Redis 3.0.5 sources</a> </li><li>  <a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-Memory-Optimization">github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-Memory-Optimization</a> </li><li>  <a href="http://redis.io/topics/memory-optimization">redis.io/topics/memory-optimization</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/272089/">https://habr.com/ru/post/272089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272075/index.html">Creating a desktop application with Electron and web technologies</a></li>
<li><a href="../272077/index.html">How to send an IDoc from SAP MII to SAP ERP</a></li>
<li><a href="../272083/index.html">NetApp becomes more efficient with inline dedupe</a></li>
<li><a href="../272085/index.html">8 principles of development planning, simplifying life</a></li>
<li><a href="../272087/index.html">Measurement of productivity of functions in JavaScript</a></li>
<li><a href="../272091/index.html">Payment conversion: 4 reasons that reduce the success of payment on your site and how to eliminate them</a></li>
<li><a href="../272093/index.html">Network equipment at risk? Let's understand ...</a></li>
<li><a href="../272095/index.html">Corporate use of Android 5.0: security recommendations</a></li>
<li><a href="../272099/index.html">PHP 7.0.0</a></li>
<li><a href="../272101/index.html">SQLi is still in service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>