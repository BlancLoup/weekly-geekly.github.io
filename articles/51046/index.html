<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classes of types, monads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of today's article will be classes of types, some standard ones, syntactic sugar with their use, and a class of monads. 
 Classes introduce ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classes of types, monads</h1><div class="post__text post__text-html js-mediator-article">  The topic of today's article will be classes of types, some standard ones, syntactic sugar with their use, and a class of monads. <br>  Classes introduce dynamic polymorphism, as well as interfaces in traditional imperative languages, and can also be used as replacements for functions overloading that is missing in Haskell. <br>  I will tell you how to define a type class, its instances and how it is all arranged inside. <br><br>  Previous articles: <br>  <a href="http://habrahabr.ru/blogs/Haskell/50600/">Data Types, Pattern Matching and Functions</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/50310/">The basics</a> <br><a name="habracut"></a><br><h4>  Type Classes </h4><br>  Suppose you have written your data type and want to write a comparison operator for it.  The problem is that there is no overloading of functions in Haskell and therefore cannot be used for this purpose (==).  Moreover, to invent a new name for each type is not an option. <br>  But you can define a ‚Äúcompare‚Äù type class.  Then, if your data type belongs to this class, values ‚Äã‚Äãof this type can be compared. <br><blockquote><code><b><font color="#0080FF">class</font></b> MyEq a <b><font color="#0080FF">where</font></b> <br> myEqual <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> Bool <br> myNotEqual <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> Bool</code> </blockquote>  <code>MyEq</code> is the name of the type class (like data types, it must begin with a capital letter), <code>a</code> is a type belonging to this class.  A class can have several <code>FooClass abc</code> ( <code>FooClass abc</code> ), but in this case only one. <br>  Type <code>a</code> belongs to the class <code>MyEq</code> , if corresponding functions are defined for it. <br>  In a class, you can define a default function.  For example, the functions <code>myEqual</code> and <code>myNotEqual</code> can be expressed through each other: <br><blockquote> <code>myEqual xy <font color="#8000FF">=</font> not <font color="#8000FF">(</font> myNotEqual xy <font color="#8000FF">)</font> <br> myNotEqual xy <font color="#8000FF">=</font> not <font color="#8000FF">(</font> myEqual xy <font color="#8000FF">)</font></code> </blockquote>  Such definitions will lead to infinite recursion, but in an instance of a class it is enough to define at least one of them. <br>  Now we‚Äôll write a class instance for <code>Bool</code> : <br><blockquote> <code><b><font color="#0080FF">instance</font></b> MyEq Bool <b><font color="#0080FF">where</font></b> <br> myEqual True True <font color="#8000FF">=</font> True <br> myEqual False False <font color="#8000FF">=</font> True <br> myEqual <b><font color="#0080FF">_</font></b> <b><font color="#0080FF">_</font></b> <font color="#8000FF">=</font> False</code> </blockquote>  An instance definition begins with the keyword <code><b><font color="#0080FF">instance</font></b></code> , instead of a variable of type <code>a</code> in the definition of the class itself, we write the type for which the instance is defined, i.e.  <code>Bool</code> . <br>  We define one function <code>myEqual</code> and now we can check the result in the interpreter: <br><blockquote> <code>ghci&gt; myEqual True True <br> True <br> ghci&gt; myNotEqual True False <br> True <br> ghci&gt; :t myEqual <br> myEqual :: (MyEq a) =&gt; a -&gt; a -&gt; Bool</code> </blockquote>  We see that the type of the <code>myEqual</code> function imposes a constraint (constraints) on the type - it must belong to the class <code>MyEq</code> . <br>  The same restrictions can be applied when declaring the class itself: <br><blockquote> <code><b><font color="#0080FF">class</font></b> <font color="#8000FF">(</font> MyEq a <font color="#8000FF">)</font> <font color="#8000FF">=&gt;</font> SomeClass a <b><font color="#0080FF">where</font></b> <br> <font color="#008080">-- ...</font></code> </blockquote> <br>  Classes are somewhat similar to interfaces - we declare functions for which we then provide implementations.  Other functions can use these functions only if for some type there is such an implementation. <br>  However, there are significant differences both in capabilities and in the implementation of the mechanism itself. <br><ol><li>  As seen in the <code>myEqual</code> function, it takes two values ‚Äã‚Äãof type <code>a</code> , whereas the virtual function takes only one hidden parameter <code>this</code> . <br>  Even if we have an <code><b><font color="#0080FF">instance</font></b> MyEq Bool</code> and an <code><b><font color="#0080FF">instance</font></b> MyEq Int</code> , a call to the function <code>myEqual True <font color="#80C000">5</font></code> will fail: <br><blockquote> <code>ghci&gt; myEqual True (5::Int) <br> <br> &lt;interactive&gt;:1:14: <br> Couldn't match expected type `Bool' against inferred type `Int' <br> In the second argument of `myEqual', namely `(5::Int)' <br> In the expression: myEqual True (5 :: Int) <br> In the definition of `it': it = myEqual True (5 :: Int) <br> ghci&gt;</code> </blockquote>  The compiler (interpreter) knows that <code>myEqual</code> parameters must be of the same type and therefore prevents such attempts. </li><li>  A class instance can be defined at any time, which is also very convenient.  Inheritance from interfaces is specified when defining the class itself. </li><li>  The function may require that the data type belong to several classes at once: <br><blockquote> <code>foo <font color="#8000FF">::</font> <font color="#8000FF">(</font> Eq a <font color="#8000FF">,</font> Show a <font color="#8000FF">,</font> Read a <font color="#8000FF">)</font> <font color="#8000FF">=&gt;</font> a <font color="#8000FF">-&gt;</font> String <font color="#8000FF">-&gt;</font> String</code> </blockquote>  How to do this, for example, in C ++ / C #?  Create a composite <code>IEquableShowableReadable</code> ?  But you will not inherit from it.  Pass the argument three times with coercion to different interfaces and assume inside the function that it is the same object, and the responsibility lies with the caller? </li></ol><br>  Since I already mentioned C ++, at the same time I would say that in the new C ++ 0x standard, <a href="http://en.wikipedia.org/wiki/C%2B%2B0x">concept and concept_map</a> are the essence of type classes, but used at the compilation stage :) <br><br>  But there is a drawback.  How do we get a list of objects that, for example, belong to the class <code>Show</code> (function <code>show <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> String</code> )? <br>  There is a way, but it is non-standard.  At the top of the file you need to add the appropriate GHC options: <br><blockquote> <code><font color="#008080">{-# <br> OPTIONS_GHC <br> -XExistentialQuantification <br> #-}</font> <br> <font color="#008080">--  , ,    TAB' GHC  </font></code> </blockquote>  Now we can declare this data type: <br><blockquote> <code><b><font color="#0080FF">data</font></b> ShowObj <font color="#8000FF">=</font> <b><font color="#0080FF">forall</font></b> a <font color="#8000FF">.</font> Show a <font color="#8000FF">=&gt;</font> ShowObj a</code> </blockquote>  (Read more about <a href="http://haskell.org/haskellwiki/Existential_type">existential types</a> ) <br>  And at the same time to determine for him an instance of the class <code>Show</code> , so that he himself also belonged to him: <br><blockquote> <code><b><font color="#0080FF">instance</font></b> Show ShowObj <b><font color="#0080FF">where</font></b> <br> show <font color="#8000FF">(</font> ShowObj x <font color="#8000FF">)</font> <font color="#8000FF">=</font> show x</code> </blockquote>  Check: <br><blockquote> <code>ghci&gt; [ShowObj 4, ShowObj True, ShowObj (ShowObj 'x')] <br> [4,True,'x']</code> </blockquote>  Although I didn‚Äôt explicitly call the <code>show</code> function, the interpreter uses it, so you can be sure that everything works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  How is all this implemented? </h4><br>  In the function that imposes restrictions on the type, a hidden parameter is passed (for each class and type - its own) - a dictionary with all the necessary functions. <br>  In fact, an <code><b><font color="#0080FF">instance</font></b></code> is the definition of a dictionary instance for a particular type. <br>  To make it easier to understand, I just give a pseudo-implementation for the <code>Eq</code> in Haskell and in C ++: <br><blockquote> <code><font color="#008080">-- class MyEq</font> <br> <b><font color="#0080FF">data</font></b> MyEq a <font color="#8000FF">=</font> MyEq <font color="#8000FF">{</font> <br> myEqual <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> Bool <font color="#8000FF">,</font> <br> myNotEqual <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> Bool <font color="#8000FF">}</font> <br> <br> <font color="#008080">-- instance MyEq Bool</font> <br> myEqBool <font color="#8000FF">=</font> MyEq <font color="#8000FF">{</font> <br> myEqual <font color="#8000FF">=</font> <font color="#8000FF">\</font> xy <font color="#8000FF">-&gt;</font> x <font color="#8000FF">==</font> y <font color="#8000FF">,</font> <br> myNotEqual <font color="#8000FF">=</font> <font color="#8000FF">\</font> xy <font color="#8000FF">-&gt;</font> not <font color="#8000FF">(</font> x <font color="#8000FF">==</font> y <font color="#8000FF">)</font> <font color="#8000FF">}</font> <br> <br> <font color="#008080">-- foo :: (MyEq a) =&gt; a -&gt; a -&gt; Bool</font> <br> foo <font color="#8000FF">::</font> MyEq a <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> Bool <br> foo dict xy <font color="#8000FF">=</font> <font color="#8000FF">(</font> myEqual dict <font color="#8000FF">)</font> xy <br> <font color="#008080">-- foo True False</font> <br> fooResult <font color="#8000FF">=</font> foo myEqBool True False</code> </blockquote>  The same on C ++: <br><blockquote> <code><font color="#339900">#include &lt;iostream&gt;</font> &lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">// class MyEq a</font> &lt;br/&gt; <br> <font color="#0000ff">class</font> MyEq&lt;br/&gt; <br> <font color="#008000">{</font> &lt;br/&gt; <br> <font color="#0000ff">public</font> <font color="#008080">:</font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> ~MyEq <font color="#008000">(</font> <font color="#008000">)</font> <font color="#0000ff">throw</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#008000">}</font> &lt;br/&gt; <br> <font color="#666666">//  void const *,        </font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> unsafeMyEqual <font color="#008000">(</font> <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> x, <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> y <font color="#008000">)</font> <font color="#0000ff">const</font> <font color="#000080">=</font> <font>0</font> ;&lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> unsafeMyNotEqual <font color="#008000">(</font> <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> x, <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> y <font color="#008000">)</font> <font color="#0000ff">const</font> <font color="#000080">=</font> <font>0</font> ;&lt;br/&gt; <br> <font color="#008000">}</font> ;&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">//  ,      </font> &lt;br/&gt; <br> <font color="#666666">//   </font> &lt;br/&gt; <br> <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">typename</font> T <font color="#000080">&gt;</font> &lt;br/&gt; <br> <font color="#0000ff">class</font> MyEqDictBase <font color="#008080">:</font> <font color="#0000ff">public</font> MyEq&lt;br/&gt; <br> <font color="#008000">{</font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> unsafeMyEqual <font color="#008000">(</font> <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> x, <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> y <font color="#008000">)</font> <font color="#0000ff">const</font> &lt;br/&gt; <br> <font color="#008000">{</font> <font color="#0000ff">return</font> myEqual <font color="#008000">(</font> <font color="#000040">*</font> <font color="#0000ff">static_cast</font> <font color="#000080">&lt;</font> T <font color="#0000ff">const</font> <font color="#000040">*</font> <font color="#000080">&gt;</font> <font color="#008000">(</font> x <font color="#008000">)</font> , <font color="#000040">*</font> <font color="#0000ff">static_cast</font> <font color="#000080">&lt;</font> T <font color="#0000ff">const</font> <font color="#000040">*</font> <font color="#000080">&gt;</font> <font color="#008000">(</font> y <font color="#008000">)</font> <font color="#008000">)</font> ; <font color="#008000">}</font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> unsafeMyNotEqual <font color="#008000">(</font> <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> x, <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> y <font color="#008000">)</font> <font color="#0000ff">const</font> &lt;br/&gt; <br> <font color="#008000">{</font> <font color="#0000ff">return</font> myNotEqual <font color="#008000">(</font> <font color="#000040">*</font> <font color="#0000ff">static_cast</font> <font color="#000080">&lt;</font> T <font color="#0000ff">const</font> <font color="#000040">*</font> <font color="#000080">&gt;</font> <font color="#008000">(</font> x <font color="#008000">)</font> , <font color="#000040">*</font> <font color="#0000ff">static_cast</font> <font color="#000080">&lt;</font> T <font color="#0000ff">const</font> <font color="#000040">*</font> <font color="#000080">&gt;</font> <font color="#008000">(</font> y <font color="#008000">)</font> <font color="#008000">)</font> ; <font color="#008000">}</font> &lt;br/&gt; <br> <font color="#0000ff">public</font> <font color="#008080">:</font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> myEqual <font color="#008000">(</font> T <font color="#0000ff">const</font> <font color="#000040">&amp;</font> x, T <font color="#0000ff">const</font> <font color="#000040">&amp;</font> y <font color="#008000">)</font> <font color="#0000ff">const</font> <font color="#008000">{</font> <font color="#0000ff">return</font> <font color="#000040">!</font> myNotEqual <font color="#008000">(</font> x, y <font color="#008000">)</font> ; <font color="#008000">}</font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> myNotEqual <font color="#008000">(</font> T <font color="#0000ff">const</font> <font color="#000040">&amp;</font> x, T <font color="#0000ff">const</font> <font color="#000040">&amp;</font> y <font color="#008000">)</font> <font color="#0000ff">const</font> <font color="#008000">{</font> <font color="#0000ff">return</font> <font color="#000040">!</font> myEqual <font color="#008000">(</font> x, y <font color="#008000">)</font> ; <font color="#008000">}</font> &lt;br/&gt; <br> <font color="#008000">}</font> ;&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">//  .    .</font> &lt;br/&gt; <br> <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">typename</font> T <font color="#000080">&gt;</font> &lt;br/&gt; <br> <font color="#0000ff">class</font> MyEqDict;&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">//      </font> &lt;br/&gt; <br> <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">typename</font> T <font color="#000080">&gt;</font> &lt;br/&gt; <br> MyEqDict <font color="#000080">&lt;</font> T <font color="#000080">&gt;</font> makeMyEqDict <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0000ff">return</font> MyEqDict <font color="#000080">&lt;</font> T <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> ; <font color="#008000">}</font> &lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">// instance MyEq Bool</font> &lt;br/&gt; <br> <font color="#666666">//   MyEq  bool</font> &lt;br/&gt; <br> <font color="#0000ff">template</font> <font color="#000080">&lt;&gt;</font> &lt;br/&gt; <br> <font color="#0000ff">class</font> MyEqDict <font color="#000080">&lt;</font> <font color="#0000ff">bool</font> <font color="#000080">&gt;</font> <font color="#008080">:</font> <font color="#0000ff">public</font> MyEqDictBase <font color="#000080">&lt;</font> <font color="#0000ff">bool</font> <font color="#000080">&gt;</font> &lt;br/&gt; <br> <font color="#008000">{</font> &lt;br/&gt; <br> <font color="#0000ff">public</font> <font color="#008080">:</font> &lt;br/&gt; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> myEqual <font color="#008000">(</font> <font color="#0000ff">bool</font> <font color="#0000ff">const</font> <font color="#000040">&amp;</font> l, <font color="#0000ff">bool</font> <font color="#0000ff">const</font> <font color="#000040">&amp;</font> r <font color="#008000">)</font> <font color="#0000ff">const</font> <font color="#008000">{</font> <font color="#0000ff">return</font> l <font color="#000080">==</font> r; <font color="#008000">}</font> &lt;br/&gt; <br> <font color="#008000">}</font> ;&lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">//      </font> &lt;br/&gt; <br> <font color="#666666">// ,       bool,   Haskell'</font> &lt;br/&gt; <br> <font color="#0000ff">bool</font> fooDict <font color="#008000">(</font> MyEq <font color="#0000ff">const</font> <font color="#000040">&amp;</font> dict, <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> x, <font color="#0000ff">void</font> <font color="#0000ff">const</font> <font color="#000040">*</font> y <font color="#008000">)</font> &lt;br/&gt; <br> <font color="#008000">{</font> &lt;br/&gt; <br> <font color="#0000ff">return</font> dict. <font color="#007788">unsafeMyNotEqual</font> <font color="#008000">(</font> x, y <font color="#008000">)</font> ; <font color="#666666">// myNotEqual</font> &lt;br/&gt; <br> <font color="#008000">}</font> &lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#666666">//  </font> &lt;br/&gt; <br> <font color="#666666">// foo :: (MyEq a) =&gt; a -&gt; a -&gt; Bool</font> &lt;br/&gt; <br> <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">typename</font> T <font color="#000080">&gt;</font> &lt;br/&gt; <br> <font color="#0000ff">bool</font> foo <font color="#008000">(</font> T <font color="#0000ff">const</font> <font color="#000040">&amp;</font> x, T <font color="#0000ff">const</font> <font color="#000040">&amp;</font> y <font color="#008000">)</font> &lt;br/&gt; <br> <font color="#008000">{</font> &lt;br/&gt; <br> <font color="#0000ff">return</font> fooDict <font color="#008000">(</font> makeMyEqDict <font color="#000080">&lt;</font> T <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#000040">&amp;</font> x, <font color="#000040">&amp;</font> y <font color="#008000">)</font> ;&lt;br/&gt; <br> <font color="#008000">}</font> &lt;br/&gt; <br> &lt;br/&gt; <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> &lt;br/&gt; <br> <font color="#008000">{</font> &lt;br/&gt; <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> foo <font color="#008000">(</font> <font color="#0000ff">true</font> , <font color="#0000ff">false</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> ; <font color="#666666">// 1</font> &lt;br/&gt; <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> foo <font color="#008000">(</font> <font color="#0000ff">false</font> , <font color="#0000ff">false</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> ; <font color="#666666">// 0</font> &lt;br/&gt; <br> <font color="#0000ff">return</font> <font>0</font> ;&lt;br/&gt; <br> <font color="#008000">}</font></code> </blockquote> <br><h4>  Some standard classes and syntactic sugar </h4><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Prelude.html">Enum</a> - listing.  Defines functions for getting next / previous value, as well as value by number. <br>  Used in syntactic sugar for lists <code><font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> <font color="#80C000">10</font> <font color="#8000FF">]</font></code> , in fact, this means <code>enumFromTo <font color="#80C000">1</font> <font color="#80C000">10</font></code> , <code><font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">,</font> <font color="#80C000">3</font> <font color="#8000FF">..</font> <font color="#80C000">10</font> <font color="#8000FF">]</font> <font color="#8000FF">=&gt;</font> enumFromThenTo <font color="#80C000">1</font> <font color="#80C000">3</font> <font color="#80C000">10</font></code> <br><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Text-Show.html">Show</a> - conversion to a string, the main function <code>show <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> String</code> . <br>  Used, for example, by the interpreter to display values. <br><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Text-Read.html">Read</a> - conversion from string, the main function <code>read <font color="#8000FF">::</font> String <font color="#8000FF">-&gt;</font> a</code> . <br>  I don‚Äôt know why they chose to return the value, rather than <code>Maybe a</code> (optional value), to signal an error in a ‚Äúclean‚Äù way, rather than a ‚Äúdirty‚Äù exception. <br><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Prelude.html">Eq</a> - comparison, operators <code><font color="#8000FF">(</font> <font color="#8000FF">==</font> <font color="#8000FF">)</font></code> and <code><font color="#8000FF">(</font> <font color="#8000FF">/=</font> <font color="#8000FF">)</font></code> (as if crossed out equality sign) <br><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Prelude.html">Ord</a> - ordered types, operators <code><font color="#8000FF">(</font> <font color="#8000FF">&lt;</font> <font color="#8000FF">)</font></code> <code><font color="#8000FF">(</font> <font color="#8000FF">&gt;</font> <font color="#8000FF">)</font></code> <code><font color="#8000FF">(</font> <font color="#8000FF">&lt;=</font> <font color="#8000FF">)</font></code> <code><font color="#8000FF">(</font> <font color="#8000FF">&gt;=</font> <font color="#8000FF">)</font></code> .  Requires type belonging to class <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Prelude.html">Eq</a> . <br><br>  A more complete list of different classes can be found <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Prelude.html">here</a> . <br><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Control-Monad.html">Functor</a> - functor, function <code>fmap <font color="#8000FF">::</font> <font color="#8000FF">(</font> a <font color="#8000FF">-&gt;</font> b <font color="#8000FF">)</font> <font color="#8000FF">-&gt;</font> fa <font color="#8000FF">-&gt;</font> fb</code> . <br>  To be clear, I will give examples of the use of this function: <br><blockquote> <code>ghci&gt; fmap (+1) [1,2,3] <br> [2,3,4] <br> ghci&gt; fmap (+1) (Just 6) <br> Just 7 <br> ghci&gt; fmap (+1) Nothing <br> Nothing <br> ghci&gt; fmap reverse getLine <br> hello <br> "olleh"</code> </blockquote>  Those.  for the list, this is just a <code>map</code> , for the optional <code>Maybe a</code> value, the function <code><font color="#8000FF">(</font> <font color="#8000FF">+</font> <font color="#80C000">1</font> <font color="#8000FF">)</font></code> is used if the value is present, and for I / O the function is applied to the result of this I / O. <br>  I will write more about I / O later, for now you can just remember that <code>getLine</code> does not return a string, so you can‚Äôt directly apply <code>reverse</code> to it. <br><br>  In order not to define instances for newly written data types each time, Haskell can do this automatically for some classes. <br><blockquote> <code><b><font color="#0080FF">data</font></b> Test a <font color="#8000FF">=</font> NoValue <font color="#8000FF">|</font> Test aa <b><font color="#0080FF">deriving</font></b> <font color="#8000FF">(</font> Show <font color="#8000FF">,</font> Read <font color="#8000FF">,</font> Eq <font color="#8000FF">,</font> Ord <font color="#8000FF">)</font> <br> <b><font color="#0080FF">data</font></b> Color <font color="#8000FF">=</font> Red <font color="#8000FF">|</font> Green <font color="#8000FF">|</font> Yellow <font color="#8000FF">|</font> Blue <font color="#8000FF">|</font> Black <font color="#8000FF">|</font> Write <b><font color="#0080FF">deriving</font></b> <font color="#8000FF">(</font> Show <font color="#8000FF">,</font> Read <font color="#8000FF">,</font> Enum <font color="#8000FF">,</font> Eq <font color="#8000FF">,</font> Ord <font color="#8000FF">)</font></code> </blockquote> <blockquote> <code>ghci&gt; NoValue <font color="#8000FF">==</font> <font color="#8000FF">(</font> Test <font color="#80C000">4</font> <font color="#80C000">5</font> <font color="#8000FF">)</font> <br> False <br> ghci&gt; read <font color="#80C000">"Test 5 6"</font> <font color="#8000FF">::</font> Test Int <br> Test <font color="#80C000">5</font> <font color="#80C000">6</font> <br> ghci&gt; <font color="#8000FF">(</font> Test <font color="#80C000">1</font> <font color="#80C000">100</font> <font color="#8000FF">)</font> <font color="#8000FF">&lt;</font> <font color="#8000FF">(</font> Test <font color="#80C000">2</font> <font color="#80C000">0</font> <font color="#8000FF">)</font> <br> True <br> ghci&gt; <font color="#8000FF">(</font> Test <font color="#80C000">2</font> <font color="#80C000">100</font> <font color="#8000FF">)</font> <font color="#8000FF">&lt;</font> <font color="#8000FF">(</font> Test <font color="#80C000">2</font> <font color="#80C000">0</font> <font color="#8000FF">)</font> <br> False <br> ghci&gt; <font color="#8000FF">[</font> Red <font color="#8000FF">..</font> Black <font color="#8000FF">]</font> <br> <font color="#8000FF">[</font> Red <font color="#8000FF">,</font> Green <font color="#8000FF">,</font> Yellow <font color="#8000FF">,</font> Blue <font color="#8000FF">,</font> Black <font color="#8000FF">]</font></code> </blockquote> <br><h4>  Great and terrible monads </h4><br>  The <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Control-Monad.html">Monad</a> class is a ‚Äúcalculation‚Äù, i.e.  It allows you to describe how to combine calculations and results. <br>  It is unlikely that I will write an article better than there are already written, so I will simply give links to the best (in my opinion) articles for understanding what these monads are for. <br>  1. <a href="http://spbhug.folding-maps.org/wiki/Monads%3Faction%3DAttachFile%26do%3Dget%26target%3Dmonad.html">Monads</a> - an article with <a href="http://spbhug.folding-maps.org/wiki/">SPbHUG</a> about monads in Russian and with analogies in the usual imperative languages. <br>  2. <a href="http://haskell.org/haskellwiki/IO_inside">IO inside</a> - an English article on input and output using monads <br>  3. <a href="http://en.wikibooks.org/wiki/Haskell/YAHT">Yet Another Haskell Tutorial</a> is a book on Haskel, in the <a href="http://en.wikibooks.org/wiki/Haskell/YAHT/Monads">Monads</a> section <a href="http://en.wikibooks.org/wiki/Haskell/YAHT/Monads">it is</a> very well written using the example of creating the Computation class, which is the essence of a monad. <br><br>  Here I will write very briefly, so that you can then peep. <br>  Suppose we want to describe sequential calculations, where each of the following depends on the results of the previous one (in some way not specified in advance).  To do this, you can define the appropriate class, in which there must be at least two functions: <br><blockquote> <code><b><font color="#0080FF">class</font></b> Computation c <b><font color="#0080FF">where</font></b> <br> return <font color="#8000FF">::</font> a <font color="#8000FF">-&gt;</font> ca <br> bind <font color="#8000FF">::</font> ca <font color="#8000FF">-&gt;</font> <font color="#8000FF">(</font> a <font color="#8000FF">-&gt;</font> cb <font color="#8000FF">)</font> <font color="#8000FF">-&gt;</font> cb</code> </blockquote>  The first function essentially takes some value and returns a calculation that, when executed, will simply return the same value. <br>  The second function takes 2 arguments: <br>  1. a calculation that, when executed, will return a value of type <code>a</code> <br>  2. a function that takes a value of type <code>a</code> and returns a new calculation that returns a value of type <code>b</code> <br>  The result is a calculation that returns a value of type <code>b</code> . <br><br>  Why all this may be necessary, I will show the example of the optional value <br><blockquote> <code><b><font color="#0080FF">data</font></b> Maybe a <font color="#8000FF">=</font> Just a <font color="#8000FF">|</font> Nothing</code> </blockquote>  Suppose we have several functions, each of which can fail and return <code>Nothing</code> .  Then, using them directly, we risk getting such a weak code: <br><blockquote> <nobr><code>funOnMaybes x <font color="#8000FF">=</font> <br> <b><font color="#0080FF">case</font></b> functionMayFail1 x <b><font color="#0080FF">of</font></b> <br> Nothing <font color="#8000FF">-&gt;</font> Nothing <font color="#008080">--      ,      </font> <br> Just x1 <font color="#8000FF">-&gt;</font> <font color="#008080">-- ,     ,    </font> <br> <b><font color="#0080FF">case</font></b> functionMayFail2 x1 <b><font color="#0080FF">of</font></b> <br> Nothing <font color="#8000FF">-&gt;</font> Nothing <font color="#008080">--       (  "")</font> <br> Just x2 <font color="#8000FF">-&gt;</font> <font color="#008080">--   </font></code></nobr> </blockquote>  Those.  instead of simply calling these functions in sequence, you have to check the value each time. <br>  But after all, our language allows us to pass functions as arguments and return the same way, using: <br><blockquote> <code>combineMaybe <font color="#8000FF">::</font> Maybe a <font color="#8000FF">-&gt;</font> <font color="#8000FF">(</font> a <font color="#8000FF">-&gt;</font> Maybe b <font color="#8000FF">)</font> <font color="#8000FF">-&gt;</font> Maybe b <br> combineMaybe Nothing <b><font color="#0080FF">_</font></b> <font color="#8000FF">=</font> Nothing <br> combineMaybe <font color="#8000FF">(</font> Just x <font color="#8000FF">)</font> f <font color="#8000FF">=</font> fx</code> </blockquote>  The <code>combineMaybe</code> function accepts an optional value and function, and returns the result of applying this function to an optional value, or failure. <br>  <code>funOnMaybes</code> function: <br><blockquote> <nobr><code>funOnMaybes x <font color="#8000FF">=</font> combineMaybe <font color="#8000FF">(</font> combineMaybe x functionMayFail1 <font color="#8000FF">)</font> functionMayFail2 <font color="#8000FF">--...</font></code></nobr> </blockquote>  Or, using the fact that the function can be called infix: <br><blockquote> <nobr><code>funOnMaybes x <font color="#8000FF">=</font> x <font color="#8000FF">`combineMaybe`</font> functionMayFail1 <font color="#8000FF">`combineMaybe`</font> functionMayFail2 <font color="#8000FF">--...</font></code></nobr> </blockquote> <br>  You may notice that the type of the <code>combineMaybe</code> function exactly repeats the type of <code>bind</code> , only <code>Maybe</code> stands instead of <code>c</code> . <br><blockquote> <code><b><font color="#0080FF">instance</font></b> Computation Maybe <b><font color="#0080FF">where</font></b> <br> return x <font color="#8000FF">=</font> Just x <br> bind Nothing f <font color="#8000FF">=</font> Nothing <br> bind <font color="#8000FF">(</font> Just x <font color="#8000FF">)</font> f <font color="#8000FF">=</font> fx</code> </blockquote>  This is exactly what the <code>Maybe</code> monad is defined to, only <code>bind</code> is called there <code><font color="#8000FF">(</font> <font color="#8000FF">&gt;&gt;=</font> <font color="#8000FF">)</font></code> , plus there is an additional operator <code><font color="#8000FF">(</font> <font color="#8000FF">&gt;&gt;</font> <font color="#8000FF">)</font></code> that does not use the result of the previous computation. <br>  In addition, syntactic sugar is defined for monads, which greatly simplifies their use: <br><blockquote> <code>funOnMaybes x <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> x1 <font color="#8000FF">&lt;-</font> functionMayFail1 x <br> x2 <font color="#8000FF">&lt;-</font> functionMayFail2 x1 <br> <b><font color="#0080FF">if</font></b> x2 <font color="#8000FF">==</font> <font color="#80C000">(0)</font> <br> <b><font color="#0080FF">then</font></b> return <font color="#80C000">(0)</font> <br> <b><font color="#0080FF">else</font></b> <b><font color="#0080FF">do</font></b> <br> x3 <font color="#8000FF">&lt;-</font> functionMayFail3 x2 <br> return <font color="#8000FF">(</font> x1 <font color="#8000FF">+</font> x3 <font color="#8000FF">)</font></code> </blockquote>  Pay attention to the extra <code><b><font color="#0080FF">do</font></b></code> inside and <code><b><font color="#0080FF">then</font></b></code> .  <code><b><font color="#0080FF">do</font></b></code> is just syntactic sugar, which combines several calculations into one, and since in the <code><b><font color="#0080FF">then</font></b></code> branch there is a calculation and so is one <code><font color="#8000FF">(</font> return <font color="#80C000">(0)</font> <font color="#8000FF">)</font></code> , then <code><b><font color="#0080FF">do</font></b></code> is not needed there;  in the <code><b><font color="#0080FF">else</font></b></code> branch, the calculations are two in a row, and in order to combine them, you need to use <code><b><font color="#0080FF">do</font></b></code> again. <br>  The special syntax with an inverse arrow <code>(&lt;-)</code> converted very simply: <br>  1. do {e} -&gt; e <br>  do with a single calculation is the calculation itself, you do not need to combine <br>  2. do {e;  es} -&gt; e &gt;&gt; do {es} <br>  several consecutive calculations are connected by an operator <code><font color="#8000FF">(</font> <font color="#8000FF">&gt;&gt;</font> <font color="#8000FF">)</font></code> <br>  3. do {let decls;  es} -&gt; let decls in do {es} <br>  inside do you can make additional declarations like <code><b><font color="#0080FF">let</font></b> <font color="#8000FF">...</font> <b><font color="#0080FF">in</font></b></code> <br>  4. do {p &lt;- e;  es} -&gt; let ok p = do {es};  ok _ = fail "..." in e &gt;&gt; = ok <br>  if the result of the first calculation is used further, then the operator is used for the combination <code><font color="#8000FF">(</font> <font color="#8000FF">&gt;&gt;=</font> <font color="#8000FF">)</font></code> <br>  In the latter case, such a construction is used because a sample can act as <code>p</code> , which may not coincide. <br>  If it matches, then the further calculation will be performed, otherwise an error with a string description will be returned. <br>  The <code>fail</code> function is another additional function in the monad, which generally has no relation to the concept of monads. <br><br>  What other monad instances are in the standard library? <br><br>  <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-State-Lazy.html">State</a> - calculations with a state.  With the help of <code>get/put</code> functions that are aware of the internal structure of the <code>State</code> , it is possible to get and set state. <br><blockquote> <nobr><code><b><font color="#0080FF">import</font></b> Control <font color="#8000FF">.</font> Monad <font color="#8000FF">.</font> State <br> <br> fact' <font color="#8000FF">::</font> Int <font color="#8000FF">-&gt;</font> State Int Int <font color="#008080">--   - Int,   -  Int</font> <br> fact' <font color="#80C000">0</font> <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> acc <font color="#8000FF">&lt;-</font> get <font color="#008080">--   </font> <br> return acc <font color="#008080">--  </font> <br> fact' n <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> acc <font color="#8000FF">&lt;-</font> get <font color="#008080">--  </font> <br> put <font color="#8000FF">(</font> acc <font color="#8000FF">*</font> n <font color="#8000FF">)</font> <font color="#008080">--    n  </font> <br> fact' <font color="#8000FF">(</font> n <font color="#008080">-</font> <font color="#80C000">1</font> <font color="#8000FF">)</font> <font color="#008080">--   </font> <br> <br> fact <font color="#8000FF">::</font> Int <font color="#8000FF">-&gt;</font> Int <br> fact n <font color="#8000FF">=</font> fst <font color="#8000FF">$</font> runState <font color="#8000FF">(</font> fact' n <font color="#8000FF">)</font> <font color="#80C000">1</font> <font color="#008080">--    - 1</font></code></nobr> </blockquote>  <code>runState</code> evaluates a function with a state, returns a tuple with a result and an altered state.  We only need the result, so <code>fst</code> . <br><br>  The list is also a monad.  Subsequent calculations apply to all previous results. <br><blockquote> <code>dummyFun contents <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> l <font color="#8000FF">&lt;-</font> lines contents <font color="#008080">--   </font> <br> <b><font color="#0080FF">if</font></b> length l <font color="#8000FF">&lt;</font> <font color="#80C000">3</font> <b><font color="#0080FF">then</font></b> fail <font color="#80C000">""</font> <font color="#008080">--   3  </font> <br> <b><font color="#0080FF">else</font></b> <b><font color="#0080FF">do</font></b> <br> w <font color="#8000FF">&lt;-</font> words l <font color="#008080">--    </font> <br> return w <font color="#008080">--  </font></code> </blockquote> <blockquote> <code>ghci&gt; dummyFun "line1\nword1 word2 word3\n \n \nline5" <br> ["line1","word1","word2","word3","line5"]</code> </blockquote> <br><br>  Continuations (continued) in Haskele - also a monad - <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-Cont.html">Cont</a> <br>  You can read about the continuation on the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25BB%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Russian wiki</a> and the <a href="http://en.wikipedia.org/wiki/Continuation">English wiki</a> and further on by links. <br>  They deserve special attention, but I cannot fit everything, and they have no direct relation to monads. <br>  <a href="http://palm-mute.livejournal.com/12291.html">A good article about the continuation in Scheme</a> is in the user <a href="http://palm-mute.livejournal.com/">palm_mute</a> in a live journal. <br><br>  I / O is also implemented using monads.  For example, the <code>getLine</code> function <code>getLine</code> : <br><blockquote> <code>getLine <font color="#8000FF">::</font> IO String</code> </blockquote>  An IO action that returns a string to us.  <code>IO</code> can be understood as: <br><blockquote> <code>getLine <font color="#8000FF">::</font> World <font color="#8000FF">-&gt;</font> <font color="#8000FF">(</font> String <font color="#8000FF">,</font> World <font color="#8000FF">)</font></code> </blockquote>  where <code>World</code> is the state of the world <br>  those.  any input-output function as if accepts a state of the world, and returns some result and a new state of the world, which is then used by subsequent functions. <br>  Of course, this is just a mental representation. <br>  Since, unlike lists and Maybe, we do not have constructors of type <code>IO</code> , we will never be able to parse the result of type <code>IO String</code> into its components, but will only have to use it in other calculations, thus ensuring that the use of I / O will be reflected in type of function. <br><br>  <font color="#888888">(‚ÄúNever‚Äù - this is loudly said, in fact there is <code>unsafePerformIO :: IO a -&gt; a</code> , but that's unsafe, to be used only with an understanding of the matter and when it is absolutely necessary. I personally have never used it).</font> <br><br>  It is worth mentioning <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-Trans.html">Monad transformers</a> (monad transformers). <br>  If we need a state, we can use <code>State</code> , if I / O is <code>IO</code> .  But what if our function wants to have states and still perform input and output? <br>  To do this, use the <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-State-Lazy.html">StateT</a> transformer, which connects the <code>State</code> and another monad.  To perform calculations in this other monad, use the <code>lift</code> function. <br>  Let's look at an example of factorial, which we change so that it prints the battery <br><blockquote> <nobr><code><b><font color="#0080FF">import</font></b> Control <font color="#8000FF">.</font> Monad <font color="#8000FF">.</font> State <br> <br> fact' <font color="#8000FF">::</font> Int <font color="#8000FF">-&gt;</font> StateT Int IO Int <font color="#008080">--  IO</font> <br> fact' <font color="#80C000">0</font> <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> acc <font color="#8000FF">&lt;-</font> get <br> return acc <br> fact' n <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> acc <font color="#8000FF">&lt;-</font> get <br> lift <font color="#8000FF">$</font> print acc <font color="#008080">-- print acc -   IO (),      lift</font> <br> put <font color="#8000FF">(</font> acc <font color="#8000FF">*</font> n <font color="#8000FF">)</font> <br> fact' <font color="#8000FF">(</font> n <font color="#008080">-</font> <font color="#80C000">1</font> <font color="#8000FF">)</font> <br> <br> fact <font color="#8000FF">::</font> Int <font color="#8000FF">-&gt;</font> IO Int <font color="#008080">--   IO  ,    :)</font> <br> fact n <font color="#8000FF">=</font> <b><font color="#0080FF">do</font></b> <br> <font color="#8000FF">(</font> r <font color="#8000FF">,</font> <b><font color="#0080FF">_</font></b> <font color="#8000FF">)</font> <font color="#8000FF">&lt;-</font> runStateT <font color="#8000FF">(</font> fact' n <font color="#8000FF">)</font> <font color="#80C000">1</font> <br> return r</code></nobr> </blockquote> <blockquote> <code>ghci&gt; fact 5 <br> 1 <br> 5 <br> 20 <br> 60 <br> 120 <br> 120</code> </blockquote> <br>  In addition to <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-State-Lazy.html">StateT,</a> there is also a <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-List.html">ListT</a> (for the list). <br><br>  Full list of <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Control-Monad.html">monads</a> and <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/mtl/Control-Monad-Trans.html">monad transformers</a> . <br><br>  For convenience, generic functions are defined over monads.  Their names speak for themselves, most of them duplicate list functions, so I'll just list some of them and give <a href="http://haskell.org/ghc/docs/6.10.1/html/libraries/base/Control-Monad.html">this link.</a> <br><blockquote> <code>sequence <font color="#8000FF">::</font> Monad m <font color="#8000FF">=&gt;</font> <font color="#8000FF">[</font> ma <font color="#8000FF">]</font> <font color="#8000FF">-&gt;</font> m <font color="#8000FF">[</font> a <font color="#8000FF">]</font> <br> <font color="#008080">--        </font> <br> mapM f <font color="#8000FF">=</font> sequence <font color="#8000FF">.</font> map f <br> forM <font color="#8000FF">=</font> flip mapM <br> <font color="#008080">-- forM [1..10] $ \i -&gt; print i</font> <br> forever <font color="#8000FF">::</font> Monad m <font color="#8000FF">=&gt;</font> ma <font color="#8000FF">-&gt;</font> mb <font color="#008080">-- ,   </font> <br> filterM <font color="#8000FF">::</font> Monad m <font color="#8000FF">=&gt;</font> <font color="#8000FF">(</font> a <font color="#8000FF">-&gt;</font> m Bool <font color="#8000FF">)</font> <font color="#8000FF">-&gt;</font> <font color="#8000FF">[</font> a <font color="#8000FF">]</font> <font color="#8000FF">-&gt;</font> m <font color="#8000FF">[</font> a <font color="#8000FF">]</font> <font color="#008080">-- filter</font> <br> foldM <font color="#8000FF">::</font> Monad m <font color="#8000FF">=&gt;</font> <font color="#8000FF">(</font> a <font color="#8000FF">-&gt;</font> b <font color="#8000FF">-&gt;</font> ma <font color="#8000FF">)</font> <font color="#8000FF">-&gt;</font> a <font color="#8000FF">-&gt;</font> <font color="#8000FF">[</font> b <font color="#8000FF">]</font> <font color="#8000FF">-&gt;</font> ma <font color="#008080">-- foldl</font> <br> when <font color="#8000FF">::</font> Monad m <font color="#8000FF">=&gt;</font> Bool <font color="#8000FF">-&gt;</font> m () <font color="#8000FF">-&gt;</font> m () <font color="#008080">-- if   else</font></code> </blockquote> <br><h4>  List comprehensions </h4><br>  <font color="#888888">(I do not undertake to translate this term)</font> <br>  List comprehensions allows you to construct lists in accordance with mathematical notation: <br><img src="https://habrastorage.org/getpro/habr/post_images/39d/477/584/39d477584b00e663434eb8885b830aa4.png"><br><blockquote> <code>ghci&gt; take <font color="#80C000">5</font> <font color="#8000FF">$</font> <font color="#8000FF">[</font> <font color="#80C000">2</font> <font color="#8000FF">*</font> x <font color="#8000FF">|</font> x <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> <font color="#8000FF">]</font> <font color="#8000FF">,</font> x <font color="#8000FF">^</font> <font color="#80C000">2</font> <font color="#8000FF">&gt;</font> <font color="#80C000">3</font> <font color="#8000FF">]</font> <br> <font color="#8000FF">[</font> <font color="#80C000">4</font> <font color="#8000FF">,</font> <font color="#80C000">6</font> <font color="#8000FF">,</font> <font color="#80C000">8</font> <font color="#8000FF">,</font> <font color="#80C000">10</font> <font color="#8000FF">,</font> <font color="#80C000">12</font> <font color="#8000FF">]</font> <br> ghci&gt; <font color="#8000FF">[</font> <font color="#8000FF">(</font> x <font color="#8000FF">,</font> y <font color="#8000FF">)</font> <font color="#8000FF">|</font> x <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> <font color="#80C000">3</font> <font color="#8000FF">]</font> <font color="#8000FF">,</font> y <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> <font color="#80C000">3</font> <font color="#8000FF">]</font> <font color="#8000FF">]</font> <br> <font color="#8000FF">[</font> <font color="#8000FF">(</font> <font color="#80C000">1</font> <font color="#8000FF">,</font> <font color="#80C000">1</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">1</font> <font color="#8000FF">,</font> <font color="#80C000">2</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">1</font> <font color="#8000FF">,</font> <font color="#80C000">3</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">2</font> <font color="#8000FF">,</font> <font color="#80C000">1</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">2</font> <font color="#8000FF">,</font> <font color="#80C000">2</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">2</font> <font color="#8000FF">,</font> <font color="#80C000">3</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">3</font> <font color="#8000FF">,</font> <font color="#80C000">1</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">3</font> <font color="#8000FF">,</font> <font color="#80C000">2</font> <font color="#8000FF">)</font> <font color="#8000FF">,</font> <font color="#8000FF">(</font> <font color="#80C000">3</font> <font color="#8000FF">,</font> <font color="#80C000">3</font> <font color="#8000FF">)</font> <font color="#8000FF">]</font></code> </blockquote>  It is seen that the last list is moved more often. <br>  y may depend on x: <br><blockquote> <code>ghci&gt; <font color="#8000FF">[</font> x <font color="#8000FF">+</font> y <font color="#8000FF">|</font> x <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> <font color="#80C000">4</font> <font color="#8000FF">]</font> <font color="#8000FF">,</font> y <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> x <font color="#8000FF">]</font> <font color="#8000FF">,</font> even x <font color="#8000FF">]</font> <br> <font color="#8000FF">[</font> <font color="#80C000">3</font> <font color="#8000FF">,</font> <font color="#80C000">4</font> <font color="#8000FF">,</font> <font color="#80C000">5</font> <font color="#8000FF">,</font> <font color="#80C000">6</font> <font color="#8000FF">,</font> <font color="#80C000">7</font> <font color="#8000FF">,</font> <font color="#80C000">8</font> <font color="#8000FF">]</font></code> </blockquote> <br>  List comprehensions is also syntactic sugar and unfolds in (last example): <br><blockquote> <code><b><font color="#0080FF">do</font></b> <br> x <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> <font color="#80C000">4</font> <font color="#8000FF">]</font> <br> y <font color="#8000FF">&lt;-</font> <font color="#8000FF">[</font> <font color="#80C000">1</font> <font color="#8000FF">..</font> x <font color="#8000FF">]</font> <br> True <font color="#8000FF">&lt;-</font> return <font color="#8000FF">(</font> even x <font color="#8000FF">)</font> <br> return <font color="#8000FF">(</font> x <font color="#8000FF">+</font> y <font color="#8000FF">)</font></code> </blockquote>  Of course, it unfolds directly, but so is the connection between monadic calculations on lists and list comprehensions. <br><br>  Next time I will try to answer all the questions, and then it will be possible to take up the implementation of the chat (or immediately, if there are few / no questions), so ask if it is not clear across all the articles. </div><p>Source: <a href="https://habr.com/ru/post/51046/">https://habr.com/ru/post/51046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../51039/index.html">Master Chef of Halo against all!</a></li>
<li><a href="../51041/index.html">Interesting coincidences (or Miranda IM Jabber and Mobile Mail.RU Agent): again twenty five</a></li>
<li><a href="../51042/index.html">3 simple tips to make your Rails application faster, part 3</a></li>
<li><a href="../51043/index.html">Skype 4.0: "at liberty"</a></li>
<li><a href="../51044/index.html">Forex. Game or business?</a></li>
<li><a href="../51048/index.html">Amazing Reactable Musical Instrument</a></li>
<li><a href="../51049/index.html">Internet at school</a></li>
<li><a href="../51050/index.html">Crisis and refactoring, thought out of hearing</a></li>
<li><a href="../51051/index.html">Ahbarahbar.ru</a></li>
<li><a href="../51053/index.html">6th International StartupPoint Meeting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>