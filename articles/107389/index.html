<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The difference in the approaches of code analysis by the compiler and the selected tool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The compiler and third-party static code analysis tools have a common task - identifying dangerous code fragments. However, there is a significant dif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The difference in the approaches of code analysis by the compiler and the selected tool</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/7a2/9a4/ce0/7a29a4ce0b20279990cc52adec5d5116.png">  The compiler and third-party static code analysis tools have a common task - identifying dangerous code fragments.  However, there is a significant difference in what type of analysis they perform.  I will use the example of the Intel C ++ compiler and the PVS-Studio analyzer to demonstrate the differences in approaches and explain what caused them. <br><br>  This time the test project will be the project Notepad ++ version 5.8.2. <br><br><a name="habracut"></a><br><h2>  Notepad ++ </h2><br>  First about the selected project.  <a href="http://notepad-plus-plus.org/">Notepad ++</a> is a free and free source code editor that supports a large number of languages, as well as a replacement for the standard Notepad.  It runs on Microsoft Windows and is licensed under the GPL.  I liked the project because it is written in C ++ and has a small size - 73000 lines of code.  And most importantly, this is a fairly neat project, as indicated by the / W4 key in the project settings and the / WX key, which makes treat each warning as an error. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Static analysis in the compiler </h2><br>  Now consider the analysis of the project from the point of view of the compiler and a separate specialized tool.  The compiler always gives warnings that can be issued by processing only a very small local code fragment.  This preference is due to the fact that the compiler has very strict performance requirements.  It is not by chance that there are tools for distributed project assembly.  Compile time for medium and large projects is a significant factor influencing the choice of development methods.  Therefore, if it will be possible to squeeze 5% of the performance gain of the compiler, it will be implemented. <br><br>  Such optimization makes the compiler more monolithic, and in fact there are hardly any clearly distinguished steps such as preprocessing, building <a href="http://www.viva64.com/terminology/Abstract_syntactical_tree_rus.html">AST</a> , code generation.  For example, by indirect evidence, I can argue that the algorithm of a preprocessor that uses Visual C ++ when compiling and when generating preprocessing "* .i" files is different.  Also, the compiler does not need and even harmful to keep the AST tree entirely.  Once the code for certain nodes has been generated and these nodes are no longer needed, they will be immediately destroyed.  In the process of compiling AST may never exist entirely.  It is not necessary.  Disassembled a piece of code, generated the code, went further.  This saves the amount of used memory and cache, and, consequently, increases the speed. <br><br>  The result of this approach is the ‚Äúlocality‚Äù of warnings.  The compiler deliberately saves on various structures that could help detect higher level errors.  Let's look in practice, what local warnings will be issued by Intel C ++ for the Notepad ++ project.  Let me remind you that the Notepad ++ project is built by the Visual C ++ compiler without warnings with the / W4 key.  The Intel C ++ compiler will naturally have a different set of warnings, and I also set the / W5 specific key [Intel C ++].  Plus, I'll take a look at what the Intel C ++ compiler calls ‚Äúremark‚Äù. <br><br>  Let's see what kind of messages we received from Intel C ++.  Here he found four errors of the same type when working with the CharUpper function (SEE NOTE IN THE END OF THE ARTICLE).  Pay attention to the "locality" of diagnosing this error - just found extremely dangerous type conversion.  Consider the corresponding code snippet: <br><br><pre>  wchar_t * destStr = new wchar_t [len + 1];
 ...
 for (int j = 0; j &lt;nbChar; j ++)
 {
   if (Case == UPPERCASE)
     destStr [j] =
       (wchar_t) :: CharUpperW ((LPWSTR) destStr [j]);
   else
     destStr [j] =
       (wchar_t) :: CharLowerW ((LPWSTR) destStr [j]);
 } </pre><br>  There are strange type conversions.  The Intel C ++ compiler reports: "# 810: conversion from" LPWSTR = {WCHAR = {__ wchar_t} *} "to" __wchar_t "may lose significant bits".  Let's look at the prototype of the CharUpper function. <br><br><pre>  LPTSTR WINAPI CharUpper (
   __inout LPTSTR lpsz
 ); </pre><br>  The function works with a string, and not with individual characters at all.  Here, the symbol is converted to a pointer, and a certain area of ‚Äã‚Äãmemory is modified by this pointer.  Horror. <br><br>  But, truth, the horrors discovered by Intel C ++ are probably ending there.  Everything else is much duller and more likely to be a messy code than a code that will cause an error.  But still consider some other warnings. <br><br>  Issued a large number of messages # 1125: <br><br>  "# 1125: function" Window :: init (HINSTANCE, HWND) "is hidden by" TabBarPlus :: init "- virtual function override intended?" <br><br>  These are not errors, but unsuccessful naming of functions.  We are interested in this message to others.  Although it seems to involve several classes for verification, special data is not remembered here.  The compiler still needs to store various information about the base classes.  That is why this diagnosis is implemented. <br><br>  The following example.  The message "# 186: pointless comparison of unsigned integer with zero" is issued for meaningless comparisons: <br><br><pre>  static LRESULT CALLBACK hookProcMouse (
   UINT nCode, WPARAM wParam, LPARAM lParam)
 {
   if (nCode &lt;0)
   {
     ...
     return 0;
   }
 ...
 } </pre><br>  The condition "nCode &lt;0" is always false.  A good example of a good local diagnosis.  So it is quite possible to detect an error. <br><br>  Consider the latest Intel C ++ warning and that's enough.  I think the idea of ‚Äã‚Äã"locality" is already clear. <br><br><pre>  void ScintillaKeyMap :: showCurrentSettings () {
   int i = :: SendDlgItemMessage (...);
   ...
   for (size_t i = 0; i &lt;nrKeys; i ++)
   {
     ...
   }
 } </pre><br>  There is no error again, just not very successful variable naming.  Initially, the variable "i" has the type "int".  Then in the ‚Äúfor ()‚Äù operator a new variable ‚Äúi‚Äù of the type ‚Äúsize_t‚Äù is declared and used for other purposes.  The compiler at the time of the declaration ‚Äúsize_t i‚Äù knows that there is already a variable with that name and issues a warning.  Again, this did not require the compiler to store any additional data.  He should still remember that until the end of the function body, the variable ‚Äúint i‚Äù is available. <br><br><h2>  External static code analyzers </h2><br>  Let's pass to specialized tools of static code analysis.  They no longer have such severe restrictions on speed, since the frequency of their launch is an order of magnitude lower than that of the compiler.  The speed of their work may well be ten times slower than compiling code.  This is not critical.  For example, a programmer works with a compiler during the day.  At night, a static code analyzer is launched and in the morning the programmer receives a report on suspicious places.  It is a reasonable approach. <br><br>  Paying by delays, static code analysis tools can afford to store the entire code tree, run it several times, and store a lot of additional information.  This allows them to find ‚Äúblurred‚Äù and high-level errors. <br><br>  Let's see what the interesting <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static analyzer finds in Notepad ++.  I note that I use the experimental version, which is not yet available for download.  We will present a free set of general-purpose rules in 1-2 months in PVS-Studio version 4.00. <br><br>  Naturally, like Intel C ++, the PVS-Studio analyzer finds errors that can be classified as ‚Äúlocal‚Äù.  First example: <br><br><pre>  bool _isPointXValid;
 bool _isPointYValid;
 bool isPointValid () {
   return _isPointXValid &amp;&amp; _isPointXValid;
 }; </pre><br>  The PVS-Studio analyzer reports: "V501: there are operator: _isPointXValid &amp;&amp; _isPointXValid." <br><br>  I think the essence of the error is obvious, and we will not dwell on it in more detail.  Diagnostics is ‚Äúlocal‚Äù, since testing can be done in the process of analyzing a single expression. <br><br>  Another local error leading to incomplete cleaning of the _iContMap array: <br><br><pre>  #define CONT_MAP_MAX 50
 int _iContMap [CONT_MAP_MAX];
 ...
 DockingManager :: DockingManager ()
 {
   ...
   memset (_iContMap, -1, CONT_MAP_MAX);
   ...
 } </pre><br>  A warning is issued "V512: A call of the memset function will lead to a buffer overflow or underflow."  The correct code is: <br><br><pre>  memset (_iContMap, -1, CONT_MAP_MAX * sizeof (int)); </pre><br><br>  And now let's move on to more interesting things.  The code where you need to simultaneously analyze two branches at once to be able to suspect that something was wrong: <br><br><pre>  void TabBarPlus :: drawItem (
   DRAWITEMSTRUCT * pDrawItemStruct)
 {
 ...

   if (! _isVertical)
     Flags | = DT_BOTTOM;
   else
     Flags | = DT_BOTTOM;
 ...
 } </pre><br>  PVS-Studio reports here: "V523: The 'then' statement is equivalent to the 'else' statement".  If you look at the code next door, you can conclude that the author actually wanted to write this: <br><br><pre>  if (! _isVertical)
   Flags | = DT_VCENTER;
 else
   Flags | = DT_BOTTOM;
</pre><br>  And now have courage.  You will test in the form of the following code snippet: <br><br><pre>  void KeyWordsStyleDialog :: updateDlg () 
 {
   ...
   Style &amp; w1Style =
     _pUserLang -&gt; _ styleArray.getStyler (STYLE_WORD1_INDEX);
   styleUpdate (w1Style, _pFgColour [0], _pBgColour [0],
     IDC_KEYWORD1_FONT_COMBO, IDC_KEYWORD1_FONTSIZE_COMBO,
     IDC_KEYWORD1_BOLD_CHECK, IDC_KEYWORD1_ITALIC_CHECK,
     IDC_KEYWORD1_UNDERLINE_CHECK);

   Style &amp; w2Style =
     _pUserLang -&gt; _ styleArray.getStyler (STYLE_WORD2_INDEX);
   styleUpdate (w2Style, _pFgColour [1], _pBgColour [1],
     IDC_KEYWORD2_FONT_COMBO, IDC_KEYWORD2_FONTSIZE_COMBO,
     IDC_KEYWORD2_BOLD_CHECK, IDC_KEYWORD2_ITALIC_CHECK,
     IDC_KEYWORD2_UNDERLINE_CHECK);

   Style &amp; w3Style =
     _pUserLang -&gt; _ styleArray.getStyler (STYLE_WORD3_INDEX);
   styleUpdate (w3Style, _pFgColour [2], _pBgColour [2],
     IDC_KEYWORD3_FONT_COMBO, IDC_KEYWORD3_FONTSIZE_COMBO,
     IDC_KEYWORD3_BOLD_CHECK, IDC_KEYWORD3_BOLD_CHECK,
     IDC_KEYWORD3_UNDERLINE_CHECK);

   Style &amp; w4Style =
     _pUserLang -&gt; _ styleArray.getStyler (STYLE_WORD4_INDEX);
   styleUpdate (w4Style, _pFgColour [3], _pBgColour [3],
     IDC_KEYWORD4_FONT_COMBO, IDC_KEYWORD4_FONTSIZE_COMBO,
     IDC_KEYWORD4_BOLD_CHECK, IDC_KEYWORD4_ITALIC_CHECK,
     IDC_KEYWORD4_UNDERLINE_CHECK);
   ...
 } </pre><br>  One can say that I am proud of our PVS-Studio analyzer, which could find an error here.  I think you hardly noticed it and just skip the entire code fragment, waiting for an explanation.  This code is practically beyond the scope of review (code review).  But the static analyzer is patient and pedantic: ‚ÄúV525: The code containing the collection of similar blocks.  Check items '7', '7', '6', '7' in lines 576, 580, 584, 588 ". <br><br>  I will shorten the text to highlight the interesting: <br><br><pre>  styleUpdate (...
   IDC_KEYWORD1_BOLD_CHECK, IDC_KEYWORD1_ITALIC_CHECK,
   ...);
 styleUpdate (...
   IDC_KEYWORD2_BOLD_CHECK, IDC_KEYWORD2_ITALIC_CHECK,
   ...);
 styleUpdate (...
   IDC_KEYWORD3_BOLD_CHECK, !!  IDC_KEYWORD3_BOLD_CHECK !!,
   ...);
 styleUpdate (...
   IDC_KEYWORD4_BOLD_CHECK, IDC_KEYWORD4_ITALIC_CHECK, </pre><br>  The code was most likely written by the Copy-Paste technique.  The result was the use of IDC_KEYWORD3_BOLD_CHECK instead of IDC_KEYWORD3_ITALIC_CHECK.  The warning looks somewhat strange when it comes to the numbers '7', '7', '6', '7'.  Unfortunately, it is difficult to give a clearer message.  These numbers are taken from the macros of the form: <br><br><pre>  #define IDC_KEYWORD1_ITALIC_CHECK (IDC_KEYWORD1 + 7)
 #define IDC_KEYWORD3_BOLD_CHECK (IDC_KEYWORD3 + 6) </pre><br>  The last example given is indicative of the fact that the PVS-Studio analyzer processed a whole large portion of code at the same time, revealed repetitive structures in it and was able to suspect that something was wrong based on heuristics.  This is a very significant difference in the level of information processing. <br><br><h2>  Some numbers </h2><br>  We describe one more consequence of the ‚Äúlocal‚Äù analysis of compilers and more global in specialized tools.  With ‚Äúlocal analysis‚Äù it is difficult to clarify whether this situation is really dangerous or not.  The result is an order of magnitude greater number of false positives.  Let me explain by example. <br><br>  When analyzing the Notepad ++ project, the PVS-Studio tool issued only 10 warnings.  Of these, 4 messages indicated real errors.  The result is modest, but the static general-purpose analysis in PVS-Studio has just begun its development.  In time, he will become one of the best. <br><br>  When analyzing the Notepad ++ project, the Intel C ++ compiler issued 439 warnings and 3139 remarks.  I do not know how many of them really point to real mistakes.  From what I had the strength to look at, I saw only 4 true errors related to CharUpper (see description above). <br><br>  3578 messages are too many to study carefully each of them.  It turns out that the compiler offers to pay attention to every twentieth line in the program (73000/3578 = 20).  This is not serious.  In the case of a general purpose analyzer, if possible, cut off all unnecessary. <br><br>  Those who have tried the <a href="http://www.viva64.com/ru/viva64-tool/">Viva64</a> rule set (included in PVS-Studio) may notice that it produces the same huge percentage of false positives.  But there is a different situation.  There you need to be able to identify all suspicious type conversions.  It is more important not to miss the error than not to give a false message.  Especially false messages are well filtered using settings. <br><br>  - UPDATE: <br><br>  It turns out I wrote a lie here.  In the example with CharUpperW there is no error.  And unfortunately nobody corrected me.  I noticed it myself when I decided to implement a similar rule in PVS-Studio. <br><br>  The fact is that <a href="http://msdn.microsoft.com/en-us/library/ms647474(VS.85).aspx">CharUpperW</a> can work both with a string and with individual characters.  If the upper part of the pointer is zero, then it is considered that this is not a pointer, but a symbol.  The WIN API in this place of course is saddened by its curvature, but the code in Notepad ++ is written correctly. <br><br>  By the way, now it turns out that Intel C ++ did not find any errors at all. </div><p>Source: <a href="https://habr.com/ru/post/107389/">https://habr.com/ru/post/107389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../107380/index.html">How to start work on a startup?</a></li>
<li><a href="../107383/index.html">Video from HighLoad ++ in Mail.Ru: what are you doing?</a></li>
<li><a href="../107386/index.html">The helicopter flew 12 hours on remote charging</a></li>
<li><a href="../107387/index.html">‚ÄúLive graphs‚Äù - growing graphs on cellular automata with Silverlight examples</a></li>
<li><a href="../107388/index.html">Taiwan scientists have created a promising flexible display</a></li>
<li><a href="../107390/index.html">Democamp 2010 Report</a></li>
<li><a href="../107393/index.html">1-bit symphony of Tristan Peric</a></li>
<li><a href="../107394/index.html">Social networks in business. Employee Conduct Policies</a></li>
<li><a href="../107395/index.html">In two months, Twitter has 30 million more users.</a></li>
<li><a href="../107396/index.html">We prohibit the use of known UserJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>