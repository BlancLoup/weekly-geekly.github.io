<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analytical calculation of derivatives on C ++ templates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few days ago they wrote about analytic finding of derivatives, which reminded me of one of my small C ++ libraries, which does almost the same thing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analytical calculation of derivatives on C ++ templates</h1><div class="post__text post__text-html js-mediator-article">  A few days ago <a href="https://habrahabr.ru/post/309676/">they wrote</a> about analytic finding of derivatives, which reminded me of one of my small C ++ libraries, which does almost the same thing, but at compile time. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7d7/d2b/f02/7d7d2bf029364d65ad444fd10d692fe0.png"></div><br>  What is the profit?  The answer is simple: I had to set the minimum to find a fairly complex function, consider the derivatives of this function to be a pen on paper for laziness, check later that I was not sealed when writing the code, and support this same code - it is doubly lazy, so it was decided to write the thing that does it for me.  Well, in order to write something like this in the code: <br><br><pre><code class="hljs lisp">using Formula_t = decltype (<span class="hljs-name"><span class="hljs-name">k</span></span> * (_1 - r0) / (_1 + r0) * (<span class="hljs-name"><span class="hljs-name">g0</span></span> / (<span class="hljs-name"><span class="hljs-name">alpha0</span></span> - logr0 / Num&lt;300&gt;) - _1))<span class="hljs-comment"><span class="hljs-comment">; //   const auto residual = Formula_t::Eval (datapoint) - knownValue; //   //   : const auto dg0 = VarDerivative_t&lt;Formula_t, decltype (g0)&gt;::Eval (datapoint); const auto dalpha0 = VarDerivative_t&lt;Formula_t, decltype (alpha0)&gt;::Eval (datapoint); const auto dk = VarDerivative_t&lt;Formula_t, decltype (k)&gt;::Eval (datapoint);</span></span></code> </pre> <br>  Instead of crocodiles, which are obtained if we take the partial derivatives of the functions in the picture at the beginning (or rather, some simplified version of it, but it doesn‚Äôt look so bad). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It's also nice to be confident enough that the compiler is optimizing it as if the corresponding derivatives and functions were written by hand.  And I would like to be sure - it was necessary to find the minimum many times (indeed, many, from hundreds of millions to billions, this was the essence of some kind of computational experiment), so the calculation of the derivatives would be a bottleneck any recursion on a tree structure.  If we force the compiler to calculate the derivative, in fact, at compile time, then there is a chance that it will still be passed by the optimizer according to the resulting code, and we will not lose compared to manual writing all the derivatives.  The chance came true, by the way. <br><br>  Under the cut - a small description of how it all works there. <br><a name="habracut"></a><br>  Let's start with the presentation of the function in the program.  For some reason, it turned out that every function is a type.  A function is also an expression tree, and the node of this tree is represented by the <code>Node</code> type: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NodeClass, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  Here <code>NodeClass</code> is the node type (variable, number, unary function, binary function), <code>Args</code> are the parameters of this node (variable index, value of number, child nodes). <br><br>  Nodes are able to differentiate themselves, to print and calculate for given values ‚Äã‚Äãof free variables and parameters.  So, if a type is defined for representing a node with a regular number: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NumberType_t = <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;NumberType_t N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre> <br>  then the knot specialization for numbers is trivial: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;NumberType_t N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;Number&lt;N&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> FPrime, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IPrime&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Number&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string (N); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Vec&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Vec::<span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> N; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} };</code> </pre> <br>  The derivative of any number with respect to any variable is zero (the type <code>Derivative_t</code> is responsible for this, let‚Äôs leave its template parameters for now).  Printing a number is also easy (see <code>Print()</code> ).  Calculate a node with a number ‚Äî return this number (see <code>Eval()</code> , the <code>Vec</code> template parameter will be discussed later). <br><br>  The variable appears in a similar way: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Family</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>&gt; struct Variable {};</code> </pre> <br>  Here, <code>Family</code> and <code>Index</code> are the ‚Äúfamily‚Äù and variable index.  So for <img src="https://habrastorage.org/files/dab/fa6/254/dabfa625489b4c9896ae6465fea6e913.png">  they will be equal to <code>'w'</code> and <code>1</code> , and for <img src="https://habrastorage.org/files/a71/3b7/bb0/a713b7bb0d24499aaf59143a8e432714.png">  - <code>'x'</code> and <code>2</code> respectively. <br><br>  The node for a variable is defined a little more interesting than for a number: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Family, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;Variable&lt;Family, Index&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> FPrime, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IPrime&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt;FPrime == Family &amp;&amp; IPrime == Index, Node&lt;Number&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;&gt;, Node&lt;Number&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { Family, <span class="hljs-string"><span class="hljs-string">'_'</span></span> } + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string (Index); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Vec&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Vec::<span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec&amp; values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values (Node {}); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} };</code> </pre> <br>  Thus, the derivative of a variable is equal to one by itself, and zero for any other variable.  Actually, the <code>FPrime</code> and <code>IPrime</code> for the type <code>Derivative_t</code> are the family and the index of the variable on which you want to take the derivative. <br><br>  Calculating the value of a function consisting of one variable is reduced to finding it in the value <code>values</code> dictionary, which is passed to the <code>Eval()</code> function.  The dictionary itself is able to find the value of the desired variable by its type, so we will simply give it the type of our variable and return the corresponding value.  As a dictionary it does, we will look at it later. <br><br>  With unary functions, everything becomes more interesting. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnaryFunction</span></span></span><span class="hljs-class"> {</span></span> Sin, Cos, Ln, Neg }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;UnaryFunction UF&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnaryFunctionWrapper</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  In the <code>UnaryFunctionWrapper</code> specialization <code>UnaryFunctionWrapper</code> we stuff the logic by taking the derivatives of each specific unary function.  To minimize duplicate code, we will take the derivative of the unary function by its argument, the caller will answer for further differentiation of the argument by the target variable through the chain rule: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnaryFunctionWrapper</span></span></span><span class="hljs-class">&lt;UnaryFunction::Sin&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Child&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Cos, Child&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnaryFunctionWrapper</span></span></span><span class="hljs-class">&lt;UnaryFunction::Cos&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Child&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Neg, Node&lt;Sin, Child&gt;&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnaryFunctionWrapper</span></span></span><span class="hljs-class">&lt;UnaryFunction::Ln&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Child&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Div, Node&lt;Number&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;&gt;, Child&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnaryFunctionWrapper</span></span></span><span class="hljs-class">&lt;UnaryFunction::Neg&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Number&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;&gt;; };</code> </pre> <br>  Then the node itself looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;UnaryFunction UF, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ChildArgs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;UnaryFunctionWrapper&lt;UF&gt;, Node&lt;ChildArgs...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Child_t = Node&lt;ChildArgs...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> FPrime, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IPrime&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Mul, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunctionWrapper&lt;UF&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Derivative_t&lt;Child_t&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node&lt;ChildArgs...&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Derivative_t&lt;FPrime, IPrime&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Print</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FunctionName (UF) + <span class="hljs-string"><span class="hljs-string">"("</span></span> + Node&lt;ChildArgs...&gt;::Print () + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Vec&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Vec::<span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec&amp; values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> child = Child_t::Eval (values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EvalUnary (UnaryFunctionWrapper&lt;UF&gt; {}, child); } };</code> </pre> <br>  We consider the derivative through the chain rule - it looks scary, the idea is simple.  The calculation is also simple: we count the value of the child node, then we calculate the value of our unary function on this value using the <code>EvalUnary()</code> function.  Rather, a family of functions: the first argument of the function is the type that defines our unary function, to ensure the choice of the desired overload during compilation.  Yes, one could pass the <code>UF</code> value itself, and a smart compiler would almost certainly make all the necessary constant propagation passes, but here it‚Äôs easier to be safe. <br><br>  By the way, a separate unary operation of negation could not be introduced, replacing it with multiplication by minus one. <br><br>  With binary nodes, everything is the same, only derivatives look absolutely scary.  For division, for example: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; struct BinaryFunctionWrapper&lt;BinaryFunction::Div&gt; { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Family</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>, typename U, typename V&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = Node&lt;Div, Node&lt;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>, Node&lt;Mul, typename U::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Derivative_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">Family</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>&gt;, V &gt;, Node&lt;Neg, Node&lt;Mul, U, typename V::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Derivative_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">Family</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>&gt; &gt; &gt; &gt;, Node&lt;Mul, V, V &gt; &gt;; };</code> </pre> <br>  Then the required <code>VarDerivative_t</code> is determined quite simply, because in fact it only calls <code>Derivative_t</code> on the node passed to it: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VarDerivative</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Family, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VarDerivative</span></span></span><span class="hljs-class">&lt;Expr, Node&lt;Variable&lt;Family, Index&gt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result_t = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Derivative_t&lt;Family, Index&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> VarDerivative_t = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> VarDerivative&lt;Node, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;Var&gt;&gt;::Result_t;</code> </pre> <br>  If we now define auxiliary variables and types, for example: <br><br><pre> <code class="hljs pgsql">//       : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sin = UnaryFunctionWrapper&lt;UnaryFunction::Sin&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Cos = UnaryFunctionWrapper&lt;UnaryFunction::Cos&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Neg = UnaryFunctionWrapper&lt;UnaryFunction::Neg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ln = UnaryFunctionWrapper&lt;UnaryFunction::Ln&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> = BinaryFunctionWrapper&lt;BinaryFunction::<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Mul = BinaryFunctionWrapper&lt;BinaryFunction::Mul&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Div = BinaryFunctionWrapper&lt;BinaryFunction::Div&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pow = BinaryFunctionWrapper&lt;BinaryFunction::Pow&gt;; // variable <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>  C++<span class="hljs-number"><span class="hljs-number">14</span></span>      : <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Family</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; constexpr Node&lt;Variable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Family</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>&gt;&gt; Var {}; //   x0  , ,    : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> X0 = Node&lt;Variable&lt;<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;&gt;; constexpr X0 x0; //       //   ,     : constexpr Node&lt;Number&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;&gt; _1; //  ,     ,  : <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T1, typename T2&gt; Node&lt;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>, std::decay_t&lt;T1&gt;, std::decay_t&lt;T2&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+ (T1, T2); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T1, typename T2&gt; Node&lt;Mul, std::decay_t&lt;T1&gt;, std::decay_t&lt;T2&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>* (T1, T2); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T1, typename T2&gt; Node&lt;Div, std::decay_t&lt;T1&gt;, std::decay_t&lt;T2&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/ (T1, T2); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T1, typename T2&gt; Node&lt;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>, std::decay_t&lt;T1&gt;, Node&lt;Neg, std::decay_t&lt;T2&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>- (T1, T2); //   ,      : <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; Node&lt;Sin, std::decay_t&lt;T&gt;&gt; Sin (T); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; Node&lt;Cos, std::decay_t&lt;T&gt;&gt; Cos (T); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; Node&lt;Ln, std::decay_t&lt;T&gt;&gt; Ln (T);</code> </pre> <br>  then you can write the code just like at the very beginning of the post. <br><br>  What is left? <br><br>  First, deal with the type that is passed to the <code>Eval()</code> function.  Secondly, to mention the possibility of converting the desired expression with the replacement of one subtree with another.  Let's start with the second, it's easier. <br><br>  Motivation (you can skip): if you slightly profile the code that comes out of the current version, it will catch your eye, which takes quite a long time to calculate <img src="https://habrastorage.org/files/50b/5af/0e2/50b5af0e231d43feaccf093b6cf4b9a9.png">  which, generally speaking, is the same for each experimental point.  No problem!  We introduce a separate variable, which we calculate once before calculating the values ‚Äã‚Äãof our formula at each of the experimental points, and replace all occurrences <img src="https://habrastorage.org/files/50b/5af/0e2/50b5af0e231d43feaccf093b6cf4b9a9.png">  to this variable (in fact, in the motivation code at the very beginning, this has already been done).  However, when we take the derivative with respect to <img src="https://habrastorage.org/files/a7a/558/927/a7a558927bbc4000a8a81788f75e1ae5.png">  we will have to remember that <img src="https://habrastorage.org/files/50b/5af/0e2/50b5af0e231d43feaccf093b6cf4b9a9.png">  , generally speaking, not a free parameter, but a function of <img src="https://habrastorage.org/files/a7a/558/927/a7a558927bbc4000a8a81788f75e1ae5.png">  .  Recall is very simple: replace <img src="https://habrastorage.org/files/50b/5af/0e2/50b5af0e231d43feaccf093b6cf4b9a9.png">  on <img src="https://habrastorage.org/files/a7a/558/927/a7a558927bbc4000a8a81788f75e1ae5.png">  ( <code>ApplyDependency_t</code> metafunction is used for this, although it would be <code>Rewrite_t</code> correct to call it <code>Rewrite_t</code> or something like that), differentiate, return <img src="https://habrastorage.org/files/a7a/558/927/a7a558927bbc4000a8a81788f75e1ae5.png">  on <img src="https://habrastorage.org/files/50b/5af/0e2/50b5af0e231d43feaccf093b6cf4b9a9.png">  back: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Unwrapped_t = ApplyDependency_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (logr0), <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (Ln (r0)), Formula_t&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Derivative_t = VarDerivative_t&lt;Unwrapped_t, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (r0)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CacheLog_t = ApplyDependency_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (Ln (r0)), <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (logr0), Derivative_t&gt;;</code> </pre> <br>  The implementation is verbose, but ideologically simple.  Recursively descend the formula tree, replacing an element of the tree, if it exactly matches the template, otherwise we change nothing.  Total three specializations: for descending a child node of a unary function, for descending a child nodes of a binary function, and for a replacement itself, while specializations for descending a child nodes should check that the pattern does not match the subtree corresponding to the subfunction in question: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Formula, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Enable = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; struct ApplyDependency { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result_t = Formula; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Formula&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ApplyDependency_t = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ApplyDependency&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;Var&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;Expr&gt;, Formula&gt;::Result_t; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr, UnaryFunction UF, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Child&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplyDependency</span></span></span><span class="hljs-class">&lt;Var, Expr, Node&lt;UnaryFunctionWrapper&lt;UF&gt;, Child&gt;, std::enable_if_t&lt;!std::is_same&lt;Var, Node&lt;UnaryFunctionWrapper&lt;UF&gt;, Child&gt;&gt;::value&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result_t = Node&lt; UnaryFunctionWrapper&lt;UF&gt;, ApplyDependency_t&lt;Var, Expr, Child&gt; &gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr, BinaryFunction BF, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FirstNode, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SecondNode&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplyDependency</span></span></span><span class="hljs-class">&lt;Var, Expr, Node&lt;BinaryFunctionWrapper&lt;BF&gt;, FirstNode, SecondNode&gt;, std::enable_if_t&lt;!std::is_same&lt;Var, Node&lt;BinaryFunctionWrapper&lt;BF&gt;, FirstNode, SecondNode&gt;&gt;::value&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result_t = Node&lt; BinaryFunctionWrapper&lt;BF&gt;, ApplyDependency_t&lt;Var, Expr, FirstNode&gt;, ApplyDependency_t&lt;Var, Expr, SecondNode&gt; &gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Var, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Expr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplyDependency</span></span></span><span class="hljs-class">&lt;Var, Expr, Var&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result_t = Expr; };</code> </pre> <br>  Ffuh.  It remains to understand the transfer of parameter values. <br><br>  Recall that each parameter has its own type, so if we build a family of functions, overloaded with the type of parameters, each of which returns the corresponding value, then again (just like with the calculation of unary functions a little earlier) there is a chance that the compiler will turn this thing and he is optimizing (by the way, he is optimizing, such a clever girl).  Well, something like: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Variable&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value_for_x0; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Variable&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value_for_x1; } ...</code> </pre> <br>  Only we want to make it beautiful so that you can write, for example: <br><br><pre> <code class="hljs lisp">BuildFunctor (<span class="hljs-name"><span class="hljs-name">g0</span></span>, someValue, alpha0, anotherValue, k, yetOneMoreValue, r0, independentVariable, logr0, logOfTheIndependentVariable)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  where <code>g0</code> , <code>alpha0</code> and company are objects that have the types of the corresponding variables, followed by the corresponding values. <br><br>  How can we cross a hedgehog and a hedgehog, having made a function in general, the type of the parameter of which is set in compile-time and the value in runtime?  Lambdas rush to the rescue! <br><br><pre> <code class="hljs kotlin">template&lt;typename ValueType, typename NodeType&gt; auto BuildFunctor (NodeType, ValueType <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>] (NodeType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; }; }</code> </pre> <br>  Suppose we have two such functions, how can we get a family of functions in the same namespace so that the desired one is chosen by overloading?  Inheritance to the rescue! <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> :</span></span> F, S { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> F::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> S::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); Map (F f, S s) : F { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt; (f) } , S { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;S&gt; (s) } { } };</code> </pre> <br>  We inherit from both lambdas (after all, lambda expands into a structure with a name generated by the compiler, which means that we can inherit from it) and bring their round-brackets to the script. <br><br>  Moreover, it is possible to inherit not only from lambdas, but also from arbitrary structures that have some round-bracket operators.  <s>Oops, got algebra.</s>  Thus, if there are N lambdas, you can inherit the first <code>Map</code> from the first two lambdas, the next <code>Map</code> from the first <code>Map</code> and the next lambda, and so on.  Let's make it in the form of a code: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Augment</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Augment</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, S&amp;&amp; s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Map&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;F&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;S&gt;&gt; { f, s }; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildFunctor</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">ValueType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = ValueType; } dummy; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dummy; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NodeType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Tail&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildFunctor</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NodeType, ValueType val, Tail&amp;&amp;... tail)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::Augment ([val] (NodeType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }, BuildFunctor&lt;ValueType&gt; (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tail&gt; (tail)...)); }</code> </pre> <br>  Automatically we get the completeness and uniqueness: if some arguments are not given, it will be a compilation error, as well as if some arguments are given twice. <br><br>  Actually, everything. <br><br>  Unless, one of my friends, to whom I showed it at one time, offered, in my opinion, a more elegant solution on constexpr-functions, but I haven't reached my hand for 9 months already. <br><br>  Well, the link to the library: <a href="https://github.com/0xd34df00d/IAmMad">I Am Mad</a> .  Not ready for production, pull-walks are accepted, and so on. <br><br>  Well, you can still wonder how clever modern compilers can wipe through all these layers of templates over templates over lambdas over templates and generate a fairly optimal code. </div><p>Source: <a href="https://habr.com/ru/post/310016/">https://habr.com/ru/post/310016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310000/index.html">How we repaired compaction in Cassandra for a week</a></li>
<li><a href="../310002/index.html">Hypervisor wars: To be continued</a></li>
<li><a href="../310006/index.html">AdBlock Plus has made a new milestone in the history of "acceptable advertising"</a></li>
<li><a href="../310008/index.html">The Myth of the Immaturity of Mobile NFC Technologies</a></li>
<li><a href="../310014/index.html">OpenJDK: Project Panama</a></li>
<li><a href="../310022/index.html">PaaS, DBaaS, SaaS ... What does all this mean?</a></li>
<li><a href="../310024/index.html">The story of one programmer</a></li>
<li><a href="../310026/index.html">One day programmers will destroy this world</a></li>
<li><a href="../310028/index.html">My way is a programmer. From QA student to remote Java developer</a></li>
<li><a href="../310030/index.html">Community Messages and Webweek from Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>