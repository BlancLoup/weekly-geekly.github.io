<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How was Aichtalka created. Part 1: engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most recently, we have released the first beta version of our online reader, which can be found by reading the book ‚Äú Hero of Our Time ‚Äù by Mikhail Le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How was Aichtalka created. Part 1: engine</h1><div class="post__text post__text-html js-mediator-article">  Most recently, we have released the first beta version of our online reader, which can be found by reading the book ‚Äú <a href="http://www.imobilco.ru/books/-/57168/read/">Hero of Our Time</a> ‚Äù by Mikhail Lermontov.  This reader is the result of almost seven months of work, five of which took only to develop the engine.  It would seem that there are already free and open JavaScript engines for reading electronic books on the Internet and such a long period of time may raise doubts as to the professional suitability of the developer (that is, me).  But there is one big and fat "BUT".  We set ourselves too ambitious and difficult task: we wanted to use the same engine on different devices, including low-power ones, such as an iPhone or electronic reader. <br><br>  What is the difficult task?  First of all - at a very low speed of web applications on the iPhone.  For example, the mobile Safari according to my estimates runs 100 times slower than its desktop counterpart.  If the same operation is performed on the deckstop machine for 10 ms and is completely invisible to the user, then on the iPhone it can be performed for more than a second.  For comparison: the first version of the engine broke a small chapter into pages in about 15 seconds.  Now, six months later, he does the same thing in less than a second and works reasonably well in our application <a href="http://itunes.apple.com/ru/app/booq/id329197020%3Fmt%3D8">booq</a> . <br><br>  In this article I will not focus on how to make your reader, but I will share the experience of optimizing a web application for iPhone.  The article will be interesting not only to developers for mobile devices, but also to ordinary web technologists.  After all, if your application / website will quickly work on a mobile device, then imagine how fast it will work on the desktop. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h2>  Task </h2><br>  For a start it is worth explaining why we chose web technologies as the basis for the reader.  First, it is their prevalence.  Now it is quite difficult to find a device that does not have a built-in browser.  Phones, computers, netbooks, tablets, e-books - they are all capable of reading HTML, decorate it with CSS and animate via JavaScript.  Having the same engine, we can easily create applications for different platforms and devices.  Secondly, not a single ‚Äúclassic‚Äù reader engine is able to display what a web browser can do.  Tables, vector graphics, audio / video content, interactive elements - all this has been successfully working in browsers for a long time.  Imagine that you are reading a scientific book and immediately see a video demonstrating the described process.  Well, or read a detective story in which you need to go through a puzzle to open the next chapter :).  Opportunities are limited only by the imagination and skills of the developer. <br><br>  All this is a beautiful marketing wrapper, but let's get down from heaven to earth and see what the engine should be from a technical point of view: <br><br><ul><li>  be cross-browser and cross-platform; </li><li>  have a modular structure to make it easier to create versions for different devices; </li><li>  support two modes of reading: page by page and scrolling (like a regular web page), and also quickly switch between them; </li><li>  handle chapters with a volume of 1 MB + (for comparison: the first volume of ‚ÄúWar and Peace‚Äù by Tolstoy weighs 1.2 MB); </li><li>  have flexible appearance settings (in fact, limited by CSS capabilities). </li></ul><br><br>  The iPhone 2G with firmware 3.1 and the chapter from Ivan Mironov's book ‚ÄúZamulennye‚Äù weighing 500 KB were used as a test site.  Such a large chapter is the exception rather than the rule, but it sets a good bar for performance, below which you should not fall. <br><br>  So let's proceed to optimization. <br><br><h2>  JS code size </h2><br>  Immediately I want to upset those who like to set up a bunch of frameworks on the page and load them with plugins to solve simple tasks like dragging blocks or selecting elements by CSS selector: the amount of JS code on the page is of great importance, at least for mobile Safari.  For example, parsing and initialization of the popular jQuery takes 1400 ms for the original, uncompressed version (155 KB) and 1200 ms for the compressed (76 KB).  Despite the fact that the compressed version is 2 times smaller than the original, they are identical in functionality: hence the ‚Äúsmall‚Äù difference in the speed of parsing.  That is, speed is not affected by the length of variable names, but by the number of functions, objects, methods, and so on.  For comparison: on the desktop the parsing takes about 30 ms. <br><br>  Ideal: keep all the JS code at the very bottom of the page and generally abandon the frameworks.  Since WebKit itself supports a lot of things, I rendered standard DOM operations (adding events, searching for elements by a selector, etc.) as a separate additional module, and for the desktop version I redefined this layer so that the calls were broadcast in jQuery . <br><br><h2>  HTML parsing </h2><br>  The reader itself is focused on the ePub format, in which each chapter of the book is represented by a separate document in the XHTML format.  The chapter must somehow be passed to JavaScript, so that it parses it, paginated it, and began to show. <br><br>  Here it is worth saying a few words about the principle of displaying content on the screen.  Let me remind you that the engine should support two reading modes: paginated and ‚Äúfootcloth‚Äù.  Therefore, I decided to frame all the content in two wrappers: the first is a kind of ‚Äúwindow‚Äù, and the second shifts the content up and down.  Selecting the correct window size and content offset, you can create the illusion of a paginated chapter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d0/59f/13a/0d059f13a23bb403769c59b9d9d6ec98.png" width="232" height="345"><br><br>  Since in any case I need all the contents of the chapter, and for calculating the size of the pages I need full DOM elements, I decided to put the chapter directly into HTML: <br><br><blockquote><code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">div</font> <font color="#ff0000">id</font> <font color="#0000ff">="window"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">div</font> <font color="#ff0000">id</font> <font color="#0000ff">="content"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">p</font> <font color="#0000ff">&gt;</font>  ‚Ä¶    ,   ‚Ä¶ <font color="#0000ff">&lt;/</font> <font color="#800000">p</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">div</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">div</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br><br>  And then he ran into a serious problem: the parsing and the accompanying display of the chapter lasted as much as 7 seconds.  I assumed that it was the content rendering that took most of the time, so as an experiment I hid the content using <code>display: none</code> : <br><br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">div</font> <font color="#ff0000">id</font> <font color="#0000ff">="window"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">div</font> <font color="#ff0000">id</font> <font color="#0000ff">="content"</font> <font color="#ff0000">style</font> <font color="#0000ff">="display:none"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">p</font> <font color="#0000ff">&gt;</font>  ‚Ä¶    ,   ‚Ä¶ <font color="#0000ff">&lt;/</font> <font color="#800000">p</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">div</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">div</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br><br>  At this time, the page parsing took 800 ms, which is very good: accelerated almost 10 times.  And since the iPhone has a rather small screen, it was enough to get some of the first elements from the tree and show them so that the user could start reading while the chapter is being read. <br><br>  In principle, this is already a pretty big victory in terms of performance and you could do other things, but intuition tells me that you can further reduce the parsing time. <br><br>  I assumed that when HTML is right in the body of the document, the browser takes some additional steps so that the elements can appear on the page at the right moment.  For example, finding and applying appropriate CSS rules.  I personally do not need these actions at the moment: I need to transfer the contents of the chapter as a DOM tree directly into JavaScript as soon as possible.  How to force the browser not to parse a specific document fragment?  Correctly, comment it out: <br><br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">div</font> <font color="#ff0000">id</font> <font color="#0000ff">="window"</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">div</font> <font color="#ff0000">id</font> <font color="#0000ff">="content"</font> <font color="#0000ff">&gt;</font> <br> <font>&lt;!--</font> <br> <font>&lt;p&gt; ‚Ä¶    ,   ‚Ä¶&lt;/p&gt;</font> <br> <font>--&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">div</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">div</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br><br>  Laugh laugh, but the page parsing time was reduced to 350 ms.  And the comment is a full-fledged DOM element that can be accessed via JavaScript and get its contents: <br><br><blockquote> <code><font color="black"><font color="#0000ff">var</font> elems = <font color="#0000ff">document</font> .getElementById( <font color="#A31515">'content'</font> ).childNodes; <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0, il = elems.length; i &lt; il; i++) { <br> <font color="#0000ff">var</font> el = elems[i]; <br> <font color="#0000ff">if</font> (el.nodeType == 8) { <font color="#008000">//comment</font> <br> <font color="#0000ff">var</font> div = <font color="#0000ff">document</font> .createElement( <font color="#A31515">'div'</font> ); <br> div.innerHTML = el.nodeValue; <br> <font color="#008000">//  div   DOM-,    </font> <br> <font color="#0000ff">break</font> ; <br> } <br> }</font></code> </blockquote> <br><br>  The total time of parsing the page and parsing the code into the tree was about 550 ms (against 800 ms in the previous version), which, in my opinion, is very good. <br><br><h2>  Calculate page sizes </h2><br>  So, I received the contents of the chapter and parsed it, now I need to break the chapter into pages.  During the optimization of parsing, I realized that my initial version of the chapter output in page mode as a window and moving content had a number of drawbacks.  First, you need to display (draw) the entire chapter, which, as you already understood, takes a very long time.  Secondly, in this situation, I could not display more than one page on the screen: for the second page, I would have to completely duplicate the entire chapter, which, again, would be slow and would inevitably cause the application to crash due to lack of memory on large chapters. <br><br>  After about two months of unsuccessful attempts to write a page breakdown with an acceptable execution time, a fairly good solution was found.  In short, what it is. <br><br>  In fact, the chapter of the book is a set of paragraphs.  Paragraphs can be represented as elements of the first level.  Taking into account the speed of rendering HTML-content in the iPhone, for the fastest display of one page, you need to determine the minimum set of first-level elements that is necessary for its presentation.  I have an entire chapter in the form of a list of first-level items, as well as a list of pages.  A page is an object in which the ordinal numbers of the first and the first level element, window size and offset are stored.  It turned out to be a rather compact and fast design: to display one page, it is enough to clone a set of first-level elements and display them on the screen, indicating the correct offset and window size. <br><br>  In order to calculate all the pages, you need to know the dimensions of each element of the first level, their internal and external indents, borders, font size and so on.  To get all this data, elements must be on the page and styles should be applied to them.  For these purposes, I created a special hidden container that inherits all the style descriptions of the page itself, added paragraphs to it and carried out calculations. <br><br>  To obtain the necessary characteristics of the element, you need to refer to its CSS properties.  I took the <code>css()</code> function from jQuery as a basis: <br><br><blockquote> <code><font color="black"><font color="#0000ff">function</font> getCSS(elem, name) { <br> <font color="#0000ff">if</font> (elem.style[name]) { <br> <font color="#0000ff">return</font> elem.style[name]; <br> } <font color="#0000ff">else</font> { <br> <font color="#0000ff">var</font> cs = window.getComputedStyle(elem, <font color="#A31515">""</font> ); <br> <font color="#0000ff">return</font> cs &amp;&amp; cs.getPropertyValue(name); <br> } <br> } <br></font></code> </blockquote><br><br>  Since I needed to get quite a few properties at once, this is a function, judging by the profiler from the Web Inspector (the desktop browser is meant, there are no such debugging tools on the iPhone, which greatly complicates the work) was the slowest.  As it turned out, the call to <code>getComputedStyle()</code> is very expensive in terms of performance.  Therefore, I modified this function so that I could give an array of properties that need to be obtained, and also removed the check <code>elem.style[name]</code> , since in 99% of cases the elements were not exposed to CSS properties through the <code>style</code> object and this optimization was more harmful than helped: <br><br><blockquote> <code><font color="black"><font color="#0000ff">function</font> getCSS(elem, name) { <br> <font color="#0000ff">var</font> names = ( <font color="#0000ff">typeof</font> name == <font color="#A31515">'string'</font> ) ? [name] : name, <br> cs = window.getComputedStyle(elem, <font color="#A31515">""</font> ), <br> result = {}; <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0, il = names.length; i &lt; il; i++) { <br> <font color="#0000ff">var</font> n = names[i]; <br> result[n] = cs &amp;&amp; cs.getPropertyValue(n); <br> } <br> <br> <font color="#0000ff">return</font> ( <font color="#0000ff">typeof</font> name == <font color="#A31515">'string'</font> ) ? result[name] : result; <br> }</font></code> </blockquote> <br><br>  After such an optimization, the <code>getCSS()</code> function did not even fall into the first three of the slowest functions :). <br><br>  The next step: correctly "smear" the calculation of pages in time.  The fact is that while JS is being executed, the browser interface is completely blocked, and restrictions on the execution time of the script also take effect.  It could be a situation that the screen ‚Äúfreezes‚Äù seconds for 20-30, and then completely falls out with an error about exceeding the timeout for execution.  The modern way to get rid of such problems is <a href="https://developer.mozilla.org/En/Using_web_workers">Web Workers</a> , but mobile Safari does not support them.  Therefore, we will use the proven ‚Äúold-fashioned‚Äù method that works in all browsers: call each iteration of page counting via <code>setTimeout()</code> .  Sample code for this solution: <br><br><blockquote> <code><font color="black"><font color="#0000ff">function</font> calculatePages(elems, callback) { <br> <font color="#008000">// elems ‚Äî  ,   </font> <br> <font color="#0000ff">var</font> cur_elem = 0; <br> <br> <font color="#0000ff">var</font> run = <font color="#0000ff">function</font> () { <br> createPage(elems[cur_elem]); <font color="#008000">//   </font> <br> <br> cur_elem++; <br> <font color="#0000ff">if</font> (cur_elem &lt; elems.length) <br> setTimeout(run, 1); <br> <font color="#0000ff">else</font> <br> callback(); <font color="#008000">//  </font> <br> }; <br> <br> run(); <br> }</font></code> </blockquote> <br><br>  The function works as follows.  For example, we need to calculate 30 elements of the first level.  We give an array of these elements to the function <code>calculatePages()</code> , inside which the closure is created as a <code>run()</code> function, which is one iteration of the calculation.  When finished to count we check whether there are still elements in the array.  If yes, then through <code>setTimeout()</code> call a new iteration, otherwise we call the callback function, informing that the calculation is over and we can move on. <br><br>  There is one important aspect to this approach - this is a load per iteration.  In this case, how many elements need to be calculated in one call of the <code>run()</code> function.  If, for example, one element is counted for one iteration, the interface for the user will be as responsive as possible, but the total calculation time for the entire chapter may increase by 2-3 times due to the overhead incurred when the function is started via <code>setTimeout()</code> .  If we count 10 elements in a single pass, the total calculation time for the chapter will decrease, but the interface responsiveness will also decrease and the risk will not go beyond the timeout if the paragraphs are very large. <br><br>  Therefore, you need to find a certain middle ground, so that the calculation time does not greatly increase, and not reduce the responsiveness of the interface.  I decided to focus not on the number of elements of the first level, but on their volume, which can be obtained through the <code>innerHTML</code> property or <code>textContent</code> .  The value of 5 KB was chosen as the threshold volume by trial and error.  Before calling <code>calculatePages()</code> I divided all the objects into groups: as soon as the total volume of one group became larger than 5 KB, it was closed and a new one was created.  Accordingly, the calculation of page sizes was carried out not by individual elements, but by groups. <br><br><h2>  Deleting items </h2><br>  After counting one group, you need to clear the hidden container and free up resources for the next group of elements.  The easiest way to clear the contents of a container is to reset the <code>innerHTML</code> property: <br><br><blockquote> <code><font color="black"><font color="#0000ff">function</font> emptyElement(elem) { <br> elem.innerHTML = <font color="#A31515">''</font> ; <br> }</font></code> </blockquote> <br><br>  However, ‚Äúthe simplest‚Äù does not always mean ‚Äúthe fastest‚Äù - as the measurements showed, this method works much faster: <br><br><blockquote> <code><font color="black"><font color="#0000ff">function</font> emptyElement(elem) { <br> <font color="#0000ff">while</font> (elem.firstChild) <br> elem.removeChild(elem.firstChild); <br> }</font></code> </blockquote> <br><br>  Perhaps, for now.  In this article, some features of parsing and calculating large amounts of data on low-power devices were considered.  In practice, all the tricks described were very effective.  For example, I tested a chapter with a volume of more than 1 MB: our reader was able to digest it in about 30-40 seconds, while other (and quite popular) readers from the AppStore, written in Objective C / C ++, simply fell. <br><br>  In the next article we will look at some of the factors that influence the time spent on drawing one page in an iPhone, as well as some tricks that allow this time to be noticeably reduced. <br><br>  <em>Sergey Chikuyonok</em> </div><p>Source: <a href="https://habr.com/ru/post/95249/">https://habr.com/ru/post/95249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../95239/index.html">It is finished. Now you can change the folder name or tag in Google Reader</a></li>
<li><a href="../95240/index.html">Juniper Research on the growth of mobile VoIP</a></li>
<li><a href="../95241/index.html">Validation of layout of popular sites</a></li>
<li><a href="../95244/index.html">Payoneer cards, who issues?</a></li>
<li><a href="../95245/index.html">Ten things that a real programmer knows, even if they are not taught in universities</a></li>
<li><a href="../95250/index.html">Android Training Seminars in St. Petersburg (registration completed)</a></li>
<li><a href="../95253/index.html">Belarus will decide on the registration of mailboxes in the coming days</a></li>
<li><a href="../95257/index.html">Minsk Mobile Tech Meetup - June 5</a></li>
<li><a href="../95261/index.html">Tesla and Toyota deal details announced</a></li>
<li><a href="../95263/index.html">Following the release of the new application for the iPhone, Skype prepared video calls for the Nokia N900</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>