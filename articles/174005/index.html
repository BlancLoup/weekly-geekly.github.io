<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization history alpha_composite in Pillow 2.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently released the second version of the Python library for working with images Pillow . As many know, this is a fork of the well-known library PIL...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization history alpha_composite in Pillow 2.0</h1><div class="post__text post__text-html js-mediator-article">  Recently released the second version of the Python library for working with images <a href="https://github.com/python-imaging/Pillow">Pillow</a> .  As many know, this is a fork of the well-known library PIL, which, despite its considerable age, until recently remained the most sane way of working with images in Python.  Pillow authors finally decided not only to maintain the old code, but also to add new features.  And one of these features is the alpha_composite () function. <br><br>  This function implements the mixing of two semi-transparent images.  This task is a general case of overlaying an image with an alpha channel onto an opaque background, which is probably familiar to many.  About mixing translucent images can be read on <a href="http://en.wikipedia.org/wiki/Alpha_compositing">Wikipedia</a> .  About this I once wrote a long time <a href="http://habrahabr.ru/post/98743/">article</a> . <br><br>  Since then, I have been able to write for my needs a more <a href="https://gist.github.com/homm/5228226">optimal implementation</a> than is given at the end of that article.  And it turned out that this implementation is faster alpha_composite () from the new version of Pillow, written in C.  Of course, it flattered me, but I still decided to try to improve the implementation of Pillow. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First you need a test bench. <br><br><div class="spoiler">  <b class="spoiler_title">bench.py</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> timeit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> repeat <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> paste_composite im1 = Image.open(<span class="hljs-string"><span class="hljs-string">'in1.png'</span></span>) im1.load() im2 = Image.open(<span class="hljs-string"><span class="hljs-string">'in2.png'</span></span>) im2.load() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> repeat(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: paste_composite(im1.copy(), im2), number=<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> repeat(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: Image.alpha_composite(im1, im2), number=<span class="hljs-number"><span class="hljs-number">100</span></span>) out1 = im1.copy() paste_composite(out1, im2) out1.save(<span class="hljs-string"><span class="hljs-string">'out1.png'</span></span>) out2 = Image.alpha_composite(im1, im2) out2.save(<span class="hljs-string"><span class="hljs-string">'out2.png'</span></span>)</code> </pre> </div></div><br>  The script takes the files in1.png and in2.png in the current folder and mixes them a hundred times first with the function paste_composite (), then alpha_composite ().  I took the files from the previous article ( <a href="">one</a> , <a href="">two</a> ).  The runtime paste_composite () averaged me 235ms.  The running time of the original alpha_composite () was 400ms. <br><br>  Why alpha_composite () is so slow, I didn‚Äôt have to guess for a long time.  Looking at the <a href="">implementation</a> , it is clear that the function performs all calculations on floating-point numbers.  When working with graphics, floating-point numbers make it quite simple to describe the algorithm, but they always have lower performance than integer numbers.  The first thing I did was transfer everything to work with integers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> UINT8 r; UINT8 g; UINT8 b; UINT8 a; } rgba8; <span class="hljs-function"><span class="hljs-function">Imaging </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImagingAlphaComposite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Imaging imDst, Imaging imSrc)</span></span></span><span class="hljs-function"> </span></span>{ Imaging imOut = ImagingNew(imDst-&gt;mode, imDst-&gt;xsize, imDst-&gt;ysize); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; imDst-&gt;ysize; y++) { rgba8* dst = (rgba8*) imDst-&gt;image[y]; rgba8* src = (rgba8*) imSrc-&gt;image[y]; rgba8* out = (rgba8*) imOut-&gt;image[y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; imDst-&gt;xsize; x ++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src-&gt;a == <span class="hljs-number"><span class="hljs-number">0</span></span>) { *out = *dst; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UINT16 blend = dst-&gt;a * (<span class="hljs-number"><span class="hljs-number">255</span></span> - src-&gt;a); UINT8 outa = src-&gt;a + blend / <span class="hljs-number"><span class="hljs-number">255</span></span>; UINT8 coef1 = src-&gt;a * <span class="hljs-number"><span class="hljs-number">255</span></span> / outa; UINT8 coef2 = blend / outa; out-&gt;r = (src-&gt;r * coef1 + dst-&gt;r * coef2) / <span class="hljs-number"><span class="hljs-number">255</span></span>; out-&gt;g = (src-&gt;g * coef1 + dst-&gt;g * coef2) / <span class="hljs-number"><span class="hljs-number">255</span></span>; out-&gt;b = (src-&gt;b * coef1 + dst-&gt;b * coef2) / <span class="hljs-number"><span class="hljs-number">255</span></span>; out-&gt;a = outa; } dst++; src++; out++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> imOut; }</code> </pre><br>  And immediately received a gain of 5.5 times.  The test worked out for 75 ms. <br><br>  Good result, but it was necessary to check how good the picture was.  Nothing is better than taking as a benchmark the result of Photoshop, I did not invent.  In appearance, the two images were indistinguishable from those in Photoshop, so I had to figure out how to more accurately visualize the differences. <br><br><div class="spoiler">  <b class="spoiler_title">diff.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import sys from PIL import Image, ImageMath def chanel_diff(c1, c2): c = ImageMath.eval('127 + c1 - c2', c1=c1, c2=c2).convert('L') return c.point(lambda c: c if 126 &lt;= c &lt;= 128 else 127 + (c - 127) * 10) im1 = Image.open(sys.argv[1]) im2 = Image.open(sys.argv[2]) diff = map(chanel_diff, im1.split(), im2.split()) Image.merge('RGB', diff[:-1]).save('diff.png', optimie=True) diff[-1].convert('RGB').save('diff.alpha.png', optimie=True)</span></span></code> </pre></div></div><br>  The script accepts 2 file names with pictures as input.  There are differences between each pair of channels of these pictures: first, the difference is simply searched and added up with a gray background (value 127) so that you can see deviations in both directions.  Then all deviations, stronger than one value, are amplified 10 times, so that they are visible visually.  The result of the comparison is recorded in 2 files: rgb channels in diff.png, alpha channel in the form of shades of gray in diff.alpha.png. <br><br>  It turned out that the difference between the alpha_composite () result and Photoshop is quite significant: <br><img src="https://habrastorage.org/storage2/192/613/49c/19261349c0b4690fb6bbccbc0d762cd1.png"><br><br>  Looking carefully at the code again, I realized that I had forgotten about rounding: integers are divided with a drop of the remainder.  If we want to get a rounded result, we need to add half of the divisor to the dividend: <br><br><pre> <code class="cpp hljs">UINT16 blend = dst-&gt;a * (<span class="hljs-number"><span class="hljs-number">255</span></span> - src-&gt;a); UINT8 outa = src-&gt;a + (blend + <span class="hljs-number"><span class="hljs-number">127</span></span>) / <span class="hljs-number"><span class="hljs-number">255</span></span>; UINT8 coef1 = src-&gt;a * <span class="hljs-number"><span class="hljs-number">255</span></span> / outa; UINT8 coef2 = blend / outa; out-&gt;r = (src-&gt;r * coef1 + dst-&gt;r * coef2 + <span class="hljs-number"><span class="hljs-number">127</span></span>) / <span class="hljs-number"><span class="hljs-number">255</span></span>; out-&gt;g = (src-&gt;g * coef1 + dst-&gt;g * coef2 + <span class="hljs-number"><span class="hljs-number">127</span></span>) / <span class="hljs-number"><span class="hljs-number">255</span></span>; out-&gt;b = (src-&gt;b * coef1 + dst-&gt;b * coef2 + <span class="hljs-number"><span class="hljs-number">127</span></span>) / <span class="hljs-number"><span class="hljs-number">255</span></span>; out-&gt;a = outa;</code> </pre><br>  Work time increased to 94 ms.  But the differences from the reference has become much smaller.  However, they did not disappear at all. <br><br>  In principle, one could dwell on this: the discrepancies that are present at this point are mainly concentrated in pixels with high transparency, which makes the value of the color channel not so significant.  But having checked the original version of alpha_composite () just in case, I found out that it practically does not disagree with the standard.  It was impossible to stop there. <br><br>  Obviously, the resulting inaccuracies are the result of insufficient accuracy of the coefficients when multiplying.  You can store additional significant bits for each variable, which improves division accuracy.  The variable blend is calculated without division, nothing needs to be done with it.  The variable outa is obtained by dividing the blend by 255. When calculating, we shift the values ‚Äã‚Äãof the blend and src-&gt; a by 4 bits up.  As a result, there will be 12 significant bits in the outa.  In both coefficients, the division by outa occurs, which is now more by 4 bits.  Plus the coefficients themselves would like to get 4 bits more.  As a result, the dividend is shifted by 8 bits. <br><br><pre> <code class="cpp hljs">UINT16 blend = dst-&gt;a * (<span class="hljs-number"><span class="hljs-number">255</span></span> - src-&gt;a); <span class="hljs-comment"><span class="hljs-comment">// 16 bit max UINT16 outa = (src-&gt;a &lt;&lt; 4) + ((blend &lt;&lt; 4) + 127) / 255; // 12 UINT16 coef1 = ((src-&gt;a * 255) &lt;&lt; 8) / outa; // 12 UINT16 coef2 = (blend &lt;&lt; 8) / outa; // 12 out-&gt;r = ((src-&gt;r * coef1 + dst-&gt;r * coef2 + 0x7ff) / 255) &gt;&gt; 4; out-&gt;g = ((src-&gt;g * coef1 + dst-&gt;g * coef2 + 0x7ff) / 255) &gt;&gt; 4; out-&gt;b = ((src-&gt;b * coef1 + dst-&gt;b * coef2 + 0x7ff) / 255) &gt;&gt; 4; out-&gt;a = (outa + 0x7) &gt;&gt; 4;</span></span></code> </pre><br>  Of course, the same 4 bits should be used to shift the result of all calculations before placing it in the image pixels.  This option works even slightly slower: 108 ms, but it practically has no pixels that differ by more than one value from the standard.  The quality result is achieved, you can again think about performance. <br><br>  Obviously, such code is not the most optimal from the point of view of the processor.  Division is one of the most difficult tasks, and here, as many as 6 divisions are performed for each pixel.  It turned out that getting rid of most of them is quite simple.  In the same PIL, in the Paste.c file, a method of quick division with rounding is described: <br> <code>a + 127 / 255 ‚âà ((a + 128) + ((a + 128) &gt;&gt; 8)) &gt;&gt; 8</code> <br> <br>  As a result, one division is replaced by 2 shifts and one addition, which is faster on most processors.  Having grouped one of the shifts with the already existing shift by 4, I received the following code: <br><br><pre> <code class="cpp hljs">UINT16 blend = dst-&gt;a * (<span class="hljs-number"><span class="hljs-number">255</span></span> - src-&gt;a); UINT16 outa = (src-&gt;a &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + (((blend &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + (blend &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x80</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); UINT16 coef1 = (((src-&gt;a &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) - src-&gt;a) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) / outa; <span class="hljs-comment"><span class="hljs-comment">// 12 UINT16 coef2 = (blend &lt;&lt; 8) / outa; // 12 UINT32 tmpr = src-&gt;r * coef1 + dst-&gt;r * coef2 + 0x800; out-&gt;r = ((tmpr &gt;&gt; 8) + tmpr) &gt;&gt; 12; UINT32 tmpg = src-&gt;g * coef1 + dst-&gt;g * coef2 + 0x800; out-&gt;g = ((tmpg &gt;&gt; 8) + tmpg) &gt;&gt; 12; UINT32 tmpb = src-&gt;b * coef1 + dst-&gt;b * coef2 + 0x800; out-&gt;b = ((tmpb &gt;&gt; 8) + tmpb) &gt;&gt; 12; out-&gt;a = (outa + 0x7) &gt;&gt; 4;</span></span></code> </pre><br>  It is executed already in 65 ms and does not make any changes in the result compared with the previous version. <br><br>  Overall, the speed of work was improved by 6 times, a pull request was sent to the repository.  One could try to achieve greater similarity with the standard.  For example, I managed to perfectly repeat the alpha channel generated by Photoshop, but at the same time more distortions were introduced to the pixels. <br><br>  <b>Big update</b> <br><br>  Once again, I thought about what was done and decided that it was foolish to be equal to the Photoshop algorithm, which is unknown for what tasks it was made and the implementation of which cannot even be viewed.  It is necessary to take the work of the algorithm on floats for reference.  I have slightly modified the script that finds the differences so that it displays some statistics. <br><br><div class="spoiler">  <b class="spoiler_title">diff.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import sys from PIL import Image, ImageMath def chanel_diff(c1, c2): return ImageMath.eval('127 + c1 - c2', c1=c1, c2=c2).convert('L') def highlight(c): return c.point(lambda c: c if 126 &lt;= c &lt;= 128 else 127 + (c - 127) * 10) im1 = Image.open(sys.argv[1]) im2 = Image.open(sys.argv[2]) diff = map(chanel_diff, im1.split(), im2.split()) if len(sys.argv) &gt;= 4: highlight(Image.merge('RGB', diff[:-1])).save('%s.png' % sys.argv[3]) highlight(diff[-1]).convert('RGB').save('%s.alpha.png' % sys.argv[3]) def stats(ch): return sorted((c, n) for n, c in ch.getcolors()) for ch, stat in zip(['red ', 'grn ', 'blu ', 'alp '], map(stats, diff)): print ch, ' '.join('{}: {:&gt;5}'.format(c, n) for c, n in stat)</span></span></code> </pre></div></div><br>  I also prepared a very serious test case of two 16 megapixel pictures, where each combination of pixels was unique. <br><br><div class="spoiler">  <b class="spoiler_title">make_testcase.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_test_images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dim)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Plese, be careful with dim &gt; 32. Result image is have dim ** 4 pixels (ie 1Mpx for 32 dim or 4Gpx for 256 dim). """</span></span> i1 = bytearray(dim ** <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>) i2 = bytearray(dim ** <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>) res = <span class="hljs-number"><span class="hljs-number">255.0</span></span> / (dim - <span class="hljs-number"><span class="hljs-number">1</span></span>) rangedim = range(dim) pos = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rangedim: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rangedim: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rangedim: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rangedim: i1[pos] = int(res * l1) i1[pos + <span class="hljs-number"><span class="hljs-number">1</span></span>] = int(res * a1) i2[pos] = int(res * l2) i2[pos + <span class="hljs-number"><span class="hljs-number">1</span></span>] = int(res * a2) pos += <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'%s of %s'</span></span> % (l1, dim) i1 = Image.frombytes(<span class="hljs-string"><span class="hljs-string">'LA'</span></span>, (dim ** <span class="hljs-number"><span class="hljs-number">2</span></span>, dim ** <span class="hljs-number"><span class="hljs-number">2</span></span>), bytes(i1)) i2 = Image.frombytes(<span class="hljs-string"><span class="hljs-string">'LA'</span></span>, (dim ** <span class="hljs-number"><span class="hljs-number">2</span></span>, dim ** <span class="hljs-number"><span class="hljs-number">2</span></span>), bytes(i2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i1.convert(<span class="hljs-string"><span class="hljs-string">'RGBA'</span></span>), i2.convert(<span class="hljs-string"><span class="hljs-string">'RGBA'</span></span>) im1, im2 = prepare_test_images(<span class="hljs-number"><span class="hljs-number">63</span></span>) im1.save(<span class="hljs-string"><span class="hljs-string">'im1.png'</span></span>) im2.save(<span class="hljs-string"><span class="hljs-string">'im2.png'</span></span>)</code> </pre></div></div><br>  After that, I decided to start from the other end: do not try to increase the accuracy of the integer algorithm, but try to bring the floating point algorithm to work with integers.  This is where I started: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dsta = dst-&gt;a / <span class="hljs-number"><span class="hljs-number">255.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> srca = src-&gt;a / <span class="hljs-number"><span class="hljs-number">255.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> blend = dsta * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - srca); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> outa = srca + blend; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> coef1 = srca / outa; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> coef2 = <span class="hljs-number"><span class="hljs-number">1</span></span> - coef1; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmpr = src-&gt;r * coef1 + dst-&gt;r * coef2; out-&gt;r = (UINT8) (tmpr + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmpg = src-&gt;g * coef1 + dst-&gt;g * coef2; out-&gt;g = (UINT8) (tmpg + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmpb = src-&gt;b * coef1 + dst-&gt;b * coef2; out-&gt;b = (UINT8) (tmpb + <span class="hljs-number"><span class="hljs-number">0.5</span></span>); out-&gt;a = (UINT8) (outa * <span class="hljs-number"><span class="hljs-number">255.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre><br>  And that's what I came to: <br><br><pre> <code class="cpp hljs">UINT16 blend = dst-&gt;a * (<span class="hljs-number"><span class="hljs-number">255</span></span> - src-&gt;a); UINT16 outa255 = src-&gt;a * <span class="hljs-number"><span class="hljs-number">255</span></span> + blend; <span class="hljs-comment"><span class="hljs-comment">// There we use 7 bits for precision. // We could use more, but we go beyond 32 bits. UINT16 coef1 = src-&gt;a * 255 * 255 * 128 / outa255; UINT16 coef2 = 255 * 128 - coef1; #define SHIFTFORDIV255(a)\ ((a &gt;&gt; 8) + a &gt;&gt; 8) UINT32 tmpr = src-&gt;r * coef1 + dst-&gt;r * coef2 + (0x80 &lt;&lt; 7); out-&gt;r = SHIFTFORDIV255(tmpr) &gt;&gt; 7; UINT32 tmpg = src-&gt;g * coef1 + dst-&gt;g * coef2 + (0x80 &lt;&lt; 7); out-&gt;g = SHIFTFORDIV255(tmpg) &gt;&gt; 7; UINT32 tmpb = src-&gt;b * coef1 + dst-&gt;b * coef2 + (0x80 &lt;&lt; 7); out-&gt;b = SHIFTFORDIV255(tmpb) &gt;&gt; 7; out-&gt;a = SHIFTFORDIV255(outa255 + 0x80);</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/174005/">https://habr.com/ru/post/174005/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173987/index.html">How to start your personal account</a></li>
<li><a href="../173989/index.html">Highscreen Boost, smartphone with a normal battery</a></li>
<li><a href="../173991/index.html">Eclipse Improved search and highlighting of code blocks</a></li>
<li><a href="../173995/index.html">China standardizes national OS based on Ubuntu</a></li>
<li><a href="../173997/index.html">GitLab 5.0 release</a></li>
<li><a href="../174007/index.html">Taiwan court allowed pirates to legally distribute adult films</a></li>
<li><a href="../174015/index.html">Comparing Serializable and Parcelable. In seconds</a></li>
<li><a href="../174019/index.html">Move semantics in C ++ 11 and STL containers</a></li>
<li><a href="../174021/index.html">OpenShot video editor with updated engine running on Windows and Mac</a></li>
<li><a href="../174023/index.html">Microsoft showed "smart" Excel - "formulas" can be set in "ordinary" language</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>