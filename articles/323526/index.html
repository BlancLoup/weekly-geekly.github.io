<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Magic newtype in haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The main way to set a new data type in Haskell is to use the data construct. However, there is also a newtype . Practicing Haskell programmers use the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Magic newtype in haskell</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/848/677/90f/84867790fc134207ba310140f9e7a854.jpg" width="35%" align="left"><br><p> The main way to set a new data type in Haskell is to use the data construct.  However, there is also a <a href="https://www.haskell.org/onlinereport/decls.html"><code>newtype</code></a> .  Practicing Haskell programmers use the <code>newtype</code> construct all the time, the popular hlint <code>hlint</code> suggests replacing <code>data</code> with <code>newtype</code> if possible. </p><br><p>  But why? </p><br><a name="habracut"></a><br><p>  At first I planned this article for newbies.  Indeed, the <code>newtype</code> construct is mentioned in the first chapters of Haskell tutorials.  It seems to be a simple idea: we limit the presentation for the data type and gain speed.  In various sources you can find references that <code>newtype</code> saves on nesting of pointers.  But I didn‚Äôt find a detailed analysis of what actually happens with this construction in the compiler and why it is so cool and necessary.  To fill these gaps, I decided to write an article on Habr. </p><br><p>  So, we need the <a href="https://haskellstack.org/">haskell stack</a> and basic knowledge of the Haskell and GHC execution model (we know what lazy calculations are, thunks (uncomputed objects), we heard a little about the stack and the GHC heap). </p><br><h1>  Semantics </h1><br><p>  The syntax for the <code>newtype</code> construct is exactly the same as the data construct, except that a <code>newtype</code> can have only one constructor and only one boxed (boxed type) field inside. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |         data MyValDL = MyValDLC Int -- |   ,       thunk' -- (   Int) data MyValDS = MyValDSC !Int -- |            , --     newtype newtype MyValN = MyValNC Int</span></span></code> </pre> <br><p>  By the way, all sorts of record syntax and phantom types also work: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFunnyA</span></span></span><span class="hljs-class"> abc = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFunnyA</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getA</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  But what is the difference between <code>MyValDL</code> ( <code>MyValDS</code> ) and <code>MyValN</code> ? </p><br><p>  The <a href="https://www.haskell.org/onlinereport/decls.html">Haskell'98 report</a> states that the <code>newtype</code> construct introduces a new type, whose representation is identical to the existing one.  That is, <code>Int</code> and <code>MyValN</code> isomorphic.  But is it not so for <code>data</code> types?  It turns out no.  The fact is that in Haskell there are ‚Äúlifted‚Äù and ‚Äúnot lifted‚Äù types.  For all types declared with <code>data</code> , an additional element "bottom" (bottom, or) is added - they become raised (for the program, the "bottom" is <code>undefined</code> ).  This means that " <code>MyValDLC ‚ä• :: MyValDL</code> " and " <code>‚ä• :: MyValDL</code> " are different meanings.  Unlike <code>data</code> , a <code>newtype</code> type is not raised (unlifted type), which means <code>‚ä• :: MyValN</code> ‚Äúborrowed‚Äù from a nested type (via <code>MyValN ‚ä•</code> ). </p><br><p>  We can say that for a compiler, a raised type means an extra layer of pointers (a pointer can refer to an embedded object, or to the bottom (undefined)).  For a programmer, this means that if the <code>data</code> field of the constructor may contain <code>undefined</code> , all is not lost: until we touch this field, the program will not break.  A non-computed field, on the other hand, can be a place of memory leakage (a series of thunks).  With strict <code>MyValDS</code> the situation is a bit more complicated: it seems that <code>MyValDSC ‚ä•</code> immediately computed to <code>‚ä•</code> , but the semantics of these two constructors are the same.  By the way, therefore, professionals recommend declaring all fields in data constructors to be strict, unless there is a real need to use the field lazily - this way you can avoid long hours of searching for memory leaks. </p><br><p>  The <a href="https://wiki.haskell.org/Newtype">Haskell wiki</a> has an excellent set of examples that illustrate the difference between data and <code>newtype</code> ;  I will give them here, adjusted for free translation and my type names: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--    (  ), --     xDL :: Int xDL = case MyValDLC undefined of MyValDLC _ -&gt; 1 -- 1 --   ,  undefined   xDS :: Int xDS = case MyValDSC undefined of MyValDSC _ -&gt; 1 -- undefined -- newtype    Int,    1 -- (  ,  ,  .  yInt) xN :: Int xN = case MyValNC undefined of MyValNC _ -&gt; 1 -- 1 --     yDL :: Int yDL = case undefined of MyValDLC _ -&gt; 1 -- undefined --     yDS :: Int yDS = case undefined of MyValDSC _ -&gt; 1 -- undefined -- newtype    Int,   MyValN --        ! yN :: Int yN = case undefined of MyValNC _ -&gt; 1 -- 1 --      Int: -- case     undefined, --     , --        yInt :: Int yInt = case (undefined :: Int) of _ -&gt; 1 -- 1</span></span></code> </pre> <br><p>  The above description is my interpretation of the <a href="https://wiki.haskell.org/Newtype">Haskell wiki</a> .  But we will not stop at this and consider a few more questions. </p><br><h1>  How does it work? </h1><br><p>  Requiring the same representation of the original type and its <code>newtype</code> wrapper for the compiler means that: </p><br><ul><li>  In the " <code>data A</code> " and " <code>newtype NA = NA</code> " type systems, these are different types. </li><li>  At run time, the representations " <code>NA</code> " and " <code>A</code> " are the same. </li></ul><br><p>  GHC works with types on two levels: Haskell‚Äôs ‚Äúvisible‚Äù type system, and representation types.  The visible type system is what we work with in Haskell programming.  However, at some point, the compiler converts the Haskell types into a machine representation.  It often happens that two different types in Haskell can have the same representation in machine code.  In the modern GHC, with the help <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html">of the role system</a> , it is possible to compare types not only nominally, but also according to their presentation.  This made it possible to implement the free type conversion mechanism (visible only at the level of the Haskell type system) in the <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Type-Coercion.html">Data.Type.Coercion</a> and <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Coerce.html">Data.Coerce modules</a> . </p><br><p>  Considering the above, the general idea of ‚Äã‚Äãimplementing <code>newtype</code> is obvious: all of the packed values ‚Äã‚Äãin Haskell are represented as a description with a pointer to the constructor (object info tables);  therefore, the value of a <code>newtype</code> can in its description use a pointer directly to the constructor of the nested value;  it turns out something like the <code>type</code> synonyms, only at a lower level. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b6e/2bb/57a/b6e2bb57aab84705aba7c96ab8d7118b.png" width="70%"></div><br><p>  Every Haskell programmer knows that GHC does not compile the source code into an assembler right away, but produces a complex series of code conversions in several stages, with optimizations on almost every one of them.  First, the Haskell syntax tree is transformed into a simplified version of the language - GHC Core (which is based on system F).  Then Core is converted to a functional STG (Spineless Tagless G-machine), then to an imperative <a href="https://ru.wikipedia.org/wiki/C--"><code>C--</code></a> (special intermediate language with support for exception handling and garbage collection), and from there to various ways into an assembler. </p><br><p>  It seems that the statement that <code>newtype</code> constructors "disappear" at run time is well known.  However, it turned out to be quite difficult to understand how this happens.  <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode">The description of the STG on the GHC website</a> makes us understand that the STG already operates with only representative types, that is, the <code>newtype</code> should be lost to it.  Another <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/EntityTypes">GHC wiki page</a> hints that some types are always visible, and some only for type checker (the latter, by the way, seem to have the tc prefix at different levels of the generated code).  To find out for sure what happens with <code>newtype</code> types, I decided to look at all the intermediate stages of the compiled code with the following example: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyNewtypeStruct</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyNewtypeConstr</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unNewtypeStruct</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyDataStruct</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyDataConstr</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unDataStruct</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } ntToD :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyNewtypeStruct</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyDataStruct</span></span></span><span class="hljs-class"> ntToD x = case x of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyNewtypeConstr</span></span></span><span class="hljs-class"> y -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyDataConstr</span></span></span><span class="hljs-class"> y dToNt :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyDataStruct</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyNewtypeStruct</span></span></span><span class="hljs-class"> dToNt x = case x of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyDataConstr</span></span></span><span class="hljs-class"> y -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyNewtypeConstr</span></span></span><span class="hljs-class"> y</span></span></code> </pre> <br><p>  The result was not long in coming at the first stage: </p><br><pre> <code class="bash hljs">stack <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ghc-core -- --no-asm Main.hs -fforce-recomp -O0 -fno-enable-rewrite-rules</code> </pre> <br><p>  The <code>ghc-core</code> program, available in the hackage package of the same name, displays a slightly cleaned GHC Core.  Already at this stage, all occurrences of <code>MyNewtypeConstr</code> are replaced by <code>cast</code> operations, while <code>MyDataConstr</code> honestly remains in its place: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">unNewtypeStruct1_rG2</span></span> :: <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> unNewtypeStruct1_rG2 = \ (ds_dGl :: <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span>) -&gt; ds_dGl unNewtypeStruct :: <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span>&gt;_R -&gt; <span class="hljs-type"><span class="hljs-type">N</span></span>:<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] :: ((<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span>) :: *) ~<span class="hljs-type"><span class="hljs-type">R</span></span># ((<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>) :: *)) unDataStruct :: <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> unDataStruct = \ (ds_dGj :: <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ds_dGj <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> _ [<span class="hljs-type"><span class="hljs-type">Occ</span></span>=<span class="hljs-type"><span class="hljs-type">Dead</span></span>] { <span class="hljs-type"><span class="hljs-type">MyDataConstr</span></span> ds1_dGk -&gt; ds1_dGk } ntToD :: <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span> ntToD = <span class="hljs-type"><span class="hljs-type">MyDataConstr</span></span> `cast` (<span class="hljs-type"><span class="hljs-type">Sym</span></span> <span class="hljs-type"><span class="hljs-type">N</span></span>:<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] -&gt; &lt;<span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span>&gt;_R :: ((<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span>) :: *) ~<span class="hljs-type"><span class="hljs-type">R</span></span># ((<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span>) :: *)) dToNt :: <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> dToNt = \ (x_awb :: <span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x_awb <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> _ [<span class="hljs-type"><span class="hljs-type">Occ</span></span>=<span class="hljs-type"><span class="hljs-type">Dead</span></span>] { <span class="hljs-type"><span class="hljs-type">MyDataConstr</span></span> y_awc -&gt; y_awc `cast` (<span class="hljs-type"><span class="hljs-type">Sym</span></span> <span class="hljs-type"><span class="hljs-type">N</span></span>:<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] :: (<span class="hljs-type"><span class="hljs-type">Int</span></span> :: *) ~<span class="hljs-type"><span class="hljs-type">R</span></span># (<span class="hljs-type"><span class="hljs-type">MyNewtypeStruct</span></span> :: *))</code> </pre> <br><p>  The next stage is STG, it can be viewed with the following command: </p><br><pre> <code class="bash hljs">stack <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ghc -- Main.hs -fforce-recomp -O0 -fno-enable-rewrite-rules -ddump-stg &gt; Main.stg</code> </pre> <br><p>  It is not much different from Core, except for the interesting detail: <code>Main.MyDataConstr</code> is defined explicitly in the generated code, and <code>Main.MyNewtypeConstr</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Main</span></span>.<span class="hljs-type"><span class="hljs-type">MyDataConstr</span></span> :: <span class="hljs-type"><span class="hljs-type">GHC</span></span>.<span class="hljs-type"><span class="hljs-type">Types</span></span>.<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Main</span></span>.<span class="hljs-type"><span class="hljs-type">MyDataStruct</span></span> [<span class="hljs-type"><span class="hljs-type">GblId</span></span>[<span class="hljs-type"><span class="hljs-type">DataCon</span></span>], <span class="hljs-type"><span class="hljs-type">Arity</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">Caf</span></span>=<span class="hljs-type"><span class="hljs-type">NoCafRefs</span></span>, <span class="hljs-type"><span class="hljs-type">Str</span></span>=<span class="hljs-type"><span class="hljs-type">DmdType</span></span> &lt;<span class="hljs-type"><span class="hljs-type">L</span></span>,<span class="hljs-type"><span class="hljs-type">U</span></span>&gt;m, <span class="hljs-type"><span class="hljs-type">Unf</span></span>=<span class="hljs-type"><span class="hljs-type">OtherCon</span></span> []] = \r srt:<span class="hljs-type"><span class="hljs-type">SRT</span></span>:[] [eta_B1] <span class="hljs-type"><span class="hljs-type">Main</span></span>.<span class="hljs-type"><span class="hljs-type">MyDataConstr</span></span> [eta_B1];</code> </pre> <br><p>  At the <code>--</code> level, you can find constructions such as <code>Main.$tc'MyNewtypeConstr</code> and <code>Main.$tc'MyDataConstr</code> , but <code>Main.MyDataConstr</code> does not find a <code>newtype</code> .  Apparently, <code>$tc</code> (from the word Type Checker) is another hint of types that are used only at the type checking level. </p><br><p>  As we can see, already at the GHC Core transformation stage, <code>newtype</code> constructors are replaced with primitive type conversions.  At the <code>C--</code> level, you can compare the low-level imperative code <code>Main.unNewtypeStruct_entry()</code> and <code>Main.unDataStruct_entry()</code> to make sure that <code>unNewtypeStruct</code> does virtually nothing, unlike <code>unDataStruct</code> . <br>  All output levels can be viewed using several commands: </p><br><pre> <code class="bash hljs">stack <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ghc -- <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.hs -fforce-recomp -O0 -fno-enable-rewrite-rules -fllvm -keep-llvm-files stack <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ghc-core -- --no-asm --no-syntax <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.hs -fforce-recomp -O0 -fno-enable-rewrite-rules &gt; <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.hcr stack <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ghc -- <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.hs -fforce-recomp -O0 -fno-enable-rewrite-rules -ddump-stg &gt; <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.stg stack <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> ghc -- <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.hs -fforce-recomp -O0 -fno-enable-rewrite-rules -ddump-opt-cmm &gt; <span class="hljs-variable"><span class="hljs-variable">${filename}</span></span>.cmm</code> </pre> <br><p>  The output formatted by me is under a cat.  I left only more or less interesting parts (the text is already too much). </p><br><div class="spoiler">  <b class="spoiler_title">Phased GHC output</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> Main_zdtczqMyNewtypeConstr_closure_struct &lt;{i64 ptrtoint (i8 * @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (% Main_zdtrModule_closure_struct * @ Main_zdtrModule_closure $ def to i64), i64 <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> % <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> Main_zdtcMyNewtypeStruct_closure_struct &lt;{i64 ptrtoint (i8 * @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (% Main_zdtrModule_closure_struct * @ Main_zdtrModule_closure $ def to i64), i64 <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> % <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> Main_zdtczqMyDataConstr_closure_struct &lt;{i64 ptrtoint (i8 * @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (% Main_zdtrModule_closure_struct * @ Main_zdtrModule_closure $ def to i64), i64 <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> % <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> Main_zdtcMyDataStruct_closure_struct &lt;{i64 ptrtoint (i8 * @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (% Main_zdtrModule_closure_struct * @ Main_zdtrModule_closure $ def to i64), i64 <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> % <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- CORE ------------------------------------------------------------------------ unNewtypeStruct1_rG2 :: MyNewtypeStruct -&gt; MyNewtypeStruct unNewtypeStruct1_rG2 = \ (ds_dGl :: MyNewtypeStruct) -&gt; ds_dGl unNewtypeStruct :: MyNewtypeStruct -&gt; Int unNewtypeStruct = unNewtypeStruct1_rG2 `cast` (&lt;MyNewtypeStruct&gt;_R -&gt; N:MyNewtypeStruct[0] :: ((MyNewtypeStruct -&gt; MyNewtypeStruct) :: *) ~R# ((MyNewtypeStruct -&gt; Int) :: *)) unDataStruct :: MyDataStruct -&gt; Int unDataStruct = \ (ds_dGj :: MyDataStruct) -&gt; case ds_dGj of _ [Occ=Dead] { MyDataConstr ds1_dGk -&gt; ds1_dGk } ntToD :: MyNewtypeStruct -&gt; MyDataStruct ntToD = MyDataConstr `cast` (Sym N:MyNewtypeStruct[0] -&gt; &lt;MyDataStruct&gt;_R :: ((Int -&gt; MyDataStruct) :: *) ~R# ((MyNewtypeStruct -&gt; MyDataStruct) :: *)) dToNt :: MyDataStruct -&gt; MyNewtypeStruct dToNt = \ (x_awb :: MyDataStruct) -&gt; case x_awb of _ [Occ=Dead] { MyDataConstr y_awc -&gt; y_awc `cast` (Sym N:MyNewtypeStruct[0] :: (Int :: *) ~R# (MyNewtypeStruct :: *)) -- ... $tc'MyNewtypeConstr1_rGD :: TrName $tc'MyNewtypeConstr1_rGD = TrNameS "'MyNewtypeConstr"# $tc'MyDataConstr1_rGF :: TrName $tc'MyDataConstr1_rGF = TrNameS "'MyDataConstr"# -- .. $tcMyNewtypeStruct1_rGE :: TrName $tcMyNewtypeStruct1_rGE = TrNameS "MyNewtypeStruct"# $tcMyDataStruct1_rGG :: TrName $tcMyDataStruct1_rGG = TrNameS "MyDataStruct"# -- ... -- STG ------------------------------------------------------------------------- unNewtypeStruct1_rG2 :: Main.MyNewtypeStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = sat-only \r srt:SRT:[] [ds_sQ7] ds_sQ7; Main.unNewtypeStruct :: Main.MyNewtypeStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] unNewtypeStruct1_rG2 eta_B1; Main.unDataStruct :: Main.MyDataStruct -&gt; GHC.Types.Int [GblId[[RecSel]], Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [ds_sQ8] case ds_sQ8 of _ [Occ=Dead] { Main.MyDataConstr ds1_sQa [Occ=Once] -&gt; ds1_sQa; }; Main.ntToD :: Main.MyNewtypeStruct -&gt; Main.MyDataStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; Main.dToNt :: Main.MyDataStruct -&gt; Main.MyNewtypeStruct [GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] = \r srt:SRT:[] [x_sQb] case x_sQb of _ [Occ=Dead] { Main.MyDataConstr y_sQd [Occ=Once] -&gt; y_sQd; }; -- ... constructors seem to be defined exactly the same way for both types ... -- There is one more definition in the STG dump Main.MyDataConstr :: GHC.Types.Int -&gt; Main.MyDataStruct [GblId[DataCon], Arity=1, Caf=NoCafRefs, Str=DmdType &lt;L,U&gt;m, Unf=OtherCon []] = \r srt:SRT:[] [eta_B1] Main.MyDataConstr [eta_B1]; -- C-- ------------------------------------------------------------------------- unNewtypeStruct1_rG2_entry() // [R2] { [(cQj, unNewtypeStruct1_rG2_info: const 4294967301; const 0; const 15;)] } {offset cQj: _sQ8::P64 = R2; goto cQl; cQl: R1 = _sQ8::P64 &amp; (-8); call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } Main.unNewtypeStruct_entry() // [R2] { [(cQv, Main.unNewtypeStruct_info: const 4294967301; const 0; const 15;)] } {offset cQv: _B1::P64 = R2; goto cQx; cQx: R2 = _B1::P64; call unNewtypeStruct1_rG2_info(R2) args: 8, res: 0, upd: 8; } } Main.unDataStruct_entry() // [R2] { [(cQJ, block_cQJ_info: const 0; const 32;), (cQM, Main.unDataStruct_info: const 4294967301; const 0; const 15;)] } {offset cQM: _sQ9::P64 = R2; if ((Sp + -8) &lt; SpLim) goto cQN; else goto cQO; cQN: R2 = _sQ9::P64; R1 = Main.unDataStruct_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cQO: I64[Sp - 8] = block_cQJ_info; R1 = _sQ9::P64; Sp = Sp - 8; if (R1 &amp; 7 != 0) goto cQJ; else goto cQK; cQK: call (I64[R1])(R1) returns to cQJ, args: 8, res: 8, upd: 8; cQJ: _sQa::P64 = R1; _sQb::P64 = P64[_sQa::P64 + 7]; R1 = _sQb::P64 &amp; (-8); Sp = Sp + 8; call (I64[R1])(R1) args: 8, res: 0, upd: 8; } } section ""data" . $tc'MyNewtypeConstr1_rGD_closure" { $tc'MyNewtypeConstr1_rGD_closure: const GHC.Types.TrNameS_static_info; const cRI_str; } section ""data" . Main.$tc'MyNewtypeConstr_closure" { Main.$tc'MyNewtypeConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyNewtypeConstr1_rGD_closure+1; const 10344856529254187725; const 4384341159368653246; const 3; } section ""data" . $tc'MyDataConstr1_rGF_closure" { $tc'MyDataConstr1_rGF_closure: const GHC.Types.TrNameS_static_info; const cRU_str; } section ""data" . Main.$tc'MyDataConstr_closure" { Main.$tc'MyDataConstr_closure: const GHC.Types.TyCon_static_info; const Main.$trModule_closure+1; const $tc'MyDataConstr1_rGF_closure+1; const 12971553621823397951; const 6686958652479025466; const 3; } section ""data" . Main.MyDataConstr_closure" { Main.MyDataConstr_closure: const Main.MyDataConstr_info; } Main.MyDataConstr_entry() // [R2] { [(cSE, Main.MyDataConstr_info: const 4294967301; const 0; const 15;)] } {offset cSE: _B1::P64 = R2; goto cSG; cSG: Hp = Hp + 16; if (Hp &gt; I64[BaseReg + 856]) goto cSI; else goto cSH; cSI: I64[BaseReg + 904] = 16; goto cSF; cSF: R2 = _B1::P64; R1 = Main.MyDataConstr_closure; call (I64[BaseReg - 8])(R2, R1) args: 8, res: 0, upd: 8; cSH: I64[Hp - 8] = Main.MyDataConstr_con_info; P64[Hp] = _B1::P64; _cSD::P64 = Hp - 7; R1 = _cSD::P64; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_con_entry() // [] { [(cSN, Main.MyDataConstr_con_info: const iSP_str-Main.MyDataConstr_con_info; const 1; const 2;)] } {offset cSN: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } Main.MyDataConstr_static_entry() // [] { [(cSO, Main.MyDataConstr_static_info: const iSQ_str-Main.MyDataConstr_static_info; const 1; const 7;)] } {offset cSO: R1 = R1 + 1; call (P64[Sp])(R1) args: 8, res: 0, upd: 8; } } -- LLVM ------------------------------------------------------------------------ %Main_zdtczqMyNewtypeConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyNewtypeConstr_closure$def = internal global %Main_zdtczqMyNewtypeConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGD_closure_struct* @rGD_closure$def to i64),i64 1), i64 -8101887544455363891, i64 4384341159368653246, i64 3}&gt; @Main_zdtczqMyNewtypeConstr_closure = alias i8* bitcast (%Main_zdtczqMyNewtypeConstr_closure_struct* @Main_zdtczqMyNewtypeConstr_closure$def to i8*) %Main_zdtcMyNewtypeStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyNewtypeStruct_closure$def = internal global %Main_zdtcMyNewtypeStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGE_closure_struct* @rGE_closure$def to i64),i64 1), i64 2735651172251469986, i64 2399541496478989519, i64 3}&gt; @Main_zdtcMyNewtypeStruct_closure = alias i8* bitcast (%Main_zdtcMyNewtypeStruct_closure_struct* @Main_zdtcMyNewtypeStruct_closure$def to i8*) %Main_zdtczqMyDataConstr_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtczqMyDataConstr_closure$def = internal global %Main_zdtczqMyDataConstr_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGF_closure_struct* @rGF_closure$def to i64),i64 1), i64 -5475190451886153665, i64 6686958652479025466, i64 3}&gt; @Main_zdtczqMyDataConstr_closure = alias i8* bitcast (%Main_zdtczqMyDataConstr_closure_struct* @Main_zdtczqMyDataConstr_closure$def to i8*) %Main_zdtcMyDataStruct_closure_struct = type &lt;{i64, i64, i64, i64, i64, i64}&gt; @Main_zdtcMyDataStruct_closure$def = internal global %Main_zdtcMyDataStruct_closure_struct&lt;{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TyCon_static_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%rGG_closure_struct* @rGG_closure$def to i64),i64 1), i64 5826051442705447975, i64 -4331072423017222539, i64 3}&gt; @Main_zdtcMyDataStruct_closure = alias i8* bitcast (%Main_zdtcMyDataStruct_closure_struct* @Main_zdtcMyDataStruct_closure$def to i8*) %Main_MyDataConstr_closure_struct = type &lt;{i64}&gt; @Main_MyDataConstr_closure$def = internal global %Main_MyDataConstr_closure_struct&lt;{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i64)}&gt; @Main_MyDataConstr_closure = alias i8* bitcast (%Main_MyDataConstr_closure_struct* @Main_MyDataConstr_closure$def to i8*) @Main_MyDataConstr_info = internal alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_info$def to i8*) define internal ghccc void @Main_MyDataConstr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 4294967301, i64 0, i64 15}&gt; { cW0: ... ret void } @Main_MyDataConstr_con_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i8*) define ghccc void @Main_MyDataConstr_con_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWK_str_struct* @iWK_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_con_info$def to i64)),i64 0), i64 1, i64 2}&gt; { ... } @Main_MyDataConstr_static_info = alias i8* bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i8*) define ghccc void @Main_MyDataConstr_static_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix &lt;{i64, i64, i64}&gt;&lt;{i64 add (i64 sub (i64 ptrtoint (%iWL_str_struct* @iWL_str$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_MyDataConstr_static_info$def to i64)),i64 0), i64 1, i64 7}&gt; { ... }</span></span></code> </pre> </div></div><br><p>  <strong>PS:</strong> Of course, the type <code>newtype N</code> itself cannot disappear anywhere during compilation: a compiled module must export characters for use in other modules.  In addition, you need somewhere to store pointers to the functions of the classes implemented by this type.  The real benefit of a <code>newtype</code> is that at a low level it is not necessary to go through a chain of constructors to get to the desired value. </p><br><h1>  And why is this necessary? </h1><br><p>  In the previous paragraph, we implicitly determined why it is better to use newtype instead of data where it is possible (newtype is faster and more compact).  Now the unresolved question is: why bother to use newtype ‚Äî a type with one constructor and a field ‚Äî when can I just use the original type or type is a synonym for it?  There are many reasons for this. </p><br><h2>  Easier to understand type inference </h2><br><p>  Type synonyms are dereferenced during type inference, and newtype is always a separate type.  Consider the following example: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Height</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Height</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Weight</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Weight</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> diseaseRate :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Height</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Weight</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Age</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> diseaseRate (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Height</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Weight</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">w</span></span></span><span class="hljs-class">) = _ diseaseRate' :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> diseaseRate' hw = _</span></span></code> </pre> <br><p>  And the output of the compiler: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Example</span></span>.hs:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span>: error: ‚Ä¢ <span class="hljs-type"><span class="hljs-type">Found</span></span> hole: _ :: <span class="hljs-type"><span class="hljs-type">Age</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Percent</span></span> ‚Ä¢ ... <span class="hljs-type"><span class="hljs-type">Example</span></span>.hs:<span class="hljs-number"><span class="hljs-number">23</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>: error: ‚Ä¢ <span class="hljs-type"><span class="hljs-type">Found</span></span> hole: _ :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> ‚Ä¢ ...</code> </pre><br><p>  It is much easier to understand what type the function <code>Age -&gt; Percent</code> should have, than <code>Int -&gt; Double</code> .  The famous <a href="https://hackage.haskell.org/package/lens">lens</a> library is a powerful tool, but I often dream about the types of its combinators in nightmares. </p><br><h2>  Documentation Assistance </h2><br><p>  A very simple reason, but for some reason it is rarely mentioned in textbooks and tutorials.  In the previous example, it is very easy to confuse height and weight as arguments of the <code>diseaseRate'</code> function, but the compiler will not allow this to be done in the <code>diseaseRate</code> function.  Of course, this does not cancel the documentation, but is a very good addition to it. <br>  If you do not want to produce a large number of new types for each function, there is a convenient technique - use tagging: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tagged</span></span></span><span class="hljs-class"> tag a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tagged</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unTagged</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  You can tag enumerated types, or just use <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html"><code>GHC.TypeLits</code></a> . <br>  The first time I saw this reception was at the <a href="https://youtu.be/ywOvfjpbYR4%3Ft%3D1971">lecture of Simon Meyer</a> . </p><br><h2>  Hiding implementation details </h2><br><p>  Do we use <code>Float</code> or <code>Double</code> as the data type for percent output?  Sometimes, the library user should not know this (the type may differ for different platforms, or we want to change it in a new version of the library). </p><br><h2>  Implement a new behavior for an existing type. </h2><br><p>  The most popular reason.  Creating a new type, we can implement some classes in a new way.  For example, I want to display percentages in the line with the sign "%" after the number: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> show (<span class="hljs-type"><span class="hljs-type">Percent</span></span> t) = show t ++ <span class="hljs-string"><span class="hljs-string">"%"</span></span></code> </pre> <br><p>  But, generally, I would like to add and multiply the percentages;  preferably without the need to override all <code>Num</code> methods and the like.  In GHC, for this there is an extension <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html"><code>GeneralizedNewtypeDeriving</code></a> , which allows you to naturally display the implementation of a wide range of classes for <code>newtype</code> types: </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Example <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fractional</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Floating</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Real</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RealFrac</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RealFloat</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> where show (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) = show t ++ "%" x :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> x = 2 + </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Percent</span></span></span><span class="hljs-class"> 4</span></span></code> </pre> <br><h1>  Examples </h1><br><p>  There are many examples of using <code>newtype</code> for various reasons.  Maybe it is used even more often than <code>data</code> .  The first and foremost example is, of course, <code>IO</code> .  Just type in the <code>ghci</code> console command <code>:info IO</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; :info <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHC</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Types</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHC</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"># </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHC</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RealWorld</span></span></span><span class="hljs-class"> -&gt; (# </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHC</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"># </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHC</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RealWorld</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> #)) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- Defined in 'GHC.Types'</span></span></span></span></code> </pre> <br><p> ,  <code>IO</code>    <code>newtype</code>     +.   ,   <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.ST.html"> ST</a> <br> <code>newtype ST sa = ST (STRep sa)</code> . </p><br><p>        <a href="https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.RWS.Lazy.html">transformers</a>     <br> <code>newtype RWST rwsma = RWST { runRWST :: r -&gt; s -&gt; m (a, s, w) }</code> . </p><br><p>      : <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html">Data.Semigroup</a>  <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Monoid.html">Data.Monoid</a>   <code>newtype</code> -         . ,  ( <code>newtype Max a = Max { getMax :: a }</code> )   <code>Ord</code>  ,   <code>Ord</code>  <code>Bounded</code>  .      ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323526/">https://habr.com/ru/post/323526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323516/index.html">Complete latent semantic analysis with Python tools</a></li>
<li><a href="../323518/index.html">Development for Sailfish OS: Qt / C ++ Unit Testing under Sailfish OS</a></li>
<li><a href="../323520/index.html">Write me money: iMessage transfers</a></li>
<li><a href="../323522/index.html">Analyzing book recommendations for developers with Stack Overflow using Python tools</a></li>
<li><a href="../323524/index.html">Learning to learn. Create self-improving AI</a></li>
<li><a href="../323528/index.html">Quality management system: how to understand the standards and start the process of their implementation in the company</a></li>
<li><a href="../323532/index.html">Turquoise Organizations: Examples and Common Answers</a></li>
<li><a href="../323534/index.html">Crowdinvesting in Russia: the StartTrack Experience</a></li>
<li><a href="../323536/index.html">An example of enterprise anti-virus integration with a SIEM platform. Part 2</a></li>
<li><a href="../323538/index.html">Citrix XenServer Version 7.1 Hypervisor New Release Released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>