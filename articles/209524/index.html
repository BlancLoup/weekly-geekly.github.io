<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network programming for game developers. Part 2: receiving and transmitting data packets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: This is a translation of the second article in the series ‚ÄúNetworking for game programmers‚Äù . I really like the whole series of a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network programming for game developers. Part 2: receiving and transmitting data packets</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: This is a translation of the second article in the series <a href="http://gafferongames.com/networking-for-game-programmers/">‚ÄúNetworking for game programmers‚Äù</a> .</i>  <i>I really like the whole series of articles, plus I always wanted to try myself as a translator.</i>  <i>Perhaps an experienced developers article seems too obvious, but, as it seems to me, the benefits of it in any case will be.</i> <i><br></i>  <i>The first article is <a href="http://habrahabr.ru/post/209144/">http://habrahabr.ru/post/209144/</a></i> <br><hr><br><h4>  Reception and transmission of data packets </h4><br><h5>  Introduction </h5><br>  Hi, my name is Glenn Fiedler and I greet you in my second article in the series ‚ÄúNetwork Programming for Game Developers‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/3d0/32a/5813d032a6302e33e150606d79addf4a.jpg"></div><br>  In the <a href="http://habrahabr.ru/post/209144/">previous article,</a> we discussed various ways of transferring data between computers over a network, and at the end decided to use the UDP protocol, rather than TCP.  We decided to use UDP in order to be able to send data without delays associated with waiting for packet retransmission. <br><br>  And now I'm going to tell you how to use UDP in practice to send and receive packets. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  BSD sockets </h5><br>  Most modern operating systems have some kind of implementation of sockets based on BSD sockets (Berkeley sockets). <br><br>  BSD sockets operate on simple functions such as socket, bind, sendto, and recvfrom.  Of course, you can directly access these functions, but in this case your code will be platform dependent, since their implementations may differ slightly in different operating systems. <br><br>  Therefore, even though I will continue to give the first simple example of interaction with BSD sockets, in the future we will not use them directly.  Instead, after mastering the basic functionality, we will write several classes that abstract all work with sockets, so that our code will be platform-independent in the future. <br><a name="habracut"></a><br><h5>  Features of different OS </h5><br>  First, let's write the code that will determine the current OS, so that we can take into account the differences in the operation of sockets: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// platform detection #define PLATFORM_WINDOWS 1 #define PLATFORM_MAC 2 #define PLATFORM_UNIX 3 #if defined(_WIN32) #define PLATFORM PLATFORM_WINDOWS #elif defined(__APPLE__) #define PLATFORM PLATFORM_MAC #else #define PLATFORM PLATFORM_UNIX #endif</span></span></code> </pre> <br>  Now connect the header files needed for working with sockets.  Since the set of necessary header files depends on the current OS, here we use the #define code, written above, to determine which files to include. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;winsock2.h&gt; #elif PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;fcntl.h&gt; #endif</span></span></span></span></code> </pre><br>  In UNIX systems, socket functions are included in the standard system libraries, so we do not need any third-party libraries in this case.  However, in Windows for this purpose we need to connect the winsock library. <br><br>  Here's a little trick on how to do this without changing the project or the makefile: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment( lib, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"wsock32.lib"</span></span></span><span class="hljs-meta"> ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  I like this trick because I'm lazy.  Of course, you can connect the library to the project or to the makefile. <br><br><h5>  Socket initialization </h5><br>  In most unix-like operating systems (including macosx), no special actions are required to initialize the functionality of working with sockets, but in Windows, you must first do a couple of steps - you need to call the ‚ÄúWSAStartup‚Äù function before using any functions of working with sockets, and after finishing - call ‚ÄúWSACleanup‚Äù. <br><br>  Let's add two new features: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeSockets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS WSADATA WsaData; return WSAStartup( MAKEWORD(2,2), &amp;WsaData ) == NO_ERROR; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return true; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } inline void ShutdownSockets() { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS WSACleanup(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  Now we have a platform independent initialization and shutdown code for sockets.  On platforms that do not require initialization, this code simply does nothing. <br><br><h5>  Create a socket </h5><br>  Now we can create a UDP socket.  This is done like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handle = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( handle &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"failed to create socket\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Next, we must bind the socket to a specific port number (for example, 30,000).  Each socket must have its own unique port, because when a new packet arrives, the port number determines which socket to send it to.  Do not use port numbers smaller than 1024 - they are reserved by the system. <br><br>  If you do not care what port number to use for the socket, you can simply transfer to the ‚Äú0‚Äù function, and then the system will allocate to you some unused port. <br><br><pre> <code class="cpp hljs"> sockaddr_in address; address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) port ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( bind( handle, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sockaddr*) &amp;address, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sockaddr_in) ) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"failed to bind socket\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Now our socket is ready to send and receive data packets. <br><br>  But what is the mysterious function ‚Äúhtons‚Äù called in the code?  This is just a small auxiliary function that translates the byte order in a 16-bit integer - from the current (little or big-endian) to big-endian, which is used for network interaction.  It needs to be called every time you use whole numbers when working with sockets directly. <br><br>  You will find the ‚Äúhtons‚Äù function and its 32-bit twin - ‚Äúhtonl‚Äù in this article several more times, so be careful. <br><br><h5>  Putting the socket into non-blocking mode </h5><br>  By default, sockets are in the so-called ‚Äúblocking mode‚Äù.  This means that if you try to read data from it using ‚Äúrecvfrom‚Äù, the function will not return a value until the socket receives a packet with data that can be read.  This behavior does not suit us at all.  Games are applications that run in real time, at a speed of 30 to 60 frames per second, and the game cannot simply stop and wait until the data packet arrives! <br><br>  This problem can be solved by putting the socket in ‚Äúnon-blocking mode‚Äù after its creation.  In this mode, the ‚Äúrecvfrom‚Äù function, if there is no data to read from the socket, immediately returns a specific value, indicating that you need to call it again when data appears in the socket. <br><br>  You can translate a socket into non-blocking mode as follows: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX int nonBlocking = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( fcntl( handle, F_SETFL, O_NONBLOCK, nonBlocking ) == -1 ) { printf( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"failed to set non-blocking socket\n"</span></span></span><span class="hljs-meta"> ); return false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS DWORD nonBlocking = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( ioctlsocket( handle, FIONBIO, &amp;nonBlocking ) != 0 ) { printf( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"failed to set non-blocking socket\n"</span></span></span><span class="hljs-meta"> ); return false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  As you can see, in Windows there is no ‚Äúfcntl‚Äù function, so together with it we use ‚Äúioctlsocket‚Äù. <br><br><h5>  Sending Packages </h5><br>  UDP is a connectionless protocol, so every time we send a packet, we need to specify the recipient address.  You can use the same UDP socket to send packets to different IP addresses ‚Äî on the other end of the socket you don‚Äôt have to have one computer. <br><br>  You can forward a packet to a specific address as follows: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sent_bytes = sendto( handle, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)packet_data, packet_size, <span class="hljs-number"><span class="hljs-number">0</span></span>, (sockaddr*)&amp;address, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sockaddr_in) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sent_bytes != packet_size ) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"failed to send packet: return value = %d\n"</span></span>, sent_bytes ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Note that the return value from the ‚Äúsendto‚Äù function only shows whether the packet was successfully sent from the local computer.  But it does not indicate whether the packet was accepted by the addressee!  UDP does not have the means to determine whether a packet has reached its destination or not. <br><br>  In the code above, we pass the sockaddr_in structure as the destination address.  How do we get this structure? <br><br>  Suppose we want to send a package to the address 207.45.186.98:370000. <br><br>  We write the address in the following form: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">207</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">45</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">186</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = <span class="hljs-number"><span class="hljs-number">98</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> port = <span class="hljs-number"><span class="hljs-number">30000</span></span>;</code> </pre><br>  And you need to make a couple more transformations in order to bring it to a form that ‚Äúsendto‚Äù understands: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> destination_address = ( a &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span> ) | ( b &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> ) | ( c &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> ) | d; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> destination_port = port; sockaddr_in address; address.sin_family = AF_INET; address.sin_addr.s_addr = htonl( destination_address ); address.sin_port = htons( destination_port );</code> </pre><br>  As you can see, we first combine the numbers a, b, c, d (which lie in the range [0, 255]) into a single integer, in which each byte is one of the original numbers.  Then we initialize the ‚Äúsockaddr_in‚Äù structure with our destination address and port, while not forgetting to convert the byte order using the ‚Äúhtonl‚Äù and ‚Äúhtons‚Äù functions. <br><br>  We should also single out the case when you need to transfer the packet to yourself: you do not need to find out the IP address of the local machine, but you can simply use 127.0.0.1 as the address (the address of the local loop) and the packet will be sent to the local computer. <br><br><h5>  Reception of packages </h5><br>  After we have tied a UDP socket to a port, all UDP packets arriving at the IP address and port of our socket will be queued.  Therefore, to receive packets, we simply call ‚Äúrecvfrom‚Äù in a loop until it gives an error, meaning that there are no more packets to read in the blackout. <br><br>  Since the UDP protocol does not support connections, packets can come from many different computers on the network.  Every time we accept a packet, the ‚Äúrecvfrom‚Äù function gives us the IP address and port of the sender, and therefore we know who sent the packet. <br><br>  Code for receiving packets in a loop: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> packet_data[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maximum_packet_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( packet_data ); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS typedef int socklen_t; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> sockaddr_in from; socklen_t fromLength = sizeof( from ); int received_bytes = recvfrom( socket, (char*)packet_data, maximum_packet_size, 0, (sockaddr*)&amp;from, &amp;fromLength ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( received_bytes &lt;= 0 ) break; unsigned int from_address = ntohl( from.sin_addr.s_addr ); unsigned int from_port = ntohs( from.sin_port ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// process received packet }</span></span></span></span></code> </pre><br>  Packages that are larger than the receive buffer size will simply be quietly removed from the queue.  So, if you use a 256 byte buffer, as in the example above, and someone sends you a 300 byte packet, it will be discarded.  You do not just get the first 256 bytes from the packet. <br><br>  But since we are writing our own protocol, this will not be a problem for us.  Just always be careful and check that the receive buffer size is large enough to accommodate the largest package you can send. <br><br><h5>  Close socket </h5><br>  On most unix-like systems, sockets are file descriptors, so in order to close sockets after use, you can use the standard ‚Äúclose‚Äù function.  However, Windows, as always, stands out, and in it we need to use ‚Äúclosesocket‚Äù. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_MAC || PLATFORM == PLATFORM_UNIX close( socket ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> PLATFORM == PLATFORM_WINDOWS closesocket( socket ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Keep it up, Windows! <br><br><h5>  Socket class </h5><br>  So, we have dealt with all the basic operations: creating a socket, binding it to a port, switching to non-blocking mode, sending and receiving packets, and, finally, closing the socket. <br><br>  But, as you can see, all these operations are slightly different from platform to platform, and, of course, it is difficult every time when working with sockets to remember the features of different platforms and write all these #ifdef. <br><br>  Therefore, we will make a ‚ÄúSocket‚Äù wrapper class for all these operations.  We will also create the class ‚ÄúAddress‚Äù to make it easier to work with IP addresses.  It will allow not to carry out all manipulations with ‚Äúsockaddr_in‚Äù every time we want to send or receive a package. <br><br>  So, our Socket class: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Socket</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Socket(); ~Socket(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address &amp; destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Address &amp; sender, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handle; };</code> </pre><br>  And Address class: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Address(); Address( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> port ); Address( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> address, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> port ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">short</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Address &amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> != ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Address &amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> address; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> port; };</code> </pre><br>  Use them for reception and transmission as follows: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create socket const int port = 30000; Socket socket; if ( !socket.Open( port ) ) { printf( "failed to create socket!\n" ); return false; } // send a packet const char data[] = "hello world!"; socket.Send( Address(127,0,0,1,port), data, sizeof( data ) ); // receive packets while ( true ) { Address sender; unsigned char buffer[256]; int bytes_read = socket.Receive( sender, buffer, sizeof( buffer ) ); if ( !bytes_read ) break; // process packet }</span></span></code> </pre><br>  As you can see, this is much easier than working directly with BSD sockets.  And also this code will be the same for all OSs, because the whole platform-dependent functionality is inside the Socket and Address classes. <br><br><h5>  Conclusion </h5><br>  Now we have a platform independent tool for sending and prema UDP packets. <br><br>  UDP does not support connections, and I wanted to make an example that would clearly show this.  Therefore, I wrote a <a href="">small program</a> that reads a list of IP addresses from a text file and sends them packets, one per second.  Each time a program receives a packet, it displays the address and port of the sending computer and the size of the received packet to the console. <br><br>  You can easily configure the program so that even on a local machine you can get several nodes exchanging packets with each other.  To do this, just different instances of the program, set different ports, for example: <br><br>  &gt; Node 30000 <br>  &gt; Node 30001 <br>  &gt; Node 30002 <br>  Etc‚Ä¶ <br><br>  Each node will forward packets to all other nodes, forming something like a mini peer-to-peer system. <br><br>  I developed this program on MacOSX, but it should compile on any unix-like OS and on Windows, however, if you need to make any improvements for this, let me know. </div><p>Source: <a href="https://habr.com/ru/post/209524/">https://habr.com/ru/post/209524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209510/index.html">Monads in Scala</a></li>
<li><a href="../209512/index.html">Kepler equation: reboot</a></li>
<li><a href="../209514/index.html">Porting C # LINQ to PHP</a></li>
<li><a href="../209516/index.html">Netavis Observer is a Linux based IP video surveillance software. Installation, configuration and small hacking</a></li>
<li><a href="../209520/index.html">dSort - put everything on the shelves</a></li>
<li><a href="../209526/index.html">All about namespaces in yii1</a></li>
<li><a href="../209532/index.html">Basics of Scala. 5 hours of brain drain</a></li>
<li><a href="../209534/index.html">Give way to ambitious goals</a></li>
<li><a href="../209536/index.html">Cook bombs, or how to put the Internet</a></li>
<li><a href="../209538/index.html">New features for profiling Windows Store applications in Visual Studio 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>