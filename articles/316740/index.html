<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Efficient storage: as we did from 50 Pb, 32 Pb</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Video report 


 Text Version 
 Changes in the ruble exchange rate two years ago made us think about ways to reduce the cost of iron for Mail.Ru Mail....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Efficient storage: as we did from 50 Pb, 32 Pb</h1><div class="post__text post__text-html js-mediator-article"><h2>  Video report </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/O247Hq3ego4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Text Version </h2><br>  Changes in the ruble exchange rate two years ago made us think about ways to reduce the cost of iron for Mail.Ru Mail.  We needed to reduce the amount of iron purchased and the price for hosting.  To find where to save, let's see what the mail consists of. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/95c/690/f52/95c690f52796405684ca02154cd30b18.png"></div><br>  Indexes and letter bodies make up 15% of the volume, files - 85%.  The place for optimizations should be searched for in files (attachments in letters).  At that time, we did not implement file deduplication;  according to our estimates, it can save up to 36% of the total mail volume: many users receive the same emails (social networks with pictures, stores with price lists, etc.).  In this post I will talk about the implementation of such a system, made under the leadership of <a href="https://habrahabr.ru/users/psialt/" class="user_link">PSIAlt</a> . <br><a name="habracut"></a><br><h1>  Meta Information Store </h1><br>  There is a stream of files, and you need to quickly understand whether the file is duplicated or not.  A simple solution is to give them names that are generated based on the contents of the file.  We use sha1.  The original file name is stored in the letter itself, so no need to take care of it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We received a letter, got the files, counted from the contents of sha1 and the value of the calculation added to the letter.  This is necessary so that when you return a letter, it is easy to find its files in our future storage. <br><br>  Now fill in the file.  We are interested to ask the repository: do you have a file with sha1?  This means that all sha1 should be stored in memory.  Let's name the place for storage fileDB. <br><br><img src="https://habrastorage.org/files/094/3ca/a73/0943caa739754b7c93cd31b99c66ef77.png"><br><br>  The same file may be in different letters;  so we‚Äôll keep a counter on the number of letters with such a file. <br><br><img src="https://habrastorage.org/files/ae5/0eb/1d3/ae50eb1d3c0f48b8bea0e08e677ac546.png"><br><br>  When you add a file counter increases.  About 40% of files are deleted.  Accordingly, when deleting a letter in which there are files uploaded to the cloud, it is necessary to reduce the counter.  If it reaches 0, the file can be deleted. <br><br>  Here we meet the first difficulty: information about the letter (indices) is in one system, and about the file - in another.  This can lead to an error, for example: <br><br><ol><li>  A request to delete a letter comes. </li><li>  The system raises the indexes of the letter. </li><li>  See that there are files (sha1). </li><li>  Sends a file delete request. </li><li>  There is a failure, and the letter is not deleted. </li></ol><br><img src="https://habrastorage.org/files/a31/9f7/3bd/a319f73bd4c94da1afde83dad54b301f.png"><br><br>  In this case, the letter remained in the system, and the counter decreased by one.  When the second time comes the removal of this letter - we once again reduce the counter and get the problem.  The file can be in one more letter, and its counter is zero. <br><br><img src="https://habrastorage.org/files/87b/ae4/bd0/87bae4bd0d0a47d18cb490c251944566.png"><br><br>  It is important not to lose data.  We can not allow a situation when the user opens the letter, but the file is not there.  At the same time, it is not a problem to store some extra files on the disks.  It is enough to have a mechanism that clearly shows whether the counter is correct or not has gone down to zero.  To do this, we have added another field - magic. <br><br><img src="https://habrastorage.org/files/3ea/cb6/dd7/3eacb6dd7e11410d8320f0d299cd72c2.png"><br><br>  The algorithm is simple.  In the letter together with sha1 from the file we generate and save one more arbitrary number.  All requests for uploading or deleting a file are done with this number.  If a request for a fill has arrived, then add this number to the stored magic.  If on removal - we take away. <br><br>  Thus, if all the letters have the correct number of times increased and decreased the counter, then the magic will also be equal to zero.  If it is non-zero, the file cannot be deleted. <br><br>  Let's look at this with an example.  There is a sha1 file.  It is filled once, and when you fill it, the letter generated a random number (magic) equal to 345 for it. <br><br><img src="https://habrastorage.org/files/fb9/943/891/fb9943891226407baf4c5c4c029b9460.png"><br><br>  Now comes another letter with the same file.  It generates its magic (123) and uploads the file.  The new magic stacks with the old, and the counter is incremented by one.  As a result, in FileDB, magic for sha1 is 468, and counter - 2. <br><br><img src="https://habrastorage.org/files/961/27b/4ec/96127b4ec5af4e72b0d8dc0096b50435.png"><br><br>  The user deletes the second letter.  The magic memorized in the second letter is subtracted from the current magic, counter is decremented by one. <br><br><img src="https://habrastorage.org/files/2cb/db3/faf/2cbdb3faf74642bca76211d0311955ce.png"><br><br>  First, consider the situation where everything goes well.  The user deletes the first letter.  Then magic and counter will be equal to zero.  This means that the data is consistent, you can delete the file. <br><br><img src="https://habrastorage.org/files/b85/bf7/48c/b85bf748c63b45d680c4a9a36102bc8f.png"><br><br>  Now suppose that something went wrong: the first letter sent two commands for deletion.  Counter (0) indicates that there are no references to the file, however, magic (222) signals a problem: the file cannot be deleted until the data is brought to a consistent state. <br><br><img src="https://habrastorage.org/files/da6/701/ab5/da6701ab5b8a424886d86e8cb10178d8.png"><br><br>  Let's screw the situation to the end and assume that the first letter has been deleted.  In this case, magic (‚Äì123) still speaks of inconsistency of data. <br><br><img src="https://habrastorage.org/files/2cc/c0e/bb2/2ccc0ebb2c104ed69e8e5be210636322.png"><br><br>  For reliability, immediately, as soon as the counter has become zero, and magic is not (in our case it is magic = 222, counter = 0), the ‚Äúdo not delete‚Äù flag is set for the file.  So even if after a lot of additions and deletions by wild coincidence, magic and counter become equal to zero, we will still know that the file is problematic and cannot be deleted. <br><br>  Let's go back to FileDB.  Any entity has some flags.  Whether you plan or not, they will be needed.  For example, you need to mark a file as undeletable. <br><br><img src="https://habrastorage.org/files/88e/057/8dc/88e0578dcf6c41faaa0b1a203274c42d.png"><br><br>  We have all the properties of the file, except for the main one: where it physically lies.  This location identifies the server (IP) and disk.  There should be two such servers with a disk. <br><br><img src="https://habrastorage.org/files/319/145/8a9/3191458a9720403a9557c15545e7feb9.png"><br><br>  But there are many files on one disk (in our case, about 2,000,000).  This means that these entries in FileDB will have the same disk pairs as storage locations.  So storing this info in FileDB is wasteful.  We bring it into a separate table, and in FileDB we leave the ID to indicate the entry in the new table. <br><br><img src="https://habrastorage.org/files/aab/b33/6a2/aabb336a230c4f0e9c848cec635934d3.png"><br><br>  I think it is obvious that, in addition to such a description of the pair, we need another field flags.  Looking ahead, I will say that the flags contain information that the disks are now locked, for example, one has flown out and the second is copied, so nothing new can be written on them. <br><br><img src="https://habrastorage.org/files/daf/d95/0ab/dafd950ab2b54953a082a064d409be11.png"><br><br>  We also need to know the amount of free space on each disk.  We add these fields to the table. <br><br><img src="https://habrastorage.org/files/42b/fc5/2f9/42bfc52f906c46b9bf622acdba6e0707.png"><br><br>  For everything to work quickly, FileDB and PairDB must be in RAM.  Take Tarantool 1.5.  I must say that now you should use the latest version.  In FileDB, there are five fields (20, 4, 4, 4, and 4 bytes each), for a total of 36 data bytes.  Each record also contains a header of 16 bytes plus 1 byte for the length of each field.  Total 57 bytes on one record turn out. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f74/52d/5ea/f7452d5ea85f48b6ab1ad02a3fc0b34b.png"></div><br>  Tarantool allows you to set the minimum size for allocation in the config, so that you can reduce the amount of memory overhead to almost zero.  We will allocate exactly as much as necessary under one record.  We have 12 000 000 000 files. <br><br><pre><code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">57</span></span> * 12 * <span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">9</span></span>) / (<span class="hljs-number"><span class="hljs-number">1024</span></span>^<span class="hljs-number"><span class="hljs-number">3</span></span>) = <span class="hljs-number"><span class="hljs-number">637</span></span> Gb</code> </pre> <br>  But that's not all, we need an index across the field sha1.  And this is 12 more bytes to write. <br><br><pre> <code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">12</span></span> * 12 * <span class="hljs-number"><span class="hljs-number">10</span></span>^<span class="hljs-number"><span class="hljs-number">9</span></span>) / (<span class="hljs-number"><span class="hljs-number">1024</span></span>^<span class="hljs-number"><span class="hljs-number">3</span></span>) = <span class="hljs-number"><span class="hljs-number">179</span></span> Gb</code> </pre> <br>  Total is about 800 Gb of RAM.  But do not forget about the replica, which means √ó 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/350/18b/de0/35018bde0fb44946ba1c66d732b6a394.png"></div><br>  If we take cars with 256 Gb of RAM, then we will need eight cars. <br><br>  We can estimate the size of pairdb.  But the average file size is 1 MB and 1 Tb disks.  This allows you to store about 1,000,000 files on disk.  So, we need about 28,000 disks.  One record in PairDB describes two disks, therefore, in PairDB 14,000 records.  This is negligible compared to FileDB. <br><br><h1>  File upload </h1><br>  With the structure of the database figured out, now move on to the API for working with the system.  Like the upload and delete methods are needed.  But let us recall deduplication: it is possible that the file that we are trying to upload is already in the repository.  It makes no sense to fill it a second time.  Hence, the following methods will be required: <br><br><ul><li>  <b>inc (sha1, magic)</b> - increase the counter.  If there is no file, return an error.  Remember that we still need magic.  This will protect against incorrect file deletions. </li><li>  <b>upload (sha1, magic)</b> - it should be called if inc returned an error.  This means that there is no such file and it is necessary to fill it. </li><li>  <b>dec (sha1, magic)</b> - called if the user deletes the letter.  First we reduce the counter. </li><li>  <b>GET / sha1</b> - just download the file via http. </li></ul><br>  Let us analyze what happens during the upload.  For the daemon that implements this interface, we chose the iproto protocol.  Demons must scale to any number of machines, so they do not store state.  A socket request comes to us: <br><br><img src="https://habrastorage.org/files/578/b37/4ac/578b374ac0294c68ad09e8fdc6c51d1f.png"><br><br>  By the name of the command, we know the length of the title and read it first.  Now the length of the <b>origin-len</b> file is important to us.  It is necessary to pick up a couple of servers to fill it.  Just pumping out the entire PairDB, there are only a few thousand entries.  Next, we apply the standard algorithm for selecting the desired pair.  We make a segment, the length of which is equal to the sum of the free places of all pairs, and randomly choose a point on the segment.  Which pair got a point on the segment is the one chosen. <br><br><img src="https://habrastorage.org/files/da7/7f6/cb6/da77f6cb635a491696eb115a40db266d.png"><br><br>  However, choosing a pair in such a simple way is dangerous.  Imagine that all disks are 90% full and you have added an empty disk.  With great probability, all new files will be poured onto it.  To avoid this problem, you need to take to build a common segment not the free space of the pair, but the root of the Nth power of the free space. <br><br>  We chose a couple, but our daemon is streaming, and if we started streaming the file to the storage, then there is no way back.  Therefore, before uploading a real file, we first send a small test file.  If the test file has been uploaded, then subtract from the filecontent socket and stream it to the storage.  If not, choose another pair.  Sha1 can be counted on the fly, so we also check it immediately upon pouring. <br><br>  Consider now the file upload from loader to the selected disk pair.  On machines with disks, we raised nginx and use the webdav protocol.  The mail has arrived.  This file is not yet in FileDB, which means that you need to upload it through a loader to a couple of disks. <br><br><img src="https://habrastorage.org/files/842/25c/9da/84225c9da9fa432f8b48926ef73d41b2.png"><br><br>  But nothing prevents another user from receiving the same letter: suppose the letter has two addressees.  This file does not exist in FileDB yet;  This means that another loader will upload the exact same file and can select the same pair. <br><br><img src="https://habrastorage.org/files/330/45e/584/33045e584a444ebebab081bee646c05c.png"><br><br>  Most likely, nginx will solve the problem correctly, but we need to control everything, so we save the file with a complex name. <br><br><img src="https://habrastorage.org/files/491/109/bd3/491109bd37474af6b8ccbe89f2679a3c.png"><br><br>  Red is the part of the name in which each loader writes a random number.  Thus, the two PUTs do not intersect and upload different files.  When nginx responded 201, the loader makes an atomic MOVE operation, indicating the final file name. <br><br><img src="https://habrastorage.org/files/132/8c8/576/1328c857682e48e2abb95f4fdfb7a996.png"><br><br>  When the second loader completes its file and makes MOVE too, the file will be overwritten, but this is the same file - there will be no problems.  When he will be on the disks, you need to add an entry to FileDB.  Our tarantula is divided into two spaces.  So far we only use zero. <br><br><img src="https://habrastorage.org/files/68e/4f8/034/68e4f80341e043db95e140e82b16509a.png"><br><br>  However, instead of simply adding an entry for a new file, we use a stored procedure that either increments the file counter or adds an entry for the file.  Why is that?  During the time when the loader checked that the file is not in FileDB, uploaded it and went to add an entry, someone else could already upload this file and add an entry.  Above, we considered just such a situation.  One letter has two recipients, and two loaders began to fill it.  When the second one finishes, it will also go to FileDB. <br><br><img src="https://habrastorage.org/files/044/6e2/dc4/0446e2dc48d049b49974682ff0a38713.png"><br><br>  In this case, the second loader simply increments the counter. <br><br>  We now turn to the procedure dec.  For our system, two tasks are prioritized - guaranteed to write the file to disk and quickly give it to the client from disk.  Physical file deletion generates a load on the disk and interferes with the first two tasks.  Therefore, we transfer it offline.  The dec procedure itself reduces the counter.  If the latter is zero, like magic, then no one needs the file anymore.  We transfer the record about him from space0 to space1 in a tarantula. <br><br><pre> <code class="cpp hljs">decrement (sha1, magic){ counter-- current_magic ‚Äì= magic <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; current_magic == <span class="hljs-number"><span class="hljs-number">0</span></span>){ move(sha1, space1) } }</code> </pre> <br><h1>  Valkyrie </h1><br>  At each site we have a daemon Valkyrie, which monitors the integrity and consistency of the data, and it works with space1.  One disk - one demon instance.  The daemon enumerates the files on the disk one by one and checks if there is an entry about the file in space1, in other words - should it be deleted. <br><br><img src="https://habrastorage.org/files/4e5/d1b/7ca/4e5d1b7caada481cac95272733d437d0.png"><br><br>  But time passes between transferring a file to space1 when performing the dec () operation and detecting the file by the valkyrie.  So, between these two events, the file can be flooded again and again be in space0. <br><br><img src="https://habrastorage.org/files/ab9/83b/738/ab983b7389ed49aaa26ab24d8c702cb5.png"><br><br>  Therefore, Valkyrie immediately checks if the file has appeared in space0.  If this happens and the record pair_id points to a pair of disks with which the current valkyrie works, then delete the record from space1. <br><br><img src="https://habrastorage.org/files/105/bc1/d8c/105bc1d8c86d4613825472946978bab0.png"><br><br>  If there is no record, the file is a candidate for deletion.  Yet there is a time gap between the request in space0 and the physical removal.  Therefore, in this gap, again, there is the likelihood of an entry about the file in space0.  Therefore, we quarantine the file. <br><br><img src="https://habrastorage.org/files/740/2a0/c0f/7402a0c0fcc640f08970dcc0642195fe.png"><br><br>  Instead of deleting a file, rename it by adding in the name of the deleted and timestamp.  That is, physically, we will delete the timestamp + file for some time specified in the config file.  If a failure occurred and the file was decided to be deleted by mistake, the user will come for it.  We will restore the file and correct the error without losing data. <br><br>  Now we remember that there are two disks, each has its own Valkyrie.  Valkyries do not synchronize with each other.  The question arises: when to delete an entry from space1? <br><br><img src="https://habrastorage.org/files/c30/bcc/865/c30bcc865483462abf09af450aac02e0.png"><br><br>  We do two things.  First we assign one of the Valkyrie masters to a specific file.  This is done very simply: on the first bit of the file name.  If it is 0, then the master is disk0, if it is 1, then the master is disk1. <br><br><img src="https://habrastorage.org/files/9b9/188/0e9/9b91880e94a1488bb115cef36b1c43cf.png"><br><br>  Now we will spread them in time.  Recall that when a file entry is in space0, there is a magic field for consistency checking.  When we transfer the record to space1, magic is not needed, so we write the timestamp of the transfer time into space1 into it.  Now Valkyrie master will process the records in space1 immediately, and the slave will add a delay to the timestamp and process the records later + remove them from space1. <br><br><img src="https://habrastorage.org/files/f6d/85c/8c7/f6d85c8c720b4f94b8bf475b874c7613.png"><br><br>  Due to this, we get another plus.  If on the master the file went to quarantine by mistake, then when we request the master we will see it in the logs and figure it out.  The client who requested the file, in the meantime, will fold on the slave, and the user will receive the file. <br><br>  We looked at a case where Valkyrie finds a file on the disk named sha1 and this file (as a candidate for removal) has an entry in space1.  Let's consider what other options are possible. <br><br>  Example.  The file is on disk, but there is no record about it in FileDB.  If for some reason Valkyrie master did not work for some time in the above case, the slave managed to put the file into quarantine and delete the entry from space1.  In this case, we also quarantine the file via sha1.deleted.ts. <br><br>  Another example.  There is a record, but it points to another pair.  This can happen when uploading a file, if one letter is sent to two recipients.  Let's remember the scheme. <br><br><img src="https://habrastorage.org/files/31c/bae/b63/31cbaeb635044ab283aaefd1cd329513.png"><br><br>  What happens if the second loader pours a file not on the same pair of disks as the first?  It increments the counter into space0, but junk files will remain on a pair of disks where it went.  We go to this pair and check that the files are read and sha1 matches.  If everything is OK, then such files can be immediately deleted. <br><br>  Valkyrie can also find the file in quarantine.  If the quarantine has expired, the file is deleted. <br><br>  Now Valkyrie stumbles upon a good file.  It should be read from the disk and checked for integrity, compare with sha1.  Then go to another disk of the pair and find out if there is a file there.  A HEAD request is enough for this.  The integrity of the file will be checked by the daemon running on that machine.  If the integrity of the file on the current machine is violated, then it is immediately loaded from another disk.  If there is no file on that disk, then upload it from the current disk to the second one. <br><br>  It remains for us to consider the last case: problems with the disk.  After monitoring, the admins understand that this has happened.  They put the disk in the service (readonly) mode and on the second disk they start the razmuv procedure.  All files from the second disk are scattered in other pairs. <br><br><h1>  Result </h1><br>  Let's go back to the beginning.  Our mail looked like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a7f/c89/4b0/a7fc894b05334c7da4b33d85894afbff.png"></div><br>  After moving to a new scheme, we saved 18 Pb: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/84e/7b8/556/84e7b85565ce4c77adbd92bc3f759ad8.png"></div><br>  Mail began to occupy 32 PB (25% - indexes, 75% - files).  The released 18 PB allowed us for a long time not to buy new hardware. <br><br><h1>  PS about sha1 </h1><br>  Since there are a lot of questions in the comments, I will add here.  Currently, there are no known, publicly calculated examples of the collision of SHA-1 itself.  There are examples of collisions for initializing vectors for the compression function (SHA-1 freestart collision).  The probability that a random collision occurs on 12 billion files is less than 10 ^ -38. <br><br>  But suppose that is possible.  In this case, when requesting a file by sha1, we will verify its size and crc32, which are stored in the indices of a particular letter when we fill it.  Those.  We will give the file only if it has been filled with this letter, or we will not give it back. </div><p>Source: <a href="https://habr.com/ru/post/316740/">https://habr.com/ru/post/316740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316730/index.html">Screaming</a></li>
<li><a href="../316732/index.html">Logux: Connection lost, data synchronized - interview with Andrey Sitnik (Evil Martians)</a></li>
<li><a href="../316734/index.html">Personal experience of implementing the GLPI system. Part 2</a></li>
<li><a href="../316736/index.html">The Tale of Cleopatra and Russian Cryptography (Continued)</a></li>
<li><a href="../316738/index.html">Advent of Code 2016</a></li>
<li><a href="../316742/index.html">How to create a trading robot using genetic programming</a></li>
<li><a href="../316746/index.html">Dual-pane using fragments</a></li>
<li><a href="../316748/index.html">Functional languages ‚Äã‚Äãin hardware design</a></li>
<li><a href="../316750/index.html">Security Week 48: Tech Support Locker, Mirai Mutations, Vulnerability in Firefox and Tor Browser</a></li>
<li><a href="../316752/index.html">The story of a single plugin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>