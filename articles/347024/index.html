<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How did I fix the interactive login, or What is there in the guts of // chrome / test / ChromeDriver?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article came about because of one of my mistakes and two bugs - one each in Chromium Headless and ChromeDriver. As a result, I had to collect all...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How did I fix the interactive login, or What is there in the guts of // chrome / test / ChromeDriver?</h1><div class="post__text post__text-html js-mediator-article"><p>  This article came about because of one of my mistakes and two bugs - one each in Chromium Headless and ChromeDriver.  As a result, I had to collect all of this from source (the article contains detailed instructions), debug the <strong>Selenium</strong> &lt;-&gt; <strong>ChromeDriver</strong> &lt;-&gt; <strong>Chromium</strong> interaction chain in the IntelliJ IDEA and Microsoft Visual Studio debugger, and dig into Java, C ++ and JS. </p><br><p>  The article will be interesting to those who want to understand what they face as they move to Selenium + Headless Chrome and how to live with it.  And also to everyone who just wants to mock a little over the unfortunate bydlokoder. </p><br><p>  <strong>Under the cut there is a pack of screenshots (traffic!).</strong> </p><br><p><img src="https://habrastorage.org/webt/31/el/c8/31elc8cgonz3lilult3x7dtpd3c.png"><br></p><br><p>  By the way, all this could be done with a screencast - but it is impossible, because the compilation time for C ++ is unusually long.  Instead, there will be screenshots to attract attention. </p><br><p>  First recall the names of the products involved.  There are three of them: </p><br><ul><li>  <strong>Chromium</strong> is a browser.  Unbranded version of Google Chrome, without auto-updates, anal tracking probes, but also without proprietary components such as codecs. </li><li>  Chromium <strong>ChromeDriver</strong> is the part of Chromium that is responsible for managing it with external tools.  This is a standalone front-server (separate exe-file), implements the <a href="https://www.w3.org/TR/webdriver/">W3C WebDriver</a> standard and uses <a href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools</a> as a <a href="https://chromedevtools.github.io/devtools-protocol/">backend</a> . </li><li>  Selenium and its <strong>Selenium Chrome Driver</strong> - this thing provides a Java API for managing Chromium.  Java is not critical here, in JavaScript and jWebDriver it would be the same (and on the Puppeteer it might not, because it uses DevTools directly). </li></ul><br><p>  Everything together gives us a browser controlled by the Java API, JavaScript, and so on. </p><br><p>  Remember?  Let's go further. </p><a name="habracut"></a><br><p>  The plot is that in one of my pet projects I parsya Habr.  This experiment is called <a href="http://textor.io/">Textorio</a> , but there is still nothing to watch, I have not even laid out the code yet.  By the way, the very minimum of requests is sent, and this does not have any load on Habr at all. </p><br><p>  For an interactive login on Habr, a combination of headed and headless Chromium is used.  At first, the code tries to log in to Habra in automatic mode using a headless browser and previously saved cookies.  When it fails (for example, because of guglokapchi) - goes into headed-mode and shows the user login window. </p><br><p><img src="https://habrastorage.org/webt/fi/wm/e7/fiwme7sygosz-sxiiljaz3pcrls.png"><br></p><br><p>  This is a common scheme that is used in another software - for example, in Wirecast, which I sometimes have the misfortune to use on stream: this is how you log in to Facebook, YouTube and Twitch.  (At least these are the directions that I myself used in streaming. Maybe there are more of them.) But Wirecast uses its bike, and I made a decision worthy of 2018 (more precisely, spring 2017) - full-fledged Headless Chrome. </p><br><img src="https://habrastorage.org/webt/aw/g0/pv/awg0pv0bfrg29yt0btjcl6a8iw0.png"><br><p>  <i>(in the screenshot I have facepalm due to the fact that they could not calculate the height of the window and show the scrollbar on the right)</i> </p><br><p>  The choice was also influenced by the fact that <a href="https://heisenbug-piter.ru/">Heisenbug</a> and <a href="https://holyjs-piter.ru/">HolyJS</a> managed to talk to a bunch of people who use it.  And even to interview <a href="https://holyjs-moscow.ru/talks/67amybzm9qgug4qggg2uiy/">Vitaly Slobodin</a> , a former PhantomJS developer, who is now actively drowning for using Headless Chromium.  And even chat with <a href="https://heisenbug-moscow.ru/talks/2017/msk/4axfxghfmo0ke0oyyack6g/">Simon Stewart</a> - the creator of WebDriver.  So many smart people just can not be wrong. </p><br><p>  And indeed, at first, immersion in Headless Chrome turned out to be soft and pleasant.  Debugging was done in fully headed mode ‚Äî it's easier to see what the browser is doing under the hood.  But as it came to production, it turned out that during non-interactive login cookies, received in interactive mode, are completely lost! </p><br><p>  I almost pulled out all the hair on my ass.  And then I came across an <a href="https://github.com/GoogleChrome/puppeteer/issues/921">epic thread</a> in the Puppeteer bugtracker.  Puppeteer is our closest competitor from the JS world, making it the same soft as we are, so they collect about the same bugs.  From this tracker in the future was still pulled a lot of amazing information. </p><br><p>  In short, yes - initially Headless Chrome could not fumble any data at all with the headed mode.  But this is not because they are so smart and care about security (as suggested by a bunch of people from whom we can remember Oleg Tsarev, for example).  And stupidly because the layout of files in user-data-dir in headless-mode was different.  Over time, this problem began to be solved, and in the freshest canaries (Chromium Canary - the nightly assembly of Chromium), the sharing finally worked. </p><br><p>  However, earned only in one direction - saved in headed can be used in headless, but not vice versa.  This is due to the fact that when leaving the headless Chromedriver nails it faster than Chromium manages to reset the data to disk.  I lost a specific link to a bug, if you write in the comments it will be fine. </p><br><p>  But for my purposes of interactive login only one direction is needed - from headed to headless, and it turned out that it already works in Canaries. </p><br><p>  Well, it is clear that we need to go to the Canary.  The matter is not long - to change the path to chrome.exe. </p><br><p>  Restarted the tests, and they immediately crumbled into dust. </p><br><p>  The problem arose when executing such a trivial code: </p><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WebElement element, String attName, String attValue</span></span></span><span class="hljs-function">)</span></span> { driver.executeScript(<span class="hljs-string"><span class="hljs-string">"arguments[0].setAttribute(arguments[1], arguments[2]);"</span></span>, element, attName, attValue); }</code> </pre> <br><p><img src="https://habrastorage.org/webt/vb/hh/g5/vbhhg5gprpqp5f2zcjgnb9pqevm.png"><br></p><br><p>  You can see badly in the screenshot, so I will repeat by letters: <br> <code>org.openqa.selenium.WebDriverException: unknown error: call function result missing 'value'.</code> </p> <br><p>  There was no limit to my despair.  If earlier it was extremely clear how to correct such errors, now some kind of tin was happening.  No obvious frills with Java code helped. </p><br><p>  The above JavaScript code is nothing special to explain: it simply messes the selected attribute on the page.  When you run the script on ChromeDriver, the arguments array is populated with what is passed in the parameters.  How exactly the parameters are thrown in there is a separate question, because the first argument is not id, but some WebElement, which I specifically get through XPath.  How it is stored, we will see below.  Why there is no such method natively in ChromeDriver and you need to write it yourself - I have no idea, we'll write off the youth of the Selenium project :-).  Back to the topic. </p><br><p>  Intuitively, this version of ChromeDriver is simply not compatible with the version of the browser you are using, and you need to try to find a fairly recent version of ChromeDriver. </p><br><p>  In principle, these fairly recent versions of ChromeDriver <a href="https://console.cloud.google.com/storage/browser/chromedriver-data/continuous/%3Fpli%3D1">are in Google Cloud</a> .  And here begins my facs, thanks to which this article appeared. </p><br><p>  I copied myself the latest version of Chromedriver (from the second of January or something like that), started on it ... and got the same error.  In other words, the new Hromdrayver is incompatible with the Canary, too?  How so?! </p><br><p>  In fact, the fresh chrome driver <strong>works fine</strong> .  The problem is that due to some mystical problems with Windows, the new file simply did not copy.  If the file was copied successfully, we would not have seen the errors.  We‚Äôll forget how to be clear as a moron, so as not to look at the driver version in the log, and move on to the next story. </p><br><p>  Then there were some attempts at reflection. <br>  First, it was necessary to read <a href="https://www.w3.org/TR/webdriver/">the W3C Webdriver specification</a> .  This is a very important specification, as we will see later. </p><br><p>  After that, I pumped the <a href="https://github.com/SeleniumHQ/selenium/tree/master/java">Selenium Chrome Driver</a> straight into the project and began to fiercely debug it. </p><br><p>  Immediately after reading the specs, the W3C caught my eye that the request was not being made <code>http://127.0.0.1:9999/session/sessionId/execute/sync</code> , as written in the spec, but at the same URL, but without Sync.  It turned out that this is the difference between <code>W3CHttpCommandCodec</code> and <code>JsonHttpCommandCodec</code> , which are set to the driver during initialization. </p><br><p>  And what if to change it - a crazy thought flashed?  We are looking for a setter method ... and do not find it. <br>  This field is private and is set only once when processing a <code>NEW_SESSION</code> .  Actually, we do not invent the dialect ourselves inside Selenium, but Hromdrayver tells us about it, and this decision will not affect in any way. </p><br><p>  But we have a Reflection!  The URL field is final, so we will change the whole dialect. <br>  Let's try to change the dialect right before sending the executeScript in the test: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CommandCodec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commandDialectFromJsonToW3C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ChromeDriver driver</span></span></span><span class="hljs-function">)</span></span> { CommandCodec oldCommandCodec = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; CommandExecutor commandExecutor = driver.getCommandExecutor(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Field commandCodecField = commandExecutor.getClass().getSuperclass().getSuperclass().getDeclaredField(<span class="hljs-string"><span class="hljs-string">"commandCodec"</span></span>); commandCodecField.setAccessible(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); oldCommandCodec = (CommandCodec) commandCodecField.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(commandExecutor); W3CHttpCommandCodec newCodec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> W3CHttpCommandCodec(); commandCodecField.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(commandExecutor, newCodec); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { staticlogger.error(<span class="hljs-string"><span class="hljs-string">"Can't change dialect"</span></span>, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oldCommandCodec; }</code> </pre> <br><p>  (From the appearance of this code, the eyes begin to bleed, but in my defense I wrote it in a strongly altered state of consciousness, and here I cite it for historical authenticity.) </p><br><p>  Cool?  Not.  Chromedriver handled the execute / sync call perfectly and responded with exactly the same error as at the beginning of the post.  The hypothesis with the dialect is not shot. </p><br><p>  A simple solution would be to be killed against the wall. </p><br><p>  But we are not looking for easy ways.  A real Indian is walking the way of Gentoo, stepping on rakes, crutches and props of night releases in a springy step! </p><br><p>  It was decided to compile from source files the ideally suited versions of Chrome and Chromedriver.  In the future, this will allow us not to depend on the Big Uncle and the success of his work on assembling canaries.  And also, to fart with manual assembly from source is nice. </p><br><p>  In principle, this is not difficult, given the availability of <a href="http://www.chromium.org/developers/how-tos/get-the-code">detailed</a> <a href="http://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html">instructions</a> , although there are nuances. </p><br><p>  <strong>Firstly</strong> , it is desirable to select some fast disk (I had this SSD on NVMe), which should be excluded from antivirus scanning.  The fact is that about 20 gigabytes of small files will be downloaded (and about 10, if you download without history in git).  Even just deleting these files from the SSD takes about five minutes.  If the antivirus starts checking them, all this can be delayed for hours. </p><br><p>  If the company has free resources, they will be superfluous.  Neither 20 cores, nor 64GB of RAM, nor the fastest SSD on solid fuel - none of this will be superfluous, as we will see later. </p><br><p>  <strong>Secondly</strong> , it was absolutely necessary to set up git: </p><br><pre> <code class="hljs cs">$ git config --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> user.name <span class="hljs-string"><span class="hljs-string">"Oleg Chirukhin"</span></span> $ git config --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> user.email <span class="hljs-string"><span class="hljs-string">"oleg@textor.io"</span></span> $ git config --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> core.autocrlf <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ git config --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> core.filemode <span class="hljs-literal"><span class="hljs-literal">false</span></span> $ git config --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> branch.autosetuprebase always</code> </pre> <br><p>  This may not be obvious, but without the three lower settings, nothing works. <br>  If this is not done, then some errors in python will fall. </p><br><p>  <strong>Thirdly</strong> , I use Windows as the main platform for most Habr users.  You need to install Visual Studio at least update 3.2 with patch 15063 (Creators Update).  The free version will do.  In the online installer, select ‚ÄúDesktop development with C ++‚Äù and in it ‚ÄúMFC and ATL support‚Äù. </p><br><p>  If you, like me, do not trust Guy, then you need to download the online installer and call it with the following parameters from the command line: <br> <code>vs_community.exe --add Microsoft.VisualStudio.Component.VC.ATLMFC --includeRecommended</code> </p> <br><p>  Next you need to go to the "Add or Remove Programs" and find the <code>Windows Software Development Kit</code> . <br>  If you use Visual Studio, then the <code>Windows Software Development Kit</code> is presented in the form of many different versions.  Need to find the latest in the list. </p><br><p>  Next will be the <code>Modify</code> (or <code>Change</code> ) button, then a selection list in which you must select a radio button named <code>Change</code> , and then a table of additional components.  You need to select <code>Debugging Tools For Windows</code> and click another <code>Change</code> button. </p><br><p>  If this is not done, everything will fall down with Very Strange Errors. <br>  If you are very lucky, there will be something of a human-readable type: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>: dbghelp.dll <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> "C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\dbghelp.dll" You must install the "Debugging Tools for Windows" feature <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the Windows <span class="hljs-number"><span class="hljs-number">10</span></span> SDK.</code> </pre> <br><p>  If you are unlucky, there will be some useless crap. </p><br><p>  Next you need to download <code>Depot Tools</code> scripts to manage the repository.  Google does not search for easy ways and stores all the Chromium code in a hellish monorep in the gita, which also uses links to SVN.  To manage this disgrace, they had to write a lot of management scripts, which consist of batch file, bash, python and all that, under each platform - different. </p><br><p>  The tutorial says that Windows should not download dependencies from something other than <code>cmd.exe</code> . <br>  Checked: the recommendation is worth it!  I tried to collect from my favorite <code>msys2</code> and from <code>git bash</code> : they had errors that are not in cmd.exe at all. </p><br><p>  Therefore, run cmd.exe and start uploading the scripts: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mkdir</span></span> z:/git cd /dz:/git git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code> </pre> <br><p>  Next, add the path to the depot tools in the PATH (I had <code>Z:/git/depot_tools</code> ) () <br>  You also need to add the global environment variable <code>DEPOT_TOOLS_WIN_TOOLCHAIN</code> , the value is <code>0</code> .  Otherwise, the collector will start using the wrong toolchain. <br>  If you often fiddle with environment variables in Windows, it is best to use the <a href="https://www.rapidee.com/ru/about">Rapid Environment Editor</a> .  This is not paid advertising, this program really saved me many hours of life. </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">cmd</span></span>.exe <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /d Z:/git/depot_tools gclient</code> </pre> <br><p>  Then we go to fill in the Chromium code, since Chromedriver is part of it. <br>  You need to create an empty directory and run the following commands: </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> chromium <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chromium fetch chromium</code> </pre> <br><p><img src="https://habrastorage.org/webt/sr/wv/ir/srwviretgok_s0v2wvxnzoyuky8.png"><br></p><br><p>  Here in this place you will have to wait a long time, there is a repository for 20 gigs. </p><br><p>  Self-made depot tools, of course, are not known to anyone.  But there is a small help <a href="https://dev.chromium.org/developers/how-tos/depottools">here</a> and <a href="http://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools.html">here</a> .  If the help is not enough - you need to read yourself and suffer. </p><br><p>  By the way, git eats significant resources.  So, if you, like me, play Overwatch along with such operations, you can catch non-acidic lags. </p><br><p><img width="800" src="https://habrastorage.org/webt/iq/ol/ol/iqololf5qgyp1aezn3rmzzunzrq.png"><br></p><br><p>  Since I did not trust my nightly build, I decided to hack the version that corresponds to the official stable driver. <br>  To do this, switch to the piece of history that is as close as possible to it. </p><br><p>  By the way, you could use <code>fetch --no-history chromium</code> , it saves ten gigabytes on a hard disk. <br>  But this is obviously only suitable for getting the latest version, and we need to first fiddle with the story and get the commit number. </p><br><p>  See the version of the "stable" browser: <code>63.0.3239.84</code> . </p><br><p><img width="400" src="https://habrastorage.org/webt/9x/rp/lb/9xrplbewa3swymyubyhrmjfn9ma.png"><br></p><br><p>  Google that she came out on December 6th. </p><br><p>  As it is normal to look at the information about the time of assembly, I did not understand (if anyone knows, tell me?).  But googling helps. </p><br><p>  Then we look at all the commits for this date: <br> <code>git log --after="2017-12-05" --until="2017-12-06"</code> </p> <br><p>  Hash last commit for this date: <code>5eaac482ef2f7f68eab47d1874a3d2a69efeff33</code> </p><br><pre> <code class="hljs pgsql">git <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>-branch hacking git <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> <span class="hljs-comment"><span class="hljs-comment">--hard 5eaac482ef2f7f68eab47d1874a3d2a69efeff33</span></span></code> </pre> <br><p>  Switching can take considerable time.  Hell monorepa makes itself felt.  In particular, while I was switching to the hacking branch, several commits flew into the master. </p><br><p>  By the way, I highly recommend using a graphical git client instead of the command line to read commits. <br>  The fact is that the numbers there go completely insane.  Between the commit we are interested in (which was only a month ago) there are five thousand other commits.  Hands to read it in the console - very painful. </p><br><p><img src="https://habrastorage.org/webt/bm/ga/_k/bmga_kwsvtqddq6auegfm9eex6w.png"><br></p><br><p>  For the trial, I generated only a project for ChromeDriver.  It was necessary to understand whether the assembly works at all. <br> <code>gn gen --ide=vs2017 --filters="//chrome/test/chromedriver" out\Release</code> </p> <br><p>  I would use the favorite <a href="https://www.jetbrains.com/clion/">CLion</a> as the IDE, but it is not on the list supported by Ninja. <br>  Of the rest, obviously, Vizhualka is the most reasonable under Windows. </p><br><p>  The <code>gn</code> command used later is Ninja, <a href="https://ninja-build.org/manual.html">the C ++ build system</a> .  How to use Ninja specifically in Chromium, described <a href="https://www.chromium.org/developers/gn-build-configuration">in a separate document</a> : </p><br><p>  To view all possible arguments, run <br> <code>gn args --list</code> </p> <br><p>  Now we use the options read there: <br> <code>gn args out\Release</code> </p> <br><p>  A text editor opens, where we enter the release options: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">is_official_build</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> is_component_build = <span class="hljs-literal"><span class="hljs-literal">false</span></span> is_debug = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Save and close.  Ninja will immediately begin to regenerate the project files.  If it hangs at the same time, we cancel it and do <code>gn args</code> once more. </p><br><p>  Then we start the assembly. <br> <code>ninja -C out\Release chromedriver</code> </p> <br><p>  This build is fast. <br>  I didn‚Äôt measure it, but for ten minutes it should be done - there are only 4207 files. </p><br><p>  Now you can go to the out \ Default directory and quietly copy chromedriver.exe from there.  It will run without dependencies and other files in this directory.  We mentally congratulate ourselves: now we are not dependent on smart uncles who assemble us nightly assemblies on the offsite. </p><br><p>  Well, the first test is done, now it was necessary to collect the real Chromium. </p><br><pre> <code class="hljs objectivec">ninja -C <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Default chrome gn gen --ide=vs2017 --filters=<span class="hljs-string"><span class="hljs-string">"//chrome"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\ChromeRelease gn args <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\ChromeRelease is_official_build = <span class="hljs-literal"><span class="hljs-literal">true</span></span> is_component_build = <span class="hljs-literal"><span class="hljs-literal">false</span></span> is_debug = <span class="hljs-literal"><span class="hljs-literal">false</span></span> ninja -C <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\ChromeRelease chrome</code> </pre> <br><p>  It turns out about 34465 files. <br>  On i7 6700k, 32GB RAM, NVMe SSD Samsung 960 EVO - the complete assembly of Chromium took about 5 hours. <br>  With 100% CPU usage and 60% RAM loading.  (I assume that there were not enough cores for a full RAM load.) <br>  The repository after assembly weighs about 40 gigabytes. </p><br><p>  It should be noted that from time to time the compilation ‚Äúshut up‚Äù for a couple of minutes: the load of the processor and memory dropped to zero, and even the fans switched to the normal mode.  How many times it was ‚Äúfor a couple of minutes‚Äù - I don‚Äôt know, for I went to bed.  I do not have enough knowledge about the computer device to interpret this behavior - maybe someone will tell? </p><br><p>  All this time on the computer does not cost anything. <br>  In these 5 hours I slept well!  The gloomy morning of January 5 came. </p><br><p><img src="https://habrastorage.org/webt/vg/cw/iq/vgcwiqn4o8ysflng3lwcid1zpas.png"><br></p><br><p>  Ah, this romance of the native Gentoo, long sleepless red-eyed nights spent building the nightly builds from the wizard!  When you see the collected <code>chrome.exe</code> in the console, it feels as if you have done a long, pleasant physical work. </p><br><p>  With joyful excitement and a head splitting from pain (5 hours is quite a bit) I run tests on a fresh browser. </p><br><p>  Nothing works. </p><br><p><img src="https://habrastorage.org/webt/xb/ce/qx/xbceqxgcrol-djhghc_z4ovkevu.jpeg"><br></p><br><p>  It became clear that you need to dive deeper. </p><br><p>  At that moment, for the first time during the holidays, I remembered the gift of a bottle of tequila and with difficulty suppressed an irresistible desire to get drunk in the spittle. </p><br><p>  ... </p><br><p>  This time, a debug build was required. </p><br><pre> <code class="hljs objectivec">gn gen --ide=vs2017 --filters=<span class="hljs-string"><span class="hljs-string">"//chrome/test/chromedriver"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Hacking gn args <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Hacking is_official_build = <span class="hljs-literal"><span class="hljs-literal">false</span></span> is_component_build = <span class="hljs-literal"><span class="hljs-literal">true</span></span> is_debug = <span class="hljs-literal"><span class="hljs-literal">true</span></span> ninja -C <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Hacking chromedriver</code> </pre> <br><p>  Unfortunately, this commit directly crashes instantly with an error: </p><br><pre> <code class="hljs tex">Z:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">git</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cf</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">src</span></span></span></span>&gt;ninja -C out<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Hacking</span></span></span></span> chromedriver ninja: Entering directory `out<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Hacking</span></span></span></span>' [75/4177] CXX obj/base/base/precompile.cc.obj FAILED: obj/base/base/precompile.cc.obj ../../third_party/llvm-build/Release+Asserts/bin/clang-cl.exe /nologo /showIncludes @obj/base/base/precompile.cc.obj.rsp /c ../../build/precompile.cc /Foobj/base/base/precompile.cc.obj /Fd"obj/base/base_cc.pdb" Assertion failed: ID &lt; FilenamesByID.size() &amp;&amp; "Invalid FilenameID", file C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rr</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tmpcwzqyv</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">w</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">src</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">third</span></span></span></span>_party<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">llvm</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tools</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">clang</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">include</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">clang</span></span></span></span>/Basic/SourceManagerInternals.h, line 105 Wrote crash dump file "C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">olegchir</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AppData</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Local</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Temp</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">clang</span></span></span></span>-cl.exe-247121.dmp" LLVMSymbolizer: error reading file: PDB Error: Unable to load PDB. Make sure the file exists and is readable. Calling loadDataForExe</code> </pre> <br><p>  OMG, <code>C:\b\rr\tmpcwzqyv\w\src\third_party</code> ?  Shy of drive C, are you serious? </p><br><p>  But this is not important, because, looking through the Internet, we find that the bug is not in the crooked way, but in Clang.  And at that time (before which we rolled back in the gita) it was not fixed yet.  Now everything is OK.  At that time, the bug was managed by disabling precompiled headers. </p><br><p>  By the way, every time I delete <code>out\Hacking</code> from Windows Explorer, to be sure of the result.  With Windows, you can‚Äôt be sure of anything for nothing. </p><br><pre> <code class="hljs objectivec">gn gen --ide=vs2017 --filters=<span class="hljs-string"><span class="hljs-string">"//chrome/test/chromedriver"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Hacking gn args <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Hacking is_official_build = <span class="hljs-literal"><span class="hljs-literal">false</span></span> is_component_build = <span class="hljs-literal"><span class="hljs-literal">true</span></span> is_debug = <span class="hljs-literal"><span class="hljs-literal">true</span></span> enable_precompiled_headers = <span class="hljs-literal"><span class="hljs-literal">false</span></span> ninja -C <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>\Hacking chromedriver</code> </pre> <br><p>  It remains to open the project in Visual Studio: <br> <code>devenv out\Hacking\all.sln</code> </p> <br><p>  When opened, the Visor hangs - this is normal. <br>  But if it hangs longer than several minutes - it is necessary to close and reopen it. <br>  Especially if you have ReSharper C ++ or something. </p><br><p>  Examining the source code by keyword <code>execute</code> gives you the only interesting file: <code>chromedriver\chrome\web_view_impl.cc</code> </p><br><p>  In it, we are primarily interested in <code>CallFunction</code> - obviously, it processes the incoming request. </p><br><pre> <code class="hljs ruby">Status WebViewImpl::CallFunction(const std::string&amp; frame, const std::string&amp; function, const base::ListValue&amp; args, std::unique_ptr&lt;base::Value&gt;* result) { std::string json; base::JSONWriter::Write(args, &amp;json); std::string w3c = w3c_compliant<span class="hljs-number"><span class="hljs-number">_</span></span> ? <span class="hljs-string"><span class="hljs-string">"true"</span></span> : <span class="hljs-string"><span class="hljs-string">"false"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO(zachconrad): Second null should be array of shadow host ids. std::string expression = base::StringPrintf( <span class="hljs-string"><span class="hljs-string">"(%s).apply(null, [null, %s, %s, %s])"</span></span>, kCallFunctionScript, function.c_str(), json.c_str(), w3c.c_str()); std::unique_ptr&lt;base::Value&gt; temp_result; Status status = EvaluateScript(frame, expression, &amp;temp_result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status.IsError()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> internal::ParseCallFunctionResult(*temp_result, result); }</code> </pre> <br><p>  After the answer is received, before returning to the client, it will parse the result: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCallFunctionResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base::Value&amp; temp_result, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;base::Value&gt;* result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> base::DictionaryValue* dict; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!temp_result.GetAsDictionary(&amp;dict)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status(kUnknownError, <span class="hljs-string"><span class="hljs-string">"call function result must be a dictionary"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status_code; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dict-&gt;GetInteger(<span class="hljs-string"><span class="hljs-string">"status"</span></span>, &amp;status_code)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status(kUnknownError, <span class="hljs-string"><span class="hljs-string">"call function result missing int 'status'"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status_code != kOk) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> message; dict-&gt;GetString(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, &amp;message); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;StatusCode&gt;(status_code), message); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> base::Value* unscoped_value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dict-&gt;Get(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, &amp;unscoped_value)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status(kUnknownError, <span class="hljs-string"><span class="hljs-string">"call function result missing 'value'"</span></span>); } result-&gt;reset(unscoped_value-&gt;DeepCopy()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status(kOk); }</code> </pre> <br><p>  We carefully look at the code and ... <strong>see our error - call function result missing 'value'!</strong> </p><br><p>  Of course, this assumption is still to be confirmed.  "Code is cheap, show me debugger." </p><br><p>  To do this, go to IntelliJ IDEA and set breakpoint in the Java code immediately before sending executeScript: </p><br><p><img src="https://habrastorage.org/webt/3d/vw/k4/3dvwk4iqsoo5war0-vh1ncxflmm.png"><br></p><br><p>  After that, go to Vizhualku and select there debug connection to the process: </p><br><p><img width="300" src="https://habrastorage.org/webt/ro/-z/ag/ro-zagtbjljjllfqr-th5mrzvvk.png"><br></p><br><p>  And from the list, select <code>chromedriver.exe</code> : </p><br><p><img width="600" src="https://habrastorage.org/webt/km/sk/ga/kmskga3d2dwq38dpcljbhvaineo.png"><br></p><br><p>  We set breakpoint to the beginning of the <code>WebViewImpl::CallFunction</code> and see what happens. </p><br><p>  Next, release the code in the Idea and stumble upon the newly installed breakpoint in Vizhalka. </p><br><p>  In the debugger you can find many interesting details about the connection.  For example, we see that the WebElements passed to the JS function are transmitted by some internal links, and not by XPath (by which they were originally searched for).  It is very cool, fast and convenient.  The function is passed stupidly by the string - and all other parameters are also wrapped in reasonable types of modern C ++. </p><br><p><img src="https://habrastorage.org/webt/rs/ls/ez/rslsezbr6dqmssoroewajd2zn3k.png"><br></p><br><p>  In particular, the driver understands that the dialect that I tried to hack from Java is not consistent with the W3C spec.  In vain worried! </p><br><p><img src="https://habrastorage.org/webt/sf/mv/c5/sfmvc5sljzxnomkv53f9-nxggee.png"><br></p><br><p>  The command parameters in the JSON form (resulting from the execution of <code>base::JSONWriter::Write(args, &amp;json);</code> ) can be beautifully viewed in the debugger: </p><br><img width="600" src="https://habrastorage.org/webt/1h/hd/nl/1hhdnloj4vd5jbkmb0dxavfgyoe.png"><br><p>  The dubious parameter of kCallFunctionScript turned out to be the wildest javascript sheet tucked into <code>const char[]</code> .  In the name of preserving the psyche of habrovchan, I post only a small fragment: </p><br><p><img width="600" src="https://habrastorage.org/webt/py/le/ud/pyleudz9fou2d1dq-x3lppn-1je.png"><br></p><br><p>  The most interesting part of debugging happens when we get to the <code>ParseCallFunctionResult</code> function: </p><br><p><img width="600" src="https://habrastorage.org/webt/s5/7x/_b/s57x_b8vigz6n0fi3ddrmlpagae.png"><br></p><br><p>  As we expected, the assumption worked. </p><br><p>  In this piece of govnokod it is written that if we could not read the <code>value</code> , i.e.  the result of the function, you need to give up and give the client an error. </p><br><p>  I rushed into Java + JS code and rewrote the original function, adding <code>retur true;</code> to the end of the JS code <code>retur true;</code>  : </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WebElement element, String attName, String attValue</span></span></span><span class="hljs-function">)</span></span> { driver.executeScript(<span class="hljs-string"><span class="hljs-string">"arguments[0].setAttribute(arguments[1], arguments[2]); return true;"</span></span>, element, attName, attValue); }</code> </pre> <br><p>  All tests instantly turned green. </p><br><p>  This is obviously a heresy, and I have already begun to prepare to <a href="https://bugs.chromium.org/p/chromedriver/issues/list">file a bug on the tracker</a> . </p><br><p>  But then something began to clear in my head, and in a moment of insight, I remembered the words from the <a href="https://www.w3.org/TR/webdriver">W3C specs</a> : </p><br><blockquote>  Script command executes a JavaScript function. </blockquote><p>  See, <em>returns</em> .  They do not follow <a href="https://www.ietf.org/rfc/rfc2119.txt">‚ÄúKey words for use in RFCs to Indicate Requirement Levels‚Äù</a> .  They do not use the words must, must not, should and should not to indicate the level of significance.  Accordingly, from some point of view, <em>returns</em> can be read as a <em>must return</em> .  Or not - this is a matter of interpretation. </p><br><p>  On the other hand, according to the specification, it is not required that we pass the completed function.  In the end, Hromdrayver already appends the function header to us - so why not assign it to the end and return? </p><br><p>  Or from a third party, functions in JS can not return anything.  They always return at least <code>undefined</code> . </p><br><p>  Take a look at the correspondence table: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-literal"><span class="hljs-literal">null</span></span> === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> === <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Obviously, <code>undefined</code> fine mapped to <code>null</code> , available in most programming languages ‚Äã‚Äã(or having equivalents).  There is no problem to translate <code>undefined</code> into something else empty. </p><br><p>  On the fourth side, it is clear that the problem is in the standard.  Specifically in this case the specification is incomplete.  It stipulates that <code>ExecuteScript</code> will necessarily return what the function returns.  But he does not stipulate how he will behave if the function returns nothing: the text of the specification can be interpreted and how ‚Äúsince the function returns nothing, <code>ExecuteScript</code> will return nothing‚Äù.  Another implementation of <code>ExecuteScript</code> may become incompatible with the new version of specs, since decomposition is now possible: </p><br><ul><li>  the function returns nothing -&gt; <code>ExecuteScript</code> returns <code>A</code> </li><li>  the function returns nothing -&gt; <code>ExecuteScript</code> returns <code>B != A</code> </li><li>  the behavior we are seeing now with an error (and in some implementation of <code>ExecuteScript</code> it was originally!) </li></ul><br><p>  Fix any behavior does not work.  Unless you allow all three options at the same time. </p><br><p>  Based on all this, I came to the conclusion that the file bug is meaningless.     <code>executeScript</code>     ,      return,     ‚Äî   .   ‚Äî     ‚Äî  ¬´¬ª ( ),   ¬´¬ª ( ),  ¬´¬ª     <code>return true</code> ;    ‚Äî     <code>return</code> . </p><br><p>       ‚Äî       ,    ? </p><br><p>         : , <strong>     </strong> . </p><br><p><img src="https://habrastorage.org/webt/ic/7x/zz/ic7xzzdu2zklsb6igkqrvrzvtoq.png"><br></p><br><p>   : <strong>¬´Fix ExecuteScript when script returns no result¬ª</strong> . </p><br><p>    : </p><br><p><img src="https://habrastorage.org/webt/tm/pj/j6/tmpjj6f0jyzxhzpgu4wz9voqa_g.png"><br></p><br><p>  ,    ¬´ ¬ª,    ¬´¬ª. <strong> ,   ?</strong> </p><br><p>           .       ?!    chromedriver.exe    ‚Äî  . !        ! </p><br><p>  <code>return true;</code>  ,    hacking     ,  .  . </p><br><h1 id="vyvody">  findings </h1><br><ul><li>    Headless Chrome          ; </li><li>      ; </li><li>    ; </li><li>  ,           ; </li><li>     Windows; </li><li> C++  ,    ; </li><li>      ,    ; </li><li>      Chromium  ChromeDriver,  ; </li><li> Selenium  ,    ,    ,    ; </li><li>   <code>executeScript</code>    - :   ,       ; </li><li> <code>WebDriver</code> ‚Äî   W3C.     ; </li><li>  <a href="https://heisenbug-piter.ru/">Heisenbug</a>  <a href="https://holyjs-piter.ru/">HolyJS</a>    <a href="https://holyjs-moscow.ru/talks/67amybzm9qgug4qggg2uiy/"> </a> ‚Äî  PhantomJS,  <a href="https://heisenbug-moscow.ru/talks/2017/msk/4axfxghfmo0ke0oyyack6g/"> </a> ‚Äî  WebDriver.         ,     . </li></ul><br><p>        ‚Äî ,  Chromium.     ,       ,    . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347024/">https://habr.com/ru/post/347024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347014/index.html">Learning to manage Kubernetes securely</a></li>
<li><a href="../347016/index.html">We increase our premium twice, or how to hack documents signed with a reinforced qualified signature</a></li>
<li><a href="../347018/index.html">Developing Reusable Reusable Components</a></li>
<li><a href="../347020/index.html">Letter to Junior: what I would like to know at the beginning</a></li>
<li><a href="../347022/index.html">Work with problem * .dwg-files in the environment of nanoCAD</a></li>
<li><a href="../347026/index.html">Introduction to modern network balancing and proxying</a></li>
<li><a href="../347028/index.html">Toaster statistics for 2017</a></li>
<li><a href="../347030/index.html">Four nuances of successful recruitment: what every startup should know</a></li>
<li><a href="../347032/index.html">Two-factor authentication is simple, using the example of JaCarta U2F</a></li>
<li><a href="../347034/index.html">New in Unity 2017.3. Compiling scripts into separate build files</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>