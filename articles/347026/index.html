<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to modern network balancing and proxying</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I realized the lack of introductory teaching materials about modern network balancing and proxying. I thought, ‚ÄúWhy so? Load balancing is on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to modern network balancing and proxying</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jt/o9/o_/jto9o_ab0xcessfr73oo9ewo3i0.jpeg"></div><br><p>  Recently, I realized the lack of introductory teaching materials about modern network balancing and proxying.  I thought, ‚ÄúWhy so?  Load balancing is one of the key concepts for building reliable distributed systems.  After all, should high-quality information about this be available? ‚ÄùI looked and found that there is little information.  Wikipedia articles on balancing and proxy servers contain reviews of some concepts, but they cannot boast of a consistent description of the subject, especially with regard to modern microservice architectures.  Google's search for balancing information basically returns vendor sites that are filled with fashionable terms and are stingy for details. </p><br><p>  In this article I will try to fill the lack of a gradual introduction to modern network balancing and proxying.  Truth be told, this is a voluminous topic worthy of a whole book.  And so that the article did not turn out to be dimensionless, I tried to submit a number of difficult tasks in the form of a simple review. </p><a name="habracut"></a><br><h2 id="chto-takoe-setevaya-balansirovka-i-proksirovanie">  What is network balancing and proxying? </h2><br><p>  Wikipedia <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">defines</a> load balancing as: </p><br><p>  <em>In computing, load balancing improves the distribution of workloads across multiple computing resources: computers, computer clusters, network connections, CPUs, and disk devices.</em>  <em>Load balancing is designed to optimize resource utilization, maximize throughput, minimize response time, and avoid overloading individual resources.</em>  <em>Using multiple components with balancing instead of one component can increase reliability and availability due to the resulting power reserve.</em>  <em>Load balancing usually involves the use of special software or hardware such as a multi-level switch or a DNS server.</em> </p><br><p>  This definition applies to all aspects of data processing, and not just to work with the network.  Operating systems use balancing to dispatch tasks among multiple physical processors.  Container orchestrators like Kubernetes use balancing to dispatch tasks among several compute clusters.  And network balancers distribute network tasks among available backends.  <strong>This article is about network balancing only.</strong> </p><br><p><img src="https://habrastorage.org/webt/gm/rt/n-/gmrtn-zyvm6xwrhwzxsmeyrmh9k.png"><br>  <em>Figure 1: network balancing</em> </p><br><p>  <strong>Figure 1</strong> shows a simplified network balancing scheme.  Some customers request resources from some backends.  The balancer is between clients and backends and performs several important tasks: </p><br><ul><li>  <strong>Service discovery</strong>  What backends are available?  What are their addresses (i.e. how can the balancer contact them)? </li><li>  <strong>Check status</strong> .  What backends are currently working and ready to process requests? </li><li>  <strong>Balancing</strong> .  What algorithms are needed for balancing individual requests among normally functioning backends? </li></ul><br><p>  Proper use of balancing in a distributed system provides several advantages: </p><br><ul><li>  <strong>Abstraction of names</strong> .  Instead of each client knowing about each backend (discovery of services), clients can contact the balancer through a predefined mechanism, and then the name resolution procedure can be delegated to the balancer.  The predefined mechanism includes built-in libraries and well-known DNS / IP / ports.  Below we take a closer look at this. </li><li>  <strong>Resistance to failure</strong> .  Using state checking and various algorithms, the balancer is able to efficiently route data bypassing failed or overloaded backends.  That is, the operator can fix the failed backend at his leisure, and not urgently. </li><li>  <strong>Reduced cost and increased productivity</strong> .  Networks of distributed systems are rarely homogeneous.  Usually the system is divided into several network zones and regions.  Within the network zone, networks are usually built with under-utilization of bandwidth, and between zones, re-use becomes the norm (in this case, re-use and under-use mean the percentage of network card bandwidth to channel width between routers).  A smart balancer can keep query traffic within a zone as long as possible, which improves performance (less latency) and reduces overall costs in the system (there are much fewer channels between zones and they can be narrower). </li></ul><br><h3 id="balansirovschik-ili-proksi">  Balancer or proxy? </h3><br><p>  The terms <strong>balancer</strong> and <strong>proxy</strong> are often used interchangeably.  In this article, we will also generally consider them to be analogues (strictly speaking, not all proxies are balancers, but the primary function of the overwhelming majority is balancing).  Someone might argue that if balancing is part of the built-in client library, then the balancer is not a proxy.  But I will answer that such a division unnecessarily complicates an already difficult subject.  Below, we will take a closer look at the types of balancers topologies, but in this article the topology of the integrated balancer will be considered a special case of proxying: the application proxies using the built-in library offering the same abstractions as the balancer outside of the application process. </p><br><h3 id="l4-podklyucheniyasessii-balansirovka">  L4 (connect / session) -balancing </h3><br><p>  Modern balancing solutions for the most part can be divided into two categories: <strong>L4</strong> and <strong>7</strong> .  They relate to <strong>level 4</strong> and <strong>level 7 of</strong> <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">the OSI model</a> .  For reasons that will become apparent during the discussion of L7 balancing, I consider the choice of these terms to be unsuccessful.  The OSI model very poorly reflects the complexity of balancing solutions that include not only traditional protocols of the fourth level, such as TCP and UDP, but often elements of protocols of other OSI levels.  For example, if the L4 TCP balancer also offers a TLS interrupt, is it now a L7 balancer? </p><br><p><img src="https://habrastorage.org/webt/fr/ig/v3/frigv3-w2rs87cmmfzlyjyb4aco.png"><br>  <em>Figure 2: L4 interrupt TCP balancer</em> </p><br><p>  <strong>Figure 2</strong> reflects the traditional L4 <a href="https://ru.wikipedia.org/wiki/Transmission_Control_Protocol">TCP balancer</a> .  In this case, the client creates a TCP connection to the balancer, the client <strong>interrupts the</strong> connection (i.e., responds directly to the SYN), selects the backend and creates a new connection to this backend (that is, sends data to the new SYN).  The details of the scheme are not so important now; we will discuss them in the section on L4 balancing. </p><br><p>  The key point is that the L4 balancer usually operates only at the L4 level of TCP / UDP connections / sessions.  Consequently, the balancer moves the bytes so that the bytes from one session arrive on one backend.  Such a balancer is unimportant features of applications, whose bytes it manipulates.  These can be bytes of HTTP, Redis, MongoDB, or any other application protocol. </p><br><h3 id="l7-prilozheniya-balansirovka">  L7 (applications) -balancing </h3><br><p>  L4 balancing is simple and widely used.  What are its features make investing in L7-balancing at the application level?  Consider the specific case of L4 as an example: </p><br><ul><li>  Two <a href="https://grpc.io/">gRPC</a> / <a href="https://en.wikipedia.org/wiki/HTTP/2">HTTP2</a> clients want to communicate with the backend and connect through an L4 balancer. </li><li>  The L4 balancer creates one outgoing TCP connection for each incoming TCP connection, so that two incoming and two outgoing. </li><li>  But client A sends 1 request per minute (RPM) through its connection, while client B sends 50 requests per second (RPS). </li></ul><br><p>  <strong>If the backend decides to handle the traffic of client A, then it will handle the load about 3000 times less than if it were processing the traffic of client B!</strong>  This is a big problem, due to which the meaning of balancing is lost in the first place.  Also note that the problem is valid for any <strong>multiplexing</strong> protocol <strong>that supports persistent connections</strong> (keep-alive) (multiplexing is sending competitive application requests through one L4 connection, and keep-alive is maintaining connection in the absence of active requests).  All modern protocols are simultaneously multiplexing and supporting permanent connections, this requires efficiency considerations (in general, creating a connection is expensive, especially if it is encrypted using TLS), so the load mismatch in the L4 balancer increases over time.  This problem is solved with the help of the L7-balancer. </p><br><p><img src="https://habrastorage.org/webt/u5/5h/ui/u55huiraprvyqbpelcwuy1h-yps.png"><br>  <em>Figure 3: interrupt L7 HTTP / 2 balancer</em> </p><br><p>  <strong>Figure 3</strong> shows the L7 HTTP / 2 balancer.  In this case, the client creates one HTTP / 2 TCP connection to the balancer, which then creates <strong>two</strong> connections to the backends.  When a client sends two HTTP / 2 streams to the balancer, the first stream goes to backend 1, and the second goes to backend 2. So even multiplexed clients with very different request traffic will be effectively balanced across backends.  Therefore, L7-balancing is so important for modern protocols (it has a lot of advantages due to the ability to inspect application traffic, but we'll discuss this later). </p><br><h3 id="l7-balansirovka-i-model-osi">  L7 balancing and OSI model </h3><br><p>  As mentioned above, it is problematic to use the OSI model to describe the properties of balancing.  The reason is that L7, at least according to the OSI model, itself covers several discrete levels of balancing abstraction.  For example, for HTTP traffic there are several sublevels: </p><br><ul><li>  Optional Transport Layer Security (TLS).  Please note that network specialists argue about which OSI layer TLS belongs to.  Here we will refer TLS to L7. </li><li>  Physical HTTP protocol (HTTP / 1 or HTTP / 2). </li><li>  Logical HTTP protocol (headers, body and trailers). </li><li>  Message protocol (gRPC, REST, etc.). </li></ul><br><p>  The sophisticated L7 balancer works with all these sublevels.  A simpler L7 balancer may have only a small set of properties for which it is referred to as L7.  In other words, the properties of L7 balancers vary much more widely than in category L4.  And of course, here we touched only HTTP, but Redis, Kafka, MongoDB and others are all examples of L7 protocols of applications that benefit from the use of L7 balancing. </p><br><h2 id="svoystva-balansirovschika">  Balancer properties </h2><br><p>  Here we briefly review the basic properties of balancers.  Not all balancers are characterized by all the mentioned properties. </p><br><h3 id="opredelenie-servisov">  Definition of services </h3><br><p>  Defining services is a way for the balancer to determine the set of available backends.  This can be done in different ways, for example, using: </p><br><ul><li>  Static configuration file. </li><li>  DNS. </li><li>  <a href="https://zookeeper.apache.org/">Zookeeper</a> , <a href="https://coreos.com/etcd/">Etcd</a> , <a href="https://www.consul.io/">Consul</a> , etc. </li><li> Universal <a href="https://medium.com/%40mattklein123/the-universal-data-plane-api-d15cec7a">API data transfer level</a> development of Envoy. </li></ul><br><h3 id="proverka-sostoyaniya">  Condition check </h3><br><p>  This is a definition of whether the backend can handle traffic.  Status check happens: </p><br><ul><li> <strong>Active</strong> : the balancer regularly pings backends (for example, sends HTTP requests to the end point <code>/healthcheck</code> ). </li><li>  <strong>Passive</strong> : the balancer determines the status of the backend on the primary data stream.  For example, the L4 balancer may decide that the backend fails after three connection errors in a row.  And the L7 balancer will consider the backend to fail if there were three HTTP 503 responses in a row. </li></ul><br><h3 id="balansirovka">  Balancing </h3><br><p>  Yes, balancers should still balance the load!  How will the backend be selected to handle a specific connection or request if there are working backends?  Balancing algorithms are an area of ‚Äã‚Äãactive research;  they range from as simple as random and round-robin to more complex, taking into account differences in latency and backend loads.  One of the most popular algorithms due to its performance and simplicity is <a href="https://brooker.co.za/blog/2012/01/17/two-random.html">power of 2</a> . </p><br><h3 id="sticky-sessii">  Sticky sessions </h3><br><p>  For certain applications, it is important that requests from one <strong>session</strong> fall on the same backend.  This is due to caching, temporary complex state and other things.  There are different definitions of the term ‚Äúsession‚Äù, it may include HTTP cookies, client connection properties and other attributes.  Many L7 balancers support sticky sessions.  I note that the ‚Äústickiness‚Äù of the session is inherently fragile (the backend hosting the session may die), so keep your ears open while designing a system that relies on sticky sessions. </p><br><h3 id="tls-preryvanie">  TLS interrupt </h3><br><p>  The topic of TLS and its role in processing and ensuring the security of inter-service interaction deserves a separate article.  Many L7 balancers perform a large amount of TLS processing, including interrupts, checking and securing certificates, servicing certificates using <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> , etc. </p><br><h3 id="nablyudaemost">  Observability </h3><br><p>  As I like to repeat: "Observability, observability, observability."  Networks are a priori unreliable, and the balancer is often responsible for exporting statistics, tracking and logging: it helps the operator understand what is happening and fix the problem.  Balancers have a variety of possibilities for providing results of monitoring the system.  The most advanced provide extensive data, including numeric statistics, distributed tracing, and custom logging.  I note that advanced observability does not come for free: balancers have to perform additional work.  However, the benefits of the resulting data far outweigh the relatively small performance degradation. </p><br><h3 id="bezopasnost-i-umenshenie-posledstviy-dos">  Security and DoS mitigation </h3><br><p>  Balancers often implement various security functions, especially in the edge topology of deployment (see below), including speed limits, authentication and reduction of DoS consequences (for example, marking and identification of IP addresses, <a href="https://en.wikipedia.org/wiki/Tarpit_(networking)">tarpitting</a> , etc.). </p><br><h3 id="konfiguraciya-i-uroven-upravleniya">  Configuration and Management Level </h3><br><p>  Balancers need to be configured.  In large deployments, this becomes an important duty.  The system that configures the balancers is called the control plane, which can be implemented in different ways.  For details, see the <a href="https://medium.com/%40mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc">article</a> . </p><br><h3 id="i-mnogoe-drugoe">  And much more </h3><br><p>  We just walked on the surface of the balancers functionality theme.  We will talk more about this in the part dedicated to L7-balancers. </p><br><h2 id="vidy-topologiy-balansirovschikov">  Types of balancers topologies </h2><br><p>  We now turn to the topologies of distributed systems in which balancers are deployed.  Each topology applies to both L4 and L7. </p><br><h3 id="promezhutochnyy-proksi">  Intermediate Proxy </h3><br><p><img src="https://habrastorage.org/webt/4t/gs/2m/4tgs2mzhc1ebtbmyjbpb4ldeiku.png"><br>  Figure 4: intermediate proxy balancer topology </p><br><p>  The intermediate proxy topology shown in <strong>Figure 4</strong> is one of the most well-known balancing techniques.  Such balancers include Cisco, Juniper, F5, and other hardware solutions;  cloud software solutions like <a href="https://aws.amazon.com/elasticloadbalancing/">Amazon ALB and NLB</a> , Google <a href="https://cloud.google.com/load-balancing/">Cloud Load Balancer</a> ;  pure software standalone solutions like <a href="https://www.haproxy.com/">HAProxy</a> , <a href="https://www.nginx.com/">NGINX</a> and <a href="https://www.envoyproxy.io/">Envoy</a> .  The advantage of an intermediate proxy scheme is simplicity.  Users connect to the balancer via DNS and are not worried about anything else.  A disadvantage of the scheme is that the proxy (even clustered) is a single point of failure, as well as a bottleneck when scaling.  In addition, an intermediate proxy is often a black box, which makes it difficult to operate.  Did the problem occur on the client?  In the physical network?  In the proxy itself?  In the backend?  Sometimes it is very difficult to determine. </p><br><h3 id="okonechnyy-proksi">  Terminal proxy </h3><br><p><img src="https://habrastorage.org/webt/s5/xl/jy/s5xljy_m6qrrv03uohe8croj_6s.png"><br>  <em>Figure 5: balancer topology with terminal proxy</em> </p><br><p>  The topology in <strong>Figure 5</strong> is a variant of the topology with an intermediate proxy in which the balancer is available via the Internet.  And in this case, the balancer usually provides additional ‚ÄúAPI gateway‚Äù features like TLS interrupts, speed limits, authentication, and advanced traffic routing.  The advantages and disadvantages are the same as in the previous topology.  It is usually impossible to avoid using a top proxy topology in large, open-source distributed systems.  As a rule, clients need access to the system via DNS using various network libraries that are not controlled by the owner of the service (it is not advisable to use built-in client libraries or side-proxy topologies described in the following sections directly on clients).  In addition, for security reasons, it is better to have a single gateway through which all Internet traffic enters the system. </p><br><h3 id="vstroennaya-klientskaya-biblioteka">  Built-in client library </h3><br><p><img src="https://habrastorage.org/webt/0d/05/2i/0d052ikkowfonqbllucd4olqph8.png"><br>  <em>Figure 6: Balancing through the built-in client library</em> </p><br><p>  To avoid a single point of failure or problems with scaling inherent in topologies with an intermediate proxy, in more complex infrastructures, embedding the balancer by means of the library directly into the services is used, as shown in <strong>Figure 6</strong> .  Libraries support various functions, the most famous and advanced solutions are <a href="https://twitter.github.io/finagle/">Finagle</a> , <a href="https://netflix.github.io/">Eureka / Ribbon / Hystrix</a> and <a href="https://grpc.io/">gRPC</a> (based on Google‚Äôs internal system called Stubby).  The main advantage of the library-based solution is that the balancer functionality is fully distributed across all clients, which means there is no single point of failure and scaling difficulties.  The main disadvantage is that the library must be implemented in every language used by the organization.  Distributed architectures become real polyglots (multilingual).  In such an environment, the main obstacle is the cost of implementing an extremely complex network library in many languages.  Finally, deploying a library update in a large service architecture turns into a huge headache, and as a result, a bunch of different versions of the library usually work in production, which increases the operational cognitive load. </p><br><p>  Considering the above, it is advisable to use libraries in companies that can limit the diversity of programming languages ‚Äã‚Äãand overcome the difficulties of updating the library. </p><br><h3 id="pobochnyy-proksi">  Side proxy </h3><br><p><img src="https://habrastorage.org/webt/5x/5e/nw/5x5enwv9smku5awuiruw844nwh0.png"><br>  <em>Figure 7: Side Proxy Balancing</em> </p><br><p>  Side proxy topology is a topology variant with a built-in client library.  In recent years, this topology has been popularized as a service mesh.  The idea is that you can get all the benefits of the version with the built-in library without any problems with programming languages, but at the expense of a small increase in the delay in the transition to another process.  Today, the most popular side proxy balancers are <a href="https://www.envoyproxy.io/">Envoy</a> , <a href="https://www.nginx.com/">NGINX</a> , <a href="https://www.haproxy.com/">HAProxy</a> , and <a href="https://linkerd.io/">Linkerd</a> .  You can read more about the approach in my <a href="https://eng.lyft.com/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191">article on Envoy</a> , as well as in the <a href="https://medium.com/%40mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc">article on the service mesh data level and management level</a> . </p><br><h3 id="preimuschestva-i-nedostatki-raznyh-topologiy">  Advantages and disadvantages of different topologies </h3><br><ul><li>  An intermediate proxy topology is usually the easiest to use.  Its drawbacks: a single point of failure, the difficulty of scaling and working with a black box. </li><li>  Topology with a terminal proxy is similar to the previous one, but usually it has to be used. </li><li>  Topology with a built-in client library has better performance and scalability, but suffers from the need to implement the library in each language and update the library across all services. </li><li>  A side proxy topology does not work as well as the previous one, but does not have its limitations. </li></ul><br><p>  I believe that the topology with a side proxy (service mesh) in the interservice interaction will gradually replace all other topologies.  A scheme with a terminal proxy will always be needed before traffic enters the service mesh. </p><br><h2 id="tekuschie-dostizheniya-v-l4-balansirovke">  Current L4 Balancing Advances </h2><br><h3 id="l4-balansirovschiki-vsyo-eschyo-aktualny">  Are L4 balancers still relevant? </h3><br><p>  We have already talked about the advantages of L7-balancers for modern protocols, and we will discuss their possibilities in more detail below.  Does this mean that L4 balancers are no longer relevant?  Not!  Although I believe that L7 balancers will completely replace L4 <strong>in interservice interaction</strong> , however L4 balancers are still very relevant <strong>at the ends of the</strong> network, because almost all modern large distributed architectures use two-tier L4 / L7 balancing for Internet traffic.  Here are the advantages of placing dedicated L4 balancers over L7 balancers at the ends: </p><br><ul><li>  Since L7 balancers perform significantly more complex analysis, conversion, and routing of application traffic, they can handle relatively small amounts of traffic (packets per second and bytes per second) compared to an optimized L4 balancer.  Therefore, it is better to use L4 for protection against certain types of DoS-attacks (for example, SYN-streams, common attacks by packet streams, etc.). </li><li>  L7 balancers are more actively developed, more often deployed and have more bugs than L4 balancers.  The presence of an L4 balancer that checks the state of backends and diverts traffic during the deployment of an L7 balancer is much simpler than the deployment mechanisms in modern L4 balancers, which usually use BGP and ECMP (more below).  Finally, since L7-balancers have a higher probability of bugs due to complexity, an L4-balancer driving traffic past failures and anomalies increases the stability of the entire system. </li></ul><br><p>  Next, I will describe several different L4 balancers with an intermediate / terminal proxy.  These schemes are not applicable to client library and side proxy topologies. </p><br><h3 id="preryvayuschie-tcpudp-balansirovschiki">  TCP / UDP interrupt balancers </h3><br><p><img src="https://habrastorage.org/webt/v-/st/o5/v-sto5vohify7asauvgmpt8fdje.png"><br>  <em>Figure 8: Interrupting L4 Balancer</em> </p><br><p>  The first type of L4 balancers, still used.  This is the same balancer as in the introductory section on L4 balancers.  There are two separate TCP connections: one between the client and the balancer, the second between the balancer and the backend. </p><br><p>  Interrupting L4 balancers are still in use for two reasons: </p><br><ol><li>  They are fairly simple to implement. </li><li>  Interrupting the connection close to the client (low latency) significantly affects performance.  In particular, if the interrupting balancer can be placed close to clients using networks with a large number of missing packets (for example, cellular networks), then retransmissions will most likely be performed faster before the data reaches reliable cable transit along the route to the destination.  In other words, this type of balancer can be used at points of presence (Point of Presence, POP) to interrupt raw TCP connections. </li></ol><br><h3 id="balansirovschiki-s-tcpudp-tranzitom">  TCP / UDP transit balancers </h3><br><p><img src="https://habrastorage.org/webt/_s/jo/ze/_sjozemgjwhmjhr1sfv--6bbhue.png"><br>  <em>Figure 9: Transit L4 Balancer</em> </p><br><p>  The second type of L4-balancer - transit - is shown in <strong>Figure 9</strong> .  Here the TCP connection by the balancer is <strong>not</strong> interrupted.  Instead, after connection tracking and network address translation ( <a href="https://ru.wikipedia.org/wiki/NAT">NAT</a> ), packets for each connection are sent to the selected backend.  First let's define the connection tracking and NAT: </p><br><ul><li>  <strong>Connection tracking</strong> is the process of tracking the status of all active TCP connections: checking the completeness of a handshake, whether a FIN was received, how long the connection was idle, which backend was selected for the connection, etc. </li><li>  <strong>NAT</strong> is a process that uses connection tracking data to change IP / port information for packets as they pass through the balancer. </li></ul><br><p>  With the help of connection tracking and NAT, the balancer can bypass <strong>mainly</strong> raw TCP traffic from the client to the backend by transit.  Suppose a client contacts <code>1.2.3.4:80</code> , and the selected backend is at <code>10.0.0.2:9000</code> .  TCP client packets will come to the balancer at <code>1.2.3.4:80</code> .  The balancer will change the IP and port for packets to <code>10.0.0.2:9000</code> , and also change their outgoing IP and port to their own.  Thus, when the backend responds to a TCP connection, the packets will return to the balancer, which will track the connection and NAT in the opposite direction. </p><br><p>  Why use a balancer of this type instead of the interrupter described above?  After all, it is more complicated.  There are several reasons: </p><br><ul><li>  <strong>Productivity and use of resources</strong> .  Since transit balancers do not interrupt TCP connections, they do not need to buffer its window.  The size of the state stored for each connection is quite small, and it can be retrieved using effective hash table searches.  Therefore, transit balancers are usually able to handle far more active connections and packets per second than terminating balancers. </li><li>  <strong>The backend can use different congestion control algorithms</strong> .  <a href="https://en.wikipedia.org/wiki/TCP_congestion_control">TCP congestion management</a> is the mechanism by which endpoints on the Internet slow down sending data so as not to overload the available channel and buffers.  Since the transit balancer does not interrupt a TCP connection, it does not participate in congestion management.  This allows backends to use different congestion control algorithms depending on the particular application.  It also simplifies congestion control experiments (for example, the recent roll out of <a href="https://queue.acm.org/detail.cfm%3Fid%3D3022184">BBR</a> ). </li><li>  <strong>You can use direct server return (DSR) and clustered L4 balancing.</strong>  Transit balancers are needed for more advanced L4 balancing schemes, such as DSR and distributed consistency hashing clustering (discussed below). </li></ul><br><h3 id="pryamoy-vozvrat-s-servera-dsr">  Direct Return from Server (DSR) </h3><br><p><img src="https://habrastorage.org/webt/b9/2l/zn/b92lzn8ohquqg6jupx-7ceymyai.png"><br>  <em>Figure 10: L4 direct return from server (DSR)</em> </p><br><p>  <strong>Figure 10</strong> shows the direct return balancer from the server.  It is created on the basis of a transit balancer.  In essence, DSR is an optimization in which <strong>incoming request packets</strong> pass through a balancer, and <strong>outgoing response packets</strong> bypass it and go straight to the client.  The benefit of using DSR is that with many types of workloads, the response traffic is many times greater than the request traffic (for example, this is typical of HTTP requests / responses).  Suppose 10% of traffic is requests, and the remaining 90% are responses, and then using DSR there will be enough balancer with a capacity of 1/10 system capacity.  Since balancers are historically very expensive, such optimization greatly reduces the cost of the system and increases reliability.  DSR-balancers - development of the concept of a transit balancer: </p><br><ul><li>  The balancer still <strong>partially</strong> tracks the connection.  Since response packets do not go through the balancer, it is not interested in the full state of the TCP connection.  However, the balancer can make assumptions about its condition by evaluating client packages and applying different types of timeouts. </li><li>  To encapsulate IP packets from the balancer to the backend, instead of NAT, the balancer usually uses common route encapsulation ( <a href="https://ru.wikipedia.org/wiki/GRE_(%25D0%25BF%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB)">GRE</a> ).  So, when the backend receives an encapsulated packet, it can decapsulate it and find out the original IP and TCP port of the client.  This allows the backend to respond directly, bypassing the balancer. </li><li>  An important feature of the DSR is that the <strong>backend is involved in balancing</strong> .  It needs a properly configured GRE tunnel, and depending on low-level network features, you may need your own connection tracking, NAT, etc. </li></ul><br><p>  Please note that the transit and DSR balancer schemes on the balancer and the backend can be configured with different ways to monitor connections, organize NAT, GRE, etc. But this is already beyond the scope of the article. </p><br><h3 id="ustoychivost-k-sboyam-blagodarya-vysokodostupnym-param-high-availability-pairs">  Resilience due to high availability pairs </h3><br><p><img src="https://habrastorage.org/webt/sq/o4/ov/sqo4ovlgalafe1txb5ikgje4lo4.png"><br>  <em>Figure 11: L4 fault tolerance due to HA pairs and connection tracking</em> </p><br><p>  So far, we have been considering the L4-balancers scheme without regard to the environment.  The transit and DSR balancer needs some amount of connection and state tracking data.  And what if the balancer dies?  If he was alone, then all connections that went through him would break.  Depending on the situation, this can greatly affect the performance of the application. </p><br><p>  Historically, L4 balancers were hardware solutions from different manufacturers (Cisco, Juniper, F5, etc.).  These devices are very expensive and handle a large amount of traffic.  To avoid the termination of all connections due to the failure of a single balancer, two balancers are usually made, combining them into <strong>highly accessible pairs</strong> , as shown in <strong>Figure 11</strong> .  The layout of a typical HA pair is as follows: </p><br><ul><li>  Two highly available end routers serve a number of virtual IP ( <a href="https://en.wikipedia.org/wiki/Virtual_IP_address">VIP</a> ).  These routers declare VIPs using the Border Gateway Protocol ( <a href="https://ru.wikipedia.org/wiki/Border_Gateway_Protocol">BGP</a> ).  The primary router has a higher BGP weight than the spare, so in normal mode it serves all traffic. BGP ‚Äî   ,       BGP ,         ,      .    ,     ,      . </li><li>     L4-   ,      BGP-,    ,         . </li><li>   <strong>-</strong>           .  ,   ,      . </li><li>       <strong>-</strong> .             BGP-      -  ,     . </li></ul><br><p>       -   .       : </p><br><ul><li> VIP'           .  - VIP    ,   VIP     VIP'. </li><li>     . 50 %     .     ,     . </li><li>           ,    ¬´/¬ª, . .        .          ,     . </li><li>           .          ,     . </li></ul><br><h3 id="ustoychivost-k-sboyam-i-masshtabirovanie-s-pomoschyu-klasterov-s-raspredelyonnym-konsistentnym-heshirovaniem">             </h3><br><p><img src="https://habrastorage.org/webt/wf/7w/lx/wf7wlx5hzxkhenwx33t0znxfgzm.png"><br> <em> 12: L4            </em> </p><br><p>   2000-   -   ,   L4  ,   <strong> 12</strong> .   : </p><br><ul><li>       . </li><li>        ,        . </li></ul><br><p>      <strong>           </strong> .   : </p><br><ul><li> N     <a href="https://ru.wikipedia.org/wiki/Anycast">Anycast</a> VIP'  BGP-.      <strong></strong>     ,        ( <a href="https://en.wikipedia.org/wiki/Equal-cost_multi-path_routing">ECMP</a> ).  ‚Äî   L4-   IP/   IP/.  , ECMP ‚Äî               .       ,     ,   ,           ,    ,  . </li><li> N L4-       VIP'   BGP-.   ECMP,      -  . </li><li>  L4-     ,     <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2585%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5"> </a>    .   ,     ,  GRE. </li><li>              DSR. </li><li>        .        ,  ,        .        . </li></ul><br><p>  ,       ,     : </p><br><ul><li>           .          ,      . </li><li>                 . </li><li>          ,       . </li></ul><br><p>      ,   : ¬´         ECMP?     ?¬ª       DoS     .       BGP,          . </p><br><p>    L4-    (    ).     ‚Äî Google <a href="https://research.google.com/pubs/pub44824.html">Maglev</a>  Amazon <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html">Network Load Balancer (NLB)</a> .    OSS-,   ,   ,        2018-.   ,    L4- ‚Äî    OSS    . </p><br><h2 id="tekuschie-dostizheniya-v-l7-balansirovke">    L7- </h2><br><p> <em>- ‚Äî  <strong> </strong> -.  ¬´ ¬ª. Nginx , HAProxy, linkerd, Envoy,     .  proxy-as-a-service/routing-as-a-service SaaS-   .   !</em> <br> <em>‚Äî <a href="https://twitter.com/copyconstruct/status/935354313617977345">@copyconstruct</a></em> </p><br><p>  ,        L7-/.             .   ,      ,   ,    .  ,  ,      ,     IP     .      ,    ,     .       ,         L7-. </p><br><h3 id="podderzhka-protokolov">   </h3><br><p>  L7-     .       ,         ,    ,      . . , Envoy    L7-    HTTP/1, HTTP2, gRPC, Redis, MongoDB  DynamoDB.        ,  MySQL  Kafka. </p><br><h3 id="dinamicheskaya-konfiguraciya">   </h3><br><p>   ,               .      ‚Äî <a href="https://istio.io/">Istio</a> .      <a href="https://medium.com/%40mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc"></a> . </p><br><h3 id="prodvinutaya-balansirovka">   </h3><br><p> L7-       ,   ,  ,  ,   (circuit breaking),   (shadowing), ,       . </p><br><h3 id="nablyudaemost-1">  </h3><br><p>          . ,     L7- ‚Äî    , <strong>   </strong> .  ,            L7-. </p><br><h3 id="rasshiryaemost">  </h3><br><p>   L7-          .       ,    .     ,  <a href="https://www.lua.org/">Lua</a> . </p><br><h3 id="ustoychivost-k-sboyam">    </h3><br><p>        L4-  .    L7-?              (stateless).     L7-    .  ,    ,  L7-,  ,    L4.    L7  ,   . </p><br><p>     L4  L7         ,     . </p><br><h3 id="i-prochee">   </h3><br><p> L7-   . , <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/arch_overview"> </a>  Envoy. </p><br><h2 id="globalnaya-balansirovka-i-centralizovannyy-uroven-upravleniya">       </h2><br><p><img src="https://habrastorage.org/webt/kt/ns/bd/ktnsbdqbk_ivdzyssrson6sto-w.png"><br> <em> 13:  </em> </p><br><p>            .  ,          .  <strong> 13</strong>   <strong>  </strong> .     : </p><br><ul><li>           (A, B  C). </li><li>  , 90 %     C,   5 % ‚Äî  A  B. </li><li>           .        , , ,    . . </li><li>             . </li></ul><br><p>        ,      .  For example: </p><br><ul><li>        . </li><li>      . </li><li>            ,  DDoS-. </li><li>     ,         . </li></ul><br><p>     , ,      ,      .       : <a href="https://medium.com/%40mattklein123/the-universal-data-plane-api-d15cec7a">1</a>  <a href="https://medium.com/%40mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc">2</a> . </p><br><h2 id="evolyuciya-ot-apparatnyh-do-programmnyh-resheniy">       </h2><br><p>          ,       L4-.     ? </p><br><p> <em>   OSI-    . ,  - :</em> <br><img src="https://habrastorage.org/webt/zj/s0/vg/zjs0vgnz4qlqriz24sba-iw39oo.png"><br> <em>‚Äî <a href="https://twitter.com/infosecdad/status/888221481590816768">@infosecdad</a></em> </p><br><p> ,   ,          : </p><br><ul><li>           . </li><li>    L3/L4      ,          ,  <a href="http://www.linuxvirtualserver.org/software/ipvs.html">IPVS</a> , <a href="http://dpdk.org/">DPDK</a>  <a href="https://fd.io/">fd.io</a> .    -   5 .        80 /   ,   Linux   ,    DPDK.      - ASIC,   ECMP-         ,    . </li><li>   L7-  NGINX, HAProxy  Envoy       ,       F5.    L7-       . </li><li>          IaaS, CaaS  FaaS,    , ,           (  ¬´ ¬ª  ¬´,       ¬ª). </li></ul><br><h2 id="zaklyuchenie-i-buduschee-balansirovki">     </h2><br><p>  : </p><br><ul><li>  ‚Äî     . </li><li>      : L4  L7. </li><li>      . </li><li> L4-     , ,   . </li><li>     L7-     . </li><li>             ,         . </li><li>       OSS-   .  ,     F5      OSS-    .       Arista/Cumulus/ .      on-premise ,             . </li></ul><br><p>  ,          !   OSS           .  ,        ¬´¬ª               . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347026/">https://habr.com/ru/post/347026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347016/index.html">We increase our premium twice, or how to hack documents signed with a reinforced qualified signature</a></li>
<li><a href="../347018/index.html">Developing Reusable Reusable Components</a></li>
<li><a href="../347020/index.html">Letter to Junior: what I would like to know at the beginning</a></li>
<li><a href="../347022/index.html">Work with problem * .dwg-files in the environment of nanoCAD</a></li>
<li><a href="../347024/index.html">How did I fix the interactive login, or What is there in the guts of // chrome / test / ChromeDriver?</a></li>
<li><a href="../347028/index.html">Toaster statistics for 2017</a></li>
<li><a href="../347030/index.html">Four nuances of successful recruitment: what every startup should know</a></li>
<li><a href="../347032/index.html">Two-factor authentication is simple, using the example of JaCarta U2F</a></li>
<li><a href="../347034/index.html">New in Unity 2017.3. Compiling scripts into separate build files</a></li>
<li><a href="../347036/index.html">Tutorial on the Unreal Engine. Part 10: How to create a simple FPS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>