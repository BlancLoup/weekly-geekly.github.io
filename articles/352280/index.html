<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ cycling for professionals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Classes that people write on their own, and then copy from one project to another, although they already exist in standard libraries, are called bicyc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ cycling for professionals</h1><div class="post__text post__text-html js-mediator-article">  Classes that people write on their own, and then copy from one project to another, although they already exist in standard libraries, are called <strong>bicycles</strong> in the common people.  The first question that arises when meeting with such a "bicycle" - <strong>why do people rewrite something again?</strong>  There may be several options. <br><br><ul><li>  Some do it <strong>for self-study</strong> : they take the class of the standard library, write it themselves from scratch, compare what happened with what is in the standard library - they learn something new for themselves in the process. <br></li><li>  Some projects have <strong>special code requirements</strong> .  In embedded-development it is customary to work without RTTI and without exception, therefore parts of the standard library that use RTTI and exception must be rewritten without them. <br></li><li>  Rarely, but it happens when they write a bicycle, because they <strong>can write better</strong> than in a standard library.  As a rule, such innovations sooner or later fall into the standard library. <br></li><li>  It only <strong>seems to</strong> others <strong>that they can write better</strong> , and there are more such people.  But in the process they learn, find out for themselves something new and discover something interesting. <br></li><li>  There may be <strong>other reasons</strong> . <br></li></ul><br>  Today we <strong>will not say that bicycles are bad</strong> , this is not necessarily the case.  We'll talk about what's really bad: <br><br><ul><li>  mindlessly transfer <strong>outdated technologies of</strong> 20-30 years old into modern projects; <br></li><li>  use <strong>"harmful" benchmarks and optimizations.</strong> <br></li></ul><br>  And also we will touch upon <strong>‚Äúharmful‚Äù tips</strong> , discuss the <strong>newest programming practices</strong> (C ++ 11 and later), think about what to do with the <strong>‚Äúperfect‚Äù bike.</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/rJWSSWYL83U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <em><strong>About the speaker:</strong> Anton Polukhin ( <a href="https://habrahabr.ru/users/antoshkka/">@antoshkka</a> ) Yandex employee, active Boost library developer, by TypeIndex, DLL, Stacktrace, Maintainer Boost Any, Conversion, Lexicalast, Variant, co-chair of the National Standardization Group C ++.</em>  <em>All this together means that <strong>Anton sees a lot of code every day</strong> , both open-source and commercial, and knows very well how often developers invent bicycles.</em> <br><br>  So, the theme is bicycles.  What class will we start from?  Correctly - from the line. <br><br><h2>  std :: string </h2><br><h3>  string: C ++ 98 </h3><br>  Imagine that in the courtyard of the deep Middle Ages, people in armor jump on horses.  You are a developer of a standard library, and the only standard that is is C ++ 98. <strong>You need to write your own line.</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  You will start writing something very simple without any templates.  You will have a pointer to a dynamically allocated piece of memory (data), a variable size that stores the number of characters in an allocated piece of memory, and a variable capacity that sets the size of this dynamic piece of memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; <span class="hljs-comment"><span class="hljs-comment">// ... public: string(const string&amp; s) :data(s. clone()) // new + memmove {} // ... string(const char* s); // new + memmove };</span></span></code> </pre><br>  For your string class, you write a copy constructor and a constructor from an array of characters.  Both of them will dynamically allocate a piece of memory, move the characters there.  Here, it says new + memmove, but in fact there may be slight variations like malloc, memcpy, the meaning remains the same. <br><br>  Since you are a good developer of a standard library, you are wondering how well such a string class will work.  You open custom code, look at popular recipes, and find something like the example below, where the map is created from the string and int, and a couple is inserted there. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; m.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) );</code> </pre><br>  And then you realize <strong>that things are bad - slowly</strong> , very slowly. <br><br>  You have a friend Vasya, who is also developing a standard library and his line class works faster.  Where exactly the <strong>performance is lost</strong> : <br><br><ul><li>  First, the string constructor from the character array is called ‚Äî this is a call to new and memmove ( <code>string("Hello!")</code> ). </li><li>  Then the constructor of the pair is called, i.e. the copy-constructor of the string will be called.  This is another call to new and another call to memmove ( <code>make_pair(string("Hello!"), 1)</code> ). </li><li>  Then this pair is inserted into the map.  The pair and its contents are copied - another call to new and memmove ( <code>m.insert(make_pair(string("Hello!"), 1))</code> ). </li><li>  After that, the temporary object of the pair and the temporary object of the line will be deleted. </li></ul><br>  It turns out a very sad picture - <strong>3 new calls, 3 memmove</strong> calls, a couple delete calls, and all this is terribly slow.  It annoys you that Vasya is faster, and you start thinking about how to do better. <br><br><h3>  string: COW </h3><br>  Here you either invent yourself or read about <strong>Copy-On-Write</strong> (COW) technology somewhere.  It allows you <strong>to work more effectively with temporary objects</strong> .  Most of the losses were due to the fact that temporary objects are being created that are not modified in any way: they were simply created, some of them were copied and immediately destroyed. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; m.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      ); //     </span></span></code> </pre><br>  By using Copy-On-Write technology, instead of the line uniquely owning the dynamic object that was created on the heap, you can have <strong>several lines simultaneously referring to a dynamic object</strong> .  Then in this dynamic object there will be a reference count - how many lines simultaneously work with it.  The code will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> use_count; <span class="hljs-comment"><span class="hljs-comment">// &lt;=== // ... };</span></span></code> </pre><br>  You write <strong>class string_impl</strong> (you can write it better) and add <strong>use_count</strong> , i.e. reference count ‚Äî how many lines refer to a dynamic object at the same time.  You also change the copy constructor; now it will take a pointer to a dynamic object from the input string and increase the reference count. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> string_impl*impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s) :impl(s.impl) { ++impl-&gt;use_count; } };</code> </pre><br>  Little will have to tinker with non-constant functions that potentially change the line.  If two lines own a dynamic object, and one of them starts changing it, the other will see the changes.  This is a side effect that users will be dissatisfied with, because they first worked with a single line, and then it suddenly changed. <br><br>  <strong>We need to add a check</strong> : if we uniquely own a dynamic object, that is, the reference count is 1, then we can do whatever we want with it.  If the reference count is not 1, we must call new and memmove, create another dynamic object and copy the data from the old object. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> string_impl*impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (impl-&gt;use_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = clone(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> impl-&gt;data[i]; } };</code> </pre><br>  Destructor also change.  It will reduce the reference count and look: if we are the last owner of a dynamic object, then it needs to be removed. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> string_impl*impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>() { --impl-&gt;use_count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl-&gt;use_count) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> impl; } } };</code> </pre><br><h3>  Insert performance in std :: map </h3><br>  There is nothing better in the constructor from the array of characters, still new and memmove.  But then the constructor will be called to copy the string when creating a pair, which now does not call either new or memmove.  When the pair is inserted into the map, the string copy constructor will again be invoked, which again does not invoke new and memmove. <br><br>  All temporary object destructors will not cause delete either - beauty! <br><br>  Total, <strong>COW more than 2 times speeds up code in C ++ 98</strong> . <br><br>  If someone tells me now that he knows a technology that increases the performance of my code by 2-3 times, I will use it everywhere. <br><br>  In the 1990s, many libraries did this.  For example, there is a QT library, where COW is present in <strong>almost all base classes</strong> . <br><br>  But technology does not stand still.  The 2000s are coming, there are processors with Hyper-threading and multi-core processors, not only server-side, but also user ones: <br><br><ul><li>  Hyper-threading in Pentium 4 processors. </li><li>  AMD64 2-core Opteron processor designed for servers. </li><li>  Pentium D x86-64 is the first 2-core processor for personal computers. </li></ul><br>  Now each user can have more than 1 core.  And our line is already bad, because we have a common reference count. <br><br>  For example, there are two streams, in which the string refers to a common dynamic object.  If threads work with strings and at the same time decide to remove them, it turns out that we from two threads will try to simultaneously change the dynamic reference count use_count.  This will cause <strong>either a memory leak or an application to crash</strong> . <br><br><h3>  string: COW MT fixes </h3><br>  To fix this, we introduce an atomic variable - let's pretend that C ++ 98 has std :: atomic.  Now our class looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity; atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; use_count; <span class="hljs-comment"><span class="hljs-comment">//&lt;=== Fixed // ... };</span></span></code> </pre><br>  Everything works - great!  Nearly‚Ä¶ <br><br>  Now we have both <strong>the copy constructor and the destructor have atomic instructions in themselves</strong> , which is not very good.  Non-constant methods turn into a terrible disgrace, because boundary conditions appear that rarely arise, but which we are obliged to handle. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> string_impl*impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (impl-&gt;use_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// atomic string cloned = clone(); // new + memmove + atomic ‚Äî swap(*this, cloned); // atomic in ~string for cloned; delete in ~string if other thread released the string } // ... } };</span></span></code> </pre><br>  For example, two threads own lines.  These lines refer to the same dynamic object.  One thread decides to change the string.  The line looks at that it non-uniquely owns the dynamic object and starts to clone the object.  At this point, the second thread says that it no longer needs the line and calls its destructor. <br><br>  And the first thread still clones, calls new, memmove.  He finished his business and suddenly realizes that he has two lines, but he needs one. <br><br>  It is necessary to provide logic for this as well, and these are additional checks, perhaps an additional call to new and memmove, and again many atomic operations, which is bad. <br><br><h3>  Atomic </h3><br>  X86 is not an atomic increment - a simple increase in the integer by one takes one processor cycle [ <a href="http://www.agner.org/optimize/instruction_tables.pdf">1</a> ].  If this operation is made atomic, it will take from 5 to 20 cycles if only one core makes an atomic instruction and if this core changes the atomic variable [ <a href="https://htor.inf.ethz.ch/publications/img/atomic-bench.pdf">2</a> ].  If the nucleus is not the last to change the atomic variable, then around 40 cycles. <br><br>  So, this solution <strong>is 5-40 times slower</strong> only due to the fact that an atomic variable is used.  Further worse. <br><br><img src="https://habrastorage.org/webt/tq/t2/30/tqt230_snk6kopqqlyqrztn0ct4.png"><br><br>  If several cores simultaneously work with an atomic variable, for example, three cores simultaneously want to increment an atomic variable, we will have a lucky kernel that will start to make an atomic increment, the other two cores will wait from 5 to 40 cycles until the core finishes all its actions. <br><br>  Then a second lucky core appears, which begins to perform an atomic operation, since it was not the latter that changed the atomic variable, it would take 40 cycles.  The third core is still waiting.  The more nuclei at the same time they try to perform an atomic operation on the same variable, the longer the last nucleus will wait. <br><br>  This is how the last kernel waits: <br><br><img src="https://habrastorage.org/webt/jz/ja/45/jzja45no5paabuddhvhkho0dn0g.png"><br><br>  In this example, 16 cores and the <strong>last core waits around 600 cycles</strong> .  This is the easiest kernel unluckiest.  If we sum up the downtime, then the idle picture will turn out to be quadratic. <br><br><img src="https://habrastorage.org/webt/v-/hd/k_/v-hdk__odqpzak5bilfpwsfhiwe.png"><br><br>  <strong>At 16 cores, about 6000 clock cycles went nowhere</strong> . <br><br>  There are systems containing more than 90 kernels, and if all of them 90 kernels decide to work simultaneously with the same atomic variable, everything will be very sad. <br><br>  <strong>COW <strike>more than 2 times</strike> speeds up code in C ++ 98.</strong>  <strong>Anyway, Copy-On-Write is faster and that's it.</strong> <br><br><h2>  C ++ 11 </h2><br>  In C ++ 11, <strong>rvalue reference</strong> appears, which allows you to write special classes and special methods that work with temporary objects. <br><br>  For example, a move constructor for a string works equally well if the string is COW and if the string is the most common baseline from the Middle Ages, where the object is dynamically allocated, and only one line owns it. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&amp; s) { swap(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, s); }</code> </pre><br>  What's going on here?  At the entrance comes the object <strong>s</strong> .  It is temporary, we know that the compiler will delete it soon, that no one else will use it, and we can <strong>take resources from it</strong> .  With it, you can do anything at all, the main thing is that for him you can then call the destructor. <br><br>  Took away resources.  We are an empty string, we received a string with the result, we make a <strong>swap</strong> .  Now we are a string with the result, and the time string with no resources is empty. <br><br>  Let's see how it works in our example, if we have a string without COW. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; m.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// string("Hello!") );</span></span></code> </pre><br>  A string is created from the ‚ÄúHello‚Äù character array.  Here new and memmove are the same as with COW. <br><br>  The next is better.  When copying a string into a pair, we will call the move-constructor of the string ( <code>pair(string&amp;&amp;, int)</code> ).  The pair sees that the string is temporary, and takes resources from the temporary object.  New and memmove will not. <br><br>  When inserting a pair into a map, the map sees that the pair is also a temporary object ( <code>m.insert(pair&amp;&amp;)</code> ).  Map calls the move constructor for the pair, the couple calls the move constructor for its content, the move constructor for the string. <br><br>  Without new and memmove, the line will move inside the map: 1 call to new and 1 call to memmove - the same as with COW, <strong>but without atomic operations</strong> . <br><br>  Well, what if we want to copy a line?  We are all reasonable people, and we want to copy a line, as a rule, if we want to change it. <br><br>  Without COW we copied the line, immediately called new and memmove.  We can change the line and do anything. <br><br>  If we have a COW line: <br><br><ul><li>  create a new row object with an atomic increment of the total reference count; </li><li>  one of these lines is starting to change; <br></li><li>  the line will atomically look that we do not uniquely own the line, will cause new, memmove, perform additional checks so that the second thread doesn‚Äôt destroy this line, that we have the right number of lines, etc. </li></ul><br>  The result is the same as without COW, but at least a <strong>pair of unnecessary atomic operations</strong> appears. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (impl-&gt;use_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// atomic string cloned = clone(); // atomic‚Äî swap(*this, cloned); // atomic in ~string for cloned } return impl-&gt;data[i]; }</span></span></code> </pre><br>  <strong>Non-constant methods are still terrible.</strong>  If we want to go through our line (the first ten characters in a line) using indices, the COW line is 10 atomic operations on the same atomic variable.  If two streams simultaneously pass through the same line - a big trouble. <br><br><img src="https://habrastorage.org/webt/xw/ro/vs/xwrovsoaxaj6s5d8sipslqeynqc.png"><br><br>  As a result, the COW constructor has atomic operators, the destructor will most likely call atomic instructions ‚Äî there are many atomic instructions that we don‚Äôt need.  We did not ask them, and this is against the rules of C ++.  We pay for what we do not use. <br><br>  <strong>Beginning with C ++ 11 COW, lines are not allowed in the standard.</strong>  There are special conditions imposed on the line that COW cannot be implemented.  All modern implementations of standard libraries do not have COW lines. <br><br>  <strong>COW is outdated, more careful with its use.</strong> <br><br>  Careful use COW in new projects.  Do not trust articles that are more than 10 years old, recheck them.  COW does not show such good results as 20 years ago. <br><br><h3>  Cases where COW is still burning </h3><br>  If you had a COW line and said to all its users: ‚ÄúWe have a COW line - it copies everything perfectly, everything is fine, we have COW everywhere‚Äù, users could sharpen it and write code taking into account that your classes use COW. <br><br>  For example, a user could write a class bimap ‚Äî this is a class that can search both by key and by value. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// COW legacy class bimap { std::map&lt;string, int&gt; str_to_int; std::map&lt;int, string&gt; int_to_str; public: void insert(string s, int i) { str_to_int.insert(make_pair(s, i)); int_to_str.insert(make_pair(i, std::move(s))); }</span></span></code> </pre><br>  He could write it through two std :: map, each of which has a line.  Here is the COW line, the user knows about this, as well as the fact that there are two copies of the line in the map.  The user knows that they will dynamically refer to the same memory object, and that this is effective from memory.  If here the COW line is changed to the usual one, the cost of memory will double. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// COW legacy fix class bimap { std::map&lt;string, int&gt; str_to_int; std::map&lt;int, string_view&gt; int_to_str; public: void insert(string s, int i) { auto it = str_to_int.insert(make_pair(std::move(s), i)); int_to_str.insert(make_pair(i, *it.first))); }</span></span></code> </pre><br>  In C ++ 17, this can be corrected, for example, as in the example above, replacing one of the lines with string_view.  From memory it will turn out exactly the same, but atomic operations will be removed and the code will be slightly faster. <br><br><h3>  One optimization for string </h3><br>  It turns out that we added a move constructor to that ancient line of the year 98, which uniquely owned a dynamic object, and that‚Äôs the perfect line?  Nothing better can be done? <br><br>  That's what people came up with.  They looked at one of our first examples where a map is created from a string and an int, and a couple is inserted into it, shook their heads for a long time and said how bad things are: <br><br><blockquote>  - Here new and memmove is called.  For new there can be a system call and atomic operations, but we still do not have C ++ 14, where the compiler can optimize new.  Everything is very bad - let's do something better! <br></blockquote><br><br>  People have <strong>come up with how you can, without changing the size of the string ‚Äî the variable std :: string ‚Äî to store characters in it without dynamically allocating memory</strong> .  They looked at the very first class of the line: <br><br><blockquote>  ‚ÄîWe have a pointer on a 64-bit platform here - this is 8 bytes, we have a size on a 64-bit platform too - this is again 8 bytes.  This is 16 bytes - you can save 15 characters!  What if to use these two variables not as a pointer variable and a size variable, but to place data directly on top of them? <br></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_small_buffer_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; } no_small_buffer; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">small_buffer_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">no_small_buffer_t</span></span>)]; }small_buffer; }impl; }</code> </pre><br>  Now inside the string in the example above is a union.  The first part is a pointer to data and the size_t variable.  The second part of the union, the structure, contains data (a small buffer of the size of char * and size_t).  Approximately <strong>16 bytes</strong> fit into it. <br><br>  If capacity = 0 - this means that we have not dynamically allocated memory and we need to go to impl small_buffer_t, and our data will be in data without our dynamic allocation. <br><br>  If capacity ‚â† 0, it means that we have dynamically allocated memory somewhere, and we need to go to impl no_small_buffer_t.  There is a pointer to a dynamically allocated piece of memory and the variable size. <br><br>  Of course, in the example a slightly simplified version.  Some standard libraries, such as Boost, can store 22 characters and, in addition, terminate 0 without dynamic allocations without increasing the size of the string.  All modern standard libraries use this trick.  This is called <strong>Small String Optimization</strong> . <br><br>  This thing is good, firstly, on empty lines.  They are now guaranteed not to allocate memory, and guaranteed to call the c_str () method will no longer allocate memory. <br><br>  I know companies that have rewritten std :: string, because their empty string dynamically allocates memory.  Do not do this anymore. <br><br>  Secondly, for example, our ‚ÄúHello!‚Äù Will fit without dynamic allocation.  If the usernames are stored in the lines, their names and surnames are separate from the names, some identifiers, cities, countries, names of currencies - as a rule, everything will fit into the line without dynamic allocations. <br><br>  But people looked and again thought that slowly.  <strong>Starting with C ++ 17, the compiler is able to optimize memmove</strong> , its alternative is the one that is in the line at the compilation stage.  But this was not enough.  In C ++ 17 there is <strong>Guaranteed copy elision</strong> , which guarantees that in some cases there will be no copies at all and there will be no memmove.  Just in a map, by some miracle, this line is formed without intermediate variables. <br><br><div class="spoiler">  <b class="spoiler_title">With the line figured out, but the answers to some clarifying questions from the audience here</b> <div class="spoiler_text"><blockquote>  - So far, everything looks like a bicycle ad in fact.  For example, the COW in the GCC was until 2015, before the release of 5.1.  So you had to write bikes? <br></blockquote><br>  - More is not needed! <br><br><blockquote>  - How?  For example, everyone says that the cool thing is Small String Optimization.  But, let's say, when a line is dynamically allocated, size and capacity can be thrust into the same buffer as the line.  Then the string will be only 8 bytes.  And if I have many lines in the object, will it be more profitable? <br></blockquote><br>  - I have a real case from practice.  Replacing the COW line with a string with Small String Optimization sped up the project by 7-15%, because for some reason we work most of the time with small lines that get into std :: string.  Therefore it becomes faster. <br><br>  Is it possible to use a line that will dynamically store size and capacity in memory?  Can.  There will be problems with the optimizer.  Seeing that we have a pointer to some part of the memory, he will not be able to better optimize these variables.  The optimizer will not be able to do heuristics based on size and capacity.  If size and capacity are located on the stack and the optimizer sees this, it will be able to make heuristics on it and better optimize the code. <br><br><blockquote>  - Does this optimization work worse with wide unicode strings? <br></blockquote><br>  - Yes, worse.  But the number of bytes, which is in small_buffer, is the same. <br></div></div><br><h2>  Development without regard to ready-made solutions.  std :: variant </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the example of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: variant,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consider what happens if people try to cycle-build without looking at other people's decisions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++ 17, the std :: variant class is adopted - this is a smart union that remembers what it stores. We can write std :: variant &lt;std :: string, std :: vector &lt;int &gt;&gt;. This means that the variant can store in itself either a string or a vector. If we write the word ‚ÄúHello‚Äù in such a variant, the variant remembers the index of the template parameter in the variable t_index (which contains a line), locates the line in place and will store it.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { T0 v0; T1 v1; T2 v2; <span class="hljs-comment"><span class="hljs-comment">// ... }; int t_index;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we now try to write a vector there, std :: variant will see that it stores the line at the moment, not the vector, will call delete for the line, construct a vector in place of the line and update t_index at some point. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The class was adopted in C ++ 17, and people all over the world immediately rushed to write it again, rewrite, and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycle building</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variant</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::tuple&lt;T...&gt; data; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above - the real code from the open source project, do you see an error in it? </font><font style="vertical-align: inherit;">Here, instead of union, was a struct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is the code from the commercial project:</font></font><br><br><pre> <code class="cpp hljs">variant&lt;T...&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> U&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (&amp;value == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } destroy(); <span class="hljs-comment"><span class="hljs-comment">// data-&gt;~Ti() construct_value(value); // new (data) Tj(value); t_index = get_index_from_type&lt;U&gt;(); // t_index = j; return *this; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the error is much worse and in many implementations of the variant it is present. There will be big problems with exceptions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we have a variant that stores std :: string and we are trying to write a vector into it. The destroy line will invoke delete for the string. From this point on, the variant is empty, it does not store anything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then in place of the line we are trying to create a vector. The vector is transmitted by a constant link and we have to copy it. Call </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">placement new</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and trying to copy the vector. The vector is a large class, it can store user data, which when copying can throw exceptions. Suppose we threw an exception. It will exit the current block, causing the destructors of all local variables, and will exit the block above. There, an exception will also cause the destructors of all local variables. It will reach the block where the variant was declared and cause the variant destructor.</font></font><br><br><pre> <code class="cpp hljs">variant&lt;T...&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> U&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (&amp;value == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } destroy(); <span class="hljs-comment"><span class="hljs-comment">// data-&gt;~Ti() construct_value(value); // throw; ... // ... // ~variant() { // data-&gt;~Ti() // Oops!!!</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The destructor of the variant looks at what is written to it in the variable index, which has not yet been updated. It contains std :: string, i.e. variant thinks that it has a string to be deleted. But in fact, there is nothing at this place, the line has already been deleted. At this point </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, your entire program will crash</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To avoid this, it is enough to open the interface of the standard library and see that std :: variant has the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valueless_by_exception</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, wonder what it is, and see why it is needed. You can open the source Boost - there 2/3 of the code is devoted to this problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I say this all so that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you and all your subordinates watch how other people have bikes written</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in order to avoid such sad consequences. </font><font style="vertical-align: inherit;">This is a very popular mistake. </font><font style="vertical-align: inherit;">She slips everywhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I give an example of a variant only, but in many other classes there is a similar one. </font><font style="vertical-align: inherit;">People rewrite, think that something is superfluous, do not look into someone else's code, and this leads to disastrous consequences.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please look at the code that you are rewriting or inventing </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">again. </font><font style="vertical-align: inherit;">This approach will greatly simplify your life.</font></font><br></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FORCE_INLINE </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's time to jump on sick corns. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can find projects where all methods are labeled as FORCE_INLINE - literally the entire project up and down in gigabytes of code. </font><font style="vertical-align: inherit;">You ask people:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Why are you all tagged FORCE_INLINE? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- We wrote a small benchmark, checked - with FORCE_INLINE faster. </font><font style="vertical-align: inherit;">We wrote and here is a small benchmark - checked, with FORCE_INLINE faster. </font><font style="vertical-align: inherit;">We tested everything with small benchmarks and everywhere faster with FORCE_INLINE - we pushed FORCE_INLINE into the whole project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- You did the wrong benchmark.</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And from this point on, it is very difficult to argue with people, because they have a benchmark, and you cannot write such a benchmark. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The processor is not only the data cache </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modern processors are very complex devices. </font><font style="vertical-align: inherit;">Nobody knows until the end how they work, even the developers of processors.</font></font><br><br><blockquote> "            :       ,             (TLB)     ()   ,   ,    " [ <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B5%25D1%2588_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580%25D0%25B0">1</a> ]. <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A modern processor cannot run your program directly from disk or straight from RAM. Before he starts executing the program, he must pull it up in the instruction cache. Only from there the processor can execute instructions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some processors have a cunning instruction cache, which makes additional processing of commands that fall into it. But the instruction cache is small, there is not enough code in it. If you use a compiler that </font><font style="vertical-align: inherit;">FORCE_INLINE </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does, when you ask him to do FORCE_INLINE, your binary code increases.</font></font><br><br><img src="https://habrastorage.org/webt/wq/ni/6p/wqni6pba3cvupf91wlfxzn0zzme.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine that in the picture above your program. </font><font style="vertical-align: inherit;">Green indicates what fit into the cache. </font><font style="vertical-align: inherit;">This is additionally your hot path - the place where your program spends most of its time. </font><font style="vertical-align: inherit;">Now it all fits into the processor‚Äôs cache, there will be no idle time in the instruction cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you add FORCE_INLINE, on benchmarks everything will be fine, but the code will no longer fit into the instruction cache. </font></font><br><br><img src="https://habrastorage.org/webt/dv/ow/x4/dvowx4i4vrcwuwnr9p2myo6ubbi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you get to the red line, the processor will say: "I do not have new instructions, I have to wait for them to catch up with the memory." </font><font style="vertical-align: inherit;">If it is somewhere in the loop, it will constantly flip through some instructions, pull them from memory to cache. </font><font style="vertical-align: inherit;">It is slow. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for your benchmark to correctly reflect the real state of affairs, it must take into account all 3 caches - data, instructions and addresses.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To do this, the benchmark should:</font></font><br><br><ul><li>      ,   production ; </li><li>        ,   production ; </li><li>    ,   production . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In other words, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is impossible to write such a benchmark</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . You can test only your production code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have added FORCE_INLINE and your production code has not become better - it is better to remove FORCE_INLINE. Modern compilers can inline. 10 years ago, they did not know how to do this well, and FORCE_INLINE really did help in some cases, for example, with GCC. Not now. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I say that FORCE_INLINE is bad, it is worth giving it up in most cases, although it can sometimes be useful. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, compiler developers are smart people. They see that users write FORCE_INLINE everywhere and programs get slower. Therefore, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modern compilers have different heuristics to ignore FORCE_INLINE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Some compilers simply count the lines inside the function - if your function is longer than three lines of code, FORCE_INLINE will be ignored. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a legend that there is a compiler, where people are very concerned about FORCE_INLINE, he got them so hard that they came up with the following heuristics:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the user marks the FORCE_INLINE function, which is guaranteed not to be done by FORCE_INLINE, the compiler remembers and considers how many times this has happened. </font><font style="vertical-align: inherit;">If a certain threshold value is exceeded, the compiler in itself puts a tick: ‚ÄúThe user does not know what FORCE_INLINE is and does not use it where it is necessary to ignore all FORCE_INLINE from the user‚Äù.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you suddenly wrote a program, added a dozen FORCE_INLINE there and everything became remarkably faster, it is possible that you use this compiler. </font><font style="vertical-align: inherit;">See the assembler code if you really need something to be embedded so that FORCE_INLINE really is in this place. </font><font style="vertical-align: inherit;">I myself was surprised that in some cases compilers silently ignore FORCE_INLINE. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conversely, the compiler can silently ignore your "not inline". </font><font style="vertical-align: inherit;">He will think: ‚ÄúYou don‚Äôt know what you‚Äôre doing, wrote not inline, but I know better - I‚Äôm in line‚Äù.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Case from practice </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know a very smart programmer who wrote the implementation of B-Tree. Everything was done in C ++, on templates, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perfect forwarding</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> everywhere </font><font style="vertical-align: inherit;">, without any dynamic allocation - just perfect. When this code was checked on one of the Performance Analyze, it turned out that execution was not fast enough because </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it took most of the time to wait for instructions</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the instruction cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The programmer thought, slightly simplified B-tree, removed perfect forwarding, replaced it everywhere with constant links, because B-tree did not change the data that came to him, removed a couple of templates, made the code a little more compact, added noexcept, which also reduces the volume binary code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, the code began to work </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 times faster.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The algorithm was not changed - everything is the same, but the code began to work faster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you do not believe me that FORCE_INLINE is bad, then I recommend watching the lectures ( </font></font><a href="https://youtu.be/FnGCDLhaxKU"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://youtu.be/nXaxk27zwlk"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of the Clang developer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chandler Karrut</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">He says the same thing as me, but in short, faster and in English. </font></font><br><br><img src="https://habrastorage.org/webt/vv/ze/xd/vvzexdaf7irdtpyu24nao2axboo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From ‚Äúharmful‚Äù benchmarks, we turn to ‚Äúharmful‚Äù advice.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aliasing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rarely, when development goes under one platform. </font><font style="vertical-align: inherit;">More often it happens that once upon a time they developed for one platform, and now for several. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, if a company starts as a small startup, it can choose one platform for itself, for which it already has customers. </font><font style="vertical-align: inherit;">Gradually, the company grows, the code becomes more popular, and the thought comes to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">port it to other platforms</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But at the moment when people start porting to GCC, the program stops working: everything compiles, but tests do not pass, the program gives some inadequate output. </font><font style="vertical-align: inherit;">People climb Stack Overflow or other programming resources ask this question and get an answer:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Add the magic compiler option </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-fno-strict-aliasing</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and everything will work for you.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And really - everything starts to work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me explain with an example what this option does (I did not bother with the function name here).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">bar </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qwe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foo&amp; f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bar&amp; b)</span></span></span><span class="hljs-function"> </span></span>{ f += b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b * b; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The qwe function takes two variables: foo by reference, bar by constant reference. </font><font style="vertical-align: inherit;">These are two different types of data. </font><font style="vertical-align: inherit;">Inside the body of the function, the value b is added to f and the square from b is displayed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a slightly assembler pseudocode that compiles the compiler if you slip the -fno-strict-aliasing option.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">bar </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qwe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foo&amp; f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bar&amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// load b // load f f += b; // load b return b * b; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compiler: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loads into the register the value of the variable b, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loads into the register the value of the variable f, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will perform the operation f + = b, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> write the value of f to memory </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will load the value of b again into memory, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">executes b </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, most people wonder why we loaded b a second time into the register, which is already in the register. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because they added the option -fno-strict-aliasing. It tells the compiler that two types of data, absolutely different, not intersecting with each other, can still </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be in the same memory cell</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Based on this, the compiler starts generating code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you do f + = b, the compiler thinks that perhaps f and b are in the same memory location, and writing to f changes the value of b. And this is in the whole of your project - an option was added, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the whole project the code began to be generated worse</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to different measurements (for example, </font></font><a href="http://docs.lib.purdue.edu/cgi/viewcontent.cgi%3Farticle%3D1124%26context%3Decetr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://habrahabr.ru/post/114117/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), depending on the code and optimization, it gives </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from 5% to 30% of performance drawdown</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It all depends on your code. If you just have system calls and networking, perhaps nothing will change for you with -fno-strict-aliasing. But just writing it when building your project is not entirely correct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is more correct </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to enable the compiler warning</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (GCC can warn when strict-aliasing is violated) and fix the strict-aliasing violation at this place. Typically, this violation occurs when you use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reinterpret_cast</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for two types that are not related to each other.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of reinterpret_cast it is better to use memcopy or memmove. </font><font style="vertical-align: inherit;">GCC compilers can optimize them. </font><font style="vertical-align: inherit;">The performance drawdown in the place where you make memcpy instead of reinterpret_cast should not be. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From fierce theory, we turn to tips that can be used in everyday practice.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daily tips </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Most likely, you know all this, and, most likely, do not use it. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example # 1, vector </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is an example of the function foo, in which a vector is created from shared_ptr. </font><font style="vertical-align: inherit;">We know shared_ptr is exactly a thousand. </font><font style="vertical-align: inherit;">They are inserted into the vector, and it returns.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; res; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; ++i) res.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first drawback: if we know how many elements our vector will hold, it is worth calling </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">res. reserve (1000)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This will </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preallocate the required amount of memory</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the vector, when inserted into it, will not try to guess how much memory is needed. Without reserve in C ++ 11, the vector will first take a value under 2 elements, then under 4 elements, 8, 16, etc. All this time, when resizing, it will call new, delete, copy or move your data type, which is slow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you call res. reserve (1000), then the vector knows for sure that it is 1000 elements, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there will be no additional move, new, delete</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with C ++ 14 compilers are allowed to optimize calls to new</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Some compilers can do this, but they should be lucky - not in all cases it works. </font><font style="vertical-align: inherit;">If you want to be sure that the compiler will generate the optimal code, it is better to insert a reserve - it will not be worse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The compiler will not be able to optimize another problematic place in this example. </font><font style="vertical-align: inherit;">This is a call to std :: shared_ptr &lt;int&gt;. </font><font style="vertical-align: inherit;">In this line there are two dynamic allocations:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first is a new int. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second is hidden inside the shared_ptr constructor. </font><font style="vertical-align: inherit;">He needs a reference counter, which he dynamically allocates somewhere on the heap.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in memory they are in different places. </font><font style="vertical-align: inherit;">If your application does not use weak pointers, or does not use them much, instead of std :: shared_ptr &lt;int&gt; (new int), it makes sense to write </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: make_shared &lt;int&gt; ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make_shared immediately allocates a chunk of memory where it can store both an int and a reference count. </font><font style="vertical-align: inherit;">Due to the fact that these two variables will be next, it is more cash-friendly. </font><font style="vertical-align: inherit;">Working with shared_ptr will be a little faster, there will be not two, but one dynamic allocation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we accelerated the code in the first example a little more than twice, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simply by adding reserve and replacing the constructor shared_ptr with make_shared</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example # 2, for (auto v: data) </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; data = get_data(); <span class="hljs-comment"><span class="hljs-comment">// ... for (auto v: data) res. insert( v ); return res; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code in the example above is terrible. Let's improve it gradually, and, most likely, not from the place that you noticed. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a copy of an element from a vector. Outside the loop, and after iterations of the loop, we don‚Äôt need it. We can tell the compiler that the variable v is no longer in use, replacing v with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move (v)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , turning it into an rvalue, and then inserting it into the resulting res container will occur via the rvalue reference. The resources from v will simply be thrown inside the container, which is faster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vector data array is no longer used; everything that it contains will be destroyed when the function exits. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of copying v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can write for (auto </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v: data), i.e. make a link to v (&amp;&amp; - here it is also a link). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result is the following: v - the link to the element inside the data. </font><font style="vertical-align: inherit;">When we apply std :: move to this link, the resource will be taken from the data vector - the string will be dragged directly from the vector directly from the vector. </font><font style="vertical-align: inherit;">There will be no dynamic allocations in the end. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compared to the original code, it became 100,500 times faster</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example # 3, vector </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; data = get_data(); <span class="hljs-comment"><span class="hljs-comment">// ... std::string res = data.back(); data.pop_back(); // ... return res; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The situation, as in the example above, occurs more often - the same, but from the vector we memorize the last element, and then we retrieve this last element. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also optimize: we say std :: string res = </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move (</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data. Back () </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">After that in res is the value of the last element (we dragged the resources from the vector into the variable res). </font><font style="vertical-align: inherit;">Now back inside the vector is an empty string, data.pop_back () will simply change one of the internal variables of the vector. </font><font style="vertical-align: inherit;">No dynamic allocations, no delete calls - all faster.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example # 4 global constants </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsers and protocols often have arrays of previously known strings. </font><font style="vertical-align: inherit;">People often write them like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;string&gt; static const std::vector&lt;std::string&gt; CONSTANTS = { "Hello", "Word", "!" };</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems that this is only a little not optimal, but, in principle, not so scary. This will happen once when you start your program or when loading a DLL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But when a project is very large, a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">large number of such pieces of code can accumulate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><strong><font style="vertical-align: inherit;">different parts of it</font></strong><font style="vertical-align: inherit;"> - 10, 100, 1000. The initialization of the CONSTANTS variable occurs when the program is started or when the dynamic library is loaded. At this moment, this single-threaded code will call new, allocate, initialize the vector of lines, and this can slow down the start of your program or load the dynamic library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those who write realtime applications and applications that need to restart quickly, if they have fallen, this can be critical. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have thousands and millions of such objects, it will slow the start of the program.</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need an array of constants, and you refer to it only by index or use it only in range-based for, you can replace the vector with a regular array. </font><font style="vertical-align: inherit;">That is, instead of std :: vector &lt;std :: string&gt; CONSTANTS, you can write </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: string_view</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONSTANTS </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start of your application will not do additional operations</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , call new, additionally fragment the memory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need a strong guarantee that this will be fulfilled even before your program starts, you can </font></font><code>static const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">replace it with </font></font><strong><code>constexpr</code></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will oblige your compiler to execute this piece of code before runtime.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example # 5 Inheritance </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// base. hpp struct base { // ... virtual void act() = 0; virtual ~base(){} };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above the base base class, in it the act method is nothing interesting. </font><font style="vertical-align: inherit;">It is interesting when we inherit from this base. </font><font style="vertical-align: inherit;">Imagine that you are a developer in a company and you were told to figure out someone else‚Äôs code, and you see only what goes below.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// something. cpp struct some_implementation: base { // ... void act() { /* ... */ } };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You only see this, you have not looked into the base description yet and you are wondering what the act method is, whether it is declared in the base class, whether we are overloading it, and in general what is happening here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can make the code more readable by simply adding the word </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">override</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// something. cpp struct some_implementation: base { // ... void act() override { /* ... */ } // &lt;====== };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be not only more readable, but also </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more secure</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When a new person reads your code, he sees override and thinks: ‚ÄúAha, so this method is declared in the base class, we are overloading it, everything is in order‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A new person will come and refactor the base class, change the signature of the act method there, add an integer there and at the compilation stage catch the error that in the heir class we are trying to rotate a class that is not already declared in the base class, which is not present. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will not break your code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Without override, everything will compile, it will somehow work, but there will be an error at runtime. It can take a lot of time to catch it. Override will break on compiletime. The person who will do refactoring will notice and correct the act method here.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also add </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the first line: </font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">some_implementation </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : base. This means that this class is final, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no one else inherits from it</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We are not very hot about this and not very cold, but this makes the compiler more fun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The compiler sees that the class is final. When he sees some_implementation and a variable of this class, and act is called on this variable, the compiler understands that nobody else inherits from this class, and there is an act in it. It will call act </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without passing through virtual tables</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , there will be no different dynamic things ‚Äî it will call act, as if it were not virtual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can still slightly improve by stuffing everything into an anonymous namespace:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// something. cpp namespace { // &lt;====== struct some_implementation final: base { // ... void act() override { /* ... */ } }; } // anonymous namespace&lt;/strong&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An anonymous namespace is sort of static on steroids. You can declare a variable or function as static, then it will not be visible outside. Anything you declare inside the anonymous namespace will only be visible in this translation unit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is good because it </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unleashes the optimizer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It can do more optimizations based on the fact that no one else uses this class from the outside. The optimizer might also think that since no one uses this class from the outside, it does not need to be exported, which </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will increase the speed of loading and linking the application at runtime</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, in OpenOffice there was a problem that the stage of dynamic loading of libraries and the linker, which connected all the dependencies to each other, took 10 seconds, because a lot of characters stuck out. </font><font style="vertical-align: inherit;">If you use an anonymous namespace, this problem will become smaller.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Example # 5, move constructors </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below are the move constructors for the class my_data_struct. </font><font style="vertical-align: inherit;">It only has the data vector.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_data_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... my_data_struct(my_data_struct&amp;&amp; other) :data_(other.data_) {} };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forgot. </font><font style="vertical-align: inherit;">And </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noexcept</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Let's rewrite:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_data_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... my_data_struct(my_data_struct&amp;&amp; other) noexcept // &lt;====== :data_(std::move(other.data_)) {} };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A number of standard containers, such as vector, do complex compile-time calculations based on whether the move constructors are marked as noexcept or not. </font><font style="vertical-align: inherit;">If your move constructors are not marked as noexcept, the vector can additionally allocate memory when it expands and copy the elements instead of moving them. </font><font style="vertical-align: inherit;">This is a disgrace, because it is very slow. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To make it faster, add noexcept. </font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This post does not like most people. </font><font style="vertical-align: inherit;">Here it is not clear what is written and you need to know:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> how does std :: vector; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if he throws exception when moving; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> whether he will throw an exception if there is an unusual allocator there; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> whether this move constructor can be marked with noexcept; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Whether it is necessary to mark it noexcept. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bunch of some parts that we do not need. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All you need to do is write here and all this will become the concern of the compiler:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_data_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... my_data_struct(my_data_struct&amp;&amp; ) = default; // &lt;====== };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compiler will arrange itself noexcept, constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , if it can. </font><font style="vertical-align: inherit;">The code from the standard library will work faster - it's easier for you.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caching divs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I want to talk about one thing that I recently came across, and which surprised me. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// .h extern const double fractions[256]; // .cpp const double fractions[256] = { 1.0 / i, ... };</span></span></code> </pre><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">People cached division of units by number</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">They created an extern array of 256 elements, in which they remembered:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first number is 1/0 (they made 0). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the second number at index 1 is 1/1. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the number at index 100 is 1/100, and so on. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further work with this array wherever part of 1 is needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you think it </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be faster or slower?</font></font></strong>  Let's find out. <br><br><img src="https://habrastorage.org/webt/bj/kg/bk/bjkgbk4membnpcf0g4i32vgfy4e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We climb into the Talmuds, where it is described how many clock cycles the instructions take, and we find that access to the element of the array, which is located in the L1 cache, takes 5 cycles, and the division is 22-29 cycles. </font><font style="vertical-align: inherit;">In total, such caching can be 2-4 times faster, but ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disadvantages of cashing divs: </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. The optimizer does not see the value.</font></font></strong> <br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no way to optimize the nearest instructions</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The array is declared in another translation unit. </font><font style="vertical-align: inherit;">If you do not have Link-time optimization, or the link-time-optimizer is not advanced enough, it will not see the values ‚Äã‚Äãand will not be able to optimize based on the values. </font><font style="vertical-align: inherit;">If you have an appeal to 1/100, and then multiplication by 100, then, if the optimizer saw the value, it would immediately turn out 1 (plus or minus). </font><font style="vertical-align: inherit;">But if the optimizer does not see the value, it will not be able to optimize it and multiplication by 100 will remain.</font></font><br></li><li> <strong>      constexpr </strong> , . </li><li>   ‚Äî aliasing. <strong>  double       </strong> ,     -fno-strict-aliasing    double         . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a serious negative impact on performance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, the compiler will not even believe you if you write const everywhere, because it does not optimize based on const. </font><font style="vertical-align: inherit;">If you wrote const somewhere, the compiler will ignore it, because somewhere else you could write const_cast. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. We spent a lot of time discussing this ...</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The fact that we spent a lot of time discussing it is also bad in this example. </font><font style="vertical-align: inherit;">When you see it in someone else's code, you will also spend a lot of time to figure out what a mess this is. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. We spent 1Kb L1 cache of 16 / 32Kb</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> People who develop compilers, write books on this topic and protect complex theories, say that in the modern world, system performance is not limited by processor speed, but often by working with memory: </font></font><br><br><blockquote> ¬´  ,         ,           ¬ª. <br><br> <sup><em>, , . . , , . 2ed.2008</em></sup> <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We spent 1Kb cache of the 1st level to save the array, and other useful data will not fit there now. </font><strong><font style="vertical-align: inherit;">Ulrich Drepper,</font></strong></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> developer of the standard C library for Linux, </font><font style="vertical-align: inherit;">wrote ‚ÄúWhat Every Programmer Should Know About Memory‚Äù, that is, about what every programmer should know about memory. </font><font style="vertical-align: inherit;">It contains serious theory and physics, but there is a wonderful simple example of the importance of cache. </font><font style="vertical-align: inherit;">On a piece of code with matrix multiplication, practically without changing the algorithm and assembler instructions, Ulrich Drepper </font><em><font style="vertical-align: inherit;">accelerated productivity 10 times simply due to more efficient work with the data cache</font></em><font style="vertical-align: inherit;"> .</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data cache is very important. </font><font style="vertical-align: inherit;">Do not write there what you rarely </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Whether it becomes faster with such caching of units or not is not clear: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you have a critical piece of memory, where you often do these operations, where they cannot be especially optimized - yes, it can become better. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have a generalized code where you work a lot with other data, and this is one single calculation - you are spending extra cache. </font><font style="vertical-align: inherit;">Most likely it will get worse.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But people wrote a lot of code, and we spent a lot of time analyzing it. </font><font style="vertical-align: inherit;">When you meet him in someone else's production code, you also spend a lot of time analyzing, your productivity will fall. </font><font style="vertical-align: inherit;">The employer will be unhappy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have already talked about the "harmful", let's move on to the good.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perfect bike </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to write your perfect bike, your perfect program, I will not tell you. </font><font style="vertical-align: inherit;">There are a lot of books for this, some of them are correct, some are not. </font><font style="vertical-align: inherit;">But, if you wrote a program, a library that:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cross-platform; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fast; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> useful; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functional </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> useful to a lot of people </font></font></li></ol><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welcome to the working group </font></font><a href="https://stdcpp.ru/proposals"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WG21</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we:</font></font></strong> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will help with the formalities. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's help with acceptance in Boost. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's help with writing the proposal. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will protect your interests at an international meeting at ISO, we will give feedback on your proposal. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the first time, to make a proposal is not easy, because there are special terms that must beware, and certain formalities that must be observed. </font><font style="vertical-align: inherit;">If you just write a proposal and send it to the Committee, most likely nothing will happen next unless you (or a trusted person) arrive at the Committee and do not defend your idea before an international meeting. </font><font style="vertical-align: inherit;">Many offers come in, and first of all, priority is given to those who are personally represented and protected.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Design Ideas WG21: </font></font></h2><br><ul><li> P0539R0: wide_int by  ,     int256, int512, int4000000; </li><li> P0275R1: Dynamic library load; </li><li> ConcurrentHashMap by  ,   ‚Äî    ; </li><li> Constexpr: ¬´D0202R2: Constexpr algorithm¬ª, std::array ‚Äî  ,   ; </li><li>        (?dlsym?); </li><li> Stacktrace   ,      Stacktrace,        Stacktrace, ,    ,    . </li><li>  ,     ISO WG21 ‚Äî     ,      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visit the website of the working group </font></font><a href="https://stdcpp.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://stdcpp.ru/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where you can offer your idea, see what others offer, and we will discuss the most interesting proposals together. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can learn about Anton‚Äôs other reports, see his presentations, publications, and lots of other useful information here - </font></font><a href="http://apolukhin.github.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://apolukhin.github.io/</font></font></a> <br><br><blockquote>   ‚Äî        <a href="http://cpp-russia.ru/">C++ Russia</a> 2017,            19  21 . <br><br>       Jon Kalb,   25-  <br>        Amazon, Microsoft, Netscape, <br> Yahoo   . Jon ‚Äî   CppCon.   <br> C++ Today: The Beast is Back. <br><br>           - ( <a href="http://ritfest.ru/">++</a> ),  <strong>9 </strong>    <a href="http://speakers.ritfest.ru/"> </a>  ,     . ,  <strong>     </strong> ,         . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/352280/">https://habr.com/ru/post/352280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352270/index.html">How to track file downloads from your site on WordPress</a></li>
<li><a href="../352272/index.html">Thymeleaf Tutorial: Chapter 13. Template text modes</a></li>
<li><a href="../352274/index.html">Critical vulnerability in Drupal core versions 6, 7 and 8</a></li>
<li><a href="../352276/index.html">Time-to-Digital (TDC) converters: what it is and how they are implemented in FPGA</a></li>
<li><a href="../352278/index.html">IT Event Digest for April</a></li>
<li><a href="../352282/index.html">Continuous Integration for Newbies</a></li>
<li><a href="../352292/index.html">Hitachi: how the Japanese sunk from chainsaws to modern storage systems</a></li>
<li><a href="../352294/index.html">How to create an ideal product roadmap and what is needed for this?</a></li>
<li><a href="../352296/index.html">A simple asynchronous task manager for Unity3D</a></li>
<li><a href="../352298/index.html">From idea to AppStore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>