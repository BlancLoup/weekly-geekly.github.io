<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Akka, actors and reactive programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear readers. 

 Today we wanted to talk to you on the topic ‚Äúeverything new is well forgotten old‚Äù and recall the actors described by Karl Hew...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Akka, actors and reactive programming</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear readers. <br><br>  Today we wanted to talk to you on the topic ‚Äúeverything new is well forgotten old‚Äù and recall the actors described by Karl Hewitt in the early 70s.  And the thing is that recently this <a href="http://www.amazon.com/Reactive-Messaging-Patterns-Actor-Model/dp/0133846830/">book</a> came out: <br><br><img src="https://habrastorage.org/files/b97/4c4/b89/b974c4b898c2485ca7bb6e08caf7a30f.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is quite voluminous - the translation should make more than 500 pages. <br><br>  Despite the underlined elitism of the book (Akka and Scala), its author Von Vernon (the largest DDD specialist) is confident that the architectural patterns described in this work are fully realizable on .NET and C #, which is described in the application.  We also place a translation of the article under the cut, the author of which allows the transfer of the actor paradigm to the Java language.  Since the book's rating on Amazon is consistently high, and the topic is universal, please share your views on both it and actor architecture in principle. <br><a name="habracut"></a><br>  The <a href="https://blog.codecentric.de/en/2015/07/a-map-of-akka/">first article</a> in this series made an overview of <a href="http://akka.io/">Akka</a> .  Now we will delve deeper into the scope of Akka actors, armed with the akka-actor module, which lays the foundation for all the other Akka modules. <br><br>  In our opinion, one can learn how to program without even having the practice of reading / writing code.  Here we will step by step develop a small actor library: a pubSub event bus operating on a ‚Äúpublish-subscribe‚Äù principle.  Of course, Akka comes with a ready-to-work local and global solution of this kind, so here we just tinker with a well-known example.  We will work in the <a href="http://scala-lang.org/">Scala</a> language, simply because it is much more convenient to write Akka-like code on it, but exactly the same results can be achieved in Java. <br><br>  <b>Actor model</b> <br><br>  In the actor model ‚Äî which was invented in 1973 by Karl Hewitt and others ‚Äî the actors are ‚Äúfundamental units of computation that implement processing, storage, and communication.‚Äù  Ok, let's get this in order. <br><br>  The concept of ‚Äúfundamental unit of computation‚Äù means that when we write a program in accordance with the actor model, our design and implementation work is built around actors.  In a <a href="https://channel9.msdn.com/Shows/Going%2BDeep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask">terrific interview</a> given to Eric Meyer, Karl Hewitt explains that "actors are everywhere" and also that "there are no single actors, they exist in systems."  We have already summarized this thought: when using the actor model, all our code will consist of actors. <br><br>  What does an actor look like?  What is, finally, ‚Äúprocessing‚Äù, ‚Äústorage‚Äù and ‚Äúcommunication‚Äù?  In essence, communication is <b>asynchronous messaging</b> , storing means that actors can have a <b>state</b> , and processing means that actors can deal with messages.  Processing is also referred to as <b>"behavior</b> . <b>"</b>  It doesn't sound too hard, right?  So let's take the next step and look at the Akka actors. <br><br>  <b>Akka actor device</b> <br><br>  As is clear from the following picture, the Akka actor consists of several interacting components.  <i>ActorRef</i> is the logical address of the actor, allowing you to send messages to the actor asynchronously according to the ‚Äúsend and forget‚Äù principle.  The dispatcher ‚Äî in this case, by default, one dispatcher is assigned to each actor‚Äôs system ‚Äî is responsible for putting messages into the queue leading to the actor‚Äôs mailbox, and also orders that mailbox to remove one or more messages from the queue, but only one at a time and transfer them to the actor for processing.  Last but not least, an actor ‚Äî usually the only API that we have to implement ‚Äî encapsulates state and behavior. <br><br><img src="https://habrastorage.org/files/0eb/6f4/180/0eb6f4180c304eef8e363d2f8d86bc2f.png"><br><br>  As will be shown below, Akka does not allow direct access to the actor and therefore ensures that the only way to interact with the actor is asynchronous messages.  Cannot call method in actor. <br>  In addition, it should be noted that sending a message to an actor and processing this message by an actor are two separate operations that most likely occur in different threads.  Of course, Akka provides the necessary synchronization to ensure that any state changes are visible to all threads. <br><br>  Accordingly, Akka, as it permits, allows us to program the illusion of single-threadedness, and we can not use any synchronization primitives like <i>volatile</i> or <i>synchronized</i> in the actor code - moreover, one should not do this. <br><br>  <b>Actor implementation</b> <br><br>  Quite a word, go to the code!  In Akka, an actor is a class to which the Actor type is mixed: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ override def receive = ??? }</code> </pre> <br>  The receive method returns the so-called initial behavior of the actor.  It is simply a partially computable function used by Akka to process messages sent to the actor.  Since the behavior is equal to <i>PartialFunction [Any, Unit]</i> , it is currently not possible to define such actors who accept messages of only a given type.  Akka already has an experimental <i>aka-typed</i> module that provides type safety on this platform, but it is still being finalized.  By the way, the behavior of the actor can change, which is why the return value of the receive method is called in the original behavior. <br><br>  Ok, let's implement the basic actor for our PubSub library: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubSubMediator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ override def receive = Actor.emptyBehavior }</code> </pre><br>  So far, we do not need PubSubMediator to process any messages, so we use the usual partially computable function Actor.emptyBehavior, for which no value is defined. <br><br>  <b>Actor systems and actor creation</b> <br><br>  As mentioned above, ‚Äúthere are no single actors, they exist in systems‚Äù.  In Akka, the system of actors is an interrelated ensemble, whose members are organized hierarchically.  Thus, each actor has its own parent actor, as shown in the following picture. <br><br><img src="https://habrastorage.org/files/e00/fbe/a32/e00fbea32af4450b9278a4f3dd1a8ce4.png"><br><br>  When creating an actor system, Akka - internally using many so-called "system actors" - creates three actors: this is the "root guardian", located at the root of the actor's hierarchy, and the system and user guards.  The user guard - often simply referred to as ‚Äúguard‚Äù - is the parent element for all the top-level actors we create (in this context, we mean the ‚Äúhighest level to which we have access‚Äù). <br><br>  Suppose, but how to create a system of actors?  You just need to call the factory method provided by the lone <i>ActorSystem object</i> : <br><br><pre> <code class="java hljs">val system = ActorSystem(<span class="hljs-string"><span class="hljs-string">"pub-sub-mediator-spec-system"</span></span>)</code> </pre><br>  And why do we even create <i>ActorSystem</i> ?  Why not just create actors?  The latter is impossible, because when you call the actor constructor directly, the system will throw an exception.  Instead, we have to use the factory method provided ‚Äî you guessed it ‚Äî with the <i>ActorSystem</i> to create the top-level actor: <br><br><pre> <code class="java hljs">system.actorOf(Props(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSubMediator), <span class="hljs-string"><span class="hljs-string">"pub-sub-mediator"</span></span>)</code> </pre><br>  Of course, <i>actorOf</i> does not return an Actor instance, but <i>ActorRef</i> .  So Akka does not allow us to gain access to an Actor instance, which, in turn, guarantees: the exchange of information with the actor is possible only through asynchronous messages.  The name we specify must be unique among the siblings of this actor, otherwise an exception will be thrown.  If we do not specify a name, Akka will create it for us, since each actor must have a name. <br><br>  And what kind of thing <i>Props</i> ?  This is just a configuration object for the actor.  It accepts a constructor as a parameter passed by name (that is, lazily) and may contain other important information ‚Äî for example, about routing or deployment. <br><br>  When it comes to remote communication, it is important to <i>bear in</i> mind that <i>Props</i> can be serialized, so it‚Äôs already a practice to add a <i>Props</i> factory to the actor‚Äôs companion object.  It is also convenient to set a constant corresponding to the name of the actor. <br><br>  Knowing all this, let's add PubSubMediator and also create a test for it with <a href="http://scalatest.org/">ScalaTest</a> and Akka Testkit, another Akka module that simplifies testing Akka actors: <br><br><pre> <code class="java hljs">object PubSubMediator { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> val Name = <span class="hljs-string"><span class="hljs-string">"pub-sub-mediator"</span></span> def props: Props = Props(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSubMediator) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubSubMediator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ override def receive = Actor.emptyBehavior } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubSubMediatorSpec</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordSpec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matchers</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeAndAfterAll</span></span></span><span class="hljs-class"> </span></span>{ implicit val system = ActorSystem(<span class="hljs-string"><span class="hljs-string">"pub-sub-mediator-spec-system"</span></span>) <span class="hljs-string"><span class="hljs-string">"A PubSubMediator"</span></span> should { <span class="hljs-string"><span class="hljs-string">"be suited for getting started"</span></span> in { EventFilter.debug(occurrences = <span class="hljs-number"><span class="hljs-number">1</span></span>, pattern = s<span class="hljs-string"><span class="hljs-string">"started.*${classOf[PubSubMediator].getName}"</span></span>).intercept { system.actorOf(PubSubMediator.props) } } } <span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= { Await.ready(system.terminate(), Duration.Inf) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.afterAll() } }</code> </pre><br>  As you can see, we create the <i>ActorSystem</i> and the <i>PubSubMediator</i> actor in the <i>PubSubMediatorSpec</i> .  The test itself is a bit contrived, because our <i>PubSubMediator</i> is still quite raw.  It uses life cycle debugging and expects logging of a debugging message of the <i>‚Äústarted ... PubSubMediator ...‚Äù type</i> .  The full code of its current version is located at GitHub under the label <a href="https://github.com/hseeberger/pubsub/releases/tag/step-01">step-01</a> . <br><br>  <b>Communication</b> <br><br>  So, having learned to create actors, let's talk about communication, which - as mentioned above - is based on asynchronous messages and is closely related to two other properties of the actor: behavior (that is, the ability to process messages) and state. <br><br>  To send a message to an actor, you need to know his address, that is, <i>ActorRef</i> : <br><br><pre> <code class="java hljs">mediator ! GetSubscribers(<span class="hljs-string"><span class="hljs-string">"topic"</span></span>)</code> </pre><br>  As you can see, there is an operator in ActorRef <i>!</i>  - the so-called ‚Äúbang‚Äù, which sends a given message to the appropriate actor.  As soon as the message is delivered, the operation is completed, and the sending code continues.  It is understood that there is no return value (except for <i>Unit</i> ), therefore, messages really go off on the principle of "sent and forgotten." <br><br>  Let it be simple, we often need a response.  Due to the fact that the operator <i>!</i>  implicitly accepts the sender as <i>ActorRef</i> , it can be done without difficulty: <br><br><pre> <code class="java hljs">override def receive = { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic)</span></span></span><span class="hljs-function"> </span></span>=&gt; <span class="hljs-comment"><span class="hljs-comment">//     sender() ! Subscribed }</span></span></code> </pre><br>  In this example, the behavior of the recipient actor processes a specific message ‚Äî the <i>Subscribe</i> command ‚Äî and sends the message ‚Äî the <i>Subscribed</i> event ‚Äî back to the sender.  Then the sender method is used to access the sender of the message that is being processed. <br><br>  Given all this, let's further improve <i>PubSubMediator</i> and the corresponding test. <br>  First, <i>let's</i> add a message protocol ‚Äî the set of all messages related to <i>PubSubMediator</i> ‚Äî to the accompanying object: <br><br><pre> <code class="java hljs">object PubSubMediator { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Publish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic: String, message: Any)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Published</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(publish: Publish)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic: String, subscriber: ActorRef)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscribe: Subscribe)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlreadySubscribed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscribe: Subscribe)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic: String, subscriber: ActorRef)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsubscribe: Unsubscribe)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotSubscribed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unsubscribe: Unsubscribe)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic: String)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> val Name </span></span>= <span class="hljs-string"><span class="hljs-string">"pub-sub-mediator"</span></span> def props: Props = Props(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PubSubMediator) }</code> </pre><br>  Next, let's implement the behavior that has so far remained unfilled: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubSubMediator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PubSubMediator._ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscribers = Map.empty[String, Set[ActorRef]].withDefaultValue(Set.empty) override def receive = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> publish @ Publish(topic, message) =&gt; subscribers(topic).foreach(_ ! message) sender() ! Published(publish) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> subscribe @ Subscribe(topic, subscriber) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic)</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber)</span></span></span><span class="hljs-function"> </span></span>=&gt; sender() ! AlreadySubscribed(subscribe) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> subscribe @ Subscribe(topic, subscriber) =&gt; subscribers += topic -&gt; (subscribers(topic) + subscriber) sender() ! Subscribed(subscribe) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> unsubscribe @ Unsubscribe(topic, subscriber) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !subscribers(topic).contains(subscriber) =&gt; sender() ! NotSubscribed(unsubscribe) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> unsubscribe @ Unsubscribe(topic, subscriber) =&gt; subscribers += topic -&gt; (subscribers(topic) - subscriber) sender() ! Unsubscribed(unsubscribe) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(topic)</span></span></span><span class="hljs-function"> </span></span>=&gt; sender() ! subscribers(topic) } }</code> </pre><br>  As you can see, the behavior processes all commands ‚Äî for example, <i>Publish</i> or <i>Subscribe</i> ‚Äî and always sends an affirmative or negative response to the sender.  Whether a team is valid and giving a positive result ‚Äî for example, <i>Subscribed</i> ‚Äî depends both on the team and on the state represented as a private variable subscribers field. <br><br>  As mentioned above, only one message is processed at the same time, and Akka ensures that state changes remain visible when processing the next message, so you do not need to manually synchronize all access to subscribers.  Competitive without problems! <br><br>  Finally, let's look at a fragment of the extended test: <br><br><pre> <code class="java hljs">val subscribe01 = Subscribe(topic01, subscriber01.ref) mediator ! subscribe01 sender.expectMsg(Subscribed(subscribe01)) val subscribe02 = Subscribe(topic01, subscriber02.ref) mediator ! subscribe02 sender.expectMsg(Subscribed(subscribe02)) val subscribe03 = Subscribe(topic02, subscriber03.ref) mediator ! subscribe03 sender.expectMsg(Subscribed(subscribe03))</code> </pre><br>  As you can see, we send Subscribe messages to the intermediary with the help of the operator <i>!</i>  and expect to receive relevant feedback.  As above, the entire project code is currently located at GitHub under the label <a href="https://github.com/hseeberger/pubsub/releases/tag/step-02">step-02</a> . <br><br>  <b>Life cycle</b> <br><br>  So far, we have neglected one important aspect of the actors: their existence, of course - that is, they are completed, and the actor can be completed at any time. <br><br>  Having access to <i>ActorRef</i> , we do not know whether the corresponding actor is ‚Äúalive‚Äù.  In particular, we will not receive exceptions if we send messages to the completed actor.  In such a case, <i>ActorRef</i> remains valid, but Akka redirects, and for messages sent to dead mailboxes, non-guaranteed delivery is in effect.  Thus, these messages are logged, which is useful for testing, but this method is by no means suitable for implementing something like a retransmission or even guaranteed delivery. <br><br>  But sometimes we really need to know whether the actor is still alive or not.  In this case, we need the ability to get rid of completed subscribers, because otherwise <i>PubSubMediator</i> sends unnecessary messages and may even sooner or later use up all the memory. <br><br>  For all these reasons, Akka provides the ability to track the life cycle of actors.  Since we can only observe the completion of the actor, this mechanism is called ‚Äú <b>dead watch</b> ‚Äù (death watch).  To track the actor, we simply call the watch method provided by <i>ActorContext</i> , available in Actor via <i>context</i> : <br><br><pre> <code class="java hljs">context.watch(subscriber)</code> </pre><br>  Then Akka will send the message Terminated to the observing actor after the observing actor is completed.  This message is guaranteed to be the last received from the actor, even with a remote connection. <br><br>  Well, we finish <i>PubSubMediator</i> : <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubSubMediator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PubSubMediator._ ... override def receive = { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> subscribe @ Subscribe(topic, subscriber) =&gt; subscribers += topic -&gt; (subscribers(topic) + subscriber) context.watch(subscriber) sender() ! Subscribed(subscribe) ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Terminated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subscriber)</span></span></span><span class="hljs-function"> </span></span>=&gt; subscribers = subscribers.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (topic, ss) =&gt; topic -&gt; (ss - subscriber) } } }</code> </pre><br>  As you can see, we track all subscribers by processing the <i>Subscribe</i> valid command and deleting each completed subscriber when dealing with the corresponding <i>Terminated</i> message.  Again, the complete actual code for this example is on GitHub under the label <a href="https://github.com/hseeberger/pubsub/releases/tag/step-03">step-03</a> . <br><br>  <b>Conclusion</b> <br><br>  This concludes a preliminary acquaintance with the actors Akka.  So, we looked at the most important aspects of the actor model - communication, behavior, and state, and also talked about the actor systems.  We also discussed the implementation of these concepts with the help of Akka and talked about the dead watch. <br><br>  Of course, I had to omit a lot of interesting and important material: the creation of subsidiary actors, tracking (supervision), etc.  We refer you to interesting additional resources, such as excellent <a href="http://akka.io/docs/">Akka documentation</a> . </div><p>Source: <a href="https://habr.com/ru/post/266103/">https://habr.com/ru/post/266103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266093/index.html">Healthcare IT: or how to exceed the budget by 420%</a></li>
<li><a href="../266095/index.html">How many downloads do you need for the TOP-10 free games of the App Store</a></li>
<li><a href="../266097/index.html">Script to calculate the space occupied by Hyper-V virtual machines</a></li>
<li><a href="../266099/index.html">Intel invites to Droidcon. Moscow, September 25-27</a></li>
<li><a href="../266101/index.html">Color Deconvolution at Wolfram Mathematica</a></li>
<li><a href="../266105/index.html">Autumn Rambler.iOS Meeting</a></li>
<li><a href="../266107/index.html">3CX API - what are they and what to do with them? Third Party Plugins (Part 2)</a></li>
<li><a href="../266109/index.html">GPS service ViaLatM - scripting language</a></li>
<li><a href="../266111/index.html">Large-scale migration of records in the database: how it does Stripe</a></li>
<li><a href="../266113/index.html">Vertical padding between columns using Sass using the bootstrap grid example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>