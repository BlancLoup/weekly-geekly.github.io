<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software Defined Radio by the hands of a sixteen year old</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDR, or software-defined radio system is a device for working with radio, which runs a mini-computer with special software. It replaces traditional ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software Defined Radio by the hands of a sixteen year old</h1><div class="post__text post__text-html js-mediator-article"><p>  SDR, or software-defined radio system is a device for working with radio, which runs a mini-computer with special software.  It replaces traditional hardware components: filters, amplifiers, modulators and de-modulators.  This allows you to create a radio that works with a variety of protocols.  Imagine a radio that, in addition to HitFM, can receive analogue and digital television, communicate via Wi-Fi, Bluetooth and GPS, as well as detect pulsar radiation. </p><br><blockquote>  Now imagine an <strong>American ninth-grader</strong> who decided to make such a radio line, ordered FPGA via the Internet, a radio module, made a six-layer board, and then assembled almost 300 components onto it with his own hands.  And after three revisions it all worked for him! <br><a name="habracut"></a><br></blockquote><br><h2 id="chto-takoe-sdr">  What is SDR </h2><br><p>  Who might need such a radiolab?  Radio amateurs who have evolved great!  Twenty years ago, an enthusiastic person bought a complex receiver and sat in headphones for hours, rotating frequencies in search of interesting signals.  In the modern world, radio broadcasts are full of information, but all of it is digital.  Listening to Wi-Fi packets with headphones is of no interest.  Today, the radio amateur finds interesting digital radio stations on the air, and then selects software that parses the transmission protocol and converts the information.  For example, you can receive data from telemetry of civil aviation - on the basis of this kind of information from many radio amateurs around the world, the site flightradar publishes data on aircraft. </p><br><p>  You can now see with your own eyes how Software Defined Radio works.  The University of Twente contains an exciting <a href="http://websdr.ewi.utwente.nl:8901/">online SDR receiver project</a> that immediately receives a 29MHz wide spectrum piece, after which radio amateurs can listen in parallel to various carriers of this range.  Catalog of similar radio projects compiled on the <a href="http://websdr.org/">site</a> </p><br><p>  A large role in the popularity of amateur SDR is played by the low cost of the minimum set of equipment.  Inexpensive TV tuners implemented on Software-Defined Radio were discovered, and <a href="http://hackaday.com/2012/03/20/software-defined-radio-from-a-usb-tv-capture-card/">instructions</a> appeared on the Internet on how to use such tuners to listen with their help not only the television signal.  A specialized kit <a href="https://world.taobao.com/item/36192184463.htm%3FfromSite%3Dmain%26spm%3D686.1000925.1000774.26.9C3XXu">on the Chinese market costs only $ 35,</a> but it comes disassembled (it‚Äôs necessary to be soldered and its charm lies) and only supports a range of 100KHz-1.7GHz.  Of course, the appetite comes with eating, and very soon a radio amateur begins to look towards equipment that can accept wide frequency ranges at high speed.  Let's look at what serious devices are now the most popular. </p><br><table><thead><tr><th>  Title </th><th>  Range </th><th>  Max.  channel width </th><th>  ADC Sample Rate </th><th>  Price </th></tr></thead><tbody><tr><td>  <a href="https://greatscottgadgets.com/hackrf/">hackRF One</a> </td><td>  1MHz - 6GHz </td><td>  20MHz </td><td>  20MSPS </td><td>  $ 299 </td></tr><tr><td>  <a href="https://www.nuand.com/blog/product/bladerf-x40/">bladeRF x40</a> </td><td>  300MHz - 3.8GHz </td><td>  28MHz </td><td>  38.4MSPS </td><td>  $ 420 </td></tr><tr><td>  <a href="https://www.ettus.com/product/details/USRP-B205mini-i">USRP B205mini-i</a> </td><td>  70 MHz - 6 GHz </td><td>  56MHz </td><td>  61.44MSPS </td><td>  $ 750 </td></tr><tr><td>  <a href="https://www.crowdsupply.com/lime-micro/limesdr">LimeSDR (coming soon)</a> </td><td>  100 kHz - 3.8 GHz </td><td>  61.44MHz </td><td>  61.44MSPS </td><td>  $ 299 </td></tr><tr><td>  <a href="http://www.rtl-sdr.com/">RTL-SDR (receive only)</a> </td><td>  22 MHz - 3.8 GHz (24 - 1766 MHz for R820T2) </td><td>  3.2MHz </td><td>  3.2MSPS </td><td>  $ 10 </td></tr><tr><td>  <a href="http://www.pervices.com/">Per Vices Crimson</a> </td><td>  0 MHz - 6 GHz </td><td>  1200MHz </td><td>  370MSPS </td><td>  $ 6500 </td></tr></tbody></table><br><p>  <a href="https://en.wikipedia.org/wiki/List_of_software-defined_radios">Full list on Wikipedia</a> </p><br><p>  In a nutshell: you can start exploring SDR with cheap RTL-SDR options.  When the appetite of the researcher exceeds the small capabilities of the device, you will have to look for a replacement expensive.  Devices such as Per Vices Crimson are used by very serious specialists, whose computers are sufficiently productive to process such streams of information.  LimeSDR is currently just finishing a Kickstarter fundraiser.  It looks very tempting: the sampling frequency is maximum for USB3.0, and the channel width is sufficient to raise six 10MHz LTE cells. </p><br><p>  However, more recently, the choice was not so great, and if you did not arrange hackRF for $ 300, then the next option was USRP immediately for $ 750, and no compromise.  In this regard, sixteen-year-old Lukas Lao Beyer decided to independently develop an SDR card and recently published a report on his project.  To say that we were amazed - to say nothing, it is better to just keep silent. </p><br><p>  "What the hell are these American schoolchildren for themselves!"  - shout in the comments to the article of Lucas.  People have been improving their skills for years, and this boy did everything between lessons!  We decided that it was impossible to leave it that way, and contacted Lucas.  In this series of articles, we will look at all aspects of creating such a device, so that Russian schoolchildren learn from their experience and do equally wonderful things.  Let's start with the Russian translation of Lucas diary, in which you can observe the course of the project and its experiences in connection with it.  Then we will analyze the selected solutions and try to make such a device in Russian conditions. </p><br><h2 id="razrabotka-apparatnoy-chasti">  Hardware design </h2><br><p>  <strong><a href="http://electronics.kitchen/misc/freesrp">From the diary of Lucas Lao Beyer</a></strong> <br>  FreeSRP is an available software-defined radio system.  I developed it because I did not find devices with higher bandwidth than the $ 300 HackRF, but cheaper than the more productive $ 700 USRP.  Some components still need to be improved, but the system will fully comply with the Open Source philosophy. </p><br><p>  FreeSRP is based on the Analog Devices AD9364 transceiver.  Key features: </p><br><ul><li>  56MHz band </li><li>  Frequency range 70MHz - 6GHz </li><li>  Full duplex operation. </li></ul><br><p>  Despite the fact that there are other alternatives like LimeSDR, I believe that FreeSRP will be in demand.  The development, as expected, was incredibly educational. </p><br><p> I started working on the system two years ago, in the summer of 2014, when I was 16. At that time I didn‚Äôt have experience with serious work with hardware, not counting the low-performance boards for my High Altitude Balloon project.  Therefore, I understood that the development of FreeSRP would be difficult in all aspects: high-speed buses (100MHz), USB3.0, signal tracks with performance up to 6GHz, complex power circuits with seven different voltages ... I really wanted to build a compact system on modern components, so I had to Get acquainted with components such as BGA or QFN. </p><br><img src="https://habrastorage.org/web/b2b/cc5/17f/b2bcc517f37140ec86ce279c5efea19e.png"><br><p>  <em>Compare my previous board and the current one.</em> </p><br><p>  Needless to say, the ambitiousness of the project is colossal.  However, it didn‚Äôt frighten me at all, and I started from a clean slate, based only on the fact that I‚Äôll definitely use the AD9346 transceiver, and I implement the bridge between the transceiver and USB3.0 on the FPGA.  Short searches led me to the Xilinx Artix 7 and the Cypress EZ-USB FX3 controller.  These toys seemed to me the best decisions in terms of price. </p><br><p>  Based on datasheets and reference designs, I gradually prepared a schematic diagram in which I solved questions for all the other components.  For development I used Altium Designer.  Although it is not open source, for me it was the most intuitive package of PCB design.  Many of its excellent features helped me a lot in development: life becomes much simpler if you have tools for drawing parallel tires or tracks with specific resistance.  However, when I finish eliminating flaws in the design, I will redraw everything into KiCad so that more people will be more comfortable using my designs. </p><br><p>  <strong>From design to prototype</strong> </p><br><img src="https://habrastorage.org/web/cc9/d78/f64/cc9d78f643714bc3b7e932acd00e40f5.png"><br><p>  When the circuit is ready, it's time to release the board template.  For the prototype, the manufacturing price is very important, and in my budget a four-layer board from our American service OSH Park, which is famous for its low price tag for piece orders, barely fit.  Suppose they have only four layers, the manufacturing parameters are very good - 5 mil tracks with the same intervals, 10 mil for holes, and also the excellent substrate Isola FR408, the quality of which depends on the radio signal. </p><br><p>  The most important thing in the design of the board - conveniently position the components.  I tried to make the connections between the components as small as possible.  Of course, I struggled to make a minimum size board, which greatly influenced the price.  I started drawing a signal from one side - from USB - and gradually added components along the way, until I got to the radio interface.  Components outside this path (voltage regulators) were added to the remaining free spaces on the board. </p><br><img src="https://habrastorage.org/web/c99/2a7/fbe/c992a7fbebd74bc0a19ef4879f9d1605.jpg"><br><p><br>  From the first time, of course, it turned out not perfect, and for quite a long time I enthusiastically reworked the board, until I finally realized that everything was fine.  The most severe pain came when I started to breed BGA on my four-layer board.  However, I managed.  The design passed all the checks, and I checked everything manually several times.  I didn‚Äôt want at all to tear my hair out after making the board with an error, because this, of course, would not have been fixed. </p><br><p>  <strong>Prototype manufacturing</strong> <br>  After a lot of trouble, I still ordered three boards, and in January 2015 they are Hurray!  - arrived.  I intended to assemble the board myself, so I additionally ordered a mounting template on the film for solder paste.  For installation, I used a halogen stove and a controller of my own design. </p><br><img src="https://habrastorage.org/web/abe/848/b56/abe848b56a8045888d8dc7f273a57705.png"><br><p>  Since FreeSRP is based on a double-sided board, I first mounted the bottom layer.  In the design, I placed only small components on the bottom: when I bake the board a second time when installing the upper layer, the small components will remain on the board, even upside down. </p><br><img src="https://habrastorage.org/web/3be/96c/336/3be96c336edc4958b8a47dbff11397f2.jpg"><br><p><br>  <strong>Partial assembly</strong> <br>  I had three printed circuit boards, so I first assembled the prototype only partially.  I installed only voltage regulators on one board, and because of this I discovered a problem with a 1.8V regulator.  No problem, I replaced it with an external power source.  But I could not eliminate the problem with the 1.3V regulator, because here the problem was a design error, so in the first revision I could not start the radio. </p><br><img src="https://habrastorage.org/web/55e/78f/cb0/55e78fcb0aa74dd98e044b28e2d44e72.jpg"><br><p><br>  On the second board, I assembled the entire digital part: USB and FPGA.  For the first time I had to mount BGA, and I did it manually.  After long hours of intense and painstaking installation of expensive components without the right to make a mistake, I carefully put the board in the oven with trembling hands.  The wait was painful, and how rejoicing I was when everything went perfect! </p><br><p>  <strong>First start</strong> </p><br><img src="https://habrastorage.org/web/348/38c/a71/34838ca711be4f08a5b032d9c3c130a0.jpg"><br><p><br>  Of course, I was incredibly afraid of the first inclusion of the board.  Although the power circuits were tested on the first board, I still did not rule out that now my precious components would flare up with a blue flame.  Perhaps there is some safe way to include a non-tested board.  Nothing better came to my mind how to smoothly increase the current on the power supply and pray that smoke would not go anywhere. </p><br><p>  The smoke test was successful, and the lights came on.  Neither the FPGA nor the USB to the touch did not heat up.  I plugged the USB into the computer, and the OS detected the Cypress chip.  Then I launched the Xilinx applications, and they connected to the FPGA via JTAG.  Looks like it all worked!  Having examined in more detail, I certainly found an error: I crooked the USB3.0 plug, so that only the second version worked.  Do not worry, we start testing in this form, and correct the problem later. </p><br><p>  <strong>Second revision</strong> <br>  In the second revision I needed to fix the problems with power and USB3.0 wiring.  As a result, I received a fully working digital part of the board, and it was time to move on to the radio part. <br>  At first I did not touch the transceiver, and collected all the other components.  In parallel, the development of the program part of the project began.  I have never programmed an FPGA before, so I had to learn Verilog from scratch.  At this stage, I decided to implement a parallel interface to the USB controller.  Although all parts of the project were not trivial, the development of FPGA for me was the most terrible part of the project.  It is very difficult to find documentation for dummies on the use of tools and IP blocks.  The messages that Vivado Design Suite wrote were for me a Chinese charter, and the inclusion of ready-made IP blocks led to hundreds of incomprehensible notifications.  Most likely, I just do not know how to cook properly in this kitchen yet. Even the most minimal changes in design required a painfully long calculation by the program, so everything must be simulated - and this further complicates entry into the wonderful world of FPGA.  And debug!  Without the Integrated Logic Analyzer, it is absolutely impossible to debug anything, and it became free only in 2016 - before that the price was very high.  Therefore, during debugging, it was necessary to transmit part of the test information by blinking the diode, and partly by the GPIO legs and watching the signal with an oscilloscope. </p><br><img src="https://habrastorage.org/web/804/c51/48a/804c5148aa124df2b8e86fc8da79a62c.png"><br><p><br>  I didn‚Äôt get to the end of the question about clocking right away - it was only by the third attempt that the realization came that the clock signal of the transceiver needed to be turned into clock-inputs on the FPGA. <br>  Having played enough with Verilog, I decided it‚Äôs time to solder the transceiver.  I took the third board, re-installed three hundred components on it, as before, starting from the bottom.  But when I soldered the upper side, the controller of my stove went on strike and did not turn off the furnace.  I could not get readings on the temperature in the furnace, and it was possible to control the unit only by turning it on or off or opening the door.  None of my prayers helped: a short circuit appeared on the tracks.  I tried to fix it, but in vain: when turned on, the FPGA heated up.  Alas, I just burned four hundred bucks in the oven, and this fact did not give me any confidence at all. </p><br><p>  Nevertheless, I was determined to finish the project, so I broke the piggy bank, re-ordered the components and after a few weeks I made another attempt to assemble everything.  You have no idea how I sweated this time, as if in the final tournament of poker!  Fortunately, everything went without surprises. </p><br><img src="https://habrastorage.org/web/3ba/96f/ee8/3ba96fee8845435cbb7cd138a7d884a4.jpg"><br><p><br>  The digital part in the new prototype worked perfectly.  But the transceiver did not want to work, its configuration port simply did not respond.  Then I noticed that the transceiver feels hot.  Why he was so hot, it was not clear, because he had to sleep without a configuration.  I tried unsuccessfully to find problems in nutrition.  Izlazil all schemes, rechecked everything a hundred times.  And then I discovered the following thing. </p><br><p>  It turns out that I mistakenly connected two resistors in series - 698 Ohms and 536 Ohms (in total 1234 Ohms) instead of 14.3 kilohm resistors from the documentation!  I replaced the resistors, and the chip stopped warming, but it still did not work.  Looks like I burned him. </p><br><img src="https://habrastorage.org/web/def/ec2/8be/defec28be4294432bff9b0b551f81f57.png"><br><p>  In general, at this moment I decided that quite a lot had already been done for such a young specialist without deep knowledge of electronics, and it was time to postpone the project.  But I still have a working FPGA, so I began to have fun with it. </p><br><p>  As a result of long experiments, I screwed up the transceiver driver and coped with the generation of test signals.  I have earned a chain of signal transmission from FPGA to USB, so that further I could manage my SDR from a computer using the library on a more familiar C ++.  Then I implemented the compatibility of my board with GNURadio, so now all the useful GNURadio-based programs could work with this board. </p><br><p>  <strong>Third revision</strong> </p><br><img src="https://habrastorage.org/web/471/d4f/9bd/471d4f9bda5841f9899434ba64113cbe.jpg"><br><p><br>  At some point, I found strength for one more spurt and did a third revision.  I corrected the annoying error with a 14.3 kilohm resistor, connected clock-inputs with FPGA, and replaced the transceiver oscillator with a chip to simplify the distribution of the clock signal and eliminate further problems. </p><br><p>  Of course, the project went beyond the time frame and budget, but now it already seems to me that having only three revisions to a working board is not bad at all! </p><br><p>  Also on this revision I switched to a six-layer PCB.  Prototypes began to cost more, but the distance between the signal tracks increased significantly, and I reached the maximum clock frequency in the tires. </p><br><p>  In addition, I bought excellent stainless steel patterns, which, unlike Kapton, are much easier to use. </p><br><img src="https://habrastorage.org/web/eff/e8a/551/effe8a55147b4978b05d1f8e6ffb59f8.jpg"><br><p><br>  Once the software was ready for me, I was able to immediately start the transceiver at the reception, and here they are the long-awaited first samples in GNURadio! </p><br><img src="https://habrastorage.org/web/426/522/c12/426522c1200b43d3be5c244ff94aaa90.png"><br><p><br>  Finally, all the hard work has borne fruit.  A few weeks later I was able to start the transmitter, and made sure that the full duplex mode took off, albeit not at full width.  And then I found a new problem with the amp on the transmission, so the signal was very weak. <br>  In any case, I have a fully functional SDR board, guys!  Yes, there is still a lot to finish.  I want to carefully measure the performance of the receiver and transmitter.  I really want to start small-scale production, but before that I need to optimize the design a little more and be 100% sure that I didn‚Äôt leave any surprises in the board. </p><br><p>  <strong>Formulation of the problem</strong> <br>  Many thanks to Lucas for his detailed report, and now let's consider his decisions. <br>  So, Lucas wanted to make a broadband, software-defined radio system with better characteristics than hackRF, and cheaper than USRP.  Let's consider how the equipment of competitors is arranged. </p><br><p>  <strong>USRP</strong> </p><br><img src="https://habrastorage.org/web/6d4/31e/9e1/6d431e9e17d4423fa00ae84cde5e60a6.png"><br><img src="https://habrastorage.org/web/f19/de3/1d1/f19de31d125449f5b9e5691b0da73ba3.png"><br><p>  <strong><a href="http://www.nuand.com/bladerf.pdf">bladeRF</a></strong> </p><br><img src="https://habrastorage.org/web/6e3/4c5/9ad/6e34c59ad257401cbac0e84c7848c39e.png"><br><p>  <strong>hackRF</strong> </p><br><img src="https://habrastorage.org/web/565/3b1/4a1/5653b14a10974b52972574f73dbedd79.jpg"><br><p><br>  The last image looks the most concise, but all three devices have the same architecture: the signal is received from the air, digitized and transferred to USB.  There are differences in details.  In hackRF, the radio part is implemented in the form of several components: the signal after reception using a mixer shifts to an intermediate frequency range of 2.3-2.7GHz, then is converted into an in-phase and quadrature component of the signal, which is already digitized.  Other devices solve this problem in one component - the transceiver.  Conversion of a digital signal for transfer to USB, as well as control of the radio path, is carried out using FPGA or a microcontroller. </p><br><p>  When designing the system from top to bottom, we will divide it into three parts: RF, FPGA and USB, and first we will work each block separately, and then we will figure out how to connect them together. </p><br><p>  <strong>RF part</strong> <br>  The radio module in such a system is the most fragile thing.  Discrete bits must turn into a wave and fly to the antenna with the necessary power.  For this, a whole lot of wonderful things were needed before: filters, interpolators, decimators, digital-to-analog converters, synthesizers, mixers and various amplifiers.  There is still a class of people who prefer to independently control every aspect of their radio module and collect them from small pieces.  What is the preferred solution to the student?  Of course, he will be glad if one superchip solves all these problems for him.  Here are the options: </p><br><p>  <strong>Like in hackRF</strong> <br>  Michael Ossmann, by the way, is also a radio amateur, not a radio professional, and the only reason why he did not decide on the radio part in his project in the form of one smart piece of silicon is the dollars that would be required for this.  Michael chose a compromise: he uses three pieces of silicon and saves about half the cost, which makes hackRF so affordable.  The hackRF radio signal comes to RFFC5071, which lowers the frequency to ~ 2.5GHz (this is called LO synthesis), then this signal enters the narrowband MAX2837 transceiver, turns into a baseband and goes to MAX5864 in this form - this is just digital-analog (and back) converter. </p><br><p>  <strong>AD9364</strong> <br>  Analog Devices produce excellent transceivers that are often used in various SDR projects.  Above the diagram shows that such a chip, for example, feels comfortable on USRP devices.  You can buy a chip from the manufacturer on the <a href="http://www.analog.com/ad-fmcomms4-ebz">AD-FMCOMMS4-EBZ</a> demo board, which in principle is a ready-made primitive SDR. </p><br><p>  <strong><a href="http://www.limemicro.com/download/LMS6002Dr2-DataSheet-1.2r0.pdf">LMS6002D</a></strong> <br>  Lime Micro chips are used in a variety of systems (bladeRF, for example), including the Russian SDR development umTRX, and this year they swung to their own SDR system and successfully collected on Kickstarter the tools to run LimeSDR in production.  In general, Lucas had the right to use this chip in his work, he is beautiful, and his main drawback is that the range of received frequencies is half as much as that of the AD9364. </p><br><p>  So in the end, Lucas chose the option with the AD9364, and immediately ordered it. </p><br><p>  <strong>FPGA selection</strong> <br>  The most difficult thing when choosing a FPGA is to decide Altera or Xilinx.  These companies, like Sony and Nintendo, produce equally cool hardware, and the devil is only in the details.  What is the difference between Altera and Xilinx? </p><br><p>  Altera is famous for the very long support of its microchips.  The Xilinx Vivado development environment only works with the latest (seventh) series of chips, while Altera's Quartus supports even the Flex 10K, which is fifteen years old since its first release.  At the time of the start of the project, the Xilinx debugging software cost $ 700 (and became free only this year), while at Altera it is free.  Altera's IP blocks (pre-built software libraries) can be tried during the demo period with restrictions.  As a result, for the beginner amateur Altera looks preferable.  But in Xilinx the smarter DSP part, it has not only multiplication (as in Altera), but also an addition with a battery, which reduces the number of logical blocks needed to solve the problem. </p><br><p>  But Lucas chose Xilinx.  He claims that because of the price, but I think that at random (compare, Xilinx Aritx-7 and Altera Cyclone V). </p><br><p>  How to choose a specific model of the chip from Xilinx?  Two years ago, the choice was between Spartan-6 and Artix-7, which are considered low-cost Xilinx offer.  Spartan-6 is no longer necessary because Vivado software does not support it. </p><br><p>  All BGA Artix-7 families are compatible with what is called pin-to-pin, so Lukas would just stick further on the model 50T, deciding to decide on a specific model when the software is ready and the performance requirements for the chip are precisely determined. </p><br><p>  What FPGAs are used in other similar projects? </p><br><table><thead><tr><th>  SDR </th><th>  FPGA model </th><th>  Logic cells </th></tr></thead><tbody><tr><td>  USRP B200 </td><td>  Xilinx Spartan 6 LX150 </td><td>  150k </td></tr><tr><td>  USRP B210 </td><td>  Xilinx Spartan 6 LX75 </td><td>  75k </td></tr><tr><td>  bladeRF x40 </td><td>  Altera Cyclone 4 </td><td>  40k </td></tr><tr><td>  bladeRF x115 </td><td>  Altera Cyclone 4 </td><td>  115k </td></tr><tr><td>  hackRF </td><td>  CPLD </td><td>  xx </td></tr></tbody></table><br><p>  The author hackRF did not put the FPGA, and chose a cheaper technology - CPLD, which is, let's say, a simplified version of the FPGA.  As a result, he can practically do nothing useful in it and generally plans to exclude the FPGA from his design, transferring the transceiver control to the USB controller chip. </p><br><p>  <strong>USB3.0</strong> <br>  It remains to determine the solution for USB3.0.  The most popular solution here is the Cypress FX3 microcontroller, and it‚Äôs hard to think of reasons not to use it.  However, consider the alternatives. </p><br><p>  The first thing that comes to mind is FTDI FT60x - a microcontroller in a QFN package.  FTDI Company is famous for the fact that it likes to produce drivers that intentionally kill your chip, if it is a fake.  If for USB2.0 the chips of this company were considered de facto standard, then in USB3.0 they, unfortunately, missed their market with such a strange attitude towards end-user equipment and low quality software. </p><br><p>  Another option is to take the transceiver from Texas Instruments TUSB1310A, and implement the MAC layer in the FPGA.  The transceiver costs $ 20 cheaper than a Cypress FX3 microcontroller, and I find it difficult to comment on why Lucas did not do that. </p><br><p>  <strong>PCB manufacturing</strong> <br>  If you want to program more than have fun with a soldering iron, I would recommend to make a prototype on the finished board.  A good list of ready-made boards on different FPGAs can be found on a <a href="https://joelw.id.au/FPGA/CheapFPGADevelopmentBoards">special site</a> .  For this particular project, there is an ideal version of the <a href="http://www.ztex.de/usb-fpga-2/usb-fpga-2.14.e.html">finished board with USB3.0 and Artix 7 FPGA, you</a> just have to switch the transceiver and you can immediately start experimenting. </p><br><p>  However, Lucas in this project were interested in all stages.  Moreover, he even wanted to mount the board himself.  Prototypes Lucas made in OSH Park - this is a very popular service among American students.        (10$   ),             . , ,          ,         .                 . </p><br><p>      .  Requirements: </p><br><ul><li> 5 mil=0,127    </li><li> 5 mil=0,127    </li><li> 10 mil=0,254    </li><li>       </li><li>  : 74 * 108mm </li></ul><br><table><thead><tr><th>  </th><th>      </th><th>    </th></tr></thead><tbody><tr><td> <a href="https://oshpark.com/">OSH Park</a> </td><td>    </td><td> 123$   ,  ‚Äî  150   </td></tr><tr><td> <a href="http://www.pcbtech.ru/">PCB tech</a> </td><td> 614$ </td><td>  - </td></tr><tr><td> <a href="http://www.rezonit.ru/"></a> </td><td> 153$ </td><td>  - </td></tr><tr><td> <a href="https://easyeda.com/">EasyEDA</a> </td><td> 284$ </td><td>  - </td></tr><tr><td> <a href="http://www.seeedstudio.com/">seeedstudio.com</a> </td><td> 158$ </td><td>  - </td></tr><tr><td> <a href="https://www.pcbwing.com/">pcbwing</a> </td><td> 348$ </td><td> 299$ </td></tr><tr><td> <a href="http://www.pcbunlimited.com/">PCB Offshore</a> </td><td> 280$ / 4pcs </td><td> 140$ / 4pcs </td></tr><tr><td> <a href="http://www.pcbcart.com/">PCBCart</a> </td><td> 191$ </td><td> 93$ </td></tr></tbody></table><br><p>         :      .   ,             . ,     ,     .   ,         EasyEDA,   .     ,           .     ,        ,              . </p><br><h2 id="pishem-po">   </h2><br><p> <strong><a href="https://www.gnuradio.org/blog/freesrp-new-usb-software-defined-radio/">    </a></strong> <br>      ,    : </p><br><ul><li>  ,     AD9364  USB </li><li>   USB  </li><li>   PC,        . </li></ul><br><p>      C++    libusb. ,    ,     -  ,     GNU Radio. </p><br><p>         GNU Radio,       gr-osmosdr,      SDR.       ,  . ,       (, Gqrx, AirProbe/gr-gsm). ,       ,        . </p><br><p>       gr-osmosdr,           SDR.  ,    ,     .      ,    ..   ‚Äî work ‚Äî       GNU Radio.     ,        , , ,  .      ,    :     <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2582%25D0%25BE%25D1%2580_(%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F)">    </a> </p><br><p>  ,        gr-osmosdr     freesrp. </p><br><p> <strong>   </strong> <br>     GNU Radio      ,     - .           .    ,        . </p><br><p>     ,      GNU Radio "probe rate",      : </p><br><img src="https://habrastorage.org/web/b19/0f3/db3/b190f3db314743459ec86518b48c409d.png"><br><p><br>        GNU Radio.      .       . </p><br><p>     .     GNU Radio    (sink block). </p><br><img src="https://habrastorage.org/web/145/772/74d/14577274db504e53872d0187ec8451e9.png"><br><p>  ,     :    32- ,     12-  (I  Q)   .    Integrated Logic Analyzer      12-        ,      . </p><br><img src="https://habrastorage.org/web/74c/679/d8b/74c679d8beb54dfcb22592d394cdbdac.png"><br><p><br> I  Q        . </p><br><p> GNU Radio    ,   - .   ,       freesrp,    .    ,     : </p><br><img src="https://habrastorage.org/web/32b/ea3/472/32bea347250b4350b33742e3e265fc69.png"><br><p>    .        .         I,  Q  ,    ‚Äî  I   Q: </p><br><img src="https://habrastorage.org/web/05c/000/cb8/05c000cb82b04dffae1779cf4ed6c3e3.png"><br><p><br>       ,   -    ,       USB-:            ,   .       ,    : </p><br><img src="https://habrastorage.org/web/64c/ef6/5a9/64cef65a99184a14bfeb2a84c567612f.png"><br><p><br>        ,     .       AD9364,        . </p><br><p> <strong>   GNU Radio</strong> <br>        .     GSM  <a href="https://ru.wikipedia.org/wiki/ZigBee">Zigbee</a> ,        gr-gsm and gr-ieee802-15-4. </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GSM</font></font></strong> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GNU Radio external modules are built via cmake, so everything is simple:</font></font></p><br><pre><code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">mkdir</span></span> build <span class="hljs-comment"><span class="hljs-comment"># Creates a blank directory for the build to run in cd build cmake .. # Load CMake build script in root of the module's directory and run it make # Run the CMake-generated makefile sudo make install # Install the module sudo ldconfig</span></span></code> </pre> <br><p>  The gr-gsm package comes with a number of trial applications.  The most interesting are grgsm_scanner and grgsm_livemon.  Using the first one, you can search for GSM broadcasting and isolate some identifiers from them, as well as get a list of base stations. </p><br><img src="https://habrastorage.org/web/1be/641/de7/1be641de7c6a43d2b93802b1f5a599e6.png"><br><p><br>  Look, by the way, I specify the code of my freesrp board as an argument - and everything works.  This is a very pleasant feeling. </p><br><p>  The second application allows you to tune into one of the GSM channels, decrypt the data and send it to your local network where you can listen to them via Wireshark.  I added a gr-fosphor module to the program to make the screenshot more colorful: </p><br><img src="https://habrastorage.org/web/076/985/202/076985202f5546249eb0c75a1bc0302b.png"><br><p>  <strong>802.15.4 (Zigbee)</strong> </p><br><p>  I had several XBee modules at home, and I decided to interact with them.  In this example, I wanted to check the sending of data. </p><br><p>  Installing a module is as easy as with gr-gsm.  The examples that come with the library are made for the Rime communication stack, so I cut off everything from Zigbee itself and added the TCP Server block so that you can connect and send data over the local network: </p><br><img src="https://habrastorage.org/web/cb4/67a/d29/cb467ad294c344aeb091e49d14761a26.png"><br><p>  For example, I wrote two Python scripts: one connects to the XBee via USB, and the other clings to the TCP ports in GNU Radio.  And then I just sent text messages through the 802.15.4 protocol, like in a chat. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ypvlMMAoEUI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>About driver development</strong> <br>  <strong>Design FPGA and USB controller</strong> <br>  Now my FPGA does nothing special, except as an interface between the transceiver and USB.  Due to the ease of implementation, I launched the driver from AD9364 on MicroBlaze, which performs setup and calibration.  The driver communicates with USB via UART.  Soon I will transfer this driver to a USB controller. </p><br><p>  The AD9364 outputs samples to a 12-bit port, alternating between I and Q. There is another 12-bit port where you need to send outgoing I \ Q values.  Also, the transceiver provides DDR-clock depending on the selected sampling rate.  In the input signal circuit, reverse interleaving and folding into a 24-bit queue occur. </p><br><p>  The USB controller has a DMA mechanism, where the FPGA can directly write (and read from there) data via a 32-bit bus.  Therefore, when the FPGA has accumulated enough data in the queue, and FX3 is ready to receive, the state machine transferred the data. </p><br><p>  Now I use only 24 bits of the available 32. One I \ Q sample fits in, and I simply discard the remaining 8 bits.  But for full duplex data transfer, all 32 bits will need to be used. </p><br><p>  The USB controller provides the following control points: </p><br><ul><li>  INTERRUPT OUT - sends commands to Microblaze on driver AD9364 </li><li>  INTERRUPT IN - accepts errors or responses to these commands. </li><li>  BULK OUT - for sending data </li><li>  BULK IN - for receiving data </li></ul><br><p>  Once enabled, FPGA can be configured via INTERRUPT OUT. </p><br><p>  <strong>Libfreesrp</strong> <br>  The library for interacting with FreeSRP is very simple.  The libusb interface is used for receiving and sending.  This allows data to be queued for optimal processing by the operating system.  The user specifies the callback that will be called if new data arrives or the send buffers are released. </p><br><p>  <strong>Plans</strong> <br>  Dmitry Stolnikov from gr-osmosdr has already contacted me and offered to merge my changes into the main branch of the library.  I will soon finish polishing it and do it. </p><br><p>  When I get rid of MicroBlaze and transfer the driver to FX3, the FPGA is almost completely free.  I would like to use this for experiments with real-time signal processing right on the FPGA. </p><br><p>  I'd like to get more accurate performance characteristics of the radio part.  I did not come close to this one step, because I have no instruments, and there are many other things to do. </p><br><h2 id="vypusk-produkta">  Product release </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/211433345" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  In April, Lucas launched crowdfunding for his product and received the first batch of orders for $ 20,000 (that is, about fifty copies). </p><br><p>  After the shipment of this game, it will be possible to say with confidence that the prototype has turned into a product, and this is a wonderful finale of a six-year long history of a sixteen-year-old kid who has brought together the present Software Defined Radio. </p><br><p>  <strong>Help links</strong> <br>  ‚Üí <a href="http://freesrp.org/schematics/freesrp_alpha.pdf">FreeSRP schematic</a> <br>  ‚Üí <a href="https://github.com/myriadrf/FreeSRP_GW">FPGA sources</a> <br>  ‚Üí <a href="https://github.com/myriadrf/FreeSRP_FX3">USB Controller Sources</a> <br>  ‚Üí <a href="http://freesrp.org/">Project site</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330052/">https://habr.com/ru/post/330052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330038/index.html">Cisco CSR 1000v: Reliability - the key to success. Part 2</a></li>
<li><a href="../330040/index.html">Flashcache - cheap and angry or alternative to HW RAID 10 SAS</a></li>
<li><a href="../330044/index.html">Chat with your own hands</a></li>
<li><a href="../330046/index.html">1 more non-recursive algorithm for generating all partitions of an integer</a></li>
<li><a href="../330048/index.html">Understanding the event architecture of Node.js</a></li>
<li><a href="../330056/index.html">The history of the creation of the Virtual File System Git (GVFS, Git Virtual File System)</a></li>
<li><a href="../330060/index.html">Kotlin, bytecode compilation and performance (part 1)</a></li>
<li><a href="../330062/index.html">Own scripting engine for games using C ++ and Lua (part 1)</a></li>
<li><a href="../330064/index.html">Kotlin, bytecode compilation and performance (part 2)</a></li>
<li><a href="../330066/index.html">Issue # 3: IT training - current issues and challenges from leading companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>