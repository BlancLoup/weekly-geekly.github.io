<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ORegex: From characters to objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good evening, hrobrozhiteli! 
 Today I want to share with you such a young project like ORegex or Object Regular Expressions. I have been working in c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ORegex: From characters to objects</h1><div class="post__text post__text-html js-mediator-article">  Good evening, hrobrozhiteli! <br>  Today I want to share with you such a young project like ORegex or Object Regular Expressions.  I have been working in computer linguistics for quite a long time and, although I am not a linguist, I still see some well-established constructions and patterns in languages. <br>  For those who are interested in how I decided to allocate them - under the cat. <br><a name="habracut"></a><br>  These templates can be as simple as: <br><ul><li>  Smilies; </li><li>  Hashtags; </li><li>  Dates; </li><li>  Telephones; </li><li>  etc. </li></ul><br>  So complex: <br><ul><li>  Direct speech; </li><li>  Names of various companies; </li><li>  Names; </li><li>  Enumerations in the text; </li><li>  etc. </li></ul><br><br>  Basically my job was to understand what and how to extract from a sequence of objects.  This can be done through grammars, through automata, or you can simply write a couple of nested loops.  But when I was specifically bothered to write tons of parsers of various sequences (tokens, words, word combinations, etc.) with varying complexity and a huge number of bugs, a reasonable question occurred to me - is it possible to make it easier?  The answer came intuitively: use regular expressions to search. <br><br>  But how?  Regular expressions, of course, do well and quickly with the task of searching by pattern, only all the engines are written exclusively for character sequences, and those that are sharpened for objects are not at all pleased with their speed and are generally in other linguistic planes.  As a result, after some deliberation, it was decided to write his own ‚Äúbicycle with a normal gear system‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I decided to make the project open source for a number of reasons, but this is not about that now. <br>  Let's take a look at how it can be used at all in combat conditions. <br><br>  <b>How to use?</b> <br><br>  I did not think long over the syntax, it was decided to use the standard .NET + notation to add comments and write normal names for atomic conditions.  This would allow without problems to make patterns in separate files: <br><br>  {MyPredicate1} |  (? {MyPredicate2} {MyPredicate3} *) <br><br>  It is worth noting that at the moment some functions of the .NET Regex are not included (conditional operators, lookahed), but they will definitely appear in the near future.  And now for the examples themselves.  Suppose we have a sequence of numbers: <br><br>  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 <br><br>  And your task is to find all consecutive primes.  To do this, you need to define a function that will answer the question whether the number is simple or not: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> boundary = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Floor(Math.Sqrt(number)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= boundary; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><br>  And define a pattern for finding simple sequences: <br><br>  {IsPrime} (. {IsPrime}) * <br><br>  On this, by and large, the difficult part is complete.  We describe the selection procedure itself: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrimeTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oregex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ORegex&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"{0}(.{0})*"</span></span>, IsPrime); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> oregex.Matches(input)) { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">","</span></span>, match.Values)); } <span class="hljs-comment"><span class="hljs-comment">//OUTPUT: //2 //3,4,5,6,7 //11,12,13 }</span></span></code> </pre><br><br>  Well, that's all, but not so convincing, right?  Well, then let's give a little more complicated.  Imagine that we have a certain sequence of words that came to us from a lexico-morphological module.  The question is how to quickly select the names of persons from the sequence?  Pretty simple. <br><br>  We define the classes of the word and person: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SemanticType { Name, FamilyName, Other, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Word</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemanticType SemType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Word</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, SemanticType semType</span></span></span><span class="hljs-function">)</span></span> { Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; SemType = semType; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Word[] Words; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OMatch&lt;Word&gt; match</span></span></span><span class="hljs-function">)</span></span> { Words = match.Values.ToArray(); Name = match.OCaptures[<span class="hljs-string"><span class="hljs-string">"name"</span></span>].First().Values.First().Value; <span class="hljs-comment"><span class="hljs-comment">//Now just normalize this name and you are good. } }</span></span></code> </pre><br><br>  And additionally some <i>important</i> function that will determine that the string is actually the initial: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsInitial</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inp = str.Trim(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'\t'</span></span>, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">'\r'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inp.Length == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>.IsUpper(inp[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br><br>  Without further ado, we make a predicate table, a pattern, and get our person objects: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonSelectionTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//INPUT_TEXT:          .. var sentence = new Word[] { new Word("", SemanticType.FamilyName), new Word("", SemanticType.Name), new Word("", SemanticType.Other), new Word("", SemanticType.Other), new Word("", SemanticType.Name), new Word("", SemanticType.Other), new Word("", SemanticType.Other), new Word("", SemanticType.Other), new Word("", SemanticType.Name), new Word(".", SemanticType.Other), new Word("", SemanticType.Other), }; //  . var pTable = new PredicateTable&lt;Word&gt;(); pTable.AddPredicate("", x =&gt; x.SemType == SemanticType.FamilyName); //Check if word is FamilyName. pTable.AddPredicate("", x =&gt; x.SemType == SemanticType.Name); //Check if word is simple Name. pTable.AddPredicate("", x =&gt; IsInitial(x.Value)); //Complex check if Value is Inital character. //      . var oregex = new ORegex&lt;Word&gt;(@" {}(?&lt;name&gt;{}) //Comments can be written inside pattern... | (?&lt;name&gt;{})({}|{}{1,2})? /*...even complex ones.*/ ", pTable); //   . var persons = oregex.Matches(sentence).Select(x =&gt; new Person(x)).ToArray(); foreach (var person in persons) { Console.WriteLine("Person found: {0}, length: {1}", person.Name, person.Words.Length); } //OUTPUT: //Person found: , length: 2 //Person found: , length: 1 //Person found: , length: 3 }</span></span></code> </pre><br><br>  Well that's all.  I tried to describe everything briefly and clearly =) <br>  If that library is available both in <a href="https://www.nuget.org/packages/ORegex/">nuget</a> and on <a href="https://github.com/eocron/ORegex">github</a> . </div><p>Source: <a href="https://habr.com/ru/post/278219/">https://habr.com/ru/post/278219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278205/index.html">360 Total Security welcomes Habrahabr</a></li>
<li><a href="../278207/index.html">CMake - create dynamic libraries</a></li>
<li><a href="../278209/index.html">Kaspersky Security Center - the struggle for automation</a></li>
<li><a href="../278213/index.html">Personalize IMGUI and Unity Editor. Part two</a></li>
<li><a href="../278217/index.html">The book "Paradox. Nine great mysteries of physics "</a></li>
<li><a href="../278221/index.html">Hacker has published data of SIM-cards and accounts of 3 million subscribers of a major African operator</a></li>
<li><a href="../278223/index.html">Using PowerShell to work with Veeam Backup Free Edition</a></li>
<li><a href="../278227/index.html">The digest of interesting materials from the world of Drupal # 18</a></li>
<li><a href="../278231/index.html">Practical training in the field of information security: Corporate Laboratories 2016, reboot</a></li>
<li><a href="../278233/index.html">Java programmer cheat sheet 7.1 Typical tasks: The optimal way to convert an InputStream to a string</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>