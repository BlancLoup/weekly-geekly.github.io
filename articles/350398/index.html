<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Native dependency inversion in TypeScript and React</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I thought about implementing dependencies in TypeScript, the first thing I was advised was inversify . I looked at this and other libraries that ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Native dependency inversion in TypeScript and React</h1><div class="post__text post__text-html js-mediator-article"><p>  When I thought about implementing dependencies in TypeScript, the first thing I was advised was <a href="http://inversify.io/">inversify</a> .  I looked at this and other libraries that implement the Service Locator pattern, and even made my own - <a href="https://www.npmjs.com/package/typedin">typedin</a> . </p><br><p>  But when I was working on the version of typedin 2.0, I finally realized that no library was needed at all.  TypeScript has everything you need. </p><br><img src="https://habrastorage.org/webt/n1/xj/3x/n1xj3xj6oaqy381dhyf1iaj3nyi.jpeg"><a name="habracut"></a><br><br><h3 id="sevice-locator-eto-antipattern">  Sevice Locator is antipattern </h3><br><p>  It has long been known that the Service Locator is an <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">anti-pattern</a> .  First of all, because it creates implicit dependencies.  If you simply pass the service ontainer to a class, and in the class code you arbitrarily receive services, then the only way to find out the dependencies of this class is to examine its code. </p><br><pre><code class="hljs pgsql">//   inversify var ninja = kernel.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;INinja&gt;("INinja");</code> </pre> <br><p>  Of course, it is possible to slightly improve this circumstance if we introduce dependencies through properties.  For example, this is how it is done in <code>typedin</code> (for <code>inversify</code> , there are also decators): </p><br><pre> <code class="hljs scala"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@inject</span></span> logService: <span class="hljs-type"><span class="hljs-type">ILogService</span></span>; }</code> </pre> <br><p>  By declaring such a property, we allegedly declare its dependency in the class interface.  But this is still bad - we can safely create an instance of a class without passing it the necessary dependencies, and get a runtime error.  IDE does not tell us how to properly use the class. </p><br><img src="https://habrastorage.org/webt/6c/rj/fx/6crjfxm4lcx31q16hebqpqscsx8.png"><br><p>  Instead, we must examine the documentation ourselves and find out everything.  But let's say we overcame all the difficulties and wrote the correct code.  However, when adding new features, someone adds another service to the class, the compiler doesn‚Äôt warn us about it.  Our code will just drop runtime due to the fact that we are not transmitting the necessary service. </p><br><p>  For all these reasons, the best way to add dependencies is using <em>constructor injection</em> with <a href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/"><em>composition root</em></a> . </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ constrcutor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> logService: <span class="hljs-type"><span class="hljs-type">ILogService</span></span>) { } }</code> </pre> <br><h3 id="slozhnosti-s-constructor-injection">  Challenges to constructor injection </h3><br><p>  The implementation of dependencies through the designer is devoid of all the above disadvantages.  We explicitly declare dependencies, so the user simply cannot create an instance of the class without passing the necessary services.  At the same time, the compiler completely controls our code and will report an error immediately.  However, this approach is rather inconvenient in "raw" form.  Every time we create an instance of a class, we need to transfer all the necessary services to it. </p><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> some = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeComponent(logService)</code> </pre> <br><p>  And if we have a component tree, then the dependency transfer code needs to be written in the whole chain. </p><br><pre> <code class="hljs javascript"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeWrapperComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private logService: ILogService) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> some = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeComponent(logService) } }</code> </pre> <br><p>  When changing the list of services in <code>SomeComponent</code> will have to change the code of <code>SomeWrapperComponent</code> and then all those who use it.  This is especially sad when the number of services becomes any significant. </p><br><p>  Nevertheless, as <a href="https://angular.io/guide/dependency-injection">Angular</a> showed us, thanks to the decorators in TypeScript, you can automatically inject dependencies listed in the constructor parameters. </p><br><pre> <code class="hljs haskell">//       <span class="hljs-type"><span class="hljs-type">Angular</span></span> @<span class="hljs-type"><span class="hljs-type">Injectable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">HeroService</span></span> { constructor(private logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>) { } }</code> </pre> <br><p>  That is, on the one hand, we explicitly declare dependencies in the parameters of the constructor, and on the other, we do not write a bunch of boilerplate to transfer services to each component.  Services are automatically located in the component tree or parent module. </p><br><p>  However, this approach is problematic to implement in React.  The analogue of the constructor for React components is <code>props</code> .  That is, React's constructor injection should look something like this: </p><br><pre> <code class="hljs kotlin">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;SomeComponent logService={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logService} /&gt; }</code> </pre> <br><p>  Unfortunately, <code>props</code> is just an interface, and no decorators will allow us to do an automatic injection of dependencies, as in Angular. </p><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">SomeComponentProps</span></span> { logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span> } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;SomeComponentProps</span></span></span><span class="hljs-class">, </span></span>{}&gt; { }</code> </pre> <br><p>  This problem is not only React.  In many frameworks, we do not control the creation of components through the constructor.  For example, in the same Vue.  In fact, in Angular, too, no one creates components through the designer, so there, too, this is all relevant. </p><br><h3 id="nativnaya-inekciya-zavisimostey-sredstvami-typescript">  Native dependency injection with TypeScript </h3><br><p>  I thought for a long time how to combine all this while working on typedin v2.0.  I wanted to preserve the explicit nature of the transmission of dependencies, as in <em>constructor injection</em> , but at the same time reduce the number of boilerplate and make it compatible with React. </p><br><p>  Gradually, I began to appear a prototype of such a solution.  I improved the code step by step, discarding everything superfluous, until one fine moment left nothing from the typedin library.  It turned out that everything you need is already in TypeScript, so one can say that this article is typedin v2.0. </p><br><p>  So, all we have to do is add one <code>$Logger</code> type declaration next to the service declaration. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(msg: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { console.info(msg); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type $Logger = { logger: Logger; };</code> </pre> <br><p>  Add another service to make it more interesting: </p><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LocalStorage</span></span> { setItem(key: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) { localStorage.setItem(key, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } getItem(key: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localStorage.getItem(key); } } export type $LocalStorage = { localStorage: LocalStorage }</code> </pre> <br><p>  We declare our component to which dependences of <code>Logger</code> and <code>LocalStorage</code> . </p><br><pre> <code class="hljs scala">export interface <span class="hljs-type"><span class="hljs-type">SomeComponentProps</span></span> { services: $<span class="hljs-type"><span class="hljs-type">Logger</span></span> &amp; $<span class="hljs-type"><span class="hljs-type">LocalStorage</span></span>; } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component&lt;SomeComponentProps</span></span></span><span class="hljs-class">, </span></span>{}&gt; { constructor(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-comment"><span class="hljs-comment">//    let habrGreeting = props.services.localStorage.getItem("Habrahabr"); props.services.logger.log("Native TypeScript DI! " + habrGreeting); ) }</span></span></code> </pre> <br><p>  Let's also announce another service that also needs dependency injection. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeroService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private services: $Logger) { services.logger.log(<span class="hljs-string"><span class="hljs-string">"Constructor injection is awesome!"</span></span>); } }</code> </pre> <br><p>  It remains to collect all this together.  In some place of the application, we initialize all our services, according to the <a href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/">composition root</a> pattern: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logger(); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> services = { <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: logger, <span class="hljs-attr"><span class="hljs-attr">localStorage</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocalStorage(), <span class="hljs-attr"><span class="hljs-attr">heroService</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HeroService({ logger }) <span class="hljs-comment"><span class="hljs-comment">//  ! };</span></span></code> </pre> <br><p>  Now you can simply pass this object to our component: </p><br><pre> <code class="hljs javascript">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">SomeComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">services</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{services}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  That's all!  This pure universal <em>constructor injection</em> without boilerplate! </p><br><h3 id="kak-vse-eto-rabotaet">  How it all works </h3><br><p>  I adore TypeScript for this <a href=""><code> &amp;</code></a> as applied to types.  Thanks to him, it all looks so simple and elegant.  When announcing the <code>Logger</code> service, we additionally declared the type <code>$Logger</code> .  If you are confused by the construction <code>type</code> , an alternative option is: </p><br><pre> <code class="hljs actionscript">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ logger: Logger; }</code> </pre> <br><p>  Literally, we declare the interface of some container containing the <code>Logger</code> service in the variable <code>logger</code> .  And so does each service - <code>$LocalStorage</code> , <code>$HeroService</code> .  In the component, we need several services, so we simply combine two interfaces: </p><br><pre> <code class="hljs perl">services: $Logger &amp; $LocalStorage;</code> </pre> <br><p>  This construction is equivalent to approximately the following: </p><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponentDependecies</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalStorage</span></span></span><span class="hljs-class"> </span></span>{ logger: Logger; localStorage: LocalStorage; } services: SomeComponentDependecies;</code> </pre> <br><p>  That is, we say that the <code>SomeComponent</code> component <code>SomeComponent</code> to transfer the container containing the <code>Logger</code> and <code>LocalStorage</code> .  And it's all!  How the component is transferred to the corresponding container, where it will come from and how it will be created is not so important.  You can import some global <code>services</code> object created in one place in composition root.  You can pass this object through a chain of parent components.  You can create it dynamically on demand.  It all depends on the conditions of a particular application. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  InversifyJS contains about 100kb code and <a href="https://github.com/inversify/InversifyJS/tree/master/wiki">documentation</a> from about 40 sections, which are not the easiest to understand.  Nevertheless, its npm package is downloaded about 100 thousand times a month, many plug-ins and extensions are written for it.  From this we can draw two conclusions: </p><br><ol><li>  Dependency injection is gaining popularity in the frontend world </li><li>  The front-line community has not yet realized that the Service Locator is an anti-pattern. </li></ol><br><p>  That is, as usual, mindlessly snatch ideas from other technologies and languages.  In fact, dependency inversion is just a <a href="http://blog.ploeh.dk/2017/01/27/dependency-injection-is-passing-an-argument/">parameter passing</a> , and no libraries are needed for this.  Are you sure that all these <a href="">factories</a> , <a href="">providers</a> , <a href="">binders</a> , <a href="">handlers</a> , <a href="">cyclic dependencies</a> and the like are worth the resources and the complexity of the code they give? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350398/">https://habr.com/ru/post/350398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350388/index.html">Examining DB and DBMS with T-SQL</a></li>
<li><a href="../350390/index.html">Proper bookmarking: how to work more efficiently and memorize more</a></li>
<li><a href="../350392/index.html">Cuckoo 2.0. We collect the best open source platform for analyzing malicious files</a></li>
<li><a href="../350394/index.html">Network Device Detection</a></li>
<li><a href="../350396/index.html">Implement fast 2D shadows in Unity using 1D shadow mapping</a></li>
<li><a href="../350402/index.html">The most appropriate ways to learn new software</a></li>
<li><a href="../350406/index.html">Own data in the system crash dump of Windows</a></li>
<li><a href="../350408/index.html">Digitalization and reality. Should I change something?</a></li>
<li><a href="../350410/index.html">How to make the best sites in Russia</a></li>
<li><a href="../350412/index.html">Duke Nukem Forever, which was not</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>