<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Systemd logging control</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The systemd initialization daemon has already become a standard in modern Linux systems. Many popular distributions have switched to it: Debian, RHEL ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Systemd logging control</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/012/627/7bf/0126277bf4aaa8e605c7362739b267da.png" alt="Systemd journal" width="100%" height="100%"><br><br>  The systemd initialization daemon has already become a standard in modern Linux systems.  Many popular distributions have switched to it: Debian, RHEL / CentOS, Ubuntu (since version 15.04).  Systemd uses a fundamentally different (compared to the traditional syslog tool) logging approach. <br>  It is based on centralization: the specialized journal component collects all system messages (kernel messages, various services and applications).  In this case, there is no need to specifically configure sending logs: applications can simply write to stdout and stderr, a journal will save these messages automatically.  Working in this mode is possible with Upstart, but it saves all the logs in a separate file, while systemd saves them in a binary database, which greatly simplifies the systematization and search. <br><br>  Storing logs in binary files also avoids the difficulty of using parsers for different types of logs.  If necessary, the logs can easily be converted to other formats (more details will be given below). <br>  Journal can work both in conjunction with syslog, and completely replace it. <br>  The journalctl utility is used to view logs.  On the features and subtleties of working with her, we will discuss in this article. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Time setting </h2><br><br>  One of the major drawbacks of syslog is the preservation of records without regard to the time zone.  In journal, this deficiency is eliminated: for logged events, you can specify both local time and coordinated universal time (UTC).  Setting the time is done using the timedatectl utility. <br>  You can view the list of time zones using the command: <br><br><pre> $ timedatectl list-timezones
</pre><br><br>  Setting the desired time zone is as follows: <br><br><pre> $ timedatectl set-timezone &lt;time zone&gt;
</pre><br>  After the installation is complete, it will be useful to make sure that everything is done correctly: <br><br><pre> $ timedatectl status
 Local time: Thu 2015-07-30 11:24:15 MSK
 Universal time: Thu 2015-07-30 08:24:15 UTC
 RTC time: Thu 2015-07-30 08:24:15
 Time zone: Europe / Moscow (MSK, +0300)
 NTP enabled: no
 NTP synchronized: no
 RTC in local TZ: no
 DST active: n / a
</pre><br><br>  The very first line (Local time) should show the exact current time and date. <br><br><h2>  Journalctl: view logs </h2><br><br>  The journalctl utility is used to view logs. <br>  If you enter the journaltl command without any arguments, a huge list will be displayed on the console: <br><br><pre>
 - Logs begin at Wed 2015-07-29 17:12:48 MSK, end at Thu 2015-07-30 11:24:15 MSK.  -
 Jul 29 17:12:48 host-10-13-37-10 systemd-journal [181]: Runtime journal is using 4.0M (max allowed 20.0M, trying to leave 30.0M free of 195.9M available ‚Üí current limit 20.0M ).
 Jul 29 17:12:48 host-10-13-37-10 systemd-journal [181]: Runtime journal is using 4.0M (max allowed 20.0M, trying to leave 30.0M free of 195.9M available ‚Üí current limit 20.0M ).
 Jul 29 17:12:48 host-10-13-37-10 kernel: Initializing cgroup subsys cpuset
 Jul 29 17:12:48 host-10-13-37-10 kernel: Initializing cgroup subsys cpu
 Jul 29 17:12:48 host-10-13-37-10 kernel: Initializing cgroup subsys cpuacct
 Jul 29 17:12:48 host-10-13-37-10 kernel: Linux version 3.16.0-4-amd64 (debian-kernel@lists.debian.org) (gcc version 4.8.4 (Debian 4.8.4- 1)) # 1 SMP Debian 3.16.7-ckt11-1 + deb8u2 (2015-07-17)
 Jul 29 17:12:48 host-10-13-37-10 kernel: Command line: BOOT_IMAGE = / boot / vmlinuz-3.16.0-4-amd64 root = UUID = b67ea972-1877-4c5b-a328-29fc0d6c7bc4 ro console = tty1 console = ttyS0 video = 640x480 consoleblank = 0 panic = 15 c
</pre><br><br>  Here we have just a small fragment of it;  in fact, it includes a huge number of entries. <br><br><h2>  Log filtering </h2><br><br>  The journalctl utility has options with which you can filter logs and quickly extract the necessary information from them. <br><br><h3>  View logs since the current download </h3><br><br>  With the -b option, you can view all the logs collected since the last system boot: <br><br><pre> $ journalctl -b
</pre><br><br><h3>  View logs of previous sessions </h3><br><br>  Using journalctl, you can view information about previous sessions of work in the system - in some cases this can be useful. <br>  It should, however, be borne in mind that saving information about previous sessions is not supported by default in all Linux distributions.  Sometimes it is required to activate <br><br>  To do this, open the journald.conf configuration file, find the [Journal] section in it and change the value of the storage parameter to persistent: <br><br><pre> $ sudo nano /etc/systemd/journald.conf
 ...
 [Journal]
 Storage = persistent
</pre><br><br>  You can view a list of previous downloads using the command: <br><br><pre> $ journalctl --list-boots

 0 9346310348bc4edea250555dc046b30c Thu 2015-07-30 12:39:49 MSK ‚Äî Thu 2015-07-30 12:39:59 MSK
</pre><br><br>  Its output consists of four columns.  The first of them indicates the serial number of the download, the second - its ID, the third - the date and time.  To view the log for a specific download, you can use identifiers from both the first and second columns: <br><br><pre> $ journalctl -b 0
</pre><br><br>  or <br><br><pre> $ journalctl -b 9346310348bc4edea250555dc046b30c
</pre><br><br><h3>  Filter by date and time </h3><br><br>  The journalctl also has the ability to view logs for certain periods of time.  To do this, use the options ‚Äîsince and ‚Äìuntil.  Suppose we need to view the logs starting from 17 hours 15 minutes July 20, 2015.  To do this, you will need to run the command: <br><pre> $ journalctl --since "2015-07-20 17:15:00"
</pre><br><br>  If no date is specified with the since option, logs will be output to the console starting from the current date.  If the date is specified, but the time is not specified, the default time value ‚Äú00:00:00‚Äù will be applied.  Seconds are also optional (in this case, the default value is 00). <br><br>  You can use the following human-readable constructions: <br><br><pre> $ journalctl --- since yesterday
 $ journalctl --since 09:00 --until now
 $ journalctl --since 10:00 --until "1 hour ago"
</pre><br><br><h3>  Filtering by application and service </h3><br><br>  To view the logs of a particular application or service, use the -u option, for example: <br><br><pre> $ journalctl -u nginx.service
</pre><br><br>  The above command will log the nginx web server logs to the console. <br>  Often there is a need to review the logs of a service for a certain period of time.  This can be done with the help of the command: <br><br><pre> $ journalctl -u nginx.service --since yesterday
</pre><br><br>  The -u option also uses date and time filtering, for example: <br><br><pre> $ journalctl -u nginx.service -u php-fpm.service ‚Äîsince today
</pre><br><br>  This allows you to track the interaction of various services and to obtain information that could not be obtained when tracking the relevant processes separately. <br><br><h3>  Filter by process, user, and group </h3><br><br>  You can view logs for a process by entering its identification number (PID) on the journalctl command, for example: <br><pre> $ journalctl _PID = 381
</pre><br><br>  To view the logs of processes running on behalf of a specific user or group, use _UID and _GID filters, respectively.  Suppose we have a web server running on behalf of the user www-data.  We first define the ID of this user: <br><pre> $ id -u www-data

 33
</pre><br>  Now you can view the logs of all processes running on behalf of this user: <br><br><pre> $ journalctl _UID = 33
</pre><br><br>  The list of users about which there are entries in the logs can be output to the console as follows: <br><br><pre> $ journalctl -F _UID
</pre><br><br>  To view a similar list of user groups, use the command: <br><br><pre> $ journalctl -F _GUID
</pre><br><br>  You can use other filters with the command journalctl.  You can view a list of all available filters by running the command <br><pre> $ man systemd.journal-fields
</pre><br><br><h3>  Filtering along the way </h3><br><br>  You can also view logs for a process by specifying the path to it, for example: <br><br><pre> $ journalctl / usr / bin / docker
</pre><br><br>  Sometimes this way you can get more detailed information (for example, view the records for all child processes). <br><br><h3>  View kernel messages </h3><br><br>  To view kernel messages, use the -k or ‚àí‚àídmesg option: <br><br><pre> $ journalctl -k
</pre><br><br>  The following command will show all kernel messages for the current boot.  To view kernel messages for previous sessions, use the -b option and specify one of the session identifiers (sequence number in the list or ID): <br><br><pre> $ journalctl -k -b -2
</pre><br><br><h3>  Error message filtering </h3><br><br>  While diagnosing and fixing problems in the system, it is often necessary to review the logs and find out if there are any critical error messages in them.  Especially for this journalctl provides the ability to filter by error level.  You can view messages about all errors that occurred in the system using the -p option: <br><br><pre> $ journalctl -p err -b
</pre><br><br>  The above command will show all error messages that occurred in the system. <br><br>  These messages can be filtered by level.  The journal uses the same classification of error levels as syslog: <br><br><ul><li>  0 - EMERG (system is inoperable); </li><li>  1 - ALERT (immediate intervention required); </li><li>  2 - CRIT (critical condition); </li><li>  3 - ERR (error); </li><li>  4 - WARNING (warning); </li><li>  5 - NOTICE (everything is fine, but you should pay attention); </li><li>  6 - INFO (announcement); </li><li>  7 ‚ÄîDEBUG (delayed printing). </li></ul><br><br>  Error level codes are specified after the -p option. <br><br><h2>  Logging to standard output </h2><br><br>  By default, journalctl uses the external utility less to display log messages.  In this case, it is impossible to apply standard utilities for processing text data (for example, grep) to them.  This problem is easily solved: just use the ‚àí‚àíno-pager option, and all messages will be written to the standard output: <br><br><pre> $ journalctl --no-pager
</pre><br><br>  After that they can be transferred to other utilities for further processing or saved in a text file. <br><br><h2>  Select output format </h2><br><br>  Using the -o option, you can convert the log data into various formats, which makes it easier to parse and further processing, for example: <br><br><pre> $ journalctl -u nginx.service -o json

 { "__CURSOR": "s = 13a21661cf4948289c63075db6c25c00; i = 116f1; b = 81b58db8fd9046ab9f847ddb82a2fa2d; m = 19f0daa; t = 50e33c33587ae; x = e307daadb4858635", "__REALTIME_TIMESTAMP": "1422990364739502", "__MONOTONIC_TIMESTAMP": "27200938", "_BOOT_ID" "81b58db8fd9046ab9f847ddb82a2fa2d", "PRIORITY": "6", "_UID": "0", "_GID": "0", _ _:::::::::::::::::::,,,,,: c c desktop "," SYSLOG_FACILITY ":" 3 "," CODE_FILE ":" src / core / unit.c "," CODE_LINE ":" 1402 "," CODE_FUNCTION ":" unit_status_log_starting_stopping_reloading "," SYSLOG_IDENTIFIER ":" d d d d ing _ _ pping pping re:: "system system" "d art art SY SY SY SY SY SY SY SY art art art SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY SY" SYSLOG_FACILITY " MESSAGE_ID ":" 7d4958e842da4a758f6c1cdc7b36dcc5 "," _TRANSPORT ":" journal "," _PID ":" 1 "," _COMM ":" systemd "," _EXE ":" / usr / lib / systemd / systemd "," _CMDLINE ":" / usr / lib / systemd / systemd "," _CMDLLE "_CMM": " "/ usr / lib / systemd / systemd", "_SYSTEMD_CGROUP": "/", "UNIT": "nginx.service", "MESSAGE": "Starting a high performance web server and reverse proxy server ...", "_SOURCE_REALTIME_TIMESTAMP": "1422990364737973"}
</pre><br><br>  The json object can be represented in a more structured and human-readable form, specifying the format json-pretty or json-sse: <br><br><pre> $ journalctl -u nginx.service -o json-pretty

 {
     "__CURSOR": "s = 13a21661cf4948289c63075db6c25c00; i = 116f1; b = 81b58db8fd9046ab9f847ddb82a2fa2d; m = 19f0daa; t = 50e33c33587ae; x = e307daadb4858635",
     "__REALTIME_TIMESTAMP": "1422990364739502",
     "__MONOTONIC_TIMESTAMP": "27200938",
     "_BOOT_ID": "81b58db8fd9046ab9f847ddb82a2fa2d",
     "PRIORITY": "6",
     "_UID": "0",
     "_GID": "0",
     "_CAP_EFFECTIVE": "3fffffffff",
     "_MACHINE_ID": "752737531a9d1a9c1e3cb52a4ab967ee",
     "_HOSTNAME": "desktop",
     "SYSLOG_FACILITY": "3",
     "CODE_FILE": "src / core / unit.c",
     "CODE_LINE": "1402",
     "CODE_FUNCTION": "unit_status_log_starting_stopping_reloading",
     "SYSLOG_IDENTIFIER": "systemd",
     "MESSAGE_ID": "7d4958e842da4a758f6c1cdc7b36dcc5",
     "_TRANSPORT": "journal",
     "_PID": "1",
     "_COMM": "systemd",
     "_EXE": "/ usr / lib / systemd / systemd",
     "_CMDLINE": "/ usr / lib / systemd / systemd",
     "_SYSTEMD_CGROUP": "/",
     "UNIT": "nginx.service",
     "MESSAGE": "Starting A high performance web server and reverse proxy server ...",
     "_SOURCE_REALTIME_TIMESTAMP": "1422990364737973"
 }
</pre><br><br>  In addition to JSON, log data can be converted to the following formats: <br><br><ul><li>  cat - only messages from logs without service fields; </li><li>  export - binary format, suitable for exporting or backing up logs; </li><li>  short - syslog output format; </li><li>  short-iso - syslog output format with time stamps in ISO 8601 format; </li><li>  short-monotonic ‚Äî syslog output format with monotonic timestamps; </li><li>  short-precise ‚Äî syslog output format with accurate time stamps (the time of events is specified with an accuracy of microseconds); </li><li>  verbose - the most detailed format of the data (includes even those fields that are not displayed in other formats). </li></ul><br><br><h2>  View information about recent events </h2><br><br>  The option -n is used to view information about recent events in the system: <br><br><pre> $ journalctl -n
</pre><br><br>  By default, the console displays information about the last 10 events.  With the -n option, you can specify the required number of events: <br><br><pre> $ journalctl -n 20
</pre><br><br><h2>  View logs in real time </h2><br><br>  Messages from logs can be viewed not only in the form of saved files, but also in real time.  To do this, use the -f option: <br><br><pre> $ journalctl -f 
</pre><br><br><h2>  Logging control </h2><br><br><h3>  Determining the current log volume </h3><br><br>  Over time, the volume of logs grows, and they take up more and more space on the hard disk.  You can find out the amount of currently available logs using the command: <br><br><pre> $ journalctl --disk-usage
 Journals take up 16.0M on disk.
</pre><br><br><h3>  Log rotation </h3><br><br>  Setting the rotation of the logs is carried out using the options ‚àí‚àí vacuum-size and ‚àí‚àí vacuum-time. <br>  The first of these sets the maximum allowable size for logs stored on disk (in our example, 1 GB): <br><br><pre> $ sudo journalctl --vacuum-size = 1G
</pre><br><br>  As soon as the volume of logs exceeds the specified figure, the extra files will be automatically deleted. <br>  The ‚àí‚àíacacuum-time option works in a similar way.  It sets a retention period for logs, after which they will be automatically deleted: <br><br><pre> $ sudo journalctl --vacuum-time = 1years
</pre><br><br><h3>  Setting the rotation logs in the configuration file </h3><br><br>  Log rotation settings can also be specified in the /tc/systemd/journald.conf configuration file, which includes the following parameters, among others: <br><br><ul><li>  SystemMaxUse = maximum amount that logs can occupy on disk; </li><li>  SystemKeepFree = amount of free space that should remain on the disk after saving logs; </li><li> SystemMaxFileSize = size of the log file, after which it should be removed from the disk; </li><li>  RuntimeMaxUse = maximum amount that logs can occupy in the / run file system; </li><li>  RuntimeKeepFree = amount of free space that should remain in the / run file system after saving logs; </li><li>  RuntimeMaxFileSize = size of the log file, after reaching which it should be removed from the / run file system. </li></ul><br><br><h2>  Central storage of logs </h2><br><br>  One of the most common tasks in the work of the system administrator is to configure the collection of logs from several machines and then place them in a centralized storage. <br>  Systemd has special components for this task: <a href="http://www.freedesktop.org/software/systemd/man/systemd-journal-remote.html" rel="nofollow">systemd-journal-remote</a> , <a href="http://www.freedesktop.org/software/systemd/man/systemd-journal-upload.html" rel="nofollow">systemd-journal-upload</a> and <a href="http://www.freedesktop.org/software/systemd/man/systemd-journal-gatewayd.service.html">systemd-journal-gatewayd</a> . <br><br>  Using the systemd-journal-remote command, you can receive logs from remote hosts and save them (the systemd-journal-gatewayd daemon must be running on each of these hosts), for example: <br><br><pre> $ systemd-journal-remote ‚àí‚àíurl https://some.host:19531/
</pre><br><br>  As a result of executing the above command, logs from the host <a href="https://some.host/">some.host</a> will be saved in the var / log / journal / some.host / remote-some ~ host.journal directory. <br><br>  Using the systemd-journal-remote command, you can also add the logs on the local machine to a separate directory, for example: <br><br><pre> $ journalctl -o export |  systemd-journal-remote -o / tmp / dir -
</pre><br><br>  The systemd-journal-upload command is used to upload logs from a local machine to a remote repository: <br><br><pre> $ systemd-journal-upload --url https://some.host:19531/
</pre><br><br>  As can be seen from the above examples, the systemd native utilities for supporting centralized logging are simple and easy to use.  But, unfortunately, they are far from being included in all distributions, but only in Fedora and ArchLinux. <br><br>  Users of other distributions so far have to send logs to syslog or rsyslog, which then send them over the network.  Another solution to the problem of centralized logging was suggested by the developers of the <a href="https://github.com/systemd/journal2gelf" rel="nofollow">journal2gelf</a> utility included in the systemd official repository: the journaltl output in JSON format is converted to GELF format and then transferred to the application for collecting and analyzing Graylog logs.  The solution is not very convenient, but nothing better can be invented in the current situation.  It remains only to wait for the "native" components to be added to all distributions. <br><br><h2>  Conclusion </h2><br><br>  As can be seen from the review done, the systemd journal is a flexible and convenient tool for collecting system and application data.  A high level of flexibility and convenience was achieved, firstly, due to the centralized approach to logging, and secondly, thanks to the automatic writing of detailed metadata to the logs.  Using journalctl, you can view logs, getting the necessary information to analyze the work and debug various system components. <br>  If you have questions and additions - welcome to comments.  The discussion about systemd and its components will be continued in the following publications. <br><br>  Readers who for one reason or another can not leave comments here are invited to <a href="http://blog.selectel.ru/upravlenie-loggirovaniem-v-systemd/">our blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/264731/">https://habr.com/ru/post/264731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264717/index.html">Can I rely on data retrieved by the WMI classes?</a></li>
<li><a href="../264719/index.html">jQuery Video Extend - extending the capabilities of HTML5 video player</a></li>
<li><a href="../264723/index.html">Cryptocurrency developers - who are they? [Interview]</a></li>
<li><a href="../264725/index.html">ReactPHP speeds up PHPixie 8 times</a></li>
<li><a href="../264727/index.html">Security Week 33: Doors Without Locks, Microsoft Invulnerability, Disassembler and Pain</a></li>
<li><a href="../264735/index.html">Five signs that you should hire this programmer right now</a></li>
<li><a href="../264737/index.html">Talking to FPConf speakers (part 2)</a></li>
<li><a href="../264739/index.html">Who is better or Walsh vs. Fourier</a></li>
<li><a href="../264741/index.html">How to become a cool designer for 365 days</a></li>
<li><a href="../264743/index.html">Fresh sections for the 2nd quarter of the popularity of CMS-systems, meters / systems analytics and online consultants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>