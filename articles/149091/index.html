<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python captcha decoding</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This translation and form of the narrative from the first person saved. Written by Ben Boyter, Bachelor of Information Technology at Charles Sturt Uni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python captcha decoding</h1><div class="post__text post__text-html js-mediator-article">  <i>This translation and form of the narrative from the first person saved.</i>  <i>Written by Ben Boyter, Bachelor of Information Technology at Charles Sturt University (CSU).</i> <br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/4ec/41a/434/4ec41a43455c51563751390a1c18d90b.jpg"><br><br>  Most people do not know, but my dissertation was a program for reading text from an image.  I thought that if I could get a high level of recognition, it could be used to improve search results.  My excellent adviser, <a href="http://csusap.csu.edu.au/~jbgao/">Dr. Gao Junbin,</a> suggested that I write a dissertation on this topic.  I finally found the time to write this article and here I will try to tell about everything that I learned.  If only there was something like that when I was just starting ... <br><br>  As I said, I tried to take ordinary images from the Internet and extract text from them to improve search results.  Most of my ideas were based on captcha hacking methods.  As everyone knows, captcha is the most annoying thing, like ‚ÄúEnter the letters you see on the image‚Äù on the registration or feedback pages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Captcha is designed so that a person can read the text without difficulty, while the machine is not (hello, reCaptcha!).  In practice, this never worked, since almost every captcha that was posted on the site was hacked for several months. <br><br>  I did quite well - more than 60% of the images were successfully guessed from my small collection.  Pretty good, given the number of different images on the Internet. <br><br><a name="habracut"></a><br><br>  In my research, I did not find any materials that would help me.  Yes, there are articles, but they contain very simple algorithms.  In fact, I found some non-working examples in PHP and Perl, I took several fragments from them and got quite good results for a very simple captcha.  But none of them helped me much, since it was too easy.  I am one of those people who can read the theory, but can not understand anything without real examples.  And in most articles it was written that they will not publish the code, because they are afraid that it will be used for bad purposes.  Personally, I think that captcha is a waste of time, because it's pretty easy to get around if you know how. <br><br>  Actually because of the lack of any materials showing the breaking of the captcha for beginners, I wrote this article. <br><br>  Let's start.  Here is a list of what I am going to cover in this article: <br><br><ul><li>  Used technologies </li><li>  What is a captcha </li><li>  How to find and extract text from images </li><li>  Image recognition using AI </li><li>  Training </li><li>  Putting it all together </li><li>  Results and conclusions </li></ul><br><br><h4>  Used technologies </h4><br>  All examples are written in Python 2.5 using the PIL library.  It should work in Python 2.6 (under Python 2.7.3 it runs fine, <i>approx. Transl.</i> ). <br><br><ul><li>  Python: <a href="http://www.python.org/">www.python.org</a> </li><li>  PIL: <a href="http://www.pythonware.com/products/pil/">www.pythonware.com/products/pil</a> </li></ul><br><br>  Install them in the order shown above and you are ready to run the examples. <br><br><h4>  Retreat </h4><br>  In the examples, I will hard-code the set of values ‚Äã‚Äãright in the code.  I have no goal to create a universal captcha recognizer, but only to show how this is done. <br><br><h4>  Captcha, what is it in the end? </h4><br><br>  Basically, captcha is an example of one-way conversion.  You can easily take a character set and get a captcha out of it, but not vice versa.  Another subtlety is that it should be simple for a person to read, but not be machine recognized.  Captcha can be considered as a simple test like "Are you human?".  Basically they are implemented as an image with some kind of characters or words. <br><br>  They are used to prevent spam on many Internet sites.  For example, captcha can be found on the registration page in <a href="http:%252F%252Fmail.live.com%252Fdefault.aspx%26lc%3D2057%26id%3D64855%26mkt%3Den-GB%26bk%3D1242258418%26rollrs%3D12%26lic%3D1">Windows Live ID</a> . <br><br>  You are shown an image, and, if you are really a person, then you need to enter its text in a separate field.  Seems like a good idea that can protect you from thousands of automatic registrations for the purpose of spamming or spreading Viagra on your forum?  The problem is that AI, and in particular, image recognition methods have undergone significant changes and become very effective in certain areas.  OCR (Optical Character Recognition) is fairly accurate today and easily recognizes printed text.  It was decided to add a little color and lines to make it harder for the computer to work without inconvenience to users.  This is a kind of arms race and, as usual, they come up with a stronger weapon for any defense.  Defeating the enhanced captcha is more difficult, but still possible.  Plus, the image should remain fairly simple, so as not to cause irritation in ordinary people. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e53/202/f62/e53202f6201746ea32026e1049c8653b.gif" alt="image"><br><br>  This image is an example of a captcha that we will decode.  This is a real captcha, which is posted on a real site. <br><br>  This is a fairly simple captcha, which consists of characters of the same color and size on a white background with some noise (pixels, colors, lines).  You think that this background noise makes it difficult to recognize, but I will show how easy it is to remove it.  Although it is not a very strong captcha, it is a good example for our program. <br><br><h4>  How to find and extract text from images </h4><br><br>  There are many methods for determining the position of text on an image and extracting it.  With Google, you can find thousands of articles that explain new methods and algorithms for finding text. <br><br>  For this example, I will use color extraction.  This is a fairly simple technique, with which I got pretty good results.  I used this technique for my dissertation. <br><br>  For our examples, I will use a multi-valued image decomposition algorithm.  In essence, this means that we first build a histogram of the color of the image.  This is done by obtaining all the pixels in the image grouped by color, after which they are counted for each group.  If you look at our test captcha, you can see three primary colors: <br><br><ul><li>  White background) </li><li>  Gray (noise) </li><li>  Red (text) </li></ul><br><br>  In Python, this will look very simple. <br><br>  The following code opens the image, converts it into a GIF (makes it easier for us to work, because there are only 255 colors in it) and prints a histogram of colors. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image im = Image.open(<span class="hljs-string"><span class="hljs-string">"captcha.gif"</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> im.histogram()</code> </pre> <br><br>  As a result, we get the following: <br><br><pre> <code class="bash hljs">[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0 , 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 1, 2, 0, 1, 0, 0, 1, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 3, 1, 3, 3, 0, 0, 0, 0, 0, 0, 1, 0, 3, 2, 132, 1, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 15, 0 , 1, 0, 1, 0, 0, 8, 1, 0, 0, 0, 0, 1, 6, 0, 2, 0, 0, 0, 0, 18, 1, 1, 1, 1, 1, 2, 365, 115, 0, 1, 0, 0, 0, 135, 186, 0, 0, 1, 0, 0, 0, 116, 3, 0, 0, 0, 0, 0, 21, 1, 1, 0, 0, 0, 2, 10, 2, 0, 0, 0, 0, 2, 10, 0, 0, 0, 0, 1, 0, 625]</code> </pre><br><br>  Here we see the number of pixels of each of the 255 colors in the image.  You can see that white (255, the most recent) occurs most often.  Behind him comes the red (text).  To verify this, write a small script: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> operator <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> itemgetter im = Image.open(<span class="hljs-string"><span class="hljs-string">"captcha.gif"</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) his = im.histogram() values = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">256</span></span>): values[i] = his[i] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j,k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(values.items(), key=itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>), reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> j,k</code> </pre><br><br>  And we get the following data: <br><br><table><tbody><tr><th>  Colour </th><th>  Number of pixels </th></tr><tr><td>  255 </td><td>  625 </td></tr><tr><td>  212 </td><td>  365 </td></tr><tr><td>  220 </td><td>  186 </td></tr><tr><td>  219 </td><td>  135 </td></tr><tr><td>  169 </td><td>  132 </td></tr><tr><td>  227 </td><td>  116 </td></tr><tr><td>  213 </td><td>  115 </td></tr><tr><td>  234 </td><td>  21 </td></tr><tr><td>  205 </td><td>  18 </td></tr><tr><td>  184 </td><td>  15 </td></tr></tbody></table><br><br>  This is a list of the 10 most common colors in an image.  As expected, white is repeated most often.  Then go gray and red. <br><br>  As soon as we receive this information, we create new images based on these color groups.  For each of the most common colors, we create a new binary image (of 2 colors), where the pixels of this color are filled with black, and everything else is white. <br><br>  Red here is the third most common color, which means that we want to save a group of pixels with a color of 220. When I experimented, I found that the color 227 is pretty close to 220, so we will save this group of pixels.  The code below opens the captcha, converts it into a GIF, creates a new image of the same size with a white background, and then walks around the original image in search of the color we need.  If it finds a pixel with the color we need, then it marks the same pixel in the second image in black.  Before shutting down, the second image is saved. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image im = Image.open(<span class="hljs-string"><span class="hljs-string">"captcha.gif"</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) im2 = Image.new(<span class="hljs-string"><span class="hljs-string">"P"</span></span>,im.size,<span class="hljs-number"><span class="hljs-number">255</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) temp = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(im.size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(im.size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): pix = im.getpixel((y,x)) temp[pix] = pix <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pix == <span class="hljs-number"><span class="hljs-number">220</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pix == <span class="hljs-number"><span class="hljs-number">227</span></span>: <span class="hljs-comment"><span class="hljs-comment"># these are the numbers to get im2.putpixel((y,x),0) im2.save("output.gif")</span></span></code> </pre><br><br>  Running this code snippet gives us the following result. <br><br><table><tbody><tr><td>  Original </td><td>  Result </td></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e53/202/f62/e53202f6201746ea32026e1049c8653b.gif" alt="image"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/58f/235/dd2/58f235dd265db90a3b05a8a2ebcf6585.gif" alt="image"></td></tr></tbody></table><br><br>  In the picture you can see that we have successfully managed to extract text from the background.  To automate this process, you can combine the first and second script. <br><br>  I hear you ask: "What if the captcha text is written in different colors?".  Yes, our equipment can still work.  Assume that the most common color is the background color and then you can find the colors of the characters. <br><br>  Thus, at the moment we have successfully extracted the text from the image.  The next step is to determine if the image contains text.  For the time being, I will not write code here, since this will make understanding difficult, while the algorithm itself is quite simple. <br><br><pre> <code class="html hljs xml">for each binary image: for each pixel in the binary image: if the pixel is on: if any pixel we have seen before is next to it: add to the same set else: add to a new set</code> </pre><br><br>  At the exit you will have a set of character boundaries.  Then all you need to do is to compare them with each other and see if they are going consistently.  If yes, then you fell the jackpot and you correctly identified the characters coming along.  You can also check the size of the resulting areas or simply create a new image and show it (the <code>show()</code> method on the image) to make sure the algorithm is accurate. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image im = Image.open(<span class="hljs-string"><span class="hljs-string">"captcha.gif"</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) im2 = Image.new(<span class="hljs-string"><span class="hljs-string">"P"</span></span>,im.size,<span class="hljs-number"><span class="hljs-number">255</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) temp = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(im.size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(im.size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): pix = im.getpixel((y,x)) temp[pix] = pix <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pix == <span class="hljs-number"><span class="hljs-number">220</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pix == <span class="hljs-number"><span class="hljs-number">227</span></span>: <span class="hljs-comment"><span class="hljs-comment"># these are the numbers to get im2.putpixel((y,x),0) # new code starts here inletter = False foundletter=False start = 0 end = 0 letters = [] for y in range(im2.size[0]): # slice across for x in range(im2.size[1]): # slice down pix = im2.getpixel((y,x)) if pix != 255: inletter = True if foundletter == False and inletter == True: foundletter = True start = y if foundletter == True and inletter == False: foundletter = False end = y letters.append((start,end)) inletter=False print letters</span></span></code> </pre><br><br>  As a result, we did the following: <br><br><pre> <code class="python hljs">[(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>), (<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>), (<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>), (<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>), (<span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">56</span></span>), (<span class="hljs-number"><span class="hljs-number">57</span></span>, <span class="hljs-number"><span class="hljs-number">67</span></span>)]</code> </pre><br><br>  These are horizontal positions at the beginning and end of each character. <br><br><h4>  AI and vector space in pattern recognition </h4><br><br>  Image recognition can be considered the greatest success of modern AI, which allowed it to penetrate into all types of commercial applications.  A good example of this is zip codes.  In fact, in many countries they are read automatically, since it is quite simple to teach a computer to recognize numbers.  This may not be obvious, but pattern recognition is considered an AI problem, albeit a very highly specialized one. <br><br>  Almost the first thing that neural networks encounter when meeting with AI in pattern recognition.  Personally, I have never had success with neural networks in character recognition.  I usually teach him 3-4 characters, after which the accuracy drops so low that it would be an order of magnitude higher, if I guess the characters at random.  At first, this caused me a slight panic, since this was the missing link in my dissertation.  Fortunately, I recently read an article about vector-space search engines and considered them an alternative method of data classification.  In the end, they turned out to be the best choice, since <br><br><ol><li>  They do not require extensive study. </li><li>  You can add / remove incorrect data and immediately see the result. </li><li>  They are easier to understand and program. </li><li>  They provide classified results so you can see the top X matches. </li><li>  Can't recognize something?  Add this and you can recognize it instantly, even if it is completely different from something seen before. </li></ol><br><br>  Of course, there is no free cheese.  The main drawback in speed.  They can be much slower than neural networks.  But I think that their advantages still outweigh this disadvantage. <br><br>  If you want to understand how the vector space works, then I advise you to read <a href="http://la2600.org/talks/files/20040102/Vector_Space_Search_Engine_Theory.pdf">Vector Space Search Engine Theory</a> .  This is the best I've found for beginners. <br><br>  I built my image recognition based on the aforementioned document and this was the first thing I tried to write on my favorite PL, which I was studying at the time.  Read this document and how you will understand its essence - come back here. <br><br>  Have you already returned?  Good.  Now we have to program our vector space.  Fortunately, it is not difficult at all.  Let's get started <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VectorCompare</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magnitude</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,concordance)</span></span></span><span class="hljs-function">:</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word,count <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> concordance.iteritems(): total += count ** <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> math.sqrt(total) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">relation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,concordance1, concordance2)</span></span></span><span class="hljs-function">:</span></span> relevance = <span class="hljs-number"><span class="hljs-number">0</span></span> topvalue = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word, count <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> concordance1.iteritems(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> concordance2.has_key(word): topvalue += count * concordance2[word] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))</code> </pre><br><br>  This is the implementation of Python vector space in 15 lines.  Essentially, it simply takes 2 dictionaries and returns a number from 0 to 1, indicating how they are related.  0 means that they are not related, and 1 means that they are identical. <br><br><h4>  Training </h4><br>  The next thing we need is a set of images with which we will compare our characters.  We need a training set.  This set can be used to train any kind of AI that we will use (neural networks, etc.). <br><br>  The data used can be crucial for the success of recognition.  The better the data, the greater the chance of success.  Since we are planning to recognize a specific captcha and can already extract symbols from it, why not use them as a training set? <br><br>  This is what I did.  I downloaded a lot of generated captchas and my program broke them into letters.  Then I collected the images in the collection (group).  After several attempts, I had at least one example of each character that a captcha generated.  Adding more examples will improve the recognition accuracy, but this was enough for me to confirm my theory. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time im = Image.open(<span class="hljs-string"><span class="hljs-string">"captcha.gif"</span></span>) im2 = Image.new(<span class="hljs-string"><span class="hljs-string">"P"</span></span>,im.size,<span class="hljs-number"><span class="hljs-number">255</span></span>) im = im.convert(<span class="hljs-string"><span class="hljs-string">"P"</span></span>) temp = {} <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> im.histogram() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(im.size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(im.size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): pix = im.getpixel((y,x)) temp[pix] = pix <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pix == <span class="hljs-number"><span class="hljs-number">220</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pix == <span class="hljs-number"><span class="hljs-number">227</span></span>: <span class="hljs-comment"><span class="hljs-comment"># these are the numbers to get im2.putpixel((y,x),0) inletter = False foundletter=False start = 0 end = 0 letters = [] for y in range(im2.size[0]): # slice across for x in range(im2.size[1]): # slice down pix = im2.getpixel((y,x)) if pix != 255: inletter = True if foundletter == False and inletter == True: foundletter = True start = y if foundletter == True and inletter == False: foundletter = False end = y letters.append((start,end)) inletter=False # New code is here. We just extract each image and save it to disk with # what is hopefully a unique name count = 0 for letter in letters: m = hashlib.md5() im3 = im2.crop(( letter[0] , 0, letter[1],im2.size[1] )) m.update("%s%s"%(time.time(),count)) im3.save("./%s.gif"%(m.hexdigest())) count += 1</span></span></code> </pre><br><br>  At the output we get a set of images in the same directory.  Each of them is assigned a unique hash in case you will process several captchas. <br>  Here is the result of this code for our test captcha: <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/446/2e0/ff0/4462e0ff0552fe20df238245c18c13c7.gif"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/698/f17/9e9/698f179e907aa88070c5df54c3becbf1.gif"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/eea/342/df8/eea342df8364e620ccb1ef099c246726.gif"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/da4/696/97f/da469697ff467d7e615262f5d2f90c92.gif"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/8ab/815/c74/8ab815c74bd8ff50419a8c8bfe859060.gif"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/73e/830/830/73e830830f5fb6a41833f7a3fb714ed5.gif"></td></tr></tbody></table><br><br>  You decide how to store these images, but I just put them in directories with the same name as in the image (symbol or number). <br><br><h4>  Putting it all together </h4><br>  Last step.  We have text extraction, character extraction, recognition technique and a training set. <br><br>  We get the image of a captcha, select the text, get the characters, and then comparing them with our training set.  You can download the final program with a training set and a small amount of captchas <a href="">from this link</a> . <br><br>  Here we simply load the training set to be able to compare with it: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildvector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(im)</span></span></span><span class="hljs-function">:</span></span> d1 = {} count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> im.getdata(): d1[count] = i count += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d1 v = VectorCompare() iconset = [<span class="hljs-string"><span class="hljs-string">'0'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>,<span class="hljs-string"><span class="hljs-string">'2'</span></span>,<span class="hljs-string"><span class="hljs-string">'3'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>,<span class="hljs-string"><span class="hljs-string">'5'</span></span>,<span class="hljs-string"><span class="hljs-string">'6'</span></span>,<span class="hljs-string"><span class="hljs-string">'7'</span></span>,<span class="hljs-string"><span class="hljs-string">'8'</span></span>,<span class="hljs-string"><span class="hljs-string">'9'</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>,<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>,<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>,<span class="hljs-string"><span class="hljs-string">'g'</span></span>,<span class="hljs-string"><span class="hljs-string">'h'</span></span>,<span class="hljs-string"><span class="hljs-string">'i'</span></span>,<span class="hljs-string"><span class="hljs-string">'j'</span></span>,<span class="hljs-string"><span class="hljs-string">'k'</span></span>,<span class="hljs-string"><span class="hljs-string">'l'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'n'</span></span>,<span class="hljs-string"><span class="hljs-string">'o'</span></span>,<span class="hljs-string"><span class="hljs-string">'p'</span></span>,<span class="hljs-string"><span class="hljs-string">'q'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'s'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-string"><span class="hljs-string">' u'</span></span>,<span class="hljs-string"><span class="hljs-string">'v'</span></span>,<span class="hljs-string"><span class="hljs-string">'w'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>,<span class="hljs-string"><span class="hljs-string">'y'</span></span>,<span class="hljs-string"><span class="hljs-string">'z'</span></span>] imageset = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iconset: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> img <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.listdir(<span class="hljs-string"><span class="hljs-string">'./iconset/%s/'</span></span>%(letter)): temp = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> img != <span class="hljs-string"><span class="hljs-string">"Thumbs.db"</span></span>: temp.append(buildvector(Image.open(<span class="hljs-string"><span class="hljs-string">"./iconset/%s/%s"</span></span>%(letter,img)))) imageset.append({letter:temp})</code> </pre><br><br>  And here all the magic happens.  We determine where each character is and check it with our vector space.  Then sort the results and print them. <br><br><pre> <code class="python hljs">count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> letters: m = hashlib.md5() im3 = im2.crop(( letter[<span class="hljs-number"><span class="hljs-number">0</span></span>] , <span class="hljs-number"><span class="hljs-number">0</span></span>, letter[<span class="hljs-number"><span class="hljs-number">1</span></span>],im2.size[<span class="hljs-number"><span class="hljs-number">1</span></span>] )) guess = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> image <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> imageset: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x,y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> image.iteritems(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(y) != <span class="hljs-number"><span class="hljs-number">0</span></span>: guess.append( ( v.relation(y[<span class="hljs-number"><span class="hljs-number">0</span></span>],buildvector(im3)),x) ) guess.sort(reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>,guess[<span class="hljs-number"><span class="hljs-number">0</span></span>] count += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br><h4>  findings </h4><br>  Now we have everything we need and we can try to start our wonderful machine. <br><br>  The input file is <code>captcha.gif</code> .  Expected Result: <code>7s9t9j</code> <br><br><pre> <code class="bash hljs">python crack.py (0.96376811594202894, <span class="hljs-string"><span class="hljs-string">'7'</span></span>) (0.96234028545977002, <span class="hljs-string"><span class="hljs-string">'s'</span></span>) (0.9286884286888929, <span class="hljs-string"><span class="hljs-string">'9'</span></span>) (0.98350370609844473, <span class="hljs-string"><span class="hljs-string">'t'</span></span>) (0.96751165072506273, <span class="hljs-string"><span class="hljs-string">'9'</span></span>) (0.96989711688772628, <span class="hljs-string"><span class="hljs-string">'j'</span></span>)</code> </pre><br><br>  Here we see the intended symbol and the degree of confidence that it really is (from 0 to 1). <br><br>  It looks like we really did it! <br><br>  In fact, on test captchas, this script will produce a successful result in about 22% of cases (I got 28.5, <i>approx. Transl.</i> ). <br><br><pre> <code class="bash hljs">python crack_test.py Correct Guesses - 11.0 Wrong Guesses - 37.0 Percentage Correct - 22.9166666667 Percentage Wrong - 77.0833333333</code> </pre><br><br>  Most of the incorrect results are due to incorrect recognition of the number "0" and the letter "O".  There is nothing unexpected, because even people often confuse them.  We still have a problem with breaking into characters, but this can be solved simply by checking the result of the split and finding a middle ground. <br><br>  However, even with such a not very perfect algorithm, we can solve every fifth captcha in a time where a person would not have had time to solve one. <br><br>  Running this code on the Core 2 Duo E6550 gives the following results: <br><br><pre> <code class="bash hljs">real 0m5.750s user 0m0.015s sys 0m0.000s</code> </pre><br><br>  <b><i>From the translator.</i></b>  I got the following results on the Dual Core T4400: <br><br><pre> <code class="bash hljs">real 0m0.176s user 0m0.160s sys 0m0.012s</code> </pre><br><br>  There are 48 captchas in our catalog, which means that solving one takes about 0.12 seconds.  With our 22% percent of successful guessing, we can guess about 432,000 captcha per day and get 95,040 correct results.  And if you use multithreading? <br><br>  That's all.  I hope that my experience will be used by you for good purposes.  I know that you can use this code to the detriment, but to make something really dangerous you must change it quite a bit. <br><br>  For those who are trying to protect themselves with captcha, I can say that it will not help you much, because you can bypass them programmatically or simply pay other people who will solve them manually.  Think over other ways of protection. </div><p>Source: <a href="https://habr.com/ru/post/149091/">https://habr.com/ru/post/149091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149082/index.html">Free JavaScript Books</a></li>
<li><a href="../149085/index.html">One of the methods of working with configuration files in C ++ (Qt)</a></li>
<li><a href="../149086/index.html">Pure and deterministic functions</a></li>
<li><a href="../149087/index.html">Automating the build project in Sublime Text 2 using Ant</a></li>
<li><a href="../149090/index.html">Want to be an iOS developer? Be it!</a></li>
<li><a href="../149092/index.html">7 minutes of horror</a></li>
<li><a href="../149093/index.html">From Facebook - to Livejournal, Twitter & Vkontakte, crossposting in source codes and comments</a></li>
<li><a href="../149094/index.html">We take out from the chest Native Shell</a></li>
<li><a href="../149095/index.html">RIM is going to license BlackBerry OS for third-party developers</a></li>
<li><a href="../149096/index.html">I probably know OOP. Experience in object-oriented programming and design. The answer is "not knowing OOP."</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>