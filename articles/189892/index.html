<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Third check of the Chromium project code using the PVS-Studio analyzer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chromium browser is developing very quickly. For example, when in 2011 we checked this project for the first time (solution), it consisted of 473 proj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Third check of the Chromium project code using the PVS-Studio analyzer</h1><div class="post__text post__text-html js-mediator-article">  Chromium browser is developing very quickly.  For example, when in 2011 we checked this project for the first time (solution), it consisted of 473 projects.  Now, it already consists of 1169 projects.  We wondered if the Google developers were able to maintain the highest quality of the code, at this speed of Chromium development.  Yes, they could. <br><a name="habracut"></a><br><h2>  Chromium </h2><br>  Chromium is an open source web browser developed by Google.  Chromium is based on the Google Chrome browser.  On the page " <a href="http://www.viva64.com/go.php%3Furl%3D1191">Get the Code</a> " you can learn how to download the source code of this project. <br><br><h2>  Some general information </h2><br>  Previously, we have already checked the project Chromium, about which there are two articles: the <a href="http://www.viva64.com/ru/a/0074/">first check</a> (05/23/2011), the <a href="http://www.viva64.com/ru/b/0113/">second check</a> (10/13/2011).  And all the time they found mistakes.  This is a subtle hint about the benefits of code analyzers. <br><br>  Now (the source code of the project was downloaded in July 2013) Chromium consists of <b>1169 projects</b> .  The total amount of C / C ++ source code is <b>260 megabytes</b> .  In addition, you can add another <b>450 megabytes of</b> used external libraries. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we take our first test of the Chromium project in 2011, then we can see that the volume of external libraries as a whole has not changed.  But the code of the project itself has grown significantly from 155 megabytes to 260 megabytes. <br><br><h2>  For the sake of interest, we consider the cyclomatic complexity </h2><br>  In the PVS-Studio analyzer, you <a href="http://www.viva64.com/ru/d/0279/">can</a> search for functions with high <a href="http://www.viva64.com/ru/t/0010/">cyclomatic complexity</a> .  As a rule, such functions are candidates for refactoring.  Having checked 1160 projects, I naturally wondered which of them could be called the record holder in the nomination ‚Äúthe most difficult function‚Äù. <br><br>  The most maximal cyclomatic complexity, equal to 2782, belongs to the function ValidateChunkAMD64 () in the Chromium project.  But she had to be disqualified from the competition.  The function is in the file validator_x86_64.c, which is autogenerated.  It's a pity.  And that would be an epic record holder.  I didn‚Äôt come across such a cyclomatic complexity. <br><br>  Thus, the first three places get the following functions: <br><ol><li>  <b>WebKit</b> library.  The HTMLTokenizer :: nextToken () function in the htmltokenizer.cpp file.  Cyclomatic complexity <b>1106</b> . </li><li>  <b>Mesa</b> library.  The _mesa_glsl_lex () function in the glsl_lexer.cc file.  Cyclomatic complexity <b>1088</b> . </li><li>  Library <b>usrsctplib</b> (some unknown sportsman).  The sctp_setopt () function in the htmltokenizer.cpp file.  Cyclomatic complexity <b>1026</b> . </li></ol><br>  If someone does not know what cyclomatic complexity 1000 is, then let him not know.  Mental health will be better :).  In general, a lot of it. <br><br><h2>  Quality code </h2><br>  What can I say about the quality of the Chromium project code?  The quality is still great.  Yes, as in any big project, you can always find mistakes.  But if you divide their number by the amount of code, their density will be negligible.  This is a very good code with a very small number of errors.  I hand over a medal for a clean code.  <a href="http://www.viva64.com/ru/b/0189/">The previous medal</a> went to the project Casablanca (C ++ REST SDK) from Microsoft. <br><img src="https://habrastorage.org/getpro/habr/post_images/adf/036/eef/adf036eef4035535619428c137deeb0b.png" alt="Figure 1. Medal to the creators of Chromium."><br>  Figure 1. Medal to the creators of Chromium. <br><br>  For the company together with Chromium, the third-party libraries included in it were checked.  But to describe the errors found in them is not interesting.  Moreover, I looked through the report very superficially.  No, I'm not a bad person at all.  I would look at you if you tried to fully examine the verification report of 1169 projects.  What I noticed during a quick scan, I put <a href="http://www.viva64.com/ru/examples/">examples of errors</a> in the <a href="http://www.viva64.com/ru/examples/">database</a> .  In this article I want to touch on only those errors that I managed to notice in the code of Chromium itself (its plug-ins and the like). <br><br>  Since the Chromium project is so good, why should I give examples of errors found?  Everything is very simple.  I want to demonstrate the power of the PVS-Studio analyzer.  If he managed to find errors in Chromium, then the tool deserves your attention. <br><br>  The analyzer managed to chew tens of thousands of files, with a total volume of 710 megabytes, and did not die from this.  Despite the fact that the project is being developed by highly qualified developers and checked by various tools, PVS-Studio still managed to identify defects.  This is a great achievement!  And the last - he did it in a reasonable time (about 5 hours) due to parallel testing (AMD FX-8320 / 3.50 GHz / eight-core processor, 16.0 GB RAM). <br><br><h2>  Some of the errors found </h2><br>  I propose to consider some examples of the code on which I looked when viewing the report.  I am sure that with detailed study, it will be possible to find a lot more interesting. <br><br><h3>  Noted N1 - typos </h3><br><pre><code class="cpp hljs">Vector3dF Matrix3F::SolveEigenproblem(Matrix3F* eigenvectors) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The matrix must be symmetric. const float epsilon = std::numeric_limits&lt;float&gt;::epsilon(); if (std::abs(data_[M01] - data_[M10]) &gt; epsilon || std::abs(data_[M02] - data_[M02]) &gt; epsilon || std::abs(data_[M12] - data_[M21]) &gt; epsilon) { NOTREACHED(); return Vector3dF(); } .... }</span></span></code> </pre> <br>  <i>V501 There are identical - the operator: data_ [M02] - data_ [M02] matrix3_f.cc 128</i> <br><br>  We need to check that the 3x3 matrix is ‚Äã‚Äãsymmetric. <br><img src="https://habrastorage.org/getpro/habr/post_images/73e/e0b/3cd/73ee0b3cda1bb527153d8ced99ff03fa.png" alt="Figure 2. 3x3 matrix."><br>  Figure 2. 3x3 matrix. <br><br>  To do this, compare the following elements: <br><ul><li>  M01 and M10 </li><li>  M02 and M20 </li><li>  M12 and M21 </li></ul><br>  Most likely, the code was written using the <a href="http://www.viva64.com/ru/t/0068/">Copy-Paste technology</a> .  As a result, cell M02 is compared to itself.  Here is such a fun class matrix. <br><br>  Another simple typo: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTextField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FormFieldData&amp; field)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> field.form_control_type == <span class="hljs-string"><span class="hljs-string">"text"</span></span> || field.form_control_type == <span class="hljs-string"><span class="hljs-string">"search"</span></span> || field.form_control_type == <span class="hljs-string"><span class="hljs-string">"tel"</span></span> || field.form_control_type == <span class="hljs-string"><span class="hljs-string">"url"</span></span> || field.form_control_type == <span class="hljs-string"><span class="hljs-string">"email"</span></span> || field.form_control_type == <span class="hljs-string"><span class="hljs-string">"text"</span></span>; }</code> </pre> <br>  <i>V501 There are identical sub-expressions' field.form_control_type == "text"</i>  <i>operator.</i>  <i>autocomplete_history_manager.cc 35</i> <br><br>  Two times there is a comparison with the string "text".  This is suspicious.  Perhaps one line is just superfluous.  Or maybe there is no other comparison needed here. <br><br><h3>  N2 seen - opposite conditions </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseRequestCookieLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; header_value, ParsedRequestCookies* parsed_cookies)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::const_iterator i = header_value.begin(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*i == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i != header_value.end() &amp;&amp; *i != <span class="hljs-string"><span class="hljs-string">'"'</span></span>) ++i; .... }</code> </pre> <br>  <i>V637 Two opposite conditions were encountered.</i>  <i>The second condition is always false.</i>  <i>Check lines: 500, 501. web_request_api_helpers.cc 500</i> <br><br>  It seems to me that this code should have skipped text framed with double quotes.  But in fact, this code does nothing.  The condition is immediately false.  For clarity, I will write pseudocode to emphasize the essence of the error: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( A == <span class="hljs-string"><span class="hljs-string">'X'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( .... &amp;&amp; A != <span class="hljs-string"><span class="hljs-string">'X'</span></span> ) ....;</code> </pre> <br>  Most likely, here you forgot to move the pointer one character and the code should look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*i == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { ++i; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i != header_value.end() &amp;&amp; *i != <span class="hljs-string"><span class="hljs-string">'"'</span></span>) ++i;</code> </pre> <br><br><h3>  Noted N3 - unsuccessful deletion of elements </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ShortcutsProvider::DeleteMatchesWithURLs( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;GURL&gt;&amp; urls) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(matches_.begin(), matches_.end(), RemoveMatchPredicate(urls)); listener_-&gt;OnProviderUpdate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  <i>V530 The return value of the function 'remove_if' is required to be utilized.</i>  <i>shortcuts_provider.cc 136</i> <br><br>  To remove items from the container, use the std :: remove_if () function.  But used incorrectly.  In fact, remove_if () does not remove anything.  It shifts elements to the beginning and returns an iterator to the garbage.  You need to remove garbage yourself by calling the erase () function on containers.  See also the Wikipedia article " <a href="http://www.viva64.com/go.php%3Furl%3D1200">Erase-remove idiom</a> ". <br><br>  The correct code is: <br><pre> <code class="cpp hljs">matches_.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_if(.....), matches_.end());</code> </pre> <br><br><h3>  N4 - Eternal confusion with SOCKET </h3><br>  SOCKET in the Linux world, this is an integer SIGNAL data type. <br><br>  SOCKET in the world of Windows, is an integer with no character type. <br><br>  In Visual C ++ header files, the SOCKET type is declared as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> UINT_PTR SOCKET;</code> </pre> <br>  However, they constantly forget about it and write the following code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NET_EXPORT_PRIVATE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCPServerSocketWin</span></span></span><span class="hljs-class"> {</span></span> .... SOCKET socket_; .... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TCPServerSocketWin::Listen(....) { .... socket_ = socket(address.GetSockAddrFamily(), SOCK_STREAM, IPPROTO_TCP); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (socket_ &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { PLOG(ERROR) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"socket() returned an error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MapSystemError(WSAGetLastError()); } .... }</code> </pre> <br>  <i>V547 Expression 'socket_ &lt;0' is always false.</i>  <i>Unsigned type value is never &lt;0. tcp_server_socket_win.cc 48</i> <br><br>  An unsigned variable is always greater than or equal to zero.  This means that checking the 'socket_ &lt;0' does not make sense.  If the program fails to open the socket, this situation will not be processed correctly. <br><br><h3>  Noted N5 - confusion with operations ~ and! </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FontStyle { NORMAL = <span class="hljs-number"><span class="hljs-number">0</span></span>, BOLD = <span class="hljs-number"><span class="hljs-number">1</span></span>, ITALIC = <span class="hljs-number"><span class="hljs-number">2</span></span>, UNDERLINE = <span class="hljs-number"><span class="hljs-number">4</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LabelButton::SetIsDefault(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_default) { .... style = is_default ? style | gfx::Font::BOLD : style &amp; !gfx::Font::BOLD; .... }</code> </pre> <br>  <i>V564 The '&amp;' operator is applied to bool type value.</i>  <i>You've probably forgotten to include the operator.</i>  <i>label_button.cc 131</i> <br><br>  As it seems to me, the code should work like this: <br><ul><li>  If the variable 'is_default' is true, then you should always set the bit responsible for the BOLD style. </li><li>  If the variable 'is_default' is false, then you always need to reset the bit responsible for the BOLD style. </li></ul><br>  However, the expression "style &amp;! Gfx :: Font :: BOLD" does not work as the programmer expects.  The result of the operation "! Gfx :: Font :: BOLD" will be 'false'.  Or in other words, 0. The code written above is equivalent to this: <br><pre> <code class="cpp hljs">style = is_default ? style | gfx::Font::BOLD : <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  For the code to work correctly, you should use the operation '~': <br><pre> <code class="cpp hljs">style = is_default ? style | gfx::Font::BOLD : style &amp; ~gfx::Font::BOLD;</code> </pre> <br><br><h3>  Noted N6 - suspicious creation of temporary objects </h3><br><pre> <code class="cpp hljs">base::win::ScopedComPtr&lt;IDirect3DSurface9&gt; scaler_scratch_surfaces_[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AcceleratedSurfaceTransformer::ResizeBilinear( IDirect3DSurface9* src_surface, ....) { .... IDirect3DSurface9* read_buffer = (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? src_surface : scaler_scratch_surfaces_[read_buffer_index]; .... }</code> </pre> <br>  <i>V623 Consider inspecting the '?:' Operator.</i>  <i>A temporary object of the ScopedComPtr type was created and subsequently destroyed.</i>  <i>Check second operand.</i>  <i>accelerated_surface_transformer_win.cc 391</i> <br><br>  This code is unlikely to lead to an error, but it deserves to be told about it.  It seems to me that some programmers will learn about a new interesting trap in C ++. <br><br>  At first glance, everything is simple.  Depending on the condition, we select the 'src_surface' pointer or one of the elements of the 'scaler_scratch_surfaces_' array.  The array consists of objects of the type base :: win :: ScopedComPtr &lt;IDirect3DSurface9&gt;, which can be automatically led to a pointer to IDirect3DSurface9. <br><br>  The devil is in the details. <br><br>  The ternary operator '?:' Cannot return a different type depending on the condition.  Let me explain with a simple example. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> X = v ? A : <span class="hljs-number"><span class="hljs-number">2.0</span></span>;</code> </pre> <br>  Operator?: Returns type 'double'.  As a result, the variable 'X' will also be of type double.  But it is not important.  It is important that the variable 'A' will be implicitly expanded to the type 'double'! <br><br>  The trouble arises if you write something like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L"1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> s2[] = <span class="hljs-string"><span class="hljs-string">L"2"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> a = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> *s = a ? s1 : s2;</code> </pre> <br>  As a result of executing this code, the variable 's' will point to the data inside the temporary object of the CString type.  The problem is that this object will be immediately destroyed. <br><br>  We now return to the source code Chromium. <br><pre> <code class="cpp hljs">IDirect3DSurface9* read_buffer = (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? src_surface : scaler_scratch_surfaces_[read_buffer_index];</code> </pre> <br>  Here the following will occur if the condition 'i == 0' is fulfilled: <br><ul><li>  from the 'src_surface' pointer, a temporary object of the type base :: win :: ScopedComPtr &lt;IDirect3DSurface9&gt; will be constructed; </li><li>  the temporary object will be implicitly cast to a pointer of type IDirect3DSurface9 and placed in the read_buffer variable; </li><li>  temporary object will be destroyed. </li></ul><br>  I do not know the logic of the program and the class ScopedComPtr and I find it difficult to say whether negative consequences can arise or not.  Most likely, in the designer the counter of the number of references will be increased, and in the destructor it will be reduced.  And all will be well. <br><br>  If this is not the case, then inadvertently you can get a non-valid pointer or break the reference count. <br><br>  In a word, even if there is no mistake, I will be glad if readers learned something new.  The ternary operator is more dangerous than it seems. <br><br>  Here is another such suspicious place: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> GenericScopedHandle&lt;HandleTraits, VerifierTraits&gt; ScopedHandle; DWORD HandlePolicy::DuplicateHandleProxyAction(....) { .... base::win::ScopedHandle remote_target_process; .... HANDLE target_process = remote_target_process.IsValid() ? remote_target_process : ::GetCurrentProcess(); .... }</code> </pre> <br>  <i>V623 Consider inspecting the '?:' Operator.</i>  <i>A temporary object of the 'GenericScopedHandle' type is subsequently created and subsequently destroyed.</i>  <i>Check third operand.</i>  <i>handle_policy.cc 81</i> <br><br><h3>  Noted N7 - duplicate checks </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">string16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAccessString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HandleType handle_type, ACCESS_MASK access)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (access &amp; FILE_WRITE_ATTRIBUTES) output.append(ASCIIToUTF16(<span class="hljs-string"><span class="hljs-string">"\tFILE_WRITE_ATTRIBUTES\n"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (access &amp; FILE_WRITE_DATA) output.append(ASCIIToUTF16(<span class="hljs-string"><span class="hljs-string">"\tFILE_WRITE_DATA\n"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (access &amp; FILE_WRITE_EA) output.append(ASCIIToUTF16(<span class="hljs-string"><span class="hljs-string">"\tFILE_WRITE_EA\n"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (access &amp; FILE_WRITE_EA) output.append(ASCIIToUTF16(<span class="hljs-string"><span class="hljs-string">"\tFILE_WRITE_EA\n"</span></span>)); .... }</code> </pre> <br>  <i>V581 The conditional expressions of the 'if' are located alongside each other are identical.</i>  <i>Check lines: 176, 178. handle_enumerator_win.cc 178</i> <br><br>  If the FILE_WRITE_EA flag is set, then the "\ tFILE_WRITE_EA \ n" sink will be added twice.  Very suspicious code. <br><br>  A similar strange picture can be seen here: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PasswordFormComparator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PasswordForm&amp; pf1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PasswordForm&amp; pf2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf1.submit_element &lt; pf2.submit_element) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf1.username_element &lt; pf2.username_element) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf1.username_value &lt; pf2.username_value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf1.username_value &lt; pf2.username_value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf1.password_element &lt; pf2.password_element) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pf1.password_value &lt; pf2.password_value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <i>V581 The conditional expressions of the 'if' are located alongside each other are identical.</i>  <i>Check lines: 259, 261. profile_sync_service_password_unittest.cc 261</i> <br><br>  The ‚Äúpf1.username_value &lt;pf2.username_value‚Äù check is repeated twice.  Possible, one line is just extra.  Or perhaps they forgot to check something else, and a completely different condition must be written. <br><br><h3>  Noted N8 - ‚Äúdisposable‚Äù cycles </h3><br><pre> <code class="cpp hljs">ResourceProvider::ResourceId PictureLayerImpl::ContentsResourceId() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (PictureLayerTilingSet::CoverageIterator iter(....); iter; ++iter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!*iter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ManagedTileState::TileVersion&amp; tile_version = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter.geometry_rect() != content_rect) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tile_version.get_resource_id(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  <i>V612 An unconditional 'return' within a loop.</i>  <i>picture_layer_impl.cc 638</i> <br><br>  There is something wrong with this cycle.  The loop performs only one iteration.  At the end of the loop is the unconditional return statement.  Possible reasons: <br><ul><li>  So conceived.  But it is very doubtful.  Why then create a loop, create an iterator, etc.? </li><li>  Instead of one of 'return', 'continue' should be written.  But also doubtful. </li><li>  Most likely, before the last 'return' some condition is missing. </li></ul><br>  There were other strange cycles that run only once: <br><pre> <code class="cpp hljs">scoped_ptr&lt;ActionInfo&gt; ActionInfo::Load(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (base::ListValue::const_iterator iter = icons-&gt;begin(); iter != icons-&gt;end(); ++iter) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scoped_ptr&lt;ActionInfo&gt;(); } result-&gt;default_icon.Add(....); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <i>V612 An unconditional 'break' within a loop.</i>  <i>action_info.cc 76</i> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BluetoothServiceRecord* BluetoothDeviceWin::GetServiceRecord( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; uuid) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ServiceRecordList::const_iterator iter = service_record_list_.begin(); iter != service_record_list_.end(); ++iter) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *iter; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  <i>V612 An unconditional 'return' within a loop.</i>  <i>bluetooth_device_win.cc 224</i> <br><br><h3>  Noted N9 - uninitialized variables </h3><br><pre> <code class="cpp hljs">HRESULT IEEventSink::Attach(IWebBrowser2* browser) { DCHECK(browser); HRESULT result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (browser) { web_browser2_ = browser; FindIEProcessId(); result = DispEventAdvise(web_browser2_, &amp;DIID_DWebBrowserEvents2); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  <i>V614 Potentially uninitialized variable 'result' used.</i>  <i>ie_event_sink.cc 240</i> <br><br>  If the 'browser' pointer is zero, the function will return an uninitialized variable. <br><br>  Another code snippet: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SavePackage::GetSaveInfo() { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> skip_dir_check; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { ....-&gt;GetSaveDir(...., &amp;skip_dir_check); } .... BrowserThread::PostTask(BrowserThread::FILE, FROM_HERE, base::Bind(..., skip_dir_check, ...)); }</code> </pre> <br>  <i>V614 Potentially uninitialized variable 'skip_dir_check' used.</i>  <i>Consider checking the fifth argument.</i>  <i>save_package.cc 1326</i> <br><br>  The variable 'skip_dir_check' may remain uninitialized. <br><br><h3>  Noted N10 - alignment of the code does not match the logic of its work </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTraceNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> notification)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notification &amp; TraceLog::EVENT_WATCH_NOTIFICATION) ++event_watch_notification_; notifications_received_ |= notification; }</code> </pre> <br>  <i>V640 The code's operational logic does not correspond with its formatting.</i>  <i>The statement is indented.</i>  <i>It is possible that curly brackets are missing.</i>  <i>trace_event_unittest.cc 57</i> <br><br>  Considering such code, it is not clear whether braces are forgotten here or not.  Even if the code is correct, it should be corrected so that it does not introduce other programmers into a thoughtful state. <br><br>  Here are a couple of places with VERY suspicious code alignment: <br><ul><li>  nss_memio.c 152 </li><li>  nss_memio.c 184 </li></ul><br><br><h3>  Noted N11 - check pointer after new </h3><br>  In many programs, the old inherited code lives, written back in the days when the 'new' operator did not throw an exception.  Previously, in the event of insufficient memory, he returned a null pointer. <br><br>  Chromium in this regard is no exception, and it includes such checks.  The trouble is not that a meaningless check is performed.  It is dangerous that with a null pointer, before any actions or functions had to be performed, certain values ‚Äã‚Äãshould be returned.  Now, due to the generation of the exception, the logic of the work has changed.  The code that was supposed to get control in case of a memory allocation error is now inactive. <br><br>  Consider an example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> base::<span class="hljs-function"><span class="hljs-function">DictionaryValue* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDictValueStats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> webrtc::StatsReport&amp; report)</span></span></span><span class="hljs-function"> </span></span>{ .... DictionaryValue* dict = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> base::DictionaryValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dict) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; dict-&gt;SetDouble(<span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>, report.timestamp); base::ListValue* values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> base::ListValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!values) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dict; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... }</code> </pre> <br>  <i>V668 It has been allocated to the use of the operator.</i>  <i>The exception will be generated in the case of memory allocation error.</i>  <i>peer_connection_tracker.cc 164</i> <br><br>  <i>V668 against '' '' '' allocated allocated allocated allocated allocated allocated allocated allocated</i>  <i>The exception will be generated in the case of memory allocation error.</i>  <i>peer_connection_tracker.cc 169</i> <br><br>  The first check ‚Äúif (! Dict) return NULL;‚Äù most likely will not bring harm.  But with the second check the situation is worse.  If the creation of an object using ‚Äúnew base :: ListValue ()‚Äù fails to allocate memory, then an 'std :: bad_alloc' exception will be thrown.  This is the end of the GetDictValueStats () function. <br><br>  As a result, this code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!values) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dict; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  never destroy an object whose address is stored in the 'dict' variable. <br><br>  The correct solution here will be to refactor the code and use smart pointers. <br><br>  Consider another code snippet: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Target::Init() { { .... ctx_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[abi_-&gt;GetContextSize()]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == ctx_) { Destroy(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } .... }</code> </pre> <br>  V668 has been defined as using the 'new' operator.  The exception will be generated in the case of memory allocation error.  target.cc 73 <br><br>  In case of a memory allocation error, the Destroy () function will not be called. <br><br>  <i>Further writing about it is not interesting.</i>  <i>I will simply provide a list of other potentially dangerous places I have noticed in the code:</i> <br><ul><li>  <i>'data' pointer.</i>  <i>target.cc 109</i> </li><li>  <i>'page_data' pointer.</i>  <i>mock_printer.cc 229</i> </li><li>  <i>'module' pointer.</i>  <i>pepper_entrypoints.cc 39</i> </li><li>  <i>'c_protocols' pointer.</i>  <i>websocket.cc 44</i> </li><li>  <i>'type_enum' pointer.</i>  <i>pin_base_win.cc 96</i> </li><li>  <i>'pin_enum' pointer.</i>  <i>filter_base_win.cc 75</i> </li><li>  <i>'port_data'.</i>  <i>port_monitor.cc 388</i> </li><li>  <i>'xcv_data' pointer.</i>  <i>port_monitor.cc 552</i> </li><li>  <i>'monitor_data'.</i>  <i>port_monitor.cc 625</i> </li><li>  <i>'sender_' pointer.</i>  <i>crash_service.cc 221</i> </li><li>  <i>'cache' pointer.</i>  <i>crash_cache.cc 269</i> </li><li>  <i>'current_browser' pointer.</i>  <i>print_preview_dialog_controller.cc 403</i> </li><li>  <i>'udp_socket' pointer.</i>  <i>network_stats.cc 212</i> </li><li>  <i>'popup_' pointer.</i>  <i>try_chrome_dialog_view.cc 90</i> </li></ul><br><br><h3>  Noted N12 - tests that do not test well </h3><br>  Unit tests are a great technology for improving the quality of programs.  However, the tests themselves often contain errors, as a result of which they do not perform their functions.  Writing tests for tests is of course a bust.  Can help static code analysis.  I considered this idea in more detail in the article ‚Äú <a href="http://www.viva64.com/ru/a/0080/">How static analysis complements TDD</a> ‚Äù. <br><br>  I will give some examples of errors I encountered in tests for Chromium: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> TestAudioConfig::TestValidConfigs() { .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> kRequestFrameCounts[] = { PP_AUDIOMINSAMPLEFRAMECOUNT, PP_AUDIOMAXSAMPLEFRAMECOUNT, <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">2048</span></span>, <span class="hljs-number"><span class="hljs-number">4096</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(kRequestFrameCounts)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(kRequestFrameCounts); j++) { .... }</code> </pre> <br>  <i>V501 There are identical sub-expressions 'sizeof (kRequestFrameCounts)'.</i>  <i>test_audio_config.cc 56</i> <br><br>  Only one test will run in the loop.  The error is that "sizeof (kRequestFrameCounts) / sizeof (kRequestFrameCounts)" equals one.  The correct expression is: ‚Äúsizeof (kRequestFrameCounts) / sizeof (kRequestFrameCounts [0])‚Äù. <br><br>  Another erroneous test: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DiskCacheEntryTest::ExternalSyncIOBackground(....) { .... scoped_refptr&lt;net::IOBuffer&gt; buffer1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> net::IOBuffer(kSize1)); scoped_refptr&lt;net::IOBuffer&gt; buffer2(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> net::IOBuffer(kSize2)); .... EXPECT_EQ(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(buffer2-&gt;data(), buffer2-&gt;data(), <span class="hljs-number"><span class="hljs-number">10000</span></span>)); .... }</code> </pre> <br>  <i>V549 The first argument of the memcmp function is equal to the second argument.</i>  <i>entry_unittest.cc 393</i> <br><br>  The ‚Äúmemcmp ()‚Äù function compares the buffer to itself.  As a result, the test does not perform the required verification.  Apparently, there should be: <br><pre> <code class="cpp hljs">EXPECT_EQ(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(buffer1-&gt;data(), buffer2-&gt;data(), <span class="hljs-number"><span class="hljs-number">10000</span></span>));</code> </pre> <br>  But a test that may unexpectedly break other tests: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kNumPainters = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name; GPUPainter* painter; } painters[] = { { <span class="hljs-string"><span class="hljs-string">"CPU CSC + GPU Render"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CPUColorPainter() }, { <span class="hljs-string"><span class="hljs-string">"GPU CSC/Render"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GPUColorWithLuminancePainter() }, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Run GPU painter tests. for (int i = 0; i &lt; kNumPainters; i++) { scoped_ptr&lt;GPUPainter&gt; painter(painters[i].painter); .... }</span></span></code> </pre> <br>  <i>V557 Array overrun is possible.</i>  <i>Shader_bench.cc 152</i> <br><br>  Perhaps earlier the array 'painters' consisted of three elements.  Now there are only two.  And the value of the constant 'kNumPainters' remains equal to 3. <br><br>  <i>Some other places in the tests that I think deserve attention:</i> <br><br>  <i>V579</i>  <i>It is possibly a mistake.</i>  <i>Inspect the second argument.</i>  <i>syncable_unittest.cc 1790</i> <br><br>  <i>V579</i>  <i>It is possibly a mistake.</i>  <i>Inspect the second argument.</i>  <i>syncable_unittest.cc 1800</i> <br><br>  <i>V579</i>  <i>It is possibly a mistake.</i>  <i>Inspect the second argument.</i>  <i>syncable_unittest.cc 1810</i> <br><br>  <i>V595 The 'browser' pointer</i>  <i>Check lines: 5489, 5493. testing_automation_provider.cc 5489</i> <br><br>  <i>V595 The 'waiting_for_.get ()' pointer was used before it was verified against nullptr.</i>  <i>Check lines: 205, 222. downloads_api_unittest.cc 205</i> <br><br>  <i>V595 The 'pNPWindow' pointer was used before it was verified against nullptr.</i>  <i>Check lines: 34, 35. plugin_windowed_test.cc 34</i> <br><br>  <i>V595 The 'pNPWindow' pointer was used before it was verified against nullptr.</i>  <i>Check lines: 16, 20. plugin_window_size_test.cc 16</i> <br><br>  <i>V595 The 'textfield_view_' pointer was used before it was verified against nullptr.</i>  <i>Check lines: 182, 191. native_textfield_views_unittest.cc 182</i> <br><br>  <i>V595 The 'message_loop_' pointer was used before it was verified against nullptr.</i>  <i>Check lines: 53, 55. test_flash_message_loop.cc 53</i> <br><br><h3>  Noted N13 - Function with variable number of arguments </h3><br>  In all programs, many defects are found in the code intended for handling errors and responding to incorrect input data.  This is because such places are difficult to test.  And, as a rule, they are not tested.  As a result, when an error occurs, the programs begin to behave much more bizarre than planned. <br><br>  Example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VOID)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryOpenFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, FILE *output)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> path_expanded[MAX_PATH] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; DWORD size = ::ExpandEnvironmentStrings( path, path_expanded, MAX_PATH - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!size) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(output, <span class="hljs-string"><span class="hljs-string">"[ERROR] Cannot expand \"%S\". Error %S.\r\n"</span></span>, path, ::GetLastError()); } .... }</code> </pre> <br>  <i>V576 Incorrect format.</i>  <i>Consider checking the fourth argument of the fprintf function.</i>  <i>Wchar_t type symbols is expected.</i>  <i>fs.cc 17</i> <br><br>  If the variable 'size' is zero, the program will try to write a text message to the file.  But this message is likely to contain a billiberd at the end.  Moreover, this code can lead to <a href="http://www.viva64.com/ru/t/0063/">access violation</a> . <br><br>  For recording, it uses the fprintf () function.  This function does not control the types of its arguments.  She expects the last argument to be a pointer to a string.  But in fact, the actual argument is a number (error code).  This number will be converted to an address and it is unknown how the program will behave further. <br><br><h3>  Unnoticed </h3><br>  Once again, I looked through the list of messages superficially.  I brought in this article only what caught my attention.  Moreover, I noticed more than I wrote in the article.  Describing everything, I will get an article too long.  And she is already too big. <br><br>  I dropped a lot of code fragments that I think will not be very interesting to the reader.  I will give a couple of examples for clarity. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ManagedUserService::UserMayLoad( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> extensions::Extension* extension, string16* error) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extension_service &amp;&amp; extension_service-&gt;GetInstalledExtension(extension-&gt;id())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extension) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> was_installed_by_default = extension-&gt;was_installed_by_default(); ..... } }</code> </pre> <br>  <i>V595 'extension pointer extension nu pointer</i>  <i>Check lines: 277, 280. managed_user_service.cc 277</i> <br><br>  In the beginning, the 'extension' pointer is dereferenced in the expression "extension-&gt; id ()".  Then this pointer is checked for equality to zero. <br><br>  Often, this code does not contain errors.  It happens that the pointer simply cannot be zero and the check is redundant.  Therefore, it makes no sense to list such places, since I could be mistaken and give a completely working code for the wrong one. <br><br>  Here is another diagnostic example that I chose not to notice: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WebMClusterParser::ParseBlock(....) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timecode = buf[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | buf[<span class="hljs-number"><span class="hljs-number">2</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timecode &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>) timecode |= (<span class="hljs-number"><span class="hljs-number">-1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>); .... }</code> </pre> <br>  <i>V610 Undefined behavior.</i>  <i>Check the shift operator '&lt;&lt;.</i>  <i>The left operand '-1' is negative.</i>  <i>webm_cluster_parser.cc 217</i> <br><br>  Formally, a negative value shift results in <a href="http://www.viva64.com/ru/t/0066/">undefined behavior</a> .  However, many compilers are stable and exactly as the programmer expects.  As a result, this code works long and successfully, although it is not required.  I don‚Äôt want to fight this now, and I‚Äôll miss such messages.  For those who want to understand the question in more detail, I recommend the article " <a href="http://www.viva64.com/ru/b/0142/">Without knowing the ford, do not climb into the water - part three</a> ." <br><br><h2>  About false positives </h2><br>  I am often asked a question: <br><br>  In the articles you are very cleverly give examples of errors found.  But you do not say what is the total number of messages issued.  Often, static analyzers produce a lot of false positives, and among them it is almost impossible to find real errors.  What about the PVS-Studio analyzer? <br><br>  And I always do not know what to immediately answer this question.  I have two opposite answers: the first - a lot, the second - a little.  It all depends on how to approach the consideration of the issued message list.  Now, using the example of Chromium, I will try to explain the essence of such duality. <br><br>  The PVS-Studio analyzer issued <b>3582</b> first-level warnings (GA rule set).  This is a lot.  And most of these messages are false.  If you go to the "forehead" and start immediately to view the entire list, then it will get very tired very quickly.  And the impression will be terrible.  Some solid homogeneous false positives.  Nothing interesting comes across.  Bad tool. <br><br>     ,       . ,     PVS-Studio ,      .  ,      .           . <br><br>     .      Chromium. ,      -  'DVLOG'.   - .     PVS-Studio  ,      . ,    ,     .  ,      DVLOG,      .  ,      <b>2300</b>   ¬´V501 There are identical sub-expressions.....¬ª. <br><br>    ,    ,    ,    : <br><br> //-V:DVLOG:501 <br><br> ,       3582 , 2300 . <b>   65% </b> .        . <br><br>           .  ,    .        ,   .        " <a href="http://www.viva64.com/ru/d/0021/">  </a> ". ,      ,   . <br><br>   .    ‚Äî   .     ‚Äî   .  ,                 . <br><br><h2>   </h2><br>  ,    .  ,  -  .  ,      , : <br><ul><li>    ¬´       ?¬ª,    " <a href="http://www.viva64.com/ru/b/0132/">  ,       </a> ". </li><li>        ,  <a href="http://www.viva64.com/ru/about-feedback/">  </a>   .      twitter,    -      . </li><li>     : <a href="https://twitter.com/Code_Analysis">@Code_Analysis</a> .             ++. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/189892/">https://habr.com/ru/post/189892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189876/index.html">Hyperloop technical specifications published</a></li>
<li><a href="../189882/index.html">How namedtuple or dynamic type creation works</a></li>
<li><a href="../189886/index.html">Dr. Tariff (3 months later) - you can pick up the tariff in 80 regions of Russia on Android and iOS</a></li>
<li><a href="../189888/index.html">Transition from HP EVA to 3PAR StoreServ 7400. Real implementation experience</a></li>
<li><a href="../189890/index.html">Intel Cloud Services Platform - "cloud" for the developer</a></li>
<li><a href="../189898/index.html">Timing for amateur racing, flexible and wireless</a></li>
<li><a href="../189900/index.html">Basics of programming objects of the Smart Home in MajorDoMo</a></li>
<li><a href="../189902/index.html">Testing Palo Alto Networks Solutions: How to Block Access to Social Networks and Applications</a></li>
<li><a href="../189904/index.html">Modest Charm - Sony Xperia L Review</a></li>
<li><a href="../189910/index.html">A look at Tizen OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>