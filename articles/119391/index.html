<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating Objects in Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Flexibility Javascript allows you to create objects in a variety of ways. But as it often happens, diversity is fraught with many pitfalls. In this ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating Objects in Javascript</h1><div class="post__text post__text-html js-mediator-article">  Flexibility Javascript allows you to create objects in a variety of ways.  But as it often happens, diversity is fraught with many pitfalls.  In this article you will learn how to see and go around these dangerous reefs. <br><a name="habracut"></a><br><h4>  Basics of the basics </h4><br>  It will be useful to remind you what objects in Javascript are and how you can create them.  An object in Javascript is just a hash table of keys and values.  If values ‚Äã‚Äãare basic types or other objects, they are called <i>properties</i> , if they are functions, they are called object <i>methods</i> . <br><br>  Objects created by the user can be changed at any point in the execution of the script.  Many properties of objects embedded in the language are also changeable.  That is, you can simply create an empty object and add properties and methods to it as necessary.  The easiest way to do this is with <i>literal notation</i> : <br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var cat = {}; // : cat.name = "Garfield"; // : cat.getName = function() { return cat.name; };</span></span></code> </pre> <br>  Another way to create an object is to use <i>constructor functions:</i> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : var cat = {name: "Garfield"}; // -: var cat = new Object(); cat.name = "Garfield";</span></span></code> </pre><br>  Obviously, the literal notation is shorter than the constructor.  There is also a philosophical reason for preferring literal notation to designers: it emphasizes that an object is just a mutable hash, and not something created from a template given by a class. <br><br>  In addition, the use of the <code>Object</code> constructor forces the interpreter to check whether this function is redefined in the local context. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Underwater Stone Object Constructor </h4><br>  There are no reasons to use the <code>Object</code> constructor.  But we all know that sometimes you have to use some old code, and in this case it is useful to know about one feature of this constructor.  It takes an argument, and depending on its type, can assign the creation of an object to another constructor built into the language;  in the end, we get the wrong object that we expected: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var o = new Object(); o.constructor === Object; // true var o = new Object(1); o.constructor === Number; //true var o = new Object("string"); o.constructor === String; //true //  ,       : typeof o.substring; // "function"</span></span></code> </pre><br>  This behavior of the <code>Object</code> constructor can lead to unexpected results if we pass to it a value that is unknown at run time. <br><br>  The moral is obvious: do not use the <code>Object</code> constructor. <br><br><h4>  Own constructors </h4><br>  We can define our own constructors.  Using them looks like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(<span class="hljs-string"><span class="hljs-string">"Garfield"</span></span>); cat.say(); <span class="hljs-comment"><span class="hljs-comment">// "I am Garfield"</span></span></code> </pre><br>  The syntax is similar to the Java constructor, but in Javascript the constructor is a normal function and therefore is defined like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.say = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"I am"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } }</code> </pre><br>  When this constructor is called with the <code>new</code> operator inside a function, the following happens: <br><ul><li>  creates an empty object pointed to by the <code>this</code> variable;  this object inherits the function prototype; </li><li>  properties and methods are added to the object stored in <code>this</code> ; </li><li>  the object stored in <code>this</code> is returned implicitly at the end of the function (since we did not return anything explicitly). </li></ul><br>  For the sake of simplicity, in the example, the <code>say()</code> method is added to the <code>this</code> object.  This is not very good, because each time new function <code>new Person()</code> is called, a <code>new Person()</code> function will be created in memory.  Since the <code>say()</code> method is the same for all objects created using this constructor, it is better to add it to the <code>Cat</code> prototype: <br><pre> <code class="javascript hljs">Cat.prototype.say = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"I am "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; };</code> </pre><br>  In addition, it is not entirely correct to say that the <code>this</code> object, implicitly created in the constructor, is empty: it inherits from the <code>Cat</code> prototype, but the consideration of prototypes is beyond the scope of this article. <br><br><h4>  What the constructor returns </h4><br>  When using the <code>new</code> operator, the constructor always returns an object.  By default, this is the object referenced by <code>this</code> .  The constructor returns <code>this</code> implicitly, but we can explicitly return any other object, for example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">"I am Garfield"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> that = {}; that.name = <span class="hljs-string"><span class="hljs-string">"I am Cat-woman"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(); cat.name <span class="hljs-comment"><span class="hljs-comment">// "I am Cat-woman"</span></span></code> </pre><br>  Thus, we can return any value from the constructor, but only if it is an object.  If we try to return, say, a string or <code>false</code> , this will not result in an error, but the return statement will be ignored, and the constructor will return <code>this</code> . <br><br><h4>  Insidious new </h4><br>  Constructors are just functions that are called with the <code>new</code> operator.  What happens if you forget this operator?  The interpreter will not issue warnings, but this will lead to logical errors.  The variable <code>this</code> will point not to the object inherited from the prototype of the constructor, but to the global object ( <code>window</code> in the case of the browser): <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">"Garfield"</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   var cat = new Cat(); typeof cat; // "object" cat.name; // "Garfield" // new: var cat = Cat(); typeof cat; // "undefined" window.name; // "Garfield"</span></span></code> </pre><br>  In the <a href="http://ecma262-5.com/ELS5_HTML.htm">strict mode of</a> the ECMAScript 5 <code>this</code> standard in this case will not point to a global object.  Let's see how to avoid this error if ECMAScript 5 is not available. <br><br><h5>  Function naming conventions </h5><br>  The easiest way is to strictly abide by the naming conventions of functions: we start the usual functions with a lowercase letter ( <code>myFunction()</code> ), and the constructor functions start with the capital one ( <code>MyConstruction()</code> ).  Unfortunately, this method almost does not save anything. <br><br><h5>  Explicit object return </h5><br>  Designers can return any objects.  Programmers can take advantage of this: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> that = {}; that.name = <span class="hljs-string"><span class="hljs-string">"Garfield"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that; }</code> </pre><br>  The variable name is arbitrary; it is not part of the specification.  With the same success, we can call the returned object <code>me</code> or <code>self</code> or whatever you want. <br><br>  For simple objects, such as those created in the example, we can generally do without additional variables using literal notation: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Garfield"</span></span> }; }</code> </pre><br>  Such a constructor will always return an object, regardless of how it is called: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(), second = Cat(); first.name; <span class="hljs-comment"><span class="hljs-comment">// "Garfield" second.name; // "Garfield"</span></span></code> </pre><br>  This method has a serious drawback: the object does not inherit the prototype of the constructor, that is, the methods and properties added directly to <code>Cat</code> will not be available to the objects created with its help. <br><br><h5>  Self-invoking constructor </h5><br>  To solve this problem, it is enough to check whether <code>this</code> in the body of the constructor is an instance of this constructor itself, and if not, call itself again, but this time with the <code>new</code> operator.  It sounds scary, but it's really simple: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Cat)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">"Garfield"</span></span>; } Cat.prototype.meow = <span class="hljs-string"><span class="hljs-string">"Meow!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(), second = Cat(); first.name; <span class="hljs-comment"><span class="hljs-comment">// "Garfield" second.name; // "Garfield" first.meow; // "Meow!" second.meow; // "Meow!"</span></span></code> </pre><br>  If our constructor is subsequently renamed, you will have to edit its body.  You can avoid this by checking the <code>arguments.callee</code> instead of the constructor name: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee(); }</code> </pre><br>  Here we used the fact that inside each function, a <code>arguments</code> object is created that contains all the parameters passed to the function at the time of the call.  The <code>callee</code> property of this object indicates the function being called.  But here, you need to be careful: strict ECMAScript 5 mode causes a <code>TypeError</code> exception when accessing this property, so you should make a choice in advance between the convenience of refactoring and the bright tomorrow. <br><br><h4>  Instead of conclusion </h4><br>  Javascript is a terrific language.  It is easy enough to master, and existing frameworks will allow you to easily use it in your projects.  But the simplicity of the syntax hides the whole reefs of the pitfalls - and very powerful tools.  Sometimes it is useful to watch what is there at the bottom. </div><p>Source: <a href="https://habr.com/ru/post/119391/">https://habr.com/ru/post/119391/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119368/index.html">Yii extension for displaying MP4 on the knee</a></li>
<li><a href="../119369/index.html">And again about MVC</a></li>
<li><a href="../119371/index.html">‚ÄúLeaflet‚Äù appeared - a new open source JavaScript library for any maps</a></li>
<li><a href="../119372/index.html">Logging and tariffing of outgoing calls for Avaya PBX</a></li>
<li><a href="../119376/index.html">Tag cloud - 404</a></li>
<li><a href="../119393/index.html">Home Finance - Home.Finance.Ua</a></li>
<li><a href="../119397/index.html">Successful things are successful immediately.</a></li>
<li><a href="../119398/index.html">LinkedIn will hold an IPO on Thursday</a></li>
<li><a href="../119399/index.html">A smartphone appeared on the Intel Atom processor</a></li>
<li><a href="../119401/index.html">ResellerClub transfers user accounts to Reg.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>