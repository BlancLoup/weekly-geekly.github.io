<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Techniques for designing game architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, nowhere is there more or less complete publication on the subject of designing architecture in games. There are separate articles on sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Techniques for designing game architecture</h1><div class="post__text post__text-html js-mediator-article">  Unfortunately, nowhere is there more or less complete publication on the subject of designing architecture in games.  There are separate articles on specific topics, but nowhere is all of this put together.  Each developer has to independently collect such information bit by bit, stuff cones.  Therefore, I decided to try to collect some of this together in this article. <br><br>  For examples, the popular Unity3D engine will be used.  Considers approaches applicable in big games.  Written from my personal experience and from how I understand it.  Of course, somewhere I may be wrong, somewhere you can do better.  I, too, are still in the process of gaining experience and getting new buds. <br><br>  The publication covers the following topics: <br><ul><li>  Inheritance VS Components </li><li>  Complex hierarchies of classes of units, objects and other things </li><li>  State machines, behavior trees </li><li>  Abstractions of game objects </li><li>  Simplify access to other components in an object, scene </li><li>  Difficult composite game objects </li><li>  Characteristics of objects in the game </li><li>  Modifiers (buffs / debuffs) </li><li>  Data serialization </li></ul><br><a name="habracut"></a><br><h4>  <b>Inheritance VS Components</b> </h4><br>  In big games, the architecture is rather complicated.  Complex entities and complex interactions between classes.  If you try to develop games using the standard OOP approach, then constant reworking of a bunch of code and a strong increase in the development time are guaranteed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The problem lies in inheritance (the problem of fragile base classes is a situation when it is impossible to change the implementation of the ancestor type without violating the correctness of the functioning of the descendant types).  When searching for solutions to combat this problem, a Component-Oriented Approach (CPC) was formed.  In short, the essence of the CPC is as follows: <br>  ‚ÄúThere is a certain container class as well as a component class that can be added to the container class.  An object consists of a container and components in this container. ‚Äù <br><br>  Components are a bit like interfaces.  But interfaces only allow to allocate a common signature of functions and properties from classes, and components allow us to take out the general implementation of classes separately. <br>  In the OOP approach, an object is defined by its class. <br>  In the KOP approach, an object is defined by the components of which it is composed.  It does not matter what kind of object.  It is important that he has and what he can do. <br><br>  KOP simplifies reuse of written code ‚Äî using the same component in different objects.  Also, from various combinations of already existing components, it is possible to assemble a new type of object. <br><br>  For example, take the object "character".  From the point of view of the PLO - it would be one big class, perhaps inherited from something.  From the point of view of the CPC is a set of components that make up the object "character".  For example: character characteristics / stats - component ‚ÄúStats‚Äù, character management ‚ÄúCharacterController‚Äù, character animation - ‚ÄúCharacterAnimationController‚Äù, collision handler - ‚ÄúCharacterCollisionHandler‚Äù. <br><br>  Do not give up inheritance in games.  Inheritance of components is quite normal practice.  And in some situations, it will be more correct.  But, if you can see that there will be several levels of class inheritance to describe objects, then it is better to use components. <br><br><h4>  <b>Complex hierarchies of classes of units, objects and other things</b> </h4><br>  Many developers, unfamiliar or new to CPC, make the same mistake when designing complex class systems for units, objects.  Or even correctly select the components, but for some reason, make inheritance of AI components. <br><br>  Let us consider in more detail the hierarchy of classes of units of different types.  To shorten the text, units in this context can be characters and buildings. <br><br><img src="https://habrastorage.org/files/261/477/8ad/2614778adc3d42c7a8eae90c06959383.png"><br><br>  Red lines indicate problem areas - the inherited type must have properties, behavior of different types.  In this example, whatever you think of - nothing will solve the problem of the constant changes of all classes in this hierarchy. <br><br>  The picture below shows how a part of this scheme might look when using CPC. <br><br><img src="https://habrastorage.org/files/ebb/9cc/8b4/ebb9cc8b4525404bb192d1c35708add8.png"><br><br>  Since  Since objects are assembled from components, then there is no problem anymore, when changing one object, you will need to change others.  Also, no more puzzling over the creation of a hierarchy of classes suitable for all objects. <br><br><h4>  <b>State machines, behavior trees</b> </h4><br>  The scheme in the previous part was very simplified.  In fact, the components will need much more.  You also need to organize their interaction with each other.  To simplify work with objects with complex behavior (units, characters) state machines, behavior trees are used. <br><br>  <b>1. State machine</b> <br>  The object's logic is divided into states, events, transitions, and can also be broken down into actions.  Variations in the implementation of these elements may differ markedly. <br><ul><li>  The state of the object - can be as a class without game logic, simply storing some data, for example, the name of the state of the object: attack, movement.  Or the class ‚Äústate‚Äù may describe the behavior of an object in a particular state. </li><li>  An action is a function that can be executed in this state. </li><li>  Transition - connection between 2 states.  Indicates which state to which transition is possible. </li><li>  An event is a kind of message / command that is transmitted to a state machine or called inside it.  It is used to indicate that it is necessary to make a transition to another state, if this is possible from the current state. </li></ul><br>  The screenshot shows a diagram (graph) of the state machine, made in PlayMaker. <br><br><img src="https://habrastorage.org/files/e66/67c/a77/e6667ca774f94128b182b3dfd3fe3d40.png"><br><br>  An interesting state machine is implemented in the Behavior Machine plugin.  There, the state is the MonoBehaviour component, which is responsible for the logic of work in this state.  Moreover, the state can also be a tree of behavior. <br><br>  <b>2. Hierarchical state machine</b> <br>  When there are many states, the number of connections between them increases, which complicates the work with the state machine graph.  To simplify working with it, you can use a hierarchical state machine.  It differs in that a nested state machine can be used as a state.  Thus a tree hierarchy of states is obtained. <br><br>  <b>3. Behavior tree</b> <br>  To simplify the writing of AI, games use behavior trees (Behavior Tree). <br><br>  The behavior tree is a tree structure, the nodes of which are small blocks of game logic.  From various blocks of logic, the developer constructs a tree structure in the visual editor, adjusts tree nodes.  This structure will be responsible for the decision-making character and its interaction with the game world. <br><br>  Each node returns a result that determines how the remaining nodes of the tree will be processed.  Return results are usually the following: success, failure, and execution. <br><br>  The main types of nodes in the behavior tree: <br><ul><li>  Action Node (action) <br>  Just some function that should be executed when visiting this site. </li><li>  Condition <br>  Usually serves to determine whether or not to follow the nodes following it.  If true, returns Success, and if false, returns Fail. </li><li>  Sequencer (sequence) <br>  Executes all nested nodes in order, until one of them fails (in this case, returns Fail), or until all of them successfully complete (then returns Success). </li><li>  Selector <br>  Unlike the Sequencer, it stops processing as soon as any nested node returns Success. </li><li>  Iterator (iterator - acts as a for loop) <br>  Used to perform a series of actions in a loop a number of times. </li><li>  Parallel node <br>  Runs all of its child nodes at the same time.  It does not mean that nodes are executed by several threads.  It just creates the illusion of parallel execution, similar to the quotes in Unity3d. </li></ul><br>  The screenshot shows the behavior tree made in the Behaviour plugin. <br><br><img src="https://habrastorage.org/files/b61/13a/ae7/b6113aae7e144ca3a9fd028c3b63c56c.png"><br><br>  <b>When is it better to use a state machine, and when is a behavior tree?</b> <br>  Artificial Intelligence for Games II, on page 370, says that behavior trees are harder to implement if they need to respond to events from outside.  It also proposes a possible solution - to introduce the concept of "task" (for example: patrolling, stalking the enemy, attacking the enemy) into the tree of behavior.  Those.  it is assumed that the controller of the behavior tree will move to another node-task in order to change the behavior.  Also in the book offers an alternative option - to combine the tree of behavior with the state machine.  By the way, this is already implemented in the Behavior Machine plugin. <br><br>  I tried to use the first option - enter the task nodes in the behavior tree.  The work is greatly complicated, since  It is necessary not only to implement a task change, but also to ‚Äúzero out‚Äù the variables of the completed / canceled task. <br><br>  I'd add from myself - if AI itself receives data from the world and does not receive any commands, then Behavior Tree is suitable for it.  If AI is controlled by something - by a person or other AI (for example, a unit in strategies is controlled by a computer player or a squad), then it is better to use a state machine. <br><br><h4>  <b>Abstractions of game objects</b> </h4><br>  It is not necessary to consider that a character controlled by a player is a Player object.  Also, do not assume that this character can be controlled only by a person or only a computer.  Who knows how the gameplay will be redone in the future. <br>  Player (can be both a computer and a person; you should not mix them in one class) is a separate object.  A character / unit is also a separate object that can be controlled by any player.  In strategic games, in addition, you can make a separate "detachment" object. <br><br>  It is not difficult to divide the game logic into such objects.  In addition, it will be applicable to many different games. <br><br><h4>  <b>Simplify access to other components in an object, scene</b> </h4><br>  With a large number of components in the object, there is an inconvenience when you need to access them.  Constantly it is necessary to create fields in each component for storing references to other components or to access them via GetComponent (). <br><br>  The mediator pattern prompted me to introduce some kind of intermediary component through which the components could communicate with each other.  In addition, this will allow to check the existence of other components in this component and the code will need to write only 1 time.  Such a component for different types of objects is also worth doing different, because  different sets of components are used.  In this case, this is not the implementation of the mediator pattern, but simply caching of links in one class for the convenience of accessing other components of the object. <br><br>  Example: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CharacterLinks</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Stats stats; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CharacterAnimationController animationController; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CharacterController characterController; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { stats = GetComponent&lt;Stats&gt;(); animationController = GetComponent&lt;CharacterAnimationController&gt;(); characterController = GetComponent&lt;CharacterController&gt;(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CharacterAnimationController</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { CharacterLinks _links; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _links = GetComponent&lt;CharacterLinks&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_links.characterController.isGrounded) ... } }</code> </pre> <br><br>  In scenes, a similar situation.  It is possible to make references to frequently used components in a certain singleton object so that in the inspector of specific components one does not have to constantly specify references to other objects. <br><br>  Example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneUILinks</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonoSingleton</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GameSceneUILinks</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MainMenu MainMenu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SettingsMenu SettingsMenu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tooltip Tooltip; }</code> </pre><br>  Using: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GameSceneUILinks</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Instance</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.MainMenu</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Show</span></span>();</code> </pre><br>  Since  components need to be specified only in one object, and not in several, the amount of work in the editor is slightly reduced, and the code as a whole will be less. <br><br><h4>  <b>Difficult composite game objects</b> </h4><br>  Characters, UI elements, and some other objects may consist of a larger number of script components and multiple nested objects.  If the hierarchy of such objects is poorly thought out, then this can greatly complicate the development. <br>  Consider 2 cases where it is important to think through the hierarchy of the object: <br><ul><li>  parts of the object must be replaced by others during the game; </li><li>  Some of the object scripts should work only in one scene, and the other part - in another. </li></ul><br>  <b>To begin, consider the first case.</b> <br>  You can completely replace an object, but if after the replacement it must be in the same state and have the same data as before the replacement, then the task becomes more complicated. <br>  To simplify the replacement of any part of the object, its structure can be organized, for example, as follows: <br>  Character <br><ul><li>  Data </li><li>  ControlLogic (scripts to control the character) </li><li>  RootBone (character's root bone; Animator components and scripts for working with IK must be here, otherwise they will not work) </li><li>  Animation (other scripts for working with animation) </li><li>  Model </li></ul><br>  Such a partition will allow you to change the appearance of the object or the animation controller, without much affecting the other components. <br><br>  <b>Now consider the second case.</b> <br>  For example, there is a certain object with sprite and data.  When you click on it in the scene of improvements, you need to improve this object.  And when you click on it in the game scene, some kind of game action should be performed. <br><br>  You can make 2 prefabs, but then, if there are many objects, you will have to configure 2 times more prefabs. <br><br>  You can go the other way and organize the structure as follows: <br>  ObjectView (object image) <br><ul><li>  Data (object data used in both scenes) </li><li>  UpgradeLogic (button and scripts for scene enhancements) </li><li>  GameLogic (button and scripts for the game scene) </li></ul><br>  The targetGraphic field in the buttons should refer to the image in the ObjectView. <br>  This approach was tested in uGUI. <br><br><h4>  <b>Characteristics of objects in the game</b> </h4><br>  In many games, characters, items, abilities, etc.  There are some characteristics (health, mana, strength, duration).  Moreover, the different types of characteristics differ. <br>  From my experience I can say that it will be more convenient to work with the characteristics if they are put into a separate component (s).  In other words - to separate the data from the functional. <br><br>  In order not to create a bunch of classes for storing various characteristics in a complex system, it is better to store them in a dictionary in a separate class that controls the work with this dictionary. <br><br>  Also, most likely, you need to have a special class to store the values ‚Äã‚Äãthemselves in the dictionary.  Thus, the dictionary will not store the values ‚Äã‚Äãthemselves, but instances of the wrapper class for these values. <br>  What could be in this class: <br><ul><li>  Event triggered by a value change; </li><li>  A value that can be of several kinds, for example: <br><ol><li>  present value; </li><li>  minimum and maximum values ‚Äã‚Äã(for example, random attack power in the range of values ‚Äã‚Äã10 - 20); </li><li>  current and maximum values ‚Äã‚Äã(for example, health). </li></ol></li></ul><br>  Universality is quite difficult to achieve.  There are only one set of stats (strength), other characters (health, mana), and third abilities (reload duration).  These sets should not intersect so that there is no confusion.  It is better to store them in different enum-ah, and not in one.  In addition, there is the problem of specifying characteristics in the inspector, since  dictionaries and type ‚Äúobject‚Äù are not serialized in Unity3D. <br><br>  In my opinion, there is no need to pursue versatility here.  For example, it is often enough just one data type (int or float), which simplifies the work.  You can also render characteristics with a type other than the rest separate from the dictionary. <br><br><h4>  <b>Modifiers (buffs / debuffs)</b> </h4><br>  Characteristics of the character / item / ability may vary due to the effects of any superimposed effects or effects of dressed items.  The entity that changes these characteristics, in this context, I will call the modifier.  I myself did not work with modifiers, but the topic is important.  Therefore, I will describe my thoughts on how this can be organized in code. <br><br>  A modifier is a component that lists the characteristics it affects and the magnitude of the effect.  It may be even better if the modifier affects only one specified characteristic.  When an effect is applied to a character, a modifier component is added to it.  Further, the modifier calls the function ‚Äúapply itself to such an object‚Äù, and the characteristics of the object are recalculated.  And only those characteristics that it affects.  When removing a modifier - recalculation is performed in the same way.  Most likely, you need to store 2 dictionaries of characteristics - actual (calculated) and initial. <br><br>  Recalculation is needed so that it is not necessary to constantly calculate current values ‚Äã‚Äãduring each access to the character data.  Those.  normal caching for increased performance. <br><br><h4>  <b>Data serialization</b> </h4><br>  When developing games, XML is still very often used, although there are alternatives that are often more convenient - JSON, SQLite, and data storage in prefabs.  Of course, the choice depends on the tasks. <br><br>  When using XML or JSON, many use fairly sub-optimal ways to work with them.  With a bunch of code to read / write / create structures in these formats, and with the need to specify the names of the names of the elements to be addressed in a string form. <br><br>  Instead, you can use serialization.  The structure of XML and JSON in this case will be generated from the code (Code First approach). <br><br>  You can use the built-in .NET tools to serialize XML in Unity3D, and you can use the JsonFx plugin for JSON.  I tested the efficiency of both solutions on Android.  It seems like it should work on other platforms, too.  used API is used in third-party cross-platform plugins. <br><br>  An example of using XML serialization: <br>  <a href="http://wiki.unity3d.com/index.php%3Ftitle%3DSaving_and_Loading_Data:_XmlSerializer">Saving and Loading Data: XmlSerialize</a> <br><br><h4>  <b>What can be read on the architecture in games</b> </h4><br>  In electronic form there is a translation of the following books into Russian: <br><ul><li>  Rollings E., Morris D. Designing and architecture of games (second edition, 2006) </li><li>  <a href="http://gameprogrammingpatterns.com/contents.html">Game Programming Patterns</a> </li></ul><br>  It is also useful to sort out third-party visual scripting systems, for example: PlayMaker, Behavior Machine, Behavior Designer, Rain AI (useful for studying, but not convenient in real projects).  Some of them can draw some ideas, look at what logical blocks can be divided game classes. </div><p>Source: <a href="https://habr.com/ru/post/255561/">https://habr.com/ru/post/255561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255547/index.html">Krovi: Big Data - as dream. Unplanned Series 5: Big Game. Private opinion</a></li>
<li><a href="../255549/index.html">Remember watched videos on youtube</a></li>
<li><a href="../255551/index.html">Scaling operations in the Intel Media SDK</a></li>
<li><a href="../255557/index.html">Sunday tale of the importance of updating, even if you are a botnet operator</a></li>
<li><a href="../255559/index.html">The digest of interesting materials for the mobile # 98 developer (April 6-12)</a></li>
<li><a href="../255565/index.html">ASN1js and PKIjs - a year after creation</a></li>
<li><a href="../255569/index.html">SSO on FreeIPA + Apache + Flask-Login + JWT</a></li>
<li><a href="../255571/index.html">Preview version of WinJS 4.0 announced: universal UX, integration with AngularJS, updated ListView</a></li>
<li><a href="../255573/index.html">qt-items - a new framework, or an attempt to find a theory of everything</a></li>
<li><a href="../255579/index.html">Stephen Wolfram: Frontiers of Computational Thinking (SXSW Festival Report)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>