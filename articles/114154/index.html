<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>B-tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Trees are data structures that implement operations on dynamic sets. I would like to single out of such operations - the search for an ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>B-tree</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Trees are data structures that implement operations on dynamic sets.  I would like to single out of such operations - the search for an element, the search for the minimum (maximum) element, insertion, deletion, transition to the parent, transition to the child.  Thus, the tree can be used both as an ordinary dictionary and as a priority queue. <br><br>  The main operations in trees are performed in a time proportional to its height.  Balanced trees minimize their height (for example, the height of a binary balanced tree with n nodes is log n).  Most are familiar with such balanced trees as the ‚Äúred-ebony tree‚Äù, ‚ÄúAVL-tree‚Äù, ‚ÄúCartesian tree‚Äù, so we will not go deeper. <br><br>  What is the problem with these standard search trees?  Consider a huge database presented in the form of one of the mentioned trees.  Obviously, we cannot store all this tree in RAM =&gt; it stores only a part of information, the rest is stored on third-party media (say, on a hard disk, the access speed to which is much slower).  Trees like red-black or Cartesian will require us to log n calls to third-party media.  For large n it is a lot.  This is the problem that B-trees are supposed to solve! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      B-trees are also balanced trees, so the time for performing standard operations in them is proportional to height.  But, unlike other trees, they were created specifically for efficient work with disk memory (in the previous example, third-party storage media), or rather, they minimize the I / O type inversion. <br><a name="habracut"></a><br><h4>  Structure </h4><br>  When constructing a B-tree, the factor t is applied, which is called the minimal degree.  Each node, except the root, must have at least t - 1, and no more than 2t - 1 keys.  Denoted by n [x] - the number of keys in the node x. <br><br>  Keys in a node are stored in non-decreasing order.  If x is not a leaf, then it has n [x] + 1 children.  If we number the keys in the node x as k [i], and children c [i], then for any key in the subtree with root c [i] (let k1), the following inequality holds: k [i-1] ‚â§k1‚â§ k [i] (for c [0]: k [i-1] = -‚àû, and for c [n [x]]: k [i] = + ‚àû).  Thus, node keys define a range for their children's keys. <br><br>  All the leaves of a B-tree should be located at the same height, which is the height of the tree.  The height of a B-tree with n ‚â• 1 nodes and a minimum degree t ‚â• 2 does not exceed logt (n + 1).  This is a very important statement (why - we will understand later)! <br><br>  h ‚â§ logt ((n + 1) / 2) is the logarithm of the base t. <br><br><h4>  B-tree operations </h4><br>  As mentioned above, in the B-tree all the standard operations of searching, inserting, deleting, etc. are performed. <br><br><h5>  Search </h5><br>  Search in a B-tree is very similar to a search in a binary tree, only here we have to make a choice of the path to the descendant not from 2 options, but from several.  The rest - no difference.  The figure below shows the search for key 27. Let us explain the illustration (and, accordingly, the standard search algorithm): <br><ul><li>  We go on the keys of the root, while less than necessary.  In this case, reached 31. </li><li>  We get down to the child, which is located to the left of this key. </li><li>  We go through the keys of the new node, while less than 27. In this case, we found 27 and stopped. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/f68/57e/1f2f6857e2fa99d307f1b6b371a7fc0e.png" alt="image"><br><br>  The search operation is performed in O (t logt n) time, where t is the minimum degree.  It is important here that we perform only O (logt n) disk operations! <br><br><h5>  Adding </h5><br>  In contrast to the search, the operation of adding is much more complicated than in a binary tree, since it is simply impossible to create a new sheet and insert the key there, since the properties of the B-tree will be violated.  It is also impossible to insert a key into an already completed sheet =&gt; an operation is required to split the node into 2. If the sheet was filled, then there were 2t-1 keys =&gt; split into 2 by t-1, and the middle element (for which t-1 are the first the keys are smaller than it, and the last t-1 more) moves to the parent node.  Accordingly, if the parent node was also filled - then we again have to break.  And so on to the root (if the root is broken, then a new root appears and the depth of the tree increases).  As in the case of ordinary binary trees, insertion is carried out in one pass from the root to the leaf.  At each iteration (in search of a position for a new key - from root to leaf), we break all the filled nodes through which we pass (including the leaf).  Thus, if, as a result, for insertion, it is necessary to break a node, we are sure that its parent is not filled! <br><br>  The figure below illustrates the same tree as in the search (t = 3).  Only now add the key "15".  In search of a position for a new key, we stumble upon a filled node (7, 9, 11, 13, 16).  Following the algorithm, we divide it - at the same time, ‚Äú11‚Äù moves to the parent node, and the initial one is broken down into 2. Next, the key ‚Äú15‚Äù is inserted into the second ‚Äúbreakaway‚Äù node.  All properties of the B-tree are saved! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21b/18f/afb/21b18fafb0065fba63b60477c4d820fb.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/28b/100/00f28b100bfb1cefb0f2df9a2208f337.png" alt="image"><br><br>  The add operation also occurs during O (t logt n).  It is important again that we perform only disk operations O (h), where h is the height of the tree. <br><br><h5>  Deletion </h5><br>  Removing a key from a B-tree is an even more cumbersome and complicated process than inserting.  This is due to the fact that removing from the internal node requires the restructuring of the tree as a whole.  Similar to insertion, it is necessary to check that we save the properties of the B-tree, only in this case it is necessary to keep track of when the keys are t-1 (that is, if the key is deleted from this node, then the node cannot exist).  Consider the deletion algorithm: <br>  1) If deletion occurs from a sheet, then it is necessary to check how many keys are in it.  If more than t-1, then just delete and nothing else to do.  Otherwise, if there is a neighboring sheet (located next to it and having the same parent) that contains more than t-1 key, then we will choose a key from this neighbor, which is a separator between the remaining keys of the neighbor node and the source node (that is, no more all from one group and not less than all from another).  Let it be the key k1.  Select the key k2 from the parent node, which is the separator of the original node and its neighbor, which we chose earlier.  Remove the desired key from the source node (which needed to be deleted), drop the k2 into this node, and instead of k2 in the parent node, put k1.  To make it clearer, the figure below is shown (Fig. 1), where the key "9" is deleted.  If all neighbors of our site have a t-1 key.  Then we merge it with any neighbor, delete the desired key.  And we will move that key from the parent node, which was the separator for these two "former" neighbors, to our newly formed node (obviously, it will be the median in it). <br>  Fig.  one. <br><img src="https://habrastorage.org/getpro/habr/post_images/a50/1c9/f67/a501c9f67b746de70ca2ad11b5b0a085.png" alt="image"><br><br>  2) Now consider removing the key k from the internal node x.  If the child node preceding key k contains more than t-1 key, then we find k1 - the predecessor k in the subtree of this node.  Remove it (recursively run our algorithm).  Replace k in the source node with k1.  We do the same work if the child node following the key k has more than t-1 key.  If both (the next and previous child nodes) have a t-1 key, then we unite these children, transfer k to them, and then remove k from the new node (recursively run our algorithm).  If the last 2 descendants of the root merge, then they become the root, and the previous root is released.  The figure below is shown (Fig. 2), where ‚Äú11‚Äù is removed from the root (the case when the next node has more than t-1 child). <br>  Fig.2. <br><img src="https://habrastorage.org/getpro/habr/post_images/3de/f86/2c4/3def862c44eb090f9684a8fdbcf1f516.png" alt="image"><br><br>  The delete operation occurs at the same time as the O (t logt n) insertion.  And disk operations require only O (h), where h is the height of the tree. <br><br>  So, we are convinced that the B-tree is a fast data structure (along with such as red-black, AVL).  And one more important property that we have received, having considered standard operations, the automatic maintenance of the balance property, let us note that we do not balance it anywhere on purpose. <br><br><h4>  Database </h4><br>  Having analyzed, together with the speed of execution, the number of operations performed with disk memory, we can say that the B-tree is undoubtedly a more advantageous data structure for cases when we have a large amount of information. <br><br>  Obviously, increasing t (the minimum degree), we increase the branching of our tree, and therefore reduce the height!  What t choose?  - Choose according to the size of RAM available to us (ie, how many keys we can view at a time).  Usually this number is in the range from 50 to 2000. Let's see what the branching of the tree gives us with a standard example, which is used in all articles about B-tree.  Suppose we have a billion keys, and t = 1001.  Then we need only 3 disk operations to search for any key!  At the same time, we take into account that we can store the root permanently.  Now you can see how little it is! <br><br>  Also, we do not read individual data from different places, but in whole blocks.  Moving the tree node to the RAM, we move the allocated block of sequential memory, so this operation works fairly quickly. <br><br>  Accordingly, we have a minimal load on the server, and at the same time a small waiting time.  These and other advantages described have allowed B-trees to become the basis for indexes based on trees in a DBMS. <br><br>  <b>Upd: <a href="http://rain.ifmo.ru/cat/view.php/vis/trees/b-2005">visualizer</a></b> <br><br><h4>  Literature </h4><br>  ‚ÄúAlgorithms.  Building and Analyzing "Thomas Kormen, Charles Lazerson, Ronald Rivest, Clifford Stein (Second Edition) <br>  ‚ÄúThe art of programming.  Sort and search ¬ªDonald Knut. </div><p>Source: <a href="https://habr.com/ru/post/114154/">https://habr.com/ru/post/114154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114147/index.html">The practice of using the Onboard Administrator in BladeSystem c3000</a></li>
<li><a href="../114150/index.html">Storing and encrypting Microsoft Windows passwords</a></li>
<li><a href="../114151/index.html">WordPress 3.1 Reinhardt Released</a></li>
<li><a href="../114152/index.html">Resurrecting a dream. A remake of your favorite iphone game</a></li>
<li><a href="../114153/index.html">Quantile Image Segmentation</a></li>
<li><a href="../114156/index.html">280 crinkles or explosive power of regular expressions</a></li>
<li><a href="../114157/index.html">What is the speed of your internet access?</a></li>
<li><a href="../114158/index.html">Scala + Processing is a fun way to learn a new language.</a></li>
<li><a href="../114159/index.html">Introduction to eZ Publish on the example of creating a site</a></li>
<li><a href="../114160/index.html">Cassandra Cluster Rescue Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>