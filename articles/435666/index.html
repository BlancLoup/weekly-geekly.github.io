<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous rasynchron: antipatterns in work with async / await in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who among us does not mow? I regularly meet with errors in asynchronous code and make them myself. To stop this wheel of the Sansara, I share with you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous rasynchron: antipatterns in work with async / await in .NET</h1><div class="post__text post__text-html js-mediator-article"><p>  Who among us does not mow?  I regularly meet with errors in asynchronous code and make them myself.  To stop this wheel of the Sansara, I share with you the most typical shoals of those that are sometimes quite difficult to catch and repair. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zy/vb/px/zyvbpxrx43dnun4q8wcegtqwnn0.png"></div><a name="habracut"></a><br><blockquote>  This text is inspired by <a href="https://blog.stephencleary.com/">Stephen Clary</a> 's <a href="https://blog.stephencleary.com/">blog</a> , a person who knows everything about competitiveness, asynchrony, multithreading and other scary words.  He is the author of the book <a href="http://shop.oreilly.com/product/0636920030171.do">Concurrency in C # Cookbook</a> , which has collected a huge number of patterns for working with competitiveness. </blockquote><br><h2>  Classic asynchronous deadlock </h2><br><p>  To understand the asynchronous deadlock, it is worth understanding which thread the method called using the await keyword is executed on. </p><br><p>  First, the method will go deeper into the chain of calls to async methods until it encounters a source of asynchrony.  How exactly the asynchronous source is implemented is a topic that goes beyond the scope of this article.  Now, for simplicity, we assume that this is an operation that does not require a workflow while waiting for its result, for example, a database request or an HTTP request.  The synchronous launch of such an operation means that while waiting for its result in the system there will be at least one falling asleep thread that consumes resources but does not perform any useful work. </p><br><p> In an asynchronous call, we kind of break the command flow to ‚Äúbefore‚Äù and ‚Äúafter‚Äù the asynchronous operation and in .NET there are no guarantees that the code lying after await will be executed in the same thread as the code before await.  In most cases, this is not necessary, but what to do when this behavior is vital for the program to work?  It is necessary to use <code>SynchronizationContext</code> .  This is a mechanism that allows you to impose certain restrictions on the threads in which the code is executed.  Next, we will deal with two synchronization contexts ( <code>AspNetSynchronizationContext</code> and <code>AspNetSynchronizationContext</code> ), but Alex Davies writes in <a href="http://shop.oreilly.com/product/0636920026532.do">his book</a> that there are about a dozen in .NET.  About <code>SynchronizationContext</code> well written <a href="https://msdn.microsoft.com/en-us/magazine/gg598924.aspx">here</a> , <a href="https://habr.com/post/107583/">here</a> , and <a href="https://habr.com/post/269985/">here the</a> author has implemented his own, for which he has great respect. </p><br><p>  So, as soon as the code comes to the asynchrony source, it saves the synchronization context that was in the <code>SynchronizationContext.Current</code> property of the thread-static, then it starts the asynchronous operation and releases the current thread.  In other words, while we wait for the completion of an asynchronous operation, we do not block any thread and this is the main profit from an asynchronous operation compared to a synchronous one.  After the completion of the asynchronous operation, we must follow the instructions that are after the asynchronous source and here, in order to decide in which thread we execute the code after the asynchronous operation, we need to consult with the previously saved synchronization context.  As he says, so we will do.  He will say to execute in the same thread as the code before await - we will execute in the same, it will not say - we will take the first available stream from the pool. </p><br><p>  And what to do if in this particular case it is important for us that the code after await is executed in any free stream from the thread pool?  You need to use the <code>ConfigureAwait(false)</code> mantra <code>ConfigureAwait(false)</code> .  The false value passed to the <code>continueOnCapturedContext</code> parameter just informs the system that any stream from the pool can be used.  And what will happen if at the moment of executing the method with await there was no synchronization context at all ( <code>SynchronizationContext.Current == null</code> ), as for example in a console application.  In this case, we have no restrictions on the thread in which the code should be executed after await and the system will take the first available stream from the pool, as is the case with <code>ConfigureAwait(false)</code> . </p><br><p>  So, what is asynchronous deadlock? </p><br><h4>  Deadlock in WPF and WinForms </h4><br><p>  The difference between WPF and WinForms applications is the presence of the synchronization context itself.  The WPF and WinForms synchronization context has a special stream - the user interface stream.  The UI stream is one per <code>SynchronizationContext</code> and only from this stream can you interact with user interface elements.  By default, the code that started working in the UI thread resumes operation after an asynchronous operation in it. </p><br>  Now let's look at an example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br>  What happens when you call <code>StartWork().Wait()</code> : <br><br><ol><li>  The calling thread (and this is the user interface thread) will go into the <code>StartWork</code> method and <code>StartWork</code> to the <code>await Task.Delay(100)</code> instruction. </li><li>  The UI thread will start the asynchronous <code>Task.Delay(100)</code> operation, and will return control to the <code>Button_Click</code> method, and there it will be the <code>Wait()</code> method of the <code>Task</code> class.  When the <code>Wait()</code> method is called, the UI thread is blocked until the end of the asynchronous operation, and we expect that as soon as it completes, the UI thread will immediately pick up the execution and go further along the code, however, everything will be wrong. </li><li>  As soon as <code>Task.Delay(100)</code> completes, the UI thread must first continue with the <code>StartWork()</code> method and for this it needs the exact thread in which the execution started.  But the UI thread is currently busy waiting for the result of the operation. </li><li>  <code>StartWork()</code> : <code>StartWork()</code> cannot continue execution and return the result, and <code>Button_Click</code> is waiting for the same result, and because the execution started in the user interface thread, the application simply hangs without a chance to continue working. </li></ol><br>  Such a situation can be quite easily cured by changing the <code>Task.Delay(100)</code> call to <code>Task.Delay(100).ConfigureAwait(false)</code> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br><p>  This code will work without deadlocks, since now the thread from the pool can be used to complete the <code>StartWork()</code> method, and not the blocked UI thread.  Stephen Clary recommends using <code>ConfigureAwait(false)</code> in all ‚Äúlibrary methods‚Äù in his blog, but specifically emphasizes that using <code>ConfigureAwait(false)</code> to treat deadlocks is a wrong practice.  Instead, he advises NOT to use blocking methods like <code>Wait()</code> , <code>Result</code> , <code>GetAwaiter().GetResult()</code> and translate all methods to use async / await, if possible (the so-called Async principle all the way). </p><br><h4>  Deadlock in ASP.NET </h4><br><p>  ASP.NET also has a synchronization context, but it has some other limitations.  It permits the use of only one thread per request at the same time and also requires that the code after await be executed in the same thread as the code before await. </p><br>  Example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deadlock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartWork().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the code following await"</span></span>; } }</code> </pre><br><p>  This code will also cause deadlock, because at the time of the <code>StartWork().Wait()</code> call, the only allowed thread will be blocked and will wait for the <code>StartWork()</code> operation to <code>StartWork()</code> , and it will never end, since the thread that needs to be continued is busy waiting </p><br><p>  It is fixed all the same <code>ConfigureAwait(false)</code> . </p><br><h4>  Deadlock in ASP.NET Core (actually not) </h4><br><p>  Now let's try to run the code from the example for ASP.NET in the project for ASP.NET Core.  If we do this, we will see that there will be no deadlock.  This is due to the fact that <a href="https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html">there is no synchronization context</a> in ASP.NET Core.  Fine!  And what, now you can cover the code with blocking calls and not be afraid of deadlocks?  Strictly speaking, yes, but remember that this causes the stream to fall asleep while waiting, that is, the stream consumes resources, but does not perform any useful work. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/qe/hc/pvqehcevrmzzqhylr7vtedbqwtc.png"></div><br><br><p></p><blockquote>  <b>Remember that using blocking calls eliminates all the benefits of asynchronous programming, making it synchronous</b> .  Yes, sometimes without using <code>Wait()</code> it will not be possible to write a program, but the reason must be serious. </blockquote><br><h2>  Erroneous use of Task.Run () </h2><br><p>  The <code>Task.Run()</code> method was created to start operations in a new thread.  As befits a method written using a TAP pattern, it returns <code>Task</code> or <code>Task&lt;T&gt;</code> and for people who first encounter async / await there is a great desire to wrap the synchronous code in <code>Task.Run()</code> and retrieve the result of this method.  The code seemed to become asynchronous, but in fact nothing has changed.  Let's see what happens with this use of <code>Task.Run()</code> . </p><br>  Example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside before sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside after sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"After: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  The result of this code will be: <br><br><pre> <code class="plaintext hljs">Before: 1 Inside before sleep: 3 Inside after sleep: 3 After: 3</code> </pre><br><p>  Here <code>Thread.Sleep(1000)</code> is any synchronous operation that requires a thread to perform.  Suppose we want to make our solution asynchronous, and so that this operation can be done, we wrapped it in <code>Task.Run()</code> . </p><br><p>  As soon as the code reaches the <code>Task.Run()</code> method, another thread gets from the thread pool and executes the code we passed to <code>Task.Run()</code> .  The old stream, as it should be for a decent stream, returns to the pool and waits for him to be called to do the work again.  The new thread executes the transferred code, reaches the synchronous operation, synchronously executes it (waits until the operation is completed) and proceeds along the code.  In other words, the operation remained synchronous: we, as before, use the stream during the execution of a synchronous operation.  The only difference is that we spent time switching the context when we called <code>Task.Run()</code> and when we returned to <code>ExecuteOperation()</code> .  Things got a little worse. </p><br><p>  It should be understood that despite the fact that in the lines <code>Inside after sleep: 3</code> and <code>After: 3</code> we see the same flow Id, in these places there is a completely different execution context.  Just ASP.NET smarter than us and tries to save resources when switching context from the code inside <code>Task.Run()</code> to external code.  Here he decided not to change at least the flow of execution. </p><br><p>  In such cases, there is no point in using <code>Task.Run()</code> .  Instead, Clary <a href="https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html">advises</a> making all operations asynchronous, that is, in our case, replace <code>Thread.Sleep(1000)</code> with <code>Task.Delay(1000)</code> , but this, of course, is not always possible.  What to do in cases when we use third-party libraries that we cannot or do not want to rewrite and make asynchronous until the end, but for one reason or another we need the async method?  It is better to use <code>Task.FromResult()</code> to wrap the result of the work of vendor methods in Task.  This, of course, does not make the code asynchronous, but at least we will save on context switching. </p><br><p></p><blockquote>  <b>Why then use Task.Run ()?</b>  <a href="https://blog.stephencleary.com/2013/11/taskrun-etiquette-examples-dont-use.html">The answer is simple:</a> for CPU-bound operations, when you need to maintain responsiveness of the UI or parallelize the calculations.  Here it must be said that CPU-bound operations are synchronous in nature.  <code>Task.Run()</code> was invented to start synchronous operations in asynchronous style. </blockquote><br><h2>  Using async void is not as intended </h2><br>  The ability to write asynchronous methods that return <code>void</code> was added to write asynchronous event handlers.  Let's see why they can make confusion, if they are used for other purposes: <br><br><ol><li>  You can not wait for the result. </li><li>  Exception handling via try-catch is not supported. </li><li>  You can not combine calls through <code>Task.WhenAll()</code> , <code>Task.WhenAny()</code> and other similar methods. </li></ol><br><p>  Of all the reasons listed, the most interesting point is the exception handling.  The fact is that in the async methods that return <code>Task</code> or <code>Task&lt;T&gt;</code> , exceptions are caught and wrapped in a <code>Task</code> object, which will then be passed to the calling method.  In <a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx">his MSDN article,</a> Clary writes that since there are no return values ‚Äã‚Äãin the async-void methods, there‚Äôs no way to wrap exceptions in the context of synchronization.  The result is an unhandled exception due to which the process crashes, succeeding, except to write an error to the console.  You can get and log such exceptions by subscribing to the <code>AppDomain.UnhandledException</code> event, but the process crash cannot be stopped even in the event handler.  This behavior is typical just for the event handler, but not for the usual method, from which we expect the possibility of standard exception handling via try-catch. </p><br>  For example, if you write this in an ASP.NET Core application, the process is guaranteed to fall: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowInAsyncVoid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThrowAsynchronously(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowAsynchronously</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Obviously, something happened"</span></span>); }</code> </pre><br><p>  But it is worth changing the type of the return value of the <code>ThrowAsynchronously</code> method to <code>Task</code> (even without adding the await keyword) and the exception will be intercepted by the standard ASP.NET Core error handler, and the process will continue to live despite the exception. </p><br><p></p><blockquote>  <b>Be careful with async-void methods</b> - they can put you in the process. </blockquote><br><h2>  await in one line method </h2><br><p>  The latest anti-pattern is not as terrible as the previous ones.  The bottom line is that it makes no sense to use async / await in methods that, for example, simply forward the result of another async method further, with the possible exception of using <a href="https://stackoverflow.com/questions/19098143/what-is-the-purpose-of-return-await-in-c/19103343">await in using</a> . </p><br>  Instead of this code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br>  it is quite possible (and preferable) to write: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  Why does this work?  Because the await keyword can be applied to Task-like objects, and not to methods marked with the async keyword.  In turn, the async keyword just tells the compiler that this method needs to be expanded into a state machine, and all the returned values ‚Äã‚Äãshould be wrapped into a <code>Task</code> (or into another Task-like object). </p><br><p>  In other words, the result of the first version of the method is <code>Task</code> , which will become <code>Completed</code> as soon as the <code>Task.Delay(1000)</code> , and the result of the second version of the method is <code>Task</code> , returned by <code>Task.Delay(1000)</code> itself <code>Task.Delay(1000)</code> , which will become <code>Completed</code> as soon as 1000 milliseconds pass. . </p><br><p>  As you can see, both versions are equivalent, but at the same time, the first requires much more resources to create an asynchronous "body kit." </p><br><p></p><blockquote>  Alex Davis writes that <b>costs directly to calling an asynchronous method can be ten times more than the cost of calling a synchronous method</b> , so there is something to try for. </blockquote><br><br>  <b>UPD:</b> <br>  As rightly noted in the comments, cutting out async / await from single-line methods leads to negative side effects.  For example, when throwing an exception, the method that forwards Task to the top will not be visible in the stack.  Therefore, <b>removing default bytes is not recommended</b> .  <a href="https://blog.stephencleary.com/2016/12/eliding-async-await.html">Post Clary</a> with analysis. </div><p>Source: <a href="https://habr.com/ru/post/435666/">https://habr.com/ru/post/435666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435654/index.html">Pitfalls of custom CSS properties</a></li>
<li><a href="../435656/index.html">Rolls-Royce among scooters - Ninebot KickScooter ES4 by Segway</a></li>
<li><a href="../435658/index.html">Chinese internet censoring</a></li>
<li><a href="../435662/index.html">"Reliability and dependability as in Google" - and not only: translation of the article "Calculation of reliability of service"</a></li>
<li><a href="../435664/index.html">Google search engine spoofing</a></li>
<li><a href="../435668/index.html">Another law of Spring: the deputy proposed to allow the police to track the location of children using geolocation</a></li>
<li><a href="../435670/index.html">High Algorithm - Algorithm Distribution by Levels of Difficulty</a></li>
<li><a href="../435672/index.html">How to retrain in business analyst</a></li>
<li><a href="../435676/index.html">Terabyte SD card is on sale</a></li>
<li><a href="../435678/index.html">Do not trust the memory information in the Task Manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>