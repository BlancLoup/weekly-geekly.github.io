<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a Match-3 game in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, at SeishunCon, I rediscovered match-3 games. I played Dr. Mario is a child, but more competitive games like Magical Drop , Bust-A-Mov...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a Match-3 game in Unity</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f26/d81/ec1/f26d81ec11b30fcd762bf4fde2b1cc3e.png" alt="image"></div><br>  A few years ago, at <a href="http://seishun-con.com/">SeishunCon,</a> I rediscovered match-3 games.  I played Dr.  Mario is a child, but more competitive games like <em>Magical Drop</em> , <em>Bust-A-Move</em> and <em>Tokimeki Memorial Taisen Puzzle-Dama</em> are very different from hers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ef/4eb/5c0/7ef4eb5c05fa00f48d0ae41c96f62eff.gif" alt="image"><br>  <i>Dr.</i>  <i>Mario</i> <br><br>  As a result, I realized how many neutral decisions are associated with the creation of the match-3 game. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the next Ludum Dare jam, I decided to experiment, but first, a week before this, I tried to develop a Tetris algorithm for detecting and deleting lines to warm up.  <a href="http://unityplus.blogspot.com/2014/06/tetris-game-tutorial-part-1.html">This tutorial Unity Plus</a> helped me a lot.  <i>[Approx.</i>  <i>Lane: My link does not open.</i>  <i>If you know how to solve the problem, write to me, I will add the article.]</i> Of course, the Tetris algorithm for finding filled rows is much simpler than the algorithm that looks for various combinations of matching tiles. <br><br>  If you want to examine these code examples in context, then go to my <a href="https://bitbucket.org/dylanwolf/ludumdare30">Ludum Dare 30 repository</a> .  (For shameless self-promotion, I again used this logic to play <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.FuncWorks.ShiftyShapes">Shifty Shapes</a> .) <br><br><h2>  Two worlds </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/699/ac6/54c/699ac654cc202f5535595172e6b73f43.jpg"><br>  <i>Magical Drop 3 (source: <a href="http://www.neogeoforlife.com/viewpage.php%3Fpage_id%3D68">Kazuya_UK</a> )</i> <br><br>  The most tricky part of creating a puzzle game in Unity is that the game does not live in the space of the world.  In any case, does not live completely. <br><br>  This is its difference from other genres.  Platformers, for example, almost completely live in the game world of Unity.  Transform player reports his position.  Colliders (or, in some cases, a raycast) tell whether a player is on the ground, hits the ceiling or collides with the enemy.  Even if you do not use in-game physics, you still most likely add strength or specify the speed of the Rigidbody to ensure collision recognition at no cost. <br><a name="habracut"></a><br>  Puzzle games are completely different.  If in your game you need to click the mouse, then it probably gets some coordinates in the space of the world, but they are usually converted into a grid cell, which completely lives in the code.  There is a clear reason for this: it is much easier to create logic for a game like Tetris or Dr.  Mario, when you work not with individual pixels, but with blocks or tiles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/935/790/d1f/935790d1f225186b27fd8b4000863a2b.png"><br>  <i>Tetris blocks should definitely not stick to the walls of the glass</i> <br><br>  In fact, in my experiments, I tried to stick to the space of the world as much as possible.  I used physics to determine the "landing" of tiles and transferred data to a two-dimensional array only to determine the filling of the string.  It seemed more secure: after all, what happens in the game world is <i>real</i> .  This is what the player sees, so if you store the data here, then there is no risk of out of sync, right? <br><br>  I was wrong.  No matter how I tried to configure the system, it just did not work correctly. <br><br>  The Unity Plus tutorial, the link to which I gave above, was of great help to me.  At a minimum, he showed that the correct approach was the complete transfer of logic from the game world to an abstract data structure.  If you have not done this yet, then at least briefly review it, because in this article I will expand the logic of "Tetris" to the logic of match-3. <br><br><h2>  Transformation from field to world space </h2><br>  As soon as I realized that this transition was convenient, the rest was simple.  I created a GameTile class that tracks the color, row and column of a tile, and based on it, updated the position of the tile.  Here is his abbreviated version: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Transform _t; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SpriteRenderer _s; [System.NonSerialized] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TileColor; [System.NonSerialized] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Row; [System.NonSerialized] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Column; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _t = GetComponent&lt;Transform&gt;(); _s = GetComponent&lt;SpriteRenderer&gt;(); } Vector3 tmpPos; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tmpPos = _t.position; tmpPos.x = (Column * Board.TileSize) - Board.WorldOffset; tmpPos.y = (Row * Board.TileSize) - Board.WorldOffset; _t.position = tmpPos; _s.sprite = Board.Current.Textures[TileColor]; }</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/35c/cb5/90a/35ccb590aa93882cb8f187944bf7a487.png"><br>  <i>Tiles in the grid</i> <br><br>  Note that in this case TileSize is a constant that determines the size of the tile in Unity units.  I use tiles of 64 √ó 64 pixels, and the sprite in Unity has a resolution of 100 pixels per unit, so TileSize is equal to 0.64.  I also use a constant offset so that the middle of the 7 √ó 7 field is in the coordinates of 0.0 space of the world, and the bottom left corner is the tile 0, 0 in the game space. <br><br>  I also created an array defining the playing field as a static field in the Board class.  (Board was first a static class, and then turned into a singleton (singleton), because I needed to change the values ‚Äã‚Äãin the editor, so it clumsily combines the features of a game object and a static class.) <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TileSize = <span class="hljs-number"><span class="hljs-number">0.64f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WorldOffset = <span class="hljs-number"><span class="hljs-number">1.92f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BoardSize = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GameTile[,] Tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[BoardSize, BoardSize];</code> </pre> <br>  In the Unity Plus tutorial, a two-dimensional array was used to store integers, but I decided to store references to my GameTile objects in this array.  This allowed me to transfer data from and to tiles directly (as you will see later), which made it easier to delete tiles and create animations. <br><br>  When making changes to the state of the playing field, I just had to cycle through the entire field array and tell each tile where it should be: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateIndexes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> updatePositions</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; BoardSize; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; BoardSize; x++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tiles[x,y] != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Tiles[x, y].Row = y; Tiles[x, y].Column = x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatePositions) Tiles[x, y].UpdatePosition(); } } } }</code> </pre> <br>  Notice that in each case we transform from the abstract game space into the space of the world.  Unity game objects do not store important information about the state of the game, they are always only a display of this state. <br><br><h2>  ‚Ä¶ and back </h2><br>  In my game there was <em>only one</em> case when it was necessary to perform a transformation from the world into the game space: when a player clicked on an empty space to throw a tile on the field.  For this task, I created a large collider under the entire playing field and attached the following script to it: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameState.Mode == GameState.GameMode.Playing) { mouseClick = Camera.main.ScreenToWorldPoint(Input.mousePosition); mouseX = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Mathf.Round ((mouseClick.x + WorldOffset) / TileSize); mouseY = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Mathf.Round ((mouseClick.y + WorldOffset) / TileSize); PutNextTile(mouseX, mouseY); Soundboard.PlayDrop(); GameState.ActionsTaken++; } }</code> </pre> <br>  That's all.  Notice that, in essence, an action is performed in it, the opposite of UpdatePosition (), where the game space is converted into the space of the world. <br><br><h2>  Recognizing and deleting matched tiles </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f04/63f/8e3/f0463f8e3df611a13b49d5e1b4f6a4ae.png"><br>  <i>Deleting matched tiles</i> <br><br>  This is the trickiest part.  Probably for the sake of this you are reading an article. <br><br>  Horizontal coincidence (as in Tetris) is quite simple to implement: you just need to look for adjacent tiles in one line.  Even adding horizontal <em>or</em> vertical matches (as in Dr. Mario) is just a variation of this theme.  However, tracking a set of contiguous tiles in both the horizontal <em>and</em> vertical directions will require recursion. <br><br>  With each action that changes the playing field, we run a check.  The first thing we do is copy the entire array of the field to another array: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyBoard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile[,] source, GameTile[,] destination</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; BoardSize; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; BoardSize; x++) { destination[x, y] = source[x, y]; } } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> clearedTiles = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MatchAndClear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile[,] board</span></span></span><span class="hljs-function">)</span></span> { clearedTiles = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      CopyBoard(board, toTest); //  ...</span></span></code> </pre> <br>  What for?  We will see later that it will be <em>much</em> easier to determine which tiles we checked. <br><br>  We begin the process with a "rough" search.  Go from cell to cell (rows first, then columns), checking each cell.  For each check, we reset some variables used to track the check, and then call a separate function (which is later used for recursion): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  MatchAndClear()... currentTile = null; collector.Clear (); for (int y = 0; y &lt; BoardSize; y++) { for (int x = 0; x &lt; BoardSize; x++) { TestTile (x, y); //  ...</span></span></code> </pre> <br>  Let's look at this TestTile function: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,  if (toTest[x,y] == null) { return; } //    if (currentTile == null) { currentTile = toTest[x, y]; toTest[x, y] = null; collector.Add(currentTile); } // **   -      ** //     ,       if (x &gt; 0) TestTile(x - 1, y); if (y &gt; 0) TestTile(x, y - 1); if (x &lt; Board.BoardSize - 1) TestTile(x + 1, y); if (y &lt; Board.BoardSize - 1) TestTile(x, y + 1); }</span></span></code> </pre> <br>  If the function detects that the cell is null, then skip it.  A cell with null means that it is either empty, or we have already tested it.  (That's why we copied it into a separate array ‚Äî it's easier to arbitrarily manipulate the new array.) <br><br>  If the cell has a value, then we do the following.  First, we memorize it as a ‚Äúcurrent‚Äù cell, one that is at the top of the recursive chain.  Then we remove it from the copy of the playing field, so as not to double check.  We also add it to the List to remember how many adjacent tiles of the same color we found. <br><br>  There are two conditions that can occur later in recursion, but we will talk about them later.  After checking the cell, we take four cells around it and perform the same check for them. <br><br>  The ‚Äúcurrent‚Äù cell is already set, which means that we are not on the first level of recursion.  In these function calls, we have three options for each cell. <br><br>  First, the cell may be null, and this again means that we have already tested it, or it is empty.  And in this case, we do nothing again. <br><br>  Secondly, the cell may not match the ‚Äúcurrent‚Äù cell.  In this case, we do not consider it "proven".  Our recursion checks for one set of adjacent tiles of the same color.  Just because this tile is not part of the current set does not mean that it is not part of any other. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  TestTile() ... //   ,  else if (currentTile.TileColor != toTest[x, y].TileColor) { return; }</span></span></code> </pre> <br>  Third, the cell may be the same color as the ‚Äúcurrent‚Äù cell.  In this case, it is ‚Äúverified‚Äù, so we set it to null in the copy of the playing field.  We also add it to the List, which we use as a drive.  This is one of the states that we missed in the example above: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  TestTile() ... //   else { collector.Add(toTest[x, y]); toTest[x, y] = null; }</span></span></code> </pre> <br>  The function will continue to perform recursion until all options have run out, reaching either the empty cell or the end of the field.  At this point, we return to the main brute force loop for processing the results. <br><br>  If there are more than three tiles in the drive, then we have found a match.  If not, we checked one or two tiles, but we do not need to perform any actions: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   MatchAndClear() ... if (collector.Count &gt;= 3) { foreach (GameTile tile in collector) { ClearTile(tile.Column, tile.Row); clearedTiles = true; Soundboard.PlayClear(); } } currentTile = null; collector.Clear (); } } if (clearedTiles) { SettleBlocks(board) } }</span></span></code> </pre> <br>  Here, as we look at later, I just turn on the animation.  The simplest approach, however, is to cycle through our drive and call DestroyObject for the game object of each matching tile.  So we will kill two birds with one stone: we will get rid of the in-game objects and set the cells in the state of the playing field to null. <br><br><h2>  Tile fall </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f26/d81/ec1/f26d81ec11b30fcd762bf4fde2b1cc3e.png"><br>  <i>Falling tile</i> <br><br>  Certain changes ‚Äî for example, dropping a tile or deleting tiles, in this case ‚Äî leave tiles without support, and this case must be resolved (of course, if this is required by the rules of your game).  And in fact, this is a fairly simple algorithm. <br><br>  Now we go column by column, and then line by line.  The order here is important. <br><br>  In each column, we pass upwards until we find an empty cell.  Then we tag it.  We simply shift the next found tile down to this position, and add one to the index of the ‚Äúempty cell‚Äù: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? firstEmpty; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SettleBlocks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile[,] board</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; BoardSize; x++) { firstEmpty = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; BoardSize; y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (board[x, y] == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !firstEmpty.HasValue) { firstEmpty = y; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstEmpty.HasValue &amp;&amp; board[x, y] != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board[x, firstEmpty.Value] = board[x, y]; board[x, y] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; firstEmpty++; } } } UpdateIndexes(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br>  After completion, you need to remember to call the match function again.  It is very likely that the falling tiles created empty lines. <br><br>  In fact, if the game is scored, it will make it easier to keep track of combos or points multipliers.  All these repetitions of drops and block deletions are recursions of that first call launched by the player‚Äôs action.  We can understand how many coincidences arose after the player‚Äôs actions and how many levels of ‚Äúchains‚Äù were required for each action. <br><br><h2>  Animations </h2><br>  The game is already working, but so far it is not intuitively understandable, mainly due to the lack of animations.  Tiles disappear and then appear on the bottom lines.  It is difficult to understand what happens if you do not follow closely. <br><br>  This is also a difficult moment.  Game objects are always a reflection of the state of the game, so tiles are constantly located in the grid.  Tiles always occupy this or that place: a tile can be in line 1 or 2, but never in line 1.5. <br><br>  What is the difficulty?  We cannot simultaneously <em>manipulate the playing field</em> and <em>animation</em> .  Remember how Tetris or Dr.  Mario - the next tile does not fall until all the tiles on the field ‚Äúcope‚Äù.  This gives the player a short respite, and also guarantees the absence of unforeseen states and interactions. <br><br>  By the way, when starting a new project, I recommend creating an enumeration of ‚Äúgame states‚Äù.  I never had to write a game in which you did not need to know the state of the game: the process of the game itself, pause, menu display, dialog box, and so on.  It is best to plan for states in the early stages of development, so you can have <em>each</em> line of code written by you check to see if it should run in its current state. <br><br>  I admit that my implementation is awkward, but in general the idea is this: when a tile is removed or dropped, we use a state change.  Each GameTile object knows how to handle this state change, and, more importantly, knows when to tell the game board that it has completed its animation: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameState.Mode == GameState.GameMode.Falling &amp;&amp; Row != LastRow) { targetY = (Row * Board.TileSize) - Board.WorldOffset; tmpPos = _t.position; tmpPos.y -= FallSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmpPos.y &lt;= targetY) { Board.fallingBlocks.Remove(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); UpdatePosition(); Soundboard.PlayDrop(); } } }</code> </pre> <br>  After completing the removal animation, the game should check for falling tiles: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DisappearTimer = <span class="hljs-number"><span class="hljs-number">0.667f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameState.Mode == GameState.GameMode.Disappearing) { timer -= Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timer &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameState.Mode = GameState.GameMode.Playing; SettleBlocks(Tiles); } }</code> </pre> <br>  After the drop animation is complete, you need to check for matches: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameState.Mode == GameState.GameMode.Falling &amp;&amp; fallingBlocks.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameState.Mode = GameState.GameMode.Playing; MatchAndClear(Tiles); } }</code> </pre> <br>  This cycle repeats until we have more matches left, after which the game can return to its work. </div><p>Source: <a href="https://habr.com/ru/post/329016/">https://habr.com/ru/post/329016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329006/index.html">Non-standard way of teaching a new programming language (translation of the article Sahil Dua)</a></li>
<li><a href="../329008/index.html">Cognitive dissonance and its application in marketing</a></li>
<li><a href="../329010/index.html">Is the impact of speed on site results critical and what can be done about it?</a></li>
<li><a href="../329012/index.html">Attorney Broflowski principle, or do-it-yourself cloud load balancing</a></li>
<li><a href="../329014/index.html">Automation of load testing of banking software for terminals</a></li>
<li><a href="../329018/index.html">Why are women programmers much less than men? Infographic survey from "My Circle"</a></li>
<li><a href="../329020/index.html">Successful CIO in 2017: what is he?</a></li>
<li><a href="../329022/index.html">SSL implementation through SAML with an example</a></li>
<li><a href="../329024/index.html">Diagnostic Tools Plugin for Qt Creator</a></li>
<li><a href="../329026/index.html">Kotlin vs. Java: compile speed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>