<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We instantiate java.lang.Class</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The java.lang.Class constructor is one of the most protected entities in the Java language. The specification clearly states that only the JVM itself ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We instantiate java.lang.Class</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/qx/lo/c2/qxloc2zz5bwezenjtg1d4o-rfg0.jpeg"></p><br><p> The <code>java.lang.Class</code> constructor is one of the most protected entities in the Java language.  The specification clearly states that only the JVM itself can create objects of type <code>Class</code> and what can we do here, but is it really so? </p><br><p>  I propose to dive into the depths of the Reflection API (and not only) and find out how everything is arranged there and how difficult it will be to bypass the existing limitations. </p><a name="habracut"></a><br><p>  I am experimenting on a 64-bit JDK 1.8.0_151 with default settings.  Java 9 is at the very end of the article. </p><br><h2 id="uroven-1-prostoy">  Level 1. Simple </h2><br><p>  Let's start with the most naive attempts and go incrementally.  First, let's face the enemy: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassLoader loader)</span></span></span><span class="hljs-function"> </span></span>{ classLoader = loader; }</code> </pre> <br><p>  This designer is nothing special.  The compiler does not make any exceptions for it, and the constructor is also present in the bytecode.  Therefore, we will try to do the same as we would do with any other class: </p><br><pre> <code class="java hljs">Constructor&lt;Class&gt; constructor = Class.class.getDeclaredConstructor(ClassLoader.class); constructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Class&lt;?&gt; clazz = constructor.newInstance(ClassLoader.getSystemClassLoader());</code> </pre> <br><p>  Quite expectedly, this code will not work and will generate the following error: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Exception</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SecurityException</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">Cannot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">make</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">constructor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">accessible</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AccessibleObject</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setAccessible0</span></span>(...) <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AccessibleObject</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setAccessible</span></span>(...) <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Sample</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span>(...)</code> </pre> <br><p>  From the first attempt, we hit the first warning from the <code>setAccessible0</code> method.  It is hard-coded specifically for the constructor of the <code>java.lang.Class</code> class: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAccessible0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AccessibleObject obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flag)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SecurityException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Constructor &amp;&amp; flag == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { Constructor&lt;?&gt; c = (Constructor&lt;?&gt;) obj; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.getDeclaringClass() == Class.class) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException(<span class="hljs-string"><span class="hljs-string">"Cannot make a java.lang.Class"</span></span> + <span class="hljs-string"><span class="hljs-string">" constructor accessible"</span></span>); } } obj.override = flag; }</code> </pre> <br><p>  Not a problem, because the key line in this method is the last one - setting the <code>override</code> field to <code>true</code> .  This is easily done using brute force: </p><br><pre> <code class="java hljs">Field overrideConstructorField = AccessibleObject.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"override"</span></span>); overrideConstructorField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); overrideConstructorField.set(constructor, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre> <br><h2 id="uroven-2-poslozhnee">  Level 2. More difficult </h2><br><p>  Naturally, setting the <code>override</code> flag is not the only restriction, but now we can at least move a little further in the <code>newInstance</code> method.  Far enough to plan next steps.  This time the error will be as follows: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Exception</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InstantiationException</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">Can</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">not</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">instantiate</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sun</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InstantiationExceptionConstructorAccessorImpl</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.newInstance</span></span>(...) <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Constructor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.newInstance</span></span>(...) <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Sample</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span>(...)</code> </pre> <br><p>  We were brought straight to the class of the <code>sun.reflect</code> package, and we know that the main magic should occur there.  It's time to look into the implementation of the <code>newInstance</code> class <code>Constructor</code> and find out how we got there: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object ... initargs)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ... </span></span>{ ... ConstructorAccessor ca = constructorAccessor; <span class="hljs-comment"><span class="hljs-comment">// read volatile if (ca == null) { ca = acquireConstructorAccessor(); } @SuppressWarnings("unchecked") T inst = (T) ca.newInstance(initargs); return inst; }</span></span></code> </pre> <br><p>  From the implementation, it becomes clear that <code>Constructor</code> delegates all the work of instantiating another object of type <code>ConstructorAccessor</code> .  It is initialized in a lazy way and does not change in the future.  I will not describe the internals of the <code>acquireConstructorAccessor</code> method; I will just say that as a result, it leads to a call to the <code>newConstructorAccessor</code> method of <code>newConstructorAccessor</code> object of the <code>sun.reflect.ReflectionFactory</code> class.  And it is for the constructor of the <code>java.lang.Class</code> class (and also for abstract classes) that this method returns an <code>InstantiationExceptionConstructorAccessorImpl</code> object.  He does not know how to instantiate, but only throws exceptions at every call to him.  All this means only one thing: the correct <code>ConstructorAccessor</code> will have to be instantiated by itself. </p><br><h2 id="uroven-3-nativnyy">  Level 3. Native </h2><br><p>  Time to find out what types of <code>ConstructorAccessor</code> objects are (in addition to the one described above): </p><br><ul><li>  <code>BootstrapConstructorAccessorImpl</code> : <br>  used to instantiate classes that are themselves implementations of <code>ConstructorAccessor</code> .  Probably saves some code from endless recursion.  The thing is highly specialized, I will not touch it; </li><li>  <code>GeneratedConstructorAccessor</code> : <br>  the most interesting implementation, which I will discuss in detail, but later; </li><li>  A bunch of <code>NativeConstructorAccessorImpl</code> and <code>DelegatingConstructorAccessorImpl</code> : <br>  what is returned by default, and therefore will be considered by me first.  <code>DelegatingConstructorAccessorImpl</code> simply delegates its work to another object stored in its field.  The advantage of this approach is that it allows you to replace the implementation on the fly.  This is exactly what is happening - <code>NativeConstructorAccessorImpl</code> for each designer works maximum as many times as specified in the <code>sun.reflect.inflationThreshold</code> system property (15 by default), after which it is replaced with <code>GeneratedConstructorAccessor</code> .  To be fair, it‚Äôs worth adding that setting the <code>sun.reflect.noInflation</code> property to <code>"true"</code> essentially resets <code>inflationThreshhold</code> to zero, and <code>NativeConstructorAccessorImpl</code> stops being created in principle.  By default, this property is set to <code>"false"</code> . </li></ul><br><p>  So for the most ordinary class under the most ordinary circumstances, we would get an object <br>  <code>NativeConstructorAccessorImpl</code> , which means that we are <code>NativeConstructorAccessorImpl</code> to create it manually: </p><br><pre> <code class="java hljs">Class&lt;?&gt; nativeCAClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"sun.reflect.NativeConstructorAccessorImpl"</span></span>); Constructor&lt;?&gt; nativeCAConstructor = nativeCAClass.getDeclaredConstructor(Constructor.class); nativeCAConstructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); ConstructorAccessor constructorAccessor = (ConstructorAccessor) nativeCAConstructor.newInstance(constructor);</code> </pre> <br><p>  There are no dirty tricks here: the object is created without unnecessary restrictions, and all we have to do is to instantiate <code>java.lang.Class</code> with it: </p><br><pre> <code class="java hljs">Class&lt;?&gt; clazz = (Class&lt;?&gt;) constructorAccessor.newInstance( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{ClassLoader.getSystemClassLoader()});</code> </pre> <br><p>  But here a surprise awaits: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta"># # A fatal </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> has been detected by the Java Runtime Environment: # # SIGSEGV (0xb) at pc=0x00007f8698589ead, pid=20537, tid=0x00007f8699af3700 # # JRE version: Java(TM) SE Runtime Environment (8.0_151-b12) (build 1.8.0_151-b12) # ...</span></span></code> </pre> <br><p>  It seems that the JVM does not expect such illogical actions from the user, especially after all the warnings.  Nevertheless, this result can rightfully be considered an achievement - I‚Äôve been flooded with the JVM, never taking advantage of the classes in the <code>sun.misc</code> package! </p><br><h2 id="uroven-4-magicheskiy">  Level 4. Magical </h2><br><p>  Native call does not work - so now you need to deal with <code>GeneratedConstructorAccessor</code> . </p><br><p>  In fact, this is not just a class, but a whole family of classes.  For each constructor in runtime, its own unique implementation is generated.  That is why the native implementation is primarily used: to generate bytecode and create a class of cost from it.  The class generation process itself is hidden in the <code>generateConstructor</code> method of the <code>sun.reflect.MethodAccessorGenerator</code> class.  Call it manually is not difficult: </p><br><pre> <code class="java hljs">Class&lt;?&gt; methodAccessorGeneratorClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"sun.reflect.MethodAccessorGenerator"</span></span>); Constructor&lt;?&gt; methodAccessorGeneratorConstructor = methodAccessorGeneratorClass.getDeclaredConstructor(); methodAccessorGeneratorConstructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Object methodAccessorGenerator = methodAccessorGeneratorConstructor.newInstance(); Method generateConstructor = methodAccessorGeneratorClass .getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"generateConstructor"</span></span>, Class.class, Class[].class, Class[].class, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.class); generateConstructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); ConstructorAccessor constructorAccessor = (ConstructorAccessor) generateConstructor.invoke(methodAccessorGenerator, constructor.getDeclaringClass(), constructor.getParameterTypes(), constructor.getExceptionTypes(), constructor.getModifiers());</code> </pre> <br><p>  As in the case of <code>NativeConstructorAccessorImpl</code> , there are no pitfalls here - this code will work and do exactly what is expected of it.  But let's think for a minute: well, have we generated some class, where will the rights to call the private constructor come from?  This should not be, so we simply must dump the generated class and examine its code.  It's easy to do this - we set up a debugger in the <code>generateConstructor</code> method and at the right moment we dump the array of bytes we need into a file.  Its decompiled version looks like this (after renaming variables): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeneratedConstructorAccessor1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstructorAccessorImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InvocationTargetException </span></span>{ Class clazz; ClassLoader classLoader; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { clazz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(); } classLoader = (ClassLoader) args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullPointerException | ClassCastException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(e.toString()); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { clazz.&lt;init&gt;(classLoader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvocationTargetException(e); } } }</code> </pre> <br><p>  Naturally, such code will not compile back, and there are two reasons for this: </p><br><ul><li>  call <code>new Class</code> without parentheses.  It corresponds to the <code>NEW</code> instruction, which allocates memory for the object, but the constructor does not call it; </li><li>  calling <code>clazz.&lt;init&gt;(classLoader)</code> is just a constructor call that is not possible in this explicit form in Java. </li></ul><br><p>  These instructions are spaced in order to be in different try-blocks.  Why it was done this way, I do not know.  This was probably the only way to handle exceptions so that they fully comply with the language specification. </p><br><p>  If we turn a blind eye to the atypical handling of exceptions, then in all other respects this class is absolutely normal, but it is still unclear where it suddenly has the right to call private designers.  It turns out that the whole thing is in the superclass: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstructorAccessorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MagicAccessorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstructorAccessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstantiationException, IllegalArgumentException, InvocationTargetException</span></span>; }</code> </pre> <br><p>  The JVM has a well known crutch called <code>sun.reflect.MagicAccessorImpl</code> .  Every successor has unlimited access to any private data of any classes.  This is exactly what you need!  Once the class is magic, it will help get the <code>java.lang.Class</code> instance.  Checking: </p><br><pre> <code class="java hljs">Class&lt;?&gt; clazz = (Class&lt;?&gt;) constructorAccessor.newInstance( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{ClassLoader.getSystemClassLoader()});</code> </pre> <br><p>  and again we get an exception: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Exception</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.IllegalAccessError</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sun</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GeneratedConstructorAccessor1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.newInstance</span></span>(...) <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Sample</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span>(...)</code> </pre> <br><p>  This is really interesting.  Apparently, the promised magic did not happen.  Or I'm wrong? </p><br><p>  It is worth examining the error more carefully and comparing it with how the <code>newInstance</code> method should behave.  If there were a problem in the <code>clazz.&lt;init&gt;(classLoader)</code> , we would get an <code>InvocationTargetException</code> .  In fact, we have <code>IllegalAccessError</code> , that is, it didn‚Äôt get to the constructor‚Äôs call.  With an error, the <code>NEW</code> instruction worked, not allowing memory to be allocated for the <code>java.lang.Class</code> object.  Here our powers are all over. </p><br><h2 id="uroven-5-sovremennyy">  Level 5. Modern </h2><br><p>  Reflection did not solve the problem.  Maybe the fact is that Reflection is old and weak, and instead you should use the young and strong MethodHandles?  I think yes.  At least worth a try. </p><br><p>  And as soon as I decided that Reflection is not needed, it was immediately useful.  MethodHandles is, of course, good, but with the help of it it is customary to receive only those data that is accessible.  And if you need a private constructor, you will have to get out the old fashioned way. </p><br><p>  So, we need <code>MethodHandles.Lookup</code> with private access to the <code>java.lang.Class</code> class.  In this case there is a very suitable constructor: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; lookupClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> allowedModes)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Call it: </p><br><pre> <code class="java hljs">Constructor&lt;MethodHandles.Lookup&gt; lookupConstructor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.class); lookupConstructor.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); MethodHandles.Lookup lookup = lookupConstructor .newInstance(Class.class, MethodHandles.Lookup.PRIVATE);</code> </pre> <br><p>  After receiving the <code>lookup</code> , you can get the <code>MethodHandle</code> object corresponding to the constructor we need: </p><br><pre> <code class="java hljs">MethodHandle handle = lookup.findConstructor(Class.class, MethodType.methodType(Class.class, ClassLoader.class));</code> </pre> <br><p>  After running this method, I was frankly surprised - <code>lookup</code> pretends that the constructor does not exist at all, although it is definitely present in the class! </p><br><pre> <code class="hljs dos">Exception <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> thread "main" java.lang.NoSuchMethodException: no such constructor: java.lang.Class.&lt;init&gt;(ClassLoader)Class/newInvokeSpecial <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MemberName.makeAccessException(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MemberName$Factory.resolveOrFail(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MethodHandles$Lookup.resolveOrFail(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MethodHandles$Lookup.findConstructor(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> Sample.main(Sample.java:<span class="hljs-number"><span class="hljs-number">59</span></span>) Caused by: java.lang.NoSuchFieldError: method resolution failed <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MethodHandleNatives.resolve(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MemberName$Factory.resolve(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.MemberName$Factory.resolveOrFail(...) ... <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">more</span></span></code> </pre> <br><p>  Strangely, the reason for the exception is <code>NoSuchFieldError</code> .  Mysteriously ... </p><br><p>  This time I was mistaken, but far from immediately I understood it.  The <code>findConstructor</code> specification requires that the return type be <code>void</code> , despite the fact that the result <code>MethodType</code> will be exactly the same as I described (all because the <code>&lt;init&gt;</code> method responsible for the constructor does return <code>void</code> for historical reasons). <br>  Anyway, confusion can be avoided, because <code>lookup</code> has a second method for obtaining a constructor, and it is called <code>unreflectConstructor</code> : </p><br><pre> <code class="java hljs">MethodHandle handle = lookup.unreflectConstructor(constructor);</code> </pre> <br><p>  This method will certainly correctly execute and return the handle that it should. </p><br><p>  The moment of truth.  Run the instantiation method: </p><br><pre> <code class="java hljs">Class&lt;?&gt; clazz = (Class&lt;?&gt;) handle. invoke(ClassLoader.getSystemClassLoader());</code> </pre> <br><p>  I think you have already guessed that nothing good will happen, but let's at least look at the error.  Now this is something new: </p><br><pre> <code class="hljs dos">Exception <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> thread "main" java.lang.IllegalAccessException: java.lang.Class <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> sun.misc.Unsafe.allocateInstance(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.DirectMethodHandle.allocateInstance(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.LambdaForm$DMH/<span class="hljs-number"><span class="hljs-number">925858445</span></span>.newInvokeSpecial_L_L(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> java.lang.invoke.LambdaForm$MH/<span class="hljs-number"><span class="hljs-number">523429237</span></span>.invoke_MT(...) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> Sample.main(...)</code> </pre> <br><p>  By default, stacktrace is shown shortened, so I added <br>  <code>-XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames</code> in the launch options.  So it becomes easier to understand what a strange place we have come to. </p><br><p>  I will not go deep into what classes <code>MethodHandles</code> generates, and it is not essential.  The important thing is quite different - we finally got to the bottom of using <code>sun.misc.Unsafe</code> , and even he could not create the <code>java.lang.Class</code> object. </p><br><p>  The <code>allocaeInstance</code> method <code>allocaeInstance</code> used in those places where you need to create an object, but not call its constructor.  This can be useful, for example, when deserializing objects.  In fact, this is the same <code>NEW</code> instruction, but not burdened with access checks.  <em>Almost</em> burdened as we just saw. </p><br><p>  Since even <code>Unsafe</code> could not, I can only come to a sad conclusion: it is impossible to allocate a new <code>java.lang.Class</code> object.  Interestingly it turns out - I thought that the designer is prohibited, and allocation is prohibited!  Let's try to get around this thing. </p><br><h2 id="uroven-6-nebezopasnyy">  Level 6. Unsafe </h2><br><p>  I propose to create an empty object and look at what it consists of.  To do this, take <code>Unsafe</code> and allocate a new <code>java.lang.Object</code> : </p><br><pre> <code class="java hljs">Field theUnsafeField = Unsafe.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"theUnsafe"</span></span>); theUnsafeField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Unsafe unsafe = (Unsafe) theUnsafeField.get(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); Object object = unsafe.allocateInstance(Object.class);</code> </pre> <br><p>  On the current JVM, the result will be a 12-byte memory area, which looks like this: </p><br><p><img src="https://habrastorage.org/webt/s6/sn/rm/s6snrm3cgyugvhlntmosw0uamly.png"></p><br><p>  What you see here is the "object header".  By and large, it consists of two parts - 8 bytes markword, which do not interest us, and 4 bytes of classword, which are important. </p><br><p>  How does the JVM recognize an object class?  It does this by reading the classword region, which stores a pointer to the internal structure of the JVM describing the class.  So if you write another value in this place, then the class of the object will change! </p><br><p>  Further code is very, very bad, never do this: </p><br><pre> <code class="java hljs">System.out.println(object.getClass()); unsafe.putInt(object, <span class="hljs-number"><span class="hljs-number">8L</span></span>, unsafe.getInt(Object.class, <span class="hljs-number"><span class="hljs-number">8L</span></span>)); System.out.println(object.getClass());</code> </pre> <br><p>  We read the classword of <code>Object.class</code> and <code>Object.class</code> it into the classword of <code>object</code> .  The result of the work is as follows: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> java.lang.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> java.lang.<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span></code> </pre> <br><p>  With a stretch we can assume that we have allocated <code>java.lang.Class</code> .  We are great!  Now we need to call the constructor.  You can laugh, but now we will use ASM to generate a class that can call the desired constructor.  Naturally, you need to inherit from <code>MagicAccessorImpl</code> . </p><br><p>  This is how the creation of the class begins (the constants are imported statically, in short) </p><br><pre> <code class="java hljs">ClassWriter cw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWriter(COMPUTE_FRAMES | COMPUTE_MAXS); cw.visit(V1_8, ACC_PUBLIC, <span class="hljs-string"><span class="hljs-string">"sun/reflect/MyConstructorInvocator"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">"sun/reflect/MagicAccessorImpl"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre> <br><p>  So it creates a constructor: </p><br><pre> <code class="java hljs">MethodVisitor init = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string"><span class="hljs-string">"&lt;init&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"()V"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); init.visitCode(); init.visitVarInsn(ALOAD, <span class="hljs-number"><span class="hljs-number">0</span></span>); init.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string"><span class="hljs-string">"sun/reflect/MagicAccessorImpl"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;init&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"()V"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); init.visitInsn(RETURN); init.visitMaxs(-<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>); init.visitEnd();</code> </pre> <br><p>  And this is how the <code>void construct(Class&lt;?&gt;, ClassLoader)</code> method is created, which the constructor calls the <code>Class&lt;?&gt;</code> Object inside: </p><br><pre> <code class="java hljs">MethodVisitor construct = cw.visitMethod(ACC_PUBLIC, <span class="hljs-string"><span class="hljs-string">"construct"</span></span>, <span class="hljs-string"><span class="hljs-string">"(Ljava/lang/Class;Ljava/lang/ClassLoader;)V"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); construct.visitCode(); construct.visitVarInsn(ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>); construct.visitVarInsn(ALOAD, <span class="hljs-number"><span class="hljs-number">2</span></span>); construct.visitMethodInsn(INVOKESPECIAL, <span class="hljs-string"><span class="hljs-string">"java/lang/Class"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;init&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"(Ljava/lang/ClassLoader;)V"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); construct.visitInsn(RETURN); construct.visitMaxs(-<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>); construct.visitEnd();</code> </pre> <br><p>  The class is ready.  It remains to load, instantiate and call the required method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = cw.toByteArray(); Class&lt;?&gt; myCustomInvocator = unsafe.defineClass(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytes.length, ClassLoader.getSystemClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); Object ci = myCustomInvocator.newInstance(); Method constructMethod = myCustomInvocator.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"construct"</span></span>, Class.class, ClassLoader.class); Class&lt;?&gt; clazz = (Class&lt;?&gt;) object; constructMethod.invoke(ci, clazz, ClassLoader.getSystemClassLoader());</code> </pre> <br><p>  And it works!  More precisely: lucky it works.  You can check by running the following code: </p><br><pre> <code class="java hljs">System.out.println(clazz.getClassLoader());</code> </pre> <br><p>  The output will be: </p><br><pre> <code class="hljs perl">sun.misc.Launcher$AppClassLoader@18b4aac2</code> </pre> <br><p>  I will tactfully keep silent about what memory area this <code>ClassLoader</code> and from where it later read.  And, as expected, calling almost any other method on this object leads to the immediate collapse of the JVM.  And the rest - the goal is completed! </p><br><h2 id="chto-tam-v-java-9">  What's in java 9? </h2><br><p>  Java 9 is pretty much the same.  You can do all the same actions, but with a few reservations: </p><br><ul><li>  You must add <code>--add-exports java.base/jdk.internal.reflect=sample</code> to the compiler parameters (where sample is the name of your module); </li><li>  in the startup parameters you need to add: <br> <code>--add-opens java.base/jdk.internal.reflect=sample</code> <br> <code>--add-opens java.base/java.lang=sample</code> <br> <code>--add-opens java.base/java.lang.reflect=sample</code> <br> <code>--add-opens java.base/java.lang.invoke=sample</code> <br> <code>--add-opens java.base/jdk.internal.reflect=java.base</code> </li> <li>  depending on the module, you must add <code>requires jdk.unsupported</code> ; </li><li>  the <code>java.lang.Class</code> constructor has changed its signature, it must be taken into account. </li></ul><br><p>  It is also worth considering that <code>sun.reflect</code> transferred to <code>jdk.internal.reflect</code> and that the <code>MyConstructorInvocator</code> class <code>MyConstructorInvocator</code> now be loaded with the same loader as <code>MagicAccessorImpl</code> . <br>  <code>ClassLoader.getSystemClassLoader()</code> will not work anymore, it will not have access. </p><br><p>  We also fixed a strange bug with <code>NoSuchFieldError</code> : now in its place is <code>NoSuchMethodError</code> , which should be there.  Trifle, but nice. </p><br><p>  In general, in Java 9 you need to try much harder to shoot yourself in the foot, even if that is the main goal.  I think it's for the best. </p><br><h2 id="vyvody">  Findings: </h2><br><ul><li>  If you want, you can create absolutely insane things in Java, it's funny; </li><li>  Reflection API is not so complicated; </li><li>  <code>MagicAccessorImpl</code> may not all; </li><li>  <code>sun.misc.Unsafe</code> may not all, but almost; </li><li>  Java 9 is even more trying to protect you. </li></ul><br><p>  Do not be too serious to take everything described.  The task of instantiating <code>java.lang.Class</code> completely meaningless.  Here the knowledge gained in the process of its decision is important. </p><br><p>  Thanks for attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341930/">https://habr.com/ru/post/341930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341920/index.html">IBM Research announced a 50-qubit quantum computer</a></li>
<li><a href="../341922/index.html">Immersion in oil: a new approach to immersion cooling</a></li>
<li><a href="../341924/index.html">‚ÄúAgile Development‚Äù: Agile Methodologies Summary</a></li>
<li><a href="../341926/index.html">Self Service: how and why to teach users autonomy</a></li>
<li><a href="../341928/index.html">Like Twins: 3 pairs of similar terms ITIL</a></li>
<li><a href="../341932/index.html">Briefly about software development methodologies: Waterfall, Lean and Feature Driven Development</a></li>
<li><a href="../341934/index.html">UX Writer: The Anatomy of a Unicorn</a></li>
<li><a href="../341936/index.html">Mobile marketing: discrepancies in installation statistics</a></li>
<li><a href="../341938/index.html">US Securities and Exchange Commission attack: stolen data can be used for insider trading</a></li>
<li><a href="../341944/index.html">We write really tested code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>