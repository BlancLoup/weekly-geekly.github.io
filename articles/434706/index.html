<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UDB. What is it? Part 3. Datapath FIFO</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to translate Cypress‚Äôs proprietary documentation into UDB blocks. Moreover, everything is very well matched. To continue the practical art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UDB. What is it? Part 3. Datapath FIFO</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/et/v5/rr/etv5rr-xdmsl0tyw4vtp_doh75k.jpeg"><br><br>  We continue to translate Cypress‚Äôs proprietary documentation into UDB blocks.  Moreover, everything is very well matched.  To continue the <a href="https://habr.com/post/433800/">practical article on UDB, we</a> will need to use FIFO, and in the theoretical part we have chosen just the description of them.  Therefore, we begin to study them in detail. <br><a name="habracut"></a><br>  Previous articles of the cycle: <br><br>  <a href="https://habr.com/post/432764/">UDB.</a>  <a href="https://habr.com/post/432764/">What is it?</a>  <a href="https://habr.com/post/432764/">Part 1. Introduction.</a>  <a href="https://habr.com/post/432764/">Pld.</a> <br>  <a href="https://habr.com/post/433018/">UDB.</a>  <a href="https://habr.com/post/433018/">What is it?</a>  <a href="https://habr.com/post/433018/">Part 2. Datapath</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  21.3.2.2 Datapath FIFO </h2><br><h3>  FIFO Modes and Configurations </h3><br>  Each FIFO buffer has several available modes of operation and configurations: <br><br>  Table 21-2.  FIFO modes and configurations. <br><table><tbody><tr><th>  Mode </th><th>  Description </th></tr><tr><td>  Input / output <br>  (Input / output buffer) </td><td>  In the input buffer mode of the CPU or DMA record <br>  the data in the FIFO, and the datapath reads it.  In mode <br>  output buffer the data gets into FIFO from <br>  Datapath, and reads them from there CPU or DMA. </td></tr><tr><td>  Single buffer <br>  (Single buffer) </td><td>  FIFO works as a single buffer with no status. <br>  The data recorded in the FIFO is immediately readable and can <br>  be overwritten at any time. </td></tr><tr><td>  Level / Edge <br>  (Level / Delta) </td><td>  The parameter responsible for loading the FIFO from Datapath, <br>  can be initiated by level or by differential. </td></tr><tr><td>  Normal / Fast <br>  (Normal / Fast) </td><td>  The parameter responsible for loading the FIFO from the source <br>  Datapath: it is clocked with the frequency selected for Datapath <br>  clock source (normal) or with the frequency of the bus (fast). <br>  This allows you to capture with the highest frequency <br>  in the system (bus frequency), regardless of the Datapath clock frequency. </td></tr><tr><td>  Software capture <br>  (Software capture) </td><td>  When this mode is on, and the FIFO is in <br>  output buffer, read CPU or DMA associated <br>  battery (A0 for F0, A1 for F1), initializes <br>  synchronous transfer of the battery value to the FIFO. <br>  The captured value is immediately readable from the FIFO. <br>  If chaining support is activated, <br>  the operation follows the chain to the MS block so that <br>  Datapath could perform an atomic read of multibyte. <br>  values. </td></tr><tr><td>  Asynch <br>  (Asynchronous) </td><td>  When the Datapach and system bus clock speeds are not <br>  synchronized, FIFO status signals can be <br>  flung the rest of the datapath either <br>  directly, clocked by the Datapath clock, <br>  or with double synchronization, in Asynch mode. </td></tr><tr><td>  Independent Clock Polarity <br>  (Independent clock polarity) </td><td>  Each FIFO has a control bit to invert. <br>  FIFO clock polarity with respect to Datapath clocking. </td></tr></tbody></table><br>  Figure 21-7 shows the possible configuration options for the FIFO pair, depending on the Input / Output modes selected for each of them.  If one FIFO is in input mode and the other in output mode, we get the RX / TX configuration.  A typical example where such a configuration is needed is an SPI bus controller.  In the <b>Dual Capture</b> configuration (both FIFOs are configured for output), independent capture of the A0 and A1 pairs or two independent captures of the A0 or A1 registers is provided.  Finally, in <b>Dual Buffer</b> mode (both at the input), it is possible to use either the register pair or two independent registers for loading or comparing. <br><br><img src="https://habrastorage.org/webt/jw/ii/lz/jwiilz_qkbulrpqu4n1xahxnsjq.png"><br><br>  Figure 21-7.  FIFO configurations. <br><br>  Figure 21-8 details the sources and receivers for the FIFO. <br><br><img src="https://habrastorage.org/webt/lj/rf/4l/ljrf4lqn5lyyq2xsi6sml5ywi5o.png"><br><br>  Figure 21-8.  Sources and receivers FIFO. <br><br>  When the FIFO operates in the input buffer mode, the source is the system bus, and the receivers are the Dx and Ax registers.  When operating in the output buffer mode, the sources are the Ax and ALU registers, and the receiver is the system bus.  The multiplexer selection is set statically in the UDB CFG15 configuration register, as shown in the table for F0_INSEL [1: 0] or F1_INSEL [1: 0]: <br><br>  Table 21-3.  A set of FIFO multiplexers in the UDB configuration register. <br><table><tbody><tr><th>  Fx_INSEL [1: 0] </th><th>  Description </th></tr><tr><td>  00 </td><td>  Input Buffer Mode: The system bus writes to the FIFO, and the receiver <br>  FIFO is Ax or Dx. </td></tr><tr><td>  01 </td><td>  Output buffer mode: the FIFO source is A0, and the receiver <br>  FIFO - system bus. </td></tr><tr><td>  ten </td><td>  Output Buffer Mode: the FIFO source is A1, and the receiver <br>  FIFO - system bus. </td></tr><tr><td>  eleven </td><td>  Output Buffer Mode: The FIFO source is the ALU output, and the receiver is <br>  FIFO - system bus. </td></tr></tbody></table><br><h3>  FIFO status </h3><br>  Each FIFO generates two status signals, ‚Äúbus‚Äù and ‚Äúblock‚Äù, which are transmitted to the UDB trace resources through the Datapath output multiplexer.  The ‚Äúbus‚Äù status can be used to trigger an interrupt or request a DMA read / write to the FIFO.  The ‚Äúblock‚Äù state is primarily intended to transfer the state of a FIFO to the internal entities of the UDB.  The assignment of the status bits depends on the configured direction (Fx_INSEL [1: 0]), and the FIFO level bits.  The FIFO level bits (Fx_LVL) are set in the Auxiliary Control register in the working register space.  The status options are shown in the following table: <br><br>  Table 21-4.  FIFO status options. <br><table><tbody><tr><th>  Fx_INSEL [1: 0] </th><th>  Fx_LVL </th><th>  condition </th><th>  Signal </th><th>  Description </th></tr><tr><td>  Input </td><td>  0 </td><td>  Not full </td><td>  Bus status </td><td>  Cocked when in FIFO is <br>  space for at least one byte. </td></tr><tr><td>  Input </td><td>  one </td><td>  Devastated <br>  least <br>  half </td><td>  Bus status </td><td>  Cocked when in FIFO is <br>  space for at least 2 bytes. </td></tr><tr><td>  Input </td><td>  N / A </td><td>  Is empty </td><td>  ‚ÄúBlock‚Äù status </td><td>  Cocked when there is no FIFO <br>  not a single byte. <br>  When the FIFO is not empty, Datapath <br>  can read bytes. <br>  When the FIFO is empty, Datapath <br>  may be able to <br>  waiting or generate <br>  a state of desolation. </td></tr><tr><td></td></tr><tr><td>  Conclusion </td><td>  0 </td><td>  Not empty </td><td>  Bus status </td><td>  Cocked when in FIFO <br>  at least 1 byte available <br>  for reading. </td></tr><tr><td>  Conclusion </td><td>  one </td><td>  Is filled <br>  least <br>  half </td><td>  Bus status </td><td>  Cocked when available in FIFO <br>  at least 2 bytes to read. </td></tr><tr><td>  Conclusion </td><td>  N / A </td><td>  Is full </td><td>  ‚ÄúBlock‚Äù status </td><td>  Cocked when the FIFO is full. <br>  When the FIFO is not full, Datapath <br>  can write bytes to FIFO. <br>  When the FIFO is full, Datapath <br>  may be located in <br>  waiting state or <br>  generate a condition <br>  overflow. </td></tr></tbody></table><br><h3>  FIFO Job Illustration </h3><br>  Figure 21-9 shows the typical sequence of reading and writing, as well as the generation of statuses associated with these operations.  In the figure, reading and writing occur at different times, but they can be performed at the same time. <br><br><img src="https://habrastorage.org/webt/pp/kr/-p/ppkr-pcweqaiz61mam-o3d4oeti.png"><br><br>  Figure 21-9 FIFO receiver operation. <br><br><h3>  Fast FIFO mode (FIFO FAST) </h3><br>  When the FIFO operates in the output buffer mode, the FIFO load operation typically uses the clock frequency of the selected Datapath to clock the recording signal.  As shown in Figure 21-10, when you select Fast FIFO (FIFO FAST) for this particular operation, you can select a bus frequency.  When used in conjunction with the <b>Level / Edge = Edge</b> mode, this operation reduces the transfer delay from the battery to the FIFO from the Datapath clock period to the bus clock frequency period, since the bus frequency can be much higher.  This allows the CPU or DMA to read the resulting FIFO with minimal latency. <br><br>  As shown in Figure 21-10, the fast boot operation is performed regardless of the current Datapath clocking, but using a bus clock frequency can increase power consumption. <br><br><img src="https://habrastorage.org/webt/au/4c/0i/au4c0iq5pfcnnebsvxxq1hmf-zu.png"><br><br>  Figure 21-10.  Receivers fast configuration FIFO. <br><br><h3>  Record mode in FIFO Edge / Level (by differential / level) </h3><br>  There are two ways to write to the FIFO from Datapath.  In the first mode, data is synchronously transferred from the batteries to the FIFO.  The control signal of this record (FX_LD) is usually generated by a state machine or a condition synchronized with the clocking of the Datapath.  The FIFO will be recorded in any cycle in which the input load control signal is '1'.  In the second mode, the FIFO is used to capture battery values ‚Äã‚Äãin response to a positive drop in the FX_LD signal.  In this mode, the signal format of the signal is arbitrary (however, its period must be equal to at least one Datapath clocking cycle).  An example of this mode is to capture the value of a battery by using the input of an external foot as a trigger.  The limitation of this mode is that the input parameter must return to the value '0' at least one cycle before another positive differential is detected. <br><br>  Figure 21-11 shows the implementation of the delta detection mode at input FX_LD.  The mode of both FIFOs in UDB is controlled by the same bit toggling this option.  Note that the differential detection is clocked at a frequency equal to the frequency of the selected FIFO. <br><br><img src="https://habrastorage.org/webt/xv/hq/u8/xvhqu8l5xwjgn-4aaww9ru8tkli.png"><br><br>  Figure 21-11.  Differential detection for internal FIFO recording receivers. <br><br><h3>  FIFO software capture mode (Software Capture) </h3><br>  A common and important requirement is to ensure that the CPU and DMA reliably read the contents of the battery during normal operation.  This is done using software capture and enabled with the FIFO Cap configuration bit.  This bit applies to both FIFOs in UDB, but works only when the FIFO is in output buffer mode.  When using software capture, F0 must read from A0, and F1 from A1. <br><br>  As shown in Figure 21-12, reading the battery initiates writing to the FIFO from the battery.  The signal is chained together so that reading a specific byte simultaneously captures the battery values ‚Äã‚Äãof all UDBs in the chain.  This allows an 8-bit processor to successfully read 16 bits or more simultaneously.  The data returned when reading the battery should be ignored, and the captured value can be immediately available for reading from the FIFO. <br><br>  The traced signal FX_LD, which generates the FIFO load, is sent to the OR term along with the program capture signal.  When hardware and software capture are used at the same time, the result can be unpredictable.  As a rule, these functions should be mutually exclusive, but hardware and software capture can be used simultaneously, under the following conditions: <br><br><ul><li>  FIFO capture clocking mode is set to FIFO FAST. </li><li>  FIFO recording mode is set to FIFO EDGE. </li></ul><br>  Under the conditions described above, hardware and software capture work in essentially the same way, and during any bus clock cycle any of these signals can trigger a capture. <br><br>  It is also recommended to clear the target FIFO in the program code (ACTL register) before the start of the program capture.  Due to this, the read and write pointers to the FIFO will be set to a known state. <br><br><img src="https://habrastorage.org/webt/0n/c7/zg/0nc7zgc7je5sn3emupt2ij7kdc0.png"><br><br>  Figure 21-12.  Software capture configuration. <br><br>  <i><b>Translator's Note:</b></i> <i><br><br></i>  <i>Frankly, I do not fully understand the full depth of the meaning of this section.</i>  <i>Perhaps someone will explain the essence in the comments.</i>  <i>But it creates a strong impression that this is primarily intended to enable the 8-bit processor core to have time to read the contents of the battery of higher capacity.</i>  <i>Such kernels are used in PSoC-3.</i>  <i>As a result, the contents of the battery atomically jumps to the FIFO, after which the contents of the latter can easily be read in 2 or more cycles (in order to pump 16 or 32 bits, plus in the MCS-51, operations will be conducted in separate commands, which will also take cycles). afraid that it will be changed.</i>  <i>And for the ARM cores, it seems that this is nothing more than an unnecessary vestige.</i> <br><br><h3>  FIFO control bits </h3><br>  The Auxiliary Control register, which can be used to control the FIFO during normal operation, contains 4 bits. <br><br>  The FIFO0 CLR and FIFO1 CLR bits are used to reset or clear the FIFO.  When one of these bits is set to '1', the associated FIFO is reset.  The bit must be restored to its original value ('0') in order for the FIFO to continue.  If the value of the bit remains equal to one, the corresponding FIFO will be disabled and will work as a single-byte buffer with no status.  Data can be written to the FIFO, data is immediately readable and can be overwritten at any time.  The direction of data using the FX INSEL [1: 0] configuration bits can still be set. <br><br>  The FIFO0 LVL and FIFO1 LVL bits define the level at which the FIFO will trigger the <b>‚Äúbus‚Äù</b> status bit (when the bus reads or writes to the FIFO).  That is, the status of the <b>‚Äúbus‚Äù</b> status depends on the given direction, as shown in the table below. <br><br>  Table 21-5.  FIFO Level Control Bits <br><table><tbody><tr><th>  FIFO LVL </th><th>  Input Buffer Mode <br>  (tire writes to FIFO) </th><th>  Output Buffer Mode <br>  (tire reads from FIFO) </th></tr><tr><td>  0 </td><td>  Not full <br>  At least 1 byte can be written. </td><td>  Not empty <br>  At least 1 byte can be read. </td></tr><tr><td>  one </td><td>  Half empty <br>  At least 2 bytes can be written. </td><td>  At least half full <br>  At least 2 bytes can be read. </td></tr></tbody></table><br><h3>  Asynchronous FIFO </h3><br>  Figure 21-13 shows the principle of asynchronous operation of the FIFO.  As an example, imagine that F0 operates in the input buffer mode, and F1 in the output buffer mode, which is a typical configuration of the TX and RX registers. <br><br><img src="https://habrastorage.org/webt/ct/ei/lo/cteilo6ne7nn0ah0hprjtkbawvo.png"><br><br>  Figure 21-13.  Asynchronous FIFO operation. <br><br>  On the TX side, the Datapath state machine uses the <b>Empty</b> flag to determine if there are any bytes available to receive.  The <b>Empty</b> value is set synchronously with the Datapath state machine, and cleared asynchronously due to a write from the bus.  After cleaning, the status is synchronized again with the Datapath state machine. <br><br>  On the RX side, the RX state machine uses <b>Full</b> to determine if there is free space to write to the FIFO.  The <b>Full</b> value is set synchronously with the Datapath state machine, and cleared asynchronously due to the bus read.  After cleaning, the status is synchronized again with the Datapath state machine. <br><br>  The ASYNCH FIFO one bit is used to enable this synchronization method, after activation this method is applied to both FIFOs. <br><br>  It applies only to the <b>Block</b> status, since it is assumed that the <b>Bus</b> status is naturally synchronized by the interrupt process. <br><br>  Table 21-6.  Parameters of synchronization of the <b>Block</b> FIFO status. <br><table><tbody><tr><th>  ASYNC </th><th>  ADD SYNC </th><th>  Operation </th><th>  Usage model </th></tr><tr><td>  0 </td><td>  0 </td><td>  Synchronized with bus clocking </td><td>  CPU write / read status changes <br>  occur at the frequency of the bus.  Can <br>  use for minimal <br>  delays if you manage to achieve <br>  Datapatch clocking frequencies <br>  equal to the bus frequency. </td></tr><tr><td>  0 </td><td>  one </td><td>  Resync from frequency <br>  tires on the Datapath frequency. </td><td>  This mode should be <br>  default operation mode.  When <br>  The CPU performs read / write operations, <br>  status change will be resynchronized <br>  with the frequency used in datapath. <br>  Allows you to use full <br>  datapath frequency period to set <br>  signal for UDB logic. </td></tr><tr><td>  one </td><td>  0 </td><td>  Reserved </td><td>  - </td></tr><tr><td>  one </td><td>  one </td><td>  Dual frequency synchronization <br>  tires on the Datapath frequency. </td><td>  When clock pulses for datapath <br>  not only not synchronized with <br>  systemic in frequency but also <br>  produced by an individual <br>  independent generator <br>  this parameter can be <br>  used for double <br>  operation synchronization <br>  read and write CPU <br>  with Datapath clocking. </td></tr></tbody></table><br><h3>  FIFO overflow during operation </h3><br>  To safely implement internal (Datapath) and external (CPU or DMA) read and write operations, use the FIFO status signals.  There is no built-in protection from the conditions of devastation and overflow.  If the FIFO is full and subsequent write operations are performed (overflow), the new data overwrites the beginning of the FIFO (the data that is currently being output is the next in the read queue).  If the FIFO is empty, and subsequent read operations are performed (emptying or wasting), the read value is undefined.  FIFO pointers maintain accuracy regardless of non-completion and overflow. <br><br><h3>  FIFO clocking invert </h3><br>  Each FIFO has the Fx CK INV control bit, which is responsible for the clocking polarity of the FIFO. About the clocking polarity of the Datapath.  By default, the FIFO works with the same polarity as the Datapath clocking.  When this bit is 1, the FIFO operates in reverse polarity relative to the Datapath.  This provides support for protocols that exchange data on both fronts, for example, SPI. <br><br><h3>  Dynamic FIFO Management </h3><br>  Typically, FIFOs are configured statically either to the input buffer mode or to the output buffer mode.  Alternatively, each FIFO can be configured to work in a mode in which the direction is controlled dynamically (by external signals).  One configuration bit per FIFO (Fx DYN) is responsible for activating this mode.  Figure 21-14 shows the configurations available in dynamic FIFO mode. <br><br><img src="https://habrastorage.org/webt/ny/ei/vo/nyeivo9hrnmr6vg8tkcbnnkaz8i.png"><br><br>  Figure 21-14.  Dynamic mode FIFO. <br><br>  In Internal Access mode, Datapath can read and write to the FIFO.  In this configuration, to select the source of write operations in the FIFO, the Fx INSEL bits must be set to 1. Fx INSEL = 0 (CPU bus source) is incorrect in this mode, it can only take values ‚Äã‚Äãof 1, 2, or 3 (A0, A1, or ALU ).  It is worth noting that reading has access only to the corresponding battery, the direction of the data registers in this mode is not available. <br><br>  In the External Access mode, the CPU or DMA can both read and write to the FIFO. <br><br>  The configuration dynamically switches between external and internal access using signal forwarding from Datapath.  For this, the input signals Datapath d0_load and d1_load are used.  It is worth noting that in the dynamic control mode, d0_load and d1_load are not available for normal use when loading the D0 / D1 registers from F0 / F1.  The dx_load signals may be called by any trace signal, including constants. <br><br>  Consider an example in which, starting from external access (dx_load == 1), a CPU or DMA can write one or more data bytes to a FIFO.  Then, when switching to internal access (dx_load == 0), the Datapath can perform operations on the data.  After that, when switching to external access, the CPU or DMA can read the result of the calculations. <br>  Since Fx INSEL must always be 01, 10, or 11 (A0, A1, or ALU), which corresponds to the ‚Äúoutput buffer mode‚Äù during normal operation, the FIFO status signals have the following definitions (depending on the Fx LVL parameter): <br><br>  Table 21-7.  FIFO status. <br><table><tbody><tr><th>  Status signal </th><th>  Value </th><th>  Fx LVL = 0 </th><th>  Fx LVL = 1 </th></tr><tr><td>  fx_blk_stat </td><td>  Record Status </td><td>  FIFO is full </td><td>  FIFO is full </td></tr><tr><td>  fx_bus_stat </td><td>  Reading status </td><td>  FIFO is not full </td><td>  At least half full </td></tr></tbody></table><br>  Since both the Datapath and the CPU can write and read from the FIFO, these signals are no longer considered as ‚Äúblock‚Äù and ‚Äúbus‚Äù statuses.  The blk_stat signal is used for write status and the bus_stat signal is for read status. <br><br><h2>  21.3.2.3 FIFO Status </h2><br>  There are four FIFO status signals, two for each FIFO: fifo0_bus_stat, fifo0_blk_stat, fifo1_bus_stat and fifo1_blk_stat.  The meaning of these signals depends on the direction of the specific FIFO, which is defined by the static configuration.  FIFO status is described in detail in Section <b>21.3.2.2 of the Datapath FIFO</b> . <br><br>  In the next part we will proceed to the analysis of the Arithmetic Logical Device (ALU). </div><p>Source: <a href="https://habr.com/ru/post/434706/">https://habr.com/ru/post/434706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434696/index.html">Employees of IT giants have figured out how to influence the policies of their companies.</a></li>
<li><a href="../434698/index.html">Pessimism about multithreading</a></li>
<li><a href="../434700/index.html">Benefits of following styleguides when developing Angular applications</a></li>
<li><a href="../434702/index.html">Why do I get nervous about the failures of modern SSD</a></li>
<li><a href="../434704/index.html">The reasons for the decline in the cost of mobile traffic in Russia and the forecast for 2019</a></li>
<li><a href="../434708/index.html">HL 2018. Abstract of the report ‚ÄúMake passwords great again! How to defeat brute force and leave hackers with nothing</a></li>
<li><a href="../434710/index.html">Blog RUVDS on Habr√©: three years</a></li>
<li><a href="../434712/index.html">Third Turing Test in Russian</a></li>
<li><a href="../434716/index.html">Moving to the data center: Preparation</a></li>
<li><a href="../434718/index.html">Two years later, I still miss the headphone jack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>