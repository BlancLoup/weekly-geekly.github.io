<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ZooKeeper or write distributed locking service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="disclaimer It so happened that last month I understood ZooKeeper, and I had a desire to systematize what I learned, the actual post about it, and not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ZooKeeper or write distributed locking service</h1><div class="post__text post__text-html js-mediator-article">  <b>disclaimer</b> It so happened that last month I understood ZooKeeper, and I had a desire to systematize what I learned, the actual post about it, and not about the service of locks, as one might think from the name.  Go! <br><br>  When moving from multithreaded programming to programming of distributed systems, many standard techniques stop working.  One of these techniques are locks (synchronized), since their scope is limited to one process, therefore, they not only do not work on different nodes of the distributed system, but also not between different instances of the application on the same machine;  it turns out that you need a separate mechanism for locking. <br><br>  It is reasonable to demand from the distributed service of locks: <br><ol><li>  operability in the conditions of network blinking (the first rule of distributed systems - <s>not to speak about distributed systems to anyone the</s> network is unreliable) </li><li>  no single point of failure </li></ol><br>  ZooKeeper will help us to create such a service. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/1cb/934/2ae/1cb9342aebf674e8709b47d7f5e95661.png" alt="image" align="left">  Wikipedia says that <b>ZooKeeper is a distributed configuration and synchronization service</b> , I don‚Äôt know about you, but this definition reveals little to me.  Looking back at my experience, I can give an alternative definition of <b>ZooKeeper, this is a distributed key / value store with the following properties</b> : <br><ul><li>  key space forms a tree (a hierarchy similar to the file system) </li><li>  values ‚Äã‚Äãcan be contained in any node of the hierarchy, and not only in the leaves (as if the files would also be directories), the hierarchy node is called znode </li><li>  there is a bidirectional connection between the client and the server, therefore, the client can be signed as a change in a specific value or part of the hierarchy </li><li>  it is possible to create a temporary key / value pair that exists while the client who created it is connected to the cluster </li><li>  all data should be stored in memory </li><li>  resistance to death of non-critical number of cluster nodes </li></ul><br><a name="habracut"></a>  Acquaintance with an unfamiliar system must begin first with the API that it offers, so <br><br><h4>  Supported operations </h4><br><table><tbody><tr><td>  exists </td><td>  checks for the existence of znode and returns its metadata </td></tr><tr><td>  create </td><td>  creates znode </td></tr><tr><td>  delete </td><td>  removes znode </td></tr><tr><td>  getData </td><td>  gets data associated with znode </td></tr><tr><td>  setData </td><td>  associates new data with znode </td></tr><tr><td>  getChildren </td><td>  gets children of the specified znode </td></tr><tr><td>  sync </td><td>  waiting for the synchronization of the cluster node to which we are connected, and the master. </td></tr></tbody></table><br>  These operations can be divided into the following groups. <br><table><tbody><tr><td>  <b>callback</b> </td><td>  <b>CAS</b> </td><td></td></tr><tr><td>  exists </td><td>  delete </td><td></td></tr><tr><td>  getData </td><td>  setData </td><td></td></tr><tr><td>  getChildren </td><td></td><td>  create </td></tr><tr><td></td><td></td><td>  sync </td></tr></tbody></table><br>  <b>Callback</b> - read-only operations, to which you can specify callbacks, callback will work when the requested entity changes.  <u>Callback will work no more than once; in the case when you need to constantly monitor the value, you must constantly re-sign in the event handler</u> . <br><br>  <b>CAS</b> - write requests.  <u>The problem of competitive access in ZooKeeper has been resolved via compare-and-swap</u> : with each znode its version is stored, if it is changed, it must be indicated, if the znode has already been changed, then the version does not match and the client will receive a corresponding exception.  Operations from this group require specifying the version of the object being changed. <br><br>  <b>create</b> - creates a new znode (key / value pair) and returns a key.  It seems odd that a key is returned if it is specified as an argument, but the fact is that you can specify a prefix as a key and say that znode is consistent, then you will add a aligned number to the prefix and the result will be used as a key.  <u>It is guaranteed that by creating successive znode with the same prefix, the keys will form an increasing (in a lexico-graphic sense) sequence</u> . <br><br>  In addition to consecutive znode, you can create <u>ephemeral znode, which will be deleted as soon as the client created them to disconnect</u> (recall that the connection between the cluster and the client in ZooKeeper is kept open for a long time).  Ephemeral znode can not have children. <br><br>  Znode can be both ephemeral and consistent. <br><br>  <b>sync</b> - synchronizes the cluster node to which the client is connected, with the master.  On good should not be caused, as synchronization happens quickly and automatically.  About when to call it, will be written below. <br><br>  Based on sequential ephemeral znode and subscriptions for their removal, you can <s>easily</s> create a system of distributed locks. <br><br><h4>  Distributed locking system </h4><br>  In fact, everything is invented before us - go to the ZooKeeper website <a href="http://zookeeper.apache.org/doc/trunk/recipes.html">in the recipe section</a> and look for the blocking algorithm there: <br><br><ol><li>  Create ephemeral serial znode using "_locknode_ / guid-lock-" as a prefix, where _locknode_ is the name of the resource that is being blocked, and guid is the newly generated guid </li><li>  Get the list of _locknode_ children without a subscription to the event </li><li>  If the znode created in the first step in the key has a minimum numeric suffix: exit the algorithm - we have captured the resource </li><li>  Otherwise, sort the list of children by the suffix and call the exists with a callback on the znode, which is in the resulting list before what we created in step 1 </li><li>  If you get false, go to step 2, otherwise wait for the event and go to step 2 </li></ol><br><blockquote>  To verify the assimilation of the material, try to understand yourself, in descending or ascending order, you need to sort the list in step 4. </blockquote><br>  Since, <u>in the event that any operation fails while ZooKeeper is running, we cannot find out if the operation has passed or not</u> , we need to make this check at the application level.  Guid is needed just for this: knowing it and requesting children, we can easily determine whether we have created a new node or not, and the operation should be repeated. <br><br>  By the way, I did not say, but I think you already guessed that to calculate the suffix for a consecutive znode, not a unique sequence for the prefix is ‚Äã‚Äãused, but a unique sequence for the parent in which the znode will be created. <br><br><h3>  WTF </h3><br>  In theory, it would be possible to finish it, but as practice has shown, the most interesting begins - <b>wtf</b> 'ki.  By <b>wtf,</b> I mean the divergence of my intuitive ideas about the system with its real behavior, attention, wtf does not carry a value judgment, and I also understand perfectly why the creators of ZooKeeper went to such architectural solutions. <br><br><h4>  WTF # 1 - turn the code inside out </h4><br>  Any API method can throw a checked exception and oblige you to handle it.  This is not usual, but correct, since the first rule of distributed systems is that the network is not reliable.  One of the exceptions that can fly is the loss of the connection (network blinking).  You should not confuse the loss of a connection with a cluster node (CONNECTIONLOSS), during which the client will restore it with the saved session and callbacks (connect to another or wait), and forcefully close the connection from the cluster and the loss of all callbacks (SESSIONEXPIRED), in this case the task of restoring the context falls on the programmer‚Äôs shoulders.  But we have moved away from the topic ... <br><br>  How to handle winks?  In fact, when <u>opening a connection with a cluster, we indicate a callback, which is called repeatedly, not just once, like the others, and which delivers events about the loss of the connection and its restoration</u> .  It turns out when the connection is lost, you need to pause the calculations and continue them when the desired event arrives. <br><br>  Doesn't this remind you of anything?  On the one hand - events, on the other - the need to "play" with the flow of the program, in my opinion somewhere near continuation and monads. <br><br>  In general, I designed the steps of the program in the form: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">continueWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task continuation)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     void run(Executor context, Object arg); //   void error(Executor context, Exception error); //  ,    -   }</span></span></code> </pre> <br>  where is executor <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Executor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Task task, Object arg, Timer timeout)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// timeout     / TimeoutException  error ,   real-time }</span></span></code> </pre><br>  By adding the necessary combinators you can build the following programs, somewhere using the idempotency of the steps, somewhere clearly clearing up the garbage: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/0c7/c67/3d00c7c676e72caa9c49e04e9ab799b5.png" alt="image"><br><br><ul><li>  the square is a useful operation, and the arrow is the execution flow and / or error flow </li><li>  diamond - combinator, which ignores the specified errors and repeats the last useful operation </li><li>  honeycomb - a combinator that performs operation A in the case of a normal flow of execution, and operation B in the case of the specified error </li><li>  a rounded parallelepiped is a combinator that allows a successful execution flow to itself, and an erroneous one immediately throws it away </li></ul><br>  When implementing the Executor, I added wrapper functions to the ZooKeeper class so that it is the handler for all events and decides for itself which Watcher (event handler to call).  Inside the implementation, I put three BlockingQueues and three threads that read them, and it eventually turned out that when an event arrives, it is added to the eventQueue, thus the stream almost instantly returns to the inside of ZooKeeper, by the way, <u>inside ZooKeeper, all Watchers work in one thread , therefore, it is possible that the processing of one event blocks all the others and ZooKeeper itself</u> .  Secondly, taskQueues are added to Task'i along with arguments.  The processing of these queues (eventQueue and taskQueue) is allocated downstream, eventThread and taskThread, respectively, these threads read their own queues and wrap each incoming object into Job'u and put it in the jobQueue with which its thread is connected, the actual trigger code of the task or handler messages.  In the case of a connection failure, the taskThread thread is suspended, and in the case of a network raise, it is resumed.  Execution of the task code and handlers in one thread allows you not to worry about locks and facilitates business logic. <br><br><h4>  WTF # 2 - main server </h4><br>  We can say that in ZooKeeper the server (cluster) is the main one, and the customers have almost no rights.  Sometimes it comes to the absolute, for example ... In the ZooKeeper configuration there is such a parameter as session timeout, it determines how much the connection between the cluster and the client can disappear, if the maximum is exceeded, the session of this client will be closed and all ephemeral znode of this client will be deleted;  if the connection is still restored, the client will receive a SESSIONEXPIRED event.  So, the client at connection loss (CONNECTIONLOSS) and exceeding session timeout stupidly waits and does nothing, although, according to the idea, he could guess that the session was dead and SESSIONEXPIRED to throw its handlers. <br><br>  Because of this behavior, the developer at some time to tear his hair out, say, you raised the ZooKeeper server and try to connect to it, but you made a mistake in the config and knocked at the wrong address, or not on that port, then, according to the behavior described above , you will just wait for the client to go to the CONNECTED state and not get any error message, as would be the case with MySQL or something similar. <br><br>  Interestingly, such a script allows you to safely update ZooKeeper on production: <br><ul><li>  turn off ZooKeeper - all clients go to the CONNECTIONLOSS state </li><li>  update ZooKeeper </li><li>  we turn on ZooKeeper, the connection with the server has been restored, but the server does not send SESSIONEXPIRED, since the time for the shutdown was relative to the server </li></ul><br>  By the way, it is because of this behavior that I pass to the Executor Timer, which cancels the execution of the Task if we are unable to connect for too long. <br><br><h4>  WTF # 3 - int overflow </h4><br>  Suppose you implemented locks according to the algorithm described above and started this case in highload production, where, let's say you take 10MM locks per day.  Somewhere in a year you will find that you are in hell - locks will stop working.  The fact is that after a year, the znode _locknode_ counter <u>cversion overflows and</u> violates the <u>principle of a monotonously increasing sequence of names of consecutive znode</u> , and our implementation of locks is based on this principle. <br><br>  What to do?  It is necessary to periodically delete / re-create _locknode_ - while the counter associated with it is reset and the principle of monotonous sequence is broken again, but the fact is that <u>znode can be deleted only when it has no children</u> , and now guess why the cversion reset from _locknode_, when there are no children in it does not affect the blocking algorithm. <br><br><h4>  WTF # 4 - quorum write, but not read </h4><br>  <u>When ZooKeeper returned OK to the write request, this means that the data was enrolled to <i>quorum</i></u> (most machines in the cluster, in the case of 3 machines, the quorum consists of 2x), but when reading the user receives data from the machine to which he connected.  That is, it is possible that the user receives old data. <br><br>  In the case when clients do not communicate except through ZooKeeper, this is not a problem, since <u>all operations in ZooKeeper are strictly ordered</u> and then there is no way to know that the event occurred except how to wait for it.  Guess yourself why it means that everything is good.  In fact, the client may know that the data was updated, even if no one told him - in the case when he made the changes himself, but ZooKeeper supports <i>read your write consistency</i> , so this is not a problem either. <br><br>  But still, if one ZooKeeper learned about a change in a part of the data through the communication channel, a forced sync can help him - for this the <b>sync</b> command is needed. <br><br><h4>  Performance </h4><br>  Most distributed key / value stores use distribution to store large amounts of data.  As I already wrote, the data that ZooKeeper keeps in itself should not exceed the size of the RAM, it is asked why it is distributed - it is used to ensure reliability.  Remembering the need to gain a record quorum, it is not surprising that there is a 15% drop in performance when using a cluster of three machines, compared with one machine. <br><br>  Another feature of ZooKeeper is that it provides persistence - for it, too, is necessary because during the processing of a request, the recording time on the disc is included. <br><br>  And the final impact on performance is due to the strict ordering of requests - in order to ensure that all write requests go through the same cluster machine. <br><br>  I tested on a local laptop, yes, yes it strongly resembles: <br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/298/d82/bfa/298d82bfad10e68896ad3346c34b1485.jpg" alt="image"><br>  <a href="https://twitter.com/DEVOPS_BORAT">DevOps borat</a> </td><td>  90% of devops which can be used in the same sentence. </td></tr></tbody></table>  but it is obvious that ZooKeeper shows itself best in a configuration from one node, with a fast disk and a small amount of data, so my X220 with SSD and i7 was perfect for this.  I tested mostly write requests. <br><br>  The performance ceiling was somewhere around 10K operations per second with intensive recording, recording takes from 1ms, therefore, from the point of view of a single client, the server can run no faster than 1K operations per second. <br><br>  What does it mean?  In conditions when we do not run into the disk (ssd utilization at the level of 10%, for fidelity, I also tried to place the data in memory via ramfs - I received a slight increase in performance), we run into cpu.  So, it turned out that ZooKeeper is only 2 times slower than the numbers that its creators indicated on the site, which is not bad, considering that they know how to squeeze everything out of it. <br><br><h4>  Summary </h4><br>  Despite everything I've written here, ZooKeeper is not as bad as it may seem.  I like its conciseness (only 7 teams), I like the way it pushes and directs its programmer API to the correct approach in the development of distributed systems, namely, <i>at any moment everything can fall, so every operation should leave the system in a consistent state</i> .  But these are my impressions, they are not as important as the fact that ZooKeeeper well solves the tasks for which it was created, including: storing cluster configs, monitoring the status of a cluster (number of connected nodes, status of nodes), synchronizing nodes (blocking , barriers) and communication of nodes of a distributed system (a-la jabber). <br><br>  I will list again what you should keep in mind when developing with ZooKeeper: <br><ul><li>  master server </li><li>  the client is notified of the record only when data has hit the disk </li><li>  quorum write + read your writes consistency </li><li>  strict order </li><li>  at any moment everything can fall, therefore after each change the system should be in a consistent state </li><li>  in case of loss of communication, we are in a state in which the state of the last write operation is unknown </li><li>  explicit error handling (for me the best strategy is to use CPS) </li></ul><br><br><h4>  About distributed locks </h4><br>  Returning to the blocking algorithm described above, I can say that it does not work, it works more precisely exactly as long as the actions inside the critical section occur on the same and only the same ZooKeeper cluster that is used for blocking.  Why is that?  - Try to guess yourself.  And in the next article I will write how to make distributed locks more honest and expand the class of operations inside the critical section to any key / value storage with CAS support. <br><br><h4>  Several links to information on ZooKeeper </h4><br>  <a href="http://zookeeper.apache.org/">zookeeper.apache.org</a> <br>  <a href="http://outerthought.org/blog/435-ot.html">outerthought.org/blog/435-ot.html</a> <br>  <a href="http://highscalability.com/zookeeper-reliable-scalable-distributed-coordination-system">highscalability.com/zookeeper-reliable-scalable-distributed-coordination-system</a> <br>  <a href="http://research.yahoo.com/node/3280">research.yahoo.com/node/3280</a> </div><p>Source: <a href="https://habr.com/ru/post/144708/">https://habr.com/ru/post/144708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144701/index.html">Using Windows Azure in a bootstrapping SaaS startup</a></li>
<li><a href="../144703/index.html">Smashing Magazine refused button Like</a></li>
<li><a href="../144705/index.html">Eric Schmidt: disconnect from computers for an hour every day</a></li>
<li><a href="../144706/index.html">Electronic door peephole</a></li>
<li><a href="../144707/index.html">Qt / Objective-C ++ 11 or building a Qt project using GCC-4.7 and Clang</a></li>
<li><a href="../144709/index.html">Fidel.ru - everything</a></li>
<li><a href="../144710/index.html">‚ÄúRunet today‚Äù, May 28, 2012. Experts of the issue: Maria Chernitskaya, Alexey Andreev</a></li>
<li><a href="../144712/index.html">Instant file search in Windows. Sleight of hand and no fraud</a></li>
<li><a href="../144713/index.html">Registration for PHDays 2012 contests has begun</a></li>
<li><a href="../144714/index.html">QScintilla: write your lexer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>