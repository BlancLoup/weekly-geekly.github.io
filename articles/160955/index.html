<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in working with exceptions in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a lot of talk on the Internet about new features of C ++ 11: auto, lambda, variadic templates. But somehow they avoided the new possibilities...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in working with exceptions in C ++ 11</h1><div class="post__text post__text-html js-mediator-article">  There is a lot of talk on the Internet about new features of C ++ 11: auto, lambda, variadic templates.  But somehow they avoided the new possibilities of working with the exceptions provided by the language and the standard library. <br><br>  From the previous version of the standard, there was an exception generation mechanism (throw), a check that we are in the process of handling an exception (std :: uncaught_exception), a stop mechanism if the exception was not processed.  There is also a hierarchy of standard exceptions based on the class std :: exception. <br><br>  The new standard adds a few more entities to these things, which, in my opinion, can significantly simplify work with exceptions in C ++. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h5>  exception_ptr </h5><br>  So, the very first thing we can encounter is std :: exception_ptr.  This type allows you to store an exception of absolutely any type.  The standard does not specify how this type is obtained.  This may be a typedef, it may be a class implementation.  Its behavior is similar to that of std :: shared_ptr, that is, it can be copied, passed as a parameter, and the exception itself is not copied.  The main purpose of exception_ptr is to pass exceptions as function parameters, it is possible to pass exceptions between threads.  Thus, objects of this type can make error handling more flexible: <br><pre><code class="hljs php">struct some_exception { explicit some_exception(int x): v(x) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" int ctor"</span></span> &lt;&lt; std::endl; } some_exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_exception &amp; e): v(ev) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" copy ctor"</span></span> &lt;&lt; std::endl; } int v; }; std::exception_ptr throwExceptionAndCaptureExceptionPtr() { std::exception_ptr currentException; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int throwValue = <span class="hljs-number"><span class="hljs-number">10</span></span>; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"throwing "</span></span> &lt;&lt; throwValue &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> some_exception(throwValue); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { currentException = std::current_exception(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentException; } void rethrowException(std::exception_ptr ePtr) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ePtr) { std::rethrow_exception(ePtr); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_exception &amp; e) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"catched int value: "</span></span> &lt;&lt; ev &lt;&lt; std::endl; } std::exception_ptr anotherExceptionPtr = ePtr; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (anotherExceptionPtr) { std::rethrow_exception(anotherExceptionPtr); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> some_exception &amp; e) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"catched int value: "</span></span> &lt;&lt; ev &lt;&lt; std::endl; } } void checkMakeExceptionPtr() { std::exception_ptr currentException = std::make_exception_ptr(some_exception(<span class="hljs-number"><span class="hljs-number">20</span></span>)); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"exception_ptr constructed"</span></span> &lt;&lt; std::endl; rethrowException(currentException); } void exceptionPtrSample() { rethrowException(throwExceptionAndCaptureExceptionPtr()); checkMakeExceptionPtr(); }</code> </pre> <br>  If we run the function <b>exceptionPtrSample</b> for execution, we will see something like the following result: <br><blockquote>  throwing 10 ... <br>  int ctor <br>  catched int value: 10 <br>  catched int value: 10 <br>  int ctor <br>  copy ctor <br>  copy ctor <br>  exception_ptr constructed <br>  catched int value: 20 <br>  catched int value: 20 </blockquote><br>  In order to be able to conveniently work with exception_ptr, there are several auxiliary functions: <br><ul><li>  <b>current_exception</b> - this function returns exception_ptr.  If we are inside a catch block, it returns a exception_ptr that contains the exception currently being processed by the current thread, if calling it outside the catch block, it will return an empty exception_ptr object </li><li>  <b>rethrow_exception</b> - this function throws an exception that is contained in exception_ptr.  If the input parameter does not contain an exception (empty object), then the result is undefined.  In this case, msvc throws <a href="http://msdn.microsoft.com/ru-ru/library/dd293602.aspx">std :: bad_exception</a> , and the program compiled with gcc-4.7.2 <b>terminates unexpectedly</b> . </li><li>  <b>make_exception_ptr</b> - this function can construct exception_ptr without throwing an exception.  Its purpose is similar to the function std :: make_shared - constructing an object.  Its execution is similar to the <b>throwExceptionAndCaptureExceptionPtr</b> function <b>.</b>  <i>In the implementation from gcc-4.7.2, make_exception_ptr makes two copies of the object some_exception.</i> </li></ul><br><br><h6>  Passing Exceptions Between Threads </h6><br>  It seems to me that the type of exception_ptr was created specifically to solve the problem of passing exceptions between threads, so let's see how we can pass an exception from one thread to another: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::promise&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"exception from thread"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { p.set_exception(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::current_exception()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkThreadAndException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; p; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = p.get_future(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(worker, ref(p))</span></span></span></span>; t.detach(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result.get(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error &amp; e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"runtime error catched from async worker"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }</code> </pre> <br>  In general, multithreading in C ++ 11 is an extensive topic, it has its own subtleties, nuances and should be written about separately.  We will now consider this example just for the sake of passing an exception.  We start the <b>worker</b> function in a separate thread, and this function throws an exception.  The object of the promise class allows you to organize the connection between different threads, and atomically transfer values ‚Äã‚Äãfrom one stream to another (or exception).  In this example, we just use the <b>set_exception</b> method, which accepts exception_ptr as a parameter.  In order to get the value, we create an object of the <b>future</b> class - this is our result and we call the <b>get</b> method.  It is also necessary for the thread to call the <b>detach</b> or <b>join</b> method, since when the object is destroyed, <b>t</b> in the destructor is checked to joinable () == false, otherwise std :: terminate is called.  Most likely, this is due to the fact that the programmer does not "release the threads at will", but always followed them (or explicitly released using the <b>detach</b> method) <br><br>  We should also mention the use of multithreading in gcc-4.7.  Initially, this example did not work for me (I threw out an exception), while googling, I found out that in order to use std :: thread it is necessary to pass the -pthread flag to the <a href="http://stackoverflow.com/questions/7359575/c0x-thread-gcc-or-my-error">linker</a> .  Since I use CMake as a build system, this task is simplified (there may be difficulty when using gcc on different platforms, for example, the -thread flag is used instead of -pthread on sparc solaris) - there is a special CMake module Threads, in which this problem is solved : <br><blockquote>  find_package (Threads REQUIRED) <br>  # ... <br>  target_link_libraries (cxx_exceptions $ {CMAKE_THREAD_LIBS_INIT}) </blockquote><br><br><h5>  Nested exceptions </h5><br>  As the name implies, this mechanism allows you to attach other exceptions (which could have been thrown earlier) to the thrown exception.  For example, if we have our own hierarchy of exceptions, then we can catch all the "third-party" exceptions, attach them to our exceptions, and when handling our exceptions, we can add extra.  information that is ‚Äúattached‚Äù to them (for example, when debugging, we can print information about third-party exceptions).  A good example of using nested exception is provided at <a href="http://en.cppreference.com/w/cpp/error/nested_exception">cppreference.com</a> , my example, overlaps with it in part: <br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> third_party_exception { explicit third_party_exception(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e) : code(e) { } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> third_party_worker() { throw third_party_exception(<span class="hljs-number"><span class="hljs-number">100</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">our_exception</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runtime_error</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: our_exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> &amp; e) : std::runtime_error(<span class="hljs-string"><span class="hljs-string">"our error: "</span></span> + e) { } }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ourWorker() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { third_party_worker(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { throw_with_nested(our_exception(<span class="hljs-string"><span class="hljs-string">"worker failed"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> exceptionHandler(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> our_exception &amp; e, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> catchNested) { std::cerr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"our exception catched: "</span></span> &lt;&lt; e.what(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catchNested) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { rethrow_if_nested(e); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> third_party_exception &amp; e) { std::cerr &lt;&lt; <span class="hljs-string"><span class="hljs-string">", low level reason is: "</span></span> &lt;&lt; e.code; } } std::cerr &lt;&lt; std::endl; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> exceptionProcessing() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ourWorker(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> our_exception &amp; e) { exceptionHandler(e, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ourWorker(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> our_exception &amp; e) { exceptionHandler(e, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><br>  So, we have a third-party function that throws an exception, we can write an adapter that catches "third-party" exceptions, and from them makes "our" exception: the <b>third_party_worker</b> and <b>ourWorker</b> act as the "third-party" function and "our" function respectively.  We catch all exceptions, and we throw further our (our_exception) exception, at the same time, some kind of ‚Äúthird-party‚Äù exception was attached to it (we can in principle not even know what).  After that, we work with our exceptions.  At the same time, if we need more detailed information about what was happening at the ‚Äúlower‚Äù level, then we can always call the <b>rethrow_if_nested</b> function.  This function analyzes if there is a hooked (nested) exception, and if so, throws this nested exception.  The function <b>exceptionHandler</b> accepts "our" exception and an additional flag that allows or prohibits the display of information about a third-party exception.  We can control the output of third-party exceptions by controlling the catchNested parameter, for example, from the configuration file (or, depending on the build, Release, Debug). <br><br>  To work with nested exception there is one class and two functions: <br><ul><li>  nested_exception - this class is ‚Äúmixed in‚Äù to the object being thrown when the <b>std :: throw_with_nested</b> function is <b>called</b> ‚Äî this class also allows you to return a nested exception (exception_ptr) using the <b>nested_ptr</b> method.  This class also has a rethrow_nested method that throws a nested exception. </li><li>  throw_with_nested - this template function accepts an object of some type (let's call it <b>InputType</b> ), and throws an object that is the heir of std :: nested_exception and our <b>InputType</b> (in the implementation from gcc it is a template type that inherits from nested_exception and InputType).  Thus, we can catch both an object of our type and an object of type nested_exception and only then get our type through the nested_ptr method </li><li>  rethrow_if_nested - this function determines if an object has a nested exception, and if so, throws it.  An implementation can use dynamic_cast to determine inheritance. </li></ul><br>  In principle, the nested exception mechanism is quite interesting, although the implementation can be quite trivial, you can do it yourself using the previously described functions <b>current_exception</b> and <b>rethrow_exception</b> .  In the same implementation of gcc, the <b>nested_exception</b> class contains a single field of type <b>exception_ptr</b> , which is initialized in the constructor using the <b>current_exception</b> function, and the implementation of the <b>rethrow_nested</b> method simply calls the <b>rethrow_exception</b> function. <br><br><h5>  Noexcept specification </h5><br>  This mechanism can be considered as an extended (and now obsolete) throw () mechanism.  Its main purpose, as before, is to ensure that the function does not throw an exception (if the warranty is violated, then std :: terminate is called). <br><br>  This mechanism is used in two forms, similar to the old throw () <br><pre> <code class="hljs swift">void <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> noexcept { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><br>  And in the new form: <br><pre> <code class="hljs go">void <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boolean_expression_known_at_compile_time)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  In this case, if the value of the expression is calculated as true, then the function is marked as noexcept, otherwise, there is no such guarantee. <br>  There is also a corresponding noexcept (expression) operator, which is also executed in compile time; this operator returns true if the expression does not throw an exception: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexceptSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"noexcept int(): "</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>()) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"noexcept vector&lt;int&gt;(): "</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;()) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  This code for gcc-4.7.2 displays: <blockquote>  noexcept int (): 1 <br>  noexcept vector &lt;int&gt; (): 0 </blockquote><br><br>  Here we see that the constructor of the built-in type int does not throw an exception, and the vector constructor can throw (not marked as noexcept). <br>  This is convenient to use in template metaprogramming, using this operator, we can write a template function, which, depending on the template parameter, can be marked as noexcept or not: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;typename InputTypeT&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> func() noexcept(noexcept(InputTypeT())) { InputTypeT var; /// <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> smth <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> var std::cout &lt;&lt; "func called, object size: " &lt;&lt; sizeof(var) &lt;&lt; std::endl; } <span class="hljs-type"><span class="hljs-type">void</span></span> noexceptSample() { std::cout &lt;&lt; "noexcept int(): " &lt;&lt; noexcept(<span class="hljs-type"><span class="hljs-type">int</span></span>()) &lt;&lt; std::endl; std::cout &lt;&lt; "noexcept vector&lt;int&gt;(): " &lt;&lt; noexcept(std::vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;()) &lt;&lt; std::endl &lt;&lt; std::endl; /// @note <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> actually <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> std::cout &lt;&lt; "noexcept func&lt;int&gt;: " &lt;&lt; noexcept(func&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;()) &lt;&lt; std::endl; std::cout &lt;&lt; "noexcept func&lt;vector&lt;int&gt;&gt;: " &lt;&lt; noexcept(func&lt;std::vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;&gt;()) &lt;&lt; std::endl; }</code> </pre> <br>  This example displays: <blockquote>  noexcept int (): 1 <br>  noexcept vector &lt;int&gt; (): 0 <br><br>  noexcept func &lt;int&gt;: 1 <br>  noexcept func &lt;vector &lt;int &gt;&gt;: 0 </blockquote><br><br><h5>  Summary </h5><br>  The C ++ 11 standard introduced a lot of new things in error handling, of course, the key feature here is exception_ptr and the ability to pass arbitrary exceptions as ordinary objects (in functions, to pass exceptions between threads).  Earlier, in each thread, we had to write a spreading try ... catch for all exceptions, and this functionality minimizes the amount of try ... catch code. <br><br>  It also became possible to create nested exceptions, in principle in the boost library there is a mechanism <a href="http://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html">boost :: exception</a> , which allows attaching arbitrary data to the object (for example, error codes, its own messages, etc.), but it solves other tasks - the transfer of arbitrary data inside the exception. <br><br>  And finally, for those who need guarantees that the code will not throw exceptions, there is <b>noexcept</b> , in particular, many parts of the standard library use this mechanism. <br><br>  As usual, all the examples are posted on <a href="https://github.com/prograholic/blog/tree/master/exceptions">github.</a> <br><br>  Update 1. Removed from examples using namespace std, now you can see which entities belong to the standard library, and which are not. </div><p>Source: <a href="https://habr.com/ru/post/160955/">https://habr.com/ru/post/160955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160943/index.html">How ZFS Works - Part 1: vdev</a></li>
<li><a href="../160945/index.html">Installing Encrypted (TrueCrypt) Windows with Ubuntu Default</a></li>
<li><a href="../160947/index.html">Google will no longer block</a></li>
<li><a href="../160949/index.html">There will be no price increase for domains in the .COM zone!</a></li>
<li><a href="../160953/index.html">Virus movie from IE team about browser haters</a></li>
<li><a href="../160957/index.html">Youtube again allows you to test the new interface by changing the cookie.</a></li>
<li><a href="../160959/index.html">Dell released for developers ultrabook with Ubuntu</a></li>
<li><a href="../160961/index.html">Solving the problem of connecting PPTP VPN via LTE from Yota</a></li>
<li><a href="../160963/index.html">A look into the future of MODX. 2013</a></li>
<li><a href="../160965/index.html">A little about the conference Microsoft TechEd 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>