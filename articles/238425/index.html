<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HDR vs LDR, implementation of HDR Rendering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As I promised, I publish a second article on some aspects of game development in three dimensions. Today I will talk about one technique that is used ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HDR vs LDR, implementation of HDR Rendering</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/f58/ed0/b3c/f58ed0b3c3a14742ae76c99fd22e2ee9.jpg"></div><br><br>  As I promised, I publish a second article on some aspects of game development in three dimensions.  Today I will talk about one technique that is used in almost any <b>AAA</b> class project.  Her name is <b>HDR Rendering</b> .  If interested - welcome to habrakat. <br><a name="habracut"></a><br><br>  But first you need to talk.  Based on the <a href="http://habrahabr.ru/post/238385/">previous</a> article - I realized that the audience hacked technology <b>Microsoft XNA</b> .  To do something, allegedly, with the help of it, is the same as writing games on the <b>ZX Spectrum</b> .  They gave me an example: ‚Äú <i>There is SharpDX, SlimDX, OpenTK!</i>  ‚Äù, Even cited the example of <b>Unity</b> .  But we‚Äôll dwell on the first three, all this is <u>pure DX wrappers for .NET</u> , and <b>Unity</b> is a <u>sandbox engine</u> .  What is <b>DirectX10 +</b> anyway?  After all, it is not and will not be in <b>XNA</b> .  So, the overwhelming number of effects, chips and technologies is implemented on the basis of <b>DirectX9c</b> .  And <b>DirectX10 +</b> introduces only additional functionality ( <b>SM4.0, SM5.0</b> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Take, for example, <b>Crysis 2</b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/25e/e5e/1d1/25ee5e1d1710406dacce3d0a0b683f40.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9da/d88/d96/9dad88d9635b488d95e3e692cd25de4b.jpg"></div><br><br>  In these two screenshots <b>there is</b> no <b>DirextX10 and DirectX11</b> .  So why do people think that doing something on <b>XNA</b> is doing necrophilia?  Yes, <b>Microsoft has</b> stopped supporting <b>XNA</b> , but the stock of what is there is enough for 3 years.  Moreover, <b>monogame</b> now exists, it is open source, cross platform <i>(win, unix, mac, android, ios, etc)</i> and retains all the same <b>XNA</b> architecture.  By the way, <b>FeZ</b> from the <a href="http://habrahabr.ru/post/238385/">previous</a> article was written using <b>monogame</b> .  And finally - articles aimed generally at computer graphics in three dimensions (all of these provisions are valid for both <b>OpenGL</b> and <b>DirectX</b> ), not <b>XNA</b> - as one might think.  <b>XNA</b> in our case is just a tool. <br><br><h4>  Okay let's go </h4><br>  Usually in games <b>LDR</b> <i>(Low Dynamic Range)</i> rendering is used.  This means that the color of the back buffer is limited to 0 ... 1.  Where each channel is given 8 bits, and this is 256 gradations.  For example: 255, 255, 255 - white color, all three channels (RGB) are equal to the maximum gradation.  The concept of <b>LDR is</b> unfair to apply to the concept of realistic rendering, because  in the real world, color is far from being zero and one.  Such a technology as <b>HDRR comes to the rescue</b> .  For a start, what is <b>HDR</b> ?  <b>High Dynamic Range Rendering</b> , sometimes simply ‚Äú <b>High Dynamic Range</b> ‚Äù is a graphical effect used in computer games for more expressive rendering of an image in contrasting scene lighting.  What is the essence of this approach?  The fact that we draw our geometry (and lighting) is not limited to zero and one: one light source can give a pixel brightness of 0.5 units, and another one of 100 units.  But as you can see at first glance, our screen reproduces just that very <b>LDR</b> format.  And if we divide all the color values ‚Äã‚Äãof the back-buffer by the maximum brightness in the scene, we get the same <b>LDR</b> , and the light source of 0.5 units is almost not visible against the background of the second one.  And just for this a special method called <b>Tone Mapping</b> was invented.  The essence of this approach is that we bring the dynamic range to <b>LDR</b> depending on the average brightness of the scene.  And in order to understand what I mean, consider the scene: two rooms, one room <i>indoor</i> , the other <i>outdoor</i> .  The first room has an artificial light source, the second room has a light source in the form of the sun.  The brightness of the sun is much higher than the brightness of an artificial light source.  And in the real world, when we are in the first room, we adapt to this lighting, when we enter another room, we adapt to a different level of lighting.  When looking from the first room to the second - it will seem to us to be excessively bright, and when looking from the second to the first - black. <br><br>  Another example: one <i>outdoor</i> room.  In this room there is the sun itself and diffused light from the sun.  The brightness of the sun is much higher than its diffused light.  In the case of <b>LDR</b> , the brightness values ‚Äã‚Äãof the light would be equal.  Therefore, using <b>HDR</b> you can achieve realistic highlights from various surfaces.  This is very noticeable on the water: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/344/e7b/188/344e7b18831d4ffdaa294016fc0f2a88.png"></div><br><br>  Or on the glare from the surface: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/c4d/299/196/c4d2991963454e719c08be683c52a672.png"></div><br><br>  Well, the contrast of the scene as a whole (on the left is HDR, on the right is LDR): <br><div style="text-align:center;"><img src="https://habrastorage.org/files/993/8d9/a73/9938d9a73a324078b100989ab3329a80.jpg"></div><br><br>  Together with <b>HDR,</b> it is common to apply the <b>Bloom</b> technology, the bright areas are blurred and superimposed over the main image: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a53/347/c50/a53347c508b04eaeaaefcb19f7c190d6.jpg"></div><br><br>  This makes the lighting even softer. <br><br>  Also, in the form of a bonus - I will tell you about <b>Color Grading</b> .  This campaign is commonly used in AAA class games. <br><br><h4>  Color grading </h4><br>  Very often in games a scene should have its own color tone; this color tone can be common both for the whole game and for individual parts of the scene.  And in order not to have a hundred postprocessing shaders each time, they use the Color Grading approach.  What is the essence of this approach? <br><br>  Famous letters <b>RGB</b> - color three-dimensional space, where each channel is a kind of coordinate.  In the case of the format R8G8B8: 255 gradations for each channel.  So, what will happen if we apply the usual processing operations (for example, curves or contrast) to this space?  Our space will change and in the future we can assign to any pixel - a pixel from this space. <br><br>  Let's create a simple <b>RGB</b> space (I want to replace that we take every 8th pixel, because if we take all 256 gradations, the size of the texture will be very large): <br><img src="https://habrastorage.org/files/fbd/499/e71/fbd499e7154f4a5fa08b6719838b3824.png"><br><br>  This is a three-dimensional texture, where each axis has its own channel. <br><br>  And take some scene that needs to be modified (adding our space to the image): <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e5e/a9d/d5c/e5ea9dd5c09244bdbb76c0eb0927bb08.png"></div><br><br>  We carry out the transformations we need (by eye): <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a24/77f/a7c/a2477fa7ce1a451e962733782e0bf910.png"></div><br><br>  And extract our modifiable space: <br><img src="https://habrastorage.org/files/a0e/256/d0c/a0e256d0ceef446fadc8033067a0b959.png"><br><br>  Now, in this space - we can apply all modifications with color to any image.  Just by matching the original color with the altered color space. <br><br><h4>  Implementation </h4><br>  Well, briefly on the implementation of <b>HDR</b> in <b>XNA</b> .  In <b>XNA,</b> the back buffer format is specified (mostly) by the <b>R8G8B8A8</b> , since  Rendering directly to the screen can not support <b>HDR a</b> priori.  For this workaround, we need to create a new RenderTarget (I previously described how they work <a href="http://habrahabr.ru/post/134819/">here</a> ) with a special format: <i>HalfVector4</i> *.  This format supports floating values ‚Äã‚Äãfor <i>RenderTarget</i> . <br><br>  * - in <b>XNA</b> there is such a format - like <i>HDRBlendable</i> , this is all the same <i>HalfVector4</i> - but RT itself takes up less space (because we don‚Äôt need a <i>floating-point</i> on the alpha channel). <br><br>  Let's get the necessary <i>RenderTarget</i> : <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _makeRenderTarget() { <span class="hljs-comment"><span class="hljs-comment">// Use regular fp16 _sceneTarget = new RenderTarget2D(GraphicsDevice, GraphicsDevice.PresentationParameters.BackBufferWidth, GraphicsDevice.PresentationParameters.BackBufferHeight, false, SurfaceFormat.HdrBlendable, DepthFormat.Depth24Stencil8, 0, RenderTargetUsage.DiscardContents); }</span></span></code> </pre> <br><br>  Create a new RT with back buffer sizes (screen resolution) with mipmap disabled (since this texture will be drawn on the screen quad) with a surface format - <i>HdrBlendable</i> (or <i>HalfVector4</i> ) and a 24-bit 8-bit depth / stencil buffer buffer .  Also disable <i>multisampling</i> . <br>  This <i>RenderTarget</i> is important to enable the depth buffer (as opposed to the usual post-process RT), because  we will draw our geometry there. <br><br>  Further, everything is like in <b>LDR</b> , we draw a scene, only now we don‚Äôt need to limit ourselves to drawing brightness [0 ... 1]. <br>  Add a skybox with a nominal brightness multiplied by three and a classic Utah teapot with <b>DirectionalLight</b> lighting and <i>Reflective</i> surface. <br><br>  The scene was created and now we need to somehow bring the <b>HDR</b> format to <b>LDR</b> .  Take the simplest <b>ToneMapping</b> - we divide all these values ‚Äã‚Äãinto the conditional max value. <br><br><pre> <code class="cs hljs">float3 _toneSimple(float3 vColor, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vColor / max; }</code> </pre><br><br>  Twist the camera and realize that the scene still has static and a similar picture can be easily achieved by applying contrast to the image. <br><br>  In real life, our eye adapts to the right light: in a poorly lit room, we still see, but as long as there is no bright source of light before our eyes.  This is called a light adaptation.  And the coolest thing is that <b>HDR</b> and color adaptation perfectly blend with each other. <br><br>  Now we need to calculate the average color value on the screen.  This is quite problematic, because  format with a floating value does not support filtering.  We proceed as follows: create an Nth number of RTs, where each next one is less than the previous one: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = DOWNSAMPLER_ADAPATION_CYCLES; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> delmiter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cycles+<span class="hljs-number"><span class="hljs-number">1</span></span>); _downscaleAverageColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RenderTarget2D[cycles]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cycles; i++) { _downscaleAverageColor[(cycles<span class="hljs-number"><span class="hljs-number">-1</span></span>)-i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RenderTarget2D(_graphics, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width * delmiter * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>)), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height * delmiter * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>)), <span class="hljs-literal"><span class="hljs-literal">false</span></span>, SurfaceFormat.HdrBlendable, DepthFormat.None); }</code> </pre><br><br>  And we will draw each previous RT in the next RT applying some blur.  After these cycles, we get a <i>1x1</i> texture, which in fact will contain the average color. <br><br>  If this is all started now, then the color adaptation really will be, but it will be instant, and it does not happen.  We need to, when looking from a sharply dark area to a sharply light one, first we feel blindness (in the form of increased brightness), and then everything returns to normal.  To do this, it is enough to get another RT <i>1x1</i> , which will be responsible for the current value of adaptation, and each frame we bring the current adaptation to the currently calculated color.  Moreover, the value of this approximation should be tied to the same <i>gameTime.ElapsedGameTime</i> so that the number of <i>FPS</i> does not affect the speed of adaptation. <br><br>  Well, now as the max parameter for _toneSimple, you can pass on our average color. <br><br>  There are lots of <b>ToneMapping</b> 'a formulas, here are some of them: <br><br><div class="spoiler">  <b class="spoiler_title">Reinhard</b> <div class="spoiler_text"><pre> <code class="cs hljs">float3 _toneReinhard(float3 vColor, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> average, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> exposure, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> whitePoint) { <span class="hljs-comment"><span class="hljs-comment">// RGB -&gt; XYZ conversion const float3x3 RGB2XYZ = {0.5141364, 0.3238786, 0.16036376, 0.265068, 0.67023428, 0.06409157, 0.0241188, 0.1228178, 0.84442666}; float3 XYZ = mul(RGB2XYZ, vColor.rgb); // XYZ -&gt; Yxy conversion float3 Yxy; Yxy.r = XYZ.g; // copy luminance Y Yxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b ); // x = X / (X + Y + Z) Yxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b ); // y = Y / (X + Y + Z) // (Lp) Map average luminance to the middlegrey zone by scaling pixel luminance float Lp = Yxy.r * exposure / average; // (Ld) Scale all luminance within a displayable range of 0 to 1 Yxy.r = (Lp * (1.0f + Lp/(whitePoint * whitePoint)))/(1.0f + Lp); // Yxy -&gt; XYZ conversion XYZ.r = Yxy.r * Yxy.g / Yxy. b; // X = Y * x / y XYZ.g = Yxy.r; // copy luminance Y XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b; // Z = Y * (1-xy) / y // XYZ -&gt; RGB conversion const float3x3 XYZ2RGB = { 2.5651,-1.1665,-0.3986, -1.0217, 1.9777, 0.0439, 0.0753, -0.2543, 1.1892}; return mul(XYZ2RGB, XYZ); }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exposure</b> <div class="spoiler_text"><pre> <code class="cs hljs">float3 _toneExposure(float3 vColor, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> average) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> T = pow(average, <span class="hljs-number"><span class="hljs-number">-1</span></span>); float3 result = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); result.r = <span class="hljs-number"><span class="hljs-number">1</span></span> - exp(-T * vColor.r); result.g = <span class="hljs-number"><span class="hljs-number">1</span></span> - exp(-T * vColor.g); result.b = <span class="hljs-number"><span class="hljs-number">1</span></span> - exp(-T * vColor.b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br></div></div><br><br>  I use my own formula: <br><br><div class="spoiler">  <b class="spoiler_title">Exposure2</b> <div class="spoiler_text"><pre> <code class="cs hljs">float3 _toneDefault(float3 vColor, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> average) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fLumAvg = exp(average); <span class="hljs-comment"><span class="hljs-comment">// Calculate the luminance of the current pixel float fLumPixel = dot(vColor, LUM_CONVERT); // Apply the modified operator (Eq. 4) float fLumScaled = (fLumPixel * g_fMiddleGrey) / fLumAvg; float fLumCompressed = (fLumScaled * (1 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1 + fLumScaled); return fLumCompressed * vColor; }</span></span></code> </pre> <br></div></div><br><br>  Well, the next stage is <b>Bloom</b> (partly I described it <a href="http://habrahabr.ru/post/147799/">here</a> ) and <b>Color Grading</b> : <br><br>  Using <i>Color Grading</i> : <br>  Any pixel color value (RGB) after <b>ToneMapping</b> 'a is in the range from 0 to 1. Our <i>Color Grading</i> color space also conventionally lies in the range from 0 to 1. Therefore, we can replace the current pixel color value with the color of the pixel in the color space.  At the same time, filtering the sampler will perform linear interpolation between our 32 values ‚Äã‚Äãon the <i>Color Grading</i> map.  Those.  we "as though" <br>  we replace the reference color space with our modified one. <br><br>  For <b>Color Grading</b> , enter the following function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gradColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">float3 color</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex3D(ColorGradingSampler, float3(color.r, color.b, color.g)).rgb; }</code> </pre><br><br>  where <i>ColorGradingSampler</i> is a three-dimensional sampler. <br><br>  Well, LDR / HDR comparison: <br>  <b>LDR:</b> <br><img src="//habrastorage.org/files/333/0fe/33b/3330fe33bbf04860881ae48c932efca9.png"><br><br>  <b>HDR:</b> <br><img src="//habrastorage.org/files/716/b28/ec4/716b28ec4f4f4ce6a8d89126f16cf19e.png"><br><br><h4>  Conclusion </h4><br>  This simple approach is one of the chips of <b>3D AAA games</b> .  And as you can see, it can be implemented on the good old <b>DirectX9c</b> , and the implementation in <b>DirectX10 + is</b> fundamentally different.  More information can be found in the <a href="">source</a> . <br><br>  It is also worth distinguishing from each other <a href="https://ru.wikipedia.org/wiki/High_Dynamic_Range_Imaging">HDRI</a> (used in photography) and <a href="https://ru.wikipedia.org/wiki/High_Dynamic_Range_Rendering">HDRR</a> (used in rendering). <br><br><h4>  Conclusion 2 </h4><br>  <i>Unfortunately, when I wrote articles on game development in 2012, there were much more responses and assessments, but now my expectations were slightly disappointed.</i>  <i>I do not chase the evaluation of the topic.</i>  <i>I do not want him artificially high or low.</i>  <i>I want it to be evaluated: not necessarily as: ‚ÄúA good article!‚Äù, But also with ‚ÄúAn article in my opinion is incomplete, with% item% the situation has remained unclear.‚Äù.</i>  <i>I am pleased even with a negative, but constructive assessment.</i>  <i>And as a result - I publish an article, and she somehow collects a couple of comments and ratings.</i>  <i>And taking into account the fact that this self-regulating community Habrahabr suggests the following conclusion: the article is not interesting -&gt; it doesn't make sense to publish such a thing.</i> <br><br>  <i>PS we are all human and we make mistakes and therefore, if you find a mistake in the text - write me a personal message, and do not rush to write an angry comment!</i> </div><p>Source: <a href="https://habr.com/ru/post/238425/">https://habr.com/ru/post/238425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238415/index.html">Mining "tyzhprogrammista"</a></li>
<li><a href="../238417/index.html">Lecture "history of astronautics"</a></li>
<li><a href="../238419/index.html">"Langfang: Silicon Valley in Chinese?"</a></li>
<li><a href="../238421/index.html">Intel introduced a new family of server chips</a></li>
<li><a href="../238423/index.html">Your Kickstarter Project: A Practical Guide</a></li>
<li><a href="../238427/index.html">A story about how I simplified my military service with Excel and VBA</a></li>
<li><a href="../238429/index.html">The digest of interesting materials for the mobile developer # 72 (September 22-28)</a></li>
<li><a href="../238431/index.html">Overview of the most interesting materials on data analysis and machine learning ‚Ññ15 (September 22 - 28, 2014)</a></li>
<li><a href="../238433/index.html">Is it possible to create a lightsaber from the point of view of modern science?</a></li>
<li><a href="../238437/index.html">The whole truth about venture capital investors, part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>