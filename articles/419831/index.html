<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS works: custom elements</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[We advise you to read] Other 19 parts of the cycle  Part 1: Overview of the engine, execution time mechanisms, call stack 
 Part 2: About the V8 inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS works: custom elements</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br>  We present to your attention a translation of 19 articles from the <a href="https://www.sessionstack.com/">SessionStack</a> series of materials on the features of various JavaScript ecosystem mechanisms.  Today we will talk about the standard Custom Elements - the so-called "custom elements".  We will talk about what tasks they allow to solve, and how to create and use them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="image"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Overview</font> </h2><br>  In one of the previous articles in this series, we talked about the <a href="https://habr.com/company/ruvds/blog/415881/">Shadow DOM</a> and some other technologies that are part of a larger phenomenon ‚Äî web components.  Web components are designed to give developers the ability to extend standard HTML capabilities by creating compact, modular and reusable elements.  This is a relatively new W3C standard, which manufacturers of all leading browsers have already noticed.  It can be found in production, although, of course, while his work is provided by polyfills (we'll talk about them later). <br><br>  As you may already know, browsers provide us with several critical tools for developing websites and web applications.  We are talking about HTML, CSS and JavaScript.  HTML is used to structure web pages, thanks to CSS they give a nice appearance, and JavaScript is responsible for interactive features.  However, before the advent of web components, it was not so easy to link actions implemented by JavaScript tools with the HTML structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a matter of fact, here we look at the basis of web components - custom elements (Custom Elements).  If you talk about them in a nutshell, the API designed to work with them allows the programmer to create custom HTML elements with JavaScript logic embedded in them and styles described by CSS.  Many confuse custom elements with Shadow DOM technology.  However, these are two completely different things that, in fact, complement each other, but are not interchangeable. <br><br>  Some frameworks (such as Angular or React) try to solve the same problem that custom elements solve by introducing their own concepts.  Custom elements can be compared with Angular directives or with React components.  However, custom elements are a standard browser feature; you do not need anything other than regular JavaScript, HTML, and CSS to work with them.  Of course, this does not allow us to say that they are a substitute for ordinary JS frameworks.  Modern frameworks give us much more than just the ability to imitate the behavior of user elements.  As a result, we can say that both frameworks and custom elements are technologies that can be used together to solve web development tasks. <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br>  Before we continue, let's see what opportunities the API provides for working with custom elements.  Namely, we are talking about the global <code>customElements</code> object, which has several methods: <br><br><ul><li>  The <code>define(tagName, constructor, options)</code> method allows you to define (create, register) a new custom element.  It takes three arguments - the name of the tag for the custom element, which corresponds to the rules for naming such elements, the class declaration and an object with parameters.  Currently, only one parameter is supported - <code>extends</code> , which is a string specifying the name of an inline element that is planned to be expanded.  This feature is used to create special versions of standard elements. </li><li>  The <code>get(tagName)</code> method returns a custom element constructor, provided that this element is already defined, otherwise it returns <code>undefined</code> .  It takes one argument ‚Äî the tag name of the custom item. </li><li>  The <code>whenDefined(tagName)</code> method returns a promise that is resolved after the user element is created.  If an item is already defined, this promise is resolved immediately.  A promis is rejected if the tag name passed to it is not a valid custom element tag name.  This method takes the tag name of the custom item. </li></ul><br><h2>  <font color="#3AC1EF">Creating custom items</font> </h2><br>  Creating custom elements is easy.  To do this, you need to do two things: create a class declaration for the element that must extend the <code>HTMLElement</code> class and register this element with the selected name.  Here's what it looks like: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br>  If you do not want to pollute the current scope, you can use an anonymous class: <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ });</span></span></code> </pre> <br>  As you can see from the examples, the user element is registered using the <code>customElements.define(...)</code> method already familiar to you. <br><br><h2>  <font color="#3AC1EF">Problems that Custom Elements Solve</font> </h2><br>  Let's talk about the problems that allow us to solve custom elements.  One of them is to improve the structure of the code and eliminate what is called ‚Äúsoup from div tags‚Äù (div soup).  This phenomenon is a very common code structure in modern web applications, in which there are many <code>div</code> elements nested in each other.  Here is what it might look like: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           ‚Ä¶         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Such HTML code is used for justifiable reasons - it describes the device of the page and provides its correct output to the screen.  However, this worsens the readability of the HTML code and complicates its maintenance. <br><br>  Suppose we have a component that looks like the one shown in the following figure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">Component appearance</font></i> <br><br>  When using the traditional approach to the description of such things this component will correspond to the following code: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Now imagine that we could, instead of this code, use this component description: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  I'm sure everyone will agree that the second code fragment looks much better.  This code is easier to read, easier to maintain, it is understandable to both the developer and the browser.  It all comes down to the fact that it is simpler than the one in which there are many nested <code>div</code> tags. <br><br>  The next problem that can be solved with custom elements is code reuse.  The code that developers write should be not only working, but also supported.  Reusing code, as opposed to constantly writing the same constructs, improves the ability to support projects. <br>  Here is a simple example that will allow you to better understand this idea.  Suppose we have the following element: <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br>  If there is always a need for it, then, with the usual approach, we will have to write the same HTML code again and again.  Now imagine that you need to make a change in this code that should be reflected wherever it is used.  This means that we need to find all the places where this fragment is used, and then make the same changes everywhere.  It is long, hard and fraught with mistakes. <br><br>  It would be much better if we could, where this element is needed, just write the following: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-custom-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-custom-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  However, modern web applications are much more than static HTML.  They are interactive.  The source of their interactivity is javascript.  Usually, to provide such opportunities, they create certain elements, then they connect event listeners to them, which allows them to react to the user's actions.  For example, they can react to clicks, the mouse hovering over them, dragging them around the screen, and so on.  Here's how to connect to the element the event listener that occurs when you click on it with the mouse: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br>  And here is the HTML code for this element: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br>  By using the API to work with custom elements, all this logic can be incorporated into the element itself.  For comparison, the code for declaring a custom element that includes an event handler is shown below: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br>  And this is how it looks in the HTML code of the page: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-custom-element</span></span></span><span class="hljs-tag">&gt;</span></span> I have not been clicked yet <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-custom-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  At first glance it may seem that to create a custom element requires more lines of JS-code.  However, in real applications it is rarely the case that such elements would be created only in order to use them only once.  Another typical phenomenon in modern web applications is that most of the elements in them are created dynamically.  This leads to the need to support two different scenarios for working with elements - situations when they are added to the page dynamically with JavaScript tools, and situations when they are described in the original HTML structure of the page.  Thanks to the use of custom elements work in these two situations is simplified. <br><br>  As a result, if we summarize this section, we can say that user elements make the code clearer, simplify its support, contribute to splitting it into small modules that include all the necessary functionality and are suitable for reuse. <br><br>  Now that we have discussed general issues of working with custom elements, let's talk about their features. <br><br><h2>  <font color="#3AC1EF">Requirements</font> </h2><br>  Before you begin developing your own custom elements, you should be aware of some of the rules to follow when creating them.  Here they are: <br><br><ul><li>  The component name must include a hyphen ( <code>-</code> symbol).  This allows the HTML parser to distinguish between embedded and custom elements.  In addition, this approach ensures the absence of name collisions with embedded elements (both with those that exist now and those that appear in the future).  For example, the actual name of the custom element is <code>&gt;my-custom-element&lt;</code> , and the names <code>&gt;myCustomElement&lt;</code> and <code>&lt;my_custom_element&gt;</code> are inappropriate. </li><li>  It is forbidden to register the same tag more than once.  Attempting to do this will cause the browser to issue a <code>DOMException</code> error.  Custom members cannot be overridden. </li><li>  Custom tags cannot be self-closing.  The HTML parser supports only a limited set of standard self-closing tags (for example, <code>&lt;img&gt;</code> , <code>&lt;link&gt;</code> , <code>&lt;br&gt;</code> ). </li></ul><br><h2>  <font color="#3AC1EF">Opportunities</font> </h2><br>  Let's talk about what you can do with custom elements.  If you briefly answer this question, it turns out that you can do a lot of interesting things with them. <br><br>  One of the most noticeable features of custom elements is that the class declaration of an element refers to the DOM element itself.  This means that you can use the this keyword in your ad to connect event listeners, access properties, child nodes, and so on. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br>  This, of course, makes it possible to write new data to the child nodes of the element.  However, it is not recommended to do this, as this may lead to unexpected behavior of the elements.  If you imagine that you are using elements that are developed by someone else, then you will surely be surprised if your own markup placed in the element is replaced with something else. <br><br>  There are several methods that allow you to execute code at certain points in an element's life cycle. <br><br><ul><li>  The <code>constructor</code> method is called once, when creating or ‚Äúupdating‚Äù (upgrading) an element (we will discuss this later).  Most often it is used to initialize the state of an element, to connect event listeners, create a Shadow DOM, and so on.  Do not forget that in the constructor you always need to call <code>super()</code> . </li><li>  The <code>connectedCallback</code> method is called each time an element is added to the DOM.  It can be used (and it is recommended to use it) in order to postpone any actions until the element is on the page (for example, you can postpone loading some data). </li><li>  The <code>disconnectedCallback</code> method is called when an element is removed from the DOM.  It is usually used to free up resources.  Note that this method is not called if the user closes the browser tab with the page.  Therefore, do not rely on it when you need to perform some particularly important actions. </li><li>  The <code>attributeChangedCallback</code> method is called when an element <code>attributeChangedCallback</code> is added, deleted, updated, or replaced.  In addition, it is called when the element is created by the parser.  Note, however, that this method applies only to the attributes that are listed in the <code>observedAttributes</code> property. </li><li>  The <code>adoptedCallback</code> method <code>adoptedCallback</code> called when the <code>document.adoptNode(...)</code> method is used to move a node to another document. </li></ul><br>  Please note that all the above methods are synchronous.  For example, the <code>connectedCallback</code> method is called immediately after an element is added to the DOM, and the rest of the program is waiting for this method to finish. <br><br><h2>  <font color="#3AC1EF">Property Reflection</font> </h2><br>  Embedded HTML elements have one very convenient feature: property reflection.  Thanks to this mechanism, the values ‚Äã‚Äãof some properties are directly reflected in the DOM as attributes.  Let's say this is typical for the <code>id</code> property.  For example, perform the following operation: <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br>  Relevant changes will also affect DOM: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  This mechanism works in the opposite direction.  It is very useful as it allows you to configure elements declaratively. <br><br>  Custom elements have no such built-in capability, but you can implement it yourself.  In order for some properties of custom elements to behave in a similar way, you can configure their getters and setters. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Expansion of existing elements</font> </h2><br>  The User Element API allows you to not only create new HTML elements, but also extend existing ones.  Moreover, we are talking about standard elements, and custom.  This is done by using the <code>extends</code> when declaring a class: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br>  Extended standard elements are also called ‚Äúcustomized built-in elements‚Äù (customized built-in element). <br><br>  It is recommended to make it a rule to always expand existing elements, and to do this progressively.  This will allow you to retain in the new elements the capabilities that were implemented in the previously created elements (that is, properties, attributes, functions). <br><br>  Please note that now custom built-in elements are supported only in Chrome 67+.  This will appear in other browsers, however, it is known that the Safari developers have decided not to implement this feature. <br><br><h2>  <font color="#3AC1EF">Update items</font> </h2><br>  As already mentioned, the <code>customElements.define(...)</code> method is used to register custom elements.  However, registration cannot be called the action that needs to be performed first.  The registration of a user element can be postponed for some time, moreover, this time can come even when the element is already added to the DOM.  This process is called the upgrade item.  In order to find out when the item will be registered, the browser provides the <code>customElements.whenDefined(...)</code> method.  The name of the element tag is passed to it, and it returns a promise that is allowed after the element is registered. <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br>  For example, it may be necessary to delay the registration of an element until its child elements are declared.  Such a line of conduct can be extremely useful if the project contains nested user elements.  Sometimes the parent element can rely on the implementation of the child elements.  In this case, you need to ensure that children are registered before the parent. <br><br><h2>  <font color="#3AC1EF">Shadow dom</font> </h2><br>  As already mentioned, custom elements and Shadow DOM are complementary technologies.  The first allows you to encapsulate JS logic in user elements, and the second allows you to create isolated environments for DOM fragments that are not affected by what is outside of them.  If you feel that you need to better understand the concept of the Shadow DOM - take a look at one of our <a href="https://habr.com/company/ruvds/blog/415881/">previous publications</a> . <br><br>  Here is how to use the Shadow DOM for a custom item: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br>  As you can see, the key here is the call to <code>this.attachShadow</code> . <br><br><h2>  <font color="#3AC1EF">Templates</font> </h2><br>  In one of our <a href="https://habr.com/company/ruvds/blog/415881/">previous materials</a> we talked a little about templates, although they are, in fact, worthy of a separate article.  Here we look at a simple example of how to embed templates into custom elements when they are created.  So, using the <code>&lt;template&gt;</code> , you can describe the DOM fragment, which will be processed by the parser, but will not be displayed on the page: <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br>  Here's how to apply a template in a custom item: <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br>  As you can see, there is a combination of a custom element, a Shadow DOM, and templates.  This allowed us to create an element isolated in its own space, in which the HTML structure is separated from the JS logic. <br><br><h2>  <font color="#3AC1EF">Stylization</font> </h2><br>  So far we have only talked about JavaScript and HTML, bypassing CSS.  Therefore, now we will touch on the theme of styles.  Obviously, we need some way of styling custom elements.  Styles can be added inside the Shadow DOM, but then the question arises of how to stylize such elements from the outside, for example, if the one who created them is not used.  The answer to this question is quite simple - custom elements are stylized in the same way as embedded ones. <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Notice that external styles have a higher priority than styles declared inside the element, overriding them. <br><br>  You may have seen how, at the time the page was displayed on the screen, at some point it is possible to observe non-stylized content on it (this is what is called FOUC - Flash Of Unstyled Content).  This phenomenon can be avoided by setting styles for unregistered components, and using certain visual effects during their registration.  For this you can use the selector <code>:defined</code> .  You can do this, for example, as follows: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">Unknown elements and undefined user elements</font> </h2><br>  The HTML specification is very flexible; it allows you to declare any tags that a developer needs.  And, if the tag is not recognized by the browser, it will be processed by the parser as <code>HTMLUnknownElement</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br>  However, when working with custom elements, this scheme does not apply.  Remember, we talked about the rules for naming such elements?     ,    ,      <code>HTMLElement</code>        . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br>   <code>HTMLElement</code>  <code>HTMLUnknownElement</code>    ,    ,  ,  ,    -   .  ,  ,     ,    .          <code>div</code> .             . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  ‚Äî   <a href="https://www.html5rocks.com/en/tutorials/webcomponents/customelements/"></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         ‚Äî   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   ‚Äî   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://caniuse.com/"></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>Dear readers!</b>         ? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/419831/">https://habr.com/ru/post/419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419817/index.html">Launch of RabbitMQ cluster in Kubernetes</a></li>
<li><a href="../419819/index.html">Biomarkers of aging. Frailty panel. Part 2</a></li>
<li><a href="../419823/index.html">Unusual Duet - Passwords and Mnemonic Images</a></li>
<li><a href="../419825/index.html">Performance testing of several types of drives in a virtual environment</a></li>
<li><a href="../419829/index.html">The default key encryption in OpenSSH is worse than its absence</a></li>
<li><a href="../419833/index.html">Remote work, how it works</a></li>
<li><a href="../419835/index.html">How to motivate authors, negotiate with experts and generally write good articles</a></li>
<li><a href="../419837/index.html">I, RoboLoyer, or how to look for anomalies in documents</a></li>
<li><a href="../419839/index.html">Low Level Hacking NCR ATMs</a></li>
<li><a href="../419843/index.html">GeekUniversity opens recruitment to the department of artificial intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>