<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My bike to reflection in c ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspired by the publication of ‚ÄúLogger with member functions that are not there,‚Äù I decided to give out for everyone to see my meta-bike for reflectio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My bike to reflection in c ++</h1><div class="post__text post__text-html js-mediator-article">  Inspired by the publication of <a href="http://habrahabr.ru/post/242869/">‚ÄúLogger with member functions that are not there,‚Äù</a> I decided to give out for everyone to see my meta-bike for reflection, which I use quite successfully, and not only for logging.  But let's start with simple logging, continuing the above publication. <br><br>  When implementing logging, tasks for yourself were set as follows: <br><br><ul><li>  Solve the problem on the "meta level" to be untied from the final implementation </li><li>  Frontend api for logging should be simple and transparent. </li><li>  To be able to turn off unnecessary logging levels at the compilation stage with one constant;  for example: all that is higher LOG_NOTICE should not fall into the resulting binary </li></ul><br>  The frontend looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. In the constructor CConnection we logged: <br><pre><code class="hljs kotlin">TestLog::Log&lt;LOG_NOTICE&gt;() &lt;&lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection created"</span></span>;</code> </pre> <br>  2. Where CConnection is inherited from <pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">TLogHeader</span></span>&lt;'<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>', <span class="hljs-type"><span class="hljs-type">CConnection</span></span>&gt;</code> </pre> <br>  3. Who, using <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> , knows that CConnection has this: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span> = CConnection; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_id; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_id_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_id), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_id&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_name_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_name), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_name&gt;; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m_state; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_state_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_state), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_state&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log_header_param_list_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">m_id_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">m_name_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">m_state_t</span></span>&gt;;</code> </pre><br>  4. And turns this data into a log line: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:23</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:test_conn</span></span> 1<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:connection</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">created</span></span></code> </pre> <br>  Where a colon is listed: c - the first parameter of the TLogHeader template, and then the values ‚Äã‚Äãof m_id, m_name, m_state <br><br>  In my case, all this is further written to rsyslog and there it is parsed into the appropriate fields for MongoDB (depending on the type of header, that is, the first parameter before the colon). <br><br>  Now this approach is in my production on a high-load system, so any constructive stones will be in peak, or better under cat.  And if laziness, <a href="http://coliru.stacked-crooked.com/a/0a99b0343302df5b">here's a working example at http://coliru.stacked-crooked.com/</a>  under the code cut of 250 lines, but a lot of letters in the description. <br><a name="habracut"></a><br>  Sorry if there is a lot of transliteration and English terms.  The article is a complete gag, but for 20 years it somehow lagged behind Russian terminology.  Therefore, there will be no references to the literature, although at one point I was helped on stackoverflow.com, but giving a link there means burning my anonymity as a sand user, as I understand it. <br><br>  So. <br><br><h4>  <b>Part 1 - Logging</b> </h4><br><h5>  <b>Start simple</b> </h5><br><pre> <code class="hljs kotlin">TestLog::Log&lt;LOG_NOTICE&gt;() &lt;&lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection created"</span></span>;</code> </pre> <br><br>  ‚ÄúTemplate TestLog :: Log‚Äù in our case is a type (but can also be implemented as a function that returns a type).  As we see, a temporary object of this type is created.  And, knowing that any object will be destroyed when leaving the scope, it is clear that for this type it will be ';'.  Accordingly, the behavior model is simple - we merge the data into this type, after which the destructor is called. <br><br><div class="spoiler">  <b class="spoiler_title">It is implemented in the class TSink</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class"> {</span></span> ~TSink() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"std::err log line flushed: \""</span></span> &lt;&lt; stream.str() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" \""</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, isNull&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { stream &lt;&lt; val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class">&lt;logLevel, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Partial specialization is needed here in order to ‚ÄúHave the ability to turn off unnecessary logging levels at the compilation stage with one constant;  for example: everything above LOG_NOTICE should not fall into the resulting binary. ‚Äù  This is a gift to us from the compiler (which I‚Äôm not 100% sure of, since I‚Äôm not too eager to decompile the code and see what we have at the exit; hello, stones!).  The idea is simple: the write statement to the stream does not perform any data manipulations, and if we take into account that we have created a temporary object and everything we do before deleting it, we write it into the stream, then the modern compiler optimizes this whole thing. </div></div><br><div class="spoiler">  <b class="spoiler_title">And this is how it will look like if instead of cerr we are merging into syslog</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class"> {</span></span> ~TSink() { syslog(logLevel, stream.str().c_str(), <span class="hljs-string"><span class="hljs-string">"junk"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, isNull&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { stream &lt;&lt; val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class">&lt;logLevel, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre> </div></div><br>  It is worth mentioning that TSink is already the final implementation tied to a specific logging module (for example: standard output stream, file, syslog, etc.).  The TLog class itself, which we will look at later, does not know how it will be implemented, it receives traits at the input, which will already refer to a specific implementation of the sink. <br><br><h5>  <b>Let's see what TestLog :: Log is</b> </h5><br>  It: <pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OUR_LOG_LEVEL = LOG_DEBUG; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TestLog = TLog&lt;OUR_LOG_LEVEL, TLogTraitsStdErr&gt;;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And, actually, implementation of TLog</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logUpTo, <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log_traits</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLog</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> log_traits&lt;logUpTo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trats_t</span></span> = log_traits&lt;logUpTo&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> sink_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trats_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> sink_type&lt;logLevel, isNull&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neededLogLevel, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TGetLogOfLevel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; neededLogLevel == logLevel, sink_type&lt;neededLogLevel, (neededLogLevel &gt; logUpTo)&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TGetLogOfLevel&lt;neededLogLevel, logLevel + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::type &gt;::type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neededLogLevel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TGetLogOfLevel</span></span></span><span class="hljs-class">&lt;neededLogLevel, LOG_DEBUG + 1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neededLogLevel&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Log = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TGetLogOfLevel&lt;neededLogLevel, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;::type; };</code> </pre> </div></div><br>  We get two parameters to the ‚Äútemplate input‚Äù: the maximum logging level in this program assembly (OUR_LOG_LEVEL) and the log_traits template type, from which we inherit from hereafter. <br><br>  As can be seen from the code, the log_traits type has two requirements: <br><ul><li>  the type must take an int logUpTo input (which is forwarded from our first TLog parameter) </li><li>  the type must have a definition of another template type sink_type &lt;int logLevel, bool isNull&gt;, where logLevel is the level of the current logging operation, and isNull - whether we log the current level at all (see partial specialization TSink &lt;logLevel, true&gt;) </li></ul><br>  It all works very simply inside: we define the type Log, which is the result of a call to the recursive meta-function TGetLogOfLevel (neededLogLevel, logLevel), which in the case of usedLogLevel == logLevel returns the current level's sink_type or recursively calls itself with a logging level of +1. <br><br><h5>  <b>Based on all this, we will do the final log_traits implementation</b> </h5><br>  To do this, we wrap our ready-made TSink into a new TLogTraits class considering the requirements for log_traits described above.  Those.  define the type of traits_type as <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span> logLevel, <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">isNull</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> sink_type = TSink&lt;logLevel, <span class="hljs-keyword"><span class="hljs-keyword">isNull</span></span>&gt;;</code> </pre>  We also add the OpenLog function and close it in the (log) destructor. <br><br><div class="spoiler">  <b class="spoiler_title">Here is the code for TLogTraitsStdErr</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logUpTo&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLogTraitsStdErr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* logName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> facility)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"std::err log opened with logName: "</span></span> &lt;&lt; logName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ~TLogTraitsStdErr() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"std::err log closed"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class"> {</span></span> ~TSink() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"std::err log line flushed: \""</span></span> &lt;&lt; stream.str() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" \""</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, isNull&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { stream &lt;&lt; val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class">&lt;logLevel, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> sink_type = TSink&lt;logLevel, isNull&gt;; };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">And by analogy TLogTraitsSyslog</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logUpTo&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLogTraitsSyslog</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* logName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> facility)</span></span></span><span class="hljs-function"> </span></span>{ openlog(logName, LOG_PID | LOG_NDELAY, facility); setlogmask(LOG_UPTO(logUpTo)); } ~TLogTraitsSyslog() { closelog(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class"> {</span></span> ~TSink() { syslog(logLevel, stream.str().c_str(), <span class="hljs-string"><span class="hljs-string">"junk"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, isNull&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { stream &lt;&lt; val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSink</span></span></span><span class="hljs-class">&lt;logLevel, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; TSink&lt;logLevel, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (T&amp;&amp; val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> logLevel, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isNull&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> sink_type = TSink&lt;logLevel, isNull&gt;; };</code> </pre> </div></div><br><h5>  <b>And, of course, we will test this cotovasia</b> </h5><br><div class="spoiler">  <b class="spoiler_title">Write testcase</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OUR_LOG_LEVEL = LOG_DEBUG; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TestLog = TLog&lt;OUR_LOG_LEVEL, TLogTraitsStdErr&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CConnection</span></span></span><span class="hljs-class"> {</span></span> CConnection() { TestLog::Log&lt;LOG_NOTICE&gt;() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection created"</span></span>; } ~CConnection() { TestLog::Log&lt;LOG_NOTICE&gt;() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection destroyed"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestLog::Log&lt;LOG_DEBUG&gt;() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection is doing something"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CServer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TestLog { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CServer() { TestLog::Open(<span class="hljs-string"><span class="hljs-string">"test_log"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestLog::Log&lt;LOG_DEBUG&gt;() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Creating connection"</span></span>; CConnection test_conn1; test_conn1.DoSomething(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ CServer server; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.Run(); }</code> </pre> </div></div><br>  Compile and get this output: <br><pre> <code class="hljs vbscript">clang++ -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out std::<span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> opened <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> logName: test_log std::<span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> line flushed: <span class="hljs-string"><span class="hljs-string">"Creating connection "</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> line flushed: <span class="hljs-string"><span class="hljs-string">"connection created "</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> line flushed: <span class="hljs-string"><span class="hljs-string">"connection is doing something "</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> line flushed: <span class="hljs-string"><span class="hljs-string">"connection destroyed "</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">err</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> closed</code> </pre> <br>  And we will play with him on (I do not even know how to call this resource) <a href="http://coliru.stacked-crooked.com/a/33f4df9328b9f614">Coliru</a> <br><br>  As a result, we got 25 lines of the TLog meta-class, and ~ 40 for each specific implementation of log_traits.  And the requirements are fulfilled: a statement that turns off unnecessary logging is done;  simply?  - like yes;  transparent?  - if you read the meta code is not difficult. <br>  Kiss from my point of view. <br>  How about you?  Hi stones 2! <br><br><h4>  <b>Part 2 - Reflection</b> </h4><br><h5>  <b>Expand the CConnection in our testcase</b> </h5><br>  Remember, at the beginning there were interesting buns: <br><blockquote>  TLogHeader &lt;'c', CConnection&gt;, using <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> , knows that CConnection has this: <pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span> = CConnection; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_id; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_id_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_id), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_id&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_name_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_name), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_name&gt;; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m_state; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_state_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_state), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_state&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log_header_param_list_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">m_id_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">m_name_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">m_state_t</span></span>&gt;;</code> </pre></blockquote><br><div class="spoiler">  <b class="spoiler_title">Here is our advanced CConnection</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CConnection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TLogHeader&lt;<span class="hljs-string"><span class="hljs-string">'c'</span></span>, CConnection&gt; { CConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; _name) : m_id(_id), m_name(_name), m_state(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) { TestLog::Log&lt;LOG_NOTICE&gt;() &lt;&lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection created"</span></span>; m_state = <span class="hljs-string"><span class="hljs-string">'b'</span></span>; } ~CConnection() { TestLog::Log&lt;LOG_NOTICE&gt;() &lt;&lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection destroyed"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestLog::Log&lt;LOG_DEBUG&gt;() &lt;&lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"connection is doing something"</span></span>; m_state = <span class="hljs-string"><span class="hljs-string">'c'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span> = CConnection; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_id; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_id_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_id), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_id&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_name_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_name), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_name&gt;; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m_state; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">m_state_t</span></span> = TParamAccessor&lt;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_state), &amp;<span class="hljs-keyword"><span class="hljs-keyword">this_t</span></span>::m_state&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log_header_param_list_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">m_id_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">m_name_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">m_state_t</span></span>&gt;; };</code> </pre> </div></div><br>  Of course, all this can be wrapped in a simple macro, such as PARAM (int, m_id), but we will not for the sanity sake. <br><br>  TParamAccessor is a type in which one static GetRef function is defined, which returns a reference to a class variable. <br><div class="spoiler">  <b class="spoiler_title">So here</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParamAccessorDefaultTraits</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">_object_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _value_type, _value_type <span class="hljs-keyword"><span class="hljs-keyword">_object_t</span></span>::*<span class="hljs-keyword"><span class="hljs-keyword">member_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">_traits_t</span></span> = TParamAccessorDefaultTraits&gt; struct TParamAccessor : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">_traits_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">_object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = _value_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> value_type&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.*<span class="hljs-keyword"><span class="hljs-keyword">member_t</span></span>; } };</code> </pre> </div></div>  Accordingly, in order for us to stuff * this into the sink_type stream, we need to inherit from TLogHeader &lt;'c', CConnection&gt; to iterate inside it by CConnection :: log_header_param_list_t and call sink_type &lt;&lt; TParamAccessor :: GetRef (our object). <br><br>  Warning: it will be a little difficult to understand here until we look at the meta version of for_each <br><br><div class="spoiler">  <b class="spoiler_title">We get the class TLogHeader</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> moduleName, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLogHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLogHeaderWriter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = TLogHeaderWriter&lt;idx, <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">accessor_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; obj, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">stringstream</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>::value_type&amp; val = <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>::GetRef(obj); out &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> sink_type&gt; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> sink_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (sink_type&amp; sink, <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>&amp; val) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> header; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> writers = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> for_each&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">log_header_param_list_t</span></span>&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> instantiate&lt;TLogHeaderWriter&gt;; for_each&lt;writers&gt;::call(*<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>*&gt;(&amp;val), header); sink &lt;&lt; moduleName &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; header.str(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sink; } };</code> </pre> </div></div><br>  TLogHeader describes only one function - an overloaded write statement to a stream. <br>  In which we see for_each in two ways: <br><ol><li>  a meta-function call to determine the type of writers to which all TLogHeaderWriter instances &lt;from object_t :: log_header_param_list_t :: from every type inside&gt; are returned as a tuple;) </li><li>  call the static call function for all types defined in writers </li></ol><br><h5>  <b>Make a "meta-hypostasis" for_each</b> </h5><br><div class="spoiler">  <b class="spoiler_title">To do this, simplify our TLogHeader before calling only the meta-function.</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> moduleName, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLogHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TLogHeaderWriter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = TLogHeaderWriter&lt;idx, <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> sink_type&gt; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> sink_type&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (sink_type&amp; sink, <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>&amp; val) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> writers = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> for_each&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">log_header_param_list_t</span></span>&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> instantiate&lt;TLogHeaderWriter&gt;; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sink; } };</code> </pre> </div></div><br>  And write the meta function. <br>  Disclaimer: because  for simplicity, cut the final code, not tested;  the final one can later be tested live. <br><br>  Just in case, I will clarify: in the most pleasant terminology to me, ‚Äúa meta-function is a function performed at the stage of compiling a program, and the result of which is a new type‚Äù (all in your own words) <br><br>  I will comment on the code, because  further a little confused will go. <br><br><div class="spoiler">  <b class="spoiler_title">For_each code</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ append to tuple /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/-       new_t /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    tuple    template argument pack,       template&lt;typename new_t, typename... other_t&gt; struct append_to_tuple { using type = std::tuple&lt;other_t..., new_t&gt;; }; template&lt;typename new_t, typename... other_t&gt; struct append_to_tuple&lt;new_t, std::tuple&lt;other_t...&gt;&gt; { using type = std::tuple&lt;other_t..., new_t&gt;; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ for_each_impl /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ for_each -  ,   func_t  instatiate, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/,         tuple  append_to_tuple /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,  ,           template&lt;size_t i, typename... args_t&gt; struct for_each_impl { using this_type = typename std::tuple_element&lt;i, std::tuple&lt;args_t...&gt;&gt;::type; using prev_type = for_each_impl&lt;i - 1, args_t...&gt;; template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = typename append_to_tuple&lt; typename func_t&lt;i, this_type&gt;::type, typename prev_type::template instantiate&lt;func_t&gt; &gt;::type; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       template&lt;typename... args_t&gt; struct for_each_impl&lt;0, args_t...&gt; { using this_type = typename std::tuple_element&lt;0, std::tuple&lt;args_t...&gt;&gt;::type; template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = std::tuple&lt;typename func_t&lt;0, this_type&gt;::type&gt;; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ for_each /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  for_each_impl,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ +     tuple&lt; &gt;  tuple&lt;&gt;   template&lt;typename... args_t&gt; struct for_each { using prev_type = for_each_impl&lt;sizeof...(args_t) - 1, args_t...&gt;; template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = typename prev_type::template instantiate&lt;func_t&gt;; }; template&lt;typename... args_t&gt; struct for_each&lt;std::tuple&lt;args_t...&gt;&gt; : public for_each&lt;args_t...&gt; { }; template&lt;&gt; struct for_each&lt;std::tuple&lt;&gt;&gt; { template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = std::tuple&lt;&gt;; };</span></span></code> </pre> </div></div><br>  Thus, we have obtained using writers = typename for_each &lt;typename object_t :: log_header_param_list_t&gt; :: template instantiate;  where writers will unfold in: <br><pre> <code class="hljs ruby">std::tuple&lt; TLogHeaderWriter&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, TParamAccessor&lt;CConnection, decltype(CConnection::m_id), &amp;CConnection::m_id<span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>, TLogHeaderWriter&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, TParamAccessor&lt;CConnection, decltype(CConnection::m_name), &amp;CConnection::m_name&gt;&gt;, TLogHeaderWriter&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>, TParamAccessor&lt;CConnection, decltype(CConnection::m_state), &amp;CConnection::m_state&gt;&gt; &gt;;</code> </pre><br>  It remains to go through these types, and call GetRef with the subsequent entry into the stream. <br><br><h5>  <b>Let's make a ‚Äúrun-time-hypostasis‚Äù for_each</b> </h5><br>  And at once we will look at the extended for_each, to which the calls of the static call function are added (only it is worth paying attention to, the rest is unchanged) <br><div class="spoiler">  <b class="spoiler_title">And here it is - the last piece of code</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ for_each_impl template&lt;size_t i, typename... args_t&gt; struct for_each_impl { using this_type = typename std::tuple_element&lt;i, std::tuple&lt;args_t...&gt;&gt;::type; using prev_type = for_each_impl&lt;i - 1, args_t...&gt;; template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = typename append_to_tuple&lt; typename func_t&lt;i, this_type&gt;::type, typename prev_type::template instantiate&lt;func_t&gt; &gt;::type; template&lt;typename object_t, typename... call_args_t&gt; static void call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { prev_type::call(std::forward&lt;object_t&gt;(obj), std::forward&lt;call_args_t&gt;(args)...); this_type::call(std::forward&lt;object_t&gt;(obj), std::forward&lt;call_args_t&gt;(args)...); } }; template&lt;typename... args_t&gt; struct for_each_impl&lt;0, args_t...&gt; { using this_type = typename std::tuple_element&lt;0, std::tuple&lt;args_t...&gt;&gt;::type; template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = std::tuple&lt;typename func_t&lt;0, this_type&gt;::type&gt;; template&lt;typename object_t, typename... call_args_t&gt; static void call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { this_type::call(std::forward&lt;object_t&gt;(obj), std::forward&lt;call_args_t&gt;(args)...); } template&lt;typename object_t&gt; static void call(object_t&amp;&amp; obj) { this_type::call(std::forward&lt;object_t&gt;(obj)); } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ for_each template&lt;typename... args_t&gt; struct for_each { using prev_type = for_each_impl&lt;sizeof...(args_t) - 1, args_t...&gt;; template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = typename prev_type::template instantiate&lt;func_t&gt;; template&lt;typename object_t, typename... call_args_t&gt; static object_t call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { prev_type::call(std::forward&lt;object_t&gt;(obj), std::forward&lt;call_args_t&gt;(args)...); return obj; } template&lt;typename object_t&gt; static object_t call(object_t&amp;&amp; obj) { prev_type::call(std::forward&lt;object_t&gt;(obj)); return obj; } }; template&lt;typename... args_t&gt; struct for_each&lt;std::tuple&lt;args_t...&gt;&gt; : public for_each&lt;args_t...&gt; { }; template&lt;&gt; struct for_each&lt;std::tuple&lt;&gt;&gt; { template&lt;template&lt;size_t, typename&gt; class func_t&gt; using instantiate = std::tuple&lt;&gt;; template&lt;typename object_t, typename... call_args_t&gt; static object_t call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { return obj; } template&lt;typename object_t&gt; static object_t call(object_t&amp;&amp; obj) { return obj; } };</span></span></code> </pre> </div></div><br>  I think it‚Äôs not necessary to comment here: call receives at least one parameter on the input, which is our proxy object, and which is returned at the end of the work - the other parameters are forwarded to call calls. <br>  In our case, this is TLogHeaderWirter :: call: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">accessor_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; obj, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">stringstream</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>::value_type&amp; val = <span class="hljs-keyword"><span class="hljs-keyword">accessor_t</span></span>::GetRef(obj); out &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span>; }</code> </pre>  Where accessor_t :: object_t = CConnection <br>  And, of course, perfect forwarding is a thing! <br><br><h4>  <b>Part 3 - Conclusion</b> </h4><br><div class="spoiler">  <b class="spoiler_title">All code in its entirety</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span></span><span class="hljs-meta"> static const int OUR_LOG_LEVEL = LOG_DEBUG; // = LOG_NOTICE; // log up to LOG_DEBUG output: //std::err log opened with logName: test_log //std::err log line flushed: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s:1:test server:Creating connection "</span></span></span><span class="hljs-meta"> //std::err log line flushed: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c:23:test_conn 1:a:connection created "</span></span></span><span class="hljs-meta"> //std::err log line flushed: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c:23:test_conn 1:b:connection is doing something "</span></span></span><span class="hljs-meta"> //std::err log line flushed: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c:23:test_conn 1:c:connection destroyed "</span></span></span><span class="hljs-meta"> //std::err log closed // log up to LOG_NOTICE output: //std::err log opened with logName: test_log //std::err log line flushed: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c:23:test_conn 1:a:connection created "</span></span></span><span class="hljs-meta"> //std::err log line flushed: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c:23:test_conn 1:c:connection destroyed "</span></span></span><span class="hljs-meta"> //std::err log closed // ---------------------------- for_each.h start ----------------------------// #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tuple&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt;</span></span></span><span class="hljs-meta"> namespace helpers { //////////////////////////////////////////////////////////////// // param accessor struct TParamAccessorDefaultTraits { }; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename _object_t, typename _value_type, _value_type _object_t::*member_t, typename _traits_t = TParamAccessorDefaultTraits&gt;</span></span></span><span class="hljs-meta"> struct TParamAccessor : public _traits_t { using traits_t = _traits_t; using object_t = _object_t; using value_type = _value_type; static value_type&amp; GetRef(object_t&amp; data) { return data.*member_t; } }; //////////////////////////////////////////////////////////////// // append to tuple template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename new_t, typename... other_t&gt;</span></span></span><span class="hljs-meta"> struct append_to_tuple { using type = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;other_t..., new_t&gt;</span></span></span><span class="hljs-meta">; }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename new_t, typename... other_t&gt;</span></span></span><span class="hljs-meta"> struct append_to_tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;new_t, std::tuple&lt;other_t...&gt;</span></span></span><span class="hljs-meta">&gt; { using type = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;other_t..., new_t&gt;</span></span></span><span class="hljs-meta">; }; //////////////////////////////////////////////////////////////// // for_each_impl template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;size_t i, typename... args_t&gt;</span></span></span><span class="hljs-meta"> struct for_each_impl { using this_type = typename std::tuple_element</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;i, std::tuple&lt;args_t...&gt;</span></span></span><span class="hljs-meta">&gt;::type; using prev_type = for_each_impl</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;i - 1, args_t...&gt;</span></span></span><span class="hljs-meta">; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;size_t, typename&gt;</span></span></span><span class="hljs-meta"> class func_t&gt; using instantiate = typename append_to_tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; typename func_t&lt;i, this_type&gt;</span></span></span><span class="hljs-meta">::type, typename prev_type::template instantiate</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;func_t&gt;</span></span></span><span class="hljs-meta"> &gt;::type; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t, typename... call_args_t&gt;</span></span></span><span class="hljs-meta"> static void call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { prev_type::call(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t&gt;</span></span></span><span class="hljs-meta">(obj), std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;call_args_t&gt;</span></span></span><span class="hljs-meta">(args)...); this_type::call(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t&gt;</span></span></span><span class="hljs-meta">(obj), std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;call_args_t&gt;</span></span></span><span class="hljs-meta">(args)...); } }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename... args_t&gt;</span></span></span><span class="hljs-meta"> struct for_each_impl</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0, args_t...&gt;</span></span></span><span class="hljs-meta"> { using this_type = typename std::tuple_element</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0, std::tuple&lt;args_t...&gt;</span></span></span><span class="hljs-meta">&gt;::type; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;size_t, typename&gt;</span></span></span><span class="hljs-meta"> class func_t&gt; using instantiate = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename func_t&lt;0, this_type&gt;</span></span></span><span class="hljs-meta">::type&gt;; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t, typename... call_args_t&gt;</span></span></span><span class="hljs-meta"> static void call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { this_type::call(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t&gt;</span></span></span><span class="hljs-meta">(obj), std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;call_args_t&gt;</span></span></span><span class="hljs-meta">(args)...); } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t&gt;</span></span></span><span class="hljs-meta"> static void call(object_t&amp;&amp; obj) { this_type::call(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t&gt;</span></span></span><span class="hljs-meta">(obj)); } }; /////////////////////////////////////////////////////////////// // for_each template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename... args_t&gt;</span></span></span><span class="hljs-meta"> struct for_each { using prev_type = for_each_impl</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sizeof...(args_t) - 1, args_t...&gt;</span></span></span><span class="hljs-meta">; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;size_t, typename&gt;</span></span></span><span class="hljs-meta"> class func_t&gt; using instantiate = typename prev_type::template instantiate</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;func_t&gt;</span></span></span><span class="hljs-meta">; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t, typename... call_args_t&gt;</span></span></span><span class="hljs-meta"> static object_t call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { prev_type::call(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t&gt;</span></span></span><span class="hljs-meta">(obj), std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;call_args_t&gt;</span></span></span><span class="hljs-meta">(args)...); return obj; } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t&gt;</span></span></span><span class="hljs-meta"> static object_t call(object_t&amp;&amp; obj) { prev_type::call(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t&gt;</span></span></span><span class="hljs-meta">(obj)); return obj; } }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename... args_t&gt;</span></span></span><span class="hljs-meta"> struct for_each</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;std::tuple&lt;args_t...&gt;</span></span></span><span class="hljs-meta">&gt; : public for_each</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;args_t...&gt;</span></span></span><span class="hljs-meta"> { }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt;</span></span></span><span class="hljs-meta"> struct for_each</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;std::tuple&lt;&gt;</span></span></span><span class="hljs-meta">&gt; { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;template&lt;size_t, typename&gt;</span></span></span><span class="hljs-meta"> class func_t&gt; using instantiate = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt;</span></span></span><span class="hljs-meta">; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t, typename... call_args_t&gt;</span></span></span><span class="hljs-meta"> static object_t call(object_t&amp;&amp; obj, call_args_t&amp;&amp;... args) { return obj; } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename object_t&gt;</span></span></span><span class="hljs-meta"> static object_t call(object_t&amp;&amp; obj) { return obj; } }; } //namespace helpers // ---------------------------- for_each.h end ----------------------------// using namespace helpers; ////////////////////////////////////////////////////////////////////////////////////////// template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int logUpTo&gt;</span></span></span><span class="hljs-meta"> struct TLogTraitsStdErr { static void Open(const char* logName, int facility) { std::cerr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "std::err log opened with logName: " &lt;&lt; logName &lt;&lt; std::endl; } ~TLogTraitsStdErr() { std::cerr &lt;&lt; "std::err log closed" &lt;&lt; std::endl; } template&lt;int logLevel, bool isNull&gt;</span></span></span><span class="hljs-meta"> struct TSink { ~TSink() { std::cerr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "std::err log line flushed: \"" &lt;&lt; stream.str() &lt;&lt; " \"" &lt;&lt; std::endl; } std::stringstream stream; template&lt;typename T&gt;</span></span></span><span class="hljs-meta"> TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, isNull&gt;</span></span></span><span class="hljs-meta">&amp; operator </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (T&amp;&amp; val) { stream &lt;&lt; val; return *this; } }; template&lt;int logLevel&gt;</span></span></span><span class="hljs-meta"> struct TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, true&gt;</span></span></span><span class="hljs-meta"> { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt;</span></span></span><span class="hljs-meta"> TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, true&gt;</span></span></span><span class="hljs-meta">&amp; operator </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (T&amp;&amp; val) { return *this; } }; template&lt;int logLevel, bool isNull&gt;</span></span></span><span class="hljs-meta"> using sink_type = TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, isNull&gt;</span></span></span><span class="hljs-meta">; }; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int logUpTo&gt;</span></span></span><span class="hljs-meta"> struct TLogTraitsSyslog { static void Open(const char* logName, int facility) { openlog(logName, LOG_PID | LOG_NDELAY, facility); setlogmask(LOG_UPTO(logUpTo)); } ~TLogTraitsSyslog() { closelog(); } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int logLevel, bool isNull&gt;</span></span></span><span class="hljs-meta"> struct TSink { ~TSink() { syslog(logLevel, stream.str().c_str(), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"junk"</span></span></span><span class="hljs-meta">); } std::stringstream stream; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt;</span></span></span><span class="hljs-meta"> TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, isNull&gt;</span></span></span><span class="hljs-meta">&amp; operator </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (T&amp;&amp; val) { stream &lt;&lt; val; return *this; } }; template&lt;int logLevel&gt;</span></span></span><span class="hljs-meta"> struct TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, true&gt;</span></span></span><span class="hljs-meta"> { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt;</span></span></span><span class="hljs-meta"> TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, true&gt;</span></span></span><span class="hljs-meta">&amp; operator </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (T&amp;&amp; val) { return *this; } }; template&lt;int logLevel, bool isNull&gt;</span></span></span><span class="hljs-meta"> using sink_type = TSink</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, isNull&gt;</span></span></span><span class="hljs-meta">; }; ////////////////////////////////////////////////////////////////////////////////////////// template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;char moduleName, typename object_t&gt;</span></span></span><span class="hljs-meta"> struct TLogHeader { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;size_t idx, typename accessor_t&gt;</span></span></span><span class="hljs-meta"> struct TLogHeaderWriter { using type = TLogHeaderWriter</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idx, accessor_t&gt;</span></span></span><span class="hljs-meta">; static void call(typename accessor_t::object_t&amp; obj, std::stringstream&amp; out) { typename accessor_t::value_type&amp; val = accessor_t::GetRef(obj); out </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; val &lt;&lt; ":"; } }; template&lt;typename sink_type&gt;</span></span></span><span class="hljs-meta"> friend sink_type&amp; operator </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (sink_type&amp; sink, object_t&amp; val) { std::stringstream header; using writers = typename for_each&lt;typename object_t::log_header_param_list_t&gt;</span></span></span><span class="hljs-meta">::template instantiate</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;TLogHeaderWriter&gt;</span></span></span><span class="hljs-meta">; for_each</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;writers&gt;</span></span></span><span class="hljs-meta">::call(*static_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;object_t*&gt;</span></span></span><span class="hljs-meta">(&amp;val), header); sink </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; moduleName &lt;&lt; ":" &lt;&lt; header.str(); return sink; } }; ////////////////////////////////////////////////////////////////////////////////////////// template&lt;int logUpTo, template&lt;int&gt;</span></span></span><span class="hljs-meta"> class log_traits = TLogTraitsSyslog&gt; struct TLog : public log_traits</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logUpTo&gt;</span></span></span><span class="hljs-meta"> { using trats_t = log_traits</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logUpTo&gt;</span></span></span><span class="hljs-meta">; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int logLevel, bool isNull&gt;</span></span></span><span class="hljs-meta"> using sink_type = typename trats_t::template sink_type</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;logLevel, isNull&gt;</span></span></span><span class="hljs-meta">; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int neededLogLevel, int logLevel&gt;</span></span></span><span class="hljs-meta"> struct TGetLogOfLevel { using type = typename std::conditional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; neededLogLevel == logLevel, sink_type&lt;neededLogLevel, (neededLogLevel &gt;</span></span></span><span class="hljs-meta"> logUpTo)&gt;, typename TGetLogOfLevel</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;neededLogLevel, logLevel + 1&gt;</span></span></span><span class="hljs-meta">::type &gt;::type; }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int neededLogLevel&gt;</span></span></span><span class="hljs-meta"> struct TGetLogOfLevel</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;neededLogLevel, LOG_DEBUG + 1&gt;</span></span></span><span class="hljs-meta"> { using type = void; }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int neededLogLevel&gt;</span></span></span><span class="hljs-meta"> using Log = typename TGetLogOfLevel</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;neededLogLevel, 0&gt;</span></span></span><span class="hljs-meta">::type; }; /////////////////////////////// //testcase using TestLog = TLog</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;OUR_LOG_LEVEL, TLogTraitsStdErr&gt;</span></span></span><span class="hljs-meta">; struct CConnection : public TLogHeader</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;'c', CConnection&gt;</span></span></span><span class="hljs-meta"> { CConnection(int _id, const std::string&amp; _name) : m_id(_id), m_name(_name), m_state('a') { TestLog::Log</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LOG_NOTICE&gt;</span></span></span><span class="hljs-meta">() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; *this &lt;&lt; "connection created"; m_state = 'b'; } ~CConnection() { TestLog::Log&lt;LOG_NOTICE&gt;</span></span></span><span class="hljs-meta">() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; *this &lt;&lt; "connection destroyed"; } void DoSomething() { TestLog::Log&lt;LOG_DEBUG&gt;</span></span></span><span class="hljs-meta">() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; *this &lt;&lt; "connection is doing something"; m_state = 'c'; } using this_t = CConnection; int m_id; using m_id_t = TParamAccessor&lt;this_t, decltype(this_t::m_id), &amp;this_t::m_id&gt;</span></span></span><span class="hljs-meta">; std::string m_name; using m_name_t = TParamAccessor</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;this_t, decltype(this_t::m_name), &amp;this_t::m_name&gt;</span></span></span><span class="hljs-meta">; char m_state; using m_state_t = TParamAccessor</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;this_t, decltype(this_t::m_state), &amp;this_t::m_state&gt;</span></span></span><span class="hljs-meta">; using log_header_param_list_t = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;m_id_t, m_name_t, m_state_t&gt;</span></span></span><span class="hljs-meta">; }; class CServer : public TLogHeader</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;'s', CServer&gt;</span></span></span><span class="hljs-meta">, public TestLog { public: CServer() : m_id(1), m_name(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test server"</span></span></span><span class="hljs-meta">) { TestLog::Open(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test_log"</span></span></span><span class="hljs-meta">, 1); }; int Run() { TestLog::Log</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LOG_DEBUG&gt;</span></span></span><span class="hljs-meta">() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; *this &lt;&lt; "Creating connection"; CConnection test_conn1(23, "test_conn 1"); test_conn1.DoSomething(); return 0; } using this_t = CServer; int m_id; using m_id_t = TParamAccessor&lt;this_t, decltype(this_t::m_id), &amp;this_t::m_id&gt;</span></span></span><span class="hljs-meta">; std::string m_name; using m_name_t = TParamAccessor</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;this_t, decltype(this_t::m_name), &amp;this_t::m_name&gt;</span></span></span><span class="hljs-meta">; using log_header_param_list_t = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;m_id_t, m_name_t&gt;</span></span></span><span class="hljs-meta"> ; }; int main(int argc, char** argv) { CServer server; return server.Run(); }</span></span></code> </pre> </div></div><br> <a href="http://coliru.stacked-crooked.com/a/0a99b0343302df5b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a finished example. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In it, we have added another 100 lines of implementation of 2 options for_each. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, if you looked at the example, you can see that they are in a separate file for_each.h</font></font><br>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I actively use it already in 5 modules of my history, such as: the native binary format of communication with postgres given the endianess of the end systems, the unfolding of packets from the buffers and the generation of the format of messages on the web socket at the compilation stage, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And as already said: Stones! </font><font style="vertical-align: inherit;">Welcome! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Code writing took half a day, and the article on Habr Day ... paradox!</font></font></div><p>Source: <a href="https://habr.com/ru/post/243571/">https://habr.com/ru/post/243571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243561/index.html">How the cloud makes life easier for startups</a></li>
<li><a href="../243563/index.html">Theoretical minimum * nix-based-systems for WebDev-padawan</a></li>
<li><a href="../243565/index.html">Using RequireJS in AngularJS Applications</a></li>
<li><a href="../243567/index.html">Ciklum iOS Practice Leaders Meet-Up // Architecture in iOS, Dnepropetrovsk, November 20</a></li>
<li><a href="../243569/index.html">A few words about caching data when reading and smartpoint</a></li>
<li><a href="../243573/index.html">Check your website availability from Africa</a></li>
<li><a href="../243577/index.html">IBM launches a joint master‚Äôs program in the field of Big Data with leading Russian universities</a></li>
<li><a href="../243579/index.html">Eskimo - Node.js boilerplate to create prototypes</a></li>
<li><a href="../243581/index.html">Literal operator templates for strings</a></li>
<li><a href="../243585/index.html">Apple released iOS 8.1.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>