<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Self-modifying code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes in detail about the self-modifying code (QMS), and how to use it in their programs. Examples are written in C ++ using inline as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Self-modifying code</h1><div class="post__text post__text-html js-mediator-article">  The article describes in detail about the self-modifying code (QMS), and how to use it in their programs.  Examples are written in C ++ using inline assembly.  I will also tell you how to execute code on a stack, which is an essential trump when writing and executing a QMS. <br><br> <a href="http://habrahabr.ru/post/272619/"><img src="https://habrastorage.org/files/613/3b0/ab9/6133b0ab9f0b4f368aa49f5712a7b8ae.jpg"></a> <br><br><h3>  1. Introduction </h3><br>  Well, let's go.  The article promises to be long, as I want to write it so that you do not have any questions.  There are already a million articles on the QMS topic, but here is my vision of the problem - after hundreds of hours of writing the QMS ... I will try to shove all my labors here.  Everything, grab tomato juice (or whatever you prefer to drink there), make the music louder and get ready to learn how to save your application from beginners!  Along the way, I will tell you about Windows memory and some other things that you don‚Äôt even suspect. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><h3>  2. A brief history of self-modifying code </h3><br>  More recently, programmers had the luxury of using self-modifying code wherever they please.  10-20 years ago, all more or less serious attempts to protect programs used the QMS (self-modifying code).  Even some compilers used QMS, operating with code in memory. <br><br>  Then in the mid-90s something happened.  This is something called Windows 95 / NT.  Suddenly, we, the programmers, were given to understand that everything that we did before is bullshit, and we have to master a new platform.  All the previously invented tricks could be forgotten, because now we could no longer play without demand with memory, hardware and the operating system.  Most people thought that the writing of the QMS would no longer be possible without the use of VxD, for which, which is typical for Windows, there was no more or less competent documentation.  After some time, it was discovered that we still CAN use the QMS in our programs.  One way is to use the WriteProcessMemory function exported by the Kernel32 library, the other is to place the code on the stack and then modify it. <br><br>  The rest of the article is mainly devoted to Microsoft Visual C ++ and 32-bit subsystem. <br><br><br><h3>  3. Windows memory as it is </h3><br>  Creating a QMS in Windows is not as easy as we would like.  Here you will have to face some of the pitfalls, carefully laid out by the creators of Windows.  Why?  Yes, because it is Microsoft. <br><br>  As you know, Windows allocates 4 gigabytes of virtual memory for each process.  For addressing this memory, two selectors are used in Windows.  One is loaded into the CS segment register, and the other is thrown into the DS, SS, and ES registers.  They all use the same base address (equal to 0) and are limited to 4 gigabytes of space. <br><br>  The program can only have ONE segment containing both code and data, as well as ONE process stack.  You can use the NEAR procedure call or the transition to the control code located on the stack.  In the latter case, you should not use SS to access the stack.  Although the value of the CS register does not match DS, SS and ES, the commands MOV dest, CS: [src], MOV dest, DS: [src] and MOV dest, SS: [src] access the same memory location. <br><br>  The memory areas (pages) containing data, code and stack may have some attributes.  For example, in code pages, read and execute are allowed, in data pages, read and write are allowed, and in the stack, read, write, and execute simultaneously. <br><br>  Also, these pages may have a number of security attributes.  I will talk about them a little later when we need them. <br><br><br><h3>  4. WriteProcessMemory - new best friend </h3><br>  The easiest way to change a few bytes in the process (in my opinion) is to use the WriteProcessMemory function (if the protection flags are not set). <br><br>  The first thing to do for this is to access the process loaded into memory using the OpenProcess function with the PROCESS_VM_OPERATION and PROCESS_VM_WRITE access attributes.  Below is an example of the simplest QMS, which we will talk about.  In C ++, to implement this mechanism, we need some built-in features of the language.  Of course, all this can be done in other languages, but only about this we'll talk some other time.  In addition, in other languages ‚Äã‚Äãit all looks much more complicated. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 1. WriteProcessMemory in the QMS service</b> <div class="spoiler_text"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wb)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE h=OpenProcess(PROCESS_VM_OPERATION| PROCESS_VM_WRITE, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, GetCurrentProcessId()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WriteProcessMemory(h, addr, &amp;wb, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ _asm { push <span class="hljs-number"><span class="hljs-number">0x74</span></span> ; JMP &gt;&gt; JZ push offset Here call WriteMe add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> Here: JMP <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> Here } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Holy Sh^&amp; OsIX, it worked! #JMP SHORT $2 was changed to JZ $2n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br>  As you can see, the program replaces an infinite loop with a simple transition JZ.  This allows the program to proceed to the next instruction, and we see a message confirming the replacement.  Great, huh?  I bet you are thinking now ... hmm, interesting, but could I do something like that?  Probably yes! <br><br>  However, this method (using WriteProcessMemory) has a number of vulnerabilities.  First of all, an experienced cracker WILL analyze the import table and detect a suspicious function.  He will most likely put a few breakpoints on this challenge, analyze the code next to him and find what he needs.  Because the use of WriteProcessMemory is typical only for compilers that collect code in memory, or for unpackers of executable files.  At the same time, with such a trick, you are free to confound the novice cracker.  I often use this technique in my programs. <br><br>  Another WriteProcessMemory sax is the impossibility of creating new pages in memory.  The trick with this feature works only on existing pages.  Therefore, although there are several ways to bring the application of this function to mind, we will turn our attention to executing code on the stack. <br><br><br><h3>  5. Placing the code on the stack, and its execution! </h3><br>  Placing code on the stack is not only permissible, but sometimes even necessary.  In particular, this makes life easier for compilers, allowing them to generate code on the fly.  But will not such liberties with the stack put the security of the system at risk?  By itself, they can bring trouble on your ass.  In addition, this is not the best technology for your programs, because installing a patch that prohibits execution of code on the stack, paralyzes the work of most of your creations.  On the other hand, although there is such a patch, in particular for Linux, for Solaris, and although it is very useful, I think that it is installed only by two people (the authors themselves, hee-hee). <br><br>  Do you still remember the WriteProcessMemory vulnerabilities mentioned above?  The trick with placing the executable code on the stack gives us two pleasant possibilities for eliminating them.  First, the instructions that modify the code are located in an unknown area of ‚Äã‚Äãmemory, and therefore it is almost impossible for the cracker to track them.  In order to analyze the protected code, it will have to cut the tree of our program right under the butt, so most likely its work will not be crowned with great success!  Another argument in favor of executing code on the stack is that at any time the program can allocate as much memory as needed, and at any time can release it.  By default, the operating system allocates 1 MB of memory for the stack.  If the task performed requires more memory, the program may request an additional quota. <br><br>  However, there are several nuances that you need to know before placing your code on the stack ... Therefore, we will talk about them now. <br><br><br><h3>  6. Why movable code can be harmful to your health. </h3><br>  You should be aware that Windows 9x, Windows NT and Windows 2k have a stack in different places.  Therefore, in order for your program to be cross-platform, it is important to use relative addressing.  Implement this requirement is not so difficult, for this all you need to follow a few simple rules - damn them, these rules! <br><br>  To our great joy, in the world of 80x86 all short-jumps and nir-kals are relative.  This means that you do not need to use linear addresses, but you must use the difference between the target address and the address of the next program guide.  Such relative addressing will greatly simplify our lives, but even it has its limitations. <br><br>  For example, what happens if the void OSIXDemo () {printf ("Hi from OSIXn");} function is copied to the stack and then called?  Such a call is likely to lead to an error, since the address of the printf has changed. <br><br>  In assembler, through the address register, we can easily fix this problem.  The relocatable call to the printf function can be implemented very simply, for example, LEA EAX, printfNCALL EAX.  Now the ABSOLUTE linear address, - not relative, - is placed in the register EAX.  Therefore, it does not matter where the printf function is called from ‚Äî it will work correctly. <br><br>  To reproduce such tricks, it is necessary for your compiler to support assembly inserts.  I know that if you are not interested in low-level programming, for you this is a complete sax, but you can do exactly the same thing by limiting yourself to the arsenal provided by high-level languages.  Here is a simple example: <br><br><div class="spoiler">  <b class="spoiler_title">Listing 2. How to copy a function to the stack and run it there</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*_printf) (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *,...))</span></span></span><span class="hljs-function"> </span></span>{ _printf(<span class="hljs-string"><span class="hljs-string">"Hello, OSIX!n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*_printf) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*_main) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*_Demo) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...)); _printf=<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> func_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) _main  (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) _Demo; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;func_len; a++) buff[a] = ((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) _Demo)[a]; _Demo = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...))) &amp;buff[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _Demo(_printf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  So do not let anyone hang their noodles on their ears, that high-level languages ‚Äã‚Äãdo not allow to execute code on the stack. <br><br><br><h3>  7. We start optimization right now! </h3><br>  If you plan to write QMS or use the code executed on the stack, then you need to seriously approach the choice of the compiler, and learn the features of its work.  Most likely, your code will collapse with an error when you first access it from the program, especially if your compiler is set to ‚Äúoptimization‚Äù mode. <br><br>  Why it happens?  Because in such purely high-level programming languages ‚Äã‚Äãlike C or Pascal, it's extremely damn hard to copy function code to the stack or anywhere else.  The programmer has the opportunity to get a pointer to a function, but at the same time, there are no rules standardizing its use.  Among programmers, this is called the "magic number", which is known only to the compiler. <br><br>  Fortunately, almost all compilers use the same logic when generating code.  This is a kind of unwritten code compilation rules.  Therefore, the programmer can also use them. <br><br>  Let's take another look at Listing 2. We rightly assume that the pointer to our Demo () function coincides with its beginning, and that the function body is located immediately after the beginning of this function.  Most compilers adhere to this "common sense compilation", but do not expect that all of them follow this.  At least, the big guys (VC ++, Borland, etc.) still adhere to this rule.  Therefore, if you do not use any unknown or new compiler, do not worry about the lack of ‚Äúcommon sense compiling‚Äù.  One note about VC ++: if you are working in debug mode, the compiler inserts a kind of "adapter" and places the function in a different place.  Damn Microsoft.  But do not worry, just make sure that the settings are set to the ‚ÄúLink Incrementally‚Äù flag, which will force your compiler to generate good code.  If your compiler does not have such an option, you can either not use the QMS, or use another compiler! <br><br>  Another problem is determining the length of the function.  To do this, there is a simple and reliable trick.  In C ++, the sizeof instruction returns the size of a function pointer, not the size of the function itself.  However, as a rule, compilers allocate memory for objects, in accordance with the order in which they appear in the source code.  So ... the size of the function is the difference between the pointer to the function and the pointer to the function following it.  Very simple!  Remember this trick, it will be useful to you, even though optimizing compilers will NOT follow these rules, and therefore the method that I just described will not work.  See why optimizing compilers are so bad for your health if you write QMS?!?!? <br><br>  Another thing that optimizing compilers do is to delete variables that, as they THINK, are not used.  Returning to our example in Listing 2, we see that some value is written to the buff buffer, but nothing is READ from there.  Most compilers are unable to recognize the fact that control has been transferred to the buffer, so they remove the instructions that copy the code to the buffer.  Bastards!  That is why control is transferred to an uninitialized buffer, and then ... boom.  Collapse.  If there is such a problem, uncheck the box with ‚ÄúGlobal optimization‚Äù and everything will be fine. <br><br>  If your program still does not work, do not give up.  The likely reason is that the compiler at the end of each function inserts subroutine calls that control the stack.  This is what Microsoft VC ++ does.  It adds __chkesp function calls to debug projects.  Do not bother to search for the description of this function, it is not in the documentation!  This call is relative, and there is no way to exclude it.  However, in the final project, VC ++ checks the state of the stack upon exiting the function, so your program will run like a clock. <br><br><br><h3>  8. QMS in your own programs </h3><br>  So, finally the time has come for what you have all been waiting for.  If you have come all this great way described in the article, I greet you.  (loud applause) <br><br>  Well, now you can ask yourself (or ask me) "What are the benefits of executing code (function) on the stack?"  In response, the crowd says: Ahhhhhhhhhhhh. <br><br>  Encrypted code is such a big pain in the ass of a cracker engaged in disassembling.  Of course, using the debugger, it makes life a little easier, but still the encrypted code makes his / her life incredibly difficult. <br><br>  For example, the simplest encryption algorithm that consistently applies an exclusive OR (XOR) operation to each line of code and which when reused restores the original code! <br><br>  Here is an example that reads the contents of our Demo () function, encrypts it, and writes the result to a file. <br><br><div class="spoiler">  <b class="spoiler_title">Listing 3. How to encrypt the Demo function</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _bild() { FILE *f; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*_Demo) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...)); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*_Bild) (); _Demo=Demo; _Bild=_bild; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> func_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) _Bild  (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) _Demo; f=fopen(<span class="hljs-string"><span class="hljs-string">"Demo32.bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;func_len; a++) fputc(((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) buff[a]) ^ <span class="hljs-number"><span class="hljs-number">0x77</span></span>, f); fclose(f); }</code> </pre></div></div><br>  The result of the encryption is placed in a string variable.  Now the Demo () function can be removed from the source code.  Later, when we need it, it can be decrypted, copied to a local buffer and called for execution.  Kick in the ass, huh? <br><br>  Here is an example of the implementation of this algorithm: <br><br><div class="spoiler">  <b class="spoiler_title">Listing 4. Encrypted program</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*_printf) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*_Demo) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...)); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> code[]=<span class="hljs-string"><span class="hljs-string">"x22xFCx9BxF4x9Bx67xB1x32x87 x3FxB1x32x86x12xB1x32x85x1BxB1 x32x84x1BxB1x32x83x18xB1x32x82 x5BxB1x32x81x57xB1x32x80x20xB1 x32x8Fx18xB1x32x8Ex05xB1x32x8D x1BxB1x32x8Cx13xB1x32x8Bx56xB1 x32x8Ax7DxB1x32x89x77xFAx32x87 x27x88x22x7FxF4xB3x73xFCx92x2A xB4"</span></span>; _printf=<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code_size=<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(&amp;code[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(&amp;buff[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;code[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>; a&lt;code_size; a++) buff[a] = buff[a] ^ <span class="hljs-number"><span class="hljs-number">0x77</span></span>; _Demo = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*) (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *,...))) &amp;buff[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _Demo(_printf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br>  Notice that the printf () function displays the greeting.  At a quick glance you will not notice anything unusual, but you look where the string "Hello, OSIX!" Is located.  It has no place in the code segment (although Borland places lines there for some reason), by checking the data segment, you will see that it is where it should be. <br><br>  Now, even if the source code is in front of the cracker's eyes, for him our program will still remain one of the hellish puzzles.  I use this method to hide ‚Äúsecret‚Äù information (serial numbers and keys for my programs, etc.). <br><br>  If you are going to use this method to check the serial number, the verification needs to be organized in such a way that even when decrypted, the cracker puzzle remains.  I will show how to do this in the following listing. <br><br>  Remember, when implementing a QMS, you need to know the EXACT location of the bytes that you are going to change.  Therefore, instead of high-level languages, you should use assembler.  Come on, stay with me, we are almost done! <br><br>  When using the assembler in the implementation of the above method, there is one problem.  To change any byte using the MOV instruction, you must pass the ABSOLUTE linear address as a parameter (which, you guessed it, it was UNKNOWN before compilation).  BUT ... we can get this information during the execution of the program.  CALL $ + 5 / POP REG / MOV [reg + relative_address], xx - code that is very popular among me.  It works as follows.  As a result of the execution of the CALL instruction, the address (or the absolute address of this instruction) remains on the stack.  This address is used as the base for addressing the code of the stack function. <br><br>  And here is an example of verification of the serial number, which I promised you ... <br><br><div class="spoiler">  <b class="spoiler_title">Listing 5. Generating a serial number and executing on the stack</b> <div class="spoiler_text"><pre> <code class="hljs vhdl">MyFunc: push esi ;   ESI   mov esi, [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; ESI = &amp;username[<span class="hljs-number"><span class="hljs-number">0</span></span>] push ebx ;      push ecx push edx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, eax ;    <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> edx, edx RepeatString: ;     Lodsb ;     AL test al, al ;   ? jz short <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> ;  ,   <span class="hljs-number"><span class="hljs-number">1</span></span>     ;   ,     ,   ; ()    ,   <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span> mov ecx, <span class="hljs-number"><span class="hljs-number">21</span></span>h RepeatChar: <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> edx, eax ;   <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span>  ADC <span class="hljs-keyword"><span class="hljs-keyword">ror</span></span> eax, <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rol</span></span> edx, <span class="hljs-number"><span class="hljs-number">5</span></span> call $+<span class="hljs-number"><span class="hljs-number">5</span></span> ; EBX = EIP pop ebx ; / <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> byte ptr [ebx0Dh], <span class="hljs-number"><span class="hljs-number">26</span></span>h; ;     ;  <span class="hljs-keyword"><span class="hljs-keyword">XOR</span></span>  ADC. <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> RepeatChar jmp short RepeatString <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>: xchg eax, edx ;   (.)  EAX pop edx ;   pop ecx pop ebx pop esi retn ;   </code> </pre></div></div><br>  This code looks rather strange, since its repeated calls, when passing the same arguments, either yield the same output or completely different results!  It depends on the length of the username.  If it is odd, the XOR is replaced by the ADC when exiting the function.  Otherwise, nothing like this happens! <br><br>  Well, that's all for now.  I hope this article has been of some use to you.  Her seal took me two whole hours!  Feedback is always appreciated. <br><br>  <i><b>English source:</b> Giovanni Tropeano.</i>  <i>Self modifying code // CodeBreakers Journal.</i>  <i>Vol.</i>  <i>1, No.</i>  <i>2, 2006.</i> </div><p>Source: <a href="https://habr.com/ru/post/272619/">https://habr.com/ru/post/272619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272607/index.html">Is it easy to recognize information on a bank card?</a></li>
<li><a href="../272609/index.html">What to do if programming gets boring</a></li>
<li><a href="../272613/index.html">Adding jump lists to the UWP application</a></li>
<li><a href="../272615/index.html">Top 10 largest campuses "cloud" data centers</a></li>
<li><a href="../272617/index.html">Learning to program is harder than it sounds.</a></li>
<li><a href="../272621/index.html">Material Design Competition: Winners Announced</a></li>
<li><a href="../272623/index.html">Simple but useful plugin for Redmine</a></li>
<li><a href="../272625/index.html">How to write a JS library in ScalaJS</a></li>
<li><a href="../272627/index.html">Installing a virtual environment and agent program on the example of antivirus</a></li>
<li><a href="../272629/index.html">Calibrate Kinect v2 with OpenCV in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>