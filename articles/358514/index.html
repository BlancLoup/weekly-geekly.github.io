<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Release Rust 1.26</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Rust development team is pleased to announce the release of a new version of Rust: 1.26.0. Rust is a system programming language aimed at security...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Release Rust 1.26</h1><div class="post__text post__text-html js-mediator-article"><p>  The Rust development team is pleased to announce the release of a new version of Rust: 1.26.0.  Rust is a system programming language aimed at security, speed, and parallel code execution. </p><br><p>  If you have a previous version of Rust installed using rustup, then to update Rust to version 1.26.0, you just need to run: </p><br><pre><code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  If you have not yet installed rustup, you can <a href="https://www.rust-lang.org/install.html">install it</a> from the corresponding page of our website.  <a href="">Detailed notes for the release of Rust 1.26.0</a> can be found on GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1260">  What is included in the stable version 1.26.0 </h2><br><p>  The last few issues had a number of relatively minor improvements.  Nevertheless, we continued to work on many other things and now they are starting to come out in a stable version.  Version 1.26 is perhaps the richest in innovations since the release of Rust 1.0.  Let's consider them! </p><br><h4 id="vtoroe-izdanie-knigi-yazyk-programmirovaniya-rust">  The second edition of the book "Rust programming language" </h4><br><p>  For nearly 18 months, Carol, Steve, and others have been working on a complete reworking of the book "Rust Programming Language".  Since the writing of the first book, we have learned a lot about how people learn Rust, so the new version of the book is now better in all respects. </p><a name="habracut"></a><br><p>  Earlier, a draft of the second edition has already been published on the website with a statement that this is an unfinished version.  Now, small final edits are made to the book and it is being prepared for printing.  So from this issue we recommend reading the second edition instead of the first.  You can <a href="https://doc.rust-lang.org/book/second-edition/">find it on doc.rust-lang.org</a> or get it locally by running <code>rustup doc --book</code> . </p><br><p>  By the way, about printing: if you don‚Äôt feel sorry for trees, then you can order a paper version of the book on <a href="https://www.nostarch.com/Rust">NoStarch Press</a> .  The content is identical, but you get either a real physical copy of the book to put it on the shelf, or a perfectly crafted PDF.  All proceeds will go to charity. </p><br><h4 id="impl-trait"> <code>impl Trait</code> </h4> <br><p>  Finally, we have <code>impl Trait</code> !  This functionality has been very much in demand for a long time, because it provides an opportunity known as "existential types".  However, it only sounds scary, the essence of the idea is simple: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Trait { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  This type signature says: " <code>foo</code> is a function that takes no arguments and returns a type that implements the <code>Trait</code> type."  That is, we do not indicate which type of return <code>foo</code> actually has, but only indicate that it implements a certain type.  You may ask how this differs from the use of types of objects: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Trait&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  This is the correct code and this method also works, but it is not good for all situations.  Suppose we have a type of <code>Trait</code> , which is implemented for both <code>i32</code> and <code>f32</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Trait</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Trait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } impl Trait for f32 { //   }</span></span></code> </pre> <br><p>  Consider the function: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; ? { <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br><p>  We want to specify a certain type of result.  Previously, only the variant with the object type was possible: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Trait&gt; { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Trait&gt; }</code> </pre> <br><p>  But here <code>Box</code> used, which entails memory allocation in the heap.  In fact, we do not want to return any dynamically defined data, so dynamic dispatching here only harms.  Instead, in Rust 1.26 you can write this: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Trait { <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br><p>  This does not create a type-object and is more like if we wrote <code>-&gt; i32</code> , but only with reference to the part related to <code>Trait</code> .  We get static dispatching, but with the ability to hide the real type. </p><br><p>  How is this useful?  One of the good uses is closures.  Do not forget that closures in Rust always have a unique, not recordable type that implements the type <code>Fn</code> .  This means that if your function returns a closure, you can do this: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  fn foo() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; { Box::new(|x| x + 1) } //  fn foo() -&gt; impl Fn(i32) -&gt; i32 { |x| x + 1 }</span></span></code> </pre> <br><p>  No packaging and no dynamic dispatch.  A similar situation occurs when iterators are returned.  Not only do iterators often include closures, they can also be nested into each other, resulting in fairly deeply nested types.  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] .into_iter() .map(|x| x + <span class="hljs-number"><span class="hljs-number">1</span></span>) .filter(|x| x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br><p>  when compiling will give an error: </p><br><pre> <code class="hljs markdown">error[E0308]: mismatched types --&gt; src/main.rs:5:5 | 5 | / vec![1, 2, 3] 6 | | .into<span class="hljs-emphasis"><span class="hljs-emphasis">_iter() 7 | | .map(|x| x + 1) 8 | | .filter(|x| x % 2 == 0) | |_</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span><span class="hljs-strong"><span class="hljs-strong">_____</span></span>^ expected (), found struct <span class="hljs-code"><span class="hljs-code">`std::iter::Filter`</span></span> | = note: expected type <span class="hljs-code"><span class="hljs-code">`()`</span></span> found type <span class="hljs-code"><span class="hljs-code">`std::iter::Filter&lt;std::iter::Map&lt;std::vec::IntoIter&lt;{integer}&gt;, [closure@src/main.rs:7:14: 7:23]&gt;, [closure@src/main.rs:8:17: 8:31]&gt;`</span></span></code> </pre> <br><p>  This 'found type' is huge because each adapter in the chain adds a new type.  In addition, we also have a closure here.  Previously, we had to use type-objects in such cases, but now we can just write </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] .into_iter() .map(|x| x + <span class="hljs-number"><span class="hljs-number">1</span></span>) .filter(|x| x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br><p>  and it's done.  You can work with <a href="https://crates.io/crates/futures">futures</a> in the same way. </p><br><p>  It is important to note that sometimes types of objects are still needed.  You can use <code>impl Trait</code> only if your function returns one type;  if you want to return a few, then you need dynamic dispatching.  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] .into_iter() .map(|x| x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(iter.filter(|x| x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(iter) } }</code> </pre> <br><p>  Here, the filter iterator may or may not be returned.  There are two different types that can be returned, and therefore we must use a type-object. </p><br><p>  And finally: for syntactic symmetry, you can use <code>impl Trait</code> also in arguments.  I.e: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  fn foo&lt;T: Trait&gt;(x: T) { //  fn foo(x: impl Trait) {</span></span></code> </pre> <br><p>  can improve the look of short signatures. </p><br><blockquote>  Note for those who understand the theory of types: there is not an existential, but a universal type.  In other words, <code>impl Trait</code> is universal at the entrance to a function, but existential at the exit. </blockquote><br><h4 id="uluchsheny-sopostavleniya-v-match">  <code>match</code> matches <code>match</code> </h4><br><p>  Have you ever tried to use <code>match</code> to link to <code>Option</code> ?  For example, in a similar code: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span></span>(arg: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> arg { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(name) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello {}!"</span></span>, name), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know who you are."</span></span>), } }</code> </pre> <br><p>  If you try to compile it in Rust 1.25, then you will get the following error: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">error</span></span>[E0658]: non-<span class="hljs-keyword"><span class="hljs-keyword">reference</span></span> pattern used to <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">reference</span></span> (see issue #<span class="hljs-number"><span class="hljs-number">42640</span></span>) --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | Some(name) =&gt; println!(<span class="hljs-string"><span class="hljs-string">"Hello {}!"</span></span>, name), | ^^^^^^^^^^ <span class="hljs-keyword"><span class="hljs-keyword">help</span></span>: consider using a <span class="hljs-keyword"><span class="hljs-keyword">reference</span></span>: <span class="hljs-string"><span class="hljs-string">`&amp;Some(name)`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>[E0658]: non-<span class="hljs-keyword"><span class="hljs-keyword">reference</span></span> pattern used to <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">reference</span></span> (see issue #<span class="hljs-number"><span class="hljs-number">42640</span></span>) --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> | <span class="hljs-number"><span class="hljs-number">7</span></span> | None =&gt; println!(<span class="hljs-string"><span class="hljs-string">"I don't know who you are."</span></span>), | ^^^^ <span class="hljs-keyword"><span class="hljs-keyword">help</span></span>: consider using a <span class="hljs-keyword"><span class="hljs-keyword">reference</span></span>: <span class="hljs-string"><span class="hljs-string">`&amp;None`</span></span></code> </pre> <br><p>  Yes of course.  Let's change the code: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span></span>(arg: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> arg { &amp;<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(name) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello {}!"</span></span>, name), &amp;<span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know who you are."</span></span>), } }</code> </pre> <br><p>  We added <code>&amp;</code> as requested by the compiler.  Let's try to compile again: </p><br><pre> <code class="hljs rust">error[E0507]: cannot <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> out of borrowed content --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | &amp;<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(name) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello {}!"</span></span>, name), | ^^^^^^----^ | | | | | hint: to prevent <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> `<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> name` or `<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> name` | cannot <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> out of borrowed content</code> </pre> <br><p>  Yes of course.  Let's tame the compiler, following his advice: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span></span>(arg: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> arg { &amp;<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> name) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello {}!"</span></span>, name), &amp;<span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know who you are."</span></span>), } }</code> </pre> <br><p>  Now the compilation is successful.  We had to add two <code>&amp;</code> one <code>ref</code> .  But most importantly, none of this was truly <em>useful to</em> us, as programmers.  Of course, at first we forgot <code>&amp;</code> , but does it matter?  We needed to add <code>ref</code> to get a reference to the value stored inside <code>Option</code> , but we <em>could not</em> do anything else but to get the reference, since we cannot move the value behind <code>&amp;T</code> </p><br><p>  So, starting with Rust 1.26, the original code without <code>&amp;</code> and <code>ref</code> will just compile and do exactly what you expect.  In short, the compiler will automatically reference or dereference references in the <code>match</code> construct.  So when we say </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> arg { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(name) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello {}!"</span></span>, name),</code> </pre> <br><p>  the compiler will automatically refer to <code>Some</code> by reference, and since this will be a borrowing, the <code>name</code> will be associated with the value as a <code>ref name</code> , also automatically.  If we changed the value: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span></span>(arg: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> arg { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(name) =&gt; name.push_str(<span class="hljs-string"><span class="hljs-string">", world"</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; (), } }</code> </pre> <br><p>  the compiler would automatically perform the variable borrowing, and the <code>name</code> would turn out to be associated with the value as <code>ref mut</code> . </p><br><p>  We think that this will get rid of the particularly painful routine code of both novice and experienced developers.  The compiler will simply take over this job, no longer requiring you to write such routine code. </p><br><h4 id="main-mozhet-vozvraschat-result">  <code>main</code> can return <code>Result</code> </h4><br><p>  Speaking of the annoying routine code: since Rust uses the <code>Result</code> type to return errors and <code>?</code>  To simplify their processing, a common pain point for newcomers to Rust is trying to use it <code>?</code>  in <code>main</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = File::open(<span class="hljs-string"><span class="hljs-string">"bar.txt"</span></span>)?; }</code> </pre> <br><p>  This generates an error like "error [E0277]: the <code>?</code> Operator can only be used in a function that returns <code>Result</code> ".  Which many people are forced to write <a href="https://doc.rust-lang.org/book/second-edition/ch12-03-improving-error-handling-and-modularity.html">similar code</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>(config: Config) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Error&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } fn main() { // ... if let Err(e) = run(config) { println!("Application error: {}", e); process::exit(1); } }</span></span></code> </pre> <br><p>  Our <code>run</code> function contains all the real logic, and <code>main</code> calls <code>run</code> , checks if an error has occurred and shuts down.  We only need this second function because <code>main</code> cannot return a <code>Result</code> , but would we like to use it <code>?</code>  in their logic. </p><br><p>  In Rust 1.26 you can now declare <code>main</code> , which returns <code>Result</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), std::io::Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = File::open(<span class="hljs-string"><span class="hljs-string">"bar.txt"</span></span>)?; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(()) }</code> </pre> <br><p>  Now it works as it should!  If <code>main</code> returns an error, it will terminate with an error code and print debug information about the error. </p><br><h4 id="zakrytye-diapazony-s-">  Closed ranges with <code>..=</code> </h4><br><p>  Long before Rust 1.0, you could create semi-open ranges with <code>..</code> , for example: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"i: {}"</span></span>, i); }</code> </pre> <br><p>  This code will type <code>i: 1</code> , and then <code>i: 2</code> .  In Rust 1.26 you can now create a closed range, for example: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..=<span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"i: {}"</span></span>, i); }</code> </pre> <br><p>  This code will type <code>i: 1</code> , then <code>i: 2</code> , like the previous one, but also <code>i: 3</code> ;  three - also included in the range.  Closed ranges are especially useful for iterating over all possible values.  For example, here is an amazing program on Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takes_u8</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... } fn main() { for i in 0..256 { println!("i: {}", i); takes_u8(i); } }</span></span></code> </pre> <br><p>  What does this program do?  Answer: nothing.  The warning we get when compiling tells us why: </p><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">warning</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">literal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> u8 <span class="hljs-comment"><span class="hljs-comment">--&gt; src/main.rs:6:17 | 6 | for i in 0..256 { | ^^^ | = </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">note:</span></span></span><span class="hljs-comment"> #[warn(overflowing_literals)] on by default</span></span></code> </pre> <br><p>  This is correct, since <code>i</code> type <code>u8</code> , which is full, and this is the same as writing <code>for i in 0..0</code> , so the loop is executed zero times. </p><br><p>  However, with closed ranges you can fix this: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takes_u8</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... } fn main() { for i in 0..=255 { println!("i: {}", i); takes_u8(i); } }</span></span></code> </pre> <br><p>  This code will print the 256 lines you expected. </p><br><h4 id="bazovye-obrazcy-srezov">  Basic Sample Slices </h4><br><p>  Another long-awaited innovation is the ‚Äúslice patterns‚Äù.  It allows you to match slices with a sample, just as you are matching other types of data with a pattern.  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> arr { [<span class="hljs-number"><span class="hljs-number">1</span></span>, _, _] =&gt; <span class="hljs-string"><span class="hljs-string">"  "</span></span>, [a, b, c] =&gt; <span class="hljs-string"><span class="hljs-string">"  - "</span></span>, }</code> </pre> <br><p>  In this case, we know that <code>arr</code> has a length of three, and therefore we need three elements inside <code>[]</code> .  We can also match when we do not know the length: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(s: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> s { [a, b] =&gt; (), [a, b, c] =&gt; (), _ =&gt; (), } }</code> </pre> <br><p>  Here we do not know how long <code>s</code> , so we can write the first two patterns, <br>  each of which is designed for a different length.  We also need the option <br>  <code>_</code> since we do not cover all possible length cases, but we cannot! </p><br><h4 id="uvelichenie-skorosti">  Speed ‚Äã‚Äãincrease </h4><br><p>  We continue to improve compiler speeds.  We found that deep <br>  nested types in some cases became non-linear, which <a href="https://github.com/rust-lang/rust/pull/48296">was corrected</a> .  After this fix, along with which many other minor fixes were released, we observed a reduction in compile time of up to 12%.  In the future we will improve more! </p><br><h4 id="128-razryadnye-celye-chisla">  128-bit integers </h4><br><p>  Finally, one very simple improvement: now Rust has 128-bit integers! </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i128</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">u128</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  They are twice the size of <code>u64</code> and therefore may contain large values.  Namely: </p><br><ul><li>  <code>u128</code> : 0 - 340,282,366,920,938,463,463,374,607,431,768,211,455 </li><li>  <code>i128</code> : ‚àí170,141,183,460,469,231,731,687,303,715,884,105,728 - 170,141,183,460,469,231,731,687,303,715,884,105,727 </li></ul><br><p>  Whew! </p><br><p>  See <a href="">the release notes for</a> details. </p><br><h3 id="stabilizaciya-bibliotek">  Library stabilization </h3><br><p>  We have stabilized <a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html"><code>fs::read_to_string</code></a> , which is more convenient than <code>File::open</code> and <code>io::Read::read_to_string</code> for easy reading into the memory of the entire file at once: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::net::SocketAddr; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo: SocketAddr = fs::read_to_string(<span class="hljs-string"><span class="hljs-string">"address.txt"</span></span>)?.parse()?;</code> </pre> <br><p>  Now you can <a href="https://github.com/rust-lang/rust/pull/48978">format the output of hexadecimal numbers with Debug</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:02x?}"</span></span>, <span class="hljs-string"><span class="hljs-string">b"Foo\0"</span></span>) == <span class="hljs-string"><span class="hljs-string">"[46, 6f, 6f, 00]"</span></span>)</code> </pre> <br><p>  Trailing commas are <a href="https://github.com/rust-lang/rust/pull/48056">now supported by all macros in the standard library</a> . </p><br><p>  See <a href="">the release notes for</a> details. </p><br><h3 id="uluchsheniya-v-cargo">  Improvements in Cargo </h3><br><p>  In this release, Cargo did not receive significant changes in functionality, but received a number of improvements in stability and performance.  Cargo should now handle dependencies from lock files even faster and smarter, and also require less manual calls to the <code>cargo update</code> .  Cargo executable <a href="https://github.com/rust-lang/cargo/pull/5083">now has the same version as rustc</a> . </p><br><p>  See <a href="">the release notes for</a> details. </p><br><h2 id="razrabotchiki-1260">  Developers 1.26.0 </h2><br><p>  A lot of people participated in the development of Rust 1.26.  We could not complete the work without the participation of each of you. </p><br><p>  <a href="">Thank!</a> </p><br><p>  <em>Authors translation: <a href="https://habr.com/users/freecoder_xx/" class="user_link">freecoder_xx</a> and <a href="https://habr.com/users/ozkriff/" class="user_link">ozkriff</a> .</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/358514/">https://habr.com/ru/post/358514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358504/index.html">How to deploy Adaptavist ScriptRunner artifacts</a></li>
<li><a href="../358506/index.html">AI, practical course. Project planning</a></li>
<li><a href="../358508/index.html">Check Point. A selection of useful materials from TS Solution</a></li>
<li><a href="../358510/index.html">Task life cycle</a></li>
<li><a href="../358512/index.html">Carrot models, bottlenecks and speech recognition: the absence of dictionaries in the field of artificial intelligence</a></li>
<li><a href="../358516/index.html">Terminal server for AutoCAD</a></li>
<li><a href="../358518/index.html">VimpelCom subscribers will pay 13 rubles per month for the Spring Law</a></li>
<li><a href="../358520/index.html">Java and Linux - features of operation</a></li>
<li><a href="../358522/index.html">Go: we accelerate sampling of large tables from MySQL</a></li>
<li><a href="../358524/index.html">We will again be counted: National biometric platform and ‚Äúpass-through identifier‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>