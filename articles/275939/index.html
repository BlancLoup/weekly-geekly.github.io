<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dry anti-pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a long time I wondered what was wrong with some parts of the code. Time after time, in each of the projects there is a certain ‚Äúespecially vulnera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dry anti-pattern</h1><div class="post__text post__text-html js-mediator-article">  For a long time I wondered what was wrong with some parts of the code.  Time after time, in each of the projects there is a certain ‚Äúespecially vulnerable‚Äù component that ‚Äúfalls‚Äù all the time.  The customer has the ability to periodically change the requirements, and the agile canons will force us to embody all the wishes by launching change request into our scrum mechanism.  And as soon as the changes concern the component, after a couple of days, the QA find several new defects in it, rediscover the old ones, and even report that it is completely inoperable at one of the application points.  So why is one of the components all the time on the lips, why is it so often pronounced the phrase a la "again # component # broke"?  Why is this component given as an anti-example, in the context of ‚Äúas long as one more is the same‚Äù?  What makes this component so unstable to change? <br><a name="habracut"></a><br>  When they find the cause that led to, or contributed to the development of such a defect in the application, this reason is designated as antipattern. <br>  This time, the Strategy pattern was the stumbling block.  The abuse of this pattern led to the creation of the most fragile parts of our projects.  The pattern itself has a completely "peaceful" use, the problem is rather that it is shoved to where it fits, and not to where it is needed.  "If you understand what I mean" (c). <br><br><h2>  Classification </h2><br>  The pattern exists in several ‚Äúfaces‚Äù.  The essence of it does not change much, the danger of its use exists in any of them. <br>  The first, classic view is a long-lived object, which receives another object through the interface, the strategy itself, through a setter, with some state change. <br>  The second kind, a degenerate version of the first - the strategy is taken once, for the entire lifetime of the object.  Those.  for one scenario, one strategy is used, for another, another. <br>  The third type is the executable method, either static or in a short-lived object, which takes an interface strategy as an input parameter.  In the "gang of four" this type is called as "Template method". <br>  The fourth type - interface, aka UI-ny.  Sometimes referred to as a ‚Äúpattern‚Äù pattern, sometimes as a ‚Äúcontainer‚Äù.  On the example of web development, it is some kind of markup that contains a placeholder (or even more than one), where a variable part of the markup, which has several different implementations, will be rendered during execution.  Parallel to the markup, in the JavaScript code also live parallel view models or controllers, depending on the architecture adopted in the application, organized by the second type. <br><br>  The common features of these all cases are: <br>  1) some unchangeable part of aka having one implementation, further, I will call it a container <br>  2) the variable part, it is a strategy <br>  3) the place of use, creating / calling the container, determining which strategy the container should use, I will call it a script below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Disease progression </h2><br>  At first, when the component using this pattern was only implemented in the project, it did not seem so bad.  It was used when it was necessary to create two identical pages (again, using web development as an example), which only slightly differ in content in the middle.  On the contrary, the developer was glad how beautiful and elegant it was to implement the principle of DRY, i.e.  completely avoid duplicate code.  These are the epithets I heard about the component when it was just created.  The one that became the popabol of the entire project a few months later. <br>  And since I began to theorize, I‚Äôll go a little further - it is attempts to realize the principle of DRY, through the strategy strategy, in fact, like through inheritance, lead to darkness.  When, for the sake of DRY, without even noticing it, the developer sacrifices the SRP principle, the first and main postulate of SOLID.  By the way, DRY is not part of SOLID, and in case of conflict, it is necessary to sacrifice them, because it does not favor the creation of a stable code, in contrast to, in fact, SOLID.  As it turned out - rather the opposite.  Re-use of the code should be a pleasant bonus of certain design decisions, and not the purpose of making them. <br>  And the temptation to reuse occurs when the customer comes with a new story to create a third page.  After all, it is so similar to the first two.  It also helps the customer‚Äôs desire to realize everything ‚Äúcheaper‚Äù, because reusing a previously created container is faster than implementing the page completely.  The story got to another developer who quickly found out that the container‚Äôs functionality is not enough, and full-fledged refactoring does not fit into the estimates.  Another of the mistakes here is that the developer continues to follow the plan set by the estimates, and this happens ‚Äúin silence‚Äù, because there is no responsibility, it lies with the entire team that made such a decision and such an assessment. <br>  And now new functionality is added to the container, new methods and fields are added to the strategy interface.  If-s appear in the container, and in the old implementations of the strategy there appear "stubs" in order not to break the already existing pages.  At the time of the second story, the component was already doomed, and the farther, the worse.  It is harder and harder for developers to understand how it works, including those who ‚Äúdid something in it quite recently‚Äù.  It's harder to make changes.  Increasingly, one has to consult with the ‚Äúprevious ones‚Äù to ask how it works, why some changes have been made.  It is increasingly likely that even the slightest change will make a new defect.  Actually, we are already starting to talk about the fact that there is an increasing probability of introducing two or more defects, since one defect appears already with near-unit probability.  And here comes the moment when new customer requirements cannot be realized.  There are two ways out: either completely rewrite, or make an explicit hack.  And in Angulyar there is just a suitable hack tool - you can do emit events from bottom to top, then broadcast from top to bottom, when you have finished dirty work at the top.  At the same time, technical debt does not increase anymore, it has long been equal to the cost of selling this component from scratch. <br><br><h2>  Dry alternative </h2><br>  Inheritance is often censured, and the corporation of good, in its Go language, decided to do without it at all, and it seems to me that the negative to inheritance is partly based on the experience of implementing the DRY principle through it.  "Strategic" DRY also leads to sad results.  Direct aggregation remains.  For illustration, I will take a simple example and show how it can be presented in the form of a strategy, that is, a template method without it. <br>  Suppose we have two very similar scenarios, represented by the following pseudocode: <br>  They repeat 10 lines X at the beginning and 15 lines Y at the end.  In the middle, one script has lines A, another - lines B <br><pre><code class="hljs">{  X1 ... X10  1 ... 5  Y1 ... Y15 }</code> </pre> <br><pre> <code class="hljs">{  X1 ... X10  B1 ... B3  Y1 ... Y15 }</code> </pre><br><br><h4>  The option of getting rid of duplication through strategy </h4><br><pre> <code class="hljs">{  X1 ... X10 ()  Y1 ... Y15 }</code> </pre><br><pre> <code class="hljs">{  1 ... 5 }</code> </pre><br><pre> <code class="hljs">{  B1 ... B3 }</code> </pre><br><pre> <code class="hljs cs">{ (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ) }</code> </pre><br><pre> <code class="hljs cs">{ (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B) }</code> </pre><br><br><h4>  Option through direct aggregation </h4><br><pre> <code class="hljs">{  X1 ... X10 }</code> </pre><br><pre> <code class="hljs">Y{  Y1 ... Y15 }</code> </pre><br><pre> <code class="hljs">{  1 ... 5 }</code> </pre><br><pre> <code class="hljs">{  B1 ... B3 }</code> </pre><br><pre> <code class="hljs">{ () A() Y() }</code> </pre><br><pre> <code class="hljs">{ () B() Y() }</code> </pre><br>  Here it is assumed that all methods are in different classes. <br>  As I said, at the time of implementation, the first option does not look so bad.  Its disadvantage is not that it is initially bad, but that it is not resistant to change.  And, nevertheless, it is worse read, although with a simple example this may not be obvious.  When you need to implement the third scenario, which is similar to the first two, but not 100%, there is a desire to reuse the code contained in the container.  But it will not work out partially, you can only take it entirely, so you have to make changes to the container, which immediately carries the risk of breaking other scenarios.  The same happens when a new requirement implies changes in scenario A, but this should not affect scenario B. In the case of aggregation, method X can be easily replaced by method X 'in one scenario, without affecting the others at all.  It is easy to assume that the methods X and X 'may also almost completely coincide, and they can also be subdivided.  With the ‚Äústrategy‚Äù approach, if cascaded in the same ‚Äústrategy‚Äù manner, then the evil placed in the project is raised to the second degree. <br><br><h2>  When can </h2><br>  Many examples of the use of the strategy pattern are visible and often used.  All of them are united by one simple rule - there is no business logic in the container.  Totally.  There may be algorithmic content, such as a hash table, search or sort.  The strategy also contains business logic.  The rule that one element is equal to another or more-less is business logic.  All linq operators are also the embodiment of the pattern, for example, the .Where () operator is also a template method, and the lambda it takes is a strategy. <br>  In addition to algorithmic content, it can be content associated with the outside world, asynchronous requests, for example, or, in the example from the ‚Äúgang of four‚Äù, a subscription to a mouse click event.  What they call callbacks is essentially the same strategy, I hope they will forgive all my hyper-generalizations.  Also, if we are talking about UI, then it can be tabs, or a pop-up window. <br>  In short, it can be anything, completely abstracted from business logic. <br>  If you are using the strategy strategy in development, and the business logic has fallen into the container - you know, you have already crossed the line, and you are standing ankle-deep in ... mmm, swamp. <br><br><h2>  Smells </h2><br>  Sometimes it is not easy to understand where the line is between business logic and general programming tasks.  And at first, when the component is just created, it is not easy to determine that it will bring hemorrhoids in the future.  And if business requirements never change, this component may never emerge.  But if there are changes, the following code smells will inevitably appear: <br>  1. The number of transferred methods.  The parameter under discussion is not harmful in itself, but it may hint.  Two or three is still normal, but if the strategy contains about a dozen methods, then probably something is wrong. <br>  2. Flags.  If, in addition to methods, there are fields / properties in the strategy, you should pay attention to what they are called.  Fields such as Name, Header, ContentText are valid.  But if you see such fields as SkipSomeCheck, IsSomethingAllowed, this means that the strategy already smacks. <br>  3. Conditional calls.  Associated with flags.  If there is a similar code in the container, it means that you have already left for a swamp to the waist. <br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!strategy.SkipSomeCheck)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strategy</span></span></span><span class="hljs-function">.C</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heckSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">. }</span></span></code> </pre><br>  4. Inadequate code.  An example from JavaScript - <br><pre> <code class="hljs lisp">if(<span class="hljs-name"><span class="hljs-name">strategy</span></span>.doSomething)</code> </pre><br>  From the name you can see that doSomething is a method, but is checked as a flag.  That is, the developers were too lazy to create a flag denoting the type, but they used the presence / absence of a method as a flag, and it wasn‚Äôt even called inside an if block.  If you meet this, you should know - the component is already in the technical debt. <br><br><h2>  Conclusion </h2><br>  Once again I want to express my opinion that the root cause of all that I described is not in the pattern as such, but in the fact that it was used for the DRY principle, and this principle was put above the sole responsibility principle, aka SRP.  And, by the way, more than once I have come across the fact that the principle of sole responsibility is somehow not adequately interpreted.  Something like ‚Äúmy divine class controls the satellite, managing the satellite is his only responsibility.‚Äù  On this note I want to finish my opus and wish less often in response to "why so", to hear the phrase "historically it happened." </div><p>Source: <a href="https://habr.com/ru/post/275939/">https://habr.com/ru/post/275939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275923/index.html">Welcome to the meeting Moscow.pm February 4</a></li>
<li><a href="../275927/index.html">Optimization of Android-games created on Unity for the Intel platform: an example from life</a></li>
<li><a href="../275929/index.html">Setting color tabs in the new assembly Vivaldi 1.0.380.2</a></li>
<li><a href="../275933/index.html">Grandstream First Conference Background Review - GAC2500</a></li>
<li><a href="../275937/index.html">Fuzzy search in the dictionary with the universal Levenshtein automaton. Part 1</a></li>
<li><a href="../275943/index.html">Building Android applications step by step, part one</a></li>
<li><a href="../275947/index.html">Customer support, Amazon backdoor</a></li>
<li><a href="../275949/index.html">Course for beginners. The Basics of IP Telephony on Cisco Packet Tracer</a></li>
<li><a href="../275951/index.html">A few things to remember about the age programmer</a></li>
<li><a href="../275953/index.html">Experience home rover</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>