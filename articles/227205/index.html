<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autotiling: automatic tile transitions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Literally I just came across an article from the sandbox about the grid-tiling and decided to write my own analogue. 
 My transition allocation method...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autotiling: automatic tile transitions</h1><div class="post__text post__text-html js-mediator-article">  Literally I just came across an article from the sandbox about the grid-tiling and decided to write my own analogue. <br>  My transition allocation method is somewhat different from that mentioned in that article. <br>  The beginning of this system was laid in the notorious game <b>WarCraft III</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ce/f80/601/9cef80601907a8f1c2c717d50ce0d26d.png" alt="image"><br><a name="habracut"></a><br>  In this screenshot of the WC3 map editor, you can see the stitches, they are indicated by red arrows.  Apparently, the logic of the tiles in this game is somewhat different than in most games.  One tile here <b>does not occupy a whole cell</b> .  It is located, as it were, at a point around which its corners are already drawn. <br><br>  Especially well seen with the included grid. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ac0/a75/16b/ac0a7516b00ae75d8dbc815202de2a18.png" alt="image"><br><br>  Usually in such a situation it is proposed to divide the tile into 4 small ones.  But there is one thing: what to do in such a case? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/afa/3d9/ecb/afa3d9ecbab01fc48a03079e6baf6408.png" alt="image"><br><br>  When are all 4 surrounding one quad tiles different?  Here it is clearly visible that the lowermost tile occupies the most part. <br>  After weighing all the pros and cons, I came to my own, quite specific, system.  Add a new grid, a transition grid.  In it, we can store, for example, the type int.  In this case, it will be possible for us to write down for each quad of the tiles the 16 IDs of the surrounding 4 tiles with 16 transition variants.  This is more than enough.  No, if someone needs more ID - please use long.  I decided that I would have enough of 16 auto-files for the game location, the rest will be without auto-transitions. <br><br>  Next, we need a set of tiles.  You can, of course, use a mask, but with a set of tiles, you will agree, with good skill (not me, no), you can achieve a very, very good picture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/058/107/ea3/058107ea390097343a327a9cd1fbae2c.png" alt="image"><br><br>  I made this test suite myself.  There are 12 transition options for one tile, you can add your own 4. I also reserved slots for future tile variations, as in WC3, but this part is quite easy and I will not describe it here. <br><br>  Go to the programming part.  First, let's describe the functions that will determine the desired bit mask for selecting the correct texture index.  At once I will make a reservation, I am peculiar to choose rather non-standard solutions.  Java + LWJGL will be used here. <br><br>  This function will create a mask of bits for the quad.  Bit 1 means that in this corner of the tile there is a tile adjacent to it (thus, it is possible to combine different tilesets of the same height).  Oh yes.  Height, about her, I forgot.  Of course, we will need to determine its height for each tile in order to know what to draw above and what is below.  This is solved simply by adding an obvious variable. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTransitionCornerFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> corner = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x-<span class="hljs-number"><span class="hljs-number">1</span></span>, y).zOrder == height) corner |= <span class="hljs-number"><span class="hljs-number">0b0001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x, y).zOrder == height) corner |= <span class="hljs-number"><span class="hljs-number">0b0010</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x, y-<span class="hljs-number"><span class="hljs-number">1</span></span>).zOrder == height) corner |= <span class="hljs-number"><span class="hljs-number">0b0100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x-<span class="hljs-number"><span class="hljs-number">1</span></span>, y-<span class="hljs-number"><span class="hljs-number">1</span></span>).zOrder == height) corner |= <span class="hljs-number"><span class="hljs-number">0b1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corner; }</code> </pre> <br><br>  Each bit means its own angle.  1 bit - upper left corner, 2 - lower left, 3 - lower right, well, 4 - upper right. <br><br>  Now, with regards to the method of determining the desired texture indices for transitions.  The method I got was bulky and ugly, well, all because of my skills.  Although specifically for the article I broke it into several methods in order not to create a huge amount of indentation. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateTransitionMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">16</span></span>, h = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// ,     4   4   ID  4    (.. 32      ) for (int i = 0; i &lt; 4; i++) //            temp[i] = 0; if (tileID &gt; 0) { for (int i = 1; i &lt;= tilesNum; i++) { int corner = getTransitionCornerFor(world, x, y, i); int c = 0; if (corner &gt; 0) { c = setPointTransition(world, temp, x, y, corner, c, i); //      if (c == 3) c = setCornerTransition(world, temp, x, y, corner, c, i); //,   3 (!) ,      if (c == 2) c = setEdgeTransition(world, temp, x, y, corner, c, i); //  2 (!) ,     } } } }</span></span></code> </pre><br><br>  And here are the methods themselves: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPointTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] temp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> corner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; k++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((corner &gt;&gt; k &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = <span class="hljs-number"><span class="hljs-number">8</span></span>+k; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> storage = <span class="hljs-number"><span class="hljs-number">0</span></span>; storage = (idx &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span> | (i &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>); temp[k] = storage; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; l++) { t = (t &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | temp[l] &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; } world.setTransition(x, y, t); c++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre><br><br>  Everything is simple here.  Run over every corner, check the bit.  If he is alone, we put the index 8 + <b>k</b> , i.e.  angle (above I described the number for each side (NE, SE, SW, SE)).  Next, using the crutch through the cycle, update our transition map. <br><br>  Do not forget at the end to give the updated number with.  Thanks to <b>Java</b> for not having <b>out</b> or passing simplest types by reference. <br><br>  Methods connecting points to angles and sides: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setEdgeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] temp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> corner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; offset++) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isSide = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; k++) { <span class="hljs-comment"><span class="hljs-comment">//    if ((corner &gt;&gt; ((k + offset) % 4) &amp; 1) != 1) isSide = false; else if (k == 1 &amp;&amp; isSide) { int idx = (offset+1)%4; int storage = 0; storage = (idx &amp; 0xF) &lt;&lt; 4 | (i &amp; 0xF); temp[offset] = storage; int t = 0; for (int l = 0; l &lt; 4; l++) { t = (t &lt;&lt; 8) | temp[l] &amp; 0xFF; } world.setTransition(x, y, t); } } } return c; } public int setCornerTransition(World world, int[] temp, int x, int y, int corner, int c, int i) { for (int offset = 0; offset &lt; 4; offset++) { boolean isCorner = true; for (int k = 0; k &lt; 3; k++) { //    if ((corner &gt;&gt; ((k + offset) % 4) &amp; 1) != 1) isCorner = false; else if (k == 2 &amp;&amp; isCorner) { int idx = 4+offset; int storage = 0; storage = (idx &amp; 0xF) &lt;&lt; 4 | (i &amp; 0xF); temp[offset] = storage; int t = 0; for (int l = 0; l &lt; 4; l++) { t = (t &lt;&lt; 8) | temp[l] &amp; 0xFF; } world.setTransition(x, y, t); } } } return c; }</span></span></code> </pre><br><br>  Here is exactly the same principle.  The only difference is the starting index number of the texture, so that we can take the desired and one more cycle, which sets the offset, which means from which point to start the angle.  The adjacent angle (or side) is checked counterclockwise, starting from this point.  If at least one point is not adjacent tile - interrupt, neither the angle nor the side is obtained. <br>  That's it, the transition map is built here!  Each tile has 5 bits.  One for storing a tile (256 possible variations) and a bit at each corner for storing metadata. <br><br>  It remains only to render this case.  I will consider the old deprecated-method via the immediate-mode (I plan to leave for VBO, now I need to deal a little with the structure and dynamic update of VBO, as well as with drawing only the visible part of it). <br><br>  Well, there is nothing complicated: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">16</span></span>, h = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileID &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = world.getTransition(x, y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src = ((t &gt;&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span>-i)*<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = src &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = src &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = (idx%<span class="hljs-number"><span class="hljs-number">8</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span>, v = <span class="hljs-number"><span class="hljs-number">16</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>*(idx/<span class="hljs-number"><span class="hljs-number">8</span></span>) + (id-<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">48</span></span>, u1 = u + w, v1 = v + h; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GRenderEngine.drawTextureQuad(x*<span class="hljs-number"><span class="hljs-number">16</span></span>, y*<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, u, v, u1, v1); <span class="hljs-comment"><span class="hljs-comment">//    ,      VBO } } } }</span></span></code> </pre><br><br>  What are we doing here?  Yeah, we go through every 8 bits and get 4 first and 4 last, for ID and transition.  Next we pass the OpenGL parameters, it already distributes the drawing. <br><br>  Result: <br><br><img src="http://i.imgur.com/MLT9NcC.png" alt="image"><br>  (Yes, yes, LWJGL canvas built into Swing). <br><br>  It seems we have forgotten something?  Draw a solid piece of tile, if 4 surrounding points are native to it in height! <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">16</span></span>, h = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileID &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = world.getTransition(x, y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src = ((t &gt;&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span>-i)*<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = src &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = src &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = (idx%<span class="hljs-number"><span class="hljs-number">8</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span>, v = <span class="hljs-number"><span class="hljs-number">16</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>*(idx/<span class="hljs-number"><span class="hljs-number">8</span></span>) + (id-<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">48</span></span>, u1 = u + w, v1 = v + h; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == tileID) c++; GRenderEngine.drawTextureQuad(x*<span class="hljs-number"><span class="hljs-number">16</span></span>, y*<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, u, v, u1, v1); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">4</span></span>) { GRenderEngine.drawTextureQuad(x*<span class="hljs-number"><span class="hljs-number">16</span></span>, y*<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>*(tileID-<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, (tileID-<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">48</span></span>+<span class="hljs-number"><span class="hljs-number">16</span></span>); } } }</code> </pre><br><br><img src="http://i.imgur.com/BXerEze.png" alt="image"><br><br>  Something is missing?  That's right, we need to decide how to draw the bottom tile.  To be honest, I managed to solve it almost by accident, but this particular moment still needs some work.  While this can be considered a screwed crutch, but it does not affect the result. <br><br>  Let's slightly change our method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">16</span></span>, h = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileID &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= tilesNum; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> corner = getTransitionCornerFor(world, x, y, i); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (corner &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; k++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((corner &gt;&gt; k &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { c++; } } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fill = getFillCornerFor(world, x, y, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fill &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; k++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fill &gt;&gt; k &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { c++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; c == <span class="hljs-number"><span class="hljs-number">4</span></span>) flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-number"><span class="hljs-number">4</span></span>) { GRenderEngine.drawTextureQuad(x*<span class="hljs-number"><span class="hljs-number">16</span></span>, y*<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>*(i-<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>, (i-<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">48</span></span>+<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = world.getTransition(x, y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src = ((t &gt;&gt; (<span class="hljs-number"><span class="hljs-number">3</span></span>-i)*<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = src &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = src &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u = (idx%<span class="hljs-number"><span class="hljs-number">8</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span>, v = <span class="hljs-number"><span class="hljs-number">16</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>*(idx/<span class="hljs-number"><span class="hljs-number">8</span></span>) + (id-<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">48</span></span>, u1 = u + w, v1 = v + h; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GRenderEngine.drawTextureQuad(x*<span class="hljs-number"><span class="hljs-number">16</span></span>, y*<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, u, v, u1, v1); } } } }</code> </pre><br><br>  Added another method.  It is almost equivalent to the method that writes bits of adjacent tiles.  Here he is: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFillCornerFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(World world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> corner = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x-<span class="hljs-number"><span class="hljs-number">1</span></span>, y).zOrder &gt; height) corner |= <span class="hljs-number"><span class="hljs-number">0b0001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x, y).zOrder &gt; height) corner |= <span class="hljs-number"><span class="hljs-number">0b0010</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x, y-<span class="hljs-number"><span class="hljs-number">1</span></span>).zOrder &gt; height) corner |= <span class="hljs-number"><span class="hljs-number">0b0100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (world.getTile(x-<span class="hljs-number"><span class="hljs-number">1</span></span>, y-<span class="hljs-number"><span class="hljs-number">1</span></span>).zOrder &gt; height) corner |= <span class="hljs-number"><span class="hljs-number">0b1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corner; }</code> </pre><br><br>  It determines all tiles in the area whose height is greater than the height of the transferred tile. <br><br>  Those.  we iterate over all the tiles for a given cell (of course, only auto-files are worth sorting) and see how many tiles are higher than this.  Do not forget that before this we count the number of points covered by this tile.  If the number of points of this tile + the sum of points of other tiles overlapping a given == 4, then we draw a full quad with this texture and interrupt the loop.  These are the crutches. <br><br>  The result is excellent: <br><br><img src="http://i.imgur.com/5eFCbrC.png" alt="image"><br><br>  Perhaps that's all. <br><br>  PS How is this method better?  Well, WC3 clearly demonstrates that with such a system you can achieve a landscape of unimaginable beauty.  Personally, it seems to me that it is more flexible, which, however, creates some difficulties in its implementation.  And yes, it still requires some, as I said above, refinement. </div><p>Source: <a href="https://habr.com/ru/post/227205/">https://habr.com/ru/post/227205/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227195/index.html">Reflections on the blues - once again about exception handling</a></li>
<li><a href="../227197/index.html">Porting a Windows 8.1 application to Windows Phone 8.0 with troubleshooting</a></li>
<li><a href="../227199/index.html">Modern aspects of the presentation of texts in the analysis of natural language: classical and alternative approaches</a></li>
<li><a href="../227201/index.html">Own WebGL engine. Article number 1. Canvas</a></li>
<li><a href="../227203/index.html">Migration and Coexistence of Mail Systems</a></li>
<li><a href="../227209/index.html">The line between the cargo cult and the evolution in learning success</a></li>
<li><a href="../227211/index.html">Increase website conversion: How to use cognitive beliefs</a></li>
<li><a href="../227213/index.html">Dell is preparing for the arrival of ARM processors in servers</a></li>
<li><a href="../227215/index.html">Wi-Fi microSD Adapter: add a Wi-Fi module to the camera</a></li>
<li><a href="../227219/index.html">RuSSIR 2014: VIII summer school on information retrieval</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>