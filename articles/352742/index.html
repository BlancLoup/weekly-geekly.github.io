<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book ‚ÄúHigh-loaded applications. Programming, scaling, support</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this book you will find the key principles, algorithms and compromises, without which it is impossible to do when developing high-loaded systems fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book ‚ÄúHigh-loaded applications. Programming, scaling, support</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/piter/blog/352742/"><img src="https://habrastorage.org/webt/bz/bk/ji/bzbkjibt-jo0lnzgbawpqsvbesc.jpeg" align="left" alt="image"></a>  In this book you will find the key principles, algorithms and compromises, without which it is impossible to do when developing high-loaded systems for working with data.  The material is considered on the example of the internal structure of popular software packages and frameworks.  The book has three main parts, devoted primarily to the theoretical aspects of working with distributed systems and databases.  The reader is required to have basic knowledge of SQL and database principles. <br><br>  The review post deals with the section "Knowledge, Truth, and Falsehood." <br><br>  If you have no experience with distributed systems, the consequences of these problems can be very misleading.  The network node knows nothing for sure - it can only make assumptions based on the messages it receives (or does not receive) over the network.  One node is able to find out the status of another node (what data is stored on it, whether it is working correctly) only by exchanging messages with it.  If the remote host does not respond, then there is no way to find out its status, since it is impossible to distinguish between network problems and problems on the host. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Discussions of these systems border on philosophy: what is true in our system, and what is a lie?  Can we rely on this knowledge if the mechanisms of knowledge and measurement are unreliable?  Should software systems obey the laws of the physical world, such as the law of cause and effect? <br><br>  Fortunately, we do not need to look for the meaning of life.  For a distributed system, it is possible to describe the assumptions regarding the behavior (system model) and design it so that it corresponds to these assumptions.  It is possible to verify the correct operation of algorithms within a specific system model.  This means that reliability is quite achievable, even if the underlying model of the system provides very few guarantees. <br><br>  However, although it is possible to ensure proper operation of the system with an unreliable model, this is not easy to do.  In the remainder of this chapter, we will discuss the concepts of knowledge and truth in distributed systems, which will help us deal with the necessary assumptions and guarantees.  In Chapter 9, we proceed to consider a number of examples of distributed systems and algorithms that provide specific guarantees with specific assumptions. <br><br><h3>  Truth is determined by the majority </h3><br>  Imagine a network with an asymmetric failure: the node receives all messages sent to it, but all its outgoing messages are delayed or discarded altogether.  And although it works fine and receives requests from other nodes, these others do not receive its responses.  As a result, after some waiting time, other nodes declare it inoperative.  The situation turns into some kind of nightmare: the node half-disconnected from the network is forcibly dragged by a graveyard, and he fights back and shouts: ‚ÄúI'm alive!‚Äù.  But since no one hears his screams, the funeral procession continues to move steadily. <br><br>  In a slightly less nightmarish scenario, a node that is half disconnected from the network may notice a lack of confirmation of the delivery of its messages from other nodes and understands that there is a network failure.  However, other nodes mistakenly declare the half-disabled node to be inoperative, but he is not able to do anything about it. <br><br>  As a third scenario, imagine a node suspended for a long time due to a long comprehensive garbage collection.  All its threads are pushed out of memory by the garbage collection process and suspended for a minute, and therefore requests are not processed, and responses are not sent.  Other nodes wait, repeat the dispatch, lose patience, eventually declare the node inoperative and ‚Äúsend it to the hearse‚Äù.  Finally, the garbage collection process ends and the node flows resume operation as if nothing had happened.  The rest of the nodes are surprised at the ‚Äúresurrection‚Äù in full health of the node declared as ‚Äúdead‚Äù and begin to happily chat with eyewitnesses of this.  At first, this node does not even realize that a full minute has passed and it was declared ‚Äúdead‚Äù - from his point of view almost an instant passed since the last exchange of messages with other nodes. <br><br>  The moral of these stories: the site can not rely only on their own opinions about the situation.  A distributed system cannot fully rely on a single node, since it can refuse at any time, leading to a failure and the impossibility of restoring the system.  Instead, many distributed algorithms base their work on a quorum, that is, the decision of the majority of nodes (see the ‚ÄúWriting and reading quorum operations‚Äù section of the ‚ÄúWriting to the database when one of the nodes fails‚Äù section 5.4): decision making requires a certain minimum number ‚ÄúVotes‚Äù from multiple nodes.  This condition reduces the dependence on any one particular node. <br><br>  This includes making decisions about declaring nodes inoperative.  If the quorum of nodes declares another node inoperative, then it is considered as such, even if it works fine at the same time.  Individual nodes are required to comply with quorum decisions. <br><br>  Typically, a quorum is an absolute majority of more than half of the nodes (although there are other types of quorums).  The quorum on the majority allows the system to work in case of failures of individual nodes (with three nodes, one failure is allowed, with five - two failures).  This method is safe because the system can only have one majority - two at the same time, whose solutions conflict, are impossible.  We discuss the use of quorums in more detail when we get to consensus algorithms in Chapter 9. <br><br><h3>  Lead and lock </h3><br>  Often, the system requires only one instance of something.  For example: <br><br><ul><li>  only one node can be the master for a database section in order to avoid the situation of the division of computing power (see the section ‚ÄúInterruptions to the maintenance of nodes‚Äù section 5.1); </li><li>  only one transaction or one client can hold a lock on a specific resource or object in order to prevent competitive entry into it and damage it; </li><li>  only one user can register a specific username, since it must uniquely identify the user. </li></ul><br>  Implementing this in a distributed system requires caution: even if a node is sure of its ‚Äúelection‚Äù (the section's leading node, the owner of the lock, the request handler that successfully acquired the user name), it is not at all the fact that the quorum of the other nodes agrees with this!  A node could previously have been a master, but if then other nodes declared it inoperative (for example, due to a network break or a pause for garbage collection), then it could well have been ‚Äúdemoted‚Äù and selected another lead node. <br><br>  The case where a node continues to behave as an ‚Äúelected‚Äù, despite the fact that the quorum of the other nodes declared it inoperative, can lead to problems in an insufficiently carefully designed system.  Such a node is able to send messages to other nodes as a self-styled ‚Äúfavorite‚Äù, and if other nodes agree with this, the system as a whole may start to work incorrectly. <br><br>  For example, in fig.  8.4, an error with data corruption due to improper lock implementation is shown (this is not at all a theoretical error: it often occurs in the HBase DBMS).  Suppose we want to make sure that only one client can access a file in the storage service at the same time, because if several clients immediately try to write to it, the file will be corrupted.  We will try to do this with the client's obligatory receipt of a lease agreement from the service of locks before accessing the file. <br><br>  The described problem is an example of what we discussed in the subsection ‚ÄúPauses during the execution of processes‚Äù of section 8.3: if the leasing client is suspended for too long, then the term of its lease agreement expires.  After that, another client can get a lease on the same file and start recording data into it.  After the resumption of work, the suspended client believes (erroneously) that he still has a valid lease agreement, and proceeds to write to the file.  As a result, the write operations of two clients are shuffled and the file is spoiled. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/zc/ur/mazcurg_7idktkapfsofjchgetu.png" alt="image"></div><br><h3>  Enclosing markers </h3><br>  When using a lock or lease agreement to protect access to a resource, for example, the file storage in fig.  8.4, it is necessary to make sure that the node, which mistakenly considers itself ‚Äúelected‚Äù, will not disrupt the operation of the rest of the system.  For this purpose, there is a fairly simple method, shown in Fig.  8.5.  It is called fencing. <br><br>  Imagine that each time a lock is granted or a lease agreement, the lock server also returns a fencing token, which is a number that is incremented each time the lock is granted (for example, it can build up the lock service).  In addition, we require that the client each time it sends a write request to the storage service includes such a token in the current request. <br><br>  In fig.  8.5 Client 1 receives a lease agreement with marker 33, after which it is permanently suspended and the lease agreement expires.  Client 2 receives a lease agreement with marker 34 (the number monotonically increases), and then sends a write request to the storage service, including this marker in the request.  Later, client 1 resumes operation and sends a write operation with a marker 33 to the storage service. However, the storage service remembers that it has already processed a write operation with a large number of the marker (34) and rejects this request. <br><br>  When using ZooKeeper as a lock service, you can use the transaction identifier zxid or the version of the cversion node as a protecting marker.  Since ZooKeeper guarantees their monotonous growth, they have the necessary properties for this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nf/9w/fw/nf9wfw8y9s7u_rarfw352jxdk_i.png" alt="image"></div><br>  Note: this mechanism requires that the resource itself take an active part in checking tokens, rejecting all write operations with markers older than those already processed, checking locking status on the clients themselves is not enough.  It is possible to bypass the restriction for resources that do not explicitly support enclosing markers (for example, in the case of a file storage service, the enclosing marker is included in the file name).  However, some verification is still needed to avoid processing requests without blocking protection. <br><br>  Checking server-side markers may seem like a drawback, but it‚Äôs quite likely that it‚Äôs not so bad: it would be unwise for a service to assume that all its clients always ‚Äúbehave themselves‚Äù, since clients often do not run people with such priorities as from the owners of the service.  Consequently, for any service it would be a good idea to protect yourself from unintentional misconduct by customers. <br><br><h3>  Byzantine failures </h3><br>  Fencing markers are able to detect and block a node that unintentionally performs erroneous actions (for example, because it has not yet detected the expiration of its lease agreement).  However, a node intentionally wanting to undermine the system guarantees can easily do this by sending a message with a fake marker. <br><br>  In this book, we assume that nodes are unreliable, but ‚Äúfair‚Äù: they may work slowly or not respond at all (due to a failure), their state may be outdated (due to a pause for garbage collection or network delays), but if the node is at all he answers, he ‚Äúspeaks the truth‚Äù (observes the rules of the protocol within the framework of the information he has). <br><br>  The problems of distributed systems are greatly exacerbated when there is a risk that nodes can ‚Äúlie‚Äù (send random failed or corrupted responses) ‚Äîfor example, if a node can declare it has received a certain message when in fact it was not.  This behavior is called the Byzantine fault (Byzantine fault), and the task of achieving consensus in such an untrustworthy environment is known as the task of the Byzantine generals (Byzantine generals problem). <br><br>  The system is protected from Byzantine failures, if it continues to work correctly even in the event of malfunction of some nodes and non-compliance with the protocol or when intruders interfere with the network.  This may be important in the following circumstances. <br><br><ul><li>  In the aerospace industry, data in computer memory or CPU registers may deteriorate due to radiation, which causes unpredictable responses to be sent to other nodes.  Since a system failure can lead to catastrophic consequences (for example, a plane crash and the death of everyone on board or a rocket collision with the International Space Station), flight control systems must be protected from Byzantine failures. </li><li> Some participants in the system with many participating organizations may try to cheat or deceive the rest.  In such circumstances, the node should not blindly believe messages from other nodes, since they can be sent with malicious intent.  For example, peer-to-peer networks such as Bitcoin and other block chains can be viewed as a way for non-trusting parties to agree on whether a transaction has occurred without relying on any central authority. </li></ul><br>  However, in such systems that we discuss in this book, you can usually safely assume that there are no Byzantine failures.  In your data center all nodes are monitored by your organization (so they hopefully trusted), and the radiation levels are low enough so that memory corruption does not pose a serious problem.  The protocols for creating systems that are protected from Byzantine failures are quite complex, and such embedded systems require hardware support.  In most server information systems, solutions that are protected from Byzantine failures are too expensive to make sense to use them. <br><br>  At the same time, it makes sense for web applications to expect arbitrary and malicious behavior from end-user-controlled users, such as browsers.  Therefore, validation of input data, control of correctness and screening of output are so important: for example, to prevent SQL injection (SQL injection) and cross-site scripting.  However, this does not usually apply Byzantine failures-protected protocols, and the server is simply delegated the authority to decide whether client behavior is acceptable.  In peer-to-peer networks where there is no such central authority, protection from Byzantine failures is more appropriate. <br><br>  You can consider software errors as Byzantine failures, however, if the same software is used in all nodes, then protection algorithms from Byzantine failures will not save you.  Most of these algorithms require a qualified majority of more than two-thirds of normally working nodes (that is, in the case of four nodes, a maximum of one may not work).  To solve the problem of errors with this approach, you would have to use four independent implementations of the same software and hope to have an error in only one of them. <br><br>  Similarly, it seems tempting for the protocol itself to protect us from vulnerabilities, security breaches, and malicious acts.  Unfortunately, in most systems this is unrealistic.  If an attacker manages to gain unauthorized access to a single node, it is very likely that he will be able to gain access to the others, since the same software most likely runs on them.  Therefore, traditional mechanisms (authentication, access control, encryption, firewalls, etc.) remain the main defense against attacks. <br><br>  <b>Weak forms of "lies".</b>  Although we assume that the nodes are predominantly ‚Äúfair‚Äù, it makes sense to add protection against weak forms of ‚Äúlies‚Äù to the software ‚Äî for example, incorrect messages due to hardware problems, software errors and incorrect settings.  Such mechanisms can not be considered a full-scale protection against Byzantine failures, because they can not be saved from a determined attacker, but these are simple and practical steps to increase reliability.  Here are some examples. <br><br><ul><li>  Damage to network packets sometimes occurs due to hardware problems or errors in the operating system, drivers, routers, etc. Normally, damaged packets are intercepted during checksum checks built into TCP and UDP protocols, but sometimes they avoid checking.  To detect packet corruption, simple measures are usually sufficient, for example, checksums in an application-level protocol. </li><li>  Open-to-public applications should carefully monitor the correctness of user input, for example, check if the values ‚Äã‚Äãare within the acceptable range and limit the length of the lines to avoid denial of service due to the allocation of too large amounts of memory.  For a service used internally, behind a firewall, fairly less stringent checks of the input data, but some simplest control of values ‚Äã‚Äã(for example, when parsing a protocol) will not interfere. </li><li>  NTP clients can be configured to use multiple server addresses.  During synchronization, the client accesses all of them, counts their errors and makes sure that there is a certain period of time with which most servers agree.  If most servers function normally, then an incorrectly configured NTP server that returns erroneous time is regarded as an anomaly and is excluded from synchronization.  The use of multiple servers increases the NTP protocol fault tolerance compared to a single server. </li></ul><br><h3>  System models in practice </h3><br>  To solve problems of distributed systems, many algorithms have been developed; for example, we will consider solutions for the consensus problem in Chapter 9. To bring some benefit, these algorithms must be able to cope with the various failures of distributed systems that we discussed in this chapter. <br><br>  Algorithms should as little as possible depend on the hardware and software settings of the system on which they work.  This, in turn, requires the formalization of types of probable failures.  To do this, we describe a system model ‚Äî an abstraction that describes the assumptions made by the algorithm. <br><br>  As for timing assumptions, three system models are often used. <br><br><ul><li>  Synchronous.  It implies the limitations of network delays, pauses of processes and discrepancy of hours.  This does not imply perfect clock synchronization or zero network latency, but simply means that the duration of network delays, pauses of processes and clock divergences never exceeds a certain fixed upper limit.  The synchronous model is unrealistic for most systems used in practice, since (as discussed in this chapter) unlimited delays and pauses sometimes occur. </li><li>  Partially synchronous.  It means that most of the time the system behaves as synchronous, but sometimes goes beyond the specified duration of network delays, pauses of processes and the discrepancy of hours [88].  This is quite a realistic model for most systems: most of the time, networks and processes function normally ‚Äî otherwise, nothing would work.  However, it is necessary to take into account such a fact: any assumptions regarding timekeeping are scattered into dust from time to time.  In this case, network delays, pauses, and clock errors can reach arbitrarily large values. </li><li>  Asynchronous.  In this model, the algorithm does not have the right to build any temporal assumptions - in fact, there are even no watches (so there is no concept of waiting time).  Some algorithms can be adapted for an asynchronous model, but it greatly limits the developer. </li></ul><br>  But, in addition to problems with timing, you should consider the possible failures of nodes.  Here are the three most common system models for nodes. <br><br><ul><li>  Model ‚Äúfailure - stop‚Äù.  Here, the algorithm considers that a node failure can only be fatal.  That is, the node is able to stop responding at any time, after which its work will never be resumed. </li><li>  Model "failure - recovery."  It is assumed that a node failure may occur at any time, but then the node will probably start responding again after an unknown period of time.  In this model, it is assumed: the nodes have reliable storage (that is, non-volatile storage media), in which data is not lost in case of failures (while the data in the RAM are considered lost). </li><li>  Byzantine (arbitrary) failures.  Nodes can do whatever they please, including attempts to deceive other nodes and deliberately mislead them, as described in the last subsection. </li></ul><br>  A partially synchronous model of the ‚Äúfailure - recovery‚Äù type is usually best suited for modeling real systems.  But how do distributed algorithms handle it? <br><br><h3>  Algorithm Correctness </h3><br>  To define the correctness of the algorithm, I will describe its properties.  For example, the results of the sorting algorithm have the following property: for any two different elements of the output list, the element on the left is smaller than the element on the right.  This is just a formal way of describing sorting a list. <br><br>  Similarly, the properties that are required from the correct distributed algorithm are formulated.  For example, when generating enclosing markers for blocking, the following properties may be required from the algorithm: <br><br><ul><li>  uniqueness - no two queries of the enclosing marker result in the return of the same value; </li><li>  monotonous increase in values ‚Äã‚Äã- if the query x returns the marker tx, and the query y returns the marker ty, and x ends before the start of execution y, then tx &lt;ty; </li><li>  accessibility - a node with which a fatal failure did not occur, having requested a fencing marker, eventually receives an answer to its request. </li></ul><br>  The algorithm is correct in some model of the system, provided that it always satisfies these properties in all situations capable, as we assume, of arising in this model of the system.  But does it make sense?  If a fatal crash occurs with all nodes or all network delays suddenly drag on to infinity, then no algorithm can do anything. <br><br><h3>  Functional safety and survivability </h3><br>  To clarify this situation, it is necessary to distinguish two different types of properties: functional safety (safety) and survivability (liveness).  In the example just given, the properties of uniqueness and monotonous increase in values ‚Äã‚Äãrelate to functional safety, and accessibility to survivability. <br><br>  What is the difference between these two types of properties?  Distinguishing feature: the presence in the definition of the survivability properties of the phrase ‚Äúin the end‚Äù (and yes, you are absolutely right: ultimate consistency is a tenacity property). <br><br>  Functional safety is often informally described by the phrase ‚Äúnothing bad happened,‚Äù and survivability, ‚Äúsomething good will happen over time.‚Äù  However, it is better not to get involved in such informal definitions too much, since the words ‚Äúbad‚Äù and ‚Äúgood‚Äù are subjective.  Genuine definitions of functional safety and survivability are mathematically accurate. <br><br><ul><li>  If the functional safety property is violated, then there is a specific moment in time of this violation (for example, if the uniqueness property is violated, a specific operation can be defined at which a duplicate token is returned).  In case of violation of the functional safety property, the damage has already been done, nothing can be done about it. </li><li>  The survivability property, on the contrary, may not be tied to any point in time (for example, a node could send a request, but still not receive a response), but there is always hope that it will be satisfied further (for example, by receiving a response) . </li></ul><br>  The advantage of separating functional safety and survivability properties is in simplifying work with complex system models.  In the case of distributed algorithms, it is often required that the functional safety properties are always respected, in all possible situations, of the system model.  That is, even in the case of a fatal failure of all nodes or the entire network, the algorithm must ensure that it does not return the wrong result (that is, the functional safety properties are observed). <br><br>  However, clarifications are likely for survivability properties: for example, it can be said that the response to a request should be returned only in the absence of a fatal failure of most of the nodes and if the network eventually recovered after a service interruption.  The definition of a partially synchronous model requires that the system gradually return to the synchronous state, that is, any period of network interruption lasts only a limited time, after which it is restored. <br><br><h3>  Binding system models to the real world </h3><br>  The functional safety and survivability properties, as well as system models, are very convenient for determining the correctness of a distributed algorithm.  However, when the algorithm is put into practice, the cruel reality comes into its own and it becomes clear that the system model is only a simplified abstraction of reality. <br><br>  For example, algorithms in the ‚Äúfatal failure - recovery‚Äù model usually assume that the data in reliable repositories experience fatal failures.  However, what happens if the data on the disk is corrupted or the data is erased due to a hardware error or an incorrect setting [91]?  And if the server‚Äôs firmware contains an error and it stops ‚Äúseeing‚Äù its hard disks after a reboot, although they are properly connected to the server? <br><br>  Quorum algorithms (see the ‚ÄúWriting and reading by quorum‚Äù section of the ‚ÄúWriting to the database when one of the nodes fails‚Äù section of Section 5.4) rely on the nodes to memorize data whose storage has been declared.  The possibility of ‚Äúamnesia‚Äù of a node and forgetting it of previously saved data violates the conditions of a quorum, and hence the correctness of the algorithm.  Probably, a new model of the system is needed with the assumption that reliable storage in most cases experiences fatal failures, but sometimes is capable of losing data.  However, to justify this model is more difficult. <br><br>  In the theoretical description of the algorithm, it can be declared that certain things simply should not happen - and in non-Byzantine systems we just make assumptions as to which failures can occur, and which fails.  However, in practice, the implementation sometimes requires the inclusion of code to handle the case when something supposed impossible happened, even if this processing comes down to printf (‚ÄúYou are not lucky‚Äù) and exit (666), that is, the operator will have to clean everything up. -man.  (This, according to some, is the difference between computer science and software engineering.) <br><br>  This does not mean that theoretical, abstract systems are worth nothing - just the opposite.  They are extremely useful in extracting from the entire complexity of a real system an acceptable set of failures that can be considered in order to understand the problem and try to solve it systematically.  It is possible to prove the correctness of the algorithm by demonstrating that its properties are always observed in a certain model of the system. <br><br>  The proof of the algorithm correctness does not mean that its implementation in a real system will always behave correctly.  But this is a very good first step, since a theoretical analysis will reveal problems in the algorithm that may remain hidden in the real system and manifest themselves only in the event of a collapse of assumptions (for example, regarding timing) due to some unusual circumstances.  Theoretical analysis and empirical testing are equally important. <br><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/recommend/product/vysokonagruzhennye-prilozheniya-programmirovanie-masshtabirovanie-podderzhka">the publisher's website.</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610512/978544610512_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610512/978544610512_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley 20% discount coupon - <b>Programming</b> </div><p>Source: <a href="https://habr.com/ru/post/352742/">https://habr.com/ru/post/352742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352732/index.html">Creating a simple RESTful API with Spark Framework</a></li>
<li><a href="../352734/index.html">Building an extended anti-virus protection system for a small enterprise. Part 1. Choosing a strategy and decision</a></li>
<li><a href="../352736/index.html">ActiveDirectory Integration into Aether Management Console</a></li>
<li><a href="../352738/index.html">Experimenting with AR: when C # meets CSS</a></li>
<li><a href="../352740/index.html">Fintech Digest: 70 Russians will teach the digital economy for 650 million rubles, the US tax and cryptocurrency, chatbot will get smarter</a></li>
<li><a href="../352744/index.html">Mobio Talks with Natalia Shagarina (Foodadil) about product growth, launching a cashback service and partnership with Yandex</a></li>
<li><a href="../352746/index.html">Data Center in Miniature</a></li>
<li><a href="../352748/index.html">We are looking for problems with website conversion to Google Spreadsheets</a></li>
<li><a href="../352750/index.html">Cretaceous lettering for dummies on the example of working on an art object</a></li>
<li><a href="../352752/index.html">Procedural worlds from simple tiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>