<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MySQL dacherization in Uber</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Schemaless storage system developed by Uber engineers is used in several of the most important and large services of our company (for example, Mez...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MySQL dacherization in Uber</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/8bf/909/41a/8bf90941a6d14a148f2fac95477f78a4.png"><br><br><p>  The <a href="https://eng.uber.com/schemaless-part-one/">Schemaless</a> storage system developed by Uber engineers is used in several of the most important and large services of our company (for example, <a href="https://eng.uber.com/mezzanine-migration/">Mezzanine</a> ).  Schemaless is a scalable and fault-tolerant data warehouse that runs on <a href="http://www.mysql.com/">MySQL</a> clusters.  When these clusters were 16, managing them was an easy task.  But at the moment we have more than 1,000 of them, and at least 4,000 database servers are deployed in them.  Managing such a system requires a completely different class of tools. </p><br><p>  Of the many components included in Schemadock, a relatively small, but very important part is Docker.  The transition to a more scalable solution has become a landmark event for us, and in this article we talked about how Docker helped us achieve this. </p><a name="habracut"></a><br><p>  Initially, we used <a href="https://puppet.com/">Puppet</a> , various scripts to manage all the clusters, and also did many things manually.  But the faster Uber grew and the more it became, the more difficult it was to continue using this approach.  Therefore, we began to look for more convenient tools for managing MySQL clusters.  The main requirements were as follows: </p><br><ul><li>  Work multiple database servers on the same host. </li><li>  Full automation. </li><li>  Single entry point to organize management and monitoring of all clusters in all data centers. </li></ul><br><p>  As a result, a solution was born called Schemadock.  Now our MySQL servers run in <a href="https://www.docker.com/">Docker</a> containers that are managed by target states that define the cluster topology using configuration files.  They may indicate that, for example, in cluster ‚ÄúA‚Äù there should be 3 servers, and which of them should become a master.  Applying the appropriate roles to individual servers is performed by special agent programs.  The unified service monitors the target states of all servers and in case of deviations from the norm performs the necessary actions to correct the situation. </p><br><h2 id="pochemu-docker">  Why docker? </h2><br><p>  Containers simplify the task of running multiple MySQL processes with different versions and configurations on the same host.  It also allows several small clusters to be located on the same machine, which ultimately makes it possible to use a smaller number of hosts with the same number of clusters.  Finally, we no longer depend on Puppet and have the same host settings. </p><br><p>  As for Docker himself: at present, our engineers create all stateless services based on it, so we know this system well.  Of course, it is not perfect, but at the moment it is the best alternative for us. </p><br><h3 id="chto-est-pomimo-docker">  What is in addition to Docker? </h3><br><p>  The alternatives to Docker are as follows: full virtualization, <a href="https://linuxcontainers.org/">LXC containers</a> , as well as managing MySQL processes directly using, for example, Puppet.  We didn‚Äôt choose for a very long time, because Docker had the best fit to the existing infrastructure.  However, if we had not used Docker before, its implementation only for MySQL could be a rather large project, for which it would be necessary to master the creation and distribution of images, monitoring and updating Docker itself, collecting logs, networking features, and much more. . </p><br><p>  This means that a Docker deployment requires resources and time.  Moreover, Docker should be considered as a technology and should not be expected to solve all problems from it.  We at Uber have very carefully approached the design of the MySQL database management system, where Docker is only one of the components.  But not all companies have reached the scale of Uber, so they can better approach the option using Puppet, <a href="https://en.wikipedia.org/wiki/Ansible_(software)">Ansible</a> or similar software. </p><br><h2 id="obraz-dlya-schemaless">  Image for Schemaless </h2><br><p>  Basically, our image only loads and installs <a href="https://www.percona.com/software/mysql-database/percona-server">Percona Server</a> , and it also starts <a href="http://dev.mysql.com/doc/refman/5.7/en/mysqld.html">mysqld</a> - almost the same thing that a standard Docker image with MySQL does onboard.  However, several more operations are performed between download and installation. </p><br><ul><li>  If there is no data on the mounted volume, then an initial download is required.  For the master we start mysql_install_db, and also we create several standard users and tables.  For a replica (minion in the terminology of Uber - approx. Transfer), we start loading data from a backup or another node in the cluster. </li><li>  Mysqld will be launched immediately after the data has been loaded. </li><li>  If copying data for some reason does not end, the container will be stopped. </li></ul><br><p>  The role of the container is set using environment variables.  It is worth paying attention to the data acquisition mechanism - the image itself does not contain any logic for setting up replication topologies, status checking, etc. Since this logic changes more often than MySQL itself, it is very reasonable to separate them. </p><br><p>  The MySQL data directory is mounted from the host's file system, which means there is no record-based overhead for the Docker.  We still write the MySQL configuration into the image, which makes it unbutable.  Although the configuration itself can be edited, these changes will never take effect, since we do not reuse the containers.  If the container stops for any reason, it will not be used again.  We delete the container, create a new one from the most recent image, using the same parameters (or new if the target state has changed since then), and run it. </p><br><p>  This approach gives us the following benefits: </p><br><ul><li>  It becomes much easier to control the configuration drift.  The problem comes down to the version numbers of the Docker images, which we monitor closely. </li><li>  Much easier to update MySQL.  We create a new image, and then stop the containers in order. </li><li>  If something breaks, it just restarts.  We remove the problematic container and start a new one without trying to repair anything. </li></ul><br><p>  The same infrastructure is used for creating images, which ensures the operation of stateless-services.  It also replicates the images between data centers to make them available in local registries. </p><br><p>  There are drawbacks in the work of several containers on one host.  Since there is no normal I / O isolation between containers, any of them can use all the bandwidth of the I / O system, which will adversely affect the work of other containers.  I / O quotas appeared in Docker 1.10, but we have not yet had time to experiment with them.  While we are struggling with this problem by controlling the number of containers on the host and constantly monitor the performance of each database. </p><br><h2 id="nastroyka-konteynerov-i-topologiy">  Configuring containers and topologies </h2><br><p>  Now that we have a Docker image that can be configured as a master or replica, something needs to run the containers and configure the required replication topology on them.  To do this, a special agent is launched on each host, which receives end-state information for all databases.  A typical description of the final state is as follows: </p><br><pre><code class="hljs pgsql">‚Äúschemadock01-mezzanine-mezzanine-us1-cluster8-db4‚Äù: { ‚Äúapp_id‚Äù: ‚Äúmezzanine-mezzanine-us1-cluster8-db4‚Äù, ‚Äústate‚Äù: ‚Äústarted‚Äù, ‚Äúdata‚Äù: { ‚Äúsemi_sync_repl_enabled‚Äù: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, ‚Äú<span class="hljs-type"><span class="hljs-type">name</span></span>‚Äù: ‚Äúmezzanine-us1-cluster8-db4‚Äù, ‚Äúmaster_host‚Äù: ‚Äúschemadock30‚Äù, ‚Äúmaster_port‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúdisabled‚Äù: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>‚Äù: ‚Äúminion‚Äù, ‚Äúport‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúsize‚Äù: ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>‚Äù } }</code> </pre> <br><p>  Here it says that one replica of the <a href="https://eng.uber.com/mezzanine-migration/">Mezzanine</a> database (port 7335) must be running on the schemadock01 host; the base for the schemadock30: 7335 should become the master for it.  The size parameter is set to all.  This means that this database is the only one on schemadock01, and it must use all the available memory. </p><br><p>  The procedure for creating such a description of the target state is a topic for a separate publication, so we move on to the next steps: an agent running on a host receives and stores the description of the target state locally, and then starts processing it. </p><br><p>  Processing is an infinite loop that runs every 30 seconds (something like Puppet running every half minute).  The loop checks the compliance of the current and target states.  For this, the following actions are performed: </p><br><ol><li>  Check if the container is running.  If not, create and run. </li><li>  Check container replication topology.  If something is wrong with her, try to fix it. <br><ul><li>  If it is a replica, but must be a master, make sure that the role change is safe.  To do this, check whether the current master read-only status is set, and also whether all <a href="https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html">GTIDs are</a> received and applied.  If all conditions are met, you can remove the link to the previous wizard and enable the ability to record. </li><li>  If it is a master that should be disabled, enable read-only mode. </li><li>  If it is a replica, but replication is not performed, set up replication. </li></ul></li><li>  Check various MySQL parameters (read_only and super_read_only, sync_binlog, etc.) according to the base role.  On the wizards, write must be enabled, replicas must be read_only, etc. Moreover, we reduce the load on replicas by turning off binlog fsync and similar parameters¬≤. </li><li>  Start or stop all ancillary containers, such as <a href="https://www.percona.com/doc/percona-toolkit/2.1/pt-heartbeat.html">pt-heartbeat</a> and <a href="https://www.percona.com/doc/percona-toolkit/2.1/pt-deadlock-logger.html">pt-deadlock-logger</a> . </li></ol><br><p>  It is important to note that we are convinced supporters of the idea of ‚Äã‚Äã‚Äúone process - one goal - one container‚Äù.  In this case, we do not have to reconfigure working containers, and the upgrade is also much easier. </p><br><p>  If any error occurs, the process generates a corresponding message and ends, and the whole procedure is repeated again during the next attempt.  We try to configure the system in such a way as to minimize the need for coordination between agents.  This means that we do not care about the order when initializing a new cluster, for example.  If you do this operation manually, then you need to perform about the following steps: </p><br><ul><li>  create a mysql master and wait until it is ready to work, </li><li>  create the first replica and connect it to the master, </li><li>  repeat the previous paragraph for the remaining replicas. </li></ul><br><p>  In the end, something like this is still happening.  But at the same time, we absolutely do not care about the order in which the steps are taken.  We only create target states that describe the configuration we need: </p><br><pre> <code class="hljs pgsql">‚Äúschemadock01-mezzanine-cluster1-db1‚Äù: { ‚Äúdata‚Äù: { ‚Äúdisabled‚Äù: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>‚Äù: ‚Äúmaster‚Äù, ‚Äúport‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúsize‚Äù: ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>‚Äù } }, ‚Äúschemadock02-mezzanine-cluster1-db2‚Äù: { ‚Äúdata‚Äù: { ‚Äúmaster_host‚Äù: ‚Äúschemadock01‚Äù, ‚Äúmaster_port‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúdisabled‚Äù: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>‚Äù: ‚Äúminion‚Äù, ‚Äúport‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúsize‚Äù: ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>‚Äù } }, ‚Äúschemadock03-mezzanine-cluster1-db3‚Äù: { ‚Äúdata‚Äù: { ‚Äúmaster_host‚Äù: ‚Äúschemadock01‚Äù, ‚Äúmaster_port‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúdisabled‚Äù: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">role</span></span>‚Äù: ‚Äúminion‚Äù, ‚Äúport‚Äù: <span class="hljs-number"><span class="hljs-number">7335</span></span>, ‚Äúsize‚Äù: ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>‚Äù } }</code> </pre> <br><p>  This information is sent to the appropriate agents in random order, and they begin to perform the task.  To achieve the target state, depending on the order, it may take several attempts.  Usually there are not many of them, but some operations are restarted hundreds of times.  For example, if the replicas start up first, they will not be able to connect to the master and will have to try to do it again and again until it comes online (which can take a long time): </p><br><img src="https://habrastorage.org/files/2dc/417/ddb/2dc417ddb3e14326a7306043fc59c735.png"><br><p>  <em>An example in which two replicas started before the master.</em>  <em>In steps 1 and 2, they will not be able to get a snapshot from the wizard, so the startup process will fail.</em>  <em>When the wizard finally starts (in step 3), the replicas will be able to connect and synchronize the data (steps 4 and 5).</em> </p><br><h2 id="rabota-v-srede-docker">  Work in the Docker environment </h2><br><p>  Most of our hosts have Docker 1.9.1 installed with devicemapper on <a href="https://en.wikipedia.org/wiki/Logical_Volume_Manager_(Linux)">LVM</a> .  Using LVM for devicemapper turned out to be a more productive solution than loopback.  Devicemapper has a lot of performance and reliability issues, but alternatives such as <a href="https://en.wikipedia.org/wiki/Aufs">AuFS</a> and <a href="https://en.wikipedia.org/wiki/OverlayFS">OverlayFS</a> are also far from ideal¬≥.  The community could not decide for a long time which variant of storage organization is better.  But lately, more and more voices have been voiced in favor of OverlayFS, which also seems to have stabilized, so we are going to switch to this file system and at the same time upgrade to Docker 1.12.1. </p><br><p>  One of the disadvantages of Docker is the requirement to restart containers when the service is restarted.  This means that we need to control the update process, as we will not have working wizards during the update of the host.  Fortunately, Docker v1.12 added the option to reboot and update the daemon without restarting the containers, so we hope that we will have to deal with this problem for the last time. </p><br><p>  In every next version of Docker, there are a lot of improvements and new features, as well as a decent amount of errors.  1.12.1 seems to be better than the previous ones, but we still face certain problems: </p><br><ul><li>  Sometimes the docker inspect hangs after the Docker has been working non-stop for several days. </li><li>  Using bridge networking with <a href="https://docs.docker.com/engine/reference/commandline/dockerd/">userland proxy</a> leads to strange behavior when terminating TCP connections.  Client connections sometimes do not receive the RST signal and remain open regardless of the timeout set. </li><li>  Container processes are sometimes reassigned to pid 1 (init), and Docker loses them. </li><li>  There are regular cases when the Docker daemon creates new containers for a very long time. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  We began by defining a list of requirements for a storage cluster management system in Uber: </p><br><p>  1) several containers on one host, <br>  2) automation, <br>  3) single entry point. </p><br><p>  Now we can perform daily maintenance using a single user interface and simple tools, none of which require direct access to hosts: </p><br><img src="https://habrastorage.org/files/b72/41d/ddb/b7241dddb56f40f58e161b3977ab71f1.gif"><br><p>  <em>Screenshot of our management console.</em>  <em>Here you can see the process of reaching the target state: in this case, we divide the cluster into two parts, first adding the second cluster, and then breaking the replication link.</em> </p><br><p>  Due to running multiple containers on the same host, we more fully use computing resources.  It became possible to perform a controlled update of the entire fleet.  With the help of Docker, we quickly managed to achieve this.  Docker also allows you to start the installation of the entire cluster in a test environment, which can be used to test various operational procedures. </p><br><p>  We started the migration to Docker in early 2016, and now we have about 1,500 Docker production servers running (for MySQL only), which have about 2,300 MySQL databases deployed. </p><br><p>  There are many other components in Schemadock, but Docker helped us a lot.  With him, we got the opportunity to quickly move forward, experimenting a lot in close connection with the existing Uber infrastructure.  The travel repository, which adds several million entries per day, is now based on documented MySQL databases (shared with other information repositories).  In other words, now without Docker, Uber users literally will not get far. </p><br><p>  <em>Joakim Recht is a full-time software engineer at Uber Engineering's Aarhus office, as well as Schemaless infrastructure automation engineering.</em> </p><br><hr><br><p>  ¬π To be precise, Percona Server 5.6 </p><br><p>  ¬≤ sync_binlog = 0 and innodb_flush_log_at_trx_commit = 2 </p><br><p>  ¬≥ A small collection of problems: <a href="https://github.com/docker/docker/issues/16653">https://github.com/docker/docker/issues/16653</a> , <a href="https://github.com/docker/docker/issues/15629">https://github.com/docker/docker/issues/15629</a> , <a href="https://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/">https://developerblog.redhat.com/2014/09 / 30 / overview-storage-scalability-docker /</a> , <a href="https://github.com/docker/docker/issues/12738">https://github.com/docker/docker/issues/12738</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322142/">https://habr.com/ru/post/322142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322130/index.html">Testing the Documented API with the Apiary Dredd Utility</a></li>
<li><a href="../322132/index.html">Detailed introduction to rvalue links for those who lacked a short</a></li>
<li><a href="../322134/index.html">[Bughunting] Blind XSS vulnerability on omnidesk support sites</a></li>
<li><a href="../322138/index.html">The worst technological forecasts for the last 150 years</a></li>
<li><a href="../322140/index.html">Graphic description of ownership and borrowing in Rust</a></li>
<li><a href="../322144/index.html">How to save the project from closing, having understood with MySQL</a></li>
<li><a href="../322146/index.html">Introducing 3CX V15 SP5 Beta and New Subscription Annual Licenses</a></li>
<li><a href="../322150/index.html">Public Data Management: Receipt and Use</a></li>
<li><a href="../322152/index.html">The digest of interesting materials for the mobile # 191 developer (February 13-19)</a></li>
<li><a href="../322154/index.html">Finnish schools: myths in the international press, context features and new technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>