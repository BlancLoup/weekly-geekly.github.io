<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do not make listeners to reflect</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 



 In the development process, it is often necessary to create an instance of a class whose name is stored in the XML configuration fil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do not make listeners to reflect</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vvedenie">  Introduction </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br>  In the development process, it is often necessary to create an instance of a class whose name is stored in the XML configuration file, or to call a method whose name is written as a string as the value of the annotation attribute.  In such cases, the answer is one: ‚ÄúUse reflection!‚Äù. </p><br><p>  In the new version of the <a href="http://cuba-platform.com/">CUBA Platform,</a> one of the tasks to improve the framework was to get rid of the explicit creation of event handlers in the controller classes of UI screens.  In previous versions, the declarations of handlers in the controller's initialization method were very cluttering up the code, so in the seventh version we decided to clean everything from there. </p><a name="habracut"></a><br><p> An event listener is just a reference to the method that you need to call at the right time (see <a href="https://en.wikipedia.org/wiki/Observer_pattern">the Observer template</a> ).  Such a template is quite simple to implement using the <code>java.lang.reflect.Method</code> class.  At the start, you just need to scan the classes, pull out annotated methods from them, save references to them, and use references to call the method (or methods) when an event occurs, as is done in the bulk of frameworks.  The only thing that stopped us is that a lot of events are traditionally generated in the UI, and when using the reflection API you have to pay some price in the form of method call time.  Therefore, we decided to look at how you can still make event handlers without using reflection. </p><br><p>  We have already published on Habr√© materials about <a href="https://habr.com/ru/company/haulmont/blog/431922/">MethodHandles</a> and <a href="https://habr.com/ru/company/haulmont/blog/432418/">LambdaMetafactory</a> , and this material is a kind of continuation.  We will consider the pros and cons of using the reflection API, as well as alternatives - code generation with AOT compilation and LambdaMetafactory, and how it was applied in the CUBA framework. </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy">  Reflection: Old.  Kind.  Reliable </h2><br><p>  <em>In computer science, reflection or reflection (holonim of introspection, English reflection) means a process during which a program can monitor and modify its own structure and behavior at run time.</em>  (c) Wikipedia. </p><br><p>  For most Java developers, reflection is never a new thing.  It seems to me that without this mechanism, Java would not have become the Java, which now occupies a large market share in the development of application software.  Just think: proxying, binding methods to events through annotations, dependency injection, aspects, and even instantiating the JDBC driver in the very first versions of the JDK!  Reflection everywhere is the cornerstone of all modern frameworks. </p><br><p>  Are there any problems with Reflection in relation to our task?  We identified three: </p><br><p>  <em>Speed</em> - calling a method via the Reflection API is slower than a direct call.  In each new version of JVM, developers all the time speed up calls through reflection, the JIT compiler tries to optimize the code even more, but the difference is still noticeable compared to a direct method call. </p><br><p>  <em>Typing</em> - if you use <code>java.lang.reflect.Method</code> in code, then this is just a link to some method.  And nowhere is it written how many parameters are transmitted and what type they are.  A call with incorrect parameters will generate an error at runtime, and not at the stage of compiling or loading the application. </p><br><p>  <em>Transparency</em> - if the method called through reflection falls down with an error, then we will have to wade through several <code>invoke()</code> calls before we get to the real cause of the error. </p><br><p>  But if we look at the code of the event handlers Spring or JPA callbacks in Hibernate, then there will be good old <code>java.lang.reflect.Method</code> inside.  And in the near future, I think this is unlikely to change.  These frameworks are too large and too much is tied to them, and it seems that the server-side event handlers have enough performance to think about what to replace calls through reflection. </p><br><p>  What other options are there? </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  AOT compilation and code generation - return speed to applications! </h2><br><p>  The first candidate to replace the reflection API is code generation.  Now frameworks such as <a href="https://micronaut.io/">Micronaut</a> or <a href="https://quarkus.io/">Quarkus</a> have begun to appear, which are trying to solve two problems: reducing the launch speed of the application and reducing memory consumption.  These two metrics are vital in our age of containers, microservices and serverless architectures, and new frameworks are trying to solve this by AOT compilation.  Using different techniques (you can read <a href="https://medium.com/%40mesirii/ad-astra-the-micronaut-framework-52ff2d684877">here</a> , for example), the application code is modified in such a way that all reflexive calls to methods, constructors, etc.  replaced by direct calls.  Thus, you do not need to scan classes and create bins at the time of launching the application, and JIT more effectively optimizes the code at runtime, which gives a significant increase in the performance of applications built on such frameworks.  Does this approach have disadvantages?  The answer: of course, is. </p><br><p>  First, you run the wrong code you wrote. The source code changes during compilation, so if something goes wrong, it is sometimes difficult to understand where the error is: in your code or in the generation algorithm (usually, in your code, of course ).  And the debugging problem follows from here - debugging does not have to be your code. </p><br><p>  The second is that you need a special tool to run an application written on the framework with AOT compilation.  You can not just take and run an application written in Quarkus, for example.  You need a special plugin for maven / gradle, which will pre-process your code.  And now, in case of detection of errors in the framework, you need to update not only the library, but also the plugin. </p><br><p>  Truth be told, code generation is also not news in the Java world, it did not appear with <a href="https://micronaut.io/">Micronaut</a> or <a href="https://quarkus.io/">Quarkus</a> .  In one form or another, some frameworks use it.  Here you can recall lombok, aspectj with its preliminary code generation for aspects, or eclipselink, which adds code to the entity classes for more efficient deserialization.  In <a href="http://cuba-platform.com/">CUBA,</a> we use code generation to generate entity state change events and to include validator messages in class code to simplify work with entities in the UI. </p><br><p>  For CUBA developers, implementing static code generation for event handlers would be a somewhat extreme step, because a lot of changes had to be made in the internal architecture and in the plugin to generate code.  Is there something that looks like reflection, but faster? </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory - the same method calls, but faster </h2><br><p>  In Java 7, a new instruction for JVM - <code>invokedynamic</code> .  About her there is an excellent report by Vladimir Ivanov on jug.ru <a href="https://www.youtube.com/watch%3Fv%3DDgshYDTpS9I">here</a> .  Originally conceived for use in dynamic languages ‚Äã‚Äãlike Groovy, this instruction has become an excellent candidate to invoke methods in Java without using reflection.  Simultaneously with the new instruction, the associated API appeared in the JDK: </p><br><ul><li>  The <code>MethodHandle</code> class appeared in Java 7, but is still not used very often. </li><li>  <code>LambdaMetafactory</code> - this class is already from Java 8, it became a further development of the API for dynamic calls, uses <code>MethodHandle</code> inside. </li></ul><br><p>  It seemed that <code>MethodHandle</code> , in essence being a typed pointer to a method (constructor, etc.), would be able to perform the role of <code>java.lang.reflect.Method</code> .  And the calls will be faster, because all type-matching checks that are executed in the Reflection API on each call, in this case, are performed only once, when creating <code>MethodHandle</code> . </p><br><p>  But alas, the pure <code>MethodHandle</code> was even slower than calls through the reflection API.  You can achieve better performance if you make the <code>MethodHandle</code> static, but not in all cases it is possible.  There is a great discussion about the speed of <code>MethodHandle</code> calls <a href="http://mail.openjdk.java.net/pipermail/mlvm-dev/2018-February/006806.html">on the OpenJDK mailing list</a> . </p><br><p>  But when the <code>LambdaMetafactory</code> class <code>LambdaMetafactory</code> , there was a real chance to speed up method calls.  <code>LambdaMetafactory</code> allows <code>LambdaMetafactory</code> to create a lambda object and wrap a direct method call in it, which can be obtained through <code>MethodHandle</code> .  And then, using the generated object, you can call the desired method.  Here is an example of generation that ‚Äúwraps‚Äù the getter method passed as a parameter in BiFunction: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p>  As a result, we get a copy of BiFunction instead of Method.  And now, even if we used Method in our code, then replacing it with BiFunction is not difficult.  Take the real (slightly simplified, true) code calling the method handler marked with the Spring Framework <code>@EventListener</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p>  And here is the same code, but which uses the method call via lambda: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p>  Minimal changes, functionality is the same, but there are advantages: </p><br><p>  <em>Lambda has a type</em> - it is specified when creating it, so calling ‚Äújust a method‚Äù will not work. </p><br><p>  <em>The stack of the trace is shorter</em> - when calling a method via lambda, only one additional call is added ‚Äî <code>apply()</code> .  And that's all.  The method itself is then called. </p><br><p>  But the speed must be measured. </p><br><h3 id="zameryaem-skorost">  Measure the speed </h3><br><p>  To test the hypothesis, we made a micro-benchmark using <a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH</a> to compare execution time and throughput when calling the same method in different ways: through the reflection API, through the LambdaMetafactory, and also added a direct method call for comparison.  References to Method and lambda were created and cached before running the test. </p><br><p>  Test parameters: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p>  The test itself can be downloaded from <a href="https://github.com/cuba-rnd/entity-lambda-accessors-benchmark">GitHub</a> and run it yourself if interested. </p><br><p>  Test results for Oracle JDK 11.0.2 and JMH 1.21 (numbers may differ, but the difference remains noticeable and about the same): </p><br><table><thead><tr><th>  <strong>Test - Get Value</strong> </th><th>  <strong>Throughput (ops / us)</strong> </th><th>  <strong>Execution Time (us / op)</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0.0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65 </td><td>  0.0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0.0048 </td></tr><tr><td>  <strong>Test - Set Value</strong> </td><td>  <strong>Throughput (ops / us)</strong> </td><td>  <strong>Execution Time (us / op</strong> </td></tr><tr><td>  Lambdasettest </td><td>  96 </td><td>  0.0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0.0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0.0031 </td></tr></tbody></table><br><p>  On average, it turned out that the method call via lambda is about 30% faster than through the reflection API.  There is another great discussion about the performance of calling methods <a href="https://www.mail-archive.com/mlvm-dev%40openjdk.java.net/msg06747.html">here</a> , if someone is interested in details.  In short, the speed gain is also due to the fact that the generated lambdas can be inlined in the program code, and type checks are not performed yet, unlike reflection. </p><br><p>  Of course, this benchmark is pretty simple; it does not include calling methods over a class hierarchy or measuring the speed of calling final methods.  But we did more complex measurements, and the results were always in favor of using the LambdaMetafactory. </p><br><h2 id="ispolzovanie">  Using </h2><br><p>  In the CUBA version 7 framework, in the UI controllers, you can use the <code>@Subscribe</code> annotation to ‚Äúsign‚Äù a method for certain user interface events.  Inside it is implemented on the <code>LambdaMetafactory</code> , references to methods-listeners are created and cached upon the first call. </p><br><p>  This innovation made it possible to greatly clean the code, especially in the case of forms with a large number of elements, complex interactions and, accordingly, with a large number of event handlers.  A simple example from CUBA QuickStart: Imagine that you need to recalculate the order amount when adding or deleting items of goods.  You need to write code that runs the <code>calculateAmount()</code> method when the collection changes in essence.  How it looked before: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p>  And in CUBA 7, the code looks like this: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p>  The bottom line: the code is cleaner and there is no magic <code>init()</code> method that tends to grow and fill with event handlers as the complexity of the form increases.  And also - we don‚Äôt even need to make a field with a component to which we subscribe, CUBA will find this component by ID. </p><br><h3 id="vyvody">  findings </h3><br><p>  Despite the emergence of a new generation of frameworks with AOT compilation ( <a href="https://micronaut.io/">Micronaut</a> , <a href="https://quarkus.io/">Quarkus</a> ), which have indisputable advantages over ‚Äútraditional‚Äù frameworks (basically, they are compared to <a href="https://spring.io/">Spring</a> ), there is still a huge amount of code in the world, which is written using the reflection API (and for this thanks to all the same Spring).  And it seems that the Spring Framework is currently still the leader among the frameworks for application development and we will work with reflection-based code for a long time. </p><br><p>  And if you are thinking about using the Reflection API in your code - whether it is an application or a framework - think twice.  First, about code generation, and then about MethodHandles / LambdaMetafactory.  The second method may be faster, and the development effort will be spent no more than when using the Reflection API. </p><br><p>  <em>Some more useful links:</em> <br>  <a href="https://medium.freecodecamp.org/a-faster-alternative-to-java-reflection-db6b1e48c33e">A faster alternative to Java Reflection</a> <br>  <a href="https://dzone.com/articles/hacking-lambda-expressions-in-java">Hacking Lambda Expressions in Java</a> <br>  <a href="https://www.baeldung.com/java-method-handles">Method Handles in Java</a> <br>  <a href="https://www.optaplanner.org/blog/2018/01/09/JavaReflectionButMuchFaster.html">Java Reflection, but much faster</a> <br>  <a href="https://www.mail-archive.com/mlvm-dev%40openjdk.java.net/msg06746.html">Why is LambdaMetafactory 10% slower than a static MethodHandle but 80% faster than a non-static MethodHandle?</a> <br>  <a href="http://insightfullogic.com/2014/May/12/fast-and-megamorphic-what-influences-method-invoca/">Too Fast, Too Megamorphic: what influences method call performance in Java?</a> <br></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/447022/">https://habr.com/ru/post/447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447010/index.html">Not long the music played ... or as OS Elbrus did not become free</a></li>
<li><a href="../447014/index.html">Disposable ref structs in C # 8.0</a></li>
<li><a href="../447016/index.html">25 years later: an interview with Linus Torvalds</a></li>
<li><a href="../447018/index.html">Quantum enrichment in a multi-world interpretation</a></li>
<li><a href="../447020/index.html">Productivity is not about time management, but about attention management.</a></li>
<li><a href="../447024/index.html">How to combine the benefits of a laptop and a desktop computer? Analysis of problems and ideas solutions</a></li>
<li><a href="../447026/index.html">Writing an OTA-downloader for ATmega128RFA1 (as part of the Smart Response XE device)</a></li>
<li><a href="../447028/index.html">Steganography past files: hiding data right in the sectors</a></li>
<li><a href="../447034/index.html">New bug in Telegram Desktop allows you to read the latest message.</a></li>
<li><a href="../447036/index.html">Cocktail for healthy eating - it is made by a startup from the accelerator of ITMO University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>