<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Execution Threads and PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP and threads of execution (threads). A sentence of just four words, and you can write a book on this topic. As usual, I will not do that, but I wil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Execution Threads and PHP</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/af5/d7f/ab9/af5d7fab9b264452b4c70cf40da576f3.jpg"></p><br><p>  PHP and threads of execution (threads).  A sentence of just four words, and you can write a book on this topic.  As usual, I will not do that, but I will give you information so that you can understand the subject to a certain extent. </p><br><p>  Let's start with the confusion that is in the minds of some programmers.  PHP is not a multi-threaded language.  Inside PHP itself, no execution threads are used, and PHP does not allow custom code to natively use them as a parallelization mechanism. </p><br><p>  PHP is very far from other technologies.  For example, in Java, execution threads are very actively used; they can also be found in user programs.  There is no such thing in PHP.  And for good reason. </p><a name="habracut"></a><br><p>  The PHP engine dispenses with threads of execution mainly for the sake of simplicity.  After reading the next section, you will learn that execution threads are not ‚Äúmagic technology that allows you to speed up the work of any program.‚Äù  Looks like a seller speech, right?  But we are not merchants - we are techies, and we know what we are talking about.  There are currently no threads in the PHP engine.  Perhaps in the future they will appear.  But it will entail so many difficulties that the result may be far from expected.  The main difficulty is cross-platform multithreaded programming (thread programming).  The second difficulty is shared resources and lock management.  The third is that execution threads are not suitable for every program.  PHP architecture originated around 2000, and at that time, streaming programming was rare and immature.  Therefore, the authors of PHP (mainly Zend engine) decided to make a whole engine without threads.  Yes, and they did not have the necessary resources to create a stable cross-platform multi-threaded engine. </p><br><p>  In addition, threads cannot be applied in PHP user space.  This language does not do the code.  The concept of PHP is ‚Äúshot and forget‚Äù.  The request should be processed as quickly as possible in order to free PHP for the next request.  PHP is created as a binding language: you do not handle complex tasks that require threads.  Instead, contact fast-and-ready resources, tie everything together and send it back to the user.  PHP is an action language, and if something requires the processing of ‚Äúmore time than usual‚Äù, then it should be done not in PHP.  Therefore, a system based on queues (Gearman, AMQP, ActiveMQ, etc.) is used for asynchronous processing of some heavy tasks.  In Unix, it‚Äôs customary to do this: "Develop small, self-sufficient tools and link them together."  PHP is not designed for active parallelization, it is a lot of other technologies.  Every problem is the right tool. </p><br><h2 id="neskolko-slov-o-potokah-vypolneniya">  A few words about the threads </h2><br><p>  Let's refresh what the execution threads are.  We will not go into details, you will find them in the Internet and books. </p><br><p>  The execution flow is a ‚Äúsmall‚Äù processing unit (light unit of work treatment) that is inside the process.  A process can create multiple threads of execution.  A thread must be part of only one process.  The process is a ‚Äúbig‚Äù processing unit within the operating system.  On multi-core (multiprocessor) computers, several cores (processors) work in parallel and process part of the load of executable tasks.  If processes A and B are ready for queuing and two cores (processors) are ready for operation, then A and B should be simultaneously sent for processing.  Then the computer effectively handles several tasks per unit of time (time interval, timeframe).  We call it "parallelism." </p><br><p>  Process: </p><br><p><img src="https://habrastorage.org/web/509/7f2/528/5097f2528da14d9282cae98659050477.png" alt="image"></p><br><p>  The flow of execution: </p><br><p><img src="https://habrastorage.org/web/c59/e85/438/c59e85438b844f4884c7f12d08c373b1.png" alt="image"></p><br><p>  Together: </p><br><p><img src="https://habrastorage.org/web/07f/2ca/1f2/07f2ca1f2963493a9f9bcc8ae239606b.png" alt="image"></p><br><p>  Previously, A and B were processes: completely independent handlers.  But execution threads are not processes.  Threads are units that live within processes.  That is, the process can distribute work across several smaller tasks that are performed simultaneously.  For example, processes A and B can generate flows A1, A2, B1 and B2.  If a computer is equipped with several processors, for example, eight, then all four threads can run in one time interval (timeframe). </p><br><p>  Execution threads are a way to divide the work of a process into several small subtasks solved in parallel (in the same time interval).  Moreover, the threads run in much the same way as the processes: the kernel program flow manager (Kernel thread scheduler) manages the threads using states. </p><br><p><img src="https://habrastorage.org/web/a6d/ce2/373/a6dce2373c48423f9826590890bb69da.png" alt="image"></p><br><p>  Execution threads are easier processes, they only need a stack and a few registers for work.  And processes need a lot of things: a new virtual machine frame (VM frame) from the kernel, a heap, different signaling information, information about file descriptors, locks, etc. </p><br><p>  The process memory is managed at the hardware level by the kernel and the MMU, and the thread execution memory is controlled at the program level by the programmer and the threading libraries. </p><br><p>  <em>So remember: execution threads are easier processes and easier to manage.</em>  <em>With proper use, they also run faster than processes, since the OS kernel almost does not interfere with thread management and dispatching.</em> </p><br><h2 id="shema-pamyati-potokov-vypolneniya">  Thread memory layout </h2><br><p>  Threads have their own stack.  Therefore, when accessing variables declared in functions, they receive their own copy of this data. </p><br><p>  The process heap is shared between threads, like global variables, and file descriptors.  This is both an advantage and a disadvantage.  If we only read from the global memory, then we need to do it on time.  For example, after the stream X and before the stream Y. If we write to the global memory, then we should make sure that we will not try to write several streams there either at the same time.  Otherwise, this memory region will be in an unpredictable state - the so-called <strong>race condition</strong> .  This is the main problem in streaming programming. </p><br><p>  In case of simultaneous access, you need to implement some mechanisms in the code, such as reentrancy or synchronization routine.  Re-entry violates concurrency.  And synchronization allows you to manage consistency in a predictable way. </p><br><p>  <em>Processes do not share memory, they are perfectly isolated at the OS level.</em>  <em>And execution threads within one process share a <strong>large amount of</strong> memory.</em> </p><br><p>  Therefore, they need tools to synchronize access to shared memory, such as semaphores and mutexes.  The operation of these tools is based on the principle of ‚Äúblocking‚Äù: if a resource is locked and the thread tries to access it, then by default the thread will wait for the resource to unlock.  Therefore, execution threads alone will not make your program faster.  Without efficiently allocating tasks to threads and managing shared memory locks, your program will run even slower than using a single process without threads.  It‚Äôs just that streams will constantly wait for each other (and I‚Äôm not even talking about deadlocks, fasting, etc.). </p><br><p>  <strong>If you have no experience in streaming programming, then it will be a difficult task for you.</strong>  To gain experience with threads of execution, it will take many hours of practice and solutions to WTF moments.  It is worth forgetting about some trifles - and the whole program will go into the dressing.  It is more difficult to debug a program with threads than without them if we are talking about real projects with hundreds or thousands of threads in one process.  You will go crazy and just drown in all this. </p><br><p>  <em>Stream programming is a difficult task.</em>  <em>To become a master, you need to spend a lot of time and effort.</em> </p><br><p>  Such a flow sharing scheme is not always convenient.  Therefore, a local thread storage (TLS) appeared.  TLS can be described as "globals belonging to one stream and not used by others."  These are memory areas that reflect a global state, private for a particular flow of execution (as in the case of using processes alone).  When creating a thread, a part of the process heap is allocated - the storage.  The stream library is queried for a key that is associated with this repository.  It must be used by the execution thread each time it accesses its repository.  To destroy the allocated resources at the end of the life of the thread requires a destructor. </p><br><p>  <em>An application is thread safe if every access to global resources is under complete control and is completely predictable.</em>  <em>Otherwise, the dispatcher (scheduler) will cross you the road: some tasks will unexpectedly be executed and the productivity will fall.</em> </p><br><h2 id="potokovye-biblioteki">  Stream libraries </h2><br><p>  Threads need the help of the OS kernel.  In operating systems, execution threads appeared in the mid-1990s, so the techniques for working with them are polished. </p><br><p>  But there are cross-platform issues.  There are especially many differences between Windows and Unix systems.  In these ecosystems, different models of stream execution are adopted and different stream libraries are used. </p><br><p>  In Linux, the kernel makes the clone () system call to create a thread or process.  But it is incredibly complex, so system calls use C code to facilitate everyday streaming programming.  The libc still does not control streaming operations (the standard library from C11 demonstrates such an initiative), external libraries are involved in this.  Today, Unix systems typically use <strong>pthread</strong> (there are other libraries as well).  Pthread is an abbreviation for Posix threads.  This POSIX normalization of the use of threads and their behavior dates back to 1995.  If you need execution threads, include the libpthread library: pass to GCC <em>-lpthread</em> .  It is written in C, its <a href="http://git.savannah.gnu.org/cgit/hurd/libpthread.git/tree/">code is open</a> , it has its own version control and management mechanism. </p><br><p>  So, in Unix-systems the <strong>pthread</strong> library is most often used.  It provides consistency (concurrency), and concurrency depends on the specific OS and computer. </p><br><p>  Consistency is when multiple threads are randomly executed on a single processor.  Parallelism is when multiple threads run simultaneously on different processors. </p><br><p>  Consistency: </p><br><p><img src="https://habrastorage.org/web/73c/afc/6c4/73cafc6c4f3040c0a730fab3cbdf427d.png" alt="image"></p><br><p>  Parallelism: </p><br><p><img src="https://habrastorage.org/web/7fc/93c/fa2/7fc93cfa21094c93b3fc9bc3abb0db99.png" alt="image"></p><br><h2 id="php-i-potoki-vypolneniya">  PHP and execution threads </h2><br><p>  To begin, remember: </p><br><ul><li>  There are no threads in PHP: its engine and code do not have threads for parallelizing internal work. </li><li>  PHP does not offer streams to users: you cannot natively use them in PHP.  Joe Watkins, one of the PHP developers, created a good library that adds execution threads to user space: <a href="http://pthreads.org/">ext / pthread</a> .  But personally, I would not choose PHP for such tasks: it is not intended for this, it is better to take C or Java. </li></ul><br><p>  So what about threads in PHP? </p><br><h2 id="kak-php-obrabatyvaet-zaprosy">  How PHP handles requests </h2><br><p> The thing is, how PHP will handle HTTP requests.  The web server needs to provide some kind of consistency (or concurrency) to serve several clients simultaneously.  After all, answering one client, it is impossible to put all the others on pause. </p><br><p>  Therefore, servers usually use several processes or several threads to respond to clients. </p><br><p> Historically, processes work under Unix.  It's just the basis of Unix, with its birth, there are processes that can create new processes ( <code>fork()</code> ), destroy them ( <code>exit()</code> ) and synchronize ( <code>wait()</code> , <code>waitpid()</code> ).  In such an environment, numerous PHP service multiple client requests.  But <strong>each works in his own process</strong> . </p><br><p>  In this situation, PHP can not help: the processes are completely isolated.  Process A, which processes request A for client data A, cannot interact (read or write) with process B, which processes request B for client B. We need this. </p><br><p>  In 98% of cases, two architectures are used: <em>php-fpm</em> and Apache with <em>mpm_prefork</em> . </p><br><p>  Under Windows, everything is more complicated, as in Unix servers with threads. </p><br><p>  Windows is a really great OS.  It has only one drawback - closed source code.  But online or in books you can find information about the internal structure of many technical resources.  Microsoft engineers <a href="https://technet.microsoft.com/en-us/">talk a lot</a> about how Windows works. </p><br><p>  Windows has a different approach to consistency and concurrency.  This OS very actively uses execution threads.  In fact, creating a process in Windows is such a difficult task that it is usually avoided.  Instead, run threads always and everywhere.  Threads in Windows are much more powerful than in Linux.  Yes exactly. </p><br><p>  When PHP runs under Windows, the web server (any) <strong>will handle client requests in streams, not processes</strong> .  That is, in this environment, PHP runs in the stream.  And therefore, he should be especially careful with the thread specifications: <strong>he must be thread safe</strong> . </p><br><p>  PHP must be thread-safe, that is, manage consistency that it did not create, but in which and with which it functions.  That is, protect your access to your own global variables.  And PHP has a lot of them. </p><br><p>  <strong>Zend Thread Safety</strong> (ZTS, Zend thread safety) is responsible for this protection. </p><br><p>  Note that the same is true for Unix, if you decide to use execution threads to parallelize the processing of client requests.  But for Unix-systems, this is a very unusual situation, since for such tasks classical processes are traditionally used here.  Although no one bothers to choose streams, it can improve performance.  Threads are easier processes, so the system can perform many more threads.  In addition, if your PHP extension needs thread-safety (like ext / pthread), then you will need thread-safe PHP. </p><br><h2 id="podrobnosti-realizacii-zts">  ZTS implementation details </h2><br><p>  ZTS is activated using <em>--enable-maintainer-zts</em> .  Typically, you do not need this switch if you do not run PHP under Windows or do not run PHP with an extension that requires the engine's thread safety to work. </p><br><p>  There are a number of ways to check the current mode of operation.  CLI and <code>php ‚Äìv</code> will tell you that NTS (Not Thread Safe) or ZTS (Zend Thread Safe) is now activated. </p><br><p><img src="https://habrastorage.org/web/56e/b9c/0c6/56eb9c0c6e4c4bfc87d1dc1489b39f37.png" alt="image"></p><br><p>  You can also use <code>phpinfo()</code> : </p><br><p><img src="https://habrastorage.org/web/ba3/298/006/ba3298006a7f42488ba3f9f9957cceb9.png" alt="image"></p><br><p>  You can read <code>PHP_ZTS</code> constant from PHP in your code. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_ZTS) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"You are running a thread safe version of the PHP engine"</span></span>; }</code> </pre> <br><p>  When compiling with ZTS, the entire foundation of PHP becomes thread-safe.  But activated extensions may not be thread-safe.  All official extensions (distributed with PHP) are safe, but you can‚Äôt vouch for third parties.  Below, you will see that mastering the thread safety of PHP extensions requires special use of the API.  And, as it constantly happens with streams: one omission - and the <strong>whole server</strong> can fall down. </p><br><p>  When using threads, if you do not call reentrant functions (usually from libc) or blindly refer to a true global variable (true global variable), this will lead to strange behavior <strong>in all single-level threads (sibling threads)</strong> .  For example, mess with threads in one extension - and this will affect every client served in all threads on the server!  A dreadful situation: one client can spoil all other client data. </p><br><p>  <em>When designing PHP extensions:</em> </p><br><ul><li>  Extreme caution and good knowledge of streaming programming are required.  Otherwise, you will completely unpredictably break the server, and you will not be able to debug it quickly enough. </li><li>  If you make a mistake with threads, this will affect all clients served by all threads on the server.  You may not even notice this, because erroneous stream programming usually leads to horrible unpredictable behavior that is not easy to reproduce. * </li></ul><br><h3 id="reenterabelnye-funkcii">  Reentrant functions </h3><br><p>  When designing a PHP extension, use <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25B0%25D0%25B1%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">reentrant functions</a> : functions that do not depend on the global state.  Although it is too simplistic.  If more, then reentrant functions can be called until their previous call is completed.  They are able to work in parallel in two or more execution threads.  If they used a global state, they would not be reentrant.  However, they can block their own global state, and therefore be thread-safe;) Many traditional functions from libc are not reentrant, because they were created when they had not yet invented execution threads. </p><br><p>  So some libc (especially glibc) publish reentrant equivalent functions as functions with the suffix <code>_r()</code> .  The new C11 standard gives more options for using threads.  And functions from C11 libc are reworked and got the <code>_s()</code> suffix (for example, <code>localtime_s()</code> ). </p><br><p> <code>strtok() =&gt; strtok_r(); strerror(), strerror_r(); readdir() =&gt; readdir_r()</code>  <code>strtok() =&gt; strtok_r(); strerror(), strerror_r(); readdir() =&gt; readdir_r()</code> -, etc. </p><br><p>  PHP itself provides some features mainly for cross-platform use.  <a href="">Take a look at main / reentrancy.c</a> . </p><br><p>  Also, do not forget about reentrancy when writing your own C-functions.  The function will be reentrant if you can pass everything you need as arguments (on the stack or through registers) and if it does not use global / static variables or any non-reentrant functions. </p><br><h3 id="ne-privyazyvaytes-k-potokonebezopasnym-bibliotekam">  Do not bind to thread safe libraries. </h3><br><p>  Remember that in streaming programming, the whole process of sharing a memory image is important.  This includes linked libraries. </p><br><p>  If your extension is tied to a library that is exactly thread safe, you will have to develop your own methods of providing thread safety in order to protect the access to the global state in the library.  In streaming programming and C, this happens often, but is easily overlooked. </p><br><h3 id="ispolzovanie-zts">  Using ZTS </h3><br><p>  ZTS is a code level that controls access to global streaming variables using Thread Local Storage (TLS) in PHP 7. </p><br><p>  When developing the PHP language and its extensions, we have to distinguish two types of globals in the code. </p><br><p>  There are <strong>true globals</strong> (true globals), which are simply traditional global variables C. They have everything in order with the architecture, but since we did not protect them from consistency in the streams, we can only read them when PHP processes requests.  True globals are created and written <strong>before</strong> at least one thread of execution is created.  In PHP's internal terminology, this step is called <em>module init</em> .  This is clearly seen in the example extensions: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> PHP_MINIT(wow_ext) <span class="hljs-comment"><span class="hljs-comment">/*   PHP */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (something()) { val = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } }</code> </pre> <br><p>  This pseudocode shows how any PHP extension might look.  Extensions have multiple hooks that are initialized during the PHP life cycle.  MINIT () interceptor refers to the initialization of PHP.  This procedure starts PHP and you can safely read a global variable or write to it, as in the example above. </p><br><p>  The second important interceptor is RINIT (), the initialization of the request.  This procedure is called for each extension, when processing each new request.  That is, RINIT () can be called extensions thousands of times.  At this point, <strong>PHP is already going into the stream</strong> .  The web server will break the initial process into threads, so <strong>thread safety is required</strong> in RINIT ().  This is perfectly logical in a situation where threads are created for simultaneous processing of several requests.  Do not forget - <strong>you do not create threads</strong> .  Instead of PHP, it creates a web server. </p><br><p>  We also use <em>thread globals</em> .  These are global variables whose thread safety is provided by the ZTS level: </p><br><pre> <code class="cpp hljs">PHP_RINIT(wow_ext) <span class="hljs-comment"><span class="hljs-comment">/*    PHP */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (something()) { WOW_G(val) = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } }</code> </pre> <br><p>  To access the streaming global, we used the <code>WOW_G()</code> macro.  Let's see how it works. </p><br><h2 id="neobhodimost-makrosov">  The need for macros </h2><br><p>  Remember: when PHP is running on threads, you need to protect access to all global states related to queries.  If there are no threads, then this protection is not needed.  After all, each process gets its own memory, which no one else uses. </p><br><p>  So, the way of accessing globals related to queries depends on the environment (a multitasking engine is used).  Therefore, it is necessary to make so that the access to the globals associated with the queries is executed in the same way regardless of the environment. </p><br><p>  Macros are used for this. </p><br><p>  The <code>WOW_G()</code> macro will be processed in different ways, in accordance with the work of the multitasking PHP engine (processes or threads).  You can influence this by recompiling your extension.  Therefore, PHP extensions are incompatible when switching between ZTS and non-ZTS modes.  Incompatible at the level of binary code (binary incompatible)! </p><br><p>  <em>ZTS is incompatible at the binary level with non-ZTS.</em>  <em>When switching from one mode to another, exceptions must be recompiled.</em> </p><br><p>  When working in a process, the <code>WOW_G()</code> macro is usually processed as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ZTS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WOW_G(v) wow_globals.v #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  When working in a stream: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> ZTS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WOW_G(v) wow_globals.v #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WOW_G(v) (((wow_globals *) (*((void ***) tsrm_get_ls_cache()))[((wow_globals_id)-1)])-&gt;v) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  In ZTS mode, more difficult. </p><br><p>  When working in the process - nonZTS mode (Non Zend Thread Safe) - the true global is used, <em>wow_globals</em> .  This variable is a structure containing global variables, and with the help of a macro we refer to each of them.  <code>WOW_G(foo)</code> leads to <code>wow_globals.foo</code> .  Naturally, you need to declare this variable so that it is reset to zero at startup.  This is also done using a macro (in ZTS mode, it is done differently): </p><br><pre> <code class="cpp hljs">ZEND_BEGIN_MODULE_GLOBALS(wow) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foo; ZEND_END_MODULE_GLOBALS(wow) ZEND_DECLARE_MODULE_GLOBALS(wow)</code> </pre> <br><p>  Then the macro is processed like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_BEGIN_MODULE_GLOBALS(module_name) typedef struct _zend_##module_name##_globals { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_END_MODULE_GLOBALS(module_name) } zend_##module_name##_globals; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_DECLARE_MODULE_GLOBALS(module_name) zend_##module_name##_globals module_name##_globals;</span></span></code> </pre> <br><p>  And that's all.  When working in the process - nothing complicated. </p><br><p>  But when working in a stream - using ZTS - we no longer have true global globals C. But global global ads look the same: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_BEGIN_MODULE_GLOBALS(module_name) typedef struct _zend_##module_name##_globals { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_END_MODULE_GLOBALS(module_name) } zend_##module_name##_globals; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WOW_G(v) (((wow_globals *) (*((void ***) tsrm_get_ls_cache()))[((wow_globals_id)-1)])-&gt;v)</span></span></code> </pre> <br><p>  In ZTS and nonZTS, globals are declared the same. </p><br><p>  But access to them happens in different ways.  The function <code>tsrm_get_ls_cache()</code> is called in ZTS.  This is a call to a TLS repository that will return the memory area allocated for the current concrete flow.  Considering that first of all we are casting to the void type, this is not so simple with this code. </p><br><h2 id="uroven-tsrm">  TSRM level </h2><br><p>  ZTS uses the so-called TSRM level - Thread Safe Resource Manager.  It's just a piece of C code, nothing more! </p><br><p>  Thanks to the TSRM level, ZTS can work.  For the most part, it is located <a href="https://github.com/php/php-src/tree/master/TSRM">in the / TSRM folder of the PHP</a> source code. </p><br><p>  TSRM is not an ideal level.  In general, it is well designed and has appeared since the beginning of PHP 5 (around 2004).  TSRM can work with several low-level thread libraries: Gnu Portable Thread, Posix Threads, State Threads, Win32 Threads, and BeThreads.  The desired level can be selected during configuration (./configure --with-tsrm-xxxxx). </p><br><p>  When analyzing TSRM, we will discuss only the implementation based on pthreads. </p><br><h2 id="zagruzka-tsrm">  TSRM download </h2><br><p>  When PHP is loaded during module initialization, it quickly calls <code>tsrm_startup()</code> .  PHP does not yet know how many threads to create and how many resources are required to ensure thread safety.  It prepares thread tables, each consisting of one element.  Later the tables will grow, but for now they are distributed using <code>malloc()</code> . </p><br><p>  This initial step is also important because here we create the TLS key and the TLS mutex that we need to synchronize. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pthread_key_t</span></span> tls_key; <span class="hljs-function"><span class="hljs-function">TSRM_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tsrm_startup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_threads, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_resources, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> debug_level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *debug_filename)</span></span></span><span class="hljs-function"> </span></span>{ pthread_key_create( &amp;tls_key, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/* Create the key */</span></span> tsrm_error_file = <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>; tsrm_error_set(debug_level, debug_filename); tsrm_tls_table_size = expected_threads; tsrm_tls_table = (tsrm_tls_entry **) <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(tsrm_tls_table_size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tsrm_tls_entry *)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tsrm_tls_table) { TSRM_ERROR((TSRM_ERROR_LEVEL_ERROR, <span class="hljs-string"><span class="hljs-string">"Unable to allocate TLS table"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } id_count=<span class="hljs-number"><span class="hljs-number">0</span></span>; resource_types_table_size = expected_resources; resource_types_table = (tsrm_resource_type *) <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(resource_types_table_size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tsrm_resource_type)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!resource_types_table) { TSRM_ERROR((TSRM_ERROR_LEVEL_ERROR, <span class="hljs-string"><span class="hljs-string">"Unable to allocate resource types table"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(tsrm_tls_table); tsrm_tls_table = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } tsmm_mutex = tsrm_mutex_alloc(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MUTEX_T pthread_mutex_t * TSRM_API MUTEX_T tsrm_mutex_alloc(void) { MUTEX_T mutexp; mutexp = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)); pthread_mutex_init(mutexp,NULL); return mutexp; }</span></span></code> </pre> <br><h2 id="resursy-tsrm">  TSRM Resources </h2><br><p>  When the TSRM level is loaded, you need to add new <strong>resources to it</strong> .  A resource is a memory area containing a set of global variables, usually related to the PHP extension.  The resource must belong to the current thread of execution or be protected for access. </p><br><p>  This area of ‚Äã‚Äãmemory has some size.  She will need initialization (constructor) and deinitialization (destructor).  Usually, initialization is limited to zeroing the memory area, and nothing is done when deinitializing. </p><br><p>  The TSRM level passes a unique ID to the resource.  The caller must then save this ID, since it will be needed later to return the protected memory area from the TSRM. </p><br><p>  TSRM function creating a new resource: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; ts_allocate_ctor ctor; ts_allocate_dtor dtor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> done; } tsrm_resource_type; <span class="hljs-function"><span class="hljs-function">TSRM_API ts_rsrc_id </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ts_allocate_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ts_rsrc_id *rsrc_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, ts_allocate_ctor ctor, ts_allocate_dtor dtor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; tsrm_mutex_lock(tsmm_mutex); <span class="hljs-comment"><span class="hljs-comment">/*  id  */</span></span> *rsrc_id = id_count++; <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resource_types_table_size &lt; id_count) { resource_types_table = (tsrm_resource_type *) <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(resource_types_table, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tsrm_resource_type)*id_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!resource_types_table) { tsrm_mutex_unlock(tsmm_mutex); TSRM_ERROR((TSRM_ERROR_LEVEL_ERROR, <span class="hljs-string"><span class="hljs-string">"Unable to allocate storage for resource"</span></span>)); *rsrc_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } resource_types_table_size = id_count; } resource_types_table[(*rsrc_id)<span class="hljs-number"><span class="hljs-number">-1</span></span>].size = size; resource_types_table[(*rsrc_id)<span class="hljs-number"><span class="hljs-number">-1</span></span>].ctor = ctor; resource_types_table[(*rsrc_id)<span class="hljs-number"><span class="hljs-number">-1</span></span>].dtor = dtor; resource_types_table[(*rsrc_id)<span class="hljs-number"><span class="hljs-number">-1</span></span>].done = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; icount &lt; id_count) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; p-&gt;storage = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(p-&gt;storage, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)*id_count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=p-&gt;count; jstorage[j] = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(resource_types_table[j].size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resource_types_table[j].ctor) { resource_types_table[j].ctor(p-&gt;storage[j]); } } p-&gt;count = id_count; } p = p-&gt;next; } } tsrm_mutex_unlock(tsmm_mutex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *rsrc_id; }</code> </pre> <br><p>  As you can see, this function needs a mutually exclusive lock (mutex lock).  If it is called in the child thread of execution (and it will be called in each of them), it will block other threads until it finishes manipulating the global thread storage state. </p><br><p>  The new resource is added to the dynamic array <code>resource_types_table[]</code> and gets a unique identifier - <code>rsrc_id</code> , which is incremented as resources are added. </p><br><h3 id="zapusk-zaprosa">  Launch request </h3><br><p>  Now we are ready to process requests.  Remember that each request will be serviced in its own thread of execution.  What happens when the request appears there?  At the very beginning of each new request, the <code>ts_resource_ex()</code> function is <code>ts_resource_ex()</code> .  It reads the ID of the current thread of execution and tries to extract the resources allocated for this thread, that is, the memory for the globals of the current thread.  If resources are not detected (the stream is new), then resources are allocated for the current stream based on the model created when you start PHP.  This is done with <code>allocate_new_resource()</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate_new_resource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tsrm_tls_entry **thread_resources_ptr, THREAD_T thread_id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; TSRM_ERROR((TSRM_ERROR_LEVEL_CORE, <span class="hljs-string"><span class="hljs-string">"Creating data structures for thread %x"</span></span>, thread_id)); (*thread_resources_ptr) = (tsrm_tls_entry *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tsrm_tls_entry)); (*thread_resources_ptr)-&gt;storage = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { (*thread_resources_ptr)-&gt;storage = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)*id_count); } (*thread_resources_ptr)-&gt;count = id_count; (*thread_resources_ptr)-&gt;thread_id = thread_id; (*thread_resources_ptr)-&gt;next = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> tsrm_tls_set(*thread_resources_ptr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tsrm_new_thread_begin_handler) { tsrm_new_thread_begin_handler(thread_id); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; istorage[i] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { (*thread_resources_ptr)-&gt;storage[i] = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(resource_types_table[i].size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resource_types_table[i].ctor) { resource_types_table[i].ctor((*thread_resources_ptr)-&gt;storage[i]); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tsrm_new_thread_end_handler) { tsrm_new_thread_end_handler(thread_id); } tsrm_mutex_unlock(tsmm_mutex); }</code> </pre> <br><h3 id="kesh-lokalnogo-hranilischa-rasshireniy">  Local storage cache extensions </h3><br><p>  Each extension in PHP 7 can declare its cache in the local storage.  This means that when starting each new thread of execution, each extension must read the local storage area of ‚Äã‚Äãits own thread of execution, rather than iterating through the list of stores with each global access (global access).  There is no magic here, for this you need to do a few things. </p><br><p>  First you need to compile PHP with cache support: enter <strong>-DZEND_ENABLE_STATIC_TSRMLS_CACHE = 1 on the</strong> compilation command line.  In any case, this should be done by default.  Next, when declaring your extension <code>ZEND_TSRMLS_CACHE_DEFINE()</code> use the macro <code>ZEND_TSRMLS_CACHE_DEFINE()</code> : </p><br><p> <code>#define ZEND_TSRMLS_CACHE_DEFINE(); __thread void *_tsrm_ls_cache = ((void *)0);</code> </p> <br><p>  As you can see, a real global C is declared, only with the special declaration <code>__thread</code> .  This is necessary in order to <a href="https://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/Thread_002dLocal.html">tell the compiler</a> that it will be a thread variable (thread specific). </p><br><p>  Then you need to fill this void * repository with data from the repository reserved for your globals with TSRM level.  To do this, you can use <code>ZEND_TSRMLS_CACHE_UPDATE()</code> in the global constructor: </p><br><pre> <code class="cpp hljs">PHP_GINIT_FUNCTION(my_ext) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ZTS ZEND_TSRMLS_CACHE_UPDATE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Continue initialization here */</span></span></span><span class="hljs-meta"> } ```cpp   (macro expansion): ```#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ZEND_TSRMLS_CACHE_UPDATE() _tsrm_ls_cache = tsrm_get_ls_cache();```    pthread: ```#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> tsrm_get_ls_cache pthread_getspecific(tls_key)``` ,    ,         ‚Äî    : ```cpp #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ZTS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_G(v) (((my_globals *) (*((void ***) _tsrm_ls_cache))[((my_globals_id)-1)])-&gt;(v))</span></span></code> </pre> <br><p>  ,        MY_G(),       ,    <code>_tsrm_ls_cache</code>   ID  : <code>my_globals_id</code> . </p><br><p><img src="https://habrastorage.org/web/3f7/03f/651/3f703f651dee4a0a80ccd34e4c244ede.png" alt="image"></p><br><p>    ,       -    .       ID. TSRM       ,    /. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>    ‚Äî  .     ,  PHP    :        TLS,         ,     ‚Äî TSRM.   ,      ,    .  ,      PHP             . </p><br><p>       TSRM:  -,   ,    .         ,      ZTS,                  .   TSRM         :       ,     ,     . </p><br><p> ,      ,    (request-bound).  -    -,      ,  servinf  :     ,   ,     -. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329446/">https://habr.com/ru/post/329446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329434/index.html">Wannacry - X-team, at the exit</a></li>
<li><a href="../329436/index.html">How IT professionals work. Savva Mikhalevsky, front-end architect Grabr</a></li>
<li><a href="../329438/index.html">Check Point Security CheckUP - R80.10. Part 2</a></li>
<li><a href="../329440/index.html">Accelerating WSUS</a></li>
<li><a href="../329444/index.html">How does Roketbank know your name</a></li>
<li><a href="../329448/index.html">Reverse engineering game Lost Vikings</a></li>
<li><a href="../329450/index.html">IT digest of events of the end of May-June</a></li>
<li><a href="../329452/index.html">Vue.js for doubters. All you need to know</a></li>
<li><a href="../329454/index.html">Top reports on Google I / O 2017: Architecture and more</a></li>
<li><a href="../329456/index.html">Learning to listen to the robot talk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>