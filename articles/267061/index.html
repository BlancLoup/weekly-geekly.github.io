<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Card game: we realize attack and we will find application of ShadowDOM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, readers. Today, we will continue to improve our toy and realize the opportunity to attack the opponent‚Äôs cards, as well as some profit in us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Card game: we realize attack and we will find application of ShadowDOM</h1><div class="post__text post__text-html js-mediator-article">  Good day, readers.  Today, we will continue to improve our toy and realize the opportunity to attack the opponent‚Äôs cards, as well as some profit in using ShadowDOM for the admin panel. <br>  Our way of implementing the queue from the last article (as opposed to the players' message on WebSockets) will unexpectedly help us in the implementation of the attack. <br><br>  I will make a reservation right away that we will develop the version on MatreshkaJS, and not on Angular. <br><br><img src="https://habrastorage.org/files/a2e/2c9/7b3/a2e2c97b3bc54fbaa8846407b820fae9.png" alt="image"><br><a name="habracut"></a><br><h2>  What we have at the moment </h2><br>  At the present time, we have implemented the ability to call the enemy to battle, and already in the game lay out cards on the arena (table).  But what kind of game is it if you can not interact with the enemy? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We sketch the algorithm: <br><ul><li>  Select the card, which we are going to make a move by clicking on it. </li><li>  When you click on another card, other cards are not highlighted. </li><li>  When you click on an opponent card, the highlighted card (if any) performs an attack event (card.attack (opponentCard)) </li><li>  We show these actions to the opponent. </li></ul><br>  And yes, creatures cannot attack on the turn they were played. <br>  And the cost of mana ... But let's do everything in order. <br><br><h2>  Admin and ShadowDOM </h2><br>  If you remember, we‚Äôve assigned the admin panel to Webix, it‚Äôs very easy to interact with DataBoom, which we use to locate the map data and the order of events. <br><br>  Since we want to make all the goodies of our prototype (HeartStone) like: ‚Äúbattle cry‚Äù, ‚Äúdeath wheeze‚Äù, etc., we need to store descriptions of various instructions for these events in a separate collection.  Recall that the relationship between collections in DataBoom is set as a property of the collection object, in which we specify an array of objects of the form <br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"obj_ID"</span></span>}</code> </pre> <br>  where obj_ID is the ID of the associated object. <br><br>  In the official documentation, an example of establishing such relationships is as follows: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pers = [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jane'</span></span> }] pers[<span class="hljs-number"><span class="hljs-number">0</span></span>].wife = pers[<span class="hljs-number"><span class="hljs-number">1</span></span>]; pers[<span class="hljs-number"><span class="hljs-number">1</span></span>].husband = pers[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  That is, we assign another object to a certain property without bothering how DataBoom links them.  In the database, it looks as described above: <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"wife"</span></span>:[{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a1303015-77ae-472d-8961-94ea2838b9b2"</span></span>}]}</code> </pre><br>  Using this knowledge, we can, without rewriting our admin panel at the root, make it possible to add a link. <br>  What do we really need?  Replace the standard input when editing a record (we use the Webix widget gridpanel) to select with a list of IDs of the desired collection.  And we will do this with the help of ShadowDOM. <br><br><h3>  What is ShadowDOM? </h3><br>  ShadowDOM, as the name suggests, is a shadow DOM construct. <br>  The word ‚Äúshadow‚Äù implies that what we do not see in the shadow is a backend on the front end.  The user interacts with what we show him.  But it is worth remembering that we change only the visual display.  the DOM structure remains the same.  We just replace the display of the usual input [type = text] with a more complex and convenient input element.  <a href="http://habrahabr.ru/post/180377/">More deployed here</a> . <br><br>  Tk the gridpanel text fields store the string data in the database, and we need to save the object, we have to pass it in string representation (JSON).  Writing such hands is hard, so let's start. <br><br>  Initialize the root of the shadow tree on our input <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = elem.createShadowRoot();</code> </pre><br>  This action will already hide the contents of the elem element, but in order to display something in it, you need to fill it with innerHTML. <br>  Since we will have a drop-down list there, we will get the data for it from the collection: <br><pre> <code class="javascript hljs">db.load(<span class="hljs-string"><span class="hljs-string">"death_xpun"</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selectOptions = <span class="hljs-string"><span class="hljs-string">'&lt;select&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data){ selectOptions += <span class="hljs-string"><span class="hljs-string">'&lt;option value="'</span></span> + data[key].id + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + data[key].name + <span class="hljs-string"><span class="hljs-string">'&lt;/option&gt;'</span></span> } selectOptions += <span class="hljs-string"><span class="hljs-string">'&lt;/select&gt;'</span></span>; }); <span class="hljs-comment"><span class="hljs-comment">//    root.innerHTML = selectOptions;</span></span></code> </pre><br>  So far we have only done the mapping, instead of the text input, we can see select, but the data for writing to the database is taken from the input, which, by the way, has not gone anywhere, but is in the same place in the DOM tree.  Hang an event handler on it: <br><pre> <code class="javascript hljs">root.querySelector(<span class="hljs-string"><span class="hljs-string">'select'</span></span>).onchange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ourValue = {} ourValue.id = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; elem.value = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(ourValue); <span class="hljs-comment"><span class="hljs-comment">//     JSON,   "[Object object]" }</span></span></code> </pre><br><h2>  We attack! </h2><br><h3>  Choosing a card, which we are going to make a move </h3><br>  Here the algorithm is quite simple, but I will describe it to understand the overall picture. <br><br>  In the myUnits module in the map model in the arena, we will see a click event on the map, that is, on the sandbox itself (MatreshkaJS, I recall).  We will additionally connect the card activation with highlighting, that is, it will add / remove the active class: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'class'</span></span>,<span class="hljs-string"><span class="hljs-string">':sandbox'</span></span>,{ <span class="hljs-comment"><span class="hljs-comment">//  class  on: 'click', //     click getValue: function(){ return this.className; }, setValue: function(v){ //  : this.class = value this.className = v; }, initialize: function(){ $(this).on('click',function(){ if ($(this).attr('enable') == 'disable') return; if ($(this).hasClass('active')) { $(this).removeClass('active'); return false; } $('#myUnits .active').removeClass('active'); $(this).addClass('active'); readyToAttack = myUnits.indexOf($(this)); //      }); } });</span></span></code> </pre><br>  Since the card should not be able to attack on the same turn, we will add a certain enabled flag to the constructor, which is ‚Äúdisabled‚Äù by default.  Later I will think whether it is better to replace it with true / false: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>: function(data){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.enable = <span class="hljs-string"><span class="hljs-string">'disable'</span></span>; }</code> </pre><br>  Maps are activated in the arena at the beginning of the turn.  According to this logic, it is necessary at the beginning of each Hov to raise some kind of event enableMyUnits, which we will issue as a directive: <br><div class="spoiler">  <b class="spoiler_title">Actions / myTimerStart.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs">define([<span class="hljs-string"><span class="hljs-string">'Directive'</span></span>, <span class="hljs-string"><span class="hljs-string">'timer'</span></span>, <span class="hljs-string"><span class="hljs-string">'myUnits'</span></span>, <span class="hljs-string"><span class="hljs-string">'mana'</span></span>],<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Directive, timer, myUnits, mana</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = { <span class="hljs-attr"><span class="hljs-attr">run</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ timer.start(); <span class="hljs-comment"><span class="hljs-comment">//   myUnits.enableAll(); //    Directive.run('getCard'); //   mana.setAllActive(); //     mana.add(); //    } } return action; })</span></span></code> </pre><br></div></div><br>  The names of the methods speaking, and there is nothing to add. <br><br>  So, the card is active and ready to attack, click on the opponent's card that we want to attack.  To do this, of course, we will add the opUnits module (opponent's units), we will click on them: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'click::sandbox'</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($(<span class="hljs-string"><span class="hljs-string">'#myUnits .active'</span></span>).length){ <span class="hljs-comment"><span class="hljs-comment">//     var readyToAttack = myUnits.filter(this.filterActive); if (readyToAttack.length != 1) return false; var agressorIndex = myUnits.indexOf(readyToAttack[0]); Directive.run('attack', { //    agressor: myUnits[agressorIndex], victim: this }); } });</span></span></code> </pre><br>  I took out the attack mechanism to a separate directive for the simple reason that we will trigger the attack event also when receiving the corresponding instruction from the server. <br><div class="spoiler">  <b class="spoiler_title">Actions / attack.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs">define([<span class="hljs-string"><span class="hljs-string">'Directive'</span></span>, <span class="hljs-string"><span class="hljs-string">'stack'</span></span>, <span class="hljs-string"><span class="hljs-string">'User'</span></span>],<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Directive, stack, User</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = { <span class="hljs-attr"><span class="hljs-attr">run</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args</span></span></span><span class="hljs-function">)</span></span>{ args.agressor.attacking(args.victim); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moreProps = { <span class="hljs-attr"><span class="hljs-attr">agressor</span></span>: args.agressor.getIndex(), <span class="hljs-attr"><span class="hljs-attr">victim</span></span>: args.victim.getIndex() } stack.push(User.opponent, <span class="hljs-string"><span class="hljs-string">'opAttack'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, moreProps); <span class="hljs-comment"><span class="hljs-comment">//       } } return action; })</span></span></code> </pre><br></div></div><br>  Since DataBoom contains collections and not tables, we can store completely different data there, with a different set of parameters.  This is one of the reasons why I chose this service.  In the example above, we are expanding the object that we are going to write to the database with the moreProps object, which can contain any parameters.  But it is worth remembering that some parameters cannot be overwritten.  Later I will check for an attempt to change such "system" parameters.  But it popoooozhe. <br><br>  The attacking () method of the myUnits module in the pilot version looks pretty clumsy <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">attacking: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">victim</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> agressor = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; victim.sandbox.style.zIndex = <span class="hljs-number"><span class="hljs-number">5</span></span>; agressor.sandbox.style.zIndex = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> yPos = victim.sandbox.offsetTop - (agressor.sandbox.offsetTop + $(<span class="hljs-string"><span class="hljs-string">'#opUnits'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].offsetHeight) + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xPos = victim.sandbox.offsetLeft - agressor.sandbox.offsetLeft; agressor.sandbox.style.top = yPos + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; agressor.sandbox.style.left = xPos + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> at = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ agressor.sandbox.style.top = <span class="hljs-number"><span class="hljs-number">0</span></span>; agressor.sandbox.style.left = <span class="hljs-number"><span class="hljs-number">0</span></span>; clearTimeout(at); },<span class="hljs-number"><span class="hljs-number">200</span></span>); agressor.enable = <span class="hljs-string"><span class="hljs-string">'disable'</span></span>; victim.health = victim.health - agressor.attack; agressor.health = agressor.health - victim.attack; }</code> </pre><br></div></div><br>  We simply move the map using styles so that it is on top of the victim card, and then back to its place.  Naturally, for this the map must have position: relative. <br><br>  Receiving instructions about the attack from our event queue from the server, we launch it in a similar way, simply by calling the attacking method on the object of the suicide card, and with the argument we transfer the victim: <br><pre> <code class="javascript hljs">define([<span class="hljs-string"><span class="hljs-string">'opUnits'</span></span>, <span class="hljs-string"><span class="hljs-string">'myUnits'</span></span>],<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opUnits, myUnits</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = { <span class="hljs-attr"><span class="hljs-attr">run</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> agressor = opUnits[args.agressor]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> victim = myUnits[args.victim]; agressor.attacking(victim); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action; })</code> </pre><br>  I will not tire, on it we will finish the given article. <br>  Play around in the still full jambs example. <br>  I would be extremely grateful if you tell me where to read, how to disable ShadowDOM so that you can play: on / off. <br><br><h2>  Resources </h2><br><ul><li>  <a href="https://github.com/seokirill/PCMatreshkaDataboom">Github</a> </li><li>  <a href="http://141.8.196.222/">Demo</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/267061/">https://habr.com/ru/post/267061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267051/index.html">We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: We interrogate keys, we generate PWM. Comparison of CMSIS and SPL code (PWM + TIM + PORT). Part one</a></li>
<li><a href="../267053/index.html">What can I learn from WhatsApp</a></li>
<li><a href="../267055/index.html">‚ÄúMade and forgotten‚Äù: Why is it not so in the layout of email-letters</a></li>
<li><a href="../267057/index.html">SYNful knock on the OS of Cisco Systems routers</a></li>
<li><a href="../267059/index.html">Overview of the Intent Sender plugin for Android Studio and certain features of its development</a></li>
<li><a href="../267063/index.html">Functional C #: Non-nullable reference types (non-zero reference types)</a></li>
<li><a href="../267067/index.html">The story of the damn doubles</a></li>
<li><a href="../267069/index.html">A new way of MITM-attack on the TLS protocol makes the attacker invisible</a></li>
<li><a href="../267071/index.html">Already a year we create an operator together</a></li>
<li><a href="../267073/index.html">Vector Drawable API. Application possibilities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>