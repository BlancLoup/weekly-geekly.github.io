<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sharding theory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It seems that we have plunged so deeply into the jungle of highload development that we simply do not think about basic problems. Take sharding, for e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sharding theory</h1><div class="post__text post__text-html js-mediator-article">  It seems that we have plunged so deeply into the jungle of highload development that we simply do not think about basic problems.  Take sharding, for example.  What to understand it, if you can write conditionally shards = n in the database settings, and everything will be done by itself.  So, he is like that, but if, rather, when something goes wrong, the resources really start to be missed, I would like to understand what the reason is and how to fix it. <br><br>  In short, if you contribute your alternative implementation of hashing in Cassandra, then there are hardly any revelations for you here.  But if the load on your services is already arriving, and the system knowledge does not keep up with it, then you are welcome.  The great and terrible <strong>Andrei Aksyonov</strong> ( <a href="https://habr.com/users/shodan/" class="user_link">shodan</a> ), in his characteristic manner, will tell you that <strong>sharding is bad, not sharding is also bad</strong> , and how it is arranged inside.  And quite by accident, one of the parts of the story about sharding is not really about sharding, but the devil knows what - like objects on shards mapit. <br><img src="https://habrastorage.org/webt/c9/ju/s6/c9jus6tadexnz4aih4q95bl7ega.jpeg"><br>  A photo of cats (although they happened to be puppies) already answers the question why this is all, but we will begin sequentially. <br><a name="habracut"></a><br><h2>  What is "sharding" <br></h2><br>  If you persistently google, it turns out that there is a fairly blurred border between the so-called partitioning and the so-called sharding.  Everyone calls everything he wants, what he wants.  Some people distinguish horizontal partitioning and sharding.  Others say that sharding is a certain kind of horizontal partitioning. <br><br>  I did not find a single terminological standard that would be approved by the founding fathers and is ISO certified.  Personal inner conviction is approximately like this: <strong>Partitioning</strong> on average is ‚Äúcutting the base into pieces‚Äù in an arbitrary manner. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <strong>Vertical</strong> partitioning - pokolonochno.  For example, there is a giant table for a couple of billion entries in 60 columns.  Instead of holding one such gigantic table, we hold 60 not less giant tables of 2 billion records - and this is not a column basis, but vertical partitioning (as an example of terminology). <br></li><li>  <strong>Horizontal</strong> partitioning - we cut line by line, maybe, inside the server. <br></li></ul><br>  The awkward moment here is in the subtle difference between horizontal partitioning and sharding.  You can cut me into pieces, but I surely will not tell you what it is.  There is a feeling that sharding and horizontal partitioning are about the same thing. <br><br>  Sharding is generally when a large table in terms of databases or a collection of documents, objects, if you do not have a database at all, but a document store, is cut by objects.  That is, out of 2 billion objects, pieces are selected no matter what size.  The objects themselves inside each object are not cut into pieces; we do not lay them out into separate columns, but lay them out in different places in bundles. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xx_Lv1P_X_I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i><a href="http://bit.do/eDkJc">Link</a> to the presentation to complete the picture.</i> <br><br>  Next came the subtle terminological differences.  For example, relatively speaking, the developers at Postgres can say that horizontal partitioning is when all the tables into which the main table is divided lie in the same schema, and when on different machines it is sharding. <br><br>  In a general sense, without being tied to the terminology of a specific database and a specific data management system, there is a feeling that sharding is just cutting by lines and documents and so on ‚Äî and that‚Äôs all: <br><br><blockquote>  Sharding (~ =, \ in ...) Horizontal Partitioning == is typical. <br></blockquote><br>  I emphasize typically.  In the sense that we are doing all this for a reason, so as to cut 2 billion documents into 20 tables, each of which would be more manageable, but in order to distribute it into many cores, many disks or many different physical or virtual servers . <br><br>  The implication is that we do this so that every shard ‚Äî every bit of data ‚Äî replicates many times.  But really, no. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs00 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs15 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre> <br>  In fact, if you do this data cutting, you will generate 16 small tablets from one giant SQL table on MySQL on your glorious laptop, without going beyond a single laptop, a single schema, a single database, etc.  etc.  - everything, you have sharding. <br><br>  Remembering the illustration with the puppies, this leads to the following: <br><br><ul><li>  Increases bandwidth - bandwidth. <br></li><li>  Latency does not change, that is, everyone, so to speak, a worker or consumer in this case, gets his own.  It is not known what puppies get in the picture, but requests are serviced in about one time, as if the puppy were alone. </li><li>  Either the one and the other, and more high availability (replication). <br></li></ul><br>  <strong>Why bandwidth?</strong>  We sometimes can have such amounts of data that do not interpose - it‚Äôs not clear where, but not intermediation - per 1 {core |  disk |  server |  ...}.  Just not enough resources and everything.  In order to work with this big dataset, you need to cut it. <br><br>  <strong>Why latency?</strong>  On one core, scanning a table of 2 billion rows is 20 times slower than scanning 20 tables on 20 cores, making it parallel.  Data is too slowly processed on one resource. <br><br>  <strong>Why high availability?</strong>  Or we cut the data in order to do both one and the other at the same time, and at the same time several copies of each shard - replication ensures high availability. <br><br><h2>  A simple example of "how to make hands" <br></h2><br>  Conditional sharding can be cut using the test table test.documents for 32 documents, and by generating 16 test tables from this table for approximately 2 documents test.docs00, 01, 02, ..., 15. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs00 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs15 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Why about?  Because a priori, we do not know how id is distributed, if from 1 to 32 inclusively, then there will be exactly 2 documents each, otherwise - no. <br><br>  <strong>We do this for what it is.</strong>  After we have made 16 tables, we can ‚Äúgrab‚Äù 16 of what we need.  Regardless of where we stand, we can parallelize these resources.  For example, if there is not enough disk space, it would make sense to decompose these tables into separate disks. <br><br>  All this, unfortunately, is not free.  I suspect that in the case of the canonical SQL standard (I haven‚Äôt reread the SQL standard for a long time, perhaps it hasn‚Äôt been updated for a long time), there is no official standardized syntax for any SQL server to say: ‚ÄúDear SQL server, make me 32 shards and decompose them into 4 disks. ‚Äù  But in individual implementations, there is often a specific syntax in order to do the same thing in principle.  PostgreSQL has mechanisms for partitioning, MySQL has MariaDB, Oracle probably did it all a long time ago. <br><br>  However, if we do it by hand, without database support and within the standard, we <strong>conditionally pay for the complexity of data access</strong> .  Where there was a simple SELECT * FROM documents WHERE id = 123, now 16 x SELECT * FROM docsXX.  And well, if we tried to get the record by key.  Much more interesting if we tried to get an early range of records.  Now (if we, I emphasize, like fools, and remain within the standard) the results of these 16 SELECT * FROM will have to be combined in the application. <br><br>  <strong>What performance changes to expect?</strong> <br><br><ul><li>  Intuitively linear. </li><li>  Theoretically sublinear because <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2590%25D0%25BC%25D0%25B4%25D0%25B0%25D0%25BB%25D0%25B0">Amdahl law</a> . </li><li>  Practically - maybe, almost linearly, maybe not. </li></ul><br>  In fact, the correct answer is unknown.  With dexterous use of the sharding technique, you can achieve a significant superlinear degradation of your application, and DBA will come running with a hot poker. <br><br>  Let's see how this can be achieved.  It is clear that simply putting the setting in PostgreSQL shards = 16, and then it itself took off - it is not interesting.  Let's think about how we can ensure that <em>we can slow down 32 times from sharding</em> - this is interesting from the point of view how not to do this. <br><br>  Our attempts to accelerate or slow down will always rest on the classics - in the good old Amdahl law, which says that there is no perfect parallelization of any query, there is always some consistent part. <br><br><h2>  Amdahl law <br></h2><br><blockquote>  <strong><em>There</em></strong> is <strong><em>always</em></strong> a serialized part. <br></blockquote><br>  There is always a part of the execution of the request that is parallel, and there is always a part that does not parallel.  Even if it seems to you that there is a perfectly parallel query, at least the collection of the result string that you are going to send to the client, from the strings received from each shard, is always there, and it is always consistent. <br><br>  There is always some consistent part.  It can be tiny, completely imperceptible on the general background, it can be gigantic and, accordingly, strongly affecting parallelization, but it always is. <br><br>  In addition, its influence is <strong><em>changing</em></strong> and can significantly grow, for example, if we cut our table - let's raise the rates - from 64 entries to 16 tables with 4 entries, this part will change.  Of course, judging by such gigantic amounts of data, we work on a mobile phone and an 86 2 MHz processor, and we don‚Äôt have enough files that can be kept open at the same time.  Apparently, with such input, we open one file at a time. <br><br><ul><li>  It was <strong>Total =</strong> <strong>Serial +</strong> <strong>Parallel</strong> .  Where, for example, parallel is all the work inside the DB, and serial is sending the result to the client. <br></li><li>  It became <strong>Total2 = Serial + Parallel / N + Xserial.</strong>  For example, when a generic ORDER BY, Xserial&gt; 0. <br></li></ul><br>  With this simple example, I'm trying to show that some kind of Xserial appears.  In addition to the fact that there is always a serialized part, and the fact that we are trying to work with data in parallel, an additional part appears to provide this data slicing.  Roughly speaking, we may need: <br><br><ul><li>  find these 16 tables in the internal database dictionary; </li><li>  open files; </li><li>  allocate memory; </li><li>  delocate memory; </li><li>  results; </li><li>  synchronize between the cores; </li></ul><br>  Any out-of-sync effects will still appear.  They may be insignificant and take one billion dollars from the total time, but they are always non-zero and always are.  With their help, we can dramatically lose in performance after sharding. <br><br><img src="https://habrastorage.org/webt/fh/mx/yh/fhmxyh9tozfrbd4yszxj2va9a1g.jpeg"><br><br>  This is a standard picture about the law of Amdal.  It is not very readable, but it is important that the lines, which should ideally be straight and linearly grow, abut on the asymptote.  But since the schedule from the Internet is unreadable, I have made, in my opinion, more visual tables with numbers. <br><br>  Suppose that we have a certain serialized part of the request processing, which takes only 5%: <strong>serial = 0.05 = 1/20.</strong> <br><br>  Intuitively, it would seem that with the serialized part, which takes only 1/20 of the request processing, if we parallelize the processing of the request for 20 cores, it will become approximately 20, at worst 18, times faster. <br><br>  In fact, <b>mathematics is heartless</b> : <br><br> <code>wall = 0.05 + 0.95/num_cores, speedup = 1 / (0.05 + 0.95/num_cores)</code> <br> <br>  It turns out that if you carefully calculate, with the serialized part of 5%, the acceleration will be 10 times (10.3), and this is 51% compared with the theoretical ideal. <br><br><table><tbody><tr><td>  8 cores </td><td>  = 5.9 </td><td>  <font color="#c45911">= 74%</font> </td></tr><tr><td>  10 cores </td><td>  = 6.9 </td><td>  <font color="#c45911">= 69%</font> </td></tr><tr><td>  <strong>20 cores</strong> </td><td>  <strong>= 10.3</strong> </td><td>  <strong><font color="#c45911">= 51%</font></strong> </td></tr><tr><td>  40 cores </td><td>  = 13.6 </td><td>  <font color="#ff0000">= 34%</font> </td></tr><tr><td>  128 cores </td><td>  = 17.4 </td><td>  <font color="#ff0000">= 14%</font> </td></tr></tbody></table><br>  Using 20 cores (20 disks, if you like) for the task on which one worked earlier, we even theoretically will never get more than 20 times the acceleration, and in practice much less.  Moreover, with an increase in the number of parallels, inefficiency is greatly increasing. <br><br>  When only 1% of the serialized work remains and 99% are parallelized, the acceleration values ‚Äã‚Äãare somewhat improved: <br><br><table><tbody><tr><td>  8 cores </td><td>  = 7.5 </td><td>  <font color="#538135">= 93%</font> </td></tr><tr><td>  16 cores </td><td>  = 13.9 </td><td>  <font color="#538135">= 87%</font> </td></tr><tr><td>  32 cores </td><td>  = 24.4 </td><td>  <font color="#c45911">= 76%</font> </td></tr><tr><td>  64 cores </td><td>  = 39.3 </td><td>  <font color="#c45911">= 61%</font> </td></tr></tbody></table><br>  For a completely thermonuclear query that is naturally executed for hours, and the preparatory work and the assembly of the result take very little time (serial = 0.001), we will see already good efficiency: <br><br><table><tbody><tr><td>  8 cores </td><td>  = 7.94 </td><td>  <font color="#538135">= 99%</font> </td></tr><tr><td>  16 cores </td><td>  = 15.76 </td><td>  <font color="#538135">= 99%</font> </td></tr><tr><td>  32 cores </td><td>  = 31.04 </td><td>  <font color="#538135">= 97%</font> </td></tr><tr><td>  64 cores </td><td>  = 60.20 </td><td>  <font color="#538135">= 94%</font> </td></tr></tbody></table><br>  Please note <strong>100% we will never see</strong> .  In particularly good cases, you can see, for example, 99.999%, but not exactly 100%. <br><br><h2>  How to chuff and repeat N times? <br></h2><br>  It is possible to fool and repeat exactly N times: <br><br><ol><li>  Send requests docs00 ... docs15 <strong>sequentially</strong> , not in parallel. </li><li>  In simple queries to make a selection <strong>by key</strong> , WHERE something = 234. </li></ol><br>  In this case, the serialized part (serial) occupies not 1% and not 5%, but approximately 20% in modern databases.  You can also get 50% of the serialized part by accessing the database using a wildly efficient binary protocol or linking it as a dynamic library to a Python script. <br><br>  The rest of the processing time of a simple request will be occupied by non-parallelized operations of parsing the request, preparing the plan, etc.  That is, it does not read the record. <br><br>  If we divide the data into 16 tables and start sequentially, as is customary in the PHP programming language, for example, (he is not very good at starting asynchronous processes), then we‚Äôll get a slowdown 16 times.  And maybe even more, because network round-trips will also be added. <br><br><blockquote>  Suddenly, when sharding, the choice of programming language is important. <br></blockquote><br>  Remember about the choice of programming language, because if you send queries to the database (or search server) sequentially, then where does the acceleration come from?  Rather, there will be a slowdown. <br><br><h3>  Bike from life <br></h3><br>  If you choose C ++, <strong>write to POSIX Threads</strong> , not Boost I / O.  I saw an excellent library from experienced developers from Oracle and MySQL, who wrote a conversation with the MySQL server on Boost.  Apparently, at work they were forced to write on pure C, and then they managed to turn around, take Boost with asynchronous I / O, etc.  One problem is that this asynchronous I / O, which theoretically should have driven 10 requests in parallel, for some reason it had an imperceptible synchronization point inside.  When you run 10 queries in parallel, they were executed exactly 20 times slower than one, because 10 times for the queries themselves and again for the synchronization point. <br><br>  <strong>Conclusion:</strong> write in languages ‚Äã‚Äãthat implement parallel execution and waiting for different requests well.  I do not know, to be honest, what exactly is there to advise, besides Go.  Not only because I love Go, but because I don‚Äôt know anything more suitable. <br><br>  <strong>Do not write in useless languages</strong> in which you will not be able to run 20 parallel queries to the database.  Or at every opportunity do not do it all by hand - understand how it works, but do not do it manually. <br><br><h2>  A / B dough <br></h2><br>  Still sometimes you can slow down, because you are used to, that everything works, and did not notice that the serialized part, firstly, is, secondly, large. <br><br><ul><li>  Immediately ~ 60 search index shards, categories </li><li>  These are correct and true shards, under the subject area. </li><li>  There were up to 1000 documents, and there were 50,000 documents. </li></ul><br>  This is a bike from the production, when the search queries were changed a little and they started to choose a lot more documents from the 60 shards of the search index.  Everything worked quickly and according to the principle: ‚ÄúIt works ‚Äî don't touch it‚Äù, they all forgotten that there are actually 60 shards inside.  Increased the sampling limit for each shard from a thousand to 50 thousand documents.  Suddenly it began to slow down and the parallel ceased.  The requests themselves, which were performed by shards, flew quite well, and the stage slowed down, when 50 thousand documents were collected from 60 shards.  These 3 million final documents on one core merged together, sorted, the top of 3 million was selected and given to the client.  The same serial part slowed down, the same merciless Amdal law worked. <br><br>  <em>So maybe you should not do sharding with your hands, but just like a human</em> <em><br></em>  <em>say database: "do it!"</em> <em><br></em> <br>  <strong>Disclaimer:</strong> I do not really know how to do something right.  I type from the wrong floor !!! <br><br>  I have all my life promoting a religion called "algorithmic fundamentalism."  It is briefly stated very simply: <br><br><blockquote>  You do not want to do anything really with your hands, but it is extremely useful to know how it is arranged inside.  So that at the moment when something goes wrong in the database, you at least understand what went wrong there, how it is arranged inside and around, how it can be repaired. <br></blockquote><br>  Let's consider the options: <br><br><ol><li>  <strong>"Hands"</strong> .  Previously, we manually split the data into 16 virtual tables, we rewrote all queries with our hands - this is extremely uncomfortable to do.  <strong>If you can not shard hands - do not shuffle hands!</strong>  But sometimes this is not possible, for example, you have MySQL 3.23, and then you have to. </li><li>  <strong>"Automatic".</strong>  It happens that you can shard with an automaton or almost with an automaton, when the database is able to distribute the data itself, you only have to roughly write a certain setting somewhere.  There are a lot of bases, and they have a lot of different settings.  I am sure that in every database in which there is an opportunity to write shards = 16 (whatever the syntax), a lot of other settings are glued to this case by a steam locomotive. </li><li>  <strong>The ‚Äúsemi-automat‚Äù</strong> is an absolutely cosmic, in my opinion, brutal mode.  That is, the base itself doesn‚Äôt seem to know how, but there are external additional patches. </li></ol><br>  It is difficult to tell something about an automaton, except for how to send to the documentation on the corresponding database (MongoDB, Elastic, Cassandra, ... in general, the so-called NoSQL).  If you are lucky, then you just pull the switch ‚Äúmake me 16 shards‚Äù and everything will work.  At the moment when it does not work itself, the rest of the article may be necessary. <br><br><h2>  Pro semiautomatic <br></h2><br>  Mostly, the delights of information technology inspire chthonic horror.  For example, MySQL out of the box did not have a sharding implementation to certain versions exactly, nevertheless, the sizes of the bases used in battle grow to indecent values. <br><br>  Suffering humanity in the face of individual DBA has been tormented for years and writes several bad sharding solutions, built incomprehensibly on what.  After that, one more or less decent sharding solution is written under the name ProxySQL (MariaDB / Spider, PG / pg_shard / Citus, ...).  This is a well-known example of this same snip. <br><br>  ProxySQL as a whole, of course, is a complete enterprise-class solution for open source, for routing and so on.  But one of the tasks to be solved is the sharding for the database, which in itself cannot be human shard.  You see, there is no ‚Äúshards = 16‚Äù switch, you have to either rewrite each request in the application, and there are many of them in places, or put some intermediate layer between the application and the database: ‚ÄúHmm ... SELECT * FROM documents?  Yes, it should be broken to 16 small SELECT * FROM server1.document1, SELECT * FROM server2.document2 - to this server with the same login / password, to this with another.  If one did not answer, then ... "etc. <br><br>  Intermediate hooks can do this exactly.  They are a little less than for all databases.  For PostgreSQL, as I understand it, at the same time there are some built-in solutions (PostgresForeign Data Wrappers, in my opinion, built into PostgreSQL itself), there are external patches. <br><br>  Configuring each specific patch is a separate giant topic that does not fit in one report, so we will discuss only the basic concepts. <br><br>  Let's talk the best about the theory of buzz. <br><br><h2>  Absolute perfect automatics? <br></h2><br>  The whole theory of buzz in the case of sharding in this letter F (), the basic principle is <strong>always</strong> the same roughly: <code>shard_id = F(object).</code> <br><br>  Sharding is all about what?  We have 2 billion records (or 64).  We want to split them into several pieces.  There is an unexpected question - how?  According to what principle should I scatter my 2 billion records (or 64) on the 16 servers available to me? <br><br>  The latent mathematician in us must suggest that in the end there is always some kind of magic function that, for each document (object, line, etc.), determines in which piece to put it. <br><br>  If you go deeper into mathematics, this function always depends not only on the object itself (the line itself), but also on external settings such as the total number of shards.  The function, which for each object should tell where to put it, cannot return a value greater than there are servers in the system.  And the functions are slightly different: <br><br><ul><li>  shard_func = <strong>F1</strong> (object); <br></li><li>  shard_id = <strong>F2</strong> (shard_func, ...); </li><li>  shard_id = <strong>F2</strong> ( <strong>F1</strong> (object), current_num_shards, ...). </li></ul><br>  But further we will not dig in these jungle of separate functions, we will just talk what magic functions F () are. <br><br><h2>  What are F ()? <br></h2><br>  They can come up with many different and many different implementation mechanisms.  Sample summary: <br><br><ul><li>  F = <strong>rand</strong> ()% nums_shards </li><li>  F = <strong>somehash</strong> (object.id)% num_shards </li><li>  F = object.date% num_shards </li><li>  F = object.user_id% num_shards </li><li>  ... </li><li>  F = shard_table [somehash () | ... object.date | ...] </li></ul><br>  An interesting fact - you can naturally scatter all data randomly - we throw the next entry on an arbitrary server, on an arbitrary kernel, into an arbitrary table.  There will be no happiness in this, but it will work. <br><br>  There are slightly more intelligent methods of sharding by reproducible or even consistent hash functions, or sharding by some attribute.  Let's go through each method. <br><br><h3>  F = rand () <br></h3><br>  Scattering radomom - not very correct method.  One problem: we scattered our 2 billion records per thousand servers randomly, and we don‚Äôt know where the record is.  We need to pull out user_1, but we don‚Äôt know where it is.  We go to a thousand servers and go through everything - somehow it is inefficient. <br><br><h3>  F = somehash () <br></h3><br>  Let's scatter users in an adult way: read the reproducible hash function from user_id, take the remainder by dividing by the number of servers and access the right server immediately. <br><br>  <em>And why are we doing this?</em>  <em>And then, that we have highload and we don‚Äôt have anything else in one server.</em>  <em>If intermeddle, life would be so simple.</em> <br><br>  Great, the situation has already improved, to get one entry, we are going to one previously known server.  But if we have a range of keys, then in all of this range we have to go through all the key values ‚Äã‚Äãand, in the limit, go either to as many shards as we have keys in the range, or to each server in general.  The situation, of course, improved, but not for all requests.  Some requests suffered. <br><br><h3>  Natural sharding (F = object.date% num_shards) <br></h3><br>  Sometimes, that is often, 95% of the traffic and 95% of the load are requests that have some kind of natural sharding. , 95%  -       1 , 3 , 7 ,   5%     .  95% ,  ,    ,        . <br><br>        , ,   ,         -           . <br><br>   ‚Äî        ,      .       ,    , , ,    .        5 %  . <br><br>       ,    : <br><br><ol><li>      ,  95%     . </li><li>  95%    ,       ,     .   ,           .     ,     . </li></ol><br>  ,      ‚Äî    ,         - . <br><br>   ,   ,         ,     ,         .       ¬´   -      ¬ª. <br><br> <strong>     ¬´¬ª.</strong> ,            . <br><br><h3> 1.  :   <br></h3><br>    ,      ,  . <br><br><ul><li>    ,   ! </li><li> <strong><em></em></strong>  () . </li></ul><br>   , /  , ,  , PM    (       ,  PM   ),     .     . <br><br>  ,    .      ,       ,    100   .        . <br><br>   ,  ,   ,            ,    - . <br><br><h3> 2. ¬´¬ª : , join <br></h3><br>   ,             ? <br><br><ul><li>  ¬´¬ª ‚Ä¶ WHERE randcol BETWEEN aaa AND bbb? <br></li><li>  ¬´¬ª ‚Ä¶ users_32shards JOIN posts_1024 shards? </li></ul><br>  : , ! <br><br>           ,    ,       ,           .      .       (, , document store    ),     ,     . <br><br>   ‚Äî <strong>-       </strong> .     .  ,          .     ,       ,    ,   .       - , ,         ,   ,         ‚Äî    . <br><br>       ,             . <br><br><h3> 3. / :  <br></h3><br> :         ,          . <br><br><blockquote>    ,   . <br></blockquote><br>      ,  , ,  .     ,     ,   ,    10 , -        30,       100   .    .          ‚Äî       ,  -   ‚Äî  , -  . <br><br> ,      :  16 -,  32. ,   17,  23 ‚Äî    .      ,  ,    -  ? <br><br>  : ,    ,     . <br><br>  ,    ¬´¬ª,   ¬´ ¬ª. <br><br><h4>   #1.   <br></h4><br><ul><li>     NewF(object),    . </li><li>   NewF()=OldF() . </li><li>   <strong> .</strong> </li><li>  Oh. </li></ul><br>  ,    2       ,  ,  .   :  17 ,  6   ,  2  ,    17   23 .   10  , ,    .      . <br><br><h4>   #2.   <br></h4><br>    ‚Äî       ‚Äî  17    23,     16   32 !         ,        . <br><br><ul><li>     NewF(object),    . </li><li> <strong>  2^N,   2^(N+1) .</strong> </li><li>   NewF()=OldF()  0,5. </li><li>   50% . </li><li> ,   <strong>   .</strong> </li></ul><br>  ,  ,         .   ,   ,  . <br><br>  ,            .   ,  16     16,      ‚Äî    . <br><br> ,        ‚Äî     . <br><br><h4>  #3. Consistent hashing <br></h4><br> ,       consistent hashing <br><img src="https://habrastorage.org/webt/il/ml/rt/ilmlrt9xy-c3wuyfaafntagufay.jpeg"><br><br>   ¬´consistent hashing¬ª,    ,    . <br><br> :    ()   ,      .    ,     ,  ,      (  ,     ), . <br><br><ul><li>   :  <strong><em> </em></strong> ,   2 ¬´¬ª,    1/n. <br></li><li>   :    ,   .  . </li></ul><br>          ,         .  ,      ,      ,     :     ,          . <br><br>        .  ,        .  ,   ..,    .  ,   - , ,        . <br><br>       ,  , ,  Cassandra   .  ,         , ,      , ,  . <br><br>   ,        ‚Äî     /    ,   ,    . <br><br> , :    ?       ? ‚Äî ,  ! <br><br><h4>  #4. Rendezvous/HRW <br></h4><br>    (  ,   ): <strong>shard_id = arg max hash(object_id, shard_id).</strong> <br><br>    Rendezvous hashing,   ,  ,    Highest Random Weight.      : <br><img src="https://habrastorage.org/webt/0t/dt/rm/0tdtrm0iftxxb5ors5a2wxcex8s.jpeg"><br>   , , 16 .    (),   - ,  16 ,      .      -,   . <br><br>    HRW-hashing,   Rendezvous hashing.       , -,        ,   . <br><br>    ,       .  ,        - -        .      . <br><br>   ,       . <br><br><h4>  #5.   <br></h4><br> ,        Google    -   : <br><br><ul><li> Jump Hash ‚Äî Google '2014. </li><li> Multi Probe ‚ÄîGoogle '2015. </li><li> Maglev ‚Äî Google '2016. </li></ul><br>    ,    .      ,   ,    , -,       .      . <br><br><h4>  #6.  Lists <br></h4><br>      ‚Äî  .     ?   ,     2  ,          object_id  2  ,     . <br><br>  ,       ?    ? <br><br>     . ,   -     ,   ,  .  ,      , ,  ,     . <br><br> : <br><br><ul><li>  1  . </li><li>      /  /  /       : min/max_id =&gt; shard_id. </li><li>    8    4    (4      !) ‚Äî  20    . </li><li>      -   ,        20  ‚Äî     . </li><li> 20  ‚Äî                 . </li></ul><br>     2     -    16  ‚Äî   100   -   .       : ,         ,   ‚Äî  1 .     ,  ,   . <br><br> ,    ,     ,    - ,     . <br><br><h1>  findings <br></h1><br>            : ¬´  ,   !¬ª.       ,     20 . <br><br>   ,   ,     .   ,  <strong>   </strong> ‚Äî   .     100$        ,     .          -,    .     ‚Äî   . <br><br> <strong>    </strong> , ,  ¬´¬ª (, DFS, ...)   .   ,   , highload   -   .  ,        ,     - .     ‚Äî <strong> ,    </strong> . <br><br>     <strong> </strong> <strong>F()</strong> ,   , ,  ..  , ,    2   <strong>     </strong> . <br><br><h2>   <br></h2><br> ,      ,        .       <a href="https://habr.com/article/429962/"> HighLoad++</a> ,  ,     ‚ÄîSphinx‚Äîhighload  ,   . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qpGljUyIht8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>    <br></h2><br>         Highload User Group.  ,    . <br><br>  , ,     <a href="http://www.highload.ru/">HighLoad++</a>     .         , ,  .  ,            , .     <a href="https://www.meetup.com/ru-RU/HighLoad-User-Group/"> </a>   highload-,   . <br><br>        ,  ,     ,  . ,           , ,        . <br><br>  <a href="https://www.meetup.com/ru-RU/HighLoad-User-Group/events/256752414/"> </a> <strong>24   -</strong>      ¬´¬ª, ¬´ ¬ª.  ,        .      ,     <a href="http://eepurl.com/VYVaf"></a> . <br><br><blockquote>         , ,  <strong>8  9   -  </strong> <a href="https://www.highload.ru/spb/2019"><strong>HighLoad++</strong></a>    <a href="https://conf.ontico.ru/lectures/propose/%3Fconference%3Dhl2019-spb"> </a>  <a href="https://conf.ontico.ru/conference/join/hl2019-spb.html"></a> early bird . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/433370/">https://habr.com/ru/post/433370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433360/index.html">Scientists have tried to predict when electric airplanes will become reality</a></li>
<li><a href="../433362/index.html">9 principles of beauty, simplicity and care in the UX</a></li>
<li><a href="../433364/index.html">LDraw + Unity. How I generated Lego</a></li>
<li><a href="../433366/index.html">Work with external resources in Unity3D</a></li>
<li><a href="../433368/index.html">How to apply grocery thinking to the world: the example of sweatshirts</a></li>
<li><a href="../433372/index.html">Car bike</a></li>
<li><a href="../433376/index.html">MIT course "Computer Systems Security". Lecture 21: "Tracking data", part 1</a></li>
<li><a href="../433378/index.html">MIT course "Computer Systems Security". Lecture 21: "Tracking data", part 2</a></li>
<li><a href="../433380/index.html">MIT course "Computer Systems Security". Lecture 21: "Tracking data", part 3</a></li>
<li><a href="../433382/index.html">[Illustrated] Networking Guide for Kubernetes. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>