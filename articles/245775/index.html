<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive javascript: Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive javascript: Node.js</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>The student asked: ‚ÄúProgrammers used only simple computers and programmed without languages, but they made excellent programs.</i>  <i>Why do we use complex computers and programming languages? ‚Äù</i>  <i>Fu-Tzu replied: "The builders used only sticks and clay beforehand, but they made beautiful huts."</i> <i><br><br></i>  <i>Master Yuan-Ma, "Programming Book"</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Currently you have learned JavaScript and used it in a single environment: in the browser.  In this and the next chapter, we will briefly introduce Node.js, a program that allows you to apply JavaScript skills outside the browser.  With it, you can write everything from command line utilities to dynamic HTTP servers. <br><br>  These chapters are about learning the important ideas that make up Node.js and are designed to give you enough information so you can write useful programs in this environment.  They are not trying to be comprehensive Node directories. <br><br>  You could write and execute the code from the previous chapters directly in the browser, but the code from this chapter is written for Node and will not work in the browser. <br><br>  If you want to immediately run the code from this chapter, start by installing Node from the nodejs.org site for your OS.  Also on this site you will find documentation on Node and its built-in modules. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  One of the most difficult problems when writing systems that communicate over a network is input and output processing.  Reading and writing data to and from the network, to disk, and other devices.  Moving data takes time, and proper planning of these actions can greatly affect the system response time for a user or network requests. <br><br>  In the traditional input and output processing method, it is assumed that a function, for example, readFile, starts reading a file and returns only when the file is completely read.  This is called synchronous I / O, input / output. <br><br>  Node was designed to facilitate and simplify the use of asynchronous I / O.  We have already met with asynchronous interfaces, such as the XMLHttpRequest object of the browser, discussed in Chapter 17. This interface allows the script to continue working while the interface is doing its own, and calls the end callback function.  So the whole I / O works in Node. <br><br>  JavaScript fits easily into a Node type system.  This is one of the few languages ‚Äã‚Äãin which the I / O system is not embedded.  Therefore, JavaScript is easily integrated into a rather eccentric approach to I / O in Node and, as a result, does not generate two different input and output systems.  In 2009, when developing Node, people already used I / O in a browser based on callbacks, so the community around the language was familiar with the asynchronous programming style. <br><br><h4>  Asynchrony </h4><br>  I will try to illustrate the difference in synchronous and asynchronous approaches in I / O with a small example where the program should get two resources from the Internet, and then do something with the data. <br><br>  In a synchronous environment, the obvious way to solve a problem is to make requests sequentially.  This method has a minus - the second request will begin only after the end of the first.  The total time will be no less than the sum of the time to process the two requests.  This is an inefficient use of a computer that will be idle most of the time while data is being transmitted over the network. <br><br>  The solution to the problem in the synchronous system is the launch of additional program execution control flows (we have already discussed them in Chapter 14).  The second thread can start the second query, and then both threads will wait for the return of the result, after which they will be synchronized again to bring work into one result. <br><br>  In the diagram, the bold lines indicate the time of normal program operation, and the thin lines indicate the I / O waiting time.  In a synchronous model, the time spent on I / O is included in the time schedule of each of the streams.  In asynchronous, starting an I / O action causes a timeline to branch.  The thread that started the I / O continues to execute, and the I / O is executed parallel to it, at the end of the work making a callback to the function. <br><br>  Program flow for synchronous and asynchronous I / O <br><br>  Another way to express this difference: in a synchronous model, waiting for the end of an I / O is implicit, and in asynchronous, it is explicit, and is under our direct control.  But asynchrony works both ways.  Using it, it is easier to express programs that do not work on the principle of a straight line, but it becomes more difficult to express straight-line programs. <br><br>  In chapter 17, I already touched on the fact that callbacks add a lot of noise and make the program less orderly.  Whether such an approach is generally a good idea is a controversial issue.  In any case, it takes time to get used to it. <br><br>  But for a javascript-based system, I would say that using asynchrony with callbacks makes sense.  One of the strengths of JavaScript is simplicity, and attempts to add several threads to the program would lead to a strong complication.  Although callbacks do not make the code simple, their idea is very simple and at the same time strong enough to write high-performance web servers. <br><br><h4>  Node command </h4><br>  When Node.js is installed on your system, you have a program called node that runs the JavaScript files.  Suppose you have a hello.js file with the following code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message);</code> </pre> <br><br>  You can execute your program from the command line: <br><br><pre> <code class="bash hljs">$ node hello.js Hello world</code> </pre><br><br>  The console.log method in Node works the same as in the browser.  Displays a piece of text.  But in Node, the text is output to standard output, not to the JavaScript console in the browser. <br><br>  If you run node without a file, it will give you a query string in which you can write JavaScript code and get the result. <br><br><pre> <code class="bash hljs">$ node &gt; 1 + 1 2 &gt; [-1, -2, -3].map(Math.abs) [1, 2, 3] &gt; process.exit(0) $</code> </pre><br><br>  The process variable, like the console, is available globally in Node.  It provides several ways to inspect and manipulate the program.  The exit method terminates the process, and you can transfer to it the code of the end-of-program status, which informs the program that launched the node (in this case, the program shell) whether the program completed successfully (zero code) or with an error (any other number). <br><br>  To access the command line arguments passed to the program, you can read an array of process.argv strings.  It also includes the name of the node command and the name of your script, so the argument list starts at index 2. If the showargv.js file contains only the console.log statement (process.argv), you can run it like this: <br><br><pre> <code class="bash hljs">$ node showargv.js one --and two [<span class="hljs-string"><span class="hljs-string">"node"</span></span>, <span class="hljs-string"><span class="hljs-string">"/home/marijn/showargv.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"--and"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>]</code> </pre><br><br>  All standard JavaScript global variables - Array, Math, JSON, are also in the Node environment.  But there is no functionality associated with the browser, for example, document or alert. <br><br>  The global scope object, which in the browser is called window, in Node has a more meaningful name global. <br><br><h4>  Modules </h4><br>  In addition to the few variables mentioned, like console and process, Node holds little functionality in the global scope.  To access the rest of the built-in capabilities, you need to contact the module system. <br><br>  The CommonJS system, based on the require function, was described in Chapter 10. Such a system is built into Node and is used to load everything from embedded modules and downloaded libraries to files that are part of your program. <br><br>  When calling the require Node you need to convert the specified string to the file name.  Paths beginning with "/", "./" or "../" are converted to paths relative to the current one.  "./" means the current directory, "../" is the directory above, and "/" is the root directory of the file system.  If you request "./world/world" from the file /home/marijn/elife/run.js, Node will try to download the file /home/marijn/elife/world/world.js.  The .js extension can be omitted. <br><br>  When a string is passed that does not look like a relative or absolute path, it is assumed that this is either a built-in module or a module installed in the node_modules directory.  For example, require ("fs") will give you a built-in module for working with the file system, and require ("elife") will try to load the library from node_modules / elife /.  The typical method of installing libraries is with NPM, which I will return to later. <br><br>  To demonstrate, let's make a simple project of two files.  The first one is called main.js, and it will define a script called from the command line, designed to distort strings. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> garble = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./garble"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   2        var argument = process.argv[2]; console.log(garble(argument));</span></span></code> </pre><br><br>  The file garble.js defines string distortion, which can be used both by the command line program specified earlier and by other scripts that need direct access to the garble function. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string.split(<span class="hljs-string"><span class="hljs-string">""</span></span>).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ch</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.fromCharCode(ch.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>); }).join(<span class="hljs-string"><span class="hljs-string">""</span></span>); };</code> </pre><br><br>  Replacing module.exports instead of adding properties to it allows us to export a specific value from a module.  In this case, the result of the query of our module is the distortion function itself. <br><br>  The function splits a string into characters using split with an empty string, and then replaces all characters with others, with a code 5 units higher.  It then connects the result back to the string. <br><br>  Now we can call our tool: <br><br><pre> <code class="bash hljs">$ node main.js JavaScript Of{fXhwnuy</code> </pre><br><br><h4>  Installation via NPM </h4><br>  NPM, incidentally mentioned in Chapter 10, is an online repository of JavaScript modules, many of which are written specifically for Node.  When you install Node on a computer, you get the npm program, which gives a convenient interface to this repository. <br><br>  For example, one of the NPM modules is called a figlet, and it converts the text into ‚ÄúASCII art‚Äù, drawings made up of text characters.  Here is how to install it: <br><br><pre> <code class="bash hljs">$ npm install figlet npm GET https://registry.npmjs.org/figlet npm 200 https://registry.npmjs.org/figlet npm GET https://registry.npmjs.org/figlet/-/figlet-1.0.9.tgz npm 200 https://registry.npmjs.org/figlet/-/figlet-1.0.9.tgz figlet@1.0.9 node_modules/figlet $ node &gt; var figlet = require(<span class="hljs-string"><span class="hljs-string">"figlet"</span></span>); &gt; figlet.text(<span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(error, data) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) console.error(error); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> console.log(data); }); _ _ _ _ _ _ _ | | | | ___| | | ___ __ _____ _ __| | __| | | | |_| |/ _ \ | |/ _ \ \ \ /\ / / _ \| <span class="hljs-string"><span class="hljs-string">'__| |/ _` | | | _ | __/ | | (_) | \ VV / (_) | | | | (_| |_| |_| |_|\___|_|_|\___/ \_/\_/ \___/|_| |_|\__,_(_)</span></span></code> </pre><br><br>  After running npm install, NPM will create the node_modules directory.  Inside it will be the figlet directory containing the library.  When we run a node and call require ("figlet"), the library is loaded and we can call its text method to print large beautiful letters. <br><br>  Interestingly, instead of simply returning a string that contains large letters, figlet.text takes a callback function, to which it passes the result.  It also passes there another argument, error, which in the case of an error will contain an error object, and in case of success, null. <br><br>  This principle of operation adopted in Node.  To create letters, figlet must read a file from a disk containing letters.  Reading a file is an asynchronous operation in Node, so figlet.text cannot return the result immediately.  Asynchrony is contagious - any function that calls asynchronous itself becomes asynchronous. <br><br>  NPM is more than just npm install.  It reads package.json files containing information in JSON format about a program or library, in particular, on which libraries it is based.  Running npm install in the directory containing the file automatically installs all dependencies, and in turn their dependencies.  The npm tool is also used to host libraries in the NPM online storage so that other people can find, download, and use them. <br><br>  We will no longer go into the details of using NPM.  Contact npmjs.org for documentation on finding libraries. <br><br><h4>  Module file system </h4><br>  One of the most popular built-in Node modules is the ‚Äúfs‚Äù module, which means ‚Äúfile system‚Äù.  The module provides functionality for working with files and directories. <br><br>  For example, there is a readFile function that reads a file and makes a callback with the contents of the file. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fs"</span></span>); fs.readFile(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"    :"</span></span>, text); });</code> </pre><br><br>  The second argument readFile sets the character encoding in which to convert the contents of the file into a string.  Text can be converted to binary data in different ways, but the newest one is UTF-8.  If you have no reason to believe that the file contains text in a different encoding, you can safely pass the "utf8" parameter.  If you did not specify a character encoding, Node will give you binary data in the form of a Buffer object, not a string.  This is a massive object containing the bytes from the file. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fs"</span></span>); fs.readFile(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, buffer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   "</span></span>, buffer.length, <span class="hljs-string"><span class="hljs-string">" ."</span></span>, <span class="hljs-string"><span class="hljs-string">" :"</span></span>, buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); });</code> </pre><br><br>  A similar function, writeFile, is used to write a file to disk. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fs"</span></span>); fs.writeFile(<span class="hljs-string"><span class="hljs-string">"graffiti.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"  Node "</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  ,   :"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" .  ."</span></span>); });</code> </pre><br><br>  You do not need to set the encoding here, because writeFile assumes that if it was given a string for writing, and not a Buffer object, then it should be output as text with the default encoding UTF-8. <br><br>  The ‚Äúfs‚Äù module contains a lot of useful information: the readdir function returns a list of directory files as an array of strings, stat returns information about the file, rename renames the file, unlink deletes, and so on.  See the nodejs.org documentation <br><br>  Many fs functions have both a synchronous and asynchronous version.  For example, there is a synchronous version of the readFile function called readFileSync. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fs"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>));</code> </pre><br><br>  Synchronous functions are easier and more useful for simple scripts, where the additional speed of the asynchronous method is not important.  But note - for the duration of the synchronous operation, your program stops completely.  If she needs to respond to user input or other programs over the network, shutting down synchronous I / O leads to annoying delays. <br><br><h4>  HTTP module </h4><br>  Another main module is ‚Äúhttp‚Äù.  It provides functionality for creating HTTP servers and HTTP requests. <br><br>  Here is all you need to run a simple HTTP server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"http"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ response.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"text/html"</span></span>}); response.write(<span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;!&lt;/h1&gt;&lt;p&gt;  &lt;code&gt;"</span></span> + request.url + <span class="hljs-string"><span class="hljs-string">"&lt;/code&gt;&lt;/p&gt;"</span></span>); response.end(); }); server.listen(<span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre><br><br>  By running the script on your machine, you can direct the browser to <a href="http://localhost/">localhost</a> : 8000 / hello, thus creating a request to the server.  It will respond with a small HTML page. <br><br>  The function passed as an argument to createServer is called each time you try to connect to the server.  The request and response variables are objects that represent input and output data.  The first contains information on the request, for example, the url property contains the URL of the request. <br><br>  To send something back, use the methods of the response object.  The first, writeHead, writes response headers (see chapter 17).  You give it a status code (in this case, 200 for ‚ÄúOK‚Äù) and an object containing header values.  Here we inform the client that he must wait for the HTML document. <br><br>  Then comes the response body (the document itself), sent via response.write.  This method can be called several times if you want to send a response in chunks, for example, sending stream data as it arrives.  Finally, response.end signals the end of the response. <br><br>  The server.listen call forces the server to listen to requests on port 8000. Therefore, you need to go to localhost: 8000 in the browser, and not just to localhost (where the default port is 80). <br><br>  To stop such a script Node, which does not end automatically, because it is waiting for the following events (in this case, connections), you must press Ctrl-C. <br><br>  A real web server does much more than this example.  He looks at the request method (the method property) to understand what action the client is trying to perform, and at the request URL to see which resource this action should be performed on.  Next you will see a more advanced version of the server. <br><br>  To make an HTTP client, we can use the ‚Äúhttp‚Äù request module function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"http"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = http.request({ <span class="hljs-attr"><span class="hljs-attr">hostname</span></span>: <span class="hljs-string"><span class="hljs-string">"eloquentjavascript.net"</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">"/20_node.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {<span class="hljs-attr"><span class="hljs-attr">Accept</span></span>: <span class="hljs-string"><span class="hljs-string">"text/html"</span></span>} }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"    "</span></span>, response.statusCode); }); request.end();</code> </pre><br><br>  The first request argument configures the request, explaining to Node which server we will communicate with, which way the request will have, which method to use, etc.  The second is the function.  which will need to call at the end of the request.  It is passed the response object, which contains all the information on the response - for example, a status code. <br><br>  Like the server's response object, the object returned by request allows you to transfer data using the write method and end the request with the end method.  The example does not use write, because GET requests should not contain data in the body. <br><br>  For requests for secure URLs (HTTPS), Node offers an https module, which has its own request function, similar to http.request. <br><br><h4>  Streams </h4><br>  We saw two examples of streams in the HTTP examples ‚Äî a response object to which the server can write, and a request object, which is returned from http.request <br><br>  Writeable streams are a popular concept in Node interfaces.  All threads have a write method that can be passed a string or a Buffer object.  The end method closes the stream, and if there is an argument, will output a piece of data before closing.  Both methods can be given a callback function through an additional argument, which they will call at the end of the recording or closing the stream. <br><br>  It is possible to create a stream showing a file using the fs.createWriteStream function.  You can then use the write method to write to the file bit by bit, and not entirely, as in fs.writeFile. <br><br>  Readable threads will be a bit more complicated.  Both the request variable passed to the callback function in the HTTP server and the response variable passed to the HTTP client are readable threads.  (The server reads the request and then writes responses, and the client writes the request and reads the response).  Reading from the stream is done through event handlers, not through methods. <br><br>  Objects that create events in Node have an on method that is similar to the addEventListener browser method.  You give it an event name and a function, and it registers this function so that it will be called immediately when an event occurs. <br><br>  Reading threads have ‚Äúdata‚Äù and ‚Äúend‚Äù events.  The first occurs when the data is received, the second - at the end.  This model is suitable for streaming data that can be processed immediately, even if not the entire document is received.  The file can be read as a stream through fs.createReadStream. <br><br>  The following code creates a server that reads the request bodies and sends them back in response as a text in capital letters. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"http"</span></span>); http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ response.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>}); request.on(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chunk</span></span></span><span class="hljs-function">) </span></span>{ response.write(chunk.toString().toUpperCase()); }); request.on(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.end(); }); }).listen(<span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre><br><br>  The chunk variable passed to the data handler will be a binary Buffer, which can be converted to a string by calling its toString method, which decodes it from the default encoding (UTF-8). <br><br>  The following code, running simultaneously with the server, sends a request to the server and displays the response received: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"http"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = http.request({ <span class="hljs-attr"><span class="hljs-attr">hostname</span></span>: <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8000</span></span>, <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ response.on(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chunk</span></span></span><span class="hljs-function">) </span></span>{ process.stdout.write(chunk.toString()); }); }); request.end(<span class="hljs-string"><span class="hljs-string">"Hello server"</span></span>);</code> </pre><br><br>  The example is written in process.stdout (the standard output of the process, which is a writable stream), and not in console.log.  We cannot use console.log, since it adds an extra line feed after each piece of code - this is not necessary here. <br><br><h4>  Simple file server </h4><br>  Let's combine our new knowledge about HTTP servers and working with the file system, and put a bridge between them: an HTTP server that provides remote access to files.  This server has many options for use.  It allows web applications to store and share data, or can give a group of people access to a set of files. <br><br>  When we treat files as HTTP resources, the GET, PUT, and DELETE methods can be used to read, write, and delete files.  We will interpret the path in the request as the path to the file. <br><br>  We do not need to open access to the entire file system, so we will interpret these paths as given relative to the root directory, and this will be the script startup directory.  If I start the server from / home / marijn / public / (or C: \ Users \ marijn \ public \ on Windows), then the request for /file.txt should point to /home/marijn/public/file.txt (or C : \ Users \ marijn \ public \ file.txt). <br><br>  We will build the program gradually using the methods object to store functions that process different HTTP methods. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"http"</span></span>), fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methods = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">respond</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, body, type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!type) type = <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>; response.writeHead(code, {<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: type}); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body &amp;&amp; body.pipe) body.pipe(response); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> response.end(body); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.method <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> methods) methods[request.method](urlToPath(request.url), respond, request); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> respond(<span class="hljs-number"><span class="hljs-number">405</span></span>, <span class="hljs-string"><span class="hljs-string">"Method "</span></span> + request.method + <span class="hljs-string"><span class="hljs-string">" not allowed."</span></span>); }).listen(<span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre><br><br>  This code will launch a server returning 405 errors ‚Äî this code is used to indicate that the requested method is not supported by the server. <br><br>  The respond function is passed to functions that handle different methods, and it acts as a callback to end the request.  It accepts the HTTP status code, body, and possibly the content type.  If the transferred body is a readable stream, it will have a pipe method that is used to pass the readable stream to the recordable one.  If not, it is assumed that this is either null (the body is empty), or a string, and then it is passed directly to the end method of the response. <br><br>  To get the path from the URL in the request, the urlToPath function, using the built-in Node module ‚Äúurl‚Äù, parses the URL.  It takes a pathname, something like /file.txt, decodes it to remove% 20 escape codes, and inserts a dot at the beginning to get a path relative to the current directory. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlToPath</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).parse(url).pathname; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">decodeURIComponent</span></span>(path); }</code> </pre><br><br>  Does it seem to you that the urlToPath function is insecure?  You're right.  Let's return to this issue in the exercises. <br><br>  We will arrange the GET method so that it returns a list of files when reading a directory, and the contents of a file when reading a file. <br><br>  Backfill question - what type of Content-Type header should we return when reading a file.  Since there can be anything in the file, the server cannot simply return the same type for all.  But NPM can help with that.  The mime module (file type content indicators like text / plain are also called MIME types) knows the correct type for a huge number of file extensions. <br><br>  By running the following npm command in the directory where the server script lives, you can use require ("mime") to query the type library. <br><br><pre> <code class="bash hljs">$ npm install mime npm http GET https://registry.npmjs.org/mime npm http 304 https://registry.npmjs.org/mime mime@1.2.11 node_modules/mime</code> </pre><br><br>  When the requested file does not exist, the correct error code for this case is 404. We will use fs.stat to return information on the file to find out if there is such a file, and if this is not a directory. <br><br><pre> <code class="javascript hljs">methods.GET = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, respond</span></span></span><span class="hljs-function">) </span></span>{ fs.stat(path, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error &amp;&amp; error.code == <span class="hljs-string"><span class="hljs-string">"ENOENT"</span></span>) respond(<span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"File not found"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) respond(<span class="hljs-number"><span class="hljs-number">500</span></span>, error.toString()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stats.isDirectory()) fs.readdir(path, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, files</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) respond(<span class="hljs-number"><span class="hljs-number">500</span></span>, error.toString()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> respond(<span class="hljs-number"><span class="hljs-number">200</span></span>, files.join(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> respond(<span class="hljs-number"><span class="hljs-number">200</span></span>, fs.createReadStream(path), <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"mime"</span></span>).lookup(path)); }); };</code> </pre><br><br>  Because disk requests take time, fs.stat works asynchronously.  When the file does not exist, fs.stat will pass an error object with the "ENOENT" code property to the callback function.  It would be great if Node defined different types of errors for different errors, but there is no such thing.  Instead, it produces tangled Unix-style codes. <br><br>  We will issue all unexpected errors with code 500, denoting that there is a problem on the server - in contrast to codes starting with 4, which indicate a problem with the request.  In some situations it will not be quite neat, but for a small sample program this will be enough. <br><br>  The stats object returned by fs.stat tells us everything about the file.  For example, size - file size, mtime - modification date.  Here we need to find out if this is a directory or a regular file ‚Äî the isDirectory method will tell us. <br><br>         fs.readdir,      ,   .         fs.createReadStream     ,    ,   ‚Äúmime‚Äù    . <br><br>   DELETE  : <br><br><pre> <code class="javascript hljs">methods.DELETE = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, respond</span></span></span><span class="hljs-function">) </span></span>{ fs.stat(path, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error &amp;&amp; error.code == <span class="hljs-string"><span class="hljs-string">"ENOENT"</span></span>) respond(<span class="hljs-number"><span class="hljs-number">204</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) respond(<span class="hljs-number"><span class="hljs-number">500</span></span>, error.toString()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stats.isDirectory()) fs.rmdir(path, respondErrorOrNothing(respond)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fs.unlink(path, respondErrorOrNothing(respond)); }); };</code> </pre><br><br> ,  ,        204  .  ,      ,      ,    .  HTTP      ‚Äì   ,              . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">respondErrorOrNothing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">respond</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) respond(<span class="hljs-number"><span class="hljs-number">500</span></span>, error.toString()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> respond(<span class="hljs-number"><span class="hljs-number">204</span></span>); }; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the HTTP response contains no data, you can use the status code 204 (‚Äúno content‚Äù). Since we need to provide callback functions that either report errors or return a 204 response in different situations, I wrote a special function respondErrorOrNothing that creates such a callback. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the PUT request handler:</font></font><br><br><pre> <code class="javascript hljs">methods.PUT = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, respond, request</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outStream = fs.createWriteStream(path); outStream.on(<span class="hljs-string"><span class="hljs-string">"error"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ respond(<span class="hljs-number"><span class="hljs-number">500</span></span>, error.toString()); }); outStream.on(<span class="hljs-string"><span class="hljs-string">"finish"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ respond(<span class="hljs-number"><span class="hljs-number">204</span></span>); }); request.pipe(outStream); };</code> </pre><br><br>        ‚Äì   ,    .    pipe        ,    ‚Äì    .     ,   ‚Äúerror‚Äù,      .    , pipe   ,      ‚Äúfinish‚Äù.           204. <br><br>     : eloquentjavascript.net/code/file_server.js.       Node. ,          . <br><br>    curl,   unix-,     HTTP .     . ‚ÄìX     ,  ‚Äìd    . <br><br><pre> <code class="bash hljs">$ curl http://localhost:8000/file.txt File not found $ curl -X PUT -d hello http://localhost:8000/file.txt $ curl http://localhost:8000/file.txt hello $ curl -X DELETE http://localhost:8000/file.txt $ curl http://localhost:8000/file.txt File not found</code> </pre><br><br>    file.txt   ,    .  PUT  ,  - ‚Äì     .     DELETE   . <br><br><h4>  Error processing </h4><br>       ,    ,    ,   .         ,     ,      .       ,  ,    . <br><br>  ,  -     ?     try,         .  Node            (   )   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, our server will crash if there are problems in the code - unlike asynchronous problems, which will be passed as arguments to the call functions. If we need to handle all the exceptions that occur during the processing of a request, so that we can send an exact response, we need to add try / catch blocks in each callback.</font></font><br><br>  This is bad.    Node  ,        ,           ,    . <br><br>    ‚Äì  ,      17.   ,         .  Node    promise       .   Node  ,      .   ‚Äúpromise‚Äù  NPM   denodeify,      fs.readFile     ,  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"promise"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"fs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> readFile = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.denodeify(fs.readFile); readFile(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The file contained: "</span></span> + content); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Failed to read file: "</span></span> + error); });</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For comparison, I wrote another version of the file server using promises, which can be found at </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eloquentjavascript.net/code/file_server_promises.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is cleaner because functions can now return results rather than assign callbacks, and exceptions are implicitly passed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me give you a few lines from there to show the difference in styles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fsp object used in the code contains variants of the fs functions with promises wrapped with Promise.denodeify. The object returned from the method handler, with the code and body properties, becomes the final result of the promise chain, and is used to determine which response to send to the client.</font></font><br><br><pre> <code class="javascript hljs">methods.GET = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inspectPath(path).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stats) <span class="hljs-comment"><span class="hljs-comment">// Does not exist return {code: 404, body: "File not found"}; else if (stats.isDirectory()) return fsp.readdir(path).then(function(files) { return {code: 200, body: files.join("\n")}; }); else return {code: 200, type: require("mime").lookup(path), body: fs.createReadStream(path)}; }); }; function inspectPath(path) { return fsp.stat(path).then(null, function(error) { if (error.code == "ENOENT") return null; else throw error; }); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The inspectPath function is a simple wrapper around fs.stat that handles the case when the file is not found. In this case, we replace the error with success, returning null. All other errors can be transmitted. When the promise returned from these handlers fails, the server responds with a code of 500.</font></font><br><br><h4>  Total </h4><br> Node ‚Äì   ,   JavaScript  .       ,      .      ,       JavaScript,     Node  . <br><br> NPM    ,       (   -,      ),         . Node      ,  ‚Äúfs‚Äù     ,  ‚Äúhttp‚Äù   HTTP    HTTP . <br><br>      Node  ,         ,  fs.readFileSync.     ,  Node     ,   I/O  . <br><br><h4>  Exercises </h4><br><h5>     </h5><br>   17        eloquentjavascript.net/author,         Accept. <br><br>   ,   Node http.request. ,   ,  text/plain, text/html  application/json. ,          headers,   http.request. <br><br>    . <br><br><h5>   </h5><br><br>             ,   /home/marijn/public.   ,  -      ,     .  What happened? <br><br>    ,   urlToPath,   : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlToPath</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).parse(url).pathname; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">decodeURIComponent</span></span>(path); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now remember that the paths passed to the ‚Äúfs‚Äù function can be relative. </font><font style="vertical-align: inherit;">They may contain the path ‚Äú../‚Äù in the top directory. </font><font style="vertical-align: inherit;">What happens if a client sends requests to a URL like the following: </font></font><br><br> <a href="http://myhostname/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">myhostname</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 8000 /../. Config / config / google-chrome / Default / Web% 20Data </font></font><br> <a href="http://myhostname/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">myhostname</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 8000 /../. Ssh / id_dsa </font></font><br> <a href="http://myhostname/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">myhostname</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 8000 / .. /../../etc/passwd </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Change the urlToPath function to fix this problem. </font><font style="vertical-align: inherit;">Note that Windows Node allows both forward and backward slashes to specify paths. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, meditate on the fact that once you put a raw system on the Internet, errors in the system can be used against you and your computer.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating directories </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although the DELETE method works when deleting directories (via fs.rmdir), the server does not provide the ability to create directories. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add support for the MKCOL method, which should create a directory via fs.mkdir. </font><font style="vertical-align: inherit;">MKCOL is not the main HTTP method, but it exists precisely for this in the WebDAV standard, which contains HTTP extensions to use to write resources, not just to read them.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Public network space </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the file server produces any files and even returns the correct Content-Type header, it can be used to maintain the website. Since it allows everyone to delete and replace files, it would be an interesting site - which can be changed, corrupted and deleted by anyone who can create the correct HTTP request. But it would still be a website. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write a simple HTML page with a simple javascript file. Place them in a directory maintained by the server and open in a browser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, as an advanced exercise, combine all the knowledge gained from the book to build a more user-friendly interface to modify the website from within the site itself.</font></font><br><br>   HTML ( 18)   ,  ,        HTTP-,     17. <br><br>    ,   .   ,       .   ,          . <br><br>         ‚Äì    ,      .   ,  ,      . <br><br>       ,  firewall,    ,       .     whatismyip.com,  IP       :8000    .      ,      . </div><p>Source: <a href="https://habr.com/ru/post/245775/">https://habr.com/ru/post/245775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245755/index.html">Gradual increase in performance when applying vector permutation instructions from SSE to AVX3.1</a></li>
<li><a href="../245759/index.html">Google Chrome will mark HTTP sites as unsafe</a></li>
<li><a href="../245763/index.html">Some tips for speeding up Drupal</a></li>
<li><a href="../245765/index.html">Prelatement to the decade of Openbravo POS</a></li>
<li><a href="../245767/index.html">Expressive JavaScript: Project: Paint</a></li>
<li><a href="../245777/index.html">Diagnosing problems after installation or upgrade ORACLE APEX</a></li>
<li><a href="../245781/index.html">Develop a mobile app and earn money</a></li>
<li><a href="../245783/index.html">The tale of how we participated in the hackathons, or Fear and Hatred in Silicon Valley</a></li>
<li><a href="../245785/index.html">How to make Greek letters in formulas in bold in LaTeX</a></li>
<li><a href="../245787/index.html">DigitalOcean announced data center in Germany</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>