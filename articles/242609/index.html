<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive javascript: search and error handling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive javascript: search and error handling</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>Debugging is initially twice as difficult to write code.</i>  <i>Therefore, if you write code as abstruse as you can, then by definition you are not able to debug it.</i> <i><br></i>  <i>Brian Kernigan and PJ Plauer, Basics of Program Style</i> <br><br>  <i>Yuan-Ma wrote a small program that uses many global variables and terrible hacks.</i>  <i>The student, reading the program, asked him: ‚ÄúYou warned us about similar techniques, but at the same time I find them in your own program.</i>  <i>How is this possible? ‚ÄùThe master replied:‚Äú There is no need to run after the watering hose if the house is not on fire. ‚Äù</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i>Master Yuan-Ma, "Programming Book".</i> <br><br>  A program is a crystallized thought.  Sometimes thoughts get confused.  Sometimes, when thoughts are turned into a program, mistakes sneak into code.  In both cases, the result is a damaged program. <br><br>  Deficiencies in programs are usually called bugs.  These may be programmer errors or problems in the systems with which the program interacts.  Some errors are obvious, others are elusive, and may be hidden in systems for years. <br><br>  Often the problem arises in those situations, the occurrence of which the programmer initially did not foresee.  Sometimes these situations cannot be avoided.  When a user is asked to enter his age, and he enters an "orange", this puts the program in a difficult situation.  These situations need to be foreseen and somehow handled. <br><a name="habracut"></a><br><h4>  Programmer errors </h4><br>  In the case of programmer errors, our goal is clear.  We need to find them and fix them.  Such errors range from simple typographical errors, which the computer will complain to immediately, as soon as it sees the program, to hidden errors in our understanding of how the program works, which lead to incorrect results in special cases.  Errors of the latter kind can be searched for weeks. <br><br>  Different languages ‚Äã‚Äãcan help you find bugs in different ways.  Unfortunately, JavaScript is located at the end of this scale, designated as ‚Äúhardly helps at all‚Äù.  Some languages ‚Äã‚Äãneed to know exactly the types of all variables and expressions before running the program, and they will immediately tell you if the types are used incorrectly.  JavaScript only considers types during the execution of programs, and even then it allows doing not very meaningful things without any complaints, for example <br><br><pre><code class="javascript hljs">x = <span class="hljs-literal"><span class="hljs-literal">true</span></span> * <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br><br>  Some things JavaScript does complain about.  Writing a syntactically incorrect program will immediately cause an error.  Other errors, such as calling something that is not a function, or calling the property of an undefined variable, will occur when the program is executed when it encounters such a meaningless situation. <br><br>  But often your meaningless calculations just spawn NaN (not a number) or undefined.  The program will happily continue, being confident that it is doing something meaningful.  The error will manifest itself later when such a dummy value has already passed through several functions.  It may not cause an error message at all, but simply lead to an incorrect execution result.  Finding the source of such problems is a difficult task. <br><br>  The process of finding bugs in programs is called debugging. <br><br><h4>  Strict mode </h4><br>  JavaScript can be forced to be stricter by translating it into strict mode.  For this, use strict is written at the top of the file or function body.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canYouSpotTheProblem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; counter &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; counter++) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); } canYouSpotTheProblem(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ReferenceError: counter is not defined</span></span></code> </pre><br><br>  Usually, when you forget to write var before a variable, as in the example before counter, JavaScript quietly creates a global variable and uses it.  In strict mode, an error is thrown.  It is very convenient.  However, an error is not generated when a global variable already exists - only when the assignment creates a new variable. <br><br>  Another change is that this binding contains undefined in those functions that were not called as methods.  When we call a function that is not in strict mode, this refers to the global scope object.  Therefore, if you accidentally incorrectly invoke the method in strict mode, JavaScript will generate an error if it tries to read something from this, and does not happily work with the global object. <br><br>  For example, consider the code that calls the constructor without the new keyword, in which case this will not refer to the object being created. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ferdinand = Person(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-comment"><span class="hljs-comment">// - console.log(name); // ‚Üí </span></span></code> </pre><br><br>  An invalid Person call succeeds, but returns as undefined and creates a global variable name.  In strict mode, everything is different: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-comment"><span class="hljs-comment">// ,    'new' var ferdinand = Person(" "); // ‚Üí TypeError: Cannot set property 'name' of undefined</span></span></code> </pre><br><br>  We are immediately reported an error.  Very comfortably. <br><br>  Strict mode can do something else.  It prohibits calling a function with several parameters with the same name, and removes some of the potentially problematic properties of a language (for example, a with statement that is so terrible that it is not even discussed in this book). <br><br>  In short, ‚Äúuse strict‚Äù before the program text rarely causes problems, but it helps you to see them. <br><br><h4>  Testing </h4><br>  If the language is not going to help us in the search for errors, we have to look for them in a complex way: by running the program and observing whether it does something as it should. <br><br>  Doing it manually, over and over again is a sure way to go crazy.  Fortunately, it is often possible to write another program that automates the checking of your main program. <br><br>  For example, let‚Äôs look at the Vector type again. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } Vector.prototype.plus = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">other</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + other.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y + other.y); };</code> </pre><br><br>  We will write a program that checks that our implementation of Vector works as it should.  Then, after each change in the implementation, we will run a verification program to make sure that we have not broken anything.  When we add functionality (for example, a new method) to the Vector type, we add checks to this new functionality. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testVector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3 = p1.plus(p2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p1.x !== <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">": x property"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p1.y !== <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" : y property"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p2.x !== <span class="hljs-number"><span class="hljs-number">-10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" : negative x property"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p3.x !== <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" : x from plus"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p3.y !== <span class="hljs-number"><span class="hljs-number">25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" : y from plus"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(testVector()); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  </span></span></code> </pre><br><br>  Writing such checks results in duplicate code.  Fortunately, there are software products that help to write sets of checks with the help of a special language adapted for writing checks.  They are called the testing frameworks. <br><br><h4>  Debugging </h4><br>  When you notice a problem in the program - it behaves incorrectly and gives errors, - it's time to find out what the problem is. <br><br>  Sometimes it's obvious.  The error message directs you to a specific program line, and if you read the error description and this line, you can often find a problem. <br><br>  But not always.  Sometimes the line that leads to an error simply turns out to be the first place where the incorrect value obtained elsewhere is used incorrectly.  Sometimes there is no error message at all - there is just an incorrect result.  If you did the exercises from the previous chapters, you must have fallen into such situations. <br><br>  The following example tries to convert the number of a given number system to a string, subtracting the last digit and making a division, to get rid of this digit.  But the wild result produced by the program hints at the presence of an error in it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-string"><span class="hljs-string">""</span></span>, sign = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { sign = <span class="hljs-string"><span class="hljs-string">"-"</span></span>; n = -n; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { result = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(n % base) + result; n /= base; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sign + result; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numberToString(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e-3181.3‚Ä¶</span></span></code> </pre><br><br>  Even if you find a problem, pretend you haven't found it yet.  We know that the program is failing, and we need to know why. <br><br>  Here you need to overcome the desire to start making random changes to the code.  Think instead.  Analyze the result and come up with a theory on which it happens.  Make additional observations to test the theory ‚Äî and if there is no theory, make observations that would help you invent it. <br><br>  Placing multiple console.log calls in strategic locations is a good way to get additional information about what the program is doing.  In our case, we need n to take the values ‚Äã‚Äã13, 1, then 0. Let's output the values ‚Äã‚Äãat the beginning of the cycle: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">1.3</span></span> <span class="hljs-number"><span class="hljs-number">0.13</span></span> <span class="hljs-number"><span class="hljs-number">0.013</span></span> ‚Ä¶ <span class="hljs-number"><span class="hljs-number">1.5e-323</span></span></code> </pre><br><br>  Y-yes.  The division of 13 by 10 does not yield an integer.  Instead of n / = base, we need n = Math.floor (n / base), then the number will be correctly ‚Äúshifted‚Äù to the right. <br><br>  In addition to console.log, you can use the debugger in the browser.  Modern browsers are able to put a breakpoint on the selected line of code.  This will pause the program execution each time the selected line is reached, and then you can view the contents of the variables.  I will not describe the process in detail, since it is organized differently in different browsers - look for developer tools in your browser.  Another way to set a breakpoint is to include in the code an instruction for the debugger consisting of the debugger keyword.  If the developer tools are active, the execution of the program will be suspended on this instruction, and you can examine the status of the program. <br><br><h4>  Error propagation </h4><br>  Unfortunately, the programmer can prevent the appearance of not all problems.  If your program communicates with the outside world, it may receive incorrect input data, or the systems with which it tries to interact may be broken or inaccessible. <br><br>  Simple programs, or programs running under your supervision, can simply ‚Äúgive up‚Äù at such a moment.  You can study the problem and try again.  "Real" applications should not just "fall".  Sometimes you have to accept incorrect input data and somehow work with them.  In other cases, you need to inform the user that something went wrong - and then give up.  In any case, the program should do something in response to a problem. <br><br>  Suppose you have a function promptInteger, which requests an integer and returns it.  What should she do if the user enters an "orange"? <br><br>  One option is to return a special meaning.  Usually for these purposes use null and undefined. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promptNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">question</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(question, <span class="hljs-string"><span class="hljs-string">""</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(result)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promptNumber(<span class="hljs-string"><span class="hljs-string">"  ?"</span></span>));</code> </pre><br><br>  This is a reliable strategy.  Now, any code calling promptNumber should check if a number was returned, and if not, somehow get out of the situation - ask again, or set a default value.  Or return the special value already to the one who caused it, reporting failure. <br><br>  In many such cases, when errors occur frequently and the code calling the function must take them into account, it is perfectly acceptable to return a special value as an error indicator.  But there are also disadvantages.  First, what if a function can return any type of value anyway?  It is difficult for her to find a special value that will differ from an acceptable result. <br><br>  The second problem - working with special values ‚Äã‚Äãcan trash the code.  If the promptNumber function is called 10 times, then you need to check 10 times if it returned null.  If the response to null is to return null to a higher level, then where this code was called, you also need to embed a check for null, and so on. <br><br><h4>  Exceptions </h4><br>  When the function cannot work normally, we would like to stop the work and jump to where such an error can be processed.  This is handled by exception handling. <br><br>  The code that encountered the problem at the time of execution can raise (or throw) an exception (raise exception, throw exception), which is some kind of value.  The return of an exception resembles a kind of "pumped" return from a function ‚Äî it jumps not only from the function itself, but also from all the functions that called it, to the place from which the execution began.  This is called unwinding the stack.  Perhaps you remember the stack of functions from Chapter 3 ... The exception quickly flushes the stack down, throwing out all the contexts of the calls that it encounters. <br><br>  If the exceptions immediately reached the very bottom of the stack, there would be little benefit from them.  They would just provide an interesting way to blow up the program.  Their strength lies in the fact that on their way in the stack you can put "obstacles" that will catch exceptions, rushing along the stack.  And then with this you can do something useful, after which the program continues to run from the point where the exception was caught. <br><br>  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promptDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">question</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = prompt(question, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.toLowerCase() == <span class="hljs-string"><span class="hljs-string">"left"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"L"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.toLowerCase() == <span class="hljs-string"><span class="hljs-string">"right"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"R"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">" : "</span></span> + result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">look</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (promptDirection(<span class="hljs-string"><span class="hljs-string">"?"</span></span>) == <span class="hljs-string"><span class="hljs-string">"L"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  "</span></span>, look()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"-  : "</span></span> + error); }</code> </pre><br><br>  The throw keyword is used to throw an exception.  The catch is a piece of code wrapped in a try block followed by catch.  When the code in the try block throws an exception, the catch block is executed.  The variable in brackets will be bound to the exception value.  After the execution of the catch block is completed, or if the try block is executed without any problems, the execution proceeds to the code behind the try / catch instruction. <br><br>  In this case, we used the Error constructor to create an exception.  This is a standard constructor that creates an object with the message property.  In modern JavaScript environments, instances of this constructor also collect information about the call stack that was accumulated at the time the exception was thrown - the so-called stack trace.  This information is stored in the stack property, and can help with the analysis of the problem ‚Äî it tells you in which function the problem occurred and what other functions led to this call. <br><br>  Note that the look function completely ignores the possibility of problems in promptDirection.  This advantage of exceptions - the code that handles errors is needed only at the place where the error occurs, and where it is processed.  Intermediate functions simply do not pay attention to it. <br><br>  Almost. <br><br><h4>  Clean up with exceptions </h4><br>  Imagine the following situation: the withContext function wants to make sure that when it is executed, the top-level variable context gets a special context value.  After completion of execution, it restores its old value. <br><br>  var context = null; <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newContext, body</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldContext = context; context = newContext; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = body(); context = oldContext; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  What if the body function throws an exception?  In this case, the call withContext will be thrown out of the stack exception, and the context value will never be returned to its original value. <br><br>  But the try instruction has another feature.  It can be followed by a finally block, either instead of catch, or with catch.  The finally block means ‚Äúexecute the code anyway after the try block has been executed‚Äù.  If functions need something to clean up, then the cleaning code should be included in the finally block. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newContext, body</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldContext = context; context = newContext; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { context = oldContext; } }</code> </pre><br><br>  Notice that we no longer need to store the result of the body call in a separate variable to return it.  Even if we return from the try block, the finally block will still be executed.  Now we can safely do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { withContext(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">": "</span></span> + e); } <span class="hljs-comment"><span class="hljs-comment">// ‚Üí : Error:   ! console.log(context); // ‚Üí null</span></span></code> </pre><br><br>  Despite the fact that the function called from withContext is ‚Äúbroken‚Äù, withContext itself still clears the value of the context variable. <br><br><h4>  Selective catch exceptions </h4><br>  When an exception reaches the bottom of the stack and no one has caught it, the environment handles it.  How exactly - depends on the specific environment.  In browsers, a description of the error is displayed in the console (it is usually available in the "Tools" or "Development" menu). <br><br>  If we are talking about errors or problems that the program cannot handle in principle, it is permissible to just skip such an error.  An unhandled exception is a reasonable way to report a problem in a program, and the console in modern browsers will give you the necessary information about which function calls were on the stack at the time the problem occurred. <br><br>  If the occurrence of a problem is predictable, the program should not fall with an unhandled exception - this is not very user-friendly. <br><br>  Invalid use of a language ‚Äî references to a non-existent variable, a property request on a variable equal to null, or a call to something that is not a function, also result in throwing exceptions.  Such exceptions can be caught just like your own. <br><br>  When entering a catch block, we only know that something inside the try block led to an exception.  We do not know what exactly, and what exception occurred. <br><br>  JavaScript (which is a flagrant omission) does not provide direct support for selective catching exceptions: either we catch everything or none.  Because of this, people often assume that the exception that occurred is precisely the one for which the catch block was written. <br><br>  But it can be different.  The violation happened somewhere else, or an error crept into the program.  Here is an example where we try to call promptDirection until we get a valid answer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = promtDirection(<span class="hljs-string"><span class="hljs-string">"?"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üê ! console.log("  ", dir); break; } catch (e) { console.log(" .   ."); } }</span></span></code> </pre><br><br>  The for (;;) construct is a way to arrange an infinite loop.  We fall out of it only when we get a valid direction.  But we incorrectly wrote the name promptDirection, which leads to the error ‚Äúundefined variable‚Äù.  And since the catch block ignores the value of the exception e, assuming that he is dealing with another problem, he believes that the exception thrown is the result of incorrect input data.  This leads to an infinite loop and hides a useful error message about the wrong variable name. <br><br>  As a rule, you should not catch exceptions so much, unless you have a goal to redirect them somewhere - for example, over the network, to inform the other system about the fall of our program.  And even then carefully look, whether the important information will not be hidden. <br><br>  So, we need to catch a certain exception.  We can check in the catch block whether the exception that has occurred is the exception of interest to us, and otherwise re-throw it.  But how do we recognize an exception? <br><br>  Of course, we could compare the message property with the error message we are waiting for.  But this is not a reliable way to write code ‚Äî use information meant for a person (a message) to make a software decision.  As soon as someone changes or translates this message, the code will stop working. <br><br>  Let's better define a new type of error and use instanceof to recognize it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stack = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>()).stack; } InputError.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.prototype); InputError.prototype.name = <span class="hljs-string"><span class="hljs-string">"InputError"</span></span>;</code> </pre><br><br>  The prototype is inherited from Error.prototype, so the instanceof Error will also be executed for objects of type InputError.  And the name property is assigned to it, as well as other standard types of errors (Error, SyntaxError, ReferenceError, etc.) <br><br>  Assigning the stack property tries to pass a stack trace to this object, on those platforms that support it, by creating an Error object and using its stack. <br><br>  Now promptDirection can create such an error. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promptDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">question</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = prompt(question, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.toLowerCase() == <span class="hljs-string"><span class="hljs-string">"left"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"L"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.toLowerCase() == <span class="hljs-string"><span class="hljs-string">"right"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"R"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputError(<span class="hljs-string"><span class="hljs-string">"Invalid direction: "</span></span> + result); }       . for (;;) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = promptDirection(<span class="hljs-string"><span class="hljs-string">"?"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InputError) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" .   ."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } }</code> </pre><br><br>  The code catches only instances of InputError and skips other exceptions.  If you make the same typo again, the message about the undefined variable will be displayed correctly. <br><br><h4>  Assertions </h4><br>  Assertions are a tool for simple error checking.  Consider the assert helper function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertionFailed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message; } AssertionFailed.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.prototype); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">test, message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!test) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssertionFailed(message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ assert(array.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"   lastElement"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array[array.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre><br><br>  This is a compact way to tighten the value requirements, which throws an exception when the specified condition is not met.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the lastElement function, which extracts the last element of an array, would return undefined for empty arrays if we did not use assertion. Extracting the last element of an empty array does not make sense, and this would clearly be a programmer's mistake. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assertions are a way to make sure that errors provoke the interruption of a program in the place where they are committed, and not just give out strange values ‚Äã‚Äãthat are transmitted through the system and cause problems in some other unrelated places.</font></font><br><br><h4>  Total </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Errors and invalid input data occur in life. Errors in the programs must be searched and corrected. It is easier to find them using automatic checking systems and adding statements to your programs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems caused by something that is not within your program need to be handled adequately. Sometimes, when a problem can be solved locally, it is permissible to return special values ‚Äã‚Äãto track such cases. In other cases, it is preferable to use exceptions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Throwing an exception causes the stack to unwind until a try / catch block is encountered or until we reach the bottom of the stack. </font><font style="vertical-align: inherit;">The exception value will be passed to the catch block, which will be able to verify that the exception is really what it is waiting for and handle it. </font><font style="vertical-align: inherit;">To work with unpredictable events in the program flow, you can use finally blocks so that certain parts of the code are executed anyway.</font></font><br><br><h4>  Exercises </h4><br><h5>  Replay </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose you have a function primitiveMultiply, which in 50% of cases multiplies 2 numbers, and in other cases throws an exception like MultiplicatorUnitFailure. </font><font style="vertical-align: inherit;">Write a function that wraps this one and just calls it until a successful result is obtained. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make sure that you handle only the exceptions you need.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MultiplicatorUnitFailure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMultiply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MultiplicatorUnitFailure(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reliableMultiply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } console.log(reliableMultiply(8, 8)); // ‚Üí 64</span></span></code> </pre><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Locked box </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider this rather contrived object: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> box = { <span class="hljs-attr"><span class="hljs-attr">locked</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">unlock</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">_content</span></span>: [], get content() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.locked) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._content; } };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a box with a lock. </font><font style="vertical-align: inherit;">Inside is an array, but it can only be reached when the box is not locked. </font><font style="vertical-align: inherit;">You cannot directly access the _content property. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write a withBoxUnlocked function that takes a function as an argument that unlocks the box, performs the function, and then always locks the box again before exiting - no matter whether the function passed correctly or if it threw an exception.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withBoxUnlocked</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">body</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } withBoxUnlocked(function() { box.content.push(""); }); try { withBoxUnlocked(function() { throw new Error("  ! !"); }); } catch (e) { console.log(" :", e); } console.log(box.locked); // ‚Üí true</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a bonus game, make sure that when you call withBoxUnlocked, when the box is not locked, the box remains unlocked. </font></font></div><p>Source: <a href="https://habr.com/ru/post/242609/">https://habr.com/ru/post/242609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242591/index.html">Stun gun in section: 3.000.000 volts for educational purposes</a></li>
<li><a href="../242593/index.html">Designing a news feed in social networks</a></li>
<li><a href="../242595/index.html">Megatons of waste paper with a flick of the wrist</a></li>
<li><a href="../242601/index.html">Immersion cooling, underwater servers: Immersion-2 for 3M ‚Ñ¢ Novec ‚Ñ¢ delivers magical results, put into practice in Hong Kong</a></li>
<li><a href="../242603/index.html">Cryptographic solutions. From the cloud signature to the trusted environment</a></li>
<li><a href="../242611/index.html">Career project manager vs organization</a></li>
<li><a href="../242613/index.html">Write clean code with Reactive Extensions</a></li>
<li><a href="../242615/index.html">‚ÄúEppur si muove!‚Äù * Or working with timezone in Python</a></li>
<li><a href="../242619/index.html">"IT theater" of concrete and green</a></li>
<li><a href="../242621/index.html">Objective-C Minimalism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>