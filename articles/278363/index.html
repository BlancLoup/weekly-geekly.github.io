<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Alljoyn: embedded view of the developer. Part 3: Porting on MK SAMD21</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles, we dealt with the basics of Alljoyn and the tools that help debugging. It's time to write code for the microcontroller. Briefly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Alljoyn: embedded view of the developer. Part 3: Porting on MK SAMD21</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/9zMct9rVH3w%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhi5Qq-E0JXhJt2PmdygZI9pinInng" frameborder="0" allowfullscreen=""></iframe><br>  In <a href="https://habrahabr.ru/company/rainbow/blog/273859/">previous articles,</a> we dealt with the basics of Alljoyn and the tools that help debugging.  It's time to write code for the microcontroller.  Briefly recall the architecture LSF (Lighting Software Framework). <br>  There are three entities in the LSF library: <br><ul><li>  Thin-lamp (lamp service), </li><li>  Router (lighting controller service), </li><li>  "Application" (lighting sample application). </li></ul><br>  Thin-bulb is the part that ‚Äúrotates‚Äù directly in the microcontroller of our smart light bulb.  That is what we are doing today.  The rest was described in great detail earlier; we will not stop again. <a name="habracut"></a><br><br>  The main thing is that all the actors are in the same local network, and the Router is ‚Äúcorrect‚Äù (see the <a href="https://habrahabr.ru/company/rainbow/blog/273859/">first part of the cycle</a> ). <br><img src="https://habrastorage.org/files/eca/110/9cb/eca1109cbdd143a2a9a4e596cd8b3038.png"><br><h5>  Our hardware configuration </h5><br>  In the role of a ‚Äúlight bulb‚Äù (physically), there is a debug board with <a href="http://www.atmel.com/tools/ATSAMD21-XPRO.aspx%3Ftab%3Doverview">samd21</a> and <a href="http://www.atmel.com/tools/ATWINC1500-XPRO.aspx">a winc 1500 wifi module, while the</a> role of Router is a program in Ubuntu <b>lighting controller service</b> .  As the controlling application, we will use the sample app LSF on the Android phone, which can be downloaded from the Allseen website of the alliance from the page of the respective <a href="https://wiki.allseenalliance.org/tsc/connected_lighting">working group</a> . <br><br>  The code for our debugging was written on the basis of the code for arduino (Thin Core) and the open code on the <a href="https://git.allseenalliance.org/cgit/lighting/service_framework.git/tree/thin_core_library/lamp_service%3Fid%3Dv15.04">github for the ‚Äúlight bulb‚Äù</a> .  As it seemed to us then, this is the closest example to pure C and the absence of an operating system.  But as it turned out later, this code is largely not completed and does not even perform the basic functions of a Thin device.  So I had to finish / redo a lot. <br>  All code is divided into 3 parts: Thin Core Alljoyn support, LSF ‚Äúlamp‚Äù support, and everything else (hal level, own functions). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Thin Core Code </h5><br>  The first thing to do is implement a hal level to be able to connect to the network.  In our case, it consists in raising a connection via UDP (for primary detection of a Thin device in the Alljoyn network using mdns), sending / receiving data via UDP, as well as raising the connection via TCP and receiving / sending data for basic communication on the network. <br>  All these functions are written in the file aj_net.s. <br>  The main problem was that the functions of interaction with the network in the arduino work on the flag, and in the library for winc interrupt, as well as for the library to work for winc, it is mandatory to constantly call the auxiliary function of polling flags set by the module.  In detail about work with winc1500 we wrote in one of our previous <a href="https://habrahabr.ru/company/rainbow/blog/275359/">articles</a> . <br>  The easiest way to begin to modify the hal level is with the connection setup functions via UDP and TCP.  They must prescribe the necessary lines for establishing a connection directly and configure the structure corresponding to the connection: specify the receive / transmit functions and receive / transmit buffers. <br><div class="spoiler">  <b class="spoiler_title">Code for UDP (connection is established in main)</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AJ_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AJ_Net_MCastUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AJ_NetSocket* netSock)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ret = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_ERR_READ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { netSock-&gt;rx.bufStart = udp_data_rx; netSock-&gt;rx.bufSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(udp_data_rx); netSock-&gt;rx.readPtr = udp_data_rx; netSock-&gt;rx.writePtr = udp_data_rx; netSock-&gt;rx.direction = AJ_IO_BUF_RX; netSock-&gt;rx.recv = AJ_Net_RecvFrom; netSock-&gt;tx.bufStart = udp_data_tx; netSock-&gt;tx.bufSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(udp_data_tx); netSock-&gt;tx.readPtr = udp_data_tx; netSock-&gt;tx.writePtr = udp_data_tx; netSock-&gt;tx.direction = AJ_IO_BUF_TX; netSock-&gt;tx.send = AJ_Net_SendTo; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_OK; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// Initialize socket address structure. addr.sin_family = AF_INET; addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT); addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP); src_addr.sin_family = AF_INET; src_addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT); //_htons(52148); src_addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP); // Initialize Wi-Fi parameters structure. memset((uint8_t *)¬∂m, 0, sizeof(tstrWifiInitParam)); // Initialize Wi-Fi driver with data and status callbacks. param.pfAppWifiCb = wifi_cb; ret = m2m_wifi_init(¬∂m); if (M2M_SUCCESS != ret) { printf("main: m2m_wifi_init call error!(%d)\r\n", ret); while (1); } // Initialize socket module socketInit(); registerSocketCallback(socket_cb, NULL); // Connect to router. m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL); printf("m2m_wifi_connect!\r\n"); ... }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">TCP code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AJ_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AJ_Net_Connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AJ_BusAttachment* bus, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AJ_Service* service)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(service-&gt;addrTypes &amp; AJ_ADDR_TCP4)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_ERR_CONNECT; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Connect()\n"</span></span>); addr.sin_port = _htons(service-&gt;ipv4port); addr.sin_addr.s_addr = _htonl(service-&gt;ipv4); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Connect(): ipv4= %x, port = %d\n"</span></span>,addr.sin_addr.s_addr, addr.sin_port); tcp_client_socket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>); ret=connect(tcp_client_socket, (struct sockaddr *)&amp;addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct sockaddr_in)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Connect(): connect\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tcp_ready_to_send==<span class="hljs-number"><span class="hljs-number">0</span></span>) { m2m_wifi_handle_events(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Connect(): connect OK\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_ERR_CONNECT; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { bus-&gt;sock.rx.bufStart = AJ_in_data_tcp; bus-&gt;sock.rx.bufSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(AJ_in_data_tcp); bus-&gt;sock.rx.readPtr = AJ_in_data_tcp; bus-&gt;sock.rx.writePtr = AJ_in_data_tcp; bus-&gt;sock.rx.direction = AJ_IO_BUF_RX; bus-&gt;sock.rx.recv = AJ_Net_Recv; bus-&gt;sock.tx.bufStart = tcp_data_tx; bus-&gt;sock.tx.bufSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tcp_data_tx); bus-&gt;sock.tx.readPtr = tcp_data_tx; bus-&gt;sock.tx.writePtr = tcp_data_tx; bus-&gt;sock.tx.direction = AJ_IO_BUF_TX; bus-&gt;sock.tx.send = AJ_Net_Send; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Connect(): connect() success: status=AJ_OK\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_OK; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Connect(): connect() failed: %d: status=AJ_ERR_CONNECT\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_ERR_CONNECT; }</code> </pre><br></div></div><br>  Over UDP, we actually only need to send mdns requests and receive an answer to them.  Upon receipt of the parcel is checked whether there is something to send.  If so, it is sent, after which the auxiliary flag handling function is called.  If the successful send flag is set (it is set in the callback), the function completes its work successfully, otherwise it returns a write error. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AJ_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AJ_Net_SendTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AJ_IOBuffer* buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tx = AJ_IO_BUF_AVAIL(buf); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ret = sendto(rx_socket, buf-&gt;readPtr, tx, <span class="hljs-number"><span class="hljs-number">0</span></span>, (struct sockaddr *)&amp;addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)); m2m_wifi_handle_events(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sock_tx_state != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_ERR_WRITE; } buf-&gt;readPtr += ret; } AJ_IO_BUF_RESET(buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_OK; }</code> </pre><br>  When received in a loop with an exit by time-out or receiving a parcel, the receive handler and the auxiliary flag processing function are called.  Arduino connoisseurs will notice that I use the millis function (it was rewritten according to our realities).  If the exit from the wait cycle of the parcel occurred on a timeout, then a read error is returned, otherwise the status is AJ_OK. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AJ_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AJ_Net_RecvFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AJ_IOBuffer* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span><span class="hljs-function"> </span></span>{ AJ_Status status = AJ_OK; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rx = AJ_IO_BUF_SPACE(buf); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Recv_lastCall = millis(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((sock_rx_state==<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (millis() - Recv_lastCall &lt; timeout)) { recv(rx_socket, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, <span class="hljs-number"><span class="hljs-number">0</span></span>); m2m_wifi_handle_events(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } ret=sock_rx_state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_RecvFrom(): read() fails. status=AJ_ERR_READ\n"</span></span>); status = AJ_ERR_READ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { AJ_DumpBytes(<span class="hljs-string"><span class="hljs-string">"AJ_Net_RecvFrom"</span></span>, buf-&gt;writePtr, ret); } buf-&gt;writePtr += ret; status = AJ_OK; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_RecvFrom(): status=%s\n"</span></span>, AJ_StatusText(status)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; }</code> </pre><br>  We now turn to the implementation of the reception / transmission of TCP.  Transmission is not much different from UDP transmission. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AJ_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AJ_Net_Send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AJ_IOBuffer* buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tx = AJ_IO_BUF_AVAIL(buf); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"AJ_Net_Send(buf=0x%p)\n"</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { send(tcp_client_socket, buf-&gt;readPtr, tx, <span class="hljs-number"><span class="hljs-number">0</span></span>); buf-&gt;readPtr += tcp_tx_ready; tcp_tx_ready=<span class="hljs-number"><span class="hljs-number">0</span></span>; } AJ_IO_BUF_RESET(buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AJ_OK; }</code> </pre><br>  But with the reception all a little more interesting.  The general approach, of course, is the same as in UDP, but the source codes still had a lot of checks, I couldn‚Äôt figure out what they were doing and how much they needed them, so most of them left that code. <br><br><div class="spoiler">  <b class="spoiler_title">TCP reception</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AJ_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AJ_Net_Recv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AJ_IOBuffer* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span><span class="hljs-function"> </span></span>{ AJ_Status status = AJ_ERR_READ; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rx = AJ_IO_BUF_SPACE(buf); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> recvd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Recv_lastCall = millis(); <span class="hljs-comment"><span class="hljs-comment">// first we need to clear out our buffer uint32_t M = 0; if (rxLeftover != 0) { // there was something leftover from before, M = min(rx, rxLeftover); memcpy(buf-&gt;writePtr, rxDataStash, M); // copy leftover into buffer. buf-&gt;writePtr += M; // move the data pointer over memmove(rxDataStash, rxDataStash + M, rxLeftover - M); // shift left-overs toward the start. rxLeftover -= M; recvd += M; // we have read as many bytes as we can // higher level isn't requesting any more if (recvd == rx) { return AJ_OK; } } if ((M != 0) &amp;&amp; (rxLeftover != 0)) { printf("AJ_Net_REcv(): M was: %d, rxLeftover was: %d\n", M, rxLeftover); } while ((tcp_rx_ready==0) &amp;&amp; (millis() - Recv_lastCall &lt; timeout)) { recv(tcp_client_socket, tcp_data_rx, sizeof(tcp_data_rx), 0); m2m_wifi_handle_events(NULL); } if (tcp_rx_ready==0) { printf("AJ_Net_Recv(): timeout. status=AJ_ERR_TIMEOUT\n"); status = AJ_ERR_TIMEOUT; } else { memcpy(AJ_in_data_tcp, tcp_data_rx,tcp_rx_ready); uint32_t askFor = rx; askFor -= M; ret=tcp_rx_ready; if (askFor &lt; ret) { printf("AJ_Net_Recv(): BUFFER OVERRUN: askFor=%u, ret=%u\n", askFor, ret); } if (ret == -1) { printf("AJ_Net_Recv(): read() failed. status=AJ_ERR_READ\n"); status = AJ_ERR_READ; } else { AJ_DumpBytes("Recv", buf-&gt;writePtr, ret); if (ret &gt; askFor) { printf("AJ_Net_Recv(): new leftover %d\n", ret - askFor); // now shove the extra into the stash memcpy(rxDataStash + rxLeftover, buf-&gt;writePtr + askFor, ret - askFor); rxLeftover += (ret - askFor); buf-&gt;writePtr += rx; } else { buf-&gt;writePtr += ret; } status = AJ_OK; } } tcp_rx_ready=0; return status; }</span></span></code> </pre><br></div></div><br>  Another important point is LocalGUID - a unique device identifier (see the <a href="https://habrahabr.ru/company/rainbow/blog/278845/">second part of the article</a> ), which we honestly borrowed (with minor changes) from a light bulb implemented on Linux. <br>  One of the important corrections: in the source code in the mdns request, the ip address of the light bulb is set explicitly.  If you do not want to rewrite it for each device with pens, then you need to add the reading of the assigned ip address (we will use dhcp to get the address on the network) and its entry into the packet.  This is done in the file: aj_disco.c in the function: ComposeMDnsReq (...). <br><br><h5>  Code for "light bulb" </h5><br>  We start the implementation of the "light bulb" in terms of LSF.  To indicate operation as light bulbs, we will use a custom LED on the debug board.  Accordingly, in the hardware we will have only the ability to turn on / off the LED. <br><br>  During the implementation of this part of the program, quite a lot of changes were made that made it work.  Enumerate them all here will not, we note only the important points. <br><br>  HAL level of work with the "light bulb" we implemented in the function <b>OEM_LS_TransitionStateFields</b> , the file <b>OEM_LS_Code.c</b> .  It could have been done less locally, but since the hal level only supports on / off, they did not spend much time and effort on it. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">LampResponseCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OEM_LS_TransitionStateFields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LampStateContainer* newStateContainer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transitionPeriod)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//OEMs should do the following operations just before transitioning the state LampState state; /* Retrieve the current state of the Lamp */ LAMP_GetState(&amp;state); /* Update the requisite fields to new values */ if (newStateContainer-&gt;stateFieldIndicators &amp; LAMP_STATE_ON_OFF_FIELD_INDICATOR) { state.onOff = newStateContainer-&gt;state.onOff; printf("%s: Updating OnOff to %u\n", __func__, state.onOff); printf("----------------state.onOff=%d-----------------------\n",state.onOff); if (state.onOff==1) { port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE); } else { port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE); } } ... }</span></span></code> </pre><br>  If you want to change the company name of the device manufacturer, device name, supported languages ‚Äã‚Äãand other parameters, then you need to change the corresponding lines at the beginning of the <b>OEM_LS_Provisioning.c</b> file. <br><br>  All settings are initially taken and, when changed, are written to some NVRAM.  We didn‚Äôt think up how to implement this in our case, so everywhere where read / write from NVRAM was used, we changed the code to work in our realities. <br><br>  It is simply impossible to list all the ‚Äúrakes‚Äù that we were attacking (there were also dead-end branches, some were forgotten).  Therefore, we mentioned the main methods and their ‚Äúcatching‚Äù - take obviously working applications (for example, under linux), and look at the WireShark exchange, which we should try to repeat. <br>  But when all the ‚Äúrakes‚Äù are passed, the working system causes affection with its forethought and, actually, work (finally!).  You can watch the video at the beginning of the article. <br><br>  Project code posted on <a href="https://github.com/marus-ka/alljoyn_lsf_lamp">githab</a> </div><p>Source: <a href="https://habr.com/ru/post/278363/">https://habr.com/ru/post/278363/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278349/index.html">Interesting ways to use Go channels (translation)</a></li>
<li><a href="../278351/index.html">How to create objects in PowerShell</a></li>
<li><a href="../278353/index.html">No, "Habr" does not die</a></li>
<li><a href="../278359/index.html">MSLibrary. Capturing and verifying phone numbers using regular expressions, for iOS and not only ... Part 2</a></li>
<li><a href="../278361/index.html">Preparing for the CISA exam. Benefits of Business Continuity</a></li>
<li><a href="../278365/index.html">Study Jam courses for Android developers started in Kazan</a></li>
<li><a href="../278367/index.html">Red Hat, Revolution R, Elasticsearch, MariaDB, Blockchain-as-a-service and much more is available in the Azure Marketplace</a></li>
<li><a href="../278369/index.html">Again about STL: containers</a></li>
<li><a href="../278373/index.html">Review of physics in Sonic games. Parts 3 and 4: Jumping and Spinning</a></li>
<li><a href="../278377/index.html">Managing ES6 class private data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>