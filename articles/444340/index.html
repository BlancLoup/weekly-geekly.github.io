<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of using the Symbol data type in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Symbolic primitives are one of the innovations of the ES6 standard that brought some valuable features to JavaScript. Symbols represented by the Symbo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of using the Symbol data type in JavaScript</h1><div class="post__text post__text-html js-mediator-article">  Symbolic primitives are one of the innovations of the ES6 standard that brought some valuable features to JavaScript.  Symbols represented by the Symbol data type are especially useful when used as identifiers of object properties.  In connection with such a scenario of their application, the question arises of what they can do, what strings cannot. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/444340/"><img src="https://habrastorage.org/webt/iz/wl/9d/izwl9dqxozauowr9lu69j04rvyo.jpeg"></a> <br><br>  In the material, the translation of which we publish today, we will focus on the Symbol data type in JavaScript.  We begin with an overview of some of the features of JavaScript, which need to be guided in order to deal with the characters. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Preliminary Information</font> </h2><br>  In JavaScript, in fact, there are two kinds of values.  The first type is the primitive values, the second is the object ones (functions are also included).  Primitive values ‚Äã‚Äãinclude simple data types like numbers (this includes everything from integers to floating-point numbers, <code>Infinity</code> and <code>NaN</code> values), logical values, strings, <code>undefined</code> values ‚Äã‚Äãand <code>null</code> values.  Notice that although <code>typeof null === 'object'</code> turns out <code>true</code> when checking the type, <code>null</code> is a primitive value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Primitive values ‚Äã‚Äãare immutable.  They can not be changed.  Of course, in a variable that stores a primitive value, you can write something new.  For example, here the new value is written to the variable <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x++;</code> </pre> <br>  But at the same time there is no change (mutation) of the primitive numerical value <code>1</code> . <br><br>  In some languages, for example, in C, there are concepts of passing arguments of functions by reference and by value.  JavaScript also has something similar.  How exactly data management is organized depends on their type.  If a primitive value represented by some variable is passed to the function, and then it is changed in this function, the value stored in the original variable does not change.  However, if you pass an object value represented by a variable to the function and modify it, then what is stored in this variable changes. <br><br>  Consider the following example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMutator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ val = val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; primitiveMutator(x); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// 1 function objectMutator(val) { val.prop = val.prop + 1; } let obj = { prop: 1 }; objectMutator(obj); console.log(obj.prop); // 2</span></span></code> </pre> <br>  Primitive values ‚Äã‚Äã(with the exception of the mysterious <code>NaN</code> , which is not equal to itself) always turn out to be equal to other primitive values ‚Äã‚Äãthat look the same as themselves.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> + <span class="hljs-string"><span class="hljs-string">"def"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-string"><span class="hljs-string">"cd"</span></span> + <span class="hljs-string"><span class="hljs-string">"ef"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first === second); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  However, the construction of object values ‚Äã‚Äãthat look alike does not lead to the fact that entities are obtained, comparing which will reveal their equality with each other.  You can check it like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1 === obj2); <span class="hljs-comment"><span class="hljs-comment">// false //     .name   : console.log(obj1.name === obj2.name); // true</span></span></code> </pre> <br>  Objects play a fundamental role in javascript.  They are applied literally everywhere.  For example, they are often used as collections of the key / value type.  But before the appearance of the <code>Symbol</code> data type, only strings could be used as object keys.  This was a serious limitation on the use of objects in the form of collections.  When attempting to assign a non-string value as an object key, this value was cast to a string.  You can verify this by: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj.foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj[<span class="hljs-string"><span class="hljs-string">'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; obj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-string"><span class="hljs-string">'someobj'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { '2': 2, foo: 'foo', bar: 'bar',    '[object Object]': 'someobj' }</span></span></code> </pre> <br>  By the way, although this takes us a little away from the topic of symbols, we would like to note that the <code>Map</code> data structure was created to allow using key / value data stores in situations where the key is not a string. <br><br><h2>  <font color="#3AC1EF">What is a character?</font> </h2><br>  Now that we‚Äôve figured out the features of primitive values ‚Äã‚Äãin JavaScript, we‚Äôre finally ready to start talking about characters.  A symbol is a unique primitive value.  If you approach the characters from this position, you can see that the characters in this regard are similar to objects, since the creation of several instances of characters will lead to the creation of different values.  But symbols, moreover, are immutable primitive values.  Here is an example of working with symbols: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === s2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  When creating an instance of a character, you can use the optional first string argument.  This argument is a character description that is intended for use in debugging.  This value does not affect the symbol itself. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'debug'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'xxyy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === str); <span class="hljs-comment"><span class="hljs-comment">// false console.log(s1 === s2); // false console.log(s1); // Symbol(debug)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Symbols as object property keys</font> </h2><br>  Symbols can be used as property keys for objects.  It is very important.  Here is an example of using them in this quality: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); obj[sym] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj.bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { bar: 'bar' } console.log(sym in obj); // true console.log(obj[sym]); // foo console.log(Object.keys(obj)); // ['bar']</span></span></code> </pre> <br>  Note that the keys specified by the characters are not returned when the <code>Object.keys()</code> method is <code>Object.keys()</code> .  The code written before the appearance of symbols in JS knows nothing about them, as a result, information about the keys of objects represented by characters should not be returned by the ancient <code>Object.keys()</code> method. <br><br>  At first glance, it may seem that the above-described features of symbols allow them to be used to create private properties of JS objects.  In many other programming languages, you can create hidden properties of objects using classes.  The lack of this feature has long been considered one of the disadvantages of JavaScript. <br><br>  Unfortunately, the code that works with objects can easily access their string keys.  The code can access the keys specified by the characters, moreover, even if the code from which the object is operated with does not have access to the corresponding character.  For example, using the <code>Reflect.ownKeys()</code> method you can get a list of all the keys of an object, and those that are strings, and those that are symbols: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToAddPrivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ o[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'Pseudo Private'</span></span>)] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span> }; tryToAddPrivate(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(obj));       <span class="hljs-comment"><span class="hljs-comment">// [ 'prop', Symbol(Pseudo Private) ] console.log(obj[Reflect.ownKeys(obj)[1]]); // 42</span></span></code> </pre> <br>  Please note that work is currently under way to equip classes with the ability to use private properties.  This feature is called <a href="https://github.com/tc39/proposal-class-fields">Private Fields</a> .  True, it does not affect absolutely all objects, referring only to those of them that are created on the basis of previously prepared classes.  Private field support is already available in Chrome browser version 72 and later. <br><br><h2>  <font color="#3AC1EF">Preventing collisions of object property names</font> </h2><br>  Symbols, of course, do not add to JavaScript the ability to create private properties of objects, but they are a valuable innovation of the language for other reasons.  Namely, they are useful in situations when certain libraries need to add properties to the objects described beyond their limits, and at the same time not to be afraid of the collision of the names of the properties of the objects. <br><br>  Consider an example in which two different libraries want to add metadata to an object.  It is possible that both libraries need to be equipped with an object with certain identifiers.  If you simply use something like the two-letter <code>id</code> string for the name of such a property, you might encounter a situation where one library overwrites the property specified by the other. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  If we use symbols in our example, then each library can generate, at initialization, the symbols it needs.  These symbols can then be used to assign properties to objects and to access these properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library1property] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib2'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library2property] = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Just looking at such a script, you can feel the benefits of the appearance of characters in JavaScript. <br><br>  However, there may be a question regarding the use of libraries for property names of objects, random strings or strings with a complex structure, including, for example, the name of the library.  Such strings can form something like namespaces for identifiers used by libraries.  For example, it might look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//       function lib1tag(obj) { obj[library1property] = 42; } const library2property = 'LIB2-NAMESPACE-id'; //     function lib2tag(obj) { obj[library2property] = 369; }</span></span></code> </pre> <br>  In general, you can do so.  Such approaches, in fact, are very similar to what happens when using symbols.  And if, using random identifiers or namespaces, a pair of libraries does not generate, by chance, the same property names, then there will be no problems with the names. <br><br>  An astute reader would say now that the two approaches to naming properties of objects are not completely equivalent.  Names of properties that are randomly generated or using namespaces have a drawback: the corresponding keys are very easy to detect, especially if the code is iterating over the keys of objects or serializing them.  Consider the following example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-string"><span class="hljs-string">'LIB2-NAMESPACE-id'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    function lib2tag(obj) { obj[library2property] = 369; } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); JSON.stringify(user); // '{"name":"Thomas Hunter II","age":32,"LIB2-NAMESPACE-id":369}'</span></span></code> </pre> <br>  If in this situation a symbol was used for the key name, then the JSON representation of the object would not contain the symbol value.  Why is this so?  The fact is that the fact that a new data type has appeared in JavaScript does not mean that the changes have been made to the JSON specification.  JSON supports, as keys of properties of objects, only strings.  When the object is serialized, no attempt is made to present the characters in any particular form. <br><br>  The problem of getting property names into the JSON representation of objects can be solved by using <code>Object.defineProperty()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//   function lib2tag(obj) { Object.defineProperty(obj, library2property, {   enumerable: false,   value: 369 }); } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); // '{"name":"Thomas Hunter II",  "age":32,"f468c902-26ed-4b2e-81d6-5775ae7eec5d":369}' console.log(JSON.stringify(user)); console.log(user[library2property]); // 369</span></span></code> </pre> <br>  String keys that are ‚Äúhidden‚Äù by setting their <code>enumerable</code> <a href="https://medium.com/intrinsic/javascript-object-property-descriptors-proxies-and-preventing-extension-1e1907aa9d10">handle</a> to <code>false</code> behave in much the same way as keys represented by characters.  Both are not displayed when <code>Object.keys()</code> called, and both can be detected using <code>Reflect.ownKeys()</code> .  Here's what it looks like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumberable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// [] console.log(Reflect.ownKeys(obj)); // [ 'foo', Symbol() ] console.log(JSON.stringify(obj)); // {}</span></span></code> </pre> <br>  Here, I must say, we almost recreated the possibilities of symbols using other means of JS.  In particular, both keys represented by symbols and hidden keys do not fall into the JSON representation of the object.  Both can be found by calling the <code>Reflect.ownKeys()</code> method.  As a result, those and others can not be called truly private.  If we assume that some random values ‚Äã‚Äãor library namespaces are used to generate key names, this means that we have got rid of the risk of name collisions. <br><br>  However, there is one small difference between using symbol names and names created using other mechanisms.  Since the strings are immutable, and the characters are guaranteed unique, there is always the possibility that someone, going through all possible combinations of characters in a string, will cause a name collision.  From a mathematical point of view, this means that the characters really give us a valuable opportunity, which is absent in lines. <br><br>  In Node.js, when examining objects (for example, using <code>console.log()</code> ), if an object method with the name <code>inspect</code> detected, then this method is used to get a string representation of the object and then display it on the screen.  It is easy to understand that absolutely everyone cannot take this into account, so this behavior of the system can lead to a call to the method of an <code>inspect</code> object, which is intended for solving problems that are not related to the formation of a string representation of an object.  This feature is deprecated in Node.js 10; in version 11, methods with a similar name are simply ignored.  Now, to implement this feature, the <code>require('util').inspect.custom</code> .  And this means that no one will ever be able to inadvertently disrupt the operation of the system by creating an object method called <code>inspect</code> . <br><br><h2>  <font color="#3AC1EF">Imitation of private properties</font> </h2><br>  Here is an interesting approach that can be used to simulate the private properties of objects.  This approach involves the use of another modern JavaScript feature - proxy objects.  Such objects serve as wrappers for other objects that allow the programmer to interfere with the actions performed on these objects. <br><br>  Proxy objects offer many ways to intercept actions performed on objects.  We are interested in the ability to control the operations of reading the keys of an object.  In detail about the proxy objects, we will not go deep here.  If you are interested in them - take a look at <a href="https://medium.com/intrinsic/javascript-object-property-descriptors-proxies-and-preventing-extension-1e1907aa9d10">this</a> publication. <br><br>  We can use a proxy to control which properties of an object are visible from the outside.  In this case, we want to create a proxy that hides two properties known to us.  One has the string name <code>_favColor</code> , and the second is represented by the character written to the variable <code>favBook</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proxy; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> favBook = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'fav book'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {   <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas Hunter II'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>,   <span class="hljs-attr"><span class="hljs-attr">_favColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>,   [favBook]: <span class="hljs-string"><span class="hljs-string">'Metro 2033'</span></span>,   [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'visible'</span></span>)]: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">ownKeys</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportedKeys = [];     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actualKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(target);     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actualKeys) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === favBook || key === <span class="hljs-string"><span class="hljs-string">'_favColor'</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       }       reportedKeys.push(key);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reportedKeys;   } }; proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(proxy)); <span class="hljs-comment"><span class="hljs-comment">// [ 'name', 'age' ] console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ] console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ] console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)] console.log(proxy._favColor); // 'blue</span></span></code> </pre> <br>  Cope with the property, whose name is represented by the string <code>_favColor</code> , easy: just read the source code.  Dynamic keys (like the uuid-keys that we saw above) can be picked up by brute force.  But without a reference to the symbol, you cannot access the <code>Metro 2033</code> value from the <code>proxy</code> object. <br><br>  Here it should be noted that in Node.js there is one feature that violates the privacy of proxy objects.  This feature does not exist in the language itself, so it is not relevant for other JS runtimes such as the browser.  The fact is that this feature allows you to access an object hidden behind a proxy object, if you have access to a proxy object.  Here is an example demonstrating the ability to bypass the mechanisms shown in the previous code snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [originalObject] = process .binding(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) .getProxyDetails(proxy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(originalObject); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allKeys[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Symbol(fav book)</span></span></code> </pre> <br>  Now, to prevent this feature from being used in a particular Node.js instance, you need to either modify the global <code>Reflect</code> object, or bind the <code>util</code> process.  However, this is another task.  If you're interested, take a look at <a href="https://medium.com/intrinsic/protecting-your-javascript-apis-9ce5b8a0e3b5">this</a> JavaScript-based API security post. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article, we talked about the <code>Symbol</code> data type, what possibilities it gives JavaScript developers, and what existing language mechanisms can be used to simulate these capabilities. <br><br>  <b>Dear readers!</b>  Do you use symbols in your JavaScript projects? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/444340/">https://habr.com/ru/post/444340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444328/index.html">UI redesign - most often a waste of time</a></li>
<li><a href="../444330/index.html">Serverless CMS is finally a worthy competitor for Wordpress</a></li>
<li><a href="../444332/index.html">Information security and public catering: how managers think about IT products</a></li>
<li><a href="../444336/index.html">Swift capture lists: what is the difference between weak, strong and unowned links?</a></li>
<li><a href="../444338/index.html">Python 3 Encapsulation</a></li>
<li><a href="../444342/index.html">Development of simple modern JavaScript applications using Webpack and progressive web technologies</a></li>
<li><a href="../444344/index.html">10 steps to a successful Python project</a></li>
<li><a href="../444346/index.html">GraphQL and Golang</a></li>
<li><a href="../444350/index.html">For some reason, MVP does not start (minimally viable product)</a></li>
<li><a href="../444352/index.html">Kontur.Kampus: we invite you to a free student camp of industrial development near St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>