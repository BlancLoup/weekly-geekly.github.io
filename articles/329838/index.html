<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apache Spark - advantages, disadvantages, wishes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to express my impressions about Apache Spark, and then I caught sight of this article from Pivotal employee Robert Bennett , publis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apache Spark - advantages, disadvantages, wishes</h1><div class="post__text post__text-html js-mediator-article">  I have long wanted to express my impressions about Apache Spark, and then I caught sight of <a href="https://thenewstack.io/the-good-bad-and-ugly-apache-spark-for-data-science-work/">this article from Pivotal employee Robert Bennett</a> , published recently, on June 26, 2018. <br><br>  It will not be a translation, but rather all the same my impressions and comments on the topic. <br><a name="habracut"></a><br><h3>  What makes Spark popular? </h3><br>  Quote: <br><blockquote>  It's easy to see why Apache Spark is so popular.  It is in-memory and it is particularly useful when working with machine learning algorithms.  I would like to write, I can use it using iterative algorithms, painfully slow. <br></blockquote>  To begin with, this is all for the most part not entirely true.  In memory?  Well, yes, Spark will try, but what is written here about other tools will also take place.  In the end, memory, processor cores and the network are limited resources, so that sooner or later any tool rests on their limits. <br><br>  In a sense, Spark is never in-memory than any classic map-reduce.  Anyway, the data should still either be on the disk (among other things, it will allow us to reliably survive the errors and not start the calculations from the very beginning), or be transmitted over the network (shuffle and other processes).  I'm not saying that you, as a programmer, will not be able to save persist, and save intermediate results to disk if you suddenly want to.  Do you want to save them in memory, if we say a terabyte of data?  I doubt it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I would rather say that unlike other tools (which usually means the classic map-reduce), Spark allows you to think a little less about optimal use of resources, and more optimizes this use by yourself.  And the final speed, in the end, depends more likely on the straightness of the hands of the person who is writing the program. <br><br>  Further, the author lists such qualities Spark, which seem to him the best: <br><br><h4>  Attractive API and lazy execution (Appealing APIs and Lazy Execution) </h4><br>  In general, I agree with this.  Spark as a development tool is much more convenient than the classic map-reduce, and somewhat more convenient than tools like Apache Crunch and other tools from the conditional "second" generation.  It is also somewhat more flexible than, for example, Hive, and is not limited to SQL per se. <br><br>  Lazy performance is not always good.  Sometimes it would be better if we say differences in the Hive and DataSet schemes were diagnosed not when all the data were processed, but a little earlier, and everything fell not in a couple of hours / day, but at startup. <br><br><h4>  Easy Conversion (Easy Conversion) </h4><br>  Here the author basically meant conversions between the Spark and Python / Pandas structures.  I am far from this, so I will not speak.  Perhaps about pySpark I will tell slightly below. <br><br><h4>  Easy Transformations </h4><br><blockquote>  Another asset of Spark is the ‚Äúmap-side join‚Äù broadcast method.  It‚Äôs not a problem.  It doesn‚Äôt need to be gone.  This also helps mitigate problems from skew.  In the case of the keys, it will be a lot of effort. <br></blockquote>  I do not know what they have there in python, but in our area a map-side join is easily done either with bare hands, or with any of the tools of the Crunch type.  I do not see any particular advantages in this, many people are able to do it, and Hive, for example.  With de facto absence of indices in the Hadoop map ecosystem, side join is probably one of the main join optimization tools in general. <br><br>  API for transformation is quite convenient, although not homogeneous.  Say, the ‚Äúold‚Äù RDD API, being probably a bit more flexible, gives at the same time more room for committing an error, especially if you are working not at the level of classes of a fixed structure (Java Beans), but Row and with a flexible data structure.  The discrepancy between real and expected Spark schemes is quite common in this case. <br><br>  As for the DataSet API, I would say that it is very good.  After some practice, it is quite possible to write everything on it as easily as in SQL, supplementing it with your UDF, and seeking greater flexibility.  UDFs themselves are easier to write than for Hive, and some difficulties arise only when returning from them complex data structures (arrays, map, struct), and then in Java, and rather because structures are expected for Scala. <br><br>  Let's say I was able to quite easily use, in the form of a UDF, such a thing as the Java port of pymorphy2.  Or a geocoder.  In essence, all you need is to correctly initialize your UDF, keeping in mind the features of Spark serialization. <br><br>  But API Spark ML, on the other hand, looks like it was designed by completely different people.  This does not mean that he is bad - he is just different. <br><br><h4>  Open Source Community </h4><br><blockquote>  Spark has a massive open-source community behind it.  Add-on packages.  For example, a team has been developed for a Spark.  It has been shown that it can be used as the Natural Language Toolkit. <br></blockquote>  There is nothing to add here.  The community is really big, skilled and friendly.  Writes a huge number of extensions for Spark. <br><br>  Let us leave the next passage about slow UDF on the conscience of a pitonist - Scala / Java UDF is not so slow at all, and at the same time very convenient. <br><br>  What I would add from myself: <br><br><h4>  Development in different languages </h4><br>  Probably one of the reasons for the popularity is the support of several development languages ‚Äã‚Äã(Scala, Java, Python and R).  By and large, the API for different languages ‚Äã‚Äãis about equally convenient, but I would not call this support ideal.  Say, when launching your Spark application, you immediately choose between Java / Scala and Python, and you cannot combine languages ‚Äã‚Äãin one launch.  Thus, integration between parts of the application on pySpark (on which ML or NLP parts are often written), and Java / Scala is really possible only through files / databases.  Well, or something like Kafka, REST, and so on. Options. <br><br><h4>  Streaming </h4><br>  Spark Streaming (not to be confused with Hadoop Streaming, which is completely different) is another attractive part of Spark's capabilities.  If we describe it in one sentence, then it is processing streaming data, for example, from Kafka, ZeroMQ, etc.  by the same means as the data taken from the database. <br><br>  The beauty is precisely that the means are the same, i.e.  you practically do not have to change anything in the program to start processing data from Kafka.  Neither map reduce, nor Crunch, nor Cascading will allow any such trick to you. <br><br><h2>  disadvantages </h2><br>  Everyone has their own shortcomings (s).  What problems can you encounter when working with Spark? <br><br><h4>  Cluster management </h4><br><blockquote>  Spark is notoriously difficult to tune and maintain.  It doesn‚Äôt mean that it can work.  If your cluster is not expertly managed, this can be negated.  It makes it very common to make it possible for users to concurrent users. <br></blockquote>  Did someone promise?  Actually, I already wrote above that everything is fine and just can be exactly in one case - if you either have a problem that is not very large, or you have plenty of resources - or in other words, the task is not too complicated. <br><br>  In other cases, which are obviously the majority, Spark applications need to be tweaked, tuned and maintained. <br><blockquote>  Do you go with fixed or dynamic memory allocation?  Spark to use?  How much memory does each get executor get?  How many partitions should Spark use when it shuffles data?  Workloads is difficult. <br></blockquote>  Say, it would seem a relatively simple task of choosing the number of executors.  In principle, knowing something about your data, you can safely calculate this number.  But in conditions when resources are used not only by you, everything becomes much more fun.  If your process also includes calls to other applications, then ... <br><br>  For example, I have an application, part of the functionality of which is reverse geocoding.  And it is engaged in a separate server ArcGIS.  At the same time, ArcGIS has only 4 cores at its disposal, and the Hadoop cluster, where Spark runs, has dozens of nodes, in the end, if we just allocate Spark to just 8 executors, then the ArcGIS processor load curve jumps to 100%, where it remains on a couple of hours of application.  And if we shift this task to Spark (by rewriting the application code in advance), then the work time is reduced by a couple of orders of magnitude - due to the fact that we can use the cluster resources for this task too. <br><br>  That is, we often have a bottleneck, where either a fixed amount of resources is allocated, or these resources are managed in a different way (which Spark cannot influence).  Accordingly, expecting Spark to optimize the use of these resources would be naive. <br><br><h4>  Debugging </h4><br>  It's true.  Expected, however.  We have a distributed parallel system, debugging and monitoring of which is a non-trivial task.  SparkUI to some extent solves the issues of observation, and Spark Metrics measures performance, but try, say, to connect to the executable application with a debugger ‚Äî you don‚Äôt know the host where it works, nor the port that is free to connect.  The same metrics that can be easily obtained for example from a JMX for a normal application, in the case of a distributed application, should be transmitted over the network, and only then can they be collected.  Yes, this is all relatively bad. <br><br><h4>  Poor UDF performance in PySpark (Slowness of PySpark UDFs) </h4><br>  Well what can I say?  For what they fought, they ran into it (c).  As far as I understand, UDF on python leads to the fact that there is a double conversion of data between the application and the UDF.  Just because python is still an alien language for the Spark JVM ecosystem and the UDF is executed outside of it. <br><br>  Here you can advise only one thing - do not write on python, write on Scala / Java.  It is clear that this advice is not always desirable and can be followed, but I am afraid that only Graal will be able to solve this problem globally, when his version of the python is brought to the industrial level. <br><br><h4>  Difficult to guarantee the maximum level of parallelism (Hard-to-Guarantee Maximal Parallelism) </h4><br><blockquote>  It is difficult to ensure that Spark parallel computations as much as possible.  It tries not to scale up on its own.  You may not need to use it if you need it.  Also, Spark divides RDDs (Resilient Distributed Dataset) / DataFrames into partitions, which takes an executor to take.  If you are not too much part, then there may be enough chunks of work.  Also, fewer partitions means larger partitions, which can cause executors to run out of memory. <br></blockquote>  If only it were that simple.  Let's start with a simple one - the parameters to start should be typed for each particular cluster.  A prod cluster can have an order of magnitude more nodes, and many times more memory available on each.  The settings for the Dev cluster will probably be understated when running on Prod.  All this is even more complicated if you start to take into account the current cluster load tasks.  In general, this task of allocating cluster resources is an optimization problem, rather nontrivial, and does not have the only correct solution. <br><br>  If there are few partitions, then concurrency is insufficient.  And if there are too many of them - then the size of each may be lower than some conditional lower limit, like the size of a HDFS block.  Since each task is resources spent on its launch, there is obviously a lower limit to the size of the task, below which you should not fall, because overhead costs grow faster than productivity. <br><br>  A simple example is an application that needs some significant amount of reference books.  If in the case of the ‚Äúnormal‚Äù map-reduce task on Hadoop, we usually deliver the code to the data, i.e.  we copy our application + Spark parts to the cluster nodes where our file (s) is located, then the directories - this is already similar to the map side join, and they need to be delivered along with the code.  And suddenly, the size of the data delivered to each node grew by a couple of orders ‚Äî for example, it was 10 megabytes (a small Spark application, without Spark itself), it became for example 20 gigabytes (a very real case, reference books needed for normalizing addresses, phones, and so on. quite pull on such a volume).  Well, here it is - the price of excessive parallelism, there is. <br><br>  Perhaps there is some natural number of partitions, which is determined by the number of blocks into which our input file is divided, taking into account the replication rate.  It is likely that this number is close to optimal from the point of view of reading data.  That is, if we have three blocks in the file, and each block has copies on 2 nodes of the cluster, then we can in parallel process processing in 6 threads, processing each replica on our node.  Of course, Spark takes these parameters into account when dynamically allocating resources. <br><br>  Unfortunately or fortunately, Spark is not a cluster resource scheduler.  It is for example Yarn.  So Spark simply may not have enough information to optimally plan the use of all resources. <br><br><h4>  Not very good integration with Hive </h4><br>  On the one hand, Spark works great with Hive data and metadata.  I would say that most of the applications that I came across, and that‚Äôs what I‚Äôm doing.  But not without annoying problems.  Say, if you try to use its partitionBy and bucketBy tools in Spark, it is very likely that Hive will not see the results of your work.  At the same time, all you get is a vague warning somewhere in the logs. <br><br><h4>  Compatibility </h4><br>  Unfortunately, my experience speaks on this topic rather bad.  We ran into multiple problems when trying to run applications on clusters, where the Spark version was different from the expected one.  When developing on Spark 2.2.0, there were problems when running on 2.1 and 2.3. <br><br>  For example, in our case, Spark for some reason could not find one of the codecs (namely snappy) when running on version 2.3.  This is not a serious problem if you need to write data (you can specify a codec when recording and select any, including unpacked data), but if you need to read something that is snappy packed, then you are clearly not lucky. <br><br>  Perhaps some of the problems were caused by errors in the installer, but this is not much easier.  Still, it seems to me that the migration between minor versions would have to be smoother. <br><br>  Well, alas, but Spark does not imply a full-time parallel installation on one cluster of two different versions of the same line (the same 2.2 and 2.3). <br><br><h2>  Horrible side </h2><br><h4>  API Awkwardness </h4><br><blockquote>  Since it really doesn?  For example, we consider accessing spark life. <br></blockquote>  I would not say that working with arrays is so terrible.  Some inconveniences are brought by the fact that the Spark API was originally made on Scala, and there its own collection structure, which, working from Java, has to lead to the Scalov one.  And so, if you are able to write a UDF, then you are able to do anything you want with arrays.  Oh, yes - in the python, everything is bad with UDF, I forget all the time. <br><br>  Not very convenient and not very effective - yes, it is possible.  This is trying to solve a new version of Spark 2.4 today, where new functions of a higher order are introduced for working with complex structures (thus avoiding the use of explode / collect). <br><br>  In my opinion, a much more uncomfortable side of the API is that, looking at the code, it is not always obvious which part will be executed on the driver, and which part on other nodes.  At the same time, the mechanism of distributing code across sites implies its serialization (in one way or another), and the code that runs on executors must be serializable.  Dealing with serialization errors you can learn a lot of new and interesting things about your code :). <br><br><h4>  Classloaders </h4><br>  Unfortunately, the issue of isolating application code from Spark code is not well resolved.  However, the same applies to classic map-reduce Hadoop applications.  At the same time, Hadoop code uses some ancient versions of such a library as Google Guava, and other libraries are far from new, frankly.  If you remember that Guava authors like to introduce backward incompatibility to their API, removing deprecated methods, then we get a completely stupid picture - you write your code under the latest Guava version, run it, and it crashes - either because you really work with the Guava version from Hadoop (much older), and your code does not find methods from the new version, or Hadoop crashes because it is incompatible with the new version.  This is a fairly typical, unfortunately problem that every second developer is probably facing.  The Apache Http Components library is another example of this problem. <br><br><h4>  SQL without bind variables </h4><br>  Alas, the typical code for fulfilling a request for a pair looks like this: <br><br>  val sqlDF = spark.sql ("SELECT * FROM people WHERE id = 1") <br><br>  The API does not provide an option to execute the request id =?  and substitution of parameters at each performance.  Well, okay, let's say the authors do not care about the problem of SQL-injection, but the developers should substitute the parameters in the request, respectively, the replacement of special characters is entirely with you and me.  For the sake of objectivity, Hive suffers the same way, where it is also impossible to define a query with parameters. <br><br>  However, what is even funnier, for JDBC sources, formally, you cannot even write a query - you can only specify a table, but not columns.  Informally, you can write something like (select a, b, c from d) t instead of a table, but whether it will work in all cases - no one will tell you for sure. <br><br><h4>  Lack of Maturity and Feature Completeness </h4><br>  Hmm.  Another's head is darkness. <br><blockquote>  This is an optional feature.  A sequential, unique column index is helpful for some types of analysis.  According to the documentation, it doesn‚Äôt guarantee that the IDs are consecutive.  Spark's older RDD format. </blockquote>  I do not understand such claims.  Source codes are available, and it is quite possible to glance, and at least to read comments: <br><br><blockquote>  Returns monotonically increasing 64-bit integers. <br><br><ul><li>  The generated id is guaranteed to be monotonically increasing. </li><li>  31 bits, and the lower 33 bits </li><li>  represent the record number within each partition.  The data frame has </li><li>  less than 1 billion partitions and less than 8 billion records. </li></ul><br></blockquote>  Well, that is, this function simply takes the partition number, and adds a counter to it. ,   ,           .  Spark  ‚Äî    JVM,     ,        JVM. <br><br>       ,              id,   ,        (    ),    (    ). <br><br><h2>     Spark 2.4 </h2><br><h4>      </h4><br>   .   . <br><br>  ,          map-,            (). <br><br> <a href="https://docs.databricks.com/_static/notebooks/apache-spark-2.4-functions.html"> </a>     . <br><br><h4>    </h4><br>    barier    .       ,       .  ,   ,      Spark map-reduce.     ‚Äî       ,    ,      . <br><br>  API       ‚Äî      . ,        Yarn-,    Spark  .        Spark   . <br><br><h4>   Avro </h4><br>  Avro      .     ,     ¬´ ¬ª (  ‚Äî   ),   Decimal, Date, Time, Duration  . <br><br> ,  ,     Hive (  Spark )    ,      .    ,   Avro     . <br><br> <a href="https://databricks.com/blog/2018/11/30/apache-avro-as-a-built-in-data-source-in-apache-spark-2-4.html">    </a> . <br><br><h4>  Scala 2.12 () </h4><br>  , ,    Java ,  ,           Java 8,   ,       . </div><p>Source: <a href="https://habr.com/ru/post/329838/">https://habr.com/ru/post/329838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329828/index.html">Courses Computer Science Club, spring 2017, part two</a></li>
<li><a href="../329830/index.html">Container Networking Interface (CNI) - network interface and standard for Linux containers</a></li>
<li><a href="../329832/index.html">Linux + Azure</a></li>
<li><a href="../329834/index.html">UX strategy. Part 6 - Implementation</a></li>
<li><a href="../329836/index.html">Security in web development: checklist</a></li>
<li><a href="../329840/index.html">DevOps on Amazon AWS</a></li>
<li><a href="../329842/index.html">"For the same functionality that SQL Server provides, Oracle asks 10 times more," - Konstantin Taranov about SQL Server</a></li>
<li><a href="../329844/index.html">Ruby on Rails agreement. Part 3</a></li>
<li><a href="../329852/index.html">Porting MIPSfpga to other cards and integrating peripherals into the system. Part 2</a></li>
<li><a href="../329854/index.html">Porting MIPSfpga to other cards and integrating peripherals into the system. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>