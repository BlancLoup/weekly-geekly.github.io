<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux: buttons, LEDs and GPIO</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Starting from version 2.6.26 (it seems), Linux has a standard interface for working with GPIO via sysfs. In the original, you can read ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux: buttons, LEDs and GPIO</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e36/00c/21d/e3600c21d6064feb96a98aa568642de7.jpg" align="left"><h4>  Introduction </h4><br>  Starting from version 2.6.26 (it seems), Linux has a standard interface for working with GPIO via sysfs.  In the original, you can read about it in [LGPIO00].  I will try to retell in my own words the contents of this document. <br><br>  The main point of working with GPIO is the <i>/ sys / class / gpio directory</i> .  If you look into it, you will see two files: <i>export</i> and <i>unexport</i> .  Immediately after booting the system, all GPIO lines belong to the kernel, and using them in your programs just won't work.  For this, the GPIO line must be exported by writing its number to the <i>export</i> file.  For example, the command: <code>echo 8 &gt; /sys/class/gpio/export</code> tells the kernel that we want to use GPIO8.  The carriage return '\ n' and the line end character '\ 0' are optional: C code: <code>write(fd, ‚Äú8‚Äù, 1);</code>  - will work the same way. <br><a name="habracut"></a><br>  The line number depends on the hardware platform used and the driver implementation.  It is clear that the numbering should be unique for each output GPIO.  It is no secret that on some SoC there are several GPIO ports (GPIOA, GPIOB, etc.), therefore, how exactly the numbers of the lines are distributed need to be specified in each case separately.  The most obvious and simplest is such a distribution: there are two GPIO ports with 32 lines each, while the first port has line numbering from 0 to 31, and the second has 32 to 63, etc. <br><br>  It should be noted that in some modern SoCs, there are more peripheral devices on the chip than the outputs on the microchip can be allowed.  Therefore, some of the pins are multiplexed between different peripherals.  As a result, some GPIO lines may already be involved in the current system configuration by an LCD display port, for example, or a USB port.  You will most likely not be able to use such lines. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Output: connect the LED </h4><br><img src="https://habrastorage.org/files/138/661/b16/138661b16fc54780a0d3420f5b3f7801.png"><br><br>  Suppose we found a free GPIO port pin on a printed circuit board and want to hang a LED on it.  Some sort of shamanism, we establish that it has number 16. Now, you can try to get access to this line: <code>echo 16 &gt; /sys/class/gpio/export</code> .  If successful, a new directory will appear in <i>/ sys / class / gpio</i> : <i>gpio16</i> . <br><br>  Looking into this directory you can see that to work with a separate line of GPIO Linux provides us with an interface consisting of the following files: <i>direction</i> , <i>value</i> , <i>edge</i> and <i>active_low</i> .  Now we are interested in only two of them: <i>direction</i> and <i>value</i> . <br><ul><li>  <i>direction</i> - determines the direction of the line: is it an input or an output.  To set up a line for input, you need to write the word 'in' to the file, and if the output is 'out'. </li><li>  <i>value</i> - allows you to read the value on the line if it is an input, or set the value if it is an output.  The value in value can take a text '0' or '1'.  Note: '0' and '1' are exactly ASCII characters, not numbers. </li></ul><br>  Let's go back to our LED.  The following code on the shell will light the LED and extinguish it in a second. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># exporting and tuning GPIO line echo 16 &gt; /sys/class/gpio/export echo out &gt; /sys/class/gpio/gpio16/direction # switch GPIO#16 on echo 1 &gt; /sys/class/gpio/gpio16/value # sleep 1 second sleep 1 # switch GPIO#16 off echo 0 &gt; /sys/class/gpio/gpio16/value</span></span></code> </pre><br>  Now let's look at the <i>active_low</i> file.  It determines the level of the active signal ‚Äî that is, which voltage will correspond to a logical zero, and which voltage to a logical one. <br><br>  By default, the logical unit (high level) is the presence of some voltage at the output (depends on the type of SoC'a, but usually it is + 3.3V), and zero (low level) is the absence of voltage (short circuit to ground).  However, this is not always convenient, since some signals can be inverted.  For example, the CS (Chip Select) signal manufacturers like to make the chip so that the chip becomes active when there is no voltage on the corresponding output, and it stops responding to external signals if the voltage is applied.  To control this setting, the characters '0' - false or '1' - true must be written to the active_low file, depending on whether we want to invert the active signal or not.  By default there is a '0'. <br><br><h4>  Login: connect button </h4><br><img src="https://habrastorage.org/files/445/b8f/5b6/445b8f5b618a43b8a9e7b84eab99999b.png"><br><br>  So, let's think up a button as input.  The scheme might look like this: <br>  How to configure the GPIO input is already mentioned above.  You can read the current value from the file <i>value</i> .  Just take and read.  You can even use cat.  Naturally, the read value depends on the active_low setting, and by default, the ASCII character is '1', if there is voltage at the output, otherwise - we get '0'. <br><br>  Note that for CMOS (or something is being used now), a pin hanging in the air will most likely give a logical unit (but not necessarily, since the state is undefined and depends on the presence of a charge based on the input transistor), and if we want to get zero, then you need to connect it to the ground. <br><br>  Well, now we can find out if a button is pressed or not, simply by reading the value from value.  But is it convenient?  Most likely no.  We will have to constantly, with a certain frequency, read the current value (this technology is called polling) to determine the moment when the button is pressed.  The extra work is a waste of resources.  Most SoC manufacturers supply their GPIO with an interrupt controller, which generates an interrupt for all sorts of different situations: level change, level setting to high or low.  Is it possible to somehow use it through sysfs?  Documentation, reports that it is possible.  To do this, we need to write one of the following values ‚Äã‚Äãto the <i>edge</i> file: <i>none</i> , <i>rising</i> , <i>rising</i> , or <i>both</i> .  Here: <i>none</i> - disable tracking of the state of the incoming line;  <i>rising</i> and <i>falling</i> - we track the transition from inactive to active and from active to inactive, respectively;  <i>both</i> - react to any change in state. <br><br>  The instruction states that it is only necessary to set one of these values ‚Äã‚Äã(except for <i>none</i> ), so immediately using the function poll () or select () you can determine whether the state of the line has changed.  In case the state has not changed, the read () call for the <i>value</i> file should be blocked.  However, there is a subtlety.  If you open the <i>value</i> file and try to set poll () on it, you will get that the reading will not be blocked, regardless of whether the state of the line has changed or not. <br><br>  The authors of the GPIO subsystem apparently wanted <code>cat value</code> always work, regardless of what is written in the <i>edge</i> file, so the first reading will never be blocked.  In principle, this is logical: in order to track changes, you must first determine the initial state.  However, I had to spend almost two hours, and only in some abandoned forum I found an assumption why poll () does not work and what can be done for this. <br><br>  I opened the <i>value</i> file for each reading and was very surprised why the lock was not happening.  It turned out that the file needs to be opened once for the entire session of tracking the line, reading the initial value from it and only then subsequent read operations will be blocked until the event specified in the <i>edge</i> appears.  And here, too, there is one subtlety: the values ‚Äã‚Äãfrom the <i>value</i> file are read only at offset 0, while a call to the read () function changes the read position.  Therefore, before calling read (), you need to reset the read position with lseek ().  In Linux documentation, these moments are somehow bypassed. <br><br>  Here is what GPIO reading will look like using <i>edge</i> events: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// set edge event on specific gpio_line int gpio_edge_set(int n, const char *edge_str) { char filename[PATH_MAX]; FILE *file; snprintf(filename, sizeof(filename), "/sys/class/gpio/gpio%d/edge", n); file = fopen(filename, "w"); if (file == NULL) return -1; fprintf(file, "%s\n", edge_str); fclose(file); return 0; } // set GPIO line polling mode int gpio_poll(int n) { char filename[PATH_MAX]; int fd; char c; int err; snprintf(filename, sizeof(filename), "/sys/class/gpio/gpio%d/value", n); fd = open(filename, O_RDONLY); if (fd &lt; 0) return -1; read(fd, &amp;c, sizeof(c)); return fd; } // get GPIO line value int gpio_get(int fd, int timeout) { struct pollfd pollfd[1]; char c; int err; pollfd[0].fd = fd; pollfd[0].events = POLLPRI | POLLERR; pollfd[0].revents = 0; err = poll(pollfd, 1, timeout); if(err != 1) return -1; lseek(fd, 0, SEEK_SET); err = read(fd, &amp;c, sizeof(c)); if(err != 1) return -1; return c - '0'; }</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  So, what we have: we can use the GPIO line for output and input, and even with minimal resources, track changes on the line.  The only thing we missed is the uevent file.  To be honest, I really did not understand what it was and what it was for.  Usually, uvent is the interface for the hotplug service, which, in particular, is used by the udev daemon.  It seems that in openWRT udev you can configure it so that when the level changes on the line, some application will run.  However, I‚Äôm not sure whether this is done by a regular udev or whether it had to be patched accordingly. <br><br>  Is this all what a GPIO driver is capable of?  Of course no.  As mentioned above: the GPIO interface in sysfs appeared relatively recently, and before that it was used exclusively by the kernel as a driver for some physical bus.  You can connect it to this bus, for example, SPI or I2C, you can make it be part of another hardware bus (for example, the ChipSelect line on the same hardware SPI), or even just set the LED and keyboard drivers on it.  However, the description of these features is beyond the scope of this article. <br><br><h4>  Bibliography </h4><br>  LGPIO00 :, Documentation / gpio.txt, </div><p>Source: <a href="https://habr.com/ru/post/236251/">https://habr.com/ru/post/236251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236239/index.html">I found a bug in the browser!</a></li>
<li><a href="../236241/index.html">Scientists have built a map of comet Churyumov-Gerasimenko based on high-definition images</a></li>
<li><a href="../236245/index.html">Specificity of used goods purchases on eBay: statistics, force majeure, security</a></li>
<li><a href="../236247/index.html">Statistics: why you should not buy Apple stock after the release of the new iPhone</a></li>
<li><a href="../236249/index.html">Intel NUC is not only for Windows. Teach Nyusha to believe in the universal bonds of community that bind all of humanity.</a></li>
<li><a href="../236253/index.html">I am groot. We do our analytics on events</a></li>
<li><a href="../236255/index.html">Increasing online store sales: 5 steps to create the perfect email newsletter</a></li>
<li><a href="../236263/index.html">The effect of a faulty monitor for text, images and SVG</a></li>
<li><a href="../236265/index.html">"VALS Semester of Code" after "Google Summer of Code", or "Do you have a opensource project? ‚ÄúFree developers are coming to you!‚Äù</a></li>
<li><a href="../236267/index.html">The presentation of the BlackBerry Passport is scheduled for September 24, 2014.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>