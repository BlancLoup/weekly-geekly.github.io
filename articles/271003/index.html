<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pro Parboiled (Part 4 final)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 4. The harsh reality 

 How to make Parboiled work even faster? What mistakes are better not to allow? What to do with the inheritance in the for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pro Parboiled (Part 4 final)</h1><div class="post__text post__text-html js-mediator-article">  <strong>Part 4. The harsh reality</strong> <br><br>  How to make Parboiled work even faster?  What mistakes are better not to allow?  What to do with the inheritance in the form of Parboiled1?  The concluding article of the series is designed to answer these, as well as other questions. <br><br>  <strong>Cycle structure:</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://habrahabr.ru/post/270233">Part 1. Why Parboiled?</a> </li><li>  <a href="http://habrahabr.ru/post/270531">Part 2. Comparison of the text</a> </li><li>  <a href="http://habrahabr.ru/post/270609">Part 3. Data Extraction</a> </li><li>  Part 4. The harsh reality </li></ul><br><a name="habracut"></a><br><br><h1>  Performance </h1><br>  Parboiled2 runs fast, but sometimes it can work even faster.  In this section we will talk about available micro-optimizations.  The main thing when performing optimizations is timeliness.  But if it is possible to immediately write a little more optimal code, without losing expressiveness at the same time, this opportunity should definitely be used. <br><br>
<h2>  <code>n.times</code> for small n &lt;= 4 </h2><br>  You can win in performance if, for small <em>n,</em> instead of the repetition operator <code>n.times</code> you simply join several repetitive rules into a chain.  How many repetitions it makes sense to unfold depends on the circumstances, but this number is hardly more than four. <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  rule { 4 times Digit } //  rule { Digit ~ Digit ~ Digit ~ Digit }</span></span></code> </pre> <br>  The relevance of this optimization was <a href="https://github.com/sirthias/parboiled2/issues/101">declared</a> by Matthias himself, although, hypothetically, the <code>n.times</code> operator could also perform it himself. <br><br><h2>  Accelerating stack operations for <code>n.times</code> </h2><br>  Using this technique will allow you to squeeze a little bit of performance when extracting data from a stack of values.  For example, so it can be applied to the previous rule: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Digit4</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">Digit</span></span> ~ <span class="hljs-type"><span class="hljs-type">Digit</span></span> ~ <span class="hljs-type"><span class="hljs-type">Digit</span></span> ~ <span class="hljs-type"><span class="hljs-type">Digit</span></span> ~ push( #(charAt(<span class="hljs-number"><span class="hljs-number">-4</span></span>))*<span class="hljs-number"><span class="hljs-number">1000</span></span> + #(charAt(<span class="hljs-number"><span class="hljs-number">-3</span></span>))*<span class="hljs-number"><span class="hljs-number">100</span></span> + #(charAt(<span class="hljs-number"><span class="hljs-number">-2</span></span>))*<span class="hljs-number"><span class="hljs-number">10</span></span> + #(lastChar) ) }</code> </pre> <br><h2>  Do not recreate <code>CharPredicate</code> </h2><br>  It is perfectly normal to rejoice at the new features of the <code>CharPredicate</code> class, but you should not create your own instances of the <code>CharPredicate</code> type inside the <code>rule</code> block: your predicate will be recreated every time the rule is fulfilled, which will dramatically ruin your parser's performance.  Therefore, instead of creating character predicates each time, define them inside your parser as a constant: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyParser</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ParserInput</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Uppercase</span></span> = <span class="hljs-type"><span class="hljs-type">CharPredicate</span></span>.from(_.isUpper) ... }</code> </pre> <br>  or, even better, send this ad to your parser's companion object: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyParser</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ParserInput</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Uppercase</span></span> = <span class="hljs-type"><span class="hljs-type">CharPredicate</span></span>.from(_.isUpper) }</code> </pre> <br><h2>  Use semantic predicates </h2><br>  The peculiarity of these rules is that they do not interact with the stack of values.  In detail, they are described in the documentation, but the most important thing is that you should know about them: <br><br><blockquote>  When using semantic predicates, the parser does not make progress, that is, it does not move its cursor to the next character.  Therefore, with their mindless use of the parser can loop. <br></blockquote><br>  Remember the example of declaring a character predicate for uppercase characters?  You can do the same thing using the semantic predicate <code>test</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JavaUpperCase</span></span></span><span class="hljs-function"> </span></span>= rule { oneOrMore(test(currentChar.isUpper) ~ <span class="hljs-type"><span class="hljs-type">ANY</span></span>) }</code> </pre> <br><h2>  Use <code>ANY</code> where you would like to see <code>CharPredicate.All</code> </h2><br>  Alas, <code>CharPredicate.All</code> is slow for large ranges of characters, <code>ANY</code> is faster.  Take advantage of this knowledge. <br><br><h2>  Use an inverting predicate </h2><br>  Imagine that your parser should capture all characters before a line feed (for definiteness, in Unix style).  Of course, this can be done with <code>noneOf</code> , but the inverting predicate will be faster: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span></span>= rule { capture(zeroOrMore(noneOf(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>))) } <span class="hljs-comment"><span class="hljs-comment">// ? def foo = rule { capture(zeroOrMore(!'\n')) }</span></span></code> </pre> <br>  Unfortunately, this great looking example will loop, because the parser will not make any progress.  To fix this, you need a rule that moves the cursor of the parser, but does not change the stack.  For example, like this: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span></span>= rule { capture(zeroOrMore( !'\n' ~ <span class="hljs-type"><span class="hljs-type">ANY</span></span> )) }</code> </pre> <br>  Now the rule <code>foo</code> will absorb absolutely everything except <code>EOI</code> and line feed. <br><br><h1>  Error reports </h1><br>  I don‚Äôt think that you want to work with the parser that produces meaningless messages with any incorrect input data.  Parboiled2 is able to quite clearly talk about errors, if you help him in this. <br><br><h2>  Formatting </h2><br>  So, if something is screwed up, the parser will give you an object of type <code>ParseError</code> , which can be put into a readable form using the <code>formatError</code> method: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage = parser formatError error</code> </pre> <br>  If the default formatting does not suit you for some reason, you should express your wishes to the parser explicitly: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage parser.formatError(error, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ErrorFormatter</span></span>(showTraces = <span class="hljs-literal"><span class="hljs-literal">true</span></span>))</code> </pre> <br>  If you want to write your <code>ErrorFormatter</code> , you will have to figure out for yourself the structure of the <code>ParseError</code> class, which is declared in the depth of Parboiled in the following way: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseError</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">position: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Position</span></span></span></span><span class="hljs-class"><span class="hljs-params">, charCount: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, traces: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">RuleTrace</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimeException</span></span></span></span></code> </pre> <br>  It is also worth noting the presence of several schemes for delivering error messages to the user: at your request, <code>ParseError</code> can be represented not only as a <code>Try</code> object, but, for example, as a polymorphic type or <code>Either</code> .  More details can be found <a href="">here</a> . <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-string"><span class="hljs-string">"foo"</span></span> | fail(<span class="hljs-string"><span class="hljs-string">" !"</span></span>) }</code> </pre> <br><h2>  Fine tuning </h2><br>  There is an option to bypass the built-in error reporting mechanism.  To do this, use the <code>fail</code> rule with the message you want to see in case of an error: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Goldfinger</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-string"><span class="hljs-string">"talk"</span></span> | fail(<span class="hljs-string"><span class="hljs-string">"to die"</span></span>) }</code> </pre> <br>  Then at an opportunity, you will get back your error message in the following form: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Invalid</span></span> input <span class="hljs-symbol"><span class="hljs-symbol">'Bon</span></span>d', expected to die. (line <span class="hljs-number"><span class="hljs-number">1</span></span>, column <span class="hljs-number"><span class="hljs-number">1</span></span>):</code> </pre> <br><h2>  Named Rules </h2><br>  The use of this type of rules is very useful not only in order to catch errors.  This mechanism is described in detail in the ‚ÄúBest Practices‚Äù section. <br><br><h2>  atomic </h2><br>  Parboiled2 generates PEG based parsers.  This means that the parsers operate with characters, not strings (as many might have thought), so errors will be shown to you at the character level.  Agree - a message of the form ‚ÄúYou have X here, we expected Y or Z‚Äù will require more mental efforts than ‚ÄúYou have XX here, and we expected to see XY or XZ‚Äù.  In order to see the lines in the error reports as a whole, there is a <code>atomi</code> marker, all you have to do is wrap the rule in it: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AtomicRuleTest</span></span></span><span class="hljs-function"> </span></span>= rule { atomic(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) | atomic(<span class="hljs-string"><span class="hljs-string">"fob"</span></span>) | atomic(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>) }</code> </pre> <br>  To receive <code>foxes</code> at the entrance <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Invalid</span></span> input <span class="hljs-string"><span class="hljs-string">"fox"</span></span>, expected <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-string"><span class="hljs-string">"fob"</span></span> or <span class="hljs-string"><span class="hljs-string">"bar"</span></span> (line <span class="hljs-number"><span class="hljs-number">1</span></span>, column <span class="hljs-number"><span class="hljs-number">1</span></span>): foxes ^</code> </pre> <br><h2>  quiet </h2><br>  When there are too many options to choose from, you don‚Äôt always want to notify the user about all possible alternatives.  For example, in a certain place your parser expects a lot of whitespace characters in conjunction with a certain rule.  To eliminate redundancy in a report, you may want to keep silent about spaces.  Using the <code>quiet</code> marker is very simple: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OptionalWhitespaces</span></span></span><span class="hljs-function"> </span></span>= rule { quiet(zeroOrMore(anyOf(<span class="hljs-string"><span class="hljs-string">" \t\n"</span></span>))) }</code> </pre> <br>  Honestly, there are no situations that encourage the use of this rule.  As well as <code>atomic</code> , it is <a href="">described in</a> detail <a href="">in the documentation</a> . <br><br><h2>  Error recovery </h2><br>  Practically the only episode in which Parboiled1 wins, and in Parboiled2, things are not very good: the parser falls only on the type of the first error it encountered.  For most scenarios, this is great: for example, it does not interfere with parsing logs, text protocols, configuration files (for some cases), but this will not please the developers of DSL or IDE-like tools.  <a href="https://github.com/sirthias/parboiled2/issues/42">Matthias promises to fix this</a> , so if you really need this functionality today, write to the bug tracker, perhaps this will speed up the development process. <br><br>  Parboiled1 has a <a href="https://github.com/sirthias/parboiled/wiki/Parse-Error-Handling">huge number of ParserRunners</a> for all occasions.  Look toward <code>RecoveringParserRunner</code> if you need to continue parsing in case of errors. <br><br><h2>  Testing </h2><br>  Parboiled developers use the specs2 framework for testing, which they supplemented with their auxiliary class <a href="http://bit.ly/1Y5iZ9t">TestParserSpec</a> .  It will seem inconvenient to those who use the scalatest, but his main idea can be adopted.  In secret from Mathias, his decision is not particularly accurate, as it relies on a changeable state.  Perhaps in the future we will have to wait for something similar to a full-fledged framework for testing. <br><br>  Rules can be tested both separately and together.  Personally, I prefer to write tests not for every rule, but to check only the main rule in ‚Äúspecial‚Äù cases: <br><br><blockquote>  In many formats, even standardized, very interesting moments can occur.  For example, in the BSD-like message format of <a href="https://www.ietf.org/rfc/rfc3164.txt">RFC 3164</a> , there are <em>always</em> two positions for the day of the month, even if the number itself has one digit.  Here is an example from the RFC itself: <br><br><blockquote>  If the day is less than 10, then it must be represented as the space and then the number.  For example, the 7th day of August would be represented as <code>"Aug 7"</code> , with two spaces between the <code>"g"</code> and the <code>"7"</code> . <br></blockquote></blockquote><br>  In addition to this kind of ‚Äúinteresting moments‚Äù, you can feed the parser strings with unclosed brackets, invalid characters, check the order of operations with the stack of values. <br><br>  In testing there is another subtlety that you will immediately encounter.  Suppose you want to test the following rule: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decimal</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { (<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>).? ~ <span class="hljs-type"><span class="hljs-type">Digit</span></span>.+ ~ <span class="hljs-string"><span class="hljs-string">"."</span></span> ~ <span class="hljs-type"><span class="hljs-type">Digit</span></span>.+ }</code> </pre> <br>  To do this, we will send the parser obviously incorrect input and wait for the output error: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//         . val p = new MyParser("12.3.456").Decimal.run() // Success(()) p.isFailure shouldBe true //  </span></span></code> </pre> <br>  But when you run the test, it turns out that the parser returned a successful result.  Why is that?  There is no <code>EOI</code> in our rule, but if we add an <code>EOI</code> to it, we spoil all the rules that <code>Decimal</code> use.  Therefore, it is necessary to create a special testing rule, for example, using the cunning mechanism of <a href="">meta-rules</a> .  Let's add an EOI at the end of our previous example, and make sure that the parser fell with an error: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Failure</span></span>(<span class="hljs-type"><span class="hljs-type">ParseError</span></span>(<span class="hljs-type"><span class="hljs-type">Position</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-type"><span class="hljs-type">Position</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), &lt;<span class="hljs-number"><span class="hljs-number">2</span></span> traces&gt;))</code> </pre> <br><h1>  Disadvantages of parboiled </h1><br><h2>  Parboiled2 </h2><br>  If people have shortcomings, why not have them?  Here Parboiled2 is no exception. <br><br><ul><li>  Long, too general and completely incomprehensible error messages from the compiler, in the best traditions of C ++.  An illustrative example is shown in the figure below (the <code>~</code> rule is inadvertently omitted in the rule).  The reason is related to performing advanced checks on types that <a href="https://github.com/sirthias/parboiled2/issues/106">promise to be removed</a> in future versions. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ca6/fe6/0a4/ca6fe60a4692d96f4d7e2034bc4eaa0c.png" alt="The compiler swears dirty"><br>  The compiler swears dirty <br><br><ul><li>  This problem no longer relates to Parboiled2, but to scalac.  The compiler can tear down the roof if argument types are explicitly (not) defined on a lambda that captures values ‚Äã‚Äãfrom the stack: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    def MyRule = rule { oneOrMore(Visible) ~&gt; {s =&gt; "[" + s + "]"} } //    def MyRule = rule { oneOrMore(Visible) ~&gt; {s: String =&gt; "[" + s + "]"} }</span></span></code> </pre> <br>  What works and what doesn't depends on the version of your compiler. <br></li><li>  Many IDEs have not yet learned how to support macro-expressions, and Parboiled2 was built not without their help.  Therefore, do not believe the underscores of your development environment.  Once, having forgotten about it, I spent the whole day searching for a non-existent error literally out of the blue. </li><li>  Lack of recovery mechanism in case of unsuccessful parsing.  Designing domain-specific languages, or those who want to use Parboiled2 as a front-end to their compiler, this will greatly disappoint.  But <a href="https://github.com/sirthias/parboiled2/issues/42">work</a> on it.  If you want to see this opportunity - write, it will speed up the development. </li></ul><br><ul><li>  I think that many developers of their small IDE and text editors would like to see more flexible error messages than those that are provided now.  At the <a href="https://github.com/sirthias/parboiled2/issues/96">moment</a> there are only two ways to influence them: <br><ul><li>  named rules </li><li>  named nested rules. </li></ul></li></ul><br><h2>  Parboiled1 </h2><br>  Most projects are still written in Parboiled1, and it is unlikely that something will change dramatically and drastically (in the enterprise), so it may be useful to know how to learn to put up with its shortcomings, of which Parboiled1 has a lot.  In addition to the very limited DSL, Parboiled has a ‚ÄúRule8‚Äù problem, which complicates writing a parser for logs.  Parboiled1 is designed so that for each rule with N elements there is a class, by analogy with tuples: there is <code>Rule0</code> , <code>Rule1</code> , right up to <code>Rule7</code> .  This is quite enough to parse complex programming languages, such as Java, and generally does not cause significant problems when parsing tree structures.  But if you need to extract data from a linear structure, for example, log-file messages, then it is very easy to rest against this restriction.  This is solved using a tuple instead of a single resulting rule.  Here is an example: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">LogEvent</span></span>] = rule { <span class="hljs-type"><span class="hljs-type">Header</span></span> ~ <span class="hljs-string"><span class="hljs-string">" "</span></span> ~ <span class="hljs-type"><span class="hljs-type">UserData</span></span> ~ <span class="hljs-string"><span class="hljs-string">" "</span></span> ~ <span class="hljs-type"><span class="hljs-type">Message</span></span> ~~&gt; { (header, data, message) =&gt; <span class="hljs-type"><span class="hljs-type">SyslogEvent</span></span> ( header._1, header._2, header._3, header._4, header._5, data._1, data._2, message ) } }</code> </pre> <br>  Let it look poor, but the problem is solved. <br><br><h1>  Best practices </h1><br>  In this section I will talk about common truths that work for any parser combinator, as well as about the nuances specific to Parboiled2. <br><br><h2>  Charutils </h2><br>  There is one useful object not mentioned in the documentation: <a href="http://bit.ly/1NJJ2kd">CharUtils</a> .  It contains a number of static methods that can facilitate your life, for example: changing the case of characters, escaping, converting integer values ‚Äã‚Äãinto the corresponding characters (strings).  and others. Its use may save your time. <br><br><h2>  Write unit tests </h2><br>  One small unsuccessful change can break your grammar and provide acute rectal pain.  This is a trivial advice that many people neglect.  The parser is not as difficult to test as, say IO: you do not need Mock objects and other tricks for this routine, but very valuable work.  We had a whole parser infrastructure.  And believe me, the first thing I did when searching for errors was to sit down and write tests, if they were not. <br><br><h2>  Make parsers and rules small </h2><br>  Split your parsers into sub-parsers.  Each component must do something well defined.  For example, if you parse LogEvent, for which the Timestamp field is defined (especially if this Timestamp corresponds to some Rfc), then do not be lazy and take it out separately. <br><br><ul><li>  First, it will reduce the code of your main prasser, and make it clearer. </li><li>  Secondly, it greatly facilitates testing.  You will cover your podparser with unit tests.  And then proceed to the development of the main parser </li></ul><br>  There are different approaches: <br><br><ul><li>  Break parser into traits and use self-typed reference (I prefer this method). </li><li>  Declare parsers as separate entities and use composition. </li><li>  Use the built-in mechanism to create subParsers. </li></ul><br>  The rules should be as compact as possible, but not more compact.  The smaller your rules, the easier it is to find a mistake in the grammar.  It is very difficult to understand the logic of the developer, if he makes the rules long, and at the same time reuses <code>capture</code> .  Implicit capture can aggravate the situation.  Specifying the type of rule also helps with support. <br><br><h2>  Send case objects instead of strings in the Value stack </h2><br>  This advice can also be attributed to optimizations, since this will make the parser work faster.  Send meaningful objects to Value stack, not strings.  This will make your parser faster, and the code more clearly. <br><br>  Poorly: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logLevel</span></span></span><span class="hljs-function"> </span></span>= rule { capture(<span class="hljs-string"><span class="hljs-string">"info"</span></span> | <span class="hljs-string"><span class="hljs-string">"warning"</span></span> | <span class="hljs-string"><span class="hljs-string">"error"</span></span>) ~ ':' }</code> </pre> <br>  Good: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logLevel</span></span></span><span class="hljs-function"> </span></span>= rule { ‚Äúinfo:‚Äù ~ push(<span class="hljs-type"><span class="hljs-type">LogLevel</span></span>.<span class="hljs-type"><span class="hljs-type">Info</span></span>) | ‚Äú<span class="hljs-string"><span class="hljs-string">warning" ~ push(LogLevel.Warning) | ‚Äúerror"</span></span> ~ push(<span class="hljs-type"><span class="hljs-type">LogLevel</span></span>.<span class="hljs-type"><span class="hljs-type">Error</span></span>) }</code> </pre> <br><h2>  Use the simplified syntax to build the object. </h2><br>  This beautiful way appeared in Parboiled1.  No magic, just the case class constructor is invoked implicitly.  The main thing is that the number and type of arguments placed on the Value Stack match the signature of the case class constructor. <br><br>  Poorly: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charsAST</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">AST</span></span>] = rule { capture(<span class="hljs-type"><span class="hljs-type">Characters</span></span>) ~&gt; ((s: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">AText</span></span>(s)) }</code> </pre> <br>  Good: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charsAST</span></span></span><span class="hljs-function"> </span></span>= rule { capture(<span class="hljs-type"><span class="hljs-type">Characters</span></span>) ~&gt; <span class="hljs-type"><span class="hljs-type">AText</span></span> }</code> </pre> <br><h2>  Named rules </h2><br>  Named rules significantly simplify life when receiving error reports, since they make it possible to use a pseudonym instead of a vague rule name.  Or mark the rules with a specific tag - "This expression" or "Modifies the stack."  In any case, to know about this function will be useful. <br><br>  Many Parboiled1 users have already loved this feature.  For example, Neo4J developers using Parboiled to parse the <a href="http://neo4j.com/docs/2.2.3/cypher-introduction.html">Cypher</a> language. <br><br>  What it looks like in Parboiled1: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Header</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Header</span></span>] = rule(<span class="hljs-string"><span class="hljs-string">"I am header"</span></span>) { ... }</code> </pre> <br>  In Parboiled2: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Header</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Header</span></span>] = namedRule(<span class="hljs-string"><span class="hljs-string">"header is here"</span></span>) { ... }</code> </pre> <br>  It is also possible to give names to nested rules: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserName</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">Prefix</span></span> ~ oneOrMore(<span class="hljs-type"><span class="hljs-type">NameChar</span></span>).named(<span class="hljs-string"><span class="hljs-string">"username"</span></span>) ~ <span class="hljs-type"><span class="hljs-type">PostFix</span></span> }</code> </pre> <br><h1>  Migration </h1><br>  Migration is often a simple process, but it takes a lot of time.  Therefore, I will try to save at least a little precious hours of your life and describe the main pitfalls. <br><br><h2>  Classpath </h2><br>  In order to avoid conflicts with the first version, Parboiled2 uses the classpath <code>org.parboiled2</code> (while the classpath uses the first version of <code>org.parboiled</code> ).  The Mavenovsky <code>groupId</code> , however, remained old: <code>org.parboiled</code> .  Due to this, it is possible to have both dependencies in one project and make a gradual transition to the new version.  Which, by the way, works quite well in the presence of several autonomous parsers.  If your parsers consist of many modules that are reused in different places (as was the case in my case), you will have to do the migration at once for all modules. <br><br><h2>  Test validation </h2><br>  Verify the availability and operability of the unit tests.  Do you have them?  Not?  Write them.  During the migration process, I had to refine some grammars because the new DSL became more powerful, and unintentional changes broke grammars.  Falling tests saved a lot of time.  I did not encounter serious problems, such as a breakdown of the entire grammar.  Maybe someone will share their experience if this happened to him. <br><br><h2>  Code around parser </h2><br>  Now the parser will be recreated every time, which is not always convenient.  With PB1, I really liked to create a parser once, and then repeatedly use it.  Now this number will not work.  Therefore, you will have to change the constructor of the parser and rewrite the code using it a little, and do not be afraid that this will worsen performance. <br><br><blockquote>  <strong>Warning</strong> Parboiled1 allows you to generate rules at run time.  Therefore, if you have a similar parser, then you will most likely have to rewrite it: Parboiled2 uses macro expressions that make the dynamics very difficult, giving you better performance instead. <br></blockquote><br><h2>  Composition </h2><br>  The approach to the composition of the elements of the parser has not changed, this is good news for migrants.  However, <code>Parser</code> is no longer a treyt, but an abstract class.  Traits are the most convenient means of composing software components, in PB1 this allowed <code>Parser</code> to be mixed into any modules, mixing the modules together.  The change in favor of the abstract class had no effect on this possibility, but now for this you need to use <a href="http://docs.scala-lang.org/tutorials/tour/explicitly-typed-self-references.html">self-typed reference</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Numbers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span> =&gt; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br>  Those who have not used such a language opportunity and each time mixed the <code>Parser</code> treit will have to change their taste preferences. <br><br>  As an alternative method, you can make full parsers of your traits and import the necessary rules (as methods) from them into your main parser.  I, however, still prefer to use the composition of the traits, because I find them more visual: it is clearer for me to see the parser assembled from pieces, instead of multiple imports. <br><br><h2>  Getting rid of primitives </h2><br>  During the migration process, be sure to arrange a revision of your personal library of primitive rules: delete everything that is in <code>CharPredicate</code> .  Your library will lose weight, but it will not disappear altogether.  Many people would like to add to parboiled support for various date formats, a grammar describing email, and HTTP headers.  Parboiled is just a parser combinator: it was such, it will remain so.  However, you must admit that it is very nice to throw out the old code. <br><br><h1>  Conclusion </h1><br>  In this series of articles, I tried to tell you about the most progressive and promising parsing tool that exists for the scala language.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I made a small tutorial and talked about the problems that I had to face in practice. </font><font style="vertical-align: inherit;">I hope that this article in the worst case will be useful for you, and at best - will be a guide to action.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Used sources </font></font></h1><br><ul><li> <a href="https://groups.google.com/forum/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parboiled Project Mailing List</font></font></a> </li><li> <a href="http://www.youtube.com/watch%3Fv%3DqZg4D62K4aQ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentation by Alexander Maltsev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://myltsev.name/ScalaDays2014/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slides to her</font></font></a> </li><li> <a href="http://bit.ly/1H2ZQ3A"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code samples from Parboiled repository</font></font></a> </li><li> <a href="https://github.com/sirthias/parboiled2/tree/master/scalaParser/src"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The parser language scala, written with Parboiled2</font></font></a> </li></ul><br><h1>  Thanks </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want to express my gratitude to Alexander and Matias for having a reason for the article, as well as a handy tool. Yana, thank you for reading and editing my many mistakes, I promise I will write more intelligently. Thank you </font></font><a href="https://habrahabr.ru/users/firegurafiku/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firegurafiku</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and Too Taboo for helping us with the first article in Vertsk, proofreading, numerous corrections, and ideas for examples in subsequent ones. Thanks to Vlad Ledovskikh for proofreading and corrections in the last article of the series. Thanks </font></font><a href="https://habrahabr.ru/users/nehaev/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nehaev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for the error found in the article code, and Igor Kustov for the idea of ‚Äã‚Äãbreaking the huge article into parts (I didn‚Äôt want to do this for a long time). Special thanks to Arseny Alesandrovich </font></font><a href="https://habrahabr.ru/users/primetalk/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primetalk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for inaccuracies found and</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useful suggestions. </font><font style="vertical-align: inherit;">Thanks to all those who followed the cycle of articles and reached the last. </font><font style="vertical-align: inherit;">I hope the work was not done in vain.</font></font></div><p>Source: <a href="https://habr.com/ru/post/271003/">https://habr.com/ru/post/271003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270989/index.html">Faster, wider, stronger: plans for the development of Bluetooth in 2016</a></li>
<li><a href="../270991/index.html">How Badoo generates images for ‚Äúsharing‚Äù in social networks</a></li>
<li><a href="../270995/index.html">Outlook Add-Ins or where does 25% of working time go and is it possible to return it?</a></li>
<li><a href="../270999/index.html">Design for Dyslexics, Part Two</a></li>
<li><a href="../271001/index.html">Big data as art</a></li>
<li><a href="../271005/index.html">Cloud Platform Localization: Software Developer's Guide</a></li>
<li><a href="../271007/index.html">Moff.js and modulated Bootstrap</a></li>
<li><a href="../271011/index.html">Cross-compiling and building a package under Synology DSM</a></li>
<li><a href="../271013/index.html">Preparing FMOD, Cocos2D-x, OpenAL and OpenSSL libraries for Android devices built on the Intel platform</a></li>
<li><a href="../271015/index.html">We write our own interface management corporate FMC SIM-cards</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>