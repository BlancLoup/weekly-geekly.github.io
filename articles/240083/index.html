<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>jQuery.viewport or how I searched for items on the screen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Just like every girl should have a ‚Äúlittle black dress‚Äù, every front-end developer should have a ‚Äúlittle black plug-in‚Äù ... somehow it doesn't sound v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>jQuery.viewport or how I searched for items on the screen</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c70/d7d/ed1/c70d7ded144c4564bad47b18d84eb3c2.jpg"><br>  Just like every girl should have a ‚Äúlittle black dress‚Äù, every front-end developer should have a ‚Äúlittle black plug-in‚Äù ... somehow it doesn't sound very much, let there be a ‚Äúlittle functional plug-in‚Äù, so what is it about me, me that I want to share one such. <br><br>  The presented plugin allows you to determine the position of any element / set of elements relative to the viewing area.  Functionally, it expands the set of pseudo-selectors, as well as adds an element tracker. <br><br>  Also, under the cut, I will talk about the process of writing a plug-in, what difficulties I encountered, etc., if I became interested in you - you are welcome under the cut. <br><a name="habracut"></a><br>  I got up before me the task of catching and processing elements at the moment of their appearance in the scope, moreover, the scope is not always the whole screen, sometimes it is a block with <code>overflow: auto;</code>  , and sometimes it is necessary to process the elements only when they appear on the screen as a whole and moreover, scrolling there in all directions (vertically or / and horizontally). <br>  I went to googol in search of something ready and to my surprise, I couldn‚Äôt find anything that would fully satisfy my needs, or the task was partially solved, like for example (to confess honestly, the idea of ‚Äã‚Äãextending pseudo-selectors steal from there, but <a href="">this</a> picture is not lying, right?), or the plugin was not at all about that.  So I got up to the fact that I had to write my own, then I decided to share this business on a githaba, and later decided to write this article, rather than actually completing the first two points of my plan <s>for becoming a celebrity</s> , and doing it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are not interested in the development process you poke <b>- &gt;&gt;</b> <a href="https://habr.com/ru/post/240083/">here</a> <b>&lt;&lt; -</b> and you immediately get to the place about where they distribute. <br><br><h6>  <b>Prologue</b> </h6><br>  If you do not know about writing plugins for jQuery, but really want to learn it - I strongly advise you to read <a href="http://habrahabr.ru/post/158235/">this article first</a> , everything is intelligible and understandable (it assumes at least basic knowledge of JS and JQ). <br><br><hr><br><h5>  <b>UPDATE 1 (10/13/2014)</b> </h5><br>  - Rewritten part of the plugin, see the changes on the githaba. <br>  - A problem has been detected that I cannot find a solution to: <br><blockquote>  If the parent element has no limiting factors (padding, border, overflow! = Visible), then the margin moves from the inner element to the outer one, and the offsetHeight of the parent element will be calculated without taking into account the margin of its descendants, while the scrollHeight correctly determines the height from considering the margin of the child elements.  As a result, such a parent element is defined as having a scrolling, since  content height &lt;height of the element itself. </blockquote><br><hr><br><h5>  <b>UPDATE 2 (10/16/2014)</b> </h5><br>  - As a solution to the above problem, the ability was added to set the viewport selector to be monitored, details on the githaba. <br>  - The speed of the plugin is markedly increased <br><br><hr><br><br><h4>  <b>Let's get started</b> </h4><br>  So, the task: it is necessary to somehow determine the position of the element relative to the scope, and depending on the context, the scope can be not only the browser window, but also smaller elements that have scrolling. <br><br><h5>  <b>What is the scope?</b> </h5><br>  Let's start, perhaps, with the definition of what is for a given context is the scope. <br>  For my task, and I wrote a plugin, first of all, to meet their needs, the scope is the nearest parent with scrolling. <br><img src="https://habrastorage.org/files/021/625/7eb/0216257ebf684f2f8d7ada92cda6c3c3.jpg"><br>  Unfortunately, there is no guaranteed and cross-browser way to determine if there is a scrollbar (at least I don‚Äôt know about this), and besides, I use a custom scrollbar, it can be adequately designed, but <code>overflow: hidden;</code> applies to the container <code>overflow: hidden;</code>  and, as a result, the stock scrollbar is hidden. <br>  But there is a way out, you can compare the height of the container ( <code>containerElem.offsetHeight</code> ) and the height of its contents ( <code>containerElem.scrollHeight</code> ) and if the height of the content exceeds the height of the container, then most likely, and for my projects - always, such a container has scrolling. <br>  We make this case in the code: <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> $ </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,       var methods = { //            haveScroll: function() { return this.scrollHeight &gt; this.offsetHeight || this.scrollWidth &gt; this.offsetWidth; } }; $.extend( $.expr[':'], { //    ':'  ,     ":have-scroll" "have-scroll": function( obj ) { return methods['haveScroll'].call( obj ); //  .call()      } } ); })( jQuery );</span></span></code> </pre><br>  From this point on, we can use .is (": have-scroll") to determine if an element has scrolling (or prerequisites for its presence) or not. <br><br><h5>  <b>Item Positioning</b> </h5><br>  The next step is to determine the location of the block of interest relative to the scope. <br>  The first thing that comes to mind: <br><pre> <code class="javascript hljs">top = $( element ).offset().top; left = $( element ).offset().left;</code> </pre>  But no, <code>.offset()</code> positions any element relative to the upper left corner of the browser window, and the scope, as mentioned, is not always the browser window - does not fit, we dismiss. <br><br>  The second thing that comes to mind: <br><pre> <code class="javascript hljs">top = $( element ).position().top; left = $( element ).position().left;</code> </pre>  Also not, <code>.position()</code> positions the element only relative to the upper left corner of its nearest parent, it would seem that here, but consider the structure: <pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"viewport"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"element"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre>  And the task is to track the <code>span</code> with respect to <code>#viewport</code> , in this case, <code>.position()</code> will position the <code>span</code> with respect to the <code>.element</code> that does not suit us, we drove on. <br><br>  The solution is a method that will bypass all parents up the DOM tree, up to the scope of the given context. <pre> <code class="javascript hljs">getFromTop: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTop = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = $( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).get( <span class="hljs-number"><span class="hljs-number">0</span></span> ); obj &amp;&amp; !$( obj ).is( <span class="hljs-string"><span class="hljs-string">':have-scroll'</span></span> ); obj = obj.offsetParent ) { fromTop += obj.offsetTop; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round( fromTop ); }</code> </pre>  Why is <code>$( this ).get( 0 ).offsetTop</code> , not <code>$( this ).position().top</code> ?  - some will ask. <br>  There are two reasons for this: <ul><li>  .position () takes into account the offset (top, bottom, left, right), does not take into account the margins, and therefore you have to use <code>.css('margin-top')</code> and then another <code>.css('margin-bottom')</code> </li><li>  these same <code>.css('margin-top')</code> and <code>.css('margin-bottom')</code> return a value of <code>13px</code> , that is, you also need to do parseInt (str, 10) to perform basic mathematical operations, the option of subtracting heights taking into account different indents (.innerHeight (), .outerHeight, .outerHeight (true)) I do not even consider, because they can be set asymmetrically, but this is important to us. <br>  In the end, with all these redundant operations, the option using <code>$( this ).position().top</code> works one and a half to two times slower than the version with <code>this.offsetTop</code> on my overclocked i7, and the user can sit on some hemp, and scary to imagine what it all pours out. </li></ul><br>  We add a similar method to determine the position from the left edge.  <s>Good thinking comes afterwards, you can combine them into one method, this will result in half the number of DOM tree walkthroughs, then finish it ..</s> <br><br>  So, now we know where, relative to the scope, the tracked object is located, but the data obtained will not change when scrolling, here we will be helped by <code>.scrollTop()</code> and <code>.scrollLeft()</code> , able to get the value of vertical and horizontal scrolling, respectively. <br>  Moreover, we need to know the position of all sides of the monitored block and the size of the scope. <br>  We make out in the next method: <br><pre> <code class="javascript hljs">getElementPosition: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _scrollableParent = $( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).parents( <span class="hljs-string"><span class="hljs-string">':have-scroll'</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//     , .parents() ,    .closest(), span, ,       . if( !_scrollableParent.length ) { // ,     . return false; } var _topBorder = methods['getFromTop'].call( this ) - _scrollableParent.scrollTop(); //             var _leftBorder = methods['getFromLeft'].call( this ) - _scrollableParent.scrollLeft(); //      return { "elemTopBorder": _topBorder, "elemBottomBorder": _topBorder + $( this ).height(), //   ,   =  +   "elemLeftBorder": _leftBorder, "elemRightBorder": _leftBorder + $( this ).width(), "viewport": _scrollableParent, "viewportHeight": _scrollableParent.height(), //     "viewportWidth": _scrollableParent.width() //     }; }</span></span></code> </pre><br>  This function returns a hash table, it is just easier to work with it afterwards.  Everything, with the relative positioning of the block sorted out. <br><br><h5>  <b>And yet, top or bottom</b> </h5><br>  Immediately to the code: <pre> <code class="javascript hljs">aboveTheViewport: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> threshold </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _threshold = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> threshold == <span class="hljs-string"><span class="hljs-string">'string'</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>( threshold, <span class="hljs-number"><span class="hljs-number">10</span></span> ) : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = methods[<span class="hljs-string"><span class="hljs-string">'getElementPosition'</span></span>].call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pos ? pos.elemTopBorder - _threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Here, I think, everything is clear, the only thing I will clarify about the threshold and strict minority. <br>  Threshold is a parameter that sets indent from the edge of the scope; for some tasks, processing may be necessary a little earlier than the object enters the scope or a little later. <br><img src="//habrastorage.org/files/6d3/76b/c65/6d376bc6567f4496a0a79e84c99e7c68.jpg"><br>  And a strict minority is indicated for the reason that if the borders coincide, then the element has not yet crossed the border and so far fits into the visibility zone, which means it is inside. <br>  Also, for partial finding in the field of visibility, there is already a little more complicated, but still simple.  just this time we are checking that the corresponding border has gone beyond the scope of the visibility and the opposite is still within it. <pre> <code class="javascript hljs">partlyAboveTheViewport: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> threshold </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _threshold = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> threshold == <span class="hljs-string"><span class="hljs-string">'string'</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>( threshold, <span class="hljs-number"><span class="hljs-number">10</span></span> ) : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = methods[<span class="hljs-string"><span class="hljs-string">'getElementPosition'</span></span>].call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pos ? pos.elemTopBorder - _threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pos.elemBottomBorder - _threshold &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><br>  It makes no sense to describe the verification of the remaining boundaries, everything is the same there, except that you can quote the code of the method that checks for finding an element within the scope: <pre> <code class="javascript hljs">inViewport: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> threshold </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _threshold = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> threshold == <span class="hljs-string"><span class="hljs-string">'string'</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>( threshold, <span class="hljs-number"><span class="hljs-number">10</span></span> ) : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = methods[<span class="hljs-string"><span class="hljs-string">'getElementPosition'</span></span>].call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pos ? !( pos.elemTopBorder - _threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) &amp;&amp; !( pos.viewportHeight &lt; pos.elemBottomBorder + _threshold ) &amp;&amp; !( pos.elemLeftBorder - _threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) &amp;&amp; !( pos.viewportWidth &lt; pos.elemRightBorder + _threshold ) : <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br><h5>  <b>But what about selectors?</b> </h5><br>  Everything is good with them, nobody has forgotten about them. <br>  So, we wrote all the methods in the object literal <code>methods</code> , what next to do the boom?  Fan, expand the pseudo-selector literal: <pre> <code class="javascript hljs"> <span class="hljs-string"><span class="hljs-string">"in-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'inViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"above-the-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'aboveTheViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"below-the-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'belowTheViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"left-of-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'leftOfViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"right-of-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'rightOfViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"partly-above-the-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'partlyAboveTheViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"partly-below-the-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'partlyBelowTheViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"partly-left-of-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'partlyLeftOfViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"partly-right-of-viewport"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj, index, meta </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'partlyRightOfViewport'</span></span>].call( obj, meta[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); }, <span class="hljs-string"><span class="hljs-string">"have-scroll"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> obj </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> methods[<span class="hljs-string"><span class="hljs-string">'haveScroll'</span></span>].call( obj ); } } );</code> </pre><br>  It is worth noting one thing, remember I was talking about the <code>threshold</code> input parameter?  And remember the standard parametric pseudo-selector <code>:not(selector)</code> ? <br>  So, we can also use this structure to indicate treshold directly in the pseudo-selector: <pre> <code class="javascript hljs">$( element ).is( <span class="hljs-string"><span class="hljs-string">":in-viewport(10)"</span></span> );</code> </pre>  In this case, treshold will expand the scope by 10 px. <br><br><h4>  <b>Tracking</b> </h4><br>  Tax, pseudo-selectors have expanded, we should now have the whole thing in some convenient way to track something. <br>  Ideally, of course, we would have to create our own event, but historically it‚Äôs so that with <code>jQuery.event.special</code> we are in extremely bad relationships, and <code>.trigger()</code> is, in my opinion, a so- <code>.trigger()</code> idea, not for this case - for sure.  Therefore, we will have the most brutal function that calls the callBack function in a no less brutal way. <br><br><div class="spoiler">  <b class="spoiler_title">Tracker code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">$.fn.viewportTrack = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> callBack, options </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings = $.extend( { <span class="hljs-string"><span class="hljs-string">"threshold"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"allowPartly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"allowMixedStates"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, options ); <span class="hljs-comment"><span class="hljs-comment">//  - if( typeof callBack != 'function' ) { //         -     $.error( 'Callback function not defined' ); return this; } return this.each( function() { //      var $this = this; callBack.apply( $this, [ methods['getState'].apply( $this, [ settings ] ) ] ); //      var _scrollable = $( $this ).parents( ':have-scroll' ); if( !_scrollable.length ) { callBack.apply( $this, 'inside' ); return true; } if( _scrollable.get( 0 ).tagName == "BODY" ) { //  ,    body,  scroll   window,    body,       $( window ).bind( "scroll.viewport", function() { callBack.apply( $this, [ methods['getState'].apply( $this, [ settings ] ) ] ); } ); } else { _scrollable.bind( "scroll.viewport", function() { //    ,  scroll    callBack.apply( $this, [ methods['getState'].apply( $this, [ settings ] ) ] ); } ); } } ); };</span></span></code> </pre></div></div><br>  <b>NAILED IT!</b> <br>  Actually, no, we need to teach our brutal to "unscrew" ... to hell with these inventions, shorter stop tracking of an element, this is precisely the point that to track each individual element you create your own scroll event handler.  If all callback functions are called from one scroll event handler, we will not be able to influence the set of monitored items without reinstalling the handler again. <br>  Here we will be helped by the event namespace, if we produce <code>.bind( "scroll.viewport")</code> and <code>.bind( "scroll")</code> on the same element, and then <code>.unbind( ".viewport")</code> on the same element, then it is untied there will be only a <code>scroll.viewport</code> event <code>scroll.viewport</code> but not just a <code>scroll</code> . <br>  And how does this help in the current task?  - You ask, I answer, of course, you will have to fade out the namespace space (such is the tautology), but the goal will be achieved, so add a method that generates a random id.  everything is just not even going to comment: <pre> <code class="javascript hljs">generateEUID: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++ ) { result += <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor( <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">16</span></span> ).toString( <span class="hljs-number"><span class="hljs-number">16</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre>  Further, when initializing for each element, we push this .generated euid (element's unique id) into .data (), and when we hang up the scroll handlers, we create the namespace <code>.viewport + EUID</code> .  And of course, the destructor, who iterates over the EUID of the set and removes unnecessary handlers, without affecting those that we still need.  In the final version, we obtain: <br><br><div class="spoiler">  <b class="spoiler_title">Code tracker, the final version</b> <div class="spoiler_text"><pre> <code class="javascript hljs">$.fn.viewportTrack = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> callBack, options </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings = $.extend( { <span class="hljs-string"><span class="hljs-string">"threshold"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"allowPartly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"allowMixedStates"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, options ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callBack == <span class="hljs-string"><span class="hljs-string">'string'</span></span> &amp;&amp; callBack == <span class="hljs-string"><span class="hljs-string">'destroy'</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//  return this.each( function() { var $this = this; var _scrollable = $( $this ).parent( ':have-scroll' ); if( !_scrollable.length || typeof $( this ).data( 'euid' ) == 'undefined' ) { return true; //    ,       } //   euid ,     ,      if( _scrollable.get( 0 ).tagName == "BODY" ) { $( window ).unbind( ".viewport" + $( this ).data( 'euid' ) ); $( this ).removeData( 'euid' ); } else { _scrollable.unbind( ".viewport" + $( this ).data( 'euid' ) ); $( this ).removeData( 'euid' ); } } ); } else if( typeof callBack != 'function' ) { $.error( 'Callback function not defined' ); return this; } return this.each( function() { var $this = this; if( typeof $( this ).data( 'euid' ) == 'undefined' ) $( this ).data( 'euid', methods['generateEUID'].call() );// EUID      callBack.apply( $this, [ methods['getState'].apply( $this, [ settings ] ) ] ); var _scrollable = $( $this ).parents( ':have-scroll' ); if( !_scrollable.length ) { callBack.apply( $this, 'inside' ); return true; } if( _scrollable.get( 0 ).tagName == "BODY" ) { $( window ).bind( "scroll.viewport" + $( this ).data( 'euid' ), function() { //  ,    EUID callBack.apply( $this, [ methods['getState'].apply( $this, [ settings ] ) ] ); } ); } else { _scrollable.bind( "scroll.viewport" + $( this ).data( 'euid' ), function() { callBack.apply( $this, [ methods['getState'].apply( $this, [ settings ] ) ] ); } ); } } ); };</span></span></code> </pre></div></div><br><br>  I missed one method, leaving it to the very end, due to the fact that this is a stupid trigger with a cloud of branches, depending on the settings that were passed during initialization.  True, there are a couple of things worth noting: <ul><li>  The logic by which the relative position of the element was determined is duplicated in this method in order not to do unnecessary calculations and samples, but only once to get all the necessary data and work with them, the code is more, but there are 8 less samples. </li><li>  The state is returned as an object with three parameters. <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = { <span class="hljs-string"><span class="hljs-string">"inside"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"posY"</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">"posX"</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> };</code> </pre>  If <code>inside</code> returned with a value of <code>true</code> , then <code>posY</code> and <code>posX</code> remain empty, since  tracked item fully fit in viewport. <br>  Otherwise, the state of the element with respect to each axis is indicated, see the githabe for details. </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Method code ['getState']</b> <div class="spoiler_text"><pre> <code class="javascript hljs">getState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> options </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings = $.extend( { <span class="hljs-string"><span class="hljs-string">"threshold"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"allowPartly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, options ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = { <span class="hljs-string"><span class="hljs-string">"inside"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"posY"</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">"posX"</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = methods[<span class="hljs-string"><span class="hljs-string">'getElementPosition'</span></span>].call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !pos ) { ret.inside = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _above = pos.elemTopBorder - settings.threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _below = pos.viewportHeight &lt; pos.elemBottomBorder + settings.threshold; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _left = pos.elemLeftBorder - settings.threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _right = pos.viewportWidth &lt; pos.elemRightBorder + settings.threshold; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( settings.allowPartly ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _partlyAbove = pos.elemTopBorder - settings.threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pos.elemBottomBorder - settings.threshold &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _partlyBelow = pos.viewportHeight &lt; pos.elemBottomBorder + settings.threshold &amp;&amp; pos.viewportHeight &gt; pos.elemTopBorder + settings.threshold; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _partlyLeft = pos.elemLeftBorder - settings.threshold &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pos.elemRightBorder - settings.threshold &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _partlyRight = pos.viewportWidth &lt; pos.elemRightBorder + settings.threshold &amp;&amp; pos.viewportWidth &gt; pos.elemLeftBorder + settings.threshold; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_above &amp;&amp; !_below &amp;&amp; !_left &amp;&amp; !_right ) { ret.inside = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( settings.allowPartly ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( _partlyAbove &amp;&amp; _partlyBelow ) { ret.posY = <span class="hljs-string"><span class="hljs-string">'exceeds'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( _partlyAbove &amp;&amp; !_partlyBelow ) || ( _partlyBelow &amp;&amp; !_partlyAbove ) ) { ret.posY = _partlyAbove ? <span class="hljs-string"><span class="hljs-string">'partly-above'</span></span> : <span class="hljs-string"><span class="hljs-string">'partly-below'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_above &amp;&amp; !_below ) { ret.posY = <span class="hljs-string"><span class="hljs-string">'inside'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ret.posY = _above ? <span class="hljs-string"><span class="hljs-string">'above'</span></span> : <span class="hljs-string"><span class="hljs-string">'below'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( _partlyLeft &amp;&amp; _partlyRight ) { ret.posX = <span class="hljs-string"><span class="hljs-string">'exceeds'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( _partlyLeft &amp;&amp; !_partlyRight ) || ( _partlyLeft &amp;&amp; !_partlyRight ) ) { ret.posX = _partlyLeft ? <span class="hljs-string"><span class="hljs-string">'partly-above'</span></span> : <span class="hljs-string"><span class="hljs-string">'partly-below'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_left &amp;&amp; !_right ) { ret.posX = <span class="hljs-string"><span class="hljs-string">'inside'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ret.posX = _left ? <span class="hljs-string"><span class="hljs-string">'left'</span></span> : <span class="hljs-string"><span class="hljs-string">'right'</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( _above &amp;&amp; _below ) { ret.posY = <span class="hljs-string"><span class="hljs-string">'exceeds'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_above &amp;&amp; !_below ) { ret.posY = <span class="hljs-string"><span class="hljs-string">'inside'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ret.posY = _above ? <span class="hljs-string"><span class="hljs-string">'above'</span></span> : <span class="hljs-string"><span class="hljs-string">'below'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( _left &amp;&amp; _right ) { ret.posX = <span class="hljs-string"><span class="hljs-string">'exceeds'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_left &amp;&amp; !_right ) { ret.posX = <span class="hljs-string"><span class="hljs-string">'inside'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ret.posX = _left ? <span class="hljs-string"><span class="hljs-string">'left'</span></span> : <span class="hljs-string"><span class="hljs-string">'right'</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br></div></div><br><br>  Fuff, that's all.  Here is such a plugin, I got 301 lines. <br><br><h4>  <b>Links</b> </h4><a name="article_bottom"></a><br>  You can pick up the plugin from my github: <a href="https://github.com/xobotyi/jquery.viewport">https://github.com/xobotyi/jquery.viewport</a> <br>  How to use in the most detailed image is described in readme. <br><br>  I sincerely hope that this article will benefit someone and will tell something new. <br>  For this I will take my leave, with all the code, sleep, and lack of desire to write an article at 4 in the morning. <br><br>  Ps whether to put a daw "training material"? </div><p>Source: <a href="https://habr.com/ru/post/240083/">https://habr.com/ru/post/240083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240071/index.html">HP ProLiant DL360 Gen9 Server - Overview, Test and Outlook</a></li>
<li><a href="../240073/index.html">LuCI moved to github</a></li>
<li><a href="../240075/index.html">Development and debugging of UEFI-drivers on Intel Galileo, part 3: starting hardware debugging</a></li>
<li><a href="../240077/index.html">Mounting wrap. Homemade breadboard</a></li>
<li><a href="../240079/index.html">The largest copyright lobbyists shared their vision for further struggle against digital piracy</a></li>
<li><a href="../240087/index.html">Harvard scientists have learned to grow insulin producing cells on an industrial scale.</a></li>
<li><a href="../240089/index.html">Video and review of the conference OSSDEVCONF-2014</a></li>
<li><a href="../240097/index.html">How to protect your data</a></li>
<li><a href="../240099/index.html">Two in one! Games on GameBoy and Dendy - pocket happiness for the knowledgeable gamer</a></li>
<li><a href="../240101/index.html">Tracker music through the eyes of the developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>