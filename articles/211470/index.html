<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to run a program without an operating system: part 5. Accessing the BIOS from the OS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the very first part of our series ‚ÄúHow to run a program without an operating system‚Äù, we stopped at the fact that we loaded the kernel using GRUB a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to run a program without an operating system: part 5. Accessing the BIOS from the OS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/36a/32a/8fc/36a32a8fc6e4ab4df4168127097a579f.jpg"><br>  In the very <a href="http://habrahabr.ru/company/neobit/blog/173263/">first part of</a> our series ‚ÄúHow to run a program without an operating system‚Äù, we stopped at the fact that we loaded the kernel using GRUB and printed the classic ‚ÄúHello World!‚Äù On the screen.  Now we will show how you can use BIOS interrupts in the OS kernel.  And for starters, let's look at what BIOS interrupts are, what they are used for, and why there are problems with calling them. <br><a name="habracut"></a><br><h4>  Something about interruptions </h4><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">An interrupt</a> is a signal that informs the processor of the occurrence of an event.  Interrupts can be divided into 2 groups: <br>  ‚Ä¢ external interrupts - generated by devices and other processors; <br>  ‚Ä¢ internal interrupts ‚Äî generated by the processor when any exceptional situations occur (for example, dividing by 0 or accessing invalid addresses) or by an int instruction. <br><br>  In general, after an interrupt occurs, the processor must transfer control to the interrupt handler from the table pointed to by the special IDTR register.  Depending on the processor's mode of operation, the table format may differ and upon a call, additional checks for the correctness of the interruption may occur. <br><br>  After turning on the power, the processor starts its operation in a mode very similar to Real Mode.  One of the stages of processor initialization is the transfer of control to the BIOS.  The BIOS tunes some CPU registers, initializes the RAM, checks the POST devices, initializes the underlying hardware, copies the bootloader to the memory, and passes control to it.  One of the BIOS steps is to set up the interrupt handler table, whose address is stored in the <b>IDTR</b> .  This is usually <b>0x0</b> .  In the real mode of the processor (Real Mode), the entry in the interrupt table consists of a pair <b>sel: offset</b> , which contains the address of the interrupt handler.  The BIOS installs its own interrupt handlers to save the operating system from low-level hardware, which may differ from machine to machine. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      BIOS interrupts act as an interface for working with hardware.  For example, the 0x13 interrupt is used to read sectors from disks, the 0x10 interrupt is used to configure video modes.  To call BIOS interrupts, a program running in Real Mode can use an <b>int</b> assembler instruction.  For example, to read a sector from disk, you need to use the instruction <b>int 0x13</b> , with parameters in general-purpose registers. <br><br>  In the real mode of operation, the processor cannot access the memory above a megabyte, and it has no mechanisms for isolating running tasks (except for segmentation).  Therefore, modern operating systems for the x86 platform run in other modes of operation of the processor, such as Protected Mode and Long Mode. <br><br>  In Protected Mode, the interrupt table looks different.  It is still indicated by the <b>IDTR register</b> , but the entry in this table is the <b>Gate Descriptor of</b> one of the 3 possible types (read clause 6.11 of the Intel <a href="http://www.intel.com/Assets/en_US/PDF/manual/253668.pdf">manual</a> ).  The interrupt table must be configured by the operating system, not by the BIOS, therefore, in protected mode it is not possible to use BIOS interrupts.  All work with devices (HDD, CD-ROM, video card ...) falls on the shoulders of the operating system, which uses for this driver.  In Long Mode, the situation is exactly the same, up to the size of the Gate Descriptor. <br><br><h4>  Ways to call BIOS from protected mode </h4><br>  Well, what to do if the OS kernel operating in protected mode still needs to read something from the disk (for example, a hard disk driver), and the driver is not loaded yet?  This can be done in two ways. <br>  1. Configure VirtualMode86 and execute BIOS calls in Protected Mode. <br>  2. Go to RealMode, access the BIOS, go back to Protected Mode. <br><br>  Virtual Mode 86 ( <a href="http://en.wikipedia.org/wiki/Virtual_8086_mode">VM86</a> ) is another processor operating mode in which segment addressing is similar to real mode, but paging the protected mode works.  We will use the second method, since, using a similar technique, we can access the BIOS from 64-bit code (which is performed in LongMode, which does not support switching to VM86).  Let's leave the work with the disk for later, and now we will determine the size of the RAM using the BIOS. <br><br>  Strictly speaking, there is still a third way to call the BIOS from a protected 32nd mode, and that is what we used <a href="http://habrahabr.ru/company/neobit/blog/176707/">in the third part of</a> our series for using VBE.  This is the execution of a 16-bit BIOS code in a 32-bit emulator.  This method is bad because it will be difficult to deliver interrupts generated by external devices to the emulator.  When determining the size of RAM, external devices are not used, since the BIOS has already determined everything at the stage of its loading, and we would have approached this method to perform the task, but still use the 2nd method, since this code will still be useful to us in the subsequent articles. <br><br>  Separately, it should be noted that the method chosen by us is very slow compared to the operation of the driver, as it spends a lot of time switching between CPU modes and does not use technologies such as MMIO and DMA.  In addition, interrupt vectors for all devices must be configured exactly as the BIOS expects, which may not be true if drivers already work for individual devices in the system.  Already running drivers, with such a transfer of control to the BIOS, will lose interrupts, which can lead to problems.  All this means that you can only act in the manner described at the beginning of the OS. <br><br><h4>  We deal with the second method </h4><br>  So, our goal: to determine the size of the RAM by the tables e820, which we get by interrupting the BIOS <b>int 0x15</b> .  The e820 tables are a physical memory card that describes which physical memory ranges are available for use by the operating system.  In the inaccessible regions of physical memory, the main BIOS and the video card BIOS, ACPI tables are stored, some ranges of physical memory are mapped into the memory of devices and their registers.  If you start the resource monitor in Windows 7 and open the ‚Äúmemory‚Äù tab, the ‚Äúreserved equipment‚Äù includes the amount of physical memory covered by the reserved ranges. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f90/220/758/f90220758423058d09d88c14e3a3bb8f.jpg"><br><br>  To get an entry from table E820, you need to write the following values ‚Äã‚Äãto registers: 0 in EBX, 0xE820 in EAX, buffer size (at least 20 bytes) in ECX, 0x534d4150 in EDX, write to pointer to ES: DI buffer.  After the int0x15 interrupt has been called, one entry from the e820 table will be written to the buffer, and the value in EBX will increase by 1. The interrupts must be repeated until the EBX is 0 again, which means the end of the table.  After that, all values ‚Äã‚Äãfrom the table will be in the buffer.  Upon successful completion, the Carry Flag in the Eflags register will be cleared, and the value 'SMAP' will be written into EAX.  A table entry has the following format: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed4/b7d/e79/ed4b7de796be657a29f294d175d1799f.jpg"><br><br>  The type is ‚Äú1‚Äù if physical memory can be used by the memory manager, ‚Äú2‚Äù if memory is reserved for devices or BIOS, ‚Äú3‚Äù or ‚Äú4‚Äù if ACPI is used.  The remaining values ‚Äã‚Äãare reserved, the ranges do not overlap.  Memory card example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b4/883/cb9/9b4883cb93f9e18c89801bce1ca1d852.jpg"><br><br>  Immediately make a reservation that GRUB, which we use as a bootloader, can provide a ready-made physical memory card, but the purpose of this article is to demonstrate accessing the BIOS from protected mode, and not using the capabilities of GRUB. <br><br>  After starting the computer, the CPU operates in RealMode mode, in which the transfer of control to the BIOS occurs.  The BIOS is free to work as it pleases, and can go into protected mode, as Coreboot does, for example.  After completing its work, the BIOS loads into memory and transfers control to the first sector of the highest priority device in accordance with the boot order (at least if it is hdd or the device is emulated as hdd).  The BIOS transfers control, being in RM.  In our case, the load happens with the hdd and the first sector is the MBR, which transfers control to GRUB.  GRUB mainly works in PM, but if necessary, it will turn to hardware (for example, read a sector from a disk) and goes to RM and uses BIOS interrupts.  GRUB transfers control to our kernel in PM.  The figure below shows the described sequence of CPU transitions between modes of operation during the boot process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/07c/31a/33e07c31ad8112f33eaf1ff29bad710d.jpg"><br><br>  To continue the conversation and go directly to the code, you need to make a small theoretical indent towards the protected mode.  The topic is extensive and well covered, so only what we will see in the code will be described here.  The main difference between RM and PM lies in the mechanisms of segment memory addressing.  What is segment memory addressing anyway?  In RM, addresses with a length of 20 bits are used to access memory, but the length of the available registers is limited to 16 bits (because of this, the code is called 16-bit).  Therefore, address pairs are used for addressing, one of which contains the base segment, and the second offset.  The linear address is obtained by adding the offset and the base of the segment shifted to the left by 4. Segmental addressing in RM is shown in the figure below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/536/00b/7a8/53600b7a81eefa3fdef3a17210488be5.jpg"><br><br>  The offset can be stored in any general register.  The base segment is stored in one of the following registers: CS, DS, SS, ES, FS, GS.  These registers are called <b>selectors</b> .  All commands have default selectors.  For PUSH, POP is SS (stack segment), for JUMP, LOOP is CS (code segment), for MOV it is DS (data segment). <br><br>  PM also uses segment addressing memory, but the mechanism has changed a lot.  Now the selector does not store the segment base itself, but refers to a <b>descriptor</b> that is stored in one of the descriptor tables.  The structure of the selector is shown in the figure below (and taken from Intel manuals). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/3e4/740/ef23e4740b15b574db8adbaa1c0049ef.jpg"><br><br>  ‚Ä¢ RPL (Requested Privilege Level) ‚Äîused to share privilege levels in a segment protection mechanism. <br>  ‚Ä¢ TI - indicates the type of the descriptor table in which the desired descriptor is located.  1 - LDT (Local Descriptor Table), 0 - GDT (Global Descriptor Table). <br>  ‚Ä¢ Index - descriptor index in the descriptor table. <br><br>  There are 2 types of descriptor tables - GDT and LDT.  The GDT table is one for the whole system, there may be many LDT tables (for example, its own for each process).  We will use GDT, since in order to use LDT, in any case, we would have to configure GDT.  Descriptors can be divided into 2 groups: system and user.  User descriptors are responsible for the segments.  System descriptors describe processor transitions between privilege levels.  In our code there will be no system descriptors, so we will not talk about them.  The structure of the user descriptor, presented below (also taken from Intel manuals), suggests how long the x86 architecture appeared and how many improvements it had to endure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c6/905/68d/6c690568dedc1332d31ae882562117d6.jpg"><br><br>  A segment descriptor determines the type of segment, size, privilege level required to access it, read, write and execute permissions, and the base of the segment.  Let us examine the structure of the descriptor. <br>  ‚Ä¢ Base Address is the 32-bit address of the first byte of the segment, the field is divided into 3 parts base_0_15, base_16_23, base_24_31. <br>  ‚Ä¢ Segment Limit - segment size in bytes, if the flag is G = 0, or in blocks of 4 Kb, if the flag is G = 1. <br>  ‚Ä¢ G (granularity) - if the flag is set, then Segment Limit is measured in blocks of 4K, otherwise in bytes. <br>  ‚Ä¢ S (descriptor type) - if the flag is set, then the descriptor is user, otherwise system.  In our code, this flag is set for all descriptors. <br>  ‚Ä¢ Type - the interpretation of this field depends on the flag S. For a user segment, there are 2 main options: a code segment and a data segment, this is determined by the most significant bit of the field.  The table below shows all possible combinations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc2/61f/07b/fc261f07b2d5f060253884fa1b8c262c.jpg"><br><br>  The following bits are defined for the data segment: E (expansion-direction), (W) write-enable, (A) accessed.  Bit (W) allows writing to a segment, (E) is used to dynamically expand a stack segment, (A) is a common bit for data and code segments, set to 1 when accessing a segment, be it read, write or execute.  In the case of a code segment, the bit (E) is interpreted as ¬©, and (W) as ¬Æ.  Bit ¬© conforming, cancels part of the security checks when calling the code of this segment from another segment.  Bit ¬Æ read enable allows reading from a code segment.  Write in the code segment in protected mode is impossible. <br><br>  ‚Ä¢ L (64-bit code segment) - set if the segment contains a 64-bit code.  The flag can be set to 1 only for code segments. <br>  ‚Ä¢ AVL (Available and reserved bits) - not used by the processor, the OS can be used. <br>  ‚Ä¢ D / B (default operation size) - determines the width of custom code and data segments.  16 bits, if the flag is set to 0 and 32, if 1 (yes, yes, the 16-bit code in the protected mode also happens). <br>  ‚Ä¢ DPL (descriptor privilege level) ‚Äîdetermines the privilege level of the segment.  It can take values ‚Äã‚Äãfrom 0 to 3, where 0 is the most privileged.  Used to restrict access to a segment. <br><br>  Read more about the descriptor structure in the <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf">Intel System Programming Guide Part 1</a> , in section 3.4.5.  There you can also find a description of how the division of access to segments is arranged in accordance with their level of privileges.  On Habr√© there is a good <a href="http://habrahabr.ru/company/smart_soft/blog/184174/">translation</a> on this topic. <br>  Recall why we all started this ‚Äî we need to trigger a BIOS interrupt from the C code. That is,  you will need from C code to go to code in RM to ASM and then back.  The C code is executed in 32-bit PM.  The transition plan will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ddc/574/e16/ddc574e16ac23918391b8cfee3e5b2df.jpg"><br><br>  Among other things, you need to pass arguments from C code to RM code and results from RM code to C code. <br><br>  <b>!</b>  <b>IMPORTANT!</b>  <b>All further actions can be successfully carried out only after successful completion of all 6 steps from the <a href="http://habrahabr.ru/company/neobit/blog/173263/">first</a> part of the article ‚ÄúHow to run a program without an operating system‚Äù!</b> <br><br>  So, our plan: <br>  1. Set up your own GDT table instead of the one configured by GRUB. <br>  2. Write a wrapper to access the BIOS in C. <br>  3. Add a few common functions. <br>  4. Blind it all and run. <br><br>  Let's get started! <br><br><h4>  Step 1. Initialize GDT </h4><br>  1. Add the <b>bitvisor-1.2 \ core \ desc.h file</b> taken from the BitVisor project to the include folder.  The code can be downloaded <a href="http://sourceforge.net/projects/bitvisor/files/bitvisor/">here</a> .  The file contains the declaration of the user descriptor structure. <br>  2. Add the file <b>descriptor.c</b> with the following contents: <br><br><pre><code class="hljs erlang-repl">#include <span class="hljs-string"><span class="hljs-string">"types.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"desc.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"string.h"</span></span> static void SetSegDesc(struct segdesc *d, u32 limit, u32 base, enum segdesc_type type, enum segdesc_s s, unsigned int dpl, unsigned int p, unsigned int avl, enum segdesc_l l, enum segdesc_d_b d_b) { d-&gt;base_15_0 = base; d-&gt;base_23_16 = base &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; d-&gt;type = type; d-&gt;s = s; d-&gt;dpl = dpl; d-&gt;p = p; d-&gt;avl = avl; d-&gt;l = l; d-&gt;d_b = d_b; d-&gt;base_31_24 = base &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; if (limit &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>xFFFFF) { d-&gt;g = <span class="hljs-number"><span class="hljs-number">0</span></span>; d-&gt;limit_15_0 = limit &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; d-&gt;limit_19_16 = limit &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; } else { d-&gt;g = <span class="hljs-number"><span class="hljs-number">1</span></span>; d-&gt;limit_15_0 = limit &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; d-&gt;limit_19_16 = limit &gt;&gt; <span class="hljs-number"><span class="hljs-number">28</span></span>; } } void SetupDescTables(struct segdesc *GDT_base) { // SEG_SEL_NULL memset(&amp;GDT_base[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(GDT_base[<span class="hljs-number"><span class="hljs-number">0</span></span>])); //  .  <span class="hljs-number"><span class="hljs-number">0</span></span> // SEG_SEL_CODE32 SetSegDesc(&amp;GDT_base[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>xFFFFFFFF, <span class="hljs-number"><span class="hljs-number">0</span></span>x00000000, // <span class="hljs-number"><span class="hljs-number">32</span></span>    SEGDESC_TYPE_EXECREAD_CODE, //   <span class="hljs-number"><span class="hljs-number">0</span></span> SEGDESC_S_CODE_OR_DATA_SEGMENT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, //  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>G <span class="hljs-number"><span class="hljs-number">0</span></span>, SEGDESC_L_16_OR_32, SEGDESC_D_B_32); // SEG_SEL_DATA32 SetSegDesc(&amp;GDT_base[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>xFFFFFFFF, <span class="hljs-number"><span class="hljs-number">0</span></span>x00000000, // <span class="hljs-number"><span class="hljs-number">32</span></span>    SEGDESC_TYPE_RDWR_DATA, //   <span class="hljs-number"><span class="hljs-number">0</span></span> SEGDESC_S_CODE_OR_DATA_SEGMENT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, //  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>G <span class="hljs-number"><span class="hljs-number">0</span></span>, SEGDESC_L_16_OR_32, SEGDESC_D_B_32); // SEG_SEL_CODE16 SetSegDesc(&amp;GDT_base[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x0000FFFF, <span class="hljs-number"><span class="hljs-number">0</span></span>x00000000, // <span class="hljs-number"><span class="hljs-number">16</span></span>    SEGDESC_TYPE_EXECREAD_CODE, //   <span class="hljs-number"><span class="hljs-number">0</span></span> SEGDESC_S_CODE_OR_DATA_SEGMENT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, //  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>G <span class="hljs-number"><span class="hljs-number">0</span></span>, SEGDESC_L_16_OR_32, SEGDESC_D_B_16); // SEG_SEL_DATA16 SetSegDesc(&amp;GDT_base[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x0000FFFF, <span class="hljs-number"><span class="hljs-number">0</span></span>x00000000, // <span class="hljs-number"><span class="hljs-number">16</span></span>    SEGDESC_TYPE_RDWR_DATA, //   <span class="hljs-number"><span class="hljs-number">0</span></span> SEGDESC_S_CODE_OR_DATA_SEGMENT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, //  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>G <span class="hljs-number"><span class="hljs-number">0</span></span>, SEGDESC_L_16_OR_32, SEGDESC_D_B_16); struct descreg gdtr; gdtr.base = (ulong)GDT_base; //     gdtr.limit = <span class="hljs-number"><span class="hljs-number">5</span></span> * sizeof(*GDT_base) - <span class="hljs-number"><span class="hljs-number">1</span></span>; //     - <span class="hljs-number"><span class="hljs-number">1</span></span> __asm__ volatile (<span class="hljs-string"><span class="hljs-string">"lgdt %0"</span></span> // GCC-Inline-Assembly : : <span class="hljs-string"><span class="hljs-string">"m"</span></span> (gdtr)); }</code> </pre> <br><br>  For the operation of the C code, 2 user segments are enough: a 32 bit code segment and a 32 bit data segment.  To go to the 16-bit code, we need two additional segments: 16-bit code and data segments.  The <b>SetupDescTables</b> function generates a GDT table with five descriptors at the <b>* GDT_base</b> address, the first of which is zero, and the remaining 4 correspond to the segments described above.  All segments have a base of 0 and 4G limit.  The first descriptor in GDT should always be zero.  The GDTR register, which points to GDT, is initialized with the lgdt instruction.  To invoke the instruction, an assembler insert with a specific GCC syntax is used.  Assembler inserts have the following structure: <br><br><pre> <code class="hljs pgsql">asm ( assembler <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> : output operands <span class="hljs-comment"><span class="hljs-comment">/* optional */</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> operands <span class="hljs-comment"><span class="hljs-comment">/* optional */</span></span> : list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> clobbered registers <span class="hljs-comment"><span class="hljs-comment">/* optional */</span></span> );</code> </pre><br><br>  The used asm insert is converted to the following code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/703/537/7d4703537783c1609b04785cd404ab5c.jpg"><br><br>  Strictly speaking, in order for the GDT table to be used, the values ‚Äã‚Äãof the corresponding selectors must be loaded into the CS, SS, DS registers.  But at this stage it is not so critical. <br><br>  3. Add a call to <b>SetupDescTables</b> and several declarations in <b>kernel.c</b> .  The result is the following: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screen.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"desc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"callrealmode.h"</span></span></span><span class="hljs-meta"> struct segdesc g_GDT[5]; void SetupDescTables(struct segdesc *GDT_base); void kmain(void) { clear_screen(); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" -- Kernel started! -- \n"</span></span></span><span class="hljs-meta">); SetupDescTables(g_GDT); u64 ram_size = GetAvalibleRAMSize (); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ram_size = %llu(%lluMb)\n"</span></span></span><span class="hljs-meta">, ram_size, ram_size / 0x100000); }</span></span></code> </pre><br><br>  The call to <b>GetAvalibleRAMSize ()</b> returns the size of the RAM in bytes. <br><br><h4>  Step 2. Add some common functions. </h4><br><br>  1. Add the <b>bitvisor-1.2 \ core \ string.s</b> file to the <b>common</b> folder, the <b>bitvisor-1.2 \ core \ longmode.h</b> and <b>bitvisor-1.2 \ include \ core \ string.h</b> <b>files</b> from the <b>BitVisor</b> project to the <b>include folder</b> .  These files contain the implementation of several general purpose functions, such as memcpy and memset.  Content <b>include \ types.h</b> replace with the following: <br><br><pre> <code class="hljs vhdl">#ifndef _TYPES_H #define _TYPES_H #define <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> typedef <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> long size_t; typedef <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> long ulong; typedef <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> char u8; typedef <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> short u16; typedef <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int u32; typedef <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> long long u64; #endif</code> </pre><br><br><h4>  Step 3. Appeal to BIOS </h4><br><br>  1. Add a <b>segment.h</b> file to <b>include</b> , containing selector values ‚Äã‚Äãfor the descriptors defined in the <b>SetupDescTables</b> function. <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#ifndef _SEGMENT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SEGMENT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_SEL_NULL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_SEL_CODE32 (1 * 8) // Index = 1, TI = 0, RPL = 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_SEL_DATA32 (2 * 8) // Index = 2, TI = 0, RPL = 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_SEL_CODE16 (3 * 8) // Index = 3, TI = 0, RPL = 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SEG_SEL_DATA16 (4 * 8) // Index = 4, TI = 0, RPL = 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  and the <b>callrealmode.h</b> file, with the <b>GetRamsize</b> function <b>prototype</b> . <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CALLREALMODE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CALLREALMODE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> u64 GetAvalibleRAMSize(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  2. Add the <b>callrealmode.c</b> file to the root of our project with the following contents: <br><br><pre> <code class="hljs lua">#include <span class="hljs-string"><span class="hljs-string">"printf.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"types.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"string.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"segment.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"callrealmode_asm.h"</span></span> // interrupts <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> paging must be disabled static void callrealmode_Call(struct callrealmode_Data *p_param) { u16 sp16; u32 sp32; // copy <span class="hljs-number"><span class="hljs-number">16</span></span> bit code <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> stack //   memcpy  <span class="hljs-number"><span class="hljs-number">16</span></span>    //  callrealmode_start  callrealmode_end //   CALLREALMODE_OFFSET &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>Mb.   //    ,   RM     //   <span class="hljs-number"><span class="hljs-number">1</span></span>Mb. memcpy ((u8*)CALLREALMODE_OFFSET, &amp;callrealmode_start, &amp;callrealmode_end - &amp;callrealmode_start); //    ,     ,    . //     RM   ,     SP //     sp16 = CALLREALMODE_OFFSET - sizeof(*p_param); //   memcpy     memcpy ((void*)(u32)sp16, p_param, sizeof(*p_param)); __asm__ volatile ( <span class="hljs-string"><span class="hljs-string">"mov %%esp,%0\n"</span></span> //   ESP   sp32 <span class="hljs-string"><span class="hljs-string">"mov %1,%%ds \n"</span></span> //  <span class="hljs-number"><span class="hljs-number">16</span></span>     <span class="hljs-string"><span class="hljs-string">"mov %1,%%es \n"</span></span> //  DS, ES, FS, GS, SS <span class="hljs-string"><span class="hljs-string">"mov %1,%%fs \n"</span></span> // <span class="hljs-string"><span class="hljs-string">"mov %1,%%gs \n"</span></span> // <span class="hljs-string"><span class="hljs-string">"mov %1,%%ss \n"</span></span> // <span class="hljs-string"><span class="hljs-string">"mov %2,%%esp\n"</span></span> //   <span class="hljs-number"><span class="hljs-number">16</span></span>     sp16 <span class="hljs-string"><span class="hljs-string">"pusha \n"</span></span> //     <span class="hljs-string"><span class="hljs-string">"lcall %3,%4 \n"</span></span> //  <span class="hljs-number"><span class="hljs-number">16</span></span>     CS //     CALLREALMODE_OFFSET. //     CS  EIP, //     // lretl    <span class="hljs-number"><span class="hljs-number">32</span></span>   <span class="hljs-string"><span class="hljs-string">"popa \n"</span></span> //      <span class="hljs-string"><span class="hljs-string">"mov %5,%%ds \n"</span></span> //  <span class="hljs-number"><span class="hljs-number">32</span></span>     <span class="hljs-string"><span class="hljs-string">"mov %5,%%es \n"</span></span> //  DS, ES, FS, GS, SS <span class="hljs-string"><span class="hljs-string">"mov %5,%%fs \n"</span></span> // <span class="hljs-string"><span class="hljs-string">"mov %5,%%gs \n"</span></span> // <span class="hljs-string"><span class="hljs-string">"mov %5,%%ss \n"</span></span> // <span class="hljs-string"><span class="hljs-string">"mov %0,%%esp\n"</span></span> //   <span class="hljs-number"><span class="hljs-number">32</span></span>  ,  //     sp32 : <span class="hljs-string"><span class="hljs-string">"=&amp;a"</span></span> (sp32) // %<span class="hljs-number"><span class="hljs-number">0</span></span> ‚Äì Input : <span class="hljs-string"><span class="hljs-string">"b"</span></span> ((u32)SEG_SEL_DATA16) // %<span class="hljs-number"><span class="hljs-number">1</span></span> - Output , <span class="hljs-string"><span class="hljs-string">"c"</span></span> ((u32)sp16) // %<span class="hljs-number"><span class="hljs-number">2</span></span> - Output , <span class="hljs-string"><span class="hljs-string">"i"</span></span> ((u32)SEG_SEL_CODE16) // %<span class="hljs-number"><span class="hljs-number">3</span></span> - Output , <span class="hljs-string"><span class="hljs-string">"i"</span></span> (CALLREALMODE_OFFSET) // %<span class="hljs-number"><span class="hljs-number">4</span></span> - Output , <span class="hljs-string"><span class="hljs-string">"d"</span></span> ((u32)SEG_SEL_DATA32) // %<span class="hljs-number"><span class="hljs-number">5</span></span> - Output ); //      <span class="hljs-number"><span class="hljs-number">16</span></span>    p_param memcpy (p_param, (void*)(u32)sp16, sizeof(*p_param)); } u64 GetAvalibleRAMSize() { struct callrealmode_Data param; // ,     //    RM,    u64 avalible_ram_sz = <span class="hljs-number"><span class="hljs-number">0</span></span>; param.func = CALLREALMODE_FUNC_GETSYSMEMMAP; param.getsysmemmap.next_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { param.getsysmemmap.num = param.getsysmemmap.next_num; callrealmode_Call(¬∂m); // int <span class="hljs-number"><span class="hljs-number">0x15</span></span>,  EBX = param.getsysmemmap.num // EAX = <span class="hljs-number"><span class="hljs-number">0xE820</span></span>, EDX = <span class="hljs-number"><span class="hljs-number">0x534d4150</span></span>, ECX = <span class="hljs-number"><span class="hljs-number">20</span></span> // ES:DI = ¬∂m.getsysmemmap.base //   EBX  // param.getsysmemmap.next_num = EBX //        SYSMEMMAP_TYPE_AVAILABLE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SYSMEMMAP_TYPE_AVAILABLE == param.getsysmemmap.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { avalible_ram_sz += param.getsysmemmap.<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; } printf(<span class="hljs-string"><span class="hljs-string">"n 0x%08X nn 0x%08X b 0x%08llX l 0x%08llX(%lldMb) t 0x%08X\n"</span></span>, param.getsysmemmap.num, param.getsysmemmap.next_num, param.getsysmemmap.base, param.getsysmemmap.<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>, param.getsysmemmap.<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> / <span class="hljs-number"><span class="hljs-number">0x100000</span></span>, param.getsysmemmap.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (param.getsysmemmap.next_num); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> avalible_ram_sz; }</code> </pre><br><br>  We have reached the most interesting!  There are 2 functions in this code: <b>GetRamsize</b> and <b>callrealmode_Call</b> .  The <b>GetRamsize</b> function forms the <b>param callrealmode_Data</b> structure to call the <b>callrealmode_Call</b> .  The <b>callrealmode_Call</b> function directly goes to the 16-bit code on the assembler.  On its basis, you can write other functions that access the BIOS, for example, the sector read from disk function.  The only condition is to use the <b>callrealmode_Data</b> structure. <br><br>  The <b>GetRamsize</b> function implements in its logic a mechanism for obtaining a physical memory card through an int0x15 interrupt, repeatedly calling the <b>callrealmode_Call</b> function (analogous to int0x15) until <b>param.getsysmemap.next_num</b> (also EBX) becomes zero.  The <b>callrealmode_Call</b> function uses two assembler tags on the assembler tags <b>callrealmode_start</b> and <b>callrealmode_end</b> to copy the entire 16-bit code to the lower megabyte at <b>CALLREALMODE_OFFSET = 0x5000</b> .  The address is selected so that when copying, do not rub the BIOS structures.  Assembler insertion is of the greatest interest in the function, it is well commented, so we will just show what it has become in the compiled form: <br><br><img src="http://habrastorage.org/getpro/habr/post_images/d25/872/671/d25872671c51a779c6bef119c846c975.jpg"><br><br>  3. Add the <b>callrealmode_asm.h</b> file to the <b>include</b> folder, the file can be taken <a href="">here</a> , and the <b>callrealmode_asm.s</b> file to the source root, which can be taken <a href="">here</a> .  The first file contains the definitions of structures used in <b>callrealmode.c</b> .  The second file contains a 16-bit code for the assembler, in which you go to RM, call BIOS, return to PM and then to code C. The code is commented in detail and can be dealt with.  It should be noted that the <b>protection_off</b> and <b>protection_on</b> procedures used to transition between PM and RM are greatly simplified.  They forget about the part of the registers, such as CR3, some MSR, the values ‚Äã‚Äãof which need to be saved and restored, as it happens with GDTR and IDTR.  A more complete implementation of these functions can be found in the BitVisor project, namely, in <b>bitvisor-1.2 \ core \ callrealmode_asm.s</b> . <br><br><h4>  Step 4. Last improvements and launch </h4><br><br>  1. Make changes to the makefile.  Replace <br><br><pre> <code class="hljs tex">OBJFILES = <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>loader.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/printf.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/screen.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>kernel.o</code> </pre><br><br>  on <br><br><pre> <code class="hljs tex">OBJFILES = <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>loader.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/printf.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/screen.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/string.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>kernel.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>callrealmode.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>callrealmode_asm.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>descriptor.o</code> </pre><br><br>  And the line <br><br><pre> <code class="hljs mel">as -o $@ $&lt;</code> </pre><br><br>  on <br><br><pre> <code class="hljs ruby">as -I <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> -o $@ $&lt;</code> </pre><br><br>  2. Reconstruct the project: <br><br><pre> <code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span> rebuild sudo <span class="hljs-built_in"><span class="hljs-built_in">make</span></span> image</code> </pre><br><br>  3. Run with the option ‚Äú‚Äìm‚Äù, which allows you to explicitly specify the size of RAM.  You should have something like the following: <br><br><pre> <code class="hljs pgsql">sudo qemu-<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>-i386 -hda hdd.img ‚Äìm <span class="hljs-number"><span class="hljs-number">123</span></span></code> </pre><br><img src="http://habrastorage.org/getpro/habr/post_images/951/834/c57/951834c57ee973d1e28536942e944259.jpg"><br><br>  The program prints all available memory ranges.  As in the previous parts, you can make the dd image of hdd.img on a flash drive and check the code on a real hardware by booting from it. <br><br><h4>  Future plans </h4><br>  As a result, we received a mechanism that allows accessing the BIOS from the code on C. In addition, the theoretical part concerning the operation of the protected mode was affected.  In the future, this article can be used as a starting point to demonstrate how to work with the FAT32 file system, but more on that next time! <br><br>  Link to the following cycle article: <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/203706/">part 6. Support for working with disks with the FAT file system</a></b> " </div><p>Source: <a href="https://habr.com/ru/post/211470/">https://habr.com/ru/post/211470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211460/index.html">Satya Nadella: Microsoft's new CEO</a></li>
<li><a href="../211462/index.html">FlightCar: peer-to-peer car exchange and the fight against bureaucrats</a></li>
<li><a href="../211464/index.html">Testing Digium phones with Asterisk and setting up Smart BLF</a></li>
<li><a href="../211466/index.html">A simple Python script to learn English words or why I don‚Äôt use flashcards</a></li>
<li><a href="../211468/index.html">VLC stereo player</a></li>
<li><a href="../211472/index.html">Basics of creating a 2D character in Unity 3D 4.3. Part 1: character preparation and animation of rest</a></li>
<li><a href="../211474/index.html">The easiest cross-platform server with ssl support</a></li>
<li><a href="../211476/index.html">About liberties in the links or the simplest messaging</a></li>
<li><a href="../211478/index.html">Experience of implementing caching in a small project with a strong social component</a></li>
<li><a href="../211480/index.html">Playing MIDI sounds in JAVA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>