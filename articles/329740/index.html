<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mock dependency in node.js applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mocks, fakes, and stubs are the three pillars of unit testing. Of course everyone knows what it is, how to salt and when to eat. I honestly thought so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mock dependency in node.js applications</h1><div class="post__text post__text-html js-mediator-article"><p>  Mocks, fakes, and stubs are the three pillars of unit testing.  Of course everyone knows what it is, how to salt and when to eat.  I honestly thought so too, until I was confronted with reality, under which I had to bend a little. </p><br><p>  It all started very simply - I changed my place of work, and the first thing I saw in the new code base was the tests, there were a little more than code.  And in the midst of these tests was a strange construction </p><br><pre><code class="javascript hljs">Component = proxyquire.noCallThru().load(<span class="hljs-string"><span class="hljs-string">'../Component'</span></span>, { <span class="hljs-string"><span class="hljs-string">'../../core/selectors/common'</span></span>: { getData } }).default;</code> </pre> <a name="habracut"></a><br><p>  For reference: </p><br><blockquote>  proxyquire is one of the most popular, and one of the oldest libraries for addicting.  In addition to it, inject-loader, rewire, mockery and others are now well known.  By "old" is meant that it is designed for the "old" node.js code.  No es6 imports. </blockquote><p>  For those who are in the tank, and do not fully understand what is happening here - everything is very simple.  Proxyquire will load us with a modified ../Component, in which one of the imports will be blocked by our stub. </p><br><p>  What for?  This is a great way to make a unit test a little more unit, reducing the number of uncontrolled external dependencies to zero.  Or simply to facilitate testing temporarily removing complex or unnecessary logic from the application. </p><br><p>  And everything would be fine, only this particular code did not work.  There was an error in the file name, it was necessary to shine one more directory upwards.  And the mistake was made for an even more prosaic reason - the project itself used webpack-alias, addressing all files from the root, and the proxyquire worked with the files after passing the babel, where all the paths were relative. </p><br><p>  Imagine that you have a code </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'something/else'</span></span>;</code> </pre> <br><p>  It seems to be very simple and understandable, only something is actually something2.default, and the file itself can be anything you like - Babel contains a lot of magic. </p><br><p>  That is how this epic began.  With attempts to add support for aliases in proxyquire. </p><br><h1 id="1-reshenie-1-pervaya-vstrecha">  1. Decision number 1.  First meeting </h1><br><p>  The first solution that came to mind was to add a little brain to the old proxyquire.  His problem is generally <a href="">very simple.</a> </p><br><pre> <code class="javascript hljs">Proxyquire.prototype._require = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, stubs, path</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶. if (hasOwnProperty.call(stubs, path)) { var stub = stubs[path];</span></span></code> </pre> <br><p>  It just needs an exact match between the name of the plug-in and the entries in the list for overload. </p><br><blockquote>  ./foo, ./foo.js, ../common/foo - this may be one file, but three different lines. </blockquote><p>  In 5 minutes, some brains were added to this place, and after another 5 minutes <a href="https://github.com/thlorenz/proxyquire/pull/148">one more PR</a> on the githaba was added.  After another 5 minutes, he was mercilessly closed, asking not to add unnecessary brains here, but to find another place for them. </p><br><h1 id="2-reshenie-2-nastoyaschie-geroi-vsegda-idut-v-obhod">  2. Decision number 2.  Real heroes always go around </h1><br><p>  In principle, not only the guys from Proxyquire were not happy with the decision.  I received a couple of suggestions from the immediate environment for alternative solutions to the problem. </p><br><p>  In short, the meaning was simple - it is enough to write a simple function that creates fileName2 from a certain fileName1, so that the first is with an alias, and the second is already in the ‚Äúcorrect‚Äù form for proxyquire. </p><br><p>  Do not try to change the proxyquire itself, but write something like </p><br><pre> <code class="javascript hljs">proxyquire.load(<span class="hljs-string"><span class="hljs-string">'../Component'</span></span>, addSomeMagic({ <span class="hljs-string"><span class="hljs-string">'something/with/alias'</span></span>:{} }))</code> </pre> <br><p>  so that the correct names come to the proxyquire itself, without aliases, but relative to the source file. </p><br><p>  Here it is necessary to dwell on the little magic of proxyquire.  Almost nobody wondered why it works. </p><br><pre> <code class="javascript hljs">Component = proxyquire.noCallThru().load(<span class="hljs-string"><span class="hljs-string">'../Component'</span></span>, {</code> </pre> <br><p>  Where does proxyquire know the current directory and technically can download a file relative to it?  And why in the tests <em>you need to</em> connect the proxyquire directly, or nothing will not work? </p><br><p>  The answer is simple - proxyquire uses the information that node.js passes to it through the variable module.  The module.parent stores information about who <em>first</em> opened this file.  It only remains to remember to <a href="">erase</a> yourself <a href="">from the cache of the modular system</a> , so that each time was like ... the first time. </p><br><p>  In general, developing a solution that would not require proxyquire modifications introduced me to many of the node.js news. </p><br><p>  As a result, I could not do anything - a normal solution required modifications to the source library.  Dead end. </p><br><h1 id="3-reshenie-3-mir-ne-stoit-na-meste">  3. Decision number 3.  The world does not stand still </h1><br><p>  In parallel, the work was in full swing.  And, in trying to make my life a little easier, I tried to improve the original proxyquire, because it was difficult to refuse to use it.  I again began to generate pull requests. </p><br><ul><li>  <a href="https://github.com/thlorenz/proxyquire/pull/163">The first of them</a> , which in principle somehow allowed to expand the library (tritely included back inheritance), was unexpectedly quickly established. </li><li>  <a href="https://github.com/thlorenz/proxyquire/pull/165">The second one</a> , which protected ‚ÄúnonProjectFiles‚Äù from erasing from the cache, was also smartly closed. </li><li>  <a href="https://github.com/thlorenz/proxyquire/pull/164">The third</a> , which added the so-called ‚Äúisolation mode‚Äù, when it was required that either all stubs were used (protects against errors in their names), or all dependencies were closed (the ideal unit test in vacuum), has been hanging without movement for two weeks already :( </li></ul><br><p>  In parallel with this, in order to test solutions in practice and to prove their effectiveness in general, work was carried out on </p><br><ul><li>  <a href="https://github.com/theKashey/proxyquire">proxyqure-2</a> is a personal fork of the source library in which just all the desired fixes are kept, </li><li>  <a href="https://github.com/theKashey/proxyquire-webpack-alias">proxyquire-webpack-alias</a> - a drop-in replacement for proxyquire, with full support for webpack aliases, without which life is not sweet to me.  One thing is bad - for my work, my fork is required above. </li><li>  <a href="https://github.com/theKashey/resolveQuire">resolveQuire</a> is the same library from solution No. 2, which I nevertheless completed to the end, and which can work on the original proxyquire, and which, in spite of its ‚Äúfunctional‚Äù beauty, still loses to the top two solutions in some moments. </li></ul><br><p>  IMHO, I can both recommend you to use any of this list instead of proxyquire, and just get acquainted with the differences in implementation, for a better understanding of the issue. </p><br><h1 id="4-retrospektiva">  4. Retrospective </h1><br><p>  As soon as I defended my version before my colleagues, and at the same time I cured not only my own, but <a href="https://github.com/theKashey/proxyquire-webpack-alias">also their long-standing pain</a> , the question arose - what next?  Although it is better to ask - what before? </p><br><p>  I tried to remember how we mocked dependencies in my former place of work.  It was difficult because they did not moss.  And in general, a survey of the delta of the surroundings showed a very simple picture of the world. </p><br><blockquote>  No one is mocking.  sinon, fetch-mock is not considered, it is not interception of dependencies, but local or global variables. </blockquote><p>  In normal people - normal DI. </p><br><p>  Then I tried to remember how it was possible at all to get wet dependencies in the environment of js code execution at my former place of work, where I spent the best years of my youth, </p><br><ul><li>  modular system <a href="https://github.com/ymaps/modules">ym</a> and <a href="https://github.com/yandex/ymb">collector ymb</a> . </li></ul><br><p>  For those who are not familiar with this very interesting CommonJS / AMD compatible solution, originally from Yandex.Maps, there are a <a href="https://www.slideshare.net/yandex/api-41873486">couple of</a> <a href="http://2013.happydev.ru/report/21.html">presentations</a> about it. </p><br><p>  In general, everything was very simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     module.define('a',['b'], (provide,b) =&gt; {}); //   ,     module.require('a');</span></span></code> </pre> <br><p>  And if you need to block the dependence </p><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.define(<span class="hljs-string"><span class="hljs-string">'b'</span></span>,[], (provide) =&gt; {}); <span class="hljs-comment"><span class="hljs-comment">//   ,     module.define('a',['b'], (provide,b) =&gt; {}); //   ,   ,    module.require('a');</span></span></code> </pre> <br><p>  Simple, and you can even say - naturally. </p><br><p>  How do different mocking solutions work on the modular system native to node.js? </p><br><ul><li>  as <a href="https://github.com/plasticine/inject-loader">inject-loader</a> is a webpack downloader that physically changes the source file as required.  (+ <a href="https://github.com/jhnns/rewire">rewire</a> ) </li><li>  as <a href="https://github.com/mfncooper/mockery">mockery</a> , through Module._load overload.  The very first system method, which <code></code> immediately after require. </li><li>  like <a href="https://github.com/thlorenz/proxyquire">proxyquire</a> , through the overload of the require.extensions handlers.  Technically the lowest level. </li></ul><br><p>  The difference is very simple: </p><br><ul><li>  inject-loader produces a real, but slightly different file.  No node.js patches </li><li>  mockery works ‚Äúso high‚Äù that the result of its work is not cached. </li><li>  but the proxyquire works below the cache. <br>  If you lock the file at the beginning, and then request it again, you will receive your message.  To be treated through noPreserveCache, but who will guess about it? </li></ul><br><p>  And everywhere there are some nuances, implementations that complicate life a little: </p><br><ul><li>  inject-loader - works only for direct dependencies. </li><li>  mockery - every time you rub the entire cache, which has a detrimental effect on speed. </li><li>  proxyquire - contains a lot of surprises. </li></ul><br><h1 id="5-finalnoe-reshenie">  5. Final decision </h1><br><p>  So - I had my own proxyquire, knowledge of dozens of other libraries, analysis of the problem from different sides and a good understanding of the technical problem.  The goal was simple - one ring to rule them all. </p><br><p>  As the original version, the most satisfying feeling of beauty was taken by <a href="https://github.com/mfncooper/mockery">mockery</a> . <br>  Why: </p><br><ul><li>  separation of the definition of interceptions and interception itself.  registerMock / enable. </li><li>  presence of isolation mode.  warnOnUnregistered / registerAllowable </li><li>  availability of replacement mode.  registerAllowable </li></ul><br><p>  The result was the library <a href="https://github.com/theKashey/rewiremock">rewiremock</a> , which satisfies all my Wishlist, and from the box can solve all problems. </p><br><pre> <code class="hljs sql">import rewiremock from 'rewiremock'; ... // totaly mock `fs` <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> your stub rewiremock(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) .with({ readFile: yourFunction }); // <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">path</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> other <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> rewiremock(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) .by(<span class="hljs-string"><span class="hljs-string">'path-mock'</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ES6 <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> rewiremock(<span class="hljs-string"><span class="hljs-string">'reactComponent'</span></span>) .withDefault(MockedComponent) // <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> part <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> <span class="hljs-keyword"><span class="hljs-keyword">library</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">keep</span></span> the rest rewiremock(<span class="hljs-string"><span class="hljs-string">'someLibrary'</span></span>) .callThought() .with({ onlyOneMethod }) ‚Ä¶ rewiremock.enable(); rewiremock.isolation(); rewiremock.passBy(/node_modules/); // <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">native</span></span> require const <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = require(<span class="hljs-string"><span class="hljs-string">'../core/somemodule'</span></span>); // or add some magic‚Ä¶. const module = require(rewiremock.resolve('core/module'));</code> </pre> <br><p>  It allows you to define mocks in separate files, cleverly cuts cache only for overlapped files (and the files that use them), supports RegEx in the passBy isolation setup, has an extremely simple api and will always work as required. </p><br><p>  The whole secret is in the plugins that allow you to control the behavior of the library in the right places. </p><br><p>  I think you shouldn‚Äôt describe the implementation details, everyone can dig into the code or the tests themselves, and at the same time express anything at all through comments. <br>  Or pullrequests, I promise to listen. </p><br><p>  ‚Üí <a href="https://github.com/theKashey/rewiremock">https://github.com/theKashey/rewiremock</a> </p><br><p>  This is how one small splinter, simply not accepting the ‚Äúcrookedness‚Äù of an actively used tool, led to the discovery of micronish of mocks, a much deeper understanding of the issue, to the 4th new libraries.  And maybe to a little bit better world. </p><br><blockquote>  PS: There are no complaints about the proxyquire authors.  Why?  <a href="https://habrahabr.ru/post/328412/">https://habrahabr.ru/post/328412/</a> </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329740/">https://habr.com/ru/post/329740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329730/index.html">"Confrontation" PHDays or what we were called the "All-seeing Eye"</a></li>
<li><a href="../329732/index.html">Innopolis and the slow pursuit of the silicon valleys</a></li>
<li><a href="../329734/index.html">Cisco CloudCenter - Any Application. Any Cloud. One platform</a></li>
<li><a href="../329736/index.html">Apache Cassandra + Apache Ignite - how to combine the best</a></li>
<li><a href="../329738/index.html">Chronobank: we sell time, we ‚Äúbuy‚Äù people</a></li>
<li><a href="../329744/index.html">Dumb ways to die, or why data centers ‚Äúfall‚Äù</a></li>
<li><a href="../329748/index.html">UK plans to ban end-to-end encryption</a></li>
<li><a href="../329752/index.html">The first to close the company where there are many tasks. YouGile project management system usage statistics</a></li>
<li><a href="../329754/index.html">How to tell what Agile is at the factory? Top 5 Most Popular Agile Practices</a></li>
<li><a href="../329756/index.html">Anonymity in Tor: what not to do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>