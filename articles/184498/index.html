<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedded language for .NET, or as I argued Eric Lippert</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 It happens that an obsession sits so firmly in your head that you return to it again and again for many years. Trying to approach the probl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedded language for .NET, or as I argued Eric Lippert</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  It happens that an obsession sits so firmly in your head that you return to it again and again for many years.  Trying to approach the problem on the other hand, to take advantage of new knowledge, or just to start it all over again with a clean slate - and so on until the question is settled once and for all.  For me, programming languages ‚Äã‚Äãhave become such an idea.  The very fact that one program allows you to create other programs, in my eyes, endowed it with incomprehensible fractal beauty.  Writing such a program yourself was only a matter of time. <br><br><a name="habracut"></a><br><br>  For the first time, the time has come after the second course.  I was sure that the acquired knowledge of the C language would be enough for me to write the compiler, the virtual machine, and the entire standard library to it alone.  The idea was elegant and breathed the romance of youthful maximalism, but instead the result of two years of diligent work was a monstrous thing.  Even in spite of the fact that the virtual machine showed signs of life and was able to execute fairly simple scripts in a pseudo-assembler, which helped write <a href="https://habrahabr.ru/users/fornever/" class="user_link">fornever</a> comrade, the project was soon abandoned.  Instead, it was decided to write a language for the .NET platform in order to get free garbage collection, jit-compiler and all the delights of a huge class library.  The compiler was implemented in just six months, the source code was <a href="http://mirelle.codeplex.com/">uploaded to CodePlex</a> , and with it I successfully defended my diploma. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, something was still missing.  With all its advantages, the language developed for the diploma demanded an explicit declaration of all types and functions, had no support for generics, could not create anonymous functions, and indeed the scope of its application was unclear.  The decision to invent another bike came a year later, when I finished the <a href="http://habrahabr.ru/post/164969/">game for Windows Phone</a> and began to think about what to do next.  The following requirements were made for the new language: <br><br><ul><li>  Interact with any available .NET types without explicit import </li><li>  Generic support </li><li>  Support for anonymous functions and closures </li><li>  The presence of at least some practical value </li></ul><br>  The aforementioned <a href="https://habrahabr.ru/users/fornever/" class="user_link">fornever</a> expressed a desire to participate, and the work began to boil.  He took an active part in creating the design of the language and wrote the parser on F #, and I took up the description of the syntax tree and internal infrastructure. <br><br>  Further in the article I will tell about what happened as a result, what pitfalls met on the way, and why the article has such a yellow title. <br><br><h4>  Who needs another bike? </h4><br>  Almost three years ago, in one of the topics on Habr√©, we found out that there are <a href="http://bash.im/quote/408222">still more than 2500</a> programming languages ‚Äã‚Äãin the world.  Why would anyone need another one?  What in it can be anything that is not in others? <br><br>  The stunning success of JavaScript and Lua was the reason to make the language embedded, with an emphasis on integration with host applications under .NET.  Hence the name of the project - <b>LENS</b> - short for <b>Language for Embeddable .NET Scripting</b> .  By "integration" is meant the ability to declare a type or function in a script, as well as the direct exchange of <i>objects</i> between external and embedded programs at runtime.  For example, like this: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-string"><span class="hljs-string">"a = 1 + 2"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compiler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LensCompiler(); compiler.RegisterProperty(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, () =&gt; a, newA =&gt; a = newA); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fx = compiler.Compile(source); fx(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Success: {0}"</span></span>, a); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (LensCompilerException ex) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Error: {0}"</span></span>, ex.FullMessage); } }</code> </pre> <br>  As you can see from the example, it is very easy to connect LENS support: just add the assembly to the project's Reference, create an instance and feed the source code to it.  All the "magic" is in the <code>RegisterProperty</code> method - with its help, any value from the host program can be available in the script for both reading and writing.  For types and functions, there are methods <code>RegisterType</code> and <code>RegisterFunction</code> respectively. <br><br><h4>  Language features </h4><br>  In terms of syntax, LENS learned a lot from Python and F #.  For ten years of working with C-like languages, the semicolon and curly brackets have been set on edge, so here the expressions end with a line break, and the blocks are indented. <br><br><h5>  Base types </h5><br>  Base types are <code>bool</code> , <code>int</code> , <code>double</code> and <code>string</code> .  Constants of these types are written the same way as in C #. <br><br><h5>  Variable declaration </h5><br>  Variables are declared using the <code>var</code> and <code>let</code> keywords.  The first declares the variable being changed, the second is a read-only variable. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span></code> </pre><br><h5>  Control structures </h5><br>  The condition is written using the <code>if</code> block, cycles - using <code>while</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(a &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) print <span class="hljs-string"><span class="hljs-string">"{0} is even"</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print <span class="hljs-string"><span class="hljs-string">"oops, {0} is odd"</span></span> a a = a + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Control constructs <i>return value</i> .  This means that <code>if</code> can also be used on the right side of the assignment sign: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> description = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(age &lt; <span class="hljs-number"><span class="hljs-number">21</span></span>) <span class="hljs-string"><span class="hljs-string">"child"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"grown-up"</span></span></code> </pre><br><h5>  Functions </h5><br>  As can be seen from the example just above, the function call <code>print</code> performed in a functional style: first the name of the function or delegate object, followed by arguments separated by spaces.  If you need to pass an expression as an argument that is more complex than a literal or a variable name, it is taken into brackets. <br><br><pre> <code class="cs hljs">print <span class="hljs-string"><span class="hljs-string">"test"</span></span> print abc print <span class="hljs-string"><span class="hljs-string">"result is: "</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  To call a function without parameters, a pair of empty brackets is used.  The fact is that in the functional paradigm there is no such thing as a ‚Äúfunction without parameters‚Äù.  Tru functionals prefer to operate with <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">pure functions</a> only, and a pure function without arguments is essentially a constant.  The pair of empty brackets in this case is a <code>unit</code> literal (synonymous with <code>void</code> ), which means <i>no</i> arguments.  Similarly, the constructor without parameters is called. <br><br>  The function declaration begins with the <code>fun</code> keyword: <br><br><pre> <code class="cs hljs">fun launch of <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> max:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> name:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(x &lt; max) println <span class="hljs-string"><span class="hljs-string">"{0}..."</span></span> x x = x - <span class="hljs-number"><span class="hljs-number">1</span></span> print <span class="hljs-string"><span class="hljs-string">"Rocket {0} name is launching!"</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rocket () rocket.Success countdown <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  There is no <code>return</code> keyword in LENS.  The return value of the function is its last expression.  If the function should not return anything, but the last expression is of some type, the already familiar literal <code>()</code> .  The keywords <code>break</code> and <code>continue</code> also not provided. <br><br>  In the version that we are working on at the moment, the function can be automatically made <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">memorable</a> .  To do this, use the <code>pure</code> keyword before the function description.  Memoizable functions cache their values ‚Äã‚Äãin the dictionary: if a function has already been called once with such a set of parameters, its value will be obtained from this dictionary, and not re-calculated: <br><br><pre> <code class="cs hljs">pure fun <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> of <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> -&gt; print <span class="hljs-string"><span class="hljs-string">"calculating..."</span></span> x + y <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// output add 2 3 // output add 2 3 // no output!</span></span></code> </pre><br><h5>  User structures and algebraic types </h5><br>  Using the <code>record</code> keyword, you can describe the structure and the list of its fields. <br><br><pre> <code class="cs hljs">record Point X : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zero = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> one = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Algebraic types are declared by the <code>type</code> keyword and a list of options that this type can accept.  A variant may also have a label of any type: <br><br><pre> <code class="cs hljs">type Card Ace King Queen Jack ValueCard of <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> king = King <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ten = ValueCard <span class="hljs-number"><span class="hljs-number">10</span></span> print (ten <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Card) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  For structures, a default constructor and a constructor are created, initializing all fields at once.  Also, for the built-in types, the <code>Equals</code> and <code>GetHashCode</code> methods are automatically created, allowing them to be used as keys in dictionaries. <br><br><h5>  Containers </h5><br>  To initialize frequently used containers, use the special syntax of the <code>new</code> operator: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [[ <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-string"><span class="hljs-string">"world"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tuple = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-number"><span class="hljs-number">42.0</span></span>; <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dict = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { <span class="hljs-string"><span class="hljs-string">"a"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-string"><span class="hljs-string">"b"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  For containers, the most appropriate generic type is automatically displayed.  For example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3.3</span></span>] <span class="hljs-comment"><span class="hljs-comment">// double[] let b = new [King; Queen] // Card[] let c = new [1; true; "hello"] // object[]</span></span></code> </pre><br><h5>  Extension methods </h5><br>  If the corresponding flag is not disabled in the settings, the compiler will also look for suitable extension methods: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Enumerable::Range <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a.Product ()</code> </pre><br>  Using a few ingenious syntax is supported LINQ: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oddSquareSum = Enumerable::Range <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> |&gt; Where ((x:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) -&gt; x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) |&gt; Select ((x:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) -&gt; x ** <span class="hljs-number"><span class="hljs-number">2</span></span>) |&gt; Sum ()</code> </pre><br><h5>  Besides </h5><br>  The compiler has implemented many more interesting things: <br><br><ul><li>  Constant expressions are evaluated at compile time </li><li>  Overrides are supported </li><li>  Classical exception handling in the form of try \ catch is supported. </li><li>  The generated assembly can be saved in .exe if nothing is imported into it. </li><li>  The functions described in the code can be used as extension-methods. </li></ul><br><h4>  So what about Lippert? </h4><br>  Many of those who have read the article already languishing to here for sure are waiting - where is the promised drama?  I remember, I remember, but first a lyrical digression. <br><br>  The compiler backend is the wonderful <a href="http://msdn.microsoft.com/ru-ru/library/system.reflection.emit.aspx">Reflection.Emit</a> library, part of the .NET Framework.  It allows you to create types, methods, fields, and other entities on the fly, and the method code is described using <a href="http://ru.wikipedia.org/wiki/Common_Intermediate_Language">MSIL commands</a> .  However, along with ample opportunities, it has a fair amount of annoying pitfalls. <br><br>  The first problem I encountered was the inability to inspect the types being created: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intMethods = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>).GetMethods(); <span class="hljs-comment"><span class="hljs-comment">//   var myType = ModuleBuilder.DefineType("MyType"); myType.DefineMethod("Test", MethodAttributes.Public); myType.GetMethods(); // NotSupportedException</span></span></code> </pre><br>  On stackoverflow, I was <a href="http://stackoverflow.com/questions/14173863/type-getmethod-alternative-for-typebuilder">clearly explained</a> that storing the list of created methods, as well as searching through them, would have to be handled.  Laborious, but not difficult. <br><br>  But further - more. <br><br>  It turned out that it is impossible to inspect not only created types, but also <i>built-in generic types that use the created ones as parameters</i> !  Here is an example of a class, an attempt to create which on Reflection.Emit will cause a problem: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;A&gt; Values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;A&gt;(); }</code> </pre><br>  It turns out a vicious circle: you can get a <code>List&lt;A&gt;</code> type constructor only when the assembly is already finalized and is no longer needed. <br><br>  My <a href="http://stackoverflow.com/questions/15646881/reflection-generated-and-generic-types">next question on Stackoverflow was</a> answered by John Skit (author of the book <a href="http://www.manning.com/skeet2/">C # in Depth</a> ) and Eric Lippert (until recently the <i>lead developer of</i> C #).  Eric's verdict was disappointing and irrevocable: <br><br><blockquote>  <b>Reflection.Emit is a real compiler</b> .  If you‚Äôre not in the least <br><br>  <i>Reflection.Emit is too weak to build a real compiler on it.</i>  <i>It is suitable for ‚Äútoy‚Äù compilation tasks, such as creating dynamic calls or expression trees in LINQ queries, but it will quickly stop being able to solve the problems of a real compiler.</i> <br></blockquote><br>  According to Eric, it would be more correct to rewrite the compiler using <a href="http://research.microsoft.com/en-us/projects/cci/">Common Compiler Infrastructure</a> , but I did not even consider this option.  The first decision that came to mind was to exclude from the language the possibility of declaring one's own types, but this would be unsporting.  The instinct prompted that there must necessarily be some unobvious way to circumvent this limitation. <br><br>  And this method really was!  It even turned out to be much more obvious than I expected. <br><br>  As I was told on <a href="http://stackoverflow.com/a/15670157/1293168">the same stackoverflow</a> , the <code>TypeBuilder</code> class has static methods that allow you to get a method, field, or property as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myType = createType(<span class="hljs-string"><span class="hljs-string">"MyType"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(List&lt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myList = listType.MakeGenericType(myType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> genericMethod = listType.GetMethod(<span class="hljs-string"><span class="hljs-string">"Add"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actualMethod = TypeBuilder.GetMethod(myList, genericMethod);</code> </pre><br>  Here, however, there is a significant drawback: the argument types are not substituted in the returned method.  The result will be a handle to the <code>List&lt;MyType&gt;.Add(T item)</code> : the type of the argument will be <code>T</code> (generic parameter), not the expected <code>MyType</code> . <br><br>  The elimination of this drawback required the implementation of an algorithm that would calculate the values ‚Äã‚Äãof the argument types from the descriptions of the containing type and the base method, and then put them in the right places.  Together with the <code>TypeBuilder</code> methods <code>TypeBuilder</code> these two mechanisms allowed to bypass the vicious circle. <br><br>  Conclusion - even the great ones sometimes make mistakes, and on Reflection.Emit <b>you can</b> make a full-featured compiler.  However, it is necessary how to steam up. <br><br>  If someone is curious to learn more about the limitations of <code>Reflection.Emit</code> , I advise you to read <a href="http://blogs.msdn.com/b/lucian/archive/2009/11/29/the-limitations-of-reflection-emit.aspx">an MSDN blog article</a> written back in 2009.  There are some examples of class topologies that cannot be generated.  Beware, examples on VB! <br><br><h4>  Wonders of Memization </h4><br>  Having stuck into the language of support for memoisation, I suddenly wondered if this practice could not improve the speed of the compiler itself?  One of the most commonly used compilers is the <code>TypeDistance</code> function.  It calculates the relative distance of inheritance or conversion between the two types, which is required for: <br><br><ul><li>  Checks on the ability to cast an expression to type </li><li>  Finding the most appropriate overload method </li><li>  Determining the most appropriate general type for a collection </li></ul><br>  This method contained more than a dozen of various checks and occupied a considerable share of the compilation time.  But the distance between the two types does not change with time, so it is quite possible to cache it into a dictionary like <code>Dictionary&lt;Tuple&lt;Type, Type&gt;, int&gt;</code> .  Memotization of the three key methods took about half an hour and reduced the compilation time of several complex scripts by <b>about 60 times</b> . <br><br><h4>  Future of the project </h4><br>  At the moment, the compiler is stable and passes more than two hundred tests.  It can already be used in real projects, but this does not mean that the work is completed.  The main task is to rewrite the parser from F # to C #.  Using the <a href="http://www.quanttec.com/fparsec/">FParsec</a> library to build parsers didn‚Äôt justify itself, and it became unbearable to support changes in the grammar.  In addition, it provides rather scant opportunities for displaying error messages and drags the entire F # runtime and 500 kilobytes of dependencies.  If we consider that all the compiler code takes 250 kb, this is a lot. <br><br>  For this reason, some features are already implemented in the compiler, but so far not supported in the parser - the slightest changes in the grammar cause an avalanche-like wave of test collapse.  Among such "chips" is the <code>for/foreach</code> , the <code>finally</code> section when handling exceptions and the memoization of functions, as well as minor syntax refinements. <br><br>  The rest of the work is about the following: <br><br><ul><li>  Add pattern matching support </li><li>  Add support for object initializers </li><li>  Allow generic methods and possibly structures to be declared. </li><li>  Add event subscription support </li><li>  Describe all features in the documentation. </li></ul><br>  While we are working on the project only together, but perhaps there will be like-minded people among the readers - then the work will go faster.  In more distant plans - support for the language in Visual Studio and the generation of debugging symbols. <br><br><h4>  Where can I try? </h4><br>  All source code is available in the githaba repository: <br><br><a href="http://github.com/impworks/lens"></a>  <a href="http://github.com/impworks/lens/"><b>github.com/impworks/lens</b></a> <br><br>  There are three test host programs in the project where you can test the operation of the compiler.  For their work you will need <a href="http://www.microsoft.com/en-us/download/details.aspx%3FDisplayLang%3Den%26id%3D15834">F # Redistributable</a> .  If you have Visual Studio 2010 and older installed, you do not need to install anything. <br><br>  <a href=""><b>Collected demos for Windows</b></a> <br><br><h5>  Console </h5><br>  The easiest host for the compiler.  The program is entered line by line or loaded from a file.  To start, you must put the <code>#</code> symbol at the end of the line <br><br><img src="https://habrastorage.org/storage2/90a/04f/e9a/90a04fe9a92ab8c24b5484899aade7fe.png"><br><br><h5>  Plotter </h5><br>  It allows you to plot a two-dimensional function according to its formula in the form <code>y = f(x)</code> .  You can set the range and pitch. <br><br> <a href=""><img src="https://habrastorage.org/storage2/041/9cf/cce/0419cfccee4dd15455cac3c2a1c88399.png"></a> <a href=""><img src="https://habrastorage.org/storage2/4ad/55c/777/4ad55c777736ff79529726630b96c4ba.png"></a> <br>  <i>(Pictures are clickable)</i> <br><br><h5>  Graphic sandbox </h5><br>  The most functional host application.  It provides the script with the Circle and Rect types, which can be displayed on the screen and describe the logic of their behavior.  Included are several demo scripts. <br><br> <a href=""><img src="https://habrastorage.org/storage2/177/b68/1c0/177b681c0041d7bb23b61a64f9e08a9e.png"></a> <a href=""><img src="https://habrastorage.org/storage2/451/f03/caa/451f03caa1a672042a62ffa9f2cfdf2f.png"></a> <br><br><h4>  Total </h4><br>  Still, the project was made more for fun than for solving practical problems.  Of course, it may not be useful to anyone and stall, but work on it took me an interesting job for about eight months and made it possible to study the intricacies of the internal structure of the framework, which in itself is great.  And if it is useful to someone in real projects - let me know! </div><p>Source: <a href="https://habr.com/ru/post/184498/">https://habr.com/ru/post/184498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184488/index.html">HTML5 circular panorama on three.js</a></li>
<li><a href="../184490/index.html">IBM Simon is the world's first smartphone. What's inside?</a></li>
<li><a href="../184492/index.html">Overview of the smartphone OPPO Find 5: "non-pop" flagship</a></li>
<li><a href="../184494/index.html">Escene US102 IP Phone Review</a></li>
<li><a href="../184496/index.html">Microsoft patents gestures to control the smartphone in the car</a></li>
<li><a href="../184500/index.html">Is it possible to get to the top App Store for free and what to do if it was not possible to do it for free</a></li>
<li><a href="../184504/index.html">Competitive Intelligence at PHD-2013</a></li>
<li><a href="../184506/index.html">Crystal photos of Bitfin specialized Bitcoin processor were obtained.</a></li>
<li><a href="../184510/index.html">Tasks with beautiful solutions</a></li>
<li><a href="../184514/index.html">Php.net has a new design (in beta). Brief news and survey</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>