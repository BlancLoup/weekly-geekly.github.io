<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android: Networking with Nearby (PlayServices API)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More recently, Google has provided mobile developers Android new technology of network data exchange - Nearby. It became immediately interesting to me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android: Networking with Nearby (PlayServices API)</h1><div class="post__text post__text-html js-mediator-article">  More recently, Google has provided mobile developers Android new technology of network data exchange - Nearby.  It became immediately interesting to me, as it allows you to establish a local connection between Android devices without any problems!  There is no need to force the user to enter the IP address and port, he simply initiates the connection, and clients simply connect to it.  On the <a href="https://developers.google.com/games/services/android/nearby">page</a> describing the technology the following uses are indicated: <br>  - multiplayer games on individual screens - players play network games, each from their device, which are networked (classics of the genre); <br>  - multiplayer games on the general screen - in this case, GoogleTV can act as a server, the main gameplay will take place on it, and all connected will use their phone / tablet as a game controller (as in the photo!); <br>  - and of course for any data exchange between various Android devices. <br><br><img src="https://habrastorage.org/files/bab/283/661/bab28366163942e79b89e2da4c5a6286.png"><br><a name="habracut"></a><br>  Already, you can try out this technology in the Beach Buggy Racing game: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/JvPUD6eI_vw%3Ffeature%3Doembed&amp;xid=25657,15700021,15700186,15700191,15700248,15700253,15700258&amp;usg=ALkJrhjExNIBi6fP4v-482DUtpTvbGfGdg" frameborder="0" allowfullscreen=""></iframe><br>  After the main material of the article was prepared, I wondered how well the system controls the sequence of delivered packages.  Especially for these purposes, I have prepared a small application for sending photos as text.  Tens of thousands of packets of 2048 characters each were sent from one device to another.  The order was not broken, not a single packet was lost.  For control of the delivery sequence, we had to pay the delivery time, it increased. <br><br>  Consider the principles of working with Nearby. <br>  In order not to create a bike, I took the <a href="https://github.com/googlesamples/android-nearby/tree/master/connections-quickstart">original example</a> and reviewed it with the translation of all comments. <br>  First of all, make sure that your phone has the latest version of GooglePlay services - <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.google.android.gms">https://play.google.com/store/apps/details?id=com.google.android.gms</a> . <br>  We now turn to the main points of the project: <br>  The PlayServices library has been added to the project (to the file ‚Äúbuild.gradle‚Äù), it allows you to work with Nearby: <br><pre><code class="java hljs">dependencies { <span class="hljs-function"><span class="hljs-function">compile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'libs'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> compile 'com.android.support:appcompat-v7:22.0.0' compile 'com.google.android.gms:play-services:7.0.0' }</span></span></code> </pre> <br>  Working with Nearby can be divided into the following steps: <br>  1) Creating the main access object - GoogleApiClient.  Run client.  Stop the client <br>  2) Launching a complaint of intent to become an access point <br>  3) Start searching for points to connect <br>  4) Attach to point <br>  5) Processing applications for accession <br>  6) Connection control <br>  7) Acceptance and processing of messages from the opponent <br>  8) Sending a message <br>  Consider everything in order. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Creating the main access object is GoogleApiClient.</b>  <b>Run client.</b>  <b>Stop the client.</b>  It's simple.  In the activity constructor, we create the main access object for Nearby.  When an activity starts, we start it; when an activity is stopped, we disconnect from the network. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ mGoogleApiClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleApiClient.Builder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .addConnectionCallbacks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .addOnConnectionFailedListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .addApi(Nearby.CONNECTIONS_API) .build(); ‚Ä¶ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStart(); Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"onStart"</span></span>); mGoogleApiClient.connect(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStop(); Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"onStop"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mGoogleApiClient != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { mGoogleApiClient.disconnect(); } }</code> </pre><br>  The next stage is the <b>launch of a complaint of intent to become an access point</b> , the startAdvertising method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startAdvertising</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ debugLog(<span class="hljs-string"><span class="hljs-string">"startAdvertising"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isConnectedToNetwork()) { debugLog(<span class="hljs-string"><span class="hljs-string">"startAdvertising: not connected to WiFi network."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//           . List&lt;AppIdentifier&gt; appIdentifierList = new ArrayList&lt;&gt;(); appIdentifierList.add(new AppIdentifier(getPackageName())); AppMetadata appMetadata = new AppMetadata(appIdentifierList); //  .    .    ,       ,  "LGE Nexus 5" String name = null; Nearby.Connections.startAdvertising(mGoogleApiClient, name, appMetadata, TIMEOUT_ADVERTISE, this).setResultCallback(new ResultCallback&lt;Connections.StartAdvertisingResult&gt;() { @Override public void onResult(Connections.StartAdvertisingResult result) { Log.d(TAG, "startAdvertising:onResult:" + result); if (result.getStatus().isSuccess()) { debugLog("startAdvertising:onResult: SUCCESS"); updateViewVisibility(STATE_ADVERTISING); } else { debugLog("startAdvertising:onResult: FAILURE "); //      'Advertise'    ,    'STATUS_ALREADY_ADVERTISING' int statusCode = result.getStatus().getStatusCode(); if (statusCode == ConnectionsStatusCodes.STATUS_ALREADY_ADVERTISING) { debugLog("STATUS_ALREADY_ADVERTISING"); } else { updateViewVisibility(STATE_READY); } } } }); }</span></span></code> </pre><br>  If the user constantly ‚Äúclicks‚Äù on the ‚ÄúAdvertise‚Äù button, he will receive a message saying that everything is working fine, relax :) - STATUS_ALREADY_ADVERTISING <br><br>  The third stage - <b>Starting the search for points for the connection</b> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDiscovery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ debugLog(<span class="hljs-string"><span class="hljs-string">"startDiscovery"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isConnectedToNetwork()) { debugLog(<span class="hljs-string"><span class="hljs-string">"startDiscovery: not connected to WiFi network."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//       Nearby    . String serviceId = getString(R.string.service_id); Nearby.Connections.startDiscovery(mGoogleApiClient, serviceId, TIMEOUT_DISCOVER, this) .setResultCallback(new ResultCallback&lt;Status&gt;() { @Override public void onResult(Status status) { if (status.isSuccess()) { debugLog("startDiscovery:onResult: SUCCESS"); updateViewVisibility(STATE_DISCOVERING); } else { debugLog("startDiscovery:onResult: FAILURE"); //      'Discover'    ,     'STATUS_ALREADY_DISCOVERING' int statusCode = status.getStatusCode(); if (statusCode == ConnectionsStatusCodes.STATUS_ALREADY_DISCOVERING) { debugLog("STATUS_ALREADY_DISCOVERING"); } else { updateViewVisibility(STATE_READY); } } } }); }</span></span></code> </pre><br>  Everything is very transparent and clear.  Just start searching for access points. <br><br>  Now consider - <b>Attaching to a data exchange point</b> .  To do this, first you need to find available access points, and then join the right one.  The onEndpointFound method is specifically designed to report a new point found: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEndpointFound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String endpointId, String deviceId, String serviceId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String endpointName)</span></span></span><span class="hljs-function"> </span></span>{ Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"onEndpointFound:"</span></span> + endpointId + <span class="hljs-string"><span class="hljs-string">":"</span></span> + endpointName); <span class="hljs-comment"><span class="hljs-comment">//    .    ,      . if (mMyListDialog == null) { // Configure the AlertDialog that the MyListDialog wraps AlertDialog.Builder builder = new AlertDialog.Builder(this) .setTitle("Endpoint(s) Found") .setCancelable(true) .setNegativeButton("Cancel", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { mMyListDialog.dismiss(); } }); //     mMyListDialog = new MyListDialog(this, builder, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { String selectedEndpointName = mMyListDialog.getItemKey(which); String selectedEndpointId = mMyListDialog.getItemValue(which); MainActivity.this.connectTo(selectedEndpointId, selectedEndpointName); mMyListDialog.dismiss(); } }); } mMyListDialog.addItem(endpointName, endpointId); mMyListDialog.show(); }</span></span></code> </pre><br>  The ‚ÄúconnectTo‚Äù method implements the <b>dialog for selecting a point to which it is possible to connect</b> .  When choosing one of the options, go to the direct connection: <br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** *       . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> endpointId -       * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> endpointName -   ,    .       . * */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String endpointId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String endpointName)</span></span></span><span class="hljs-function"> </span></span>{ debugLog(<span class="hljs-string"><span class="hljs-string">"connectTo:"</span></span> + endpointId + <span class="hljs-string"><span class="hljs-string">":"</span></span> + endpointName); <span class="hljs-comment"><span class="hljs-comment">//       . String myName = null; byte[] myPayload = null; Nearby.Connections.sendConnectionRequest(mGoogleApiClient, myName, endpointId, myPayload, new Connections.ConnectionResponseCallback() { @Override public void onConnectionResponse(String endpointId, Status status, byte[] bytes) { Log.d(TAG, "onConnectionResponse:" + endpointId + ":" + status); if (status.isSuccess()) { debugLog("onConnectionResponse: " + endpointName + " SUCCESS"); Toast.makeText(MainActivity.this, "Connected to " + endpointName, Toast.LENGTH_SHORT).show(); mOtherEndpointId = endpointId; updateViewVisibility(STATE_CONNECTED); } else { debugLog("onConnectionResponse: " + endpointName + " FAILURE"); } } }, this); }</span></span></code> </pre><br>  If everything went well, you can start messaging. <br><br>  The onConnectionRequest method is used for <b>processing applications for connection</b> : <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConnectionRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String endpointId, String deviceId, String endpointName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] payload)</span></span></span><span class="hljs-function"> </span></span>{ debugLog(<span class="hljs-string"><span class="hljs-string">"onConnectionRequest:"</span></span> + endpointId + <span class="hljs-string"><span class="hljs-string">":"</span></span> + endpointName); <span class="hljs-comment"><span class="hljs-comment">//          .            . mConnectionRequestDialog = new AlertDialog.Builder(this) .setTitle("Connection Request") .setMessage("Do you want to connect to " + endpointName + "?") .setCancelable(false) .setPositiveButton("Connect", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { byte[] payload = null; Nearby.Connections.acceptConnectionRequest(mGoogleApiClient, endpointId, payload, MainActivity.this) .setResultCallback(new ResultCallback&lt;Status&gt;() { @Override public void onResult(Status status) { if (status.isSuccess()) { debugLog("acceptConnectionRequest: SUCCESS"); mOtherEndpointId = endpointId; updateViewVisibility(STATE_CONNECTED); } else { debugLog("acceptConnectionRequest: FAILURE"); } } }); } }) .setNegativeButton("No", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Nearby.Connections.rejectConnectionRequest(mGoogleApiClient, endpointId); } }).create(); mConnectionRequestDialog.show(); }</span></span></code> </pre><br>  A number of methods are responsible for controlling the connection: <br>  onDisconnected - processing a connection break; <br>  onConnected - connection handling; <br>  onEndpointLost - break connection handling; <br>  onConnectionSuspended - handling connection interruption; <br>  onConnectionFailed - handling failed connections. <br>  Control over the reconnection of clients (for example, if the connection is broken when the user leaves the WiFi zone) is completely left to the developer. <br><br>  To <b>process incoming messages,</b> you must rewrite the onMessageReceived method: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessageReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String endpointId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] payload, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isReliable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     debugLog("onMessageReceived:" + endpointId + ":" + new String(payload)); }</span></span></code> </pre><br>  Sending messages is carried out using two methods: <br>  1) Nearby.Connections.sendReliableMessage - sending reliable messages; <br>  2) Nearby.Connections.sendUnreliableMessage - sending unreliable messages. <br>  When using the first method, the system itself controls the correctness of the sequence of the delivered messages, in the second case the sequence can be broken, since there is no control.  But the second method is faster, so it is better to use it when you need to send a large number of messages, for example, when you send the cursor position on the screen. <br><br>  In the resources you need to specify the service identifier for which customers will be searched and connected. <br><pre> <code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>?&gt; &lt;resources&gt; ... &lt;string name=<span class="hljs-string"><span class="hljs-string">"service_id"</span></span>&gt;&lt;!--   ,  ..--&gt;&lt;/string&gt; ... &lt;/resources&gt;</code> </pre><br>  To resolve an application complaint, the following must be written in the manifest: <br><pre> <code class="java hljs">&lt;application&gt; &lt;meta-data android:name=<span class="hljs-string"><span class="hljs-string">"com.google.android.gms.nearby.connection.SERVICE_ID"</span></span> android:value=<span class="hljs-string"><span class="hljs-string">"@string/service_id"</span></span> /&gt; &lt;activity&gt; ... &lt;/activity&gt; &lt;/application&gt;</code> </pre><br>  If you build this application and run it on your devices, you can watch the following: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ca3rlQsLfcU%3Ffeature%3Doembed&amp;xid=25657,15700021,15700186,15700191,15700248,15700253,15700258&amp;usg=ALkJrhhYYpM_vbguW1cgwqtQdnnVjK9kdA" frameborder="0" allowfullscreen=""></iframe><br>  At first glance it may seem that using the Nearby API is difficult and cumbersome, but this is only at first glance.  As a result, the developer gets a ready, reliable, controlled tool for network data exchange.  Personally, I really liked this solution, no longer need to control the order in which data packets arrive, ask users to enter ip address and socket number, make additional settings ... Beauty! <br><br>  <b><a href="">Sources with comments</a></b> <br>  <a href="">Separately APK</a> <br><br>  Thanks for the help in preparing the <a href="http://habrahabr.ru/users/inatale/">inatale</a> material! </div><p>Source: <a href="https://habr.com/ru/post/256071/">https://habr.com/ru/post/256071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256059/index.html">GrabDuck: a new look at bookmarks</a></li>
<li><a href="../256061/index.html">Ghostlab: Using Chrome development tools for debugging in any browser</a></li>
<li><a href="../256063/index.html">We translate using Yandex</a></li>
<li><a href="../256067/index.html">Wolfram Language (Mathematica) in Russian ... or advanced function assignment</a></li>
<li><a href="../256069/index.html">CSS of the future: distance to the eyes</a></li>
<li><a href="../256077/index.html">The digest of interesting materials for the mobile # 99 developer (April 13-19)</a></li>
<li><a href="../256079/index.html">Eliminating the mysterious error "undefined is not a function" in V8</a></li>
<li><a href="../256081/index.html">How SpaceX uses the GPU to calculate rocket engines</a></li>
<li><a href="../256083/index.html">WEB 3.0. From cytocentricism to user centrism, from anarchy to pluralism</a></li>
<li><a href="../256085/index.html">Restoration of the PC "Microsha"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>