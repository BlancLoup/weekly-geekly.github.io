<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>@ActivityScope with Dagger 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I want to share the experience of creating an ActivityScope. Those examples that I saw on the Internet, in my opinion, are not sufficiently ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>@ActivityScope with Dagger 2</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I want to share the experience of creating an ActivityScope.  Those examples that I saw on the Internet, in my opinion, are not sufficiently complete, irrelevant, artificial and do not take into account some of the nuances of practical development. <br><br>  The article assumes that the reader is already familiar with Dagger 2 and understands what a component is, a module, an injection, and an object graph and how it all works together.  Here we, first of all, will concentrate on creating an ActivityScope and on how to link it to the fragments. <br><br>  So, let's go ... What is the scope? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/2af/a00/4fd/2afa004fd331431186e6ed8348d370b8.jpg"><br><a name="habracut"></a><br>  Scope is a Dagger 2 mechanism that allows you to save a certain set of objects that has its own life cycle.  In other words, a scop is an object graph having its own lifetime, which depends on the developer. <br><br>  By default, Dagger 2 out of the box provides us with support for the <b>javax.inject.Singleton</b> scop.  As a rule, objects in this scopa exist exactly as long as the instance of our application exists. <br><br>  In addition, we are not limited in the possibility of creating our own additional scopes.  A good example of a custom scop can be the <b>UserScope</b> , whose objects exist as long as the user is authorized in the application.  As soon as the user's session ends, or the user explicitly exits the application, the object graph is destroyed and re-created at the next authorization.  In this scoop it is convenient to store objects associated with a specific user and not having meaning for other users.  For example, some AccountManager that allows you to view lists of accounts of a particular user. <br><br><img src="https://habrastorage.org/files/f25/485/cfb/f25485cfbe504ec5948016beb94f5010.png"><br><br>  The figure shows an example of the <b>Singleton</b> and <b>UserScope</b> life cycle in an application. <br><br><ul><li>  At startup, a <b>singleton</b> scop is created, the lifetime of which equals the lifetime of the application.  In other words, objects belonging to Singleton will exist until the system destroys and unloads our application from memory. </li><li>  After starting the application, <b>User1 is</b> authorized in the application.  At this point, a UserScope is created, containing objects that have meaning for this user. </li><li>  After some time, the user decides to "log out" and logs out of the application. </li><li>  Now <b>User2 is</b> authorized and this initiates the creation of <b>UserScope</b> objects for the second user. </li><li>  When a user session expires, it will destroy the object graph. </li><li>  <b>User1</b> returns to the application, <b>becomes</b> authorized, thereby creates a graph of <b>UserScope</b> objects and sends the application to the background. </li><li>  After some time, the system in a situation of lack of resources decides to stop and unload from the memory of our application.  This results in the destruction of both the <b>UserScope</b> and the <b>SingletonScope</b> . </li></ul><br>  Hopefully we figured out a bit with the scopes. <br><br>  We now turn to our example - <b>ActivityScope</b> .  In real Android applications, ActivityScope can be extremely useful.  Still would!  It is enough to imagine some complex screen consisting of a heap of classes: five different fragments, a lot of adapters, helpers and presenters.  In this case, it would be ideal to ‚Äúfumble‚Äù between them a model and / or business logic classes, which should be common. <br><br><img width="40%" height="40%" align="right" src="https://habrastorage.org/files/ca6/d6f/587/ca6d6f5874ac4058b1233c49bf61cfc2.png">  There are 3 options for solving this problem: <br><br><ol><li>  Use homemade singletons, the Application class, or static variables to pass references to common objects.  I definitely don‚Äôt like this approach, because it violates the principles of OOP and SOLID, makes the code confusing, hard to read and unsupported. <br><br></li><li>  Independently transfer objects from an Activity to the required classes via setters or constructors.  The disadvantage of this approach is the cost of writing a routine code, when you could instead focus on writing new features. <br><br></li><li>  Use Dagger 2 to inject shared objects into necessary places of our application.  In this case, we get all the advantages of the second approach, while not spending time on writing the template code.  In fact, we shift the writing of binding code to the library. </li></ol><br>  Let's take a step-by-step how to create and use an ActivityScope with Dagger 2. <br><br>  So, to create a custom skopa you need: <br><br><ul><li>  Announce scop (create annotation) </li><li>  Declare at least one component and the corresponding module for scopa </li><li>  At the right time, instantiate the object graph and delete it after use. </li></ul><br>  The interface of our <a href="https://github.com/d-tarasov/dagger-2-activity-scope">demo application</a> will consist of two <b>ActivityA</b> and <b>ActivityB</b> screens and a common fragment used by both <b>SharedFragment activities</b> . <br><br><img width="45%" src="https://habrastorage.org/files/a07/aca/547/a07aca547e884f1993613303266c97d4.png"><img width="45%" src="https://habrastorage.org/files/ab1/a72/bf7/ab1a72bf7c1b4d5e82338dbd9f99fcef.png"><br><br>  The application will have 2 scopes: <b>Singleton</b> and <b>ActivityScope</b> . <br><br>  Conventionally, all our beans can be divided into 3 groups: <br><br><ul><li>  Singletons - <b>SingletonBean</b> </li><li>  Activation Scope Bins, which are needed only inside Activiti - <b>BeanA</b> and <b>BeanB</b> </li><li>  Activation Scope Bins, access to which is needed both from the Activation itself and from other activation sites of the Scope, for example, a fragment - <b>SharedBean</b> </li></ul><br>  Each bin gets a unique id when created.  This allows you to visually understand whether the skup works as intended, because each new instance of the bean will have an id that is different from the previous one. <br><br><img src="https://habrastorage.org/files/4d2/df5/6c1/4d2df56c1f3d416f9f31cb4b39a25bfb.png"><br><br>  Thus, in the application there will be 3 object graphs (3 components) <br><br><ul><li>  <b>SingletonComponent</b> - a graph of objects that exist while the application is running and not killed by the system. </li><li>  <b>ComponentActivityA</b> is a graph of objects necessary for the operation of ActivityA (including its fragments, adapters, presenters, and so on) and existing as long as an instance of ActivityA exists.  When you destroy and re-create the activation, the graph will also be destroyed and re-created along with the new activation instance.  This graph is a superset that includes all objects from the singleton scop. </li><li>  <b>ComponentActivityB</b> is a similar graph, but for ActivityB </li></ul><br><img src="https://habrastorage.org/files/002/46a/708/00246a7086944930a716905af9d39043.png"><br><br>  Let's turn to implementation.  First we connect Dagger 2 to our project.  To do this, connect the <b>android-apt</b> plugin in the root <b>build.gradle</b> ... <br><br><pre><code class="javascript hljs">buildscript { <span class="hljs-comment"><span class="hljs-comment">//... dependencies { //... classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' } }</span></span></code> </pre> <br>  and Dagger 2 itself in <b>app / build.gradle</b> <br><br><pre> <code class="javascript hljs">dependencies { compile <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger:2.7'</span></span> apt <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger-compiler:2.7'</span></span> }</code> </pre><br>  Next, we announce the module that will provide singletons <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingletonModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">SingletonBean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideSingletonBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingletonBean(); } }</code> </pre><br>  and the singleton component: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = SingletonModule.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingletonComponent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  We create an injector - the only singleton in our application, which we will manage, and not Dagger 2, and which will hold the <b>Singleton</b> scop dagger and be responsible for the injection. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Injector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Injector INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Injector(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SingletonComponent singletonComponent; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Injector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ singletonComponent = DaggerSingletonComponent.builder() .singletonModule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingletonModule()) .build(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SingletonComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSingletonComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INSTANCE.singletonComponent; } }</code> </pre><br>  We declare <b>ActivityScope</b> .  In order to declare your scop, you need to create an annotation with the name of the scop and mark it with the annotation <b>javax.inject.Scope</b> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ActivityScope { }</code> </pre><br>  Group the beans into modules: shared and for activities <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">BeanA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideBeanA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanA(); } } <span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">BeanB </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideBeanB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanB(); } } <span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">SharedBean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideSharedBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedBean(); } }</code> </pre><br>  We declare the corresponding components of activities.  In order to implement a component that will include objects of another component, there are 2 ways: <b>subcomponents</b> and <b>component dependencies</b> .  In the first case, the child components have access to all objects of the parent component automatically.  In the second, in the parent component, you must explicitly specify the list of objects that we want to export to the children.  Within one application, in my opinion, it is more convenient to use the first option. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>(modules = {ModuleA.class, SharedModule.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentActivityA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActivityA activity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SharedFragment fragment)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>(modules = {ModuleB.class, SharedModule.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentActivityB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActivityB activity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SharedFragment fragment)</span></span></span></span>; }</code> </pre><br>  In the created subcomponents, we declare injection points.  In our example there are two such points: <b>Activity</b> and <b>SharedFragment</b> .  They will have shared <b>SharedBean</b> shared <b>beans</b> . <br><br>  Subcomponent instances are obtained from the parent component by adding objects from the subcomponent module to an existing graph.  In our example, the parent component is <b>SingletonComponent</b> , we will add methods for creating subcomponents to it. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = SingletonModule.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingletonComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ComponentActivityA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleA a, SharedModule shared)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ComponentActivityB </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleB b, SharedModule shared)</span></span></span></span>; }</code> </pre><br>  That's all.  The entire infrastructure is ready, it remains to instantiate the declared components and inject dependencies.  Let's start with a fragment. <br><br>  The fragment is used immediately within two different activities, so it does not need to know specific details about the activity within which it is located.  However, we need access to the activation component in order to gain access to the graph of objects of our scopes through it.  To solve this ‚Äúproblem‚Äù, we use the <b>Inversion of Control</b> pattern, creating an intermediate interface, <b>InjectorProvider</b> , through which interaction with activities will be built. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> SharedBean shared; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> SingletonBean singleton; <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ @Override public void onAttach(Context context) { super.onAttach(context); if (context instanceof InjectorProvider) { ((InjectorProvider) context).inject(this); } else { throw new IllegalStateException("You should provide InjectorProvider"); } } public interface InjectorProvider { void inject(SharedFragment fragment); } }</span></span></code> </pre><br>  It remains to instantiate the components of the <b>ActivityScope</b> level within each of the activities and project the activity and the fragment contained within it. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityA</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedFragment</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectorProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> SharedBean shared; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> BeanA a; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> SingletonBean singleton; ComponentActivityA component = Injector.getSingletonComponent() .newComponent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModuleA(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedModule()); <span class="hljs-comment"><span class="hljs-comment">//... @Override public void inject(SharedFragment fragment) { component.inject(this); component.inject(fragment); } }</span></span></code> </pre><br>  I will voice again the main points: <br><br><ul><li>  We created 2 different scopes: <b>Singleton</b> and <b>ActivityScope</b> </li><li>  <b>The ActivityScope</b> is implemented through <b>Subcomponent</b> , not component dependencies, so that you do not have to explicitly expose all the bins from the singleton scop </li><li>  Activity stores a link to the object graph of its corresponding ActivityScop, and injects itself and all classes that want to inject bins from the ActivityScope, for example, SharedFragment </li><li>  With the destruction of activations, the object graph for this activity is also destroyed. </li><li>  The graph of <b>singleton</b> objects exists as long as the application instance exists <br></li></ul><br>  At first glance it may seem that to implement such a simple task it is necessary to write a lot of glue code.  In the demo application, the number of classes that perform ‚Äúwork‚Äù (bins, fragments, and activities) is approximately comparable to the number of ‚Äúlinking‚Äù Dagger classes.  But: <br><br><ul><li>  In a real project, the number of ‚Äúworking‚Äù classes will be much larger. </li><li>  Binding code is enough to write once, and then just add the necessary components and modules. </li><li>  Using DI makes testing a lot easier.  You have additional opportunities for injecting mocks and stubs instead of real bins during testing. </li><li>  The business logic code becomes more isolated and concise by moving the glue and instantiation code into Dagger classes.  At the same time, in the business logic classes themselves, only business logic remains and nothing superfluous.  Such classes are again easier to write, maintain and cover with unit tests. </li></ul><br>  ¬ªA demo project is available on <a href="https://github.com/d-tarasov/dagger-2-activity-scope">github</a> <br><br>  All Dagger and happy coding!  :) </div><p>Source: <a href="https://habr.com/ru/post/312196/">https://habr.com/ru/post/312196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312184/index.html">Hide text from prying eyes (Scala example)</a></li>
<li><a href="../312186/index.html">Call center for a small company: Symbiosis amoCRM and Hive</a></li>
<li><a href="../312188/index.html">Usage Chart in Software Development</a></li>
<li><a href="../312190/index.html">Apply the Check Knowledge Module (CKM) in projects based on Oracle Data Integrator</a></li>
<li><a href="../312194/index.html">When the old MapReduce is better than the new Tez</a></li>
<li><a href="../312198/index.html">Visual Studio "15" Preview 5</a></li>
<li><a href="../312200/index.html">The problem of the Internet - in low bandwidth</a></li>
<li><a href="../312202/index.html">Multiple PHP versions under one Apache on Windows (v2)</a></li>
<li><a href="../312206/index.html">Preparing to migrate vCenter Server to vSphere 6.0 Update 2m. Part 1</a></li>
<li><a href="../312208/index.html">Complete Idiot's Guide: How to get started with Google Analytics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>