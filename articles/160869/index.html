<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About two-dimensional packaging: online algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a continuation of the post about offline packaging algorithms. 

 The essence of the problem: we have a semi-infinite strip - as in tetris, on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About two-dimensional packaging: online algorithms</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/c94/07d/b77/c9407db7753a73de4241c3f908049528.jpg" align="right">  This is a continuation of the <a href="http://habrahabr.ru/post/136225/">post</a> about offline packaging algorithms. <br><br>  The essence of the problem: we have a semi-infinite strip - as in tetris, only without a game over, and a finite set of rectangles.  Rectangle data comes in real time;  Each new rectangle must be placed immediately and no longer move.  The goal is to minimize the overall height of the packed rectangles. <br>  This is an online variation of the problem of packing rectangles into a semi-bounded strip (2 Dimensional Strip Packing, 2DSP). <br><br>  A little more theoretical information can be found in the previous article, but for now, without further ado, let's turn to the algorithms. <br><a name="habracut"></a><br>  For illustration, this sequence of bricks will be used: <br><img src="https://habrastorage.org/storage2/a6f/cc9/adf/a6fcc9adffcd9955dd55d55ce6257dec.png"><br>  (The source data sponsor is random.org). <br>  Some heuristic algorithms will be described, the general idea of ‚Äã‚Äãwhich is to pre-divide a strip into areas and place newly incoming rectangles in a specific area according to certain criteria. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Level algorithms </h2><img src="https://habrastorage.org/storage2/84c/3f9/ad9/84c3f9ad9feb9931fe9a4c3b8f84fbe0.png" align="right"><img src="https://habrastorage.org/storage2/b4b/19c/924/b4b19c92465eb2b5c5dcb3a09720d994.png" align="right"><img src="https://habrastorage.org/storage2/fe4/343/1a0/fe43431a06d9aa33cd76d36afc787381.png" align="right"><br>  The approach of all level algorithms is that the strip is divided into levels, based on the height of the rectangles present at this stage.  Rectangles are placed along the bottom of the current level from left to right as long as possible;  a rectangle that does not fit is packed to the next level.  The height of each level is determined by the highest rectangle in it.  Here are three packaging options: <br>  Next Fit Level - when the next level opens, the previous one ‚Äúcloses‚Äù and is no longer considered; <br>  First Fit Level - at each step of the algorithm, <i>each</i> level is viewed, starting from the lowest one, and the rectangle is packed into the first suitable one, which has enough space; <br>  Best Fit Level - at every step of the algorithm, <i>all</i> levels are viewed, and the most appropriate one is selected - the one at which there will be a minimum of space after packaging. <br>  All three algorithms are illustrated above.  At this stage, it is easy to guess which one. <br><br><div class="spoiler">  <b class="spoiler_title">Algorithms NFL, FFL, BFL</b> <div class="spoiler_text">  <b>Next Fit Level</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: level = 0;  h (level + 1) = 0;  H = 0;  i = 0
  2: while there is an unpacked rectangle do
  3: i ++
  4: if there is a level
  5: pack rectangle left justified
  6: if h (level + 1) &lt;h (Li) then
  7: h (level + 1) = h (Li)
  8: end if
  9: else [there is insufficient space on current level]
 10: open the rectangle
 11: H + = h (level + 1);  level ++
 12: end if
 13: end while
 14: print H and entire packing </pre><br><br>  <b>First Fit Level</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: level = 0;  h (level + 1) = h (L1);  H = h (L1);  i = 1
  2: while there is an unpacked rectangle do
  3: i ++;  level = 0
  4: search for space level
  5: if such a level exists then
  6: pack rectangle left justified
  7: if this is the level and h (level) &lt;h (li) then
  8: h (level) = h (Li)
  9: end if
 10: else [there is insufficient space in all existing levels]
 11: create a new level above the top-most level
 12: pack rectangle left justified
 13: h (level) = h (Li);  H + = h (Li)
 14: end if
 15: end while
 16: print H and entire packing </pre><br><br>  <b>Best Fit Level</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: level = 0;  h (level + 1) = h (L1);  H = h (L1);  i = 0
  2: while there is an unpacked rectangle do
  3: i ++;  level = 0
  4: Search for the lowest level with minimum residual horizontal space
  5: if such a level exists then
  6: pack rectangle left justified
  7: else [such a level does not exist]
  8: create a new level above the top-most level
  9: pack rectangle left justified
 10: h (level) = h (Li);  H + = h (Li)
 11: end if
 12: end while
 13: print H and entire packing </pre></div></div><br><br><h2>  Bi-Level Next Fit </h2><img src="https://habrastorage.org/storage2/bbd/f46/5a3/bbdf465a318ab5d325ee02717c262a4d.png" align="right"><br>  Sly modification Next Fit Level.  Levels are created in two, each with its own strategy. <br>  The bottom level (or all odd ones): the first arriving rectangle is packed along the left edge, the rest - from right to left, while there is enough space.  Then the level is closed and its height is determined by the highest rectangle in it. <br>  Top level (or all even): if there is only one rectangle on the bottom level, the level is packed similarly to the bottom one.  If two or more, then the first rectangle is packed over the lower of the two pressed to the edges of the strip, and also pressed against the edge of the strip;  all subsequent ones are packed from right to left, regardless of whether the first one was packed - on the left or on the right. <br><br>  It sounds confusing and not immediately clear why such dances with a tambourine.  The only thing that this algorithm obviously provides is a more uniform distribution of rectangles over the volume of the strip, without skewing to the left edge.  But we will return to this strategy when we consider compression algorithms. <br><br><div class="spoiler">  <b class="spoiler_title">BiNFL Algorithm</b> <div class="spoiler_text">  <b>Bi-Level Next Fit</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: level = 1;  h (level) = 0;  H = 0;  i = 1
  2: open a new bi-level
  3: call 'pack on lower level'
  4: print H and entire packing
 Procedure 'pack on lower level'
  1: the first rectangle packed is left justified
  2: subsequent rectangles that fit are right justified
  3: if there is insufficient space then
  4: h (level) tallest rectangle packed
  5: call 'pack on upper level'
  6: end if
 Procedure 'pack on the upper level'
  1: if Li + 1 is the first rectangle packed then
  2: left justify on top of Li
  3: else
  4: if Li + 2 is the first rectangle packed then
  5: pack above min {h (Li);  h (Li + 1)}
  6: justify according to min {h (Li);  h (Li + 1)}
  7: else
  8: if Li + j (j&gt; 3) fits on the upper level then
  9: left justify all other rectangles
 10: else [rectangle does not fit]
 11: H + = h (lower) + h (upper);  open new bi-level
 12: end if
 13: end if
 14: end if </pre></div></div><br><br><h2>  Shelf algorithms </h2><img src="https://habrastorage.org/storage2/e5e/9dc/47b/e5e9dc47b99520d0c5634cb5fd531375.png" align="right"><img src="https://habrastorage.org/storage2/9c8/472/192/9c8472192307cda4705442917ef525c5.png" align="right"><img src="https://habrastorage.org/storage2/635/1d4/db7/6351d4db7b850924c94ffb03d5158590.png" align="right"><br>  Shelf algorithms are not tied to the exact height of the rectangles, and after packing the first level (shelf) there is not much room left in case the next one is a little higher.  This ‚Äúlittle‚Äù is regulated by the parameter <i>r</i> ‚àà (0; 1).  The shelf height is defined as <i>r</i> <sup><i>k</i></sup> , where <i>r</i> <sup><i>k + 1</i></sup> &lt;h (L <sub>i</sub> ) ‚â§ <i>r</i> <sup><i>k</i></sup> for some integer <i>k</i> and the height of the first packed rectangle h (L <sub>i</sub> ).  Similar to layered algorithms, Next Fit, First Fit, and Best Fit shelf bypass strategies are applied.  The ‚Äúreserve‚Äù left on each shelf becomes profitable in the last two cases (compare FFL and FFS, BFL and BFS).  In the example, <i>p</i> = 0.7. <br><br><div class="spoiler">  <b class="spoiler_title">Algorithms NFS, FFS, BFS</b> <div class="spoiler_text">  <b>Next Fit Shelf</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)}
        w and strip width
 Output: The height H and the packing.
  1: shelf = 1;  w (shelf) = 0;
     h (shelf) = r ^ k for some integer k;  i = 0;  H = h (shelf)
  2: while there is an unpacked rectangle do
  3: i ++;  compute k
  4: if there is sufficient space and r ^ (k + 1) &lt;h (Li) ‚â§ r ^ k then
  5: Rectangle Packed Rectangle
  6: else [there is insufficient space]
  7: create one new shelf
           Li and the pack.
  8: shelf ++;  H + = r ^ k
  9: end if
 10: end while
 11: print H and entire packing. </pre><br><br>  <b>First Fit Shelf</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)}
        w and strip width
 Output: The height H and the packing.
  1: shelf = 1;  h (shelf) = r ^ k for some integer k;
     i = 0;  H = h (shelf);  shelfnum = 1
  2: while there is an unpacked rectangle do
  3: i ++;  compute k
  4: search for low height
  5: if such a shelf exists then
  6: Pack Rectangle Pack
  7: else [there is insufficient space in all shelves of
              appropriate height or such a shelf does not exist]
  8: create a new shelf above the top-most shelf
           Li and the pack.
  9: shelf ++;  H + = r ^ k;  shelfnum ++
 10: end if
 11: end while
 12: print H and entire packing. </pre><br><br>  <b>Best Fit Shelf</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)}
        w and strip width
 Output: The height H and the packing.
  1: shelf = 1;  h (shelf) = r ^ k for some integer k;
     i = 0;  H = h (shelf);  shelfnum = 1
  2: while there is an unpacked rectangle do
  3: i ++;  compute k
  4: search all shelves (starting with the bottom) for one
        with appropriate height and has minimum horizontal space.
  5: if such a shelf exists then
  6: Pack Rectangle Pack
  7: else [there is insufficient space or
              there is no shelf of appropriate height]
  8: create a new shelf above the top-most shelf
           Li on the new shelf.
  9: shelf ++;  H + = r ^ k;  shelfnum ++
 10: end if
 11: end while
 12: print H and entire packing. </pre></div></div><br><br><h2>  Harmonic shelf </h2><img src="https://habrastorage.org/storage2/77b/4a9/c0f/77b4a9c0fb8fccf72f5c79cc433ac1df.png" align="right"><br>  Harmonic Shelf packs rectangles one level not only with a similar height, but also with a similar width.  The result will be more levels, but they will be filled with denser.  An additional parameter <i>M</i> is introduced to calculate the allowable width. <br><br>  The total width of the strip, for simplicity, we take it per unit, divided by <i>M</i> intervals <i>I</i> <sub>1</sub> .. <i>I</i> <sub><i>M.</i></sub>  The author claims that a reasonable value of <i>M</i> is in [3;  12].  The width of the intervals is calculated by the formula: <br><br><img src="https://habrastorage.org/storage2/aee/47d/375/aee47d3755382a2fb46fcf9081ddcb2d.png">  ; <img src="https://habrastorage.org/storage2/b47/e3f/8ba/b47e3f8badf98db52492675eb741141b.png"><br><br>  For each rectangle, <i>p is</i> calculated.  Parameter <i>k</i> for height is calculated similarly to shelf algorithms.  Two conditions are checked: is there a place on a shelf with height <i>r</i> <sup><i>k</i></sup> for a rectangle and does it correspond to <i>p</i> already packed there.  If at least one is not done, it creates its own shelf, with blackjack and the most comfortable conditions.  In the example, <i>p</i> = 0.7, <i>M</i> = 4. <br><br><div class="spoiler">  <b class="spoiler_title">HS Algorithm</b> <div class="spoiler_text">  <b>Harmonic shelf</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)}
        the parameters M and the strip width W.
 Output: The height H and the packing.
  1: shelf = 1;  h (shelf) = r ^ k for some integer k;  i = 0
  2: while there is an unpacked rectangle do
  3: i ++;  compute k such that r ^ (k + 1) &lt;h (Li) ‚â§ r ^ k
  4: compute the value of p such that 1 / (p + 1) &lt;w (Li) ‚â§ 1 / p
        where 1 ‚â§ p &lt;M
  5: amongst shelves of height r ^ k find the one
        with packing rectangles
  6: if there is a r ^ k then rectangle of height
  7:
  8: shelf ++
  9: end if
 10: if rectangle
 11: h (shelf) = r ^ k;  H + = h (shelf)
 12: end if
 13: end while
 14: print H and entire packing </pre></div></div><br><br><h2>  Azar <sub>y</sub> </h2><img src="https://habrastorage.org/storage2/88a/700/04f/88a70004f8f042bd1de071dc92a46b7a.png" align="right"><br>  For division into levels, a certain threshold value 0 &lt; <i>Y</i> &lt;1/2 is introduced.  The width of the rectangles is scaled according to the width of the strip, which is taken as one.  Rectangles with a height of 2 <sup><i>j</i> -1</sup> &lt;h (L <sub>i</sub> ) ‚â§ 2 <sup><i>j</i></sup> and a width of 2 <sup>- <i>x</i> -1</sup> &lt;h (L <sub>i</sub> ) ‚â§ 2 <sup>- <i>x</i></sup> are packed into one level.  That is, a level is characterized by a pair ( <i>x</i> , <i>j</i> ) for some integer <i>j</i> and natural <i>x</i> . <br><br>  Rectangles with a width of at least <i>Y</i> are <i>buffered</i> and packed each on a separate level.  That is, if you get such a rectangle, you urgently need to open a new level that is equal in height.  All others (non-buffer) are packed at the first appropriate level.  Suitable - in the sense of the same pair ( <i>x</i> , <i>j</i> ).  If suddenly there is not enough space, a non-buffer rectangle may become the first in a new level, then the height of this level will be 2 <sup><i>j</i></sup> . <br>  Some kind of unhealthy hierarchy, in general. <br>  In the example, <i>Y</i> = 0.4. <br><br><div class="spoiler">  <b class="spoiler_title">Azar algorithm</b> <div class="spoiler_text">  <b>Azar <sub>y</sub></b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)}
        the parameter Y and the strip width W.
 Output: The height H and the packing.
  1: h (level) = 0;  w (level) = 0;  level = 0
  2: while there is an unpacked rectangle do
  3: if w (Li) ‚â• Y then
  4: level ++;  w (level) = w (Li);  h (level) = h (Li);  H + = h (level)
  5: else [w (Li) &lt;Y]
  6: compute x and j such that
           2 ^ (j-1) &lt;h (Li) ‚â§ 2 ^ j and 2 ^ (- x-1) &lt;w (Li) ‚â§ 2 ^ (- x)
  7: search for the lowest (x, j) level
  8: if no (x, j) level is available or Li is blocked then
  9: level ++;  h (level) = 2 ^ j;  H + = h (level)
 10: w (level) + = w (Li)
 11: else [(x, j) level is available and not blocked]
 12: w (level) + = w (Li)
 13: end if
 14: end if
 15: end while
 16: print H and entire packing </pre></div></div><br><br><h2>  Compression algorithms </h2><img src="https://habrastorage.org/storage2/c76/ff4/075/c76ff4075ccef48aba2ade4ec61d693c.png" align="right"><img src="https://habrastorage.org/storage2/fc6/3cc/65f/fc63cc65fcb29dc09cd722632ce48f8f.png" align="right"><img src="https://habrastorage.org/storage2/407/301/0c1/4073010c1bb036dc936a669d155e9b82.png" align="right"><br>  Compression algorithms are based on BiNFL and are essentially patches to the top-level packaging method. <br>  The general difference is that the top level is always packed from left to right. <br>  Compression Part Fit: For each rectangle packed on the upper level, it is checked whether there is a space below it on the lower level.  If it is possible to move it to the lower level so that a part of it remains at the upper level, it moves (from here Part Fit - it can be partially ‚Äúpressed‚Äù into the previous level).  In this way, the overall height of the second level can be reduced.  More on the packaging, it does not radically affect.  In the first picture you can see a rectangle hanging between the levels - it was shifted. <br>  Compression Full Fit: For each rectangle packed to the top level, it is checked whether it can completely move down to the previous level.  Actually, if it can, it shifts.  This gives us a strategic advantage: the space thus freed up can be used for the next rectangle.  Unfortunately, the second picture does not contain such a situation, but on it you can see two failed. <br>  Compression Combo: Yes, yes, this is a combination of the two previous ones and, accordingly, a combination of their advantages.  The third drawing illustrates. <br><br><div class="spoiler">  <b class="spoiler_title">Algorithms CPF, CFF, CC</b> <div class="spoiler_text">  <b>Compression</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: i = 0;  H = 0
  2: open new bi-level
  3: packing on lower level is similar to BiNFL;  H + = h (lowerlevel)
  4: if there is a gap
  5: call 'pack on the upper level'
  6: end if
  7: print H and entire packing
 Procedure 'pack on the upper level'
  1: while there is an unpacked rectangle do
  2: if i ‚â• 3 and Li is the first rectangle packed then
  3: justify according to the shorter
           of the rectangles
  4: slide rectangle downwards if there is a sufficient space
           and go to 12
  5: else
  6: if i ‚â• 3 and Li is the second rectangle packed then
  7: right justify and go to 12
  8: else [rectangle does not fit]
  9: H + = h (upperlevel);  open new bi-level
 10: end if
 11: end if
 12: end while </pre><br><br>  <b>Compression Part Fit</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: i = 0;  H = 0
  2: open a new bi-level
  3: packing on lower level is similar to BiNFL;  H + = h (lowerlevel)
  4: if there is a gap
  5: call 'pack on the upper level'
  6: end if
  7: print H and entire packing
 Procedure 'pack on the upper level'
  1: while there is an unpacked rectangle do
  2: if h (Li)&gt; VerticalSpace and w (Li) ‚â§ HorizontalSpace then
  3: shift rectangle Li downwards;  go to 11
  4: else
  5: if h (Li) ‚â§ VerticalSpace and W - w (level) ‚â• w (Li) then
  6: left justify;  go to 11
  7: else [rectangle does not fit]
  8: H + = h (upperlevel);  open a new bi-level
  9: end if
 10: end if
 11: end while </pre><br><br>  <b>Compression Full Fit</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: i = 0;  H = 0
  2: open a new bi-level
  3: packing on lower level is similar to BiNFL;  H + = h (lowerlevel)
  4: if there is a gap
  5: call 'pack on the upper level'
  6: end if
  7: print H and entire packing
 Procedure 'pack on the upper level'
  1: while there is an unpacked rectangle do
  2: if h (Li) ‚â§ VerticalSpace and w (Li) ‚â§ HorizontalSpace then
  3: slide rectangle Li downwards;  go to 11
  4: else
  5: if h (Li) ‚â§ VerticalSpace and W - w (level) ‚â• w (Li) then
  6: left justify;  go to 11
  7: else [rectangle does not fit]
  8: H + = h (upperlevel);  open new bi-level
  9: end if
 10: end if
 11: end while </pre><br><br>  <b>Compression combo</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: i = 0;  H = 0
  2: open a new bi-level
  3: packing on lower level is similar to BiNFL;  H + = h (lowerlevel)
  4: if there is a gap
  5: call 'pack on the upper level'
  6: end if
  7: print H and entire packing
 Procedure 'pack on the upper level'
  1: while there is an unpacked rectangle do
  2: if w (Li) ‚â§ HorizontalSpace then
  3: slide rectangle Li downwards;  go to 11
  4: else
  5: if w (Li)&gt; HorizontalSpace and W - w (level) ‚â• w (Li) then
  6: left justify, go to 11
  7: else [rectangle does not fit]
  8: H + = h (upperlevel);  open new bi-level
  9: end if
 10: end if
 11: end while </pre></div></div><br><br><h2>  Online fit </h2><img src="https://habrastorage.org/storage2/f5a/3fd/305/f5a3fd305bf2d576e01e5df1a9235c4f.png" align="right"><br>  More time-consuming method than previous ones, but also more productive.  Based on the Burke algorithm for an <a href="http://habrahabr.ru/post/136225/">offline</a> variant of the task.  Some aspects I, perhaps, draw. <br><br><img src="https://habrastorage.org/storage2/e68/610/8c1/e686108c1272cd63e1f43b4717dffdb5.jpg" align="left"><img src="https://habrastorage.org/storage2/571/206/9c1/5712069c1883e4ff0c1657caf087ceb6.jpg" align="left"><br><br>  During the packaging, Empty Areas may form, which the algorithm will try to fill in first.  How they can be formed can be seen in the photo on the left.  Note that for this you need to store a certain representation of the fullness of the band. <br>  After filling out from an empty area, it may turn out to be two (or it may not, you know). <br><br><img src="https://habrastorage.org/storage2/7dc/8f1/c28/7dc8f1c286a0f19999971da7ba8f348b.jpg" align="left"><img src="https://habrastorage.org/storage2/2cb/eb0/ea4/2cbeb0ea43fdd3673ba4e59663f10c84.jpg" align="left">  Also, several areas can be created in one step at a time ‚Äî the space below the rectangle is analyzed vertically and divided by the number of ‚Äústeps‚Äù.  On the middle photo, once again shows the division of the empty area into two after packing a rectangle there (by the way, it seems to me that in this place it would be better to split it <i>horizontally</i> ). <br>  In general, the farther into the forest, the more voids.  At each step, the rapidly shallowing voids are closely examined.  Here I see another optimization: you can enter a measure of appropriate area and discard unwanted ones. <br><br><img src="https://habrastorage.org/storage2/8aa/4ff/087/8aa4ff08741e3411e04f1bda24fa7630.jpg" align="right">  If none of the empty areas match, the packaging continues with the Burke method.  I remember.  A height map for the strip is constructed, and the rectangle is tried on the lowest area at the moment.  If he does not enter there, the low place is ‚Äúfilled‚Äù to the level of the nearest step, and the search is repeated.  So a potential place can be pushed to the very top, and then there is another option for the formation of empty space (see right). <br>  The same elevation map is used at each step to identify empty areas. <br><br>  In general, everything has been said.  First we try to pack in empty areas, then in the lowest place, and last of all - from above, a degenerate case of the ‚Äúlowest place‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">OF algorithm</b> <div class="spoiler_text">  <b>Online fit</b> <br><pre>  Input: The dimensions of the rectangles {w (Li);  h (Li)} and the strip width W.
 Output: The height H and the packing.
  1: i = 0;  H = 0
  2: Create a linear array number of elements are equal to W
  3: while there is an unpacked rectangle do
  4: i ++
  5: Li
  6: if w (EmptyArea) ‚â• w (Li) and h (EmptyArea) ‚â• h (Li) then
  7: pack rectangle in empty area
  8: else
  9: If the area is empty
 10: Search for linear array for packing width
 11: else [there is a space in linear array]
 12: pack rectangle on top left justified
              from the index leading to smaller space
 13: end if
 14: end if
 15: end while
 16: H = highest entry in the linear array
 17: print H and entire packing </pre></div></div><br><br><h2>  Afterword </h2><br>  To dispel the sense of purposelessness of what is happening, I will give one of the classic, but inspiring examples of the application of algorithms for two-dimensional packaging in a semi-unlimited band.  This is a task scheduler for a multiprocessor system.  In modern software for clusters, more ‚Äúadult‚Äù algorithms are used, but the <a href="http://en.wikipedia.org/wiki/Multiprocessor_scheduling">planning task</a> itself is reduced to 2DSP.  Under the conditions of clusters, the flow of incoming tasks is nothing more than online data for packaging: the horizontal dimension is the required number of cores, the vertical is the task time.  (Everything is like at the dawn of technology: you get in line to the computer and you warn in advance how much resources you need and how long your card will turn).  The scheduler must allocate specific processors for the task and determine the launch moment.  In its pure form, by the way, no algorithm can be used, as time drips while the scheduler is waiting for a task or is thinking about its placement.  Additionally, the programmer can be tied by hands with different specific conditions: the priority of tasks;  the ability to scale the task at runtime;  hardware delays and system self-service, including redistribution taking into account failed resources;  comparison of the nature of communications within the task with the cluster architecture, etc. <br>  Any algorithm is beautiful in its mathematical rigor, until you start to apply it to real life. <br><br>  And finally, the comparative characteristics of the algorithms in a pleasant, impersonal form.  Here is the ratio of the optimal packing height (the sum of the areas of the rectangles divided by the width of the strip) to the resulting. <br><table><tbody><tr><th>  NFL </th><th>  Ffl </th><th>  Bfl </th><th>  BiNFL </th><th>  Nfs </th><th>  Ffs </th><th>  Bfs </th><th>  HS </th><th>  Azar <sub>y</sub> </th><th>  CPF </th><th>  CFF </th><th>  CC </th><th>  Of </th></tr><tr><td>  0.56 </td><td>  0.63 </td><td>  0.75 </td><td>  0.56 </td><td>  0.45 </td><td>  0.57 </td><td>  0.57 </td><td>  0.37 </td><td>  0.44 </td><td>  0.60 </td><td>  0.59 </td><td>  0.63 </td><td>  0.72 </td></tr></tbody></table><hr><br>  Code (Qt): <br>  Algorithms <a href="http://pastebin.com/XtdEHAR6">packager.h</a> <a href="http://pastebin.com/eGXRZ65c">packager.cpp</a> <br>  Gui <a href="http://pastebin.com/iqFU7Qg2">window.h</a> <a href="http://pastebin.com/qWk7q7EX">window.cpp</a> <a href="http://pastebin.com/4m2DW4S0">renderarea.h</a> <a href="http://pastebin.com/s0QkUeq5">renderarea.cpp</a> <a href="http://pastebin.com/LMpUBUEj">main.cpp</a> </div><p>Source: <a href="https://habr.com/ru/post/160869/">https://habr.com/ru/post/160869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160859/index.html">Friday post good: good Samsung affairs in Brazil and Vietnam</a></li>
<li><a href="../160861/index.html">Query optimization in SQLite. Use rowid</a></li>
<li><a href="../160863/index.html">Project Engineer's Diaries: challenge accepted!</a></li>
<li><a href="../160865/index.html">Microsoft added 121 terabytes of satellite and aerial images to Bing Maps</a></li>
<li><a href="../160867/index.html">The Living Dead Skinvertizing</a></li>
<li><a href="../160871/index.html">Do I need to study at university?</a></li>
<li><a href="../160873/index.html">LED line in printers</a></li>
<li><a href="../160877/index.html">I-Bolit Team Presentation</a></li>
<li><a href="../160879/index.html">Homemade X-ray scanner</a></li>
<li><a href="../160881/index.html">AWS Command Line Tools updater</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>