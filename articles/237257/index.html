<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Centrifuge - I will no longer update the page before posting a comment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time has passed since I wrote about Centrifuge the previous time. There have been many changes during this period. Much of what was described in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Centrifuge - I will no longer update the page before posting a comment</h1><div class="post__text post__text-html js-mediator-article">  Some time has passed since I wrote about <a href="https://github.com/FZambia/centrifuge">Centrifuge</a> the <a href="http://habrahabr.ru/company/mailru/blog/197044/">previous</a> time.  There have been many changes during this period.  Much of what was described in earlier articles ( <a href="http://habrahabr.ru/post/184262/">1</a> , <a href="http://habrahabr.ru/company/mailru/blog/194640/">2</a> ) has sunk into oblivion, but the essence and idea of ‚Äã‚Äãthe project remain the same - this is the server for sending real-time messages to users connected from a web browser.  When an event occurs on your site, about which you need to instantly inform some of your users, you post this event in Centrifuge, and she, in turn, sends it to all interested users who subscribe to the desired channel.  In its simplest form, this is shown in the diagram: <br><br> <a href="http://habrahabr.ru/company/mailru/blog/237257/"><img src="https://habrastorage.org/files/d60/98a/e49/d6098ae49e5e4c44891dc4cec943e907.png"></a> <br><br>  The project is written in Python using the Tornado asynchronous web server.  You can use it even if the backend of your site is not written in Python.  I would like to tell you that the centrifuge is at the moment. <br><a name="habracut"></a><br> <a href=""><img src="https://habrastorage.org/files/33a/0c8/efa/33a0c8efa5f1414fbaf738fbbae5513e.gif"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Trying a project in action is a snap if you are familiar with installing Python packages.  Inside virtualenv: <br><br><pre><code class="bash hljs">$ pip install centrifuge</code> </pre> <br>  Run: <br><br><pre> <code class="bash hljs">$ centrifuge</code> </pre> <br>  After that, the administrative interface of the Centrifuge process that you just launched will be available at <a href="http://localhost:8000/">http: // localhost: 8000</a> . <br><br>  Especially for the article, I launched the Centrifuge instance on Heroku - <a href="http://habrifuge.herokuapp.com/">habrifuge.herokuapp.com</a> .  Password - habrahabr.  I hope for your honesty and prudence - the demo is in no way protected from attempts to break everything and prevent others from appreciating the project.  Launched on a free dino with all the consequences.  Heroku, of course, is not the best place to host this kind of applications, but for demonstration purposes it will do. <br><br>  I think I will not be far from the truth if I say that Centrifuge has no analogs, at least in the open-source world of Python.  Let me explain why I think so.  There are plenty of ways to add real-time events to the site.  From what comes to mind: <br><br><ul><li>  stand alone asynchronous server; </li><li>  cloud service (pusher.com, pubnub.com); </li><li>  gevent (gunicorn, uwsgi); </li><li>  Nginx modules / extensions; </li><li>  BOSH, XMPP. </li></ul><br>  In JavaScript, there is Meteor, Derby - a completely different approach.  There is also a wonderful Faye server that easily integrates with your JavaScript or Ruby backend.  But this solution is for NodeJS and Ruby.  The centrifuge implements the first approach listed above.  The advantage of a stand-alone asynchronous server (and cloud service) is that you do not need to change the code and philosophy of the existing backend, which will inevitably happen as soon as you decide to use Gevent, for example, to patch the standard Python libraries.  The approach with a separate server makes it easy and painless to integrate real-time messages into the existing backend architecture. <br><br>  The disadvantage is that the output with a similar architecture results in a slightly ‚Äútrimmed‚Äù real-time.  Your web application must withstand HTTP requests from clients that generate events: new events are initially sent to your backend, validated, stored in the database, if necessary, and then sent to Centrifuge (at pusher.com, pubnub.com and others).  However, in most cases, this restriction does not affect the tasks of the web; dynamic real-time games can suffer from this, where one client generates a very large number of events.  For such cases, perhaps, we need a closer integration of real-time applications and backends, perhaps something like gevent-socketio.  If the events on the site are not generated by the client, but by the backend itself, then in this case, the disadvantage voiced above does not matter. <br><br>  Saying that there are no centrifuges in the open-source world of Python, I do not mean that there is no other implementation of a stand-alone server for sending messages via web sockets and polyfills to them.  I just did not find any such project, fully from the box solves most of the problems of real use. <br><br>  Typing in the search engine " <i>python real-time github</i> " you get a lot of links to examples of such servers.  But!  Most of these results only demonstrate an approach to solving the problem, without going deep.  You are missing one process and you need to scale the application somehow - well, if the project documentation says that you need to use PUB / SUB broker for this purpose ‚Äî Redis, ZeroMQ, RabbitMQ ‚Äî this is true, but you will have to implement it yourself.  Often, all such examples are limited to a set type class variable, to which new connection objects are added and sending a new message to all clients from this connection set. <br><br>  The main purpose of the Centrifuge is to provide out of the box solution to real-use problems  Let's look at some points that will have to deal more. <br><br><h1>  Polyphilli </h1>  Alone webboxes are not enough.  If you do not believe, watch a speech with the saying title ‚ÄúWebsuckets‚Äù from one of the Socket.io developers.  Here are the <a href="https://speakerdeck.com/3rdeden/websuckets">slides</a> .  And here is the video: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ni9Ugmj3feQ%3Ffeature%3Doembed&amp;xid=25657,15700022,15700043,15700186,15700190,15700253&amp;usg=ALkJrhjoHHv_mlJMKss-c2Lp2g5F4AbIwQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Of course, there are projects (again, dynamic real-time games) for which the use of web sockets is critical.  The centrifuge uses SockJS to emulate web sockets in older browsers.  This means browser support up to IE7 using transports such as xhr-streaming, iframe-eventsource, iframe-htmlfile, xhr-polling, jsonp-polling.  For this, a wonderful implementation of SockJS server is <a href="https://github.com/mrjoes/sockjs-tornado">used</a> - <a href="https://github.com/mrjoes/sockjs-tornado">sockjs-tornado</a> . <br><br>  It is also worth noting that you can also connect to the Centrifuge using ‚Äúclean‚Äù web sockets - without wrapping the interaction in the SockJS protocol. <br><br>  There is a JavaScript client in the repository with a simple and clear API. <br><br><h1>  Scaling </h1>  You can run several processes - they will communicate with each other using Redis PUB / SUB.  I would like to note that Centrifuge does not claim to be installed inside huge sites with millions of visitors.  Perhaps, for such projects you need to find another solution - the same cloud services or your own development.  But for the vast majority of projects, several instances of the server behind the balancer, connected by the Redis PUB / SUB mechanism, will be more than enough.  We have, for example, one instance (Redis is not needed in this case) withstands 1000 simultaneous connections without problems, the average message sending time is less than 50 ms. <br><br>  Here, by the way, is a graph from Graphite for the weekly period of Centrifuge operation used by the Mail.Ru Group intranet.  The blue line is the number of active connections, the green line is the average message distribution time in milliseconds.  In the middle - the weekend.  :) <br><br><img src="https://habrastorage.org/files/ae7/476/45a/ae747645a91a4b19ab85ec2af5bf7a29.png"><br><br><h1>  Authentication and authorization </h1>  By connecting to Centrifuge, you use symmetric encryption based on the project's private key to generate a token (HMAC).  This token is validated upon connection.  Also, when connected, the user ID and, if desired, additional information about it are transmitted.  Therefore, Centrifuge knows enough about your users to handle connections to private channels.  This mechanism is inherently very similar to <a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html">JWT</a> (JSON Web Token). <br><br>  I would like to mention one of the recent innovations.  As I told in previous articles, if a client subscribes to a private channel, the Centrifuge will send a POST request to your application, asking if a user with such an ID can connect to a specific channel.  Now it is possible to create a private channel, when subscribing to which your web application will not be involved at all.  Just name the channel at your convenience and at the end after the special character # write the user ID, which is allowed to subscribe to this channel.  Only the user with ID 42 will be allowed to subscribe to this channel: <br><br><pre> <code class="javascript hljs">news#<span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br>  And you can do it like this: <br><br><pre> <code class="javascript hljs">dialog#<span class="hljs-number"><span class="hljs-number">42</span></span>,<span class="hljs-number"><span class="hljs-number">56</span></span></code> </pre> <br>  This is a private channel for 2 users with ID 42 and 56. <br><br>  In recent versions, the connection expiration mechanism has also been added - it is turned off by default, since it is not needed for most projects.  The mechanism should be considered as experimental. <br><br>  Perhaps, in the development process of the project, there were two most difficult solutions: how to synchronize the state between several processes (the simplest way was to choose - using Redis) and the problem with clients who connected to the Centrifuge before they were deactivated (banned, deleted) in web application. <br><br>  The difficulty here is that the Centrifuge does not store anything at all except the settings of projects and the namespaces of projects in the permanent storage.  Therefore, it was necessary to think of a way to reliably disable non-valid clients, without being able to save the identifiers or tokens of these clients, taking into account possible centrifuges and web applications downtime.  This method was eventually found.  However, to apply it in a real project has not yet happened, hence the experimental status.  I will try to describe how the solution works in theory. <br><br>  As I described earlier, in order to connect to the Centrifuge from the browser, you need to transfer, in addition to the connection address, some required parameters - the current user ID and the project ID.  Also in the connection settings there must be an HMAC token generated based on the project's secret key on the backend of the web application.  This token confirms the correctness of the parameters passed by the client. <br><br>  The trouble is that earlier, once having received such a token, the client could easily use it in the future: subscribe to public channels, read messages from them.  Fortunately, do not write (since the messages initially pass through your backend)!  This is a normal situation for many public sites.  Nevertheless, I was sure that an additional data protection mechanism was needed. <br><br>  Therefore, among the required parameters when connecting appeared parameter <code>timestamp</code> .  This is Unix seconds ( <code>str(int(time.time()))</code> ).  This <code>timestamp</code> also involved in the generation of the token.  That is, the connection now looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centrifuge = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Centrifuge({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'http://localhost:8000/connection'</span></span>, <span class="hljs-attr"><span class="hljs-attr">token</span></span>: <span class="hljs-string"><span class="hljs-string">'TOKEN'</span></span>, <span class="hljs-attr"><span class="hljs-attr">project</span></span>: <span class="hljs-string"><span class="hljs-string">'PROJECT_ID'</span></span>, <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'USER_ID'</span></span>, <span class="hljs-attr"><span class="hljs-attr">timestamp</span></span>: <span class="hljs-string"><span class="hljs-string">'1395086390'</span></span> });</code> </pre><br>  In the project settings, an option appeared that answers the question: how many seconds should a new connection be considered correct?  The centrifuge periodically searches for compounds that have expired and adds them to a special list (actually set) for testing.  Once a certain time interval, the Centrifuge sends a POST request to your application with a list of user IDs that need to be verified.  The application responds by sending a list of user IDs that did not pass this check ‚Äî these clients will be immediately forcibly disconnected from the Centrifuge, while there will be no automatic reconnect on the client side. <br><br>  But not everything is so simple.  There is a possibility that the ‚Äúattacker‚Äù, having corrected, for example, JavaScript on the client, will instantly reconnect after being forcibly expelled.  And if the <code>timestamp</code> in its connection parameters is still valid, the connection will be accepted.  But on the next verification cycle, after its connection expires, its ID will be sent to the web application using the same mechanism, it will say that the user is invalid, and after that it will be disabled forever (since the <code>timestamp</code> has already expired).  That is, there is a small gap in time during which the client has the opportunity to continue reading from public channels.  But its value is configured - I think it is not at all scary if, after the actual deactivation, the user can still read messages from the channels for some time. <br><br>  Perhaps using the scheme to understand this mechanism will be much easier: <br><br><img src="https://habrastorage.org/files/f31/b9c/dae/f31b9cdae5d84a368aa1c27e81786965.png"><br><br><h1>  Depla </h1>  In the repository there are examples of real configuration files that we use for deploying Centrifuges.  We run it on CentOS 6 for Nginx under the supervisor (Supervisord).  There is a spec-file - if you have CentOS, then you can build rpm based on it. <br><br><h1>  Monitoring </h1>  The latest version of Centrifuge has the ability to export various metrics to Graphite via UDP.  Metrics are aggregated at a given time interval, √† la StatsD.  Above the text was just a picture with a graph from Graphite. <br><br>  In the previous article about Centrifuge, I told you that it uses ZeroMQ.  And the comments were unanimous - ZeroMQ is not needed, use Redis, the performance of which is enough with the head.  At first I thought a bit and added Redis as an optional PUB / SUB backend.  And then there was this benchmark: <br><br><img src="https://habrastorage.org/files/88f/d4d/a32/88fd4da32f784c96bbaf1f55264b2009.png"><br><br>  I was surprised, really.  Why was ZeroMQ so much worse for my tasks than Redis?  I do not know the answer to this question.  Searching on the Internet, I found an article where the author also complains that ZeroMQ is not suitable for fast real-time web.  Unfortunately, now I have lost the link to this article.  As a result, ZeroMQ in the Centrifuge is no longer used, only 2 so-called engines remain - Memory and Redis (the first one is suitable if you run one Centrifuge instance, and Redis and its PUB / SUB are not for you). <br><br>  As you could see on the gif above, the web interface has not disappeared anywhere, it is still used to create projects, change settings, monitor messages in some channels.  Through it, you can also send commands to the Centrifuge, for example, post a message.  In general, it was before, I just decided to repeat, if you suddenly do not know. <br><br>  From other changes: <br><br><ul><li>  MIT license instead of BSD; </li><li>  neymspeys refactoring: now it is not a separate entity and field in the protocol, but simply a prefix in the channel name, separated by a colon ( <code>public:news</code> ); </li><li>  JavaScript client improvements </li><li>  Work with JSON can now be significantly accelerated if the ujson module is additionally installed; </li><li>  organization <a href="https://github.com/centrifugal">Centrifugal</a> on GitHub - with repositories related to the project, in addition to the Python client for Centrifuge - there is now including an example of how to deploy the project on Heroku and the first version of the adjacent library - a small wrapper for integration with Django (simplifies life with generating parameters connections, there are methods for conveniently sending messages to the Centrifuge); </li><li>  corrected / expanded <a href="http://centrifuge.readthedocs.org/en/latest/">documentation</a> in accordance with the changes / additions; </li><li>  many other changes are reflected in the <a href="">changelog</a> . </li></ul><br>  As <a href="http://habrahabr.ru/company/mailru/blog/232577/">mentioned</a> earlier in the Mail.Ru Group blog on Habr√©, the centrifuge is used in our corporate intranet.  Real-rime messages have added usability, colors and dynamics to our internal portal.  Users do not need to update the page before posting a comment (no need to update, no need to update ...) - isn't this great? <br><br><h1>  Conclusion </h1>  Like any other solution, you need to use the Centrifuge wisely.  This is not a silver bullet, you need to understand that by and large it is only a message broker, whose only task is to keep connections with customers and send them messages. <br><br>  Do not wait for a guaranteed message delivery to the client.  If, for example, a user opens a page, then plunges his laptop into a dream, then when he ‚Äúwakes up‚Äù his machine, the connection with the Centrifuge will be re-established.  But all the events that occurred while the laptop was in sleep mode will be lost.  And the user needs to either update the page, or you should independently write the logic of reloading lost events from your backend.  You also need to remember that almost all objects (connections, channels, message history) are stored in RAM, so it is important to monitor its consumption.  One should not forget about the limits of the operating system for open file descriptors and increase them if necessary.  It is necessary to think about what channel to create in a given situation - private or public, with or without history, what should be the length of this story, etc. <br><br>  As I mentioned above, there are plenty of ways to add real-time to your site, you need to choose wisely, perhaps in your case, the option with a separate asynchronous server will not be more advantageous. <br><br>  PS In the late spring, I attended the python developers conference in St. Petersburg, Piter Py.  In one of the reports, the talk was about instant notifications to users that their task, which was performed asynchronously in Celery-worker, is ready.  The speaker said that they use Tornado and web sockets for this purpose.  Then followed a few questions about how it works in conjunction with Django, how it starts, what authorization ... The guys who asked those questions, if you read this article, give the Centrifuge a chance, it is great for such tasks. </div><p>Source: <a href="https://habr.com/ru/post/237257/">https://habr.com/ru/post/237257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237245/index.html">Fujitsu Fast Track for Microsoft Private Cloud</a></li>
<li><a href="../237247/index.html">5 lessons that we learned at Tolstoy Startup Camp</a></li>
<li><a href="../237249/index.html">Smart Matter</a></li>
<li><a href="../237251/index.html">Apple has ceased to store user keys on its server</a></li>
<li><a href="../237255/index.html">Testing Adobe AIR applications in the HockeyApp system</a></li>
<li><a href="../237259/index.html">Multithreaded proxy on Perl, or how to buy on books.ru conveniently</a></li>
<li><a href="../237261/index.html">Interview with coworking inventor</a></li>
<li><a href="../237263/index.html">ITIL for developers</a></li>
<li><a href="../237265/index.html">Khan Academy has developed a quick javascript library for working with mathematical formulas.</a></li>
<li><a href="../237267/index.html">A tale about how we printed a t-shirt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>