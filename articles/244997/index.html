<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Core PCI-express in Achronix FPGA - quick start</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post was written to show developers of FPGA design how to start working with the PCI-express bus on the Ahronix Speedster22i platform with the le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Core PCI-express in Achronix FPGA - quick start</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/df5/672/48b/df567248b8fa444a834633c86f7b55a1.jpg"><br><br>  This post was written to show developers of FPGA design how to start working with the <i>PCI-express</i> bus on the <i>Ahronix Speedster22i</i> platform with the least amount of time and effort.  The article describes the organization of the project, the adaptation of which to the specific requirements of the developer is reduced to a simple modification of the source text of just one module, which allows you to connect to the host's <i>PCIe</i> bus in literally 1 hour.  Hopefully, developers on other platforms will find this article just as interesting. <br><a name="habracut"></a><br><br>  The <i>Speedster22i HD1000</i> FPGA has two <i>PCIe</i> hardware cores certified by <i><a href="">PCI-SIG</a></i> compliant with the <i>PCIe 3.0</i> specification, and the <i>Speedster22i HD1000 Development Kit</i> (which I wrote about in a previous <a href="http://habrahabr.ru/post/231007/">post</a> ) has one of these cores connected to the <i>PCIe</i> connector.  Through the <i>PCIe</i> interface it is very convenient to interact with the debug board with the host computer.  In fact, this is the only high-speed solution for this purpose.  An alternative to using <i>PCIe</i> for communicating a debug card with a host computer can only be the built-in com port, which is several orders of magnitude slower.  All other solutions require more or less hardware sophistication; at a minimum, signal level converters will be required. <br>  <i>Achronix</i> has a reference design that demonstrates how the <i>PCIe</i> hardware core works in all its glory - the kernel works in <i>target</i> mode with access both to the <i>CPU</i> itself and through the <i>DMA</i> mechanism for reading and writing.  I checked, everything works fine.  But this design turned out to be quite difficult to modify for its own purposes due to insufficient modularity and excessive complexity of the code in the <i>Verilog language</i> .  Therefore, it was decided on the basis of corporate design to create your own version, removing from it everything related to the exchange via <i>DMA</i> , as well as structuring it in such a way as to explicitly select in it modules with unchangeable code and modules whose code needs to be modified in order to adapt to specific tasks of the developer.  The result was a simple, well-structured project, the adaptation of which for the specific tasks of the developer comes down to a simple change in the code of just one module. <br>  <i>Achronix's FPGA</i> feature is the presence of hardware-implemented IP cores of controllers of such interfaces as <i>PCIe</i> , <i>DDR3</i> , <i>100/40 / 10G Ethernet</i> and <i>Interlaken</i> .  These hardware cores provide everything that is necessary for the operation of these interfaces, the only thing that is required of the developer is to write your own interface modules with these controllers.  As a result, the amount of work is dramatically reduced.  In addition, the achievement of the required timing is greatly simplified.  In the case of a <i>PCIe</i> design, it took just a few interface modules, most of which were taken from proprietary reference design. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><h2>  Brief description of the project </h2><br>  The project has access to three 128-bit registers.  <i>The PCIe</i> core is configured for 3 BARs: BAR0 - 64KB, BAR1 and BAR2 - 8 KB each.  Access to registers is carried out through BAR1.  The presence of 3 BARs is due to compatibility requirements with the driver used.  A description of the registers is given below: <br><br><table><tbody><tr><th>  Name </th><th>  Offset in AP BAR1 </th><th>  type of </th><th>  Description </th></tr><tr><td>  R0 </td><td>  0 </td><td>  RO </td><td>  {4 {32'hDEADBEEF}} </td></tr><tr><td>  R1 </td><td>  20h </td><td>  Rw <br>  Rw </td><td>  Bits [7: 0] - output to the line of LEDs <br>  Bits [127: 8] - not used </td></tr><tr><td>  R2 </td><td>  40h </td><td>  RO <br>  Rw </td><td>  Bits [7: 0] - reading the switch range <br>  Bits [127: 8] - not used <br></td></tr></tbody></table><br><br>  When upgrading the project, the first thing that was done was to delete the code associated with the exchange of data through <i>DMA</i> .  After that, the read and write <i>channels target_read</i> and <i>target_write</i> were used to connect to the kernel.  Further, the structure of the modules shown in the figure was determined: <br><img src="https://habrastorage.org/files/81e/c4f/29d/81ec4f29d1de4a2bae1b5e2b43a32db0.png"><br><br>  A total of 4 modules turned out (some of them include submodules) <br><br>  The composition of the modules: <br><ul><li>  <i>pcie_g3x4.v</i> is a wrapper for the <i>PCIe</i> hardware core.  It determines its parameters, such as <i>VendorID</i> , the number of lanes, the width of the local bus, etc. This module is generated using the kernel of the <i>ACE</i> development environment. </li><li>  <i>pci_target_bus_ctrl.v</i> is a wrapper module that matches the <i>target</i> channel of the hardware core and the local bus on which the registers are located that are accessible via the <i>PCI bus</i> .  Since the <i>target</i> channel consists of two independent subchannels: write and read, this module combines two modules: <i>pci_target_bus_write_ctrl.v</i> and <i>pci_target_bus_read_ctrl.v</i> , implementing write and read operations, respectively. </li><li>  <i>lbus_registers.v</i> is the module containing the user registers themselves.  The only module that requires modification of the code for a specific project. </li><li>  <i>ACX_SNAPSHOT.v</i> is an auxiliary module for in-circuit debugging.  At the end of debugging can be excluded from the project. </li></ul><br><br>  In this project, to achieve the necessary developer functionality, it is required to change the source code of just one module - <i>lbus_registers.v</i> .  All other modules are used as is, without any alteration.  At the same time, the <i>lbus_registers.v</i> module can be used as a template to which the developer needs the functionality.  Thus, in order to get a working interface with several registers on a <i>PCIe bus</i> , the time required to write the module code is no more than an hour. <br><br><br><h2>  PCIe kernel generation </h2><br>  To generate a kernel, you can use the ACE shell generator.  All specified parameters are saved in a file with the .axip extension, which can be edited at any time.  The result of the generator are text files in <i>Verilog</i> and <i>VHDL</i> .  A screenshot of the kernel generation process is shown below: <br><br><img src="https://habrastorage.org/files/3b1/c60/581/3b1c60581dfb49059d3c8773a79d6970.png"><br><br><h3>  Pcie kernel target interface </h3><br>  The PCI hardware core includes several interfaces, but we are interested in the target interface.  Registers acting as passive devices are connected via this interface, and the processor acts as an active device.  The target interface consists of 4 channels: set the write address, write data, set the read address and read data.  The writing and reading channels operate independently of each other.  Below are timing charts of write and read transactions.  The same diagrams show local bus signals. <br><img src="https://habrastorage.org/files/85e/50f/f84/85e50ff849c347d48380c98a779cc07c.png"><br><br><h3>  Local bus </h3><br>  The local bus has a very simple structure.  It consists of two independent channels - writing and reading and can be configured to different word widths.  This project uses 128-bit words. <br>  The local bus interface implemented in the <i>lbus_registers.v</i> module <i>provides</i> for writing to the registers without delay and reading with a delay of 1 clock cycle.  The real delays, however, are somewhat higher, since  submodules included in the <i>pci_target_bus_ctrl.v</i> module contribute to the latency of write and read transactions. <br><br><br><h2>  Implementation </h2><br>  The implementation of the project consists of two stages - the synthesis phase and the trace phase. <br><br><h3>  Directory structure </h3><br>  The following directory organization was chosen for implementation: <br><pre> pci_simple
     | --- src
     | --- syn
     | --- tr
     | --- tools
</pre><br><br>  The <i>src</i> directory contains source files in the <i>Verilog language</i> .  The <i>syn</i> directory contains the files needed for synthesis using the <i>synplify</i> program, and the <i>tr</i> directory <i>contains the</i> files needed for the trace step.  Also in this directory by default are generated kernels.  The <i>tools</i> directory contains drivers and the <i>PciExpress</i> program, which can be used to read and write data to the registers connected to the <i>PCIe bus</i> . <br><br><h3>  Synthesis </h3><br>  The syn directory contains the <i>pcie_simple_design.prj</i> project <i>file</i> .  This file must be indicated by the <i>synopsys synplify-pro</i> synthesis program.  The result of this program is the <i>pcie_simple_design.vma</i> file in the <i>syn / rev_1 subdirectory</i> .  This file is input to the next stage - tracing.  A screen shot during the execution of the synthesis step is shown below: <br><br><img src="https://habrastorage.org/files/510/6d1/2e4/5106d12e4db94bd4a2fa408c23ab7a02.png"><br><br><h3>  Tracing </h3><br>  The tracing step is performed by <i>Achronix‚Äôs</i> own <i>ACE</i> program.  The <i>tr</i> directory contains the <i>pci-simple.prj</i> project file, which must be specified by the <i>ACE</i> program.  At the end of the tracing step, the <i>pci-simple-design.jam</i> firmware file will appear in the <i>tr / impl_1 / output</i> <i>subdirectory</i> , which is loaded directly into the FPGA.  Screenshot during tracing step: <br><br><img src="https://habrastorage.org/files/efd/09e/1a7/efd09e1a7ede4da290dea0aaddf4f3e3.png"><br><br><h3>  The counters </h3><br>  There are only two files of constraints - one describes the clock circuits, and the other defines the I / O pins used.  The files are in the <i>tr</i> directory and have the names <i>pcie_simple_design.sdc</i> and <i>pcie_simple_design.pdc,</i> respectively.  They are already connected through the project files to the synthesis and trace programs. <br><br><br><h2>  results </h2><br><br><h3>  Timing </h3><br><table><tbody><tr><th colspan="4">  Trace results </th></tr><tr><td></td><td colspan="2">  Frequency (MHz) </td><td></td></tr><tr><td>  Clock / Group </td><td>  Target </td><td>  Achieved </td><td>  Meets timing </td></tr><tr><td>  user_clk </td><td>  212.5 </td><td>  308.5 </td><td>  yes (+ 45.2%) </td></tr><tr><td>  core_clk </td><td>  212.5 </td><td>  433.5 </td><td>  yes (+ 104.0%) </td></tr><tr><td>  sbus_clk </td><td>  50.0 </td><td>  138.7 </td><td>  yes (+ 177.5%) </td></tr><tr><td>  Tck </td><td>  10.0 </td><td>  175.4 </td><td>  yes (+ 1653.6%) </td></tr></tbody></table><br><br>  We are interested in the user_clk clock group to which the user registers are connected.  As can be seen, at a given frequency of 212.5 MHz, a result of 308.5 MHz was achieved, i.e.  45% higher than required. <br><br><h3>  Recycling </h3><br><table><tbody><tr><th>  Resource </th><th>  Busy </th></tr><tr><td>  RLBs </td><td>  0.520% </td></tr><tr><td>  LUT4 Sites </td><td>  0.410% </td></tr><tr><td>  DFF Sites </td><td>  0.520% </td></tr><tr><td>  MUX2 Sites </td><td>  0.010% </td></tr><tr><td>  ALU Sites </td><td>  0.170% </td></tr><tr><td>  LRAM Sites </td><td>  1.280% </td></tr><tr><td>  BRAM Sites </td><td>  0.190% </td></tr><tr><td>  BMULT Sites </td><td>  0.000% </td></tr><tr><td>  I / O Pad Sites </td><td>  1.980% </td></tr><tr><td>  Data pads </td><td>  1.740% </td></tr><tr><td>  Clock pads </td><td>  12.50% </td></tr><tr><td>  Reset pads </td><td>  0.000% </td></tr></tbody></table><br><br><br><h2>  Connect to host computer </h2><br>  A driver is required to connect to the host computer.  Under certain conditions, you can use the driver from the corporate reference design.  With this driver, the application <i>PciExpress.exe works</i> , through which you can access registers connected to the <i>PCIe bus</i> .  To be able to use these tools, you need to preserve the structure of the BARs of the original design and save the values ‚Äã‚Äãof the <i>VendorID</i> and <i>DeviceID</i> parameters. <br><br>  To start working with a Windows host computer, you must perform the following steps: <br><ul><li>  Connect the debug board to the computer via the <i>PCIe bus</i> .  Requires a PCIe x8 slot or wider.  Connection should be made on switched off devices in compliance with antistatic protection measures.  The debug board is powered from an external power source. </li><li>  Turn on the power of the computer and the board.  The power on procedure is not significant. </li><li>  Download firmware to FPGA. </li><li>  Using the device manager, find a new device on the <i>PCI bus</i> and install a driver for it. </li><li>  Reboot </li><li>  After rebooting, using the <i>PciExpress</i> program, <i>you</i> can write / read registers. </li></ul><br><br>  The following figure shows the result of reading the register with an offset of 0 in the address space BAR1: <br><br><img src="https://habrastorage.org/files/d48/757/273/d48757273a414a2db2d3783983259ce3.png"><br><br><br><h2>  Customization of the lbus_registers.v module </h2><br>  In order for the source code to be used in your own projects, you need to enter into the design the registers needed by the developer.  All user registers are in the lbus_registers.v module and when customizing it, the following simple steps are required: <br><ol><li>  Write code for each user register </li><li>  Set the address of each register in the parameter list </li><li>  Write the address decoder code for each register </li><li>  Connect each register to write and read buses </li></ol><br><br>  We show how to implement these actions in practice. <br>  ‚Ä¢ Define the register name and its length: <br><pre><code class="vhdl hljs">reg [AXI_DATA_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] my_register;</code> </pre> <br>  ‚Ä¢ Define the read and write gates for this register: <br><pre> <code class="vhdl hljs">wire selw_my_register; wire selr_my_register;</code> </pre><br><br>  ‚Ä¢ Write an always-block for this register.  This is conveniently done using the <i>generate</i> statement. <br>  In the simplest case, the code looks like this: <br><pre> <code class="vhdl hljs">genvar i; <span class="hljs-keyword"><span class="hljs-keyword">generate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; AXI_BE_WIDTH; i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>: leds_lanes always @( posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge rst_n ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rst_n) my_register [<span class="hljs-number"><span class="hljs-number">7</span></span>+ <span class="hljs-number"><span class="hljs-number">8</span></span>*i: <span class="hljs-number"><span class="hljs-number">8</span></span>*i] &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selw_my_register &amp;&amp; lbus_wr_be[i] ) my_register[<span class="hljs-number"><span class="hljs-number">7</span></span>+ <span class="hljs-number"><span class="hljs-number">8</span></span>*i: <span class="hljs-number"><span class="hljs-number">8</span></span>*i] &lt;= lbus_wr_data[<span class="hljs-number"><span class="hljs-number">7</span></span>+ <span class="hljs-number"><span class="hljs-number">8</span></span>*i: <span class="hljs-number"><span class="hljs-number">8</span></span>*i]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> my_register [<span class="hljs-number"><span class="hljs-number">7</span></span>+ <span class="hljs-number"><span class="hljs-number">8</span></span>*i: <span class="hljs-number"><span class="hljs-number">8</span></span>*i] &lt;= my_register [<span class="hljs-number"><span class="hljs-number">7</span></span>+ <span class="hljs-number"><span class="hljs-number">8</span></span>*i: <span class="hljs-number"><span class="hljs-number">8</span></span>*i]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endgenerate</code> </pre><br><br>  If more complex processing of individual bits is required, then the always-block will naturally become more complicated and it may be easier to write the code explicitly without using the generate statement. <br>  ‚Ä¢ Add a line to the list of parameters: <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> ADDR_MY_REGISTER = <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h1234_5678</span></span></code> </pre>  , <br>  where - instead of <i>32'h1234_5678 we</i> specify the real offset in bytes in the required address space <br>  ‚Ä¢ We write formulas for register selection signals: <br><pre> <code class="vhdl hljs">selw_my_register = reg_wr_hit &amp; (lbus_wr_addr[REG_ADDR_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] == ADDR_MY_REGISTER [REG_ADDR_WIDTH+AXI_REMAIN_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:AXI_REMAIN_WIDTH]); selr_my_register = reg_rd_hit &amp; (lbus_rd_addr[REG_ADDR_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] == ADDR_MY_REGISTER [REG_ADDR_WIDTH+AXI_REMAIN_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:AXI_REMAIN_WIDTH]);</code> </pre> <br><br>  ‚Ä¢ In the always_comb block <br><pre> <code class="vhdl hljs">always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) ‚Ä¶ endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Add a new branch inside the case statement: <br><pre> <code class="vhdl hljs">selr_my_register: c_reg_rd_data = my_register;</code> </pre> <br><br>  The above steps are repeated for each user register. <br><br><h3>  Module interface </h3><br>  The module interface is defined as follows: <br><br><pre> <code class="vhdl hljs">module lbus_registers #( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BAR_NMB = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> AXI_DATA_WIDTH = <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> AXI_BE_WIDTH = AXI_DATA_WIDTH/<span class="hljs-number"><span class="hljs-number">8</span></span>, // AXI Len <span class="hljs-literal"><span class="hljs-literal">Width</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> LBUS_ADDR_WIDTH = <span class="hljs-number"><span class="hljs-number">12</span></span>, // <span class="hljs-number"><span class="hljs-number">64</span></span> KB expected <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> NWL Reference Design <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> REG_ADDR_WIDTH = LBUS_ADDR_WIDTH, // <span class="hljs-number"><span class="hljs-number">64</span></span> KB expected <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> NWL Reference Design <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> ADDR_R0 = <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000_0000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> ADDR_R1 = <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000_0020</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> ADDR_R2 = <span class="hljs-number"><span class="hljs-number">32</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h000_0040</span></span> ) ( input wire rst_n, input wire clk, // input wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] switches, output wire [AXI_DATA_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] rg1_out, output wire [AXI_DATA_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] rg2_out, output wire [<span class="hljs-number"><span class="hljs-number">71</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] debug_bus, // Local <span class="hljs-keyword"><span class="hljs-keyword">Bus</span></span> channel input wire [LBUS_ADDR_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_wr_addr, input wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_wr_region, input wire lbus_wr_en, input wire [AXI_BE_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_wr_be, input wire [AXI_DATA_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_wr_data, // input wire [LBUS_ADDR_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_rd_addr, input wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_rd_region, output wire [AXI_DATA_WIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lbus_rd_data );</code> </pre><br><br><h3>  Settings </h3><br>  The settings for the lbus_registers.v module are listed in the table: <br><table><tbody><tr><th>  Parameter name </th><th>  Default value </th><th>  Value range </th><th>  Description </th></tr><tr><td>  BAR_NMB </td><td>  3'd0 </td><td>  3'd0-3'd7 </td><td>  BAR number to which the address selector is configured </td></tr><tr><td>  AXI_DATA_WIDTH </td><td>  128 </td><td>  128, 256 </td><td>  Data bus size </td></tr><tr><td>  AXI_BE_WIDTH </td><td>  AXI_DATA_WIDTH / 8 </td><td>  - </td><td>  Do not change manually </td></tr><tr><td>  LBUS_ADDR_WIDTH </td><td>  12 </td><td>  8-15 </td><td>  Specifies the local address bus width.  Usually corresponds to the size of the AP of the largest BAR </td></tr><tr><td>  REG_ADDR_WIDTH </td><td>  LBUS_ADDR_WIDTH </td><td>  &lt;= LBUS_ADDR_WIDTH </td><td>  Sets the bit depth of the local address bus AP corresponding to the selected BAR </td></tr><tr><td>  ADDR_R0 <br>  ADDR_R1 <br>  ADDR_R2 </td><td>  32'h000_0000 </td><td>  Depends on BAR size </td><td>  Register address R0 (R1, R2).  Register addresses are always specified in bytes and correspond to their offset in the address space of the BAR </td></tr></tbody></table><br><br><br><h2>  Debugging </h2><br>  Debugging is performed using an internal signal analyzer, for which the project uses the <i>ACX_SNAPSHOT.v</i> module, which is <i>enabled</i> by the conditional compilation directive <i>`define USE_SNAPSHOT</i> .  Documentation on the organization of in-circuit debugging is located on the <i>Achronix</i> website in the <i>Snapshot User Guide.pdf</i> file. <br><br><br><h2>  Conclusion and conclusions </h2><br>  Even such a difficult task as connecting to the <i>PCI-express</i> bus is solved on the <i>Achronix Speedster22i</i> platform easily and, most importantly, quickly.  Creating a working project based on the <i>PCIe</i> hardware core was not easy, but very simple. <br>  The story about other hardware cores of the Achronix Speedster22i FPGA is planned as they are learned.  In subsequent posts will be told about the core <i>DDR-3</i> and <i>100G Ehernet</i> . <br><br><br><h2>  Links </h2><br>  1. Achronix announces the compliance of its PCI Express hardware cores in the FPGA Speedster22i to the PCI-SIG specification (English) <a href="http://www.achronix.com/wp-content/uploads/pr/2014_May_PCI-SIG.pdf">www.achronix.com/wp-content/uploads/pr/2014_May_PCI-SIG.pdf</a> <br>  2. HD1000 dev kit debug board (English) 22iHD1000_Development_Board_Schematic.pdf <br>  3. Guide to using PCIe controllers on Speedster22i (English) <a href="http://www.achronix.com/wp-content/uploads/docs/Speedster22i_PCIe_User_Guide_UG030.pdf">www.achronix.com/wp-content/uploads/docs/Speedster22i_PCIe_User_Guide_UG030.pdf</a> <br>  4. Snapshot User Guide (English) <a href="http://www.achronix.com/wp-content/uploads/docs/Speedster22i_Snapshot_User_Guide_UG016.pdf">www.achronix.com/wp-content/uploads/docs/Speedster22i_Snapshot_User_Guide_UG016.pdf</a> <br>  5. Original reference design: Speedster22i_PCIe_Demo_Design.zip <br>  6. The source files of the described project: <a href="https://drive.google.com/file/d/0B9Gt8fTYH6s-VGhfbk5RQWM4bk0">drive.google.com/file/d/0B9Gt8fTYH6s-VGhfbk5RQWM4bk0</a> </div><p>Source: <a href="https://habr.com/ru/post/244997/">https://habr.com/ru/post/244997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244987/index.html">Creating a virtual SSD for vSphere 5.5</a></li>
<li><a href="../244989/index.html">DNA Salesforce users: analysis of companies that use Salesforce CRM</a></li>
<li><a href="../244991/index.html">A brief introduction to trust, or why you can not run blindly without checking scripts from the Internet</a></li>
<li><a href="../244993/index.html">Kerio Connect 8.4 has been released</a></li>
<li><a href="../244995/index.html">Android 5.0 for Xperia Z Ultra Google Play Edition</a></li>
<li><a href="../244999/index.html">Kotlin for Android, or an easy way to stop programming in Java</a></li>
<li><a href="../245003/index.html">Educational series about marketing and sales issues in a studio / agency</a></li>
<li><a href="../245007/index.html">Go beyond the edge of the browser</a></li>
<li><a href="../245011/index.html">No cON Name CTF 2014 Final</a></li>
<li><a href="../245013/index.html">Split nodejs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>