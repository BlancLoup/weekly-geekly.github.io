<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Measurement of ore weight by stator current. Practice. Part 2. Software implementation at MK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The last part of the cycle "Measuring the weight of minerals . " This article will show the software implementation on the MC. 

 Recall the basics of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Measurement of ore weight by stator current. Practice. Part 2. Software implementation at MK</h1><div class="post__text post__text-html js-mediator-article">  The last part of the cycle <b>"Measuring the weight of minerals</b> . <b>"</b>  This article will show the software implementation on the MC. <br><br>  Recall the basics of this method of measuring the weight of minerals by the stator current of a mine lifting installation (silo), equipped with a high-voltage asynchronous motor with a phase-rotor. <br><ul><li>  <a href="https://habrahabr.ru/post/275141/">Theoretical basis.</a>  <a href="https://habrahabr.ru/post/275141/">Formula calculation.</a> </li><li>  <a href="https://habrahabr.ru/post/275459/">Practice.</a>  <a href="https://habrahabr.ru/post/275459/">Part 1. The signal processing algorithm in MK.</a> </li></ul><br><br><h4>  <b>Instead of the preface</b> </h4><br>  Since the real device was not designed or manufactured, the Proteus software was used to simulate this process.  This simulator supports many different MCs, and from the list of supported hardware, they chose a hardware platform for implementing the algorithm and testing the entire method. <br><a name="habracut"></a><br><h4>  <b>Foreword</b> </h4><br>  For the convenience of testing when simulating, the original circuit in the proteus shown in the <a href="https://habrahabr.ru/post/275141/">first part</a> has undergone changes.  Consider the changes. <br> <a href=""><img src="https://habrastorage.org/files/c06/5b9/034/c065b90344904f41b22a60125c18505b.JPG"></a> <br>  <i>The first sheet of the scheme.</i>  <i>The picture is clickable.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The changes affected the multiplication of the voltage signal, breaking the current circuit, the introduction of the inductive component into the load circuit. <br> <a href=""><img src="https://habrastorage.org/files/77b/b53/d11/77bb53d1187f484db109d1009cc616dd.JPG"></a> <br>  <i>The second sheet of the scheme.</i>  <i>The picture is clickable.</i> <br><br>  The ComPim component is used to communicate with the system port.  MK company Microchip.  Input signals from the first sheet.  Instruments (voltmeter, ammeter) for visual monitoring of voltage and current parameters.  Switches are used to automatically calculate the midpoint of the current and voltage channels. <br><br><h4>  <b>Introduction</b> </h4><br>  When writing a program for the PIC18F2580 MK, the free IDE MpLab X v 2.26 was used, the XC8 compiler v1.20. <br>  During the development of the program, I had to write my own mathematical functions: <br><br><ul><li>  extracting the square root of a 32-bit integer, </li><li>  taking the square root of a single-precision floating-point number, </li><li>  multiplication of unsigned integers by 16 bits, </li><li>  multiplication of integer signed numbers 16 bits. </li></ul><br><br>  The standard functions that the compiler uses are not suitable in terms of speed, this applies to 16x16 multiplication.  And there was no library function for extracting the square root from a whole 32-bit number. <br><br>  The project also used custom variable types.  They are introduced for ease of use. <br><br>  User-defined variable types are described in the user_type.h header. <br><br><h4>  <b>Initialization MK</b> </h4><br>  Initialization of MK is taken out in a separate module in the project.  It is made according to the datasheet on the MK.  Configuration bits are included in the initialization module header.  For MK data, these fuses can be stitched into the firmware, in the .hex file. <br><br>  Here is the leader. <br><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;xc.h&gt;</span></span></span><span class="hljs-meta"> /*     */ #pragma config IESO = OFF #pragma config OSC = HSPLL //HS oscillator, PLL enabled (Clock Frequency = 4 x FOSC1) #pragma config MCLRE = ON //MCLR pin enabled; RE3 input pin disabled #pragma config XINST = OFF //Instruction set extension and Indexed Addressing mode disabled (Legacy mode) #pragma config PBADEN = OFF //PORTB</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;4:0&gt;</span></span></span><span class="hljs-meta"> pins are configured as digital I/O on Reset /*      */ void INT_init(void); void T0_init(void); void ADC_init(void); void USART_init(int BAUD); void T2_init(void); void PIC_init(void);</span></span></code> </pre> <br><br>  We initialize the necessary periphery with our own function. <br><br>  Interruptions in this MK have priority.  There are only two levels: high and low.  Interruption from timer 0, by which we count time intervals (samples) for measuring voltage and current signals, has a high priority, since it is time-critical, the rest is low. <br><br><h4>  <b>Signal processing with ADC</b> </h4><br>  According to the interruption from the detector, which is initiated by the external interrupt INT1, we start a timer with a count of 200 Œºs interval.  By interrupting the timer, we load the preset values ‚Äã‚Äãinto it, for an accurate count, and read the ADC values ‚Äã‚Äãfrom both channels and perform preliminary calculations. <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Count_sample&lt;SAMPLE){ <span class="hljs-comment"><span class="hljs-comment">//      ADCON0bits.GO_DONE=1; //   while(ADCON0bits.GO_DONE); //  ADCON0bits.CHS0=0; //   I_adc.byte.HB=ADRESH; I_adc.byte.LB=ADRESL; //   I_int=(INT)I_adc.Val-I_0.Val; /* *         *   ,   *        88 *     ,  *    1616=32      , *    *  854  288     302   , *      *        ,    *     */ I_sum+=(SLONG)mul_int(I_int,I_int); ADCON0bits.GO_DONE=1; //   while(ADCON0bits.GO_DONE); //  ADCON0bits.CHS0=1; //      U_adc.byte.HB=ADRESH; U_adc.byte.LB=ADRESL; //   U_int=(INT)U_adc.Val-U_0.Val; U_sum+=(SLONG)mul_int(U_int,U_int); P_act+=(SLONG)mul_sint(U_int,I_int); Count_sample++; } if (Count_sample&gt;=SAMPLE){ // ,   Count_sample=0; Flag_izm=1; T0CONbits.TMR0ON=0; }</span></span></code> </pre><br><br>  In the main loop, <b>we</b> perform additional intermediate calculations <b>using the Flag_izm</b> flag. <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Flag_izm){ <span class="hljs-comment"><span class="hljs-comment">//  Flag_izm=0; if (Count_main_sample&lt;MAIN_SAMPLE){ U_d+=(SLONG)U_sum; U_sum=0; I_d+=(SLONG)I_sum; I_sum=0; P_m+=(SLONG)P_act; P_act=0; Count_main_sample++; } }</span></span></code> </pre><br><br><h4>  <b>ModBus RTU protocol</b> </h4><br>  In this implementation, communication with the "external" world is carried out using USART MK, on ‚Äã‚Äãtop of this interface the industrial protocol ModBus RTU is applied.  The implementation of this protocol is quite simple and not resource intensive.  Reception of messages is made in the interruption from the USART receiver <br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PIR1bits.RCIF){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RCSTAbits.FERR || RCSTAbits.OERR) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> RCSTAbits.CREN=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> RCSTAbits.CREN=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } MODBUS.rxtimer=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(MODBUS.rxcnt&gt;(BUF_SZ<span class="hljs-number"><span class="hljs-number">-2</span></span>)) MODBUS.rxcnt=<span class="hljs-number"><span class="hljs-number">0</span></span>; MODBUS.buffer[MODBUS.rxcnt++]=RCREG1; <span class="hljs-comment"><span class="hljs-comment">/*      ModBus*/</span></span> PIR1bits.RCIF=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }</code> </pre><br><br>  Processing of messages from the master occurs in the main loop when time-critical measurements are completed. <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Flag_izm){ <span class="hljs-comment"><span class="hljs-comment">//  ‚Ä¶ if (MODBUS.rxgap){ //   MODBUS_SLAVE(&amp;MODBUS); //  MODBUS.rxgap=0; } }</span></span></code> </pre><br><br>  USART transmission is not organized in a very optimal, blocking manner. <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/* *     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TX_FRAME(UART_DATA *MODBUS) { RCSTAbits.CREN=<span class="hljs-number"><span class="hljs-number">0</span></span>; TXSTAbits.TXEN=<span class="hljs-number"><span class="hljs-number">1</span></span>; INTCONbits.GIEH=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> INTCONbits.GIEL=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(MODBUS-&gt;txcnt&lt;MODBUS-&gt;txlen){ TXREG=MODBUS-&gt;buffer[MODBUS-&gt;txcnt++]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!PIR1bits.TXIF) NOP(); } INTCONbits.GIEH=<span class="hljs-number"><span class="hljs-number">1</span></span>; INTCONbits.GIEL=<span class="hljs-number"><span class="hljs-number">1</span></span>; MODBUS-&gt;txlen=<span class="hljs-number"><span class="hljs-number">0</span></span>; RCSTAbits.CREN=<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br><h4>  <b>Filling the register table ModBus</b> </h4><br>  The ModBus protocol allows the hardware developer to determine which registers in the card will be responsible for which parameter.  There are no hard rules in this matter.  So we will not invent something complicated and not rational. <br><br>  Let's start with the first register (zero).  Put in it the value of the effective voltage in the Real format, that is, the value will take up two 16-bit Modbus registers.  Further, the value of current, active power, total power, cosine. <br><pre> <code class="objectivec hljs"> res_table[<span class="hljs-number"><span class="hljs-number">0</span></span>].Val=U_real.word.LW; <span class="hljs-comment"><span class="hljs-comment">//   res_table[1].Val=U_real.word.HW; //,    res_table[2].Val=I_real.word.LW; res_table[3].Val=I_real.word.HW; res_table[4].Val=P_real.word.LW; res_table[5].Val=P_real.word.HW; res_table[6].Val=P_pol.word.LW; res_table[7].Val=P_pol.word.HW; res_table[8].Val=Cos_p.word.LW; res_table[9].Val=Cos_p.word.HW;</span></span></code> </pre><br>  Now, when requesting the master of the values ‚Äã‚Äãof these registers, the device will respond with quite adequate data. <br><br>  To display data from the device, at this stage, we will use the OPC server.  Its internal tools are enough to display data, write values ‚Äã‚Äãto registers, etc. <br><br><h4>  <b>Automatic determination of the midpoint of the channels and the calculation of coefficients</b> </h4><br>  For measurements, we need to calculate the average point of the sine wave voltage and current signals.  In this case, we will use the algorithm <a href="https://habrahabr.ru/post/275459/">described</a> in the <a href="https://habrahabr.ru/post/275459/">last article</a> . <br><br>  To automatically calculate the ADC0 channels, it is necessary to remove the useful signal from them, i.e.  break the current loop into which the ACS712 current sensor is connected and connect a midpoint with an op-amp to the voltage input.  Next, the algorithm will calculate the root-mean-square value of the signal, and upon a command from the master, we will add the calculated values ‚Äã‚Äãto ADC0 for each channel and write these values ‚Äã‚Äãto the EEPROM.  After that, we connect the voltage and current signals under study. <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MODBUS.write){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res_table[<span class="hljs-number"><span class="hljs-number">10</span></span>].Val==<span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-comment"><span class="hljs-comment">//   U_0.Val=(WORD)U_real.Val; // 0 I_0.Val=(WORD)I_real.Val; eeprom_write(0,U_0.byte.HB); //    eeprom_write(1,U_0.byte.LB); //0   eeprom_write(2,I_0.byte.HB); eeprom_write(3,I_0.byte.LB); } }</span></span></code> </pre><br>  To calculate the coefficients, we use the following procedure.  After calculating the midpoint of the channels, connecting the actual signals to the analog inputs, the algorithm calculates the root-mean-square value of the voltage and current in ADC units.  To convert them to physical quantities, it is necessary to measure these signals with instruments, a voltmeter and an ammeter.  The values ‚Äã‚Äãmeasured by the instruments are recorded in the necessary registers of Modbas, and upon a command from the master we perform the calculation of the coefficients.  To reduce the length of the parcel according to Modbas, in this implementation, the value from the devices is converted to an integer value by multiplying the voltage value by 10, and the current value by 100. The obtained data is recorded in registers, and the coefficients are calculated by the wizard.  The calculated coefficients are written to the EEPROM. <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MODBUS.write){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res_table[<span class="hljs-number"><span class="hljs-number">10</span></span>].Val==<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-comment"><span class="hljs-comment">//    K_u.Val=U_real.Val/res_table[11].Val; //   K_u.Val*=10.0; K_i.Val=I_real.Val/res_table[12].Val; K_i.Val*=100.0; eeprom_write(4,K_u.byte.MB); //  eeprom_write(5,K_u.byte.UB); eeprom_write(6,K_u.byte.HB); eeprom_write(7,K_u.byte.LB); eeprom_write(8,K_i.byte.MB); eeprom_write(9,K_i.byte.UB); eeprom_write(10,K_i.byte.HB); eeprom_write(11,K_i.byte.LB); } res_table[10].Val=0; MODBUS.write=0; }</span></span></code> </pre><br><br><h4>  <b>Weight calculation</b> </h4><br>  The weight of the ore can be calculated directly from the formula given in the <a href="https://habrahabr.ru/post/275141/">first part of the</a> story. <br><img src="https://habrastorage.org/files/779/ba4/1d6/779ba41d694c42449c06d77c4c244ec8.JPG"><br><img src="https://habrastorage.org/files/d34/8e3/ab0/d348e3ab07b841b4a3cc672e08c8bb4c.JPG"><br><br>  Where: <br><ul><li>  F0 - the force developed by the engine when lifting an empty vessel, </li><li>  F is the force measured when lifting a loaded vessel, </li><li>  g is the acceleration due to gravity at the weighing points. </li></ul><br><br>  In this implementation, the mass measurement is not performed, since the simulation in the Proteus does not provide for such a possibility. <br>  The simulation in the proteus makes it possible to understand the viability of the main idea: ‚ÄúMeasuring the weight of ore during transportation in a lifting vessel using the stator current‚Äù. <br><br>  The archive with the project in MpLab X and the proteus project file is <a href="https://yadi.sk/d/XvW-fu1YnrHKZ">here</a> . <br><br>  <i><b>A video that demonstrates the processing of voltage and current signals, the calculation of active power, cosine phi, and total power is shown below.</b></i> <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/H-llHrXmaTc%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgBtpDnOsaaMEzN22wtr2LcgM7RyQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  <b>Conclusion</b> </h4><br>  Measuring the weight of mined minerals in industry is of great importance in technology accounting, evaluating the effectiveness of the work performed, etc. <br><br>  Many different types and types of weighing devices are used to measure the mass of ore. <br><br>  In this series of articles, the possibility of measuring the weight of ore was considered, according to the measurement of the developed moment of the silo drive engine during the transportation of cargo in a lifting vessel.  This method is used in silos with DC motors, where the mass is calculated from the armature current with constant excitation. <br><br>  <b>PS</b> <br><br>  Since mining in the world is produced in large volumes, and there are no prerequisites for a decline, this method of measuring ore scales for technological accounting has the right to life.  And maybe in the near future we will see industrial devices for measuring the mass of cargo in a lifting vessel, based on this principle. </div><p>Source: <a href="https://habr.com/ru/post/276051/">https://habr.com/ru/post/276051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276037/index.html">Prime numbers: history and facts</a></li>
<li><a href="../276039/index.html">The largest hackathon in the history of software development with a prize fund of $ 140,000</a></li>
<li><a href="../276041/index.html">Updates in the service ViaLatM</a></li>
<li><a href="../276047/index.html">Backup: Google Case</a></li>
<li><a href="../276049/index.html">5 common mistakes with working with Amazon Web Services</a></li>
<li><a href="../276053/index.html">Remote reflection in .NET runtime</a></li>
<li><a href="../276055/index.html">Speed ‚Äã‚Äãup a SELECT COUNT (*) query for large tables in PostgreSQL</a></li>
<li><a href="../276057/index.html">‚ÄúWhy is it possible for everyone, but I can't?‚Äù Or reverse the API and get data from eToken</a></li>
<li><a href="../276059/index.html">Uninstalling / restoring Metro applications in Windows 10</a></li>
<li><a href="../276061/index.html">Preparing ASP.NET Core: let's talk about non-standard approaches when working with views</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>