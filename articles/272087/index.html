<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Measurement of productivity of functions in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Performance has always played a key role in software. And in web applications, its value is even higher, because users can easily go to competitors if...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Measurement of productivity of functions in JavaScript</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/33d/9ac/bd8/33d9acbd82db46d1bab42e089fb28d6f.jpg"><br><br>  Performance has always played a key role in software.  And in web applications, its value is even higher, because users can easily go to competitors if the site you have made is slow.  Any professional web developer should keep this in mind.  Today, it is still possible to successfully apply a lot of old methods of performance optimization, such as minimizing the number of requests, using a CDN and not using a blocking code for rendering.  But the more developers use JavaScript, the more important the task of optimizing its code becomes. <br><a name="habracut"></a><br>  Probably, you have some suspicions about the performance of the functions you use often.  Perhaps you even figured out how to improve the situation.  But how do you measure performance gains?  How can you accurately and quickly test the performance of functions in JavaScript?  The ideal option is to use the built-in <code>performance.now()</code> function and measure the time before and after the execution of your functions.  Here we look at how this is done, as well as analyze a number of pitfalls. <br><br><h1>  Performance.now () </h1><br>  The <a href="http://www.w3.org/TR/hr-time/">High Resolution Time API</a> has a <code>now()</code> function that returns a <a href="http://www.w3.org/TR/hr-time/">DOMHighResTimeStamp</a> object.  This is a floating point number that reflects the current time in milliseconds, to the nearest thousandth of a millisecond.  In itself, this number has little value for us, but the difference between the two measured values ‚Äã‚Äãdescribes how much time has passed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Besides the fact that this tool is more accurate than the built-in <code>Date</code> object, it is also ‚Äúmonotonous‚Äù.  If in a simple way: it is not affected by the system time correction.  That is, by creating two copies of the <code>Date</code> and calculating the difference between them, we will not get an accurate, representative idea of ‚Äã‚Äãhow much time has passed. <br><br>  From the point of view of mathematics, the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">monotonous function</a> either only increases or only decreases.  Another example, for a better understanding: the transition to summer or winter time, when all the hours in the country are set back an hour or an hour ahead.  If we compare the values ‚Äã‚Äãof two copies of the <code>Date</code> - before and after the clock transfer, we get, for example, the difference "1 hour 3 seconds and 123 milliseconds."  And when using two copies of <code>performance.now()</code> - "3 seconds 123 milliseconds 456,789 thousandths milliseconds."  We will not analyze this API in detail here; those who wish can refer to the article <a href="http://www.sitepoint.com/discovering-the-high-resolution-time-api/">Discovering the High Resolution Time API</a> . <br><br>  So now we know what the High Resolution Time API is and how to use it.  Let us now consider some possible errors, but first let's write the function <code>makeHash()</code> , which will be used further in the text. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeHash</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; source.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> char = source.charCodeAt(i); hash = ((hash&lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>)-hash)+char; hash = hash &amp; hash; <span class="hljs-comment"><span class="hljs-comment">// Convert to 32bit integer } return hash; }</span></span></code> </pre><br>  The performance of such functions can be measured in the following way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = makeHash(<span class="hljs-string"><span class="hljs-string">'Peter'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = performance.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Took'</span></span>, (t1 - t0).toFixed(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-string"><span class="hljs-string">'milliseconds to generate:'</span></span>, result);</code> </pre><br>  If you execute this code in a browser, the result will look like this: <br><br><pre> <code class="bash hljs">Took 0.2730 milliseconds to generate: 77005292</code> </pre><br>  Demo: <a href="http://codepen.io/SitePoint/pen/YXmdNJ/">codepen.io/SitePoint/pen/YXmdNJ</a> <br><br><h1>  Mistake number 1: random measurement of unnecessary things </h1><br>  In the example above, you might have noticed that between the two <code>performance.now()</code> uses the function <code>makeHash()</code> , whose value is assigned to the variable <code>result</code> .  So we calculate how long it took to execute this function, and nothing more.  You can measure in this way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = performance.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(makeHash(<span class="hljs-string"><span class="hljs-string">'Peter'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// Bad idea! var t1 = performance.now(); console.log('Took', (t1 - t0).toFixed(4), 'milliseconds');</span></span></code> </pre><br>  Demo: <a href="http://codepen.io/SitePoint/pen/PqMXWv/">codepen.io/SitePoint/pen/PqMXWv</a> <br><br>  But in this case we would measure how long the call to the function <code>makeHash('Peter')</code> , <b>as well as the</b> duration of sending and outputting the result to the console.  We do not know how long each of these operations takes, we only know their total duration.  In addition, the speed of sending data and output to the console strongly depends on the browser and even on what else it does at that time.  You probably think that <code>console.log</code> is unpredictably slow.  But in any case, it will be an error to perform more than one function, even if each of the functions does not imply any input-output operations.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">'Peter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = makeHash(name.toLowerCase()).toString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = performance.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Took'</span></span>, (t1 - t0).toFixed(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-string"><span class="hljs-string">'milliseconds to generate:'</span></span>, result);</code> </pre><br>  Again, we don‚Äôt know which operation took the most time: assigning a value to a variable, calling <code>toLowerCase()</code> or <code>toString()</code> . <br><br><h1>  Mistake number 2: single measurement </h1><br>  Many conduct only one measurement, add up the total time and draw far-reaching conclusions.  But the situation can change every time, because the speed of implementation depends greatly on such factors as: <br><br><ul><li>  compile time to bytecode (compiler warm-up time), </li><li>  employment of the main process in performing other tasks </li><li>  CPU utilization is something that inhibits the entire browser. </li></ul><br>  Therefore, it is better to perform not one measurement, but several: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { makeHash(<span class="hljs-string"><span class="hljs-string">'Peter'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = performance.now(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Took'</span></span>, ((t1 - t0) / <span class="hljs-number"><span class="hljs-number">10</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-string"><span class="hljs-string">'milliseconds to generate'</span></span>);</code> </pre><br>  Demo: <a href="http://codepen.io/SitePoint/pen/Qbezpj/">codepen.io/SitePoint/pen/Qbezpj</a> <br><br>  The risk of this approach is that the browser-based JavaScript engine can perform sub-optimization, i.e., the function will be called a second time with the same input data that will be stored and used in the future.  To get around this, you can use many different input lines instead of taking the same value over and over again.  However, with different input data and the speed of the function execution may differ from time to time. <br><br><h1>  Mistake number 3: excessive confidence in average values </h1><br>  So, it is advisable to make a series of measurements to more accurately assess the performance of a particular function.  But how to determine the performance of the function, if with different input data it is performed at different speeds?  Let's first experiment and measure the execution time ten times with the same input data.  The results will look something like this: <br><br><pre> <code class="bash hljs">Took 0.2730 milliseconds to generate: 77005292 Took 0.0234 milliseconds to generate: 77005292 Took 0.0200 milliseconds to generate: 77005292 Took 0.0281 milliseconds to generate: 77005292 Took 0.0162 milliseconds to generate: 77005292 Took 0.0245 milliseconds to generate: 77005292 Took 0.0677 milliseconds to generate: 77005292 Took 0.0289 milliseconds to generate: 77005292 Took 0.0240 milliseconds to generate: 77005292 Took 0.0311 milliseconds to generate: 77005292</code> </pre><br>  Notice how the very first value differs from the rest.  Most likely, the reason is just in the conduct of sub-optimization and the need to "warm up" the compiler.  Little can be done to avoid this, but you can protect yourself from incorrect conclusions. <br><br>  For example, you can exclude the first value and calculate the arithmetic average of the remaining nine.  But it is better to take all the results and calculate the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_%2528%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0%2529">median</a> .  Results are sorted in order, and the average is selected.  That's where <code>performance.now()</code> very useful, because you get a value with which you can do anything. <br><br>  So let's measure again, but this time we use the median value of the sample: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = performance.now(); makeHash(<span class="hljs-string"><span class="hljs-string">'Peter'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = performance.now(); numbers.push(t1 - t0); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">median</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sequence</span></span></span><span class="hljs-function">) </span></span>{ sequence.sort(); <span class="hljs-comment"><span class="hljs-comment">// note that direction doesn't matter return sequence[Math.ceil(sequence.length / 2)]; } console.log('Median time', median(numbers).toFixed(4), 'milliseconds');</span></span></code> </pre><br><h1>  Mistake number 4: comparing functions in a predictable order. </h1><br>  Now we know that it is always better to take several measurements and take an average.  Moreover, the last example suggests that, ideally, you should take the median instead of the average. <br><br>  Runtime measurement is good to use to select the fastest function.  Suppose we have two functions that use the same input data and produce the same results, but they work differently.  Let's say we need to choose a function that returns true or false if it finds a particular string in the array, regardless of case.  In this case, we cannot use <code>Array.prototype.indexOf</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">haystack, needle</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; haystack.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.toLowerCase() === needle.toLowerCase()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isIn([<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>], <span class="hljs-string"><span class="hljs-string">'B'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log(isIn(['a','b','c'], 'd')); // false</span></span></code> </pre><br>  This code can be improved, since the <code>haystack.forEach</code> loop will <code>haystack.forEach</code> through all the elements, even if we quickly found a match.  We use the good old for: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">haystack, needle</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = haystack.length; i &lt; len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i].toLowerCase() === needle.toLowerCase()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isIn([<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>], <span class="hljs-string"><span class="hljs-string">'B'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log(isIn(['a','b','c'], 'd')); // false</span></span></code> </pre><br>  Now let's see which option is faster.  Perform each function ten times and calculate the "correct" results: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIn1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">haystack, needle</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; haystack.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.toLowerCase() === needle.toLowerCase()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIn2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">haystack, needle</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = haystack.length; i &lt; len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (haystack[i].toLowerCase() === needle.toLowerCase()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isIn1([<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>], <span class="hljs-string"><span class="hljs-string">'B'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log(isIn1(['a','b','c'], 'd')); // false console.log(isIn2(['a','b','c'], 'B')); // true console.log(isIn2(['a','b','c'], 'd')); // false function median(sequence) { sequence.sort(); // note that direction doesn't matter return sequence[Math.ceil(sequence.length / 2)]; } function measureFunction(func) { var letters = 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z'.split(','); var numbers = []; for (var i = 0; i &lt; letters.length; i++) { var t0 = performance.now(); func(letters, letters[i]); var t1 = performance.now(); numbers.push(t1 - t0); } console.log(func.name, 'took', median(numbers).toFixed(4)); } measureFunction(isIn1); measureFunction(isIn2);</span></span></code> </pre><br>  We get the following result: <br><br><pre> <code class="bash hljs"><span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> isIn1 took 0.0050 isIn2 took 0.0150</code> </pre><br>  Demo: <a href="http://codepen.io/SitePoint/pen/YXmdZJ/">codepen.io/SitePoint/pen/YXmdZJ</a> <br><br>  What does it mean?  The first function was <b>three times faster</b> .  It just can not be!  The explanation is simple, but not obvious.  The first function that uses <code>haystack.forEach</code> benefits from low-level optimization at the browser JS engine level, which is not done using an array index.  So do not measure, do not know! <br><br><h1>  findings </h1><br>  Trying to demonstrate the accuracy of performance measurement in JavaScript using <code>performance.now()</code> , we found that our intuition could fail us: the empirical data did not completely coincide with our assumptions.  If you want to write fast web applications, the JS code must be optimized.  And since computers are practically living beings, they are still capable of being unpredictable and surprising us.  So the best way to make your code faster is to measure and compare. <br><br>  Another reason why we cannot know in advance which option will be faster is that it all depends on the situation.  In the last example, we searched for a match among 26 values ‚Äã‚Äãregardless of case.  But if we search among 100,000 values, the choice of the function may be different. <br><br>  The errors considered are not the only possible ones.  To them, you can add, for example, the measurement of unrealistic scenarios or the measurement on only one JS engine.  But it‚Äôs important to remember the most important thing: if you want to create fast web applications, then you‚Äôll not find a better <code>performance.now()</code> tool.  However, measuring the runtime is only one aspect.  Performance is also affected by memory usage and code complexity. </div><p>Source: <a href="https://habr.com/ru/post/272087/">https://habr.com/ru/post/272087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272073/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 18. "Briefing"</a></li>
<li><a href="../272075/index.html">Creating a desktop application with Electron and web technologies</a></li>
<li><a href="../272077/index.html">How to send an IDoc from SAP MII to SAP ERP</a></li>
<li><a href="../272083/index.html">NetApp becomes more efficient with inline dedupe</a></li>
<li><a href="../272085/index.html">8 principles of development planning, simplifying life</a></li>
<li><a href="../272089/index.html">Under the hood Redis: Hash table (part 2) and List</a></li>
<li><a href="../272091/index.html">Payment conversion: 4 reasons that reduce the success of payment on your site and how to eliminate them</a></li>
<li><a href="../272093/index.html">Network equipment at risk? Let's understand ...</a></li>
<li><a href="../272095/index.html">Corporate use of Android 5.0: security recommendations</a></li>
<li><a href="../272099/index.html">PHP 7.0.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>