<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating applications for Firebird with the use of various components and drivers: FireDac</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will describe the process of creating applications for the Firebird DBMS using the FireDac access components and the Delphi XE5 environme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating applications for Firebird with the use of various components and drivers: FireDac</h1><div class="post__text post__text-html js-mediator-article">  This article will describe the process of creating applications for the Firebird DBMS using the FireDac access components and the Delphi XE5 environment.  FireDac is a standard set of components for accessing various databases starting with Delphi XE3. <br><br>  Our application will work with the database model, which is shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/763/0b9/bfc/7630b9bfc5954ddcb37264abdb19e7a3.png" alt="diagramm"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the end of this article there are links to other articles that describe the process of creating a database with this model and a link to the script for creating a database. <br><table><tbody><tr><td>  <b>Attention!</b> <br><br>  This model is just an example.  Your subject area may be more complicated, or completely different.  The model used in this article is simplified as much as possible in order not to clutter up the description of working with components with the description of creating and modifying the data model. <br></td></tr></tbody></table><a name="habracut"></a><br>  Create a new project File-&gt; New-&gt; VCL Forms Application - Delphi.  In the new project, add the new date module File-&gt; New-&gt; Other, in the wizard that appears, select Delphi Projects-&gt; Delphi Files-&gt; Data Module.  This date module will be the main one in our project.  It will contain some instances of global access components that should be accessible to all forms that need to work with the data.  For example, such a component is a TFDConnection. <br><br><h2>  TFDConnection Component </h2><br>  The TFDConnection component provides connectivity to various types of databases.  We will specify an instance of this component in the Connection properties of the remaining FireDac components.  What type of database will be connected to depends on the value of the DriverName property.  To access Firebird, we need to set this property to FB.  In order for the connection to know exactly which access library to work with, we will place the TFDPhysFBDriverLink component in the main data module.  Its property VendorLib allows you to specify the path to the client library.  If it is not specified, the connection to Firebird will be made through libraries registered in the system, for example in system32, which in some cases may be undesirable. <br><br><h3>  Client Library Path </h3><br>  We will place the necessary access library in the fbclient folder, which is located in the application folder.  To do this, in the code for the OnCreate event, the date of the module is the following code. <br><br><pre><code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      xAppPath := ExtractFileDir(Application.ExeName) + PathDelim; FDPhysFBDriverLink.VendorLib := xAppPath + 'fbclient' + PathDelim + 'fbclient.dll';</span></span></code> </pre> <br><br><table><tbody><tr><td>  <b>Important!</b> <br><br>  If you are compiling a 32 bit application, then you must use the 32 bit fbclient.dll library.  For 64 bit - 64 bit.  In addition to the fbclient.dll file, it is advisable to place the msvcp80.dll and msvcr80.dll libraries (for Firebird 2.5), and msvcp100.dll and msvcr100.dll (for Firebird 3.0) in the same folder.  These libraries can be found either in the bin subfolder (Firebird 2.5) or in the root folder of the server (Firebird 3.0). <br><br>  In order for the application to correctly display its own firebird errors, you must also copy the file firebird.msg.  For Firebird 2.5 and earlier, it should be one level higher than the client library catalog, i.e.  in our case in the application directory.  For Firebird 3, it should be located in the client library directory, i.e.  in the fbclient directory. <br></td></tr></tbody></table><br><br>  If you need your application to work without the Firebird server installed, i.e.  in Embedded mode, then for Firebird 2.5 you need to replace fbclient.dll with fbembed.dll.  If desired, the library name can be placed in the configuration file of your application.  For Firebird 3.0, nothing needs to be changed (the mode of operation depends on the connection string and the value of the Providers parameter in the firebird.conf / databases.conf file). <br><br><table><tbody><tr><td>  <b>The board</b> <br><br>  Even if your application will work with Firebird in Embedded mode, it is more convenient to conduct development under a full-fledged server.  The fact is that in Embedded mode, Firebird works in the same address space with your application, which can lead to undesirable consequences if errors occur in your application.  In addition, at the time of development, the Delphi environment and your application are separate applications using Embedded.  Until version 2.5, they cannot work with one base at the same time. <br></td></tr></tbody></table><br><h3>  Connection settings </h3><br>  The TFDConnection component of the database connection settings are contained in the Params property (user name, password, connection character set, etc.).  If you use the property editor TFDConnection (double click on the component), then the mentioned properties will be filled automatically.  The set of these properties depends on the type of database. <br><br><table><tbody><tr><th width="150">  Parameter </th><th>  Purpose </th></tr><tr><td>  Pooled </td><td>  Whether the connection pool is used. </td></tr><tr><td>  Database </td><td>  The path to the database or its alias, as defined in the aliases.conf configuration file (or databases.conf) of the Firebird server. </td></tr><tr><td>  User_Name </td><td>  Username. </td></tr><tr><td>  Password </td><td>  Password. </td></tr><tr><td>  OSAuthent </td><td>  Whether authentication is used by the operating system. </td></tr><tr><td>  Protocol </td><td>  Connection protocol  The following values ‚Äã‚Äãare allowed: <br><ul><li>  Local - local protocol; </li><li>  NetBEUI - Named Pipes; </li><li>  SPX - not supported in modern versions; </li><li>  TCPIP - TCP / IP. </li></ul><br></td></tr><tr><td>  Server </td><td>  Server name or IP address.  If the server is running on a non-standard port, then you must also specify the port through a slash, for example, localhost / 3051. </td></tr><tr><td>  SQLDialect </td><td>  Dialect.  Must match the database dialect. </td></tr><tr><td>  RoleName </td><td>  Role name </td></tr><tr><td>  CharacterSet </td><td>  The name of the connection character set. </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3a2/908/6d5/3a29086d549344119e8b49e9470e59b2.png" alt="FDConnection_params"></div><br><br>  Additional properties: <br><br>  <b>Connected</b> - control connection to the database, or check the status of the connection.  This property must be set to True for the wizards of other FireDac components to work.  If your application should request data for authorization, it is important not to forget to reset this property to False before compiling your application. <br><br>  <b>LoginPrompt</b> - whether to ask for a username and password when trying to connect. <br><br>  <b>Transaction</b> is a TFDTransaction component that will be used as the default for performing various TFDConnection operations.  If this property is not explicitly assigned, TFDConnection will create an instance of TFDTransaction on its own, its parameters can be specified in the TxOptions property. <br><br>  <b>UpdateTransaction</b> is a component of TFDTransaction, which will be used as default for properties of the same name of TFDQuery components.  If this property is not assigned explicitly, the value from the Transaction property will be used. <br><br>  Since the connection settings, with the exception of the username and password, usually do not change during the operation of the application, we will read them from the configuration file. <br><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//    xIniFile := TIniFile.Create(xAppPath + 'config.ini'); try xIniFile.ReadSectionValues('connection', FDConnection.Params); finally xIniFile.Free; end;</span></span></code> </pre><br><br>  The config.ini file contains approximately the following lines: <br><pre> <code class="hljs pgsql">[<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>] DriverID=FB Protocol=TCPIP <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span>=localhost/<span class="hljs-number"><span class="hljs-number">3051</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Database</span></span>=examples OSAuthent=<span class="hljs-keyword"><span class="hljs-keyword">No</span></span> RoleName= CharacterSet=UTF8</code> </pre><br><br>  The contents of the connection section can be obtained by copying the contents of the Params property of the TFDConnection component after the wizard has been run. <br><table><tbody><tr><td>  <b>Comment</b> <br><br>  In fact, the general settings are usually found in% AppData% \ Manufacture \ AppName and saved there by the installer of the application.  However, during development it is convenient for the settings file to be placed somewhere closer, for example, in the folder with the application. <br><br>  Note that if your application is installed in the Program Files folder and the configuration file is in the same place, then this file will be virtualized into Program Data, or there will be problems with its modification and subsequent reading of the new settings. <br></td></tr></tbody></table><br><h3>  Database connection </h3><br>  To connect to the database, you must change the Connected TFDConnection property to True or call the Open method.  In the latter method, you can pass the username and password as parameters.  In our application, we will replace the standard database connection dialog.  We give the opportunity to make a mistake when entering registration information no more than three times, after which the application will be closed.  To do this, write the following code in the OnCreate event handler of the main datamodule. <br><br><pre> <code class="delphi hljs"> <span class="hljs-comment"><span class="hljs-comment">//   3    ,    xLoginCount := 0; xLoginPromptDlg := TLoginPromptForm.Create(Self); while (xLoginCount &lt; MAX_LOGIN_COUNT) and (not FDConnection.Connected) do begin try if xLoginPromptDlg.ShowModal = mrOK then FDConnection.Open( xLoginPromptDlg.UserName, xLoginPromptDlg.Password) else xLoginCount := MAX_LOGIN_COUNT; except on E: Exception do begin Inc(xLoginCount); Application.ShowException(E); end end; end; xLoginPromptDlg.Free; if not FDConnection.Connected then Halt;</span></span></code> </pre><br><br><h2>  Component TFDTransaction </h2><br>  The TFDTransaction component is intended for explicit work with transactions. <br><br>  The client side of Firebird allows execution of any actions only in the context of a transaction.  Therefore, if you were able to access the data without an explicit call to TFDTransaction.StartTransaction, then somewhere in the depths of FireDac this call occurred automatically.  This behavior is not recommended to use.  For correct operation of applications with the database, it is desirable to manage transactions manually, that is, explicitly call the StartTransaction, Commit and Rollback methods of the TFDTransaction component. <br><br><table><tbody><tr><th width="200">  Parameter </th><th>  Purpose </th></tr><tr><td>  Connection </td><td>  Communication with the FDConnection component. </td></tr><tr><td>  Options.AutoCommit </td><td>  Manages the automatic start and completion of the transaction.  The default is True. <br><br>  If the value of this property is set to True, then FireDAC does the following: <br><ul><li>  A transaction is started (if required) before executing each SQL command, and terminates the transaction after executing the SQL command.  If the command is executed successfully, the transaction will be completed as COMMIT, otherwise - ROLLBACK. </li><li>  If the application calls the StartTransaction method, automatic transaction management will be disabled until the transaction ends as Commit or Rollback. </li></ul><br>  In Firebird, automatic transaction management is emulated by the FireDAC components themselves. <br></td></tr><tr><td>  Options.AutoStart </td><td>  Manages the automatic start of a transaction.  Default is True. </td></tr><tr><td>  Options.AutoStop </td><td>  Manages the automatic completion of a transaction.  Default is True. </td></tr><tr><td>  Options.DisconnectAction </td><td>  The action that will be performed when the connection is closed, if the transaction is active.  The default is xdCommit.  The following options are possible: <br><ul><li>  xdNone - nothing will be done.  The action will be given at the mercy of the DBMS; </li><li>  xdCommit - confirmation of the transaction; </li><li>  xdRollback - rollback transaction. </li></ul><br>  In other access components, the default value for the similar xdRollback property.  Therefore, it is necessary to set this property manually to the value that is really required. <br></td></tr><tr><td>  Options.EnableNested </td><td>  Manages nested transactions.  The default is True. <br><br>  When a transaction is active, the next StartTransaction call will create a nested transaction.  FireDAC emulates nested transactions using savepoints if the DBMS does not explicitly support nested transactions.  To disable nested transactions, set EnableNested to False and the next call to StartTransaction will raise an exception. <br><br>  Firebird does not explicitly support nested transactions. <br></td></tr><tr><td>  Options.Isolation </td><td>  Specifies the isolation level of the transaction.  This is the most important property of a transaction.  The default is xiReadCommited.  The following options are possible: <br><ul><li>  xiUnspecified - the default isolation level for your DBMS is used (in Firebird, this is SNAPSHOT, that is, with read write concurrency wait parameters); </li><li>  xiDirtyRead - this level of isolation in Firebird does not exist therefore READ COMMITED will be used instead; </li><li>  xiReadCommited - isolation level READ COMMITED.  In Firebird, such a transaction starts with read write options read_committed rec_version nowait; </li><li>  xiRepeatableRead - this isolation level in Firebird does not exist, so SNAPSHOT will be used instead; </li><li>  xiSnapshot - SNAPSHOT isolation level.  In Firebird, such a transaction starts with read write concurrency parameters wait; </li><li>  xiSerializable - isolation level SERIALIZABLE.  In fact, there is no transaction in Firebird with this isolation level, but it is emulated by starting a transaction with read write consistency wait parameters. </li></ul><br></td></tr><tr><td>  Options.Params </td><td>  DBMS specific transaction parameters.  Currently used only for Firebird and Interbase.  Possible values: <br><ul><li>  read </li><li>  write </li><li>  read_committed </li><li>  concurrency </li><li>  consistency </li><li>  wait </li><li>  nowait </li><li>  rec_version </li><li>  no rec_version </li></ul><br></td></tr><tr><td>  Options.ReadOnly </td><td>  Indicates whether the transaction is read only.  Default is False.  If set to True, then no changes within the current transaction are possible, in Firebird in this case there is no read value in the transaction parameters. <br><br>  Setting this property to True allows the DBMS to optimize the use of resources. <br></td></tr></tbody></table><br>  Unlike other DBMS, in Firebird it is allowed to use any number of TFDTransaction components bound to one connection.  In our application, we will use one common read transaction for all reference books and operational journals, and one writing transaction for each reference book / journal. <br><br>  In our application, we will not rely on the automatic start and completion of transactions, and therefore in all transactions, Options.AutoCommit = False, Options.AutoStart = False and Options.AutoStop = False. <br><br>  Since the reading transaction is common for all directories and journals, it is convenient to place it in the main data module.  For normal operation (showing data in a grid, etc.), the isolation mode is READ COMMITED (Options.Isolation = xiReadCommited), since  it allows the transaction to see other people committed to database changes simply by re-performing queries (re-reading the data).  Since this transaction is used only for reading, we set the Options.ReadOnly property to True.  Thus, our transaction will have parameters read read_commited rec_version.  A transaction with such parameters in Firebird can be open for an arbitrarily long time (days, weeks, months), without blocking other transactions or affecting the accumulation of garbage in the database (because in fact, on a server, such a transaction starts as committed). <br><br><table><tbody><tr><td>  <b>Comment</b> <br><br>  Such a transaction cannot be used for reports (especially if they use several consecutive requests), because a transaction with the READ COMMITED isolation mode during re-reading of data will see all new committed changes. <br><br>  For reports, it is recommended to use a read-only short transaction with SNAPSHOT isolation mode (Options.Isolation = xiSnapshot and Options.ReadOnly = True).  In this example, working with reports is not considered. <br></td></tr></tbody></table><br><br>  We start the read transaction immediately after successfully establishing the connection with the database, calling trRead.StartTransaction in the OnCreate event of the main datamodule, and terminating before closing the connection by calling tRead.Commit in the OnDestroy event of the main datamodule.  The value of the Options.DisconnectAction property is xdCommit by default, suitable for a read-only transaction. <br><br>  The writing transaction will be separate for each directory / journal.  We will post it on a form that relates directly to the desired journal.  A writing transaction should be as short as possible in order not to hold Oldest Active Transaction, which does not allow garbage collection, which in turn leads to performance degradation.  Since the writing transaction is very short, we can use the SNAPSHOT isolation level.  Thus, our writing transaction will have Options.ReadOnly = False and Options.Isolation = xiSnapshot parameters.  For writing transactions, the value of the Options.DisconnectAction property is not suitable by default, it must be set to xdRollback. <br><br><h2>  Datasets </h2><br>  You can work with data in FireDac using the FDQuery, FDTable, FDStoredProc, FDCommand components, but FDCommand is not a dataset. <br><br>  TFDQuery, TFDTable, and TFDStoredProc are inherited from TFDRdbmsDataSet.  In addition to the data sets to work directly with the database, in FireDac there is also a component TFDMemTable, which is designed to work with the data set in memory, which is analogous to TClientDataSet. <br><br>  The main component for working with datasets is TFDQuery.  The capabilities of this component is enough for almost any purpose.  The TFDTable and TFDStoredProc components are just modifications, either slightly extended or truncated.  We will not consider and apply them in our application.  If you wish, you can read them in the FireDac documentation. <br><br>  The purpose of the component is to buffer the records selected by the SELECT statement to represent this data in the Grid, as well as to ensure the "editable" record (the current one in the buffer (grid)).  Unlike the IBX.IBDataSet component, the FDQuery component does not contain the RefreshSQL, InsertSQL, UpdateSQL and DeleteSQL properties.  Instead, ‚Äúeditableness‚Äù is provided by the FDUpdateSQL component, which is set in the UpdateObject property. <br><br><table><tbody><tr><td>  <b>Comment</b> <br><br>  In some cases, you can make the FDQuery component editable without setting the UpdateObject property and prescribing Insert / Update / Delete queries by simply setting the UpdateOptions.RequestLive = True property, while modifying queries will be generated automatically.  However, this approach has many limitations on the basic SELECT query, so do not rely on it. <br></td></tr></tbody></table><br><br><table><tbody><tr><th width="270">  Parameter </th><th>  Purpose </th></tr><tr><td>  Connection </td><td>  Communication with the FDConnection component. </td></tr><tr><td>  MasterSource </td><td>  Reference to the Master Data Source (TDataSource) for FDQuery, used as Detail. </td></tr><tr><td>  Transaction </td><td>  The transaction within which the query specified in the SQL property will be executed.  If the property is not specified, the default transaction will be used to connect. </td></tr><tr><td>  UpdateObject </td><td>  Communication with the FDUpdateSQL component, which provides the ‚Äúeditable‚Äù data set when a SELECT query does not meet the requirements for automatically generating modifying queries when UpdateOptions.RequestLive = True is set. </td></tr><tr><td>  UpdateTransaction </td><td>  The transaction within which the modifying queries will be executed.  If the property is not specified, a transaction from the Transaction property will be used. </td></tr><tr><td>  UpdateOptions.CheckRequired </td><td>  If the CheckRequired property is set to True, then FireDac controls the Required property of the corresponding fields, i.e.  fields with NOT NULL constraint.  The default is set to true. <br><br>  If CheckRequired = True and no value is assigned to the field with the property Required = True, then an exception is raised when the Post method is called.  This may be undesirable if the value of this field can be assigned later in the BEFORE triggers. <br></td></tr><tr><td>  UpdateOptions.EnableDelete </td><td>  Determines whether deleting a record from the dataset is allowed.  If EnableDelete = False, an exception will be raised when the Delete method is called. </td></tr><tr><td>  UpdateOptions.EnableInsert </td><td>  Determines whether insertion of a record into a dataset is allowed.  If EnableInsert = False, then an exception will be raised when calling the Insert / Append method. </td></tr><tr><td>  UpdateOptions.EnableUpdate </td><td>  Determines whether a record is allowed to be changed in the dataset.  If EnableUpdate = False, an exception will be raised when the Edit method is called. </td></tr><tr><td>  UpdateOptions.FetchGeneratorsPoint </td><td>  Controls the moment when the next value of the generator specified in the UpdateOptions.GeneratorName property or the GeneratorName property of the auto-increment field AutoGenerateValue = arAutoInc is received.  It has the following options: <br><ul><li>  gpNone - the value of the generator is not extracted; </li><li>  gpImmediate - the next value of the generator is retrieved immediately after the call to the Insert / Append method; </li><li>  gpDeffered - the next value of the generator is retrieved before publishing a new record in the database, i.e.  during the execution of the Post or ApplyUpdates methods. </li></ul><br>  The default is gpDeffered. <br></td></tr><tr><td>  UpdateOptions.GeneratorName </td><td>  The name of the generator to extract the next value of the auto-increment field. </td></tr><tr><td>  UpdateOptions.ReadOnly </td><td>  Indicates whether the dataset is read only.  Default is False.  If the value of this property is set to True, then the values ‚Äã‚Äãof the properties EnableDelete, EnableInsert and EnableUpdate will be automatically set to False. </td></tr><tr><td>  UpdateOptions.RequestLive </td><td>  Setting RequestLive to True makes the request ‚Äúlive‚Äù, i.e.  editable if possible.  In this case, Insert / Update / Delete requests will be generated automatically.  This option imposes many restrictions on the SELECT query, introduced for backward compatibility with the BDE and is not recommended. </td></tr><tr><td>  UpdateOptions.UpdateMode </td><td>  Responsible for checking the modification record.  This property made it possible to control the possible ‚Äúoverlapping‚Äù of updates for cases when a user performs editing a ‚Äúlong‚Äù record, and another user can manage to edit the same record and save it earlier.  That is, the first user at the editing stage will not even know that the record has already changed, perhaps more than once, and will be able to ‚Äúwipe‚Äù these updates with his: <br><ul><li>  upWhereAll - checking for the existence of a record by the primary key + checking all columns for old values.  for example <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pkfield = :old_ pkfield <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> client_name = :old_client_name <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> info = :old_info ...</code> </pre><br>  That is, in this case, the request will change the information in the record only if no one has changed the record before us. <br>  This is especially important if there are interdependencies between the values ‚Äã‚Äãof the columns - for example, the minimum and maximum wages, etc. <br></li><li>  upWhereCahnged - check the existence of a record by the primary key + plus check for old values ‚Äã‚Äãof only the columns being changed. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pkfield = :old_pkfield <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> client_name = :old_client</code> </pre><br></li><li>  upWhereKeyOnly (default) - check the entry for existence on the primary key. </li></ul><br>  The last check corresponds to the request automatically generated for UpdateSQL. ,            where . , ,      upWhereChanged      update table set‚Ä¶ ‚Äî  ,    set    ,       .   ,       UpdateSQL. <br><br>            ,      ProviderFlags   . <br></td></tr><tr><td> CachedUpdates </td><td> ,             .       True,    (Insert/Post, Update/Post, Delete)      ,     . <br><br>     ,   ApplyUpdates.                 .      False. <br></td></tr><tr><td>  SQL </td><td>  SQL .     SELECT ,      Open.       Execute  ExecSQL. </td></tr></tbody></table><br><br><h2>  TFDUpdateSQL </h2><br>  TFDUpdateSQL   SQL ,      .          TFDQuery, TFDTable  TFDStoredProc.  TFDUpdateSQL     TFDQuery  TFDTable,                .  TFDUpdateSQL        TFDStoredProc.    ,     ,            . <br><br>     SQL    ,   TFDUpdateSQL  ,      . <br><br><table><tbody><tr><td>  <b>Comment</b> <br><br>       FireDac ,        (TFDConnection.Connected = True)       (TFDTransaction.Options.AutoStart = True).        . ,        ,  TFDConnection      SYSDBA.           TFDConnection.Connected   .  ,           . <br></td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/files/558/533/def/558533def35549e0bf78e03aded46796.png" alt="FDUpdateSQL_Generate"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the Generate tab, you can simplify the task of writing Insert / Update / Delete / Refresh queries. </font><font style="vertical-align: inherit;">To do this, select the table for the update, its key fields, the fields for the update, and the fields that will be re-read after the update, and click on the ‚ÄúGenerate SQL‚Äù button. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, the requests will be generated automatically, and you will be taken to the ‚ÄúSQL Commands‚Äù tab, where you can correct each of the requests.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ccf/9b7/d66/ccf9b7d66f154944a44c8013546bb70e.png" alt="FDUpdateSQL_SQLCommands"></div><br><br><table><tbody><tr><td>  <b>Comment</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because product_id is not included in Updating Fields, it is not in the generated insert query. </font><font style="vertical-align: inherit;">It is assumed that this column is filled automatically with a trigger (with a generator), or this is an IDENTITY column (starting with Firebird 3.0). </font><font style="vertical-align: inherit;">When getting the generator value for this column from the server, it is recommended to manually add the PRODUCT_ID column to the RETURNING clause of the INSERT statement.</font></font><br></td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Options tab contains some properties that can affect query generation. </font><font style="vertical-align: inherit;">These properties are not related to the TFDUpdateSQL component itself, but are references to the UpdateOptions properties of a dataset that has the current TFDUpdateSQL in the UpdateObject property. </font><font style="vertical-align: inherit;">This is done solely for convenience.</font></font><br><br><table><tbody><tr><th>  Parameter </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Purpose </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connection </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Communication with the FDConnection component. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DeleteSQL </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL query to delete the record. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FetchrowSQL </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL query to return one current (updated, inserted) record. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> InsertSQL </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL query to insert record. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LockSQL </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL query to lock one current record. </font><font style="vertical-align: inherit;">(FOR UPDATE WITH LOCK).</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ModifySQL </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SQL query to modify the record. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UnlockSQL </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL query to unlock the current record. </font><font style="vertical-align: inherit;">In Firebird does not apply.</font></font></td></tr></tbody></table><br><br>    ,   TFDUpdateSQL   Transaction.  ,       ,         ,    TFDRdbmsDataSet. <br><br><h2>  TFDCommand </h2><br>  TFDCommand    SQL .     TDataSet,      SQL ,    . <br><br><table><tbody><tr><th width="150">  Parameter </th><th>  </th></tr><tr><td> Connection </td><td>    FDConnection. </td></tr><tr><td>  Transaction </td><td> ,      SQL . </td></tr><tr><td> CommandKind </td><td>  . <br><ul><li> skUnknown ‚Äì .             ; </li><li> skStartTransaction ‚Äì    ; </li><li> skCommit ‚Äì     ; </li><li> skRollback ‚Äì     ; </li><li> skCreate ‚Äì  CREATE ‚Ä¶     ; </li><li> skAlter ‚Äì  ALTER ‚Ä¶    ; </li><li> skDrop ‚Äì  DROP ‚Ä¶    ; </li><li> skSelect ‚Äì  SELECT   ; </li><li> skSelectForLock ‚Äì  SELECT ‚Ä¶ WITH LOCK    ; </li><li> skInsert ‚Äì  INSERT ‚Ä¶    ; </li><li> skUpdate ‚Äì  UPDATE ‚Ä¶   ; </li><li> skDelete ‚Äì  DELETE ‚Ä¶   ; </li><li> skMerge ‚Äì  MERGE INTO ‚Ä¶ </li><li> skExecute ‚Äì  EXECUTE PROCEDURE  EXECUTE BLOCK; </li><li> skStoredProc ‚Äì   ; </li><li> skStoredProcNoCrs ‚Äì      ; </li><li> skStoredProcWithCrs ‚Äì     . </li></ul><br>        SQL . <br></td></tr><tr><td> CommandText </td><td>  SQL . </td></tr></tbody></table><br><br><h2>   </h2><br>       :     .         TDBGrid,   TDataSource,   TFDQuery,   TFDTransaction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6d1/ecc/b29/6d1eccb29f924cf8bfad11963f8c2111.png" alt="Customers"></div><br><br><table><tbody><tr><td>  <b>Comment</b> <br><br>  trRead  ,      ,    dmMain. <br></td></tr></tbody></table><br><br>       . <br><br>   TFDQuery     qryCustomers.        DataSet   DataSource.   Transaction  ReadOnly  trRead,       .   UpdateTransaction   trWrite,   Connection ‚Äî     .   SQL   : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> customer_id, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, address, zipcode, phone <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customer <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span></code> </pre><br><br>   trWrite    ,     SNAPSHOT.          ,       .  ,      : <br><br> Options.AutoStart = False <br> Options.AutoCommit = False <br> Options.AutoStop = False <br> Options.DisconnectAction = xdRollback <br> Options.Isolations = xiSnapshot <br> Options.ReadOnly = False <br><br>        SNAPSHOT   INSERT/UPDATE/DELETE.       ,     INSERT/UPDATE/DELETE   ,      SNAPSHOT. <br><br>   ,    READ COMMITED         (statement read consistency).  ,  SELECT   ,         .     SNAPSHOT    ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To be able to edit a dataset, you must fill in the InsertSQL, ModifySQL, DeleteSQL and FetchRowSQL properties. </font><font style="vertical-align: inherit;">These properties can be generated by the wizard, but after that some editing may be required. </font><font style="vertical-align: inherit;">For example, you can add a RETURNING clause, delete a modification of some columns, or even completely replace the automatically generated request to call a stored procedure. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InsertSQL:</font></font></b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> customer (customer_id, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, address, zipcode, phone) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (:new_customer_id, :new_name, :new_address, :new_zipcode, :new_phone)</code> </pre><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ModifySQL:</font></font></b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> customer <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = :new_name, address = :new_address, zipcode = :new_zipcode, phone = :new_phone <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (customer_id = :old_customer_id)</code> </pre><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DeleteSQL:</font></font></b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customer <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (customer_id = :old_customer_id)</code> </pre><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FetchRowSQL:</font></font></b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> customer_id, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, address, zipcode, phone <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customer <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id = :old_customer_id</code> </pre><br><br>            .        TFDQuery    UpdateOptions.GeneratorName = GEN_CUSTOMER_ID  UpdateOptions.AutoIncFields = CUSTOMER_ID.   ,    ( )    INSERT     RETURNING.     . <br><br>           ,      mrOK     .       DBAware ,                     Insert/Edit, ..  Post.       Insert/Edit     .  ,  -          ,    ,         ,          .       ,       ,      .        : <br><ol><li>   CachedUpdates,           ,      . </li><li>    DBAware .        . </li></ol><br>     .       .      <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCustomerForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actEditRecordExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xEditor: TEditCustomerForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xEditor := TEditCustomerForm.Create(Self); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> xEditor.OnClose := CustomerEditorClose; xEditorForm.DataSource := DataSource; xEditor.Caption := <span class="hljs-string"><span class="hljs-string">'Edit customer'</span></span>; qryCustomer.CachedUpdates := True; qryCustomer.Edit; xEditor.ShowModal; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> xEditor.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>   ,             CachedUpdates,         . <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCustomerForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomerEditorClose</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Action: TCloseAction)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TForm(Sender).ModalResult &lt;&gt; mrOK <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    qryCustomer.Cancel; qryCustomer.CancelUpdates; //        qryCustomer.CachedUpdates := False; //     Action := caFree; Exit; end; try //       qryCustomer.Post; //   trWrite.StartTransaction; //       if (qryCustomer.ApplyUpdates = 0) then begin //     qryCustomer.CommitUpdates; //    trWrite.Commit; end else begin raise Exception.Create(qryCustomer.RowError.Message); end; qryCustomer.CachedUpdates := False; Action := caFree; except on E: Exception do begin //   if trWrite.Active then trWrite.Rollback; Application.ShowException(E); //   ,     Action := caNone; end; end; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the code it is clear that until the OK button is pressed, the writing transaction does not start at all. </font><font style="vertical-align: inherit;">Thus, the writing transaction is active only while data is being transferred from the dataset buffer to the database. </font><font style="vertical-align: inherit;">Since we are saving no more than one record in the buffer, the transaction will be active for a very short time, as required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reference book of goods is done similarly to the reference book of customers. </font><font style="vertical-align: inherit;">However, we will demonstrate another method for obtaining auto-increment values ‚Äã‚Äãin it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main query will look like this:</font></font><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> product_id, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, price, description <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> product <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The property of the TFDUpdateSQL.InsertSQL component will contain the following query: </font></font><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> PRODUCT (<span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, PRICE, DESCRIPTION) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (:NEW_NAME, :NEW_PRICE, :NEW_DESCRIPTION) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> PRODUCT_ID</code> </pre><br>      RETURNING,     PRODUCT_ID     BEFORE INSERT .          UpdateOptions.GeneratorName.  ,  PRODUCT_ID    Required = False  ReadOnly = True,       .           . <br><br><h2>   </h2><br>       ¬´-¬ª.              . <br><br> - ‚Äì   ,     (, ,  ‚Ä¶),   -   ,  ,   ..       :       ,    ‚Äî  .  ,         TDBGrid,       TDataSource,         TFDQuery.           qryInvoice,     qryInvoiceLine. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Transaction property of both datasets, we specify the ReadOnly transaction trRead, which was created in the main datamodule of the project. In the UpdateTransaction property, we specify the transaction trWrite, in the Connection property, the connection located in the main datamodule.</font></font><br><br>        .               ,       .   ‚Äì   ,     .       ,     ,       ,    dmMain, ,   ,   ,   .              (   ).           . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0b5/6e5/f28/0b56e5f28e1f4b80b66169cc390f6607.png" alt="Invoices"></div><br><br>        ,          .   ,   SQL   qryInvoice     : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> invoice.invoice_id <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> invoice_id, invoice.customer_id <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> customer_id, customer.NAME <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> customer_name, invoice.invoice_date <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> invoice_date, invoice.total_sale <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> total_sale, <span class="hljs-keyword"><span class="hljs-keyword">IIF</span></span>(invoice.payed=<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Yes'</span></span>, <span class="hljs-string"><span class="hljs-string">'No'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> payed <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> invoice <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> customer <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> customer.customer_id = invoice.customer_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> invoice.invoice_date <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> :date_begin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> :date_end <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> invoice.invoice_date <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre><br><br>          : <br><br><pre> <code class="delphi hljs"> qryInvoice.ParamByName(<span class="hljs-string"><span class="hljs-string">'date_begin'</span></span>).AsSqlTimeStamp := dmMain.BeginDateSt; qryInvoice.ParamByName(<span class="hljs-string"><span class="hljs-string">'date_end'</span></span>).AsSqlTimeStamp := dmMain.EndDateSt; qryInvoice.Open;</code> </pre><br><br>    -      ,              INSERT/UPDATE/DELETE. <br><br>           TFDCommand.      TFDRdbmsDataSet,         ,         ,   .       ,   Transaction  TFDCommand    trWrite. <br><br><table><tbody><tr><td>  <b>Comment</b> <br><br>   ,            TFDUpdateSQL. <br></td></tr></tbody></table><br><br>     -   : , ,     ¬´¬ª.   - ,     ,   ,    .      .       . <br><br> <b>qryAddInvoice.CommandText:</b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_add_invoice( <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> gen_invoice_id, :CUSTOMER_ID, :INVOICE_DATE )</code> </pre><br><br> <b>qryEditInvoice.CommandText:</b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_edit_invoice( :INVOICE_ID, :CUSTOMER_ID, :INVOICE_DATE )</code> </pre><br><br> <b>qryDeleteInvoice.CommandText:</b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_delete_invoice(:INVOICE_ID)</code> </pre><br><br> <b>qryPayForInvoice.CommandText:</b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_pay_for_inovice(:invoice_id)</code> </pre><br><br>         TFDUpdateSQL,       qryInvoice.Refresh     . <br><br>   ,      ,   : <br><pre> <code class="delphi hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MessageDlg(<span class="hljs-string"><span class="hljs-string">'     ?'</span></span>, mtConfirmation, [mbYes, mbNo], <span class="hljs-number"><span class="hljs-number">0</span></span>) = mrYes <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   trWrite.StartTransaction; try qryDeleteInvoice.ParamByName('INVOICE_ID').AsInteger := qryInvoice.FieldByName('INVOICE_ID').AsInteger; //    qryDeleteInvoice.Execute; //   trWrite.Commit; //     qryInvoice.Refresh; except on E: Exception do begin if trWrite.Active then trWrite.Rollback; Application.ShowException(E); end; end; end;</span></span></code> </pre><br><br>       ,           .        DBAware .    ‚Äî        TButtonedEdit.      ,            . ,     -  TDBLookupCombobox, , -            , -         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/718/9e1/2bc/7189e12bcbc14fa3a567c79bc4a405c3.png" alt="EditInvoice"></div><br><br>           ,      .       TButtonedEdit    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEditInvoiceForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edtCustomerRightButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xSelectForm: TCustomerForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xSelectForm := TCustomerForm.Create(Self); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> xSelectForm.Visible := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xSelectForm.ShowModal = mrOK <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCustomerId := xSelectForm.qryCustomer.FieldByName(<span class="hljs-string"><span class="hljs-string">'CUSTOMER_ID'</span></span>) .AsInteger; edtCustomer.Text := xSelectForm.qryCustomer.FieldByName(<span class="hljs-string"><span class="hljs-string">'NAME'</span></span>).AsString; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> xSelectForm.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>     DBAware ,                . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TInvoiceForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actEditInvoiceExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xEditorForm: TEditInvoiceForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xEditorForm:= TEditInvoiceForm.Create(Self); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> xEditorForm.OnClose := EditInvoiceEditorClose; xEditor.Caption := <span class="hljs-string"><span class="hljs-string">' -'</span></span>; xEditorForm.InvoiceId := qryInvoice.FieldByName(<span class="hljs-string"><span class="hljs-string">'INVOICE_ID'</span></span>).AsInteger; xEditorForm.SetCustomer(qryInvoice.FieldByName(<span class="hljs-string"><span class="hljs-string">'CUSTOMER_ID'</span></span>).AsInteger, qryInvoice.FieldByName(<span class="hljs-string"><span class="hljs-string">'CUSTOMER_NAME'</span></span>).AsString); xEditorForm.InvoiceDate := qryInvoice.FieldByName(<span class="hljs-string"><span class="hljs-string">'INVOICE_DATE'</span></span>).AsDateTime; xEditorForm.ShowModal; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> xEditorForm.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEditInvoiceForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ACustomerId: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ACustomerName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCustomerId := ACustomerId; edtCustomer.Text := ACustomerName; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    -          , ,     .            CachedUpdates,       ,     DBAware . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TInvoiceForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditInvoiceEditorClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Action: TCloseAction)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xEditorForm: TEditInvoiceForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xEditorForm := TEditInvoiceForm(Sender); <span class="hljs-comment"><span class="hljs-comment">//        OK, //     .   . if xEditorForm.ModalResult &lt;&gt; mrOK then begin Action := caFree; Exit; end; //      trWrite.StartTransaction; try qryEditInvoice.ParamByName('INVOICE_ID').AsInteger := xEditorForm.InvoiceId; qryEditInvoice.ParamByName('CUSTOMER_ID').AsInteger := xEditorForm.CustomerId; qryEditInvoice.ParamByName('INVOICE_DATE').AsSqlTimeStamp := DateTimeToSQLTimeStamp(xEditorForm.InvoiceDate); qryEditInvoice.Execute(); trWrite.Commit; qryInvoice.Refresh; Action := caFree; except on E: Exception do begin if trWrite.Active then trWrite.Rollback; Application.ShowException(E); //   ,     Action := caNone; end; end; end;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the positions of the invoice. </font><font style="vertical-align: inherit;">Set the qryInvoiceLine data set the property MasterSource = MasterSource, which is bound to qryInvoice, and the property MasterFields = INVOICE_ID. </font><font style="vertical-align: inherit;">In the SQL property, we write the following query:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> invoice_line.invoice_line_id <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> invoice_line_id, invoice_line.invoice_id <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> invoice_id, invoice_line.product_id <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> product_id, product.name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> productname, invoice_line.quantity <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> quantity, invoice_line.sale_price <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sale_price, invoice_line.quantity * invoice_line.sale_price <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> total <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> invoice_line <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> product <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> product.product_id = invoice_line.product_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> invoice_line.invoice_id = :invoice_id</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All modifications, as in the case of the invoice header, will be carried out using stored procedures. </font><font style="vertical-align: inherit;">We give the text of the request to call the stored procedures. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qryAddInvoiceLine:</font></font></b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_add_invoice_line( :invoice_id, :product_id, :quantity )</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qryEditInvoiceLine:</font></font></b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_edit_invoice_line( :invoice_line_id, :quantity )</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qryDeleteInvoiceLine:</font></font></b> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> sp_delete_invoice_line( :invoice_line_id )</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The form for adding a new record and editing an existing one, as in the case with the header, will not use DBAware. </font><font style="vertical-align: inherit;">To select a product, we will use the TButtonedEdit component. </font><font style="vertical-align: inherit;">The button handler code in the TButtonedEdit component will look like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEditInvoiceLineForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edtProductRightButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xSelectForm: TGoodsForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//        //         if FEditMode = emInvoiceLineEdit then Exit; xSelectForm := TGoodsForm.Create(Self); try xSelectForm.Visible := False; if xSelectForm.ShowModal = mrOK then begin FProductId := xSelectForm.qryGoods.FieldByName('PRODUCT_ID') .AsInteger; edtProduct.Text := xSelectForm.qryGoods.FieldByName('NAME').AsString; //          edtPrice.Text := xSelectForm.qryGoods.FieldByName('PRICE').AsString; end; finally xSelectForm.Free; end; end;</span></span></code> </pre><br><br>     DBAware ,           ,      . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TInvoiceForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actEditInvoiceLineExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xEditorForm: TEditInvoiceLineForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xEditorForm:= TEditInvoiceLineForm.Create(Self); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> xEditorForm.OnClose := EditInvoiceLineEditorClose; xEditorForm.EditMode := emInvoiceLineEdit; xEditorForm.Caption := <span class="hljs-string"><span class="hljs-string">' '</span></span>; xEditorForm.InvoiceLineId := qryInvoiceLine.FieldByName(<span class="hljs-string"><span class="hljs-string">'INVOICE_LINE_ID'</span></span>).AsInteger; xEditorForm.SetProduct(qryInvoiceLine.FieldByName(<span class="hljs-string"><span class="hljs-string">'PRODUCT_ID'</span></span>).AsInteger, qryInvoiceLine.FieldByName(<span class="hljs-string"><span class="hljs-string">'PRODUCTNAME'</span></span>).AsString, qryInvoiceLine.FieldByName(<span class="hljs-string"><span class="hljs-string">'SALE_PRICE'</span></span>).AsCurrency); xEditorForm.Quantity := qryInvoiceLine.FieldByName(<span class="hljs-string"><span class="hljs-string">'QUANTITY'</span></span>).AsInteger; xEditorForm.ShowModal; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> xEditorForm.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEditInvoiceLineForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AProductId: Integer; AProductName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; APrice: Currency)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FProductId := AProductId; edtProduct.Text := AProductName; edtPrice.Text := CurrToStr(APrice); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>              . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TInvoiceForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditInvoiceLineEditorClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Action: TCloseAction)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xCustomerId: Integer; xEditorForm: TEditInvoiceLineForm; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xEditorForm := TEditInvoiceLineForm(Sender); <span class="hljs-comment"><span class="hljs-comment">//        OK, //     .   . if xEditorForm.ModalResult &lt;&gt; mrOK then begin Action := caFree; Exit; end; //      trWrite.StartTransaction; try qryEditInvoiceLine.ParamByName('INVOICE_LINE_ID').AsInteger := xEditorForm.InvoiceLineId; qryEditInvoiceLine.ParamByName('QUANTITY').AsInteger := xEditorForm.Quantity; qryEditInvoiceLine.Execute(); trWrite.Commit; qryInvoice.Refresh; qryInvoiceLine.Refresh; Action := caFree; except on E: Exception do begin if trWrite.Active then trWrite.Rollback; Application.ShowException(E); //    .     Action := caNone; end; end; end;</span></span></code> </pre><br><br> ,   . ,           Delphi    FireDac     Firebird. <br><br>     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2b9/8fd/257/2b98fd257a8e4b80ae8de3454b5d5c89.png" alt="screenshot"></div><br><br> ,      ,   . <br><br><h2>  Links </h2><br> <a href="">     </a> </div><p>Source: <a href="https://habr.com/ru/post/273549/">https://habr.com/ru/post/273549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273535/index.html">How we switched from Scala to Go</a></li>
<li><a href="../273537/index.html">The digest of interesting materials for the mobile # 134 developer (December 14-20)</a></li>
<li><a href="../273543/index.html">Simple Blender. Part 5, final</a></li>
<li><a href="../273545/index.html">Quick start in 5 minutes with Angular 2 beta</a></li>
<li><a href="../273547/index.html">HP Thin Client as a home router and file server</a></li>
<li><a href="../273553/index.html">Comparison of css-frameworks / libraries on a live example. Part 1</a></li>
<li><a href="../273555/index.html">Forgotten word: environment</a></li>
<li><a href="../273557/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 190 (December 13 - 20, 2015)</a></li>
<li><a href="../273559/index.html">The future of p2p payments: when the smartphone replaces cash</a></li>
<li><a href="../273561/index.html">Welcome to the Russian-language site for developers on Rust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>