<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>3rd place in 11 steps in the Hola JavaScript contest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surely many of you have already flashed the headlines of articles from the competition from Hola , which recently came to its logical conclusion. In t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>3rd place in 11 steps in the Hola JavaScript contest</h1><div class="post__text post__text-html js-mediator-article">  Surely many of you have already flashed the headlines of articles from the <a href="http://habrahabr.ru/company/hola/blog/270847/">competition from Hola</a> , which recently came to its logical conclusion.  In the <a href="http://habrahabr.ru/company/hola/blog/275111/">final results</a> I was lucky to be in 3rd place.  For this reason, I allowed myself to share a description of <a href="">my decision</a> , as well as how I came to him. <br><a name="habracut"></a><br><h2>  1. Why am I worse? </h2><br>  The very first decision, naturally, "in a forehead".  We form a pair of regular expressions for each rule, and then we start the cycle according to the messages with a nested loop according to the rules.  The code to the disgrace is simple (and, as we already know, it easily fits into this frightening number of 666 bytes), so I don‚Äôt see the point here. <br><br><h2>  2. Long live dynamic functions! </h2><br>  The next step I decided to expand the inner loop.  To do this, preliminarily, based on the rules, we dynamically form the getActions (from, to) function and call it in a loop for each message.  The filter takes about the following form: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messages, rules</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   var builder = []; builder.push('var actions = [];'); for ( var i = 0; i &lt; rules.length; i++ ) { var rxFrom = createRegex(rules[i].from); if ( rxFrom ) builder.push(escapeRegex(rxFrom), '.test(from) &amp;&amp; '); var rxTo = createRegex(rules[i].to); if ( rxTo ) builder.push(escapeRegex(rxTo), '.test(to) &amp;&amp; '); builder.push('actions.push(\'', escapeString(rules[i].action), '\');'); } builder.push('return actions;'); var getActions = new Function('from, to', builder.join('')); //   var result = {}; for ( var key in messages ) { var message = messages[key]; result[key] = getActions(message.from, message.to); } return result; }</span></span></code> </pre> <br>  Below is an example of the generated getActions function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">from, to</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = []; <span class="hljs-regexp"><span class="hljs-regexp">/^.*@work\.com$/</span></span>.test(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'tag work'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">/^.*@spam\.com$/</span></span>.test(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'tag spam'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">/^jack@example\.com$/</span></span>.test(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/^jill@example\.org$/</span></span>.test(to) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'folder jack'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">/^jill@example\.com$/</span></span>.test(to) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'forward to jill@elsewhere.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> actions; }</code> </pre><br>  The advantage of this approach is that inside the function we are free to pre-program any conditions necessary for a particular rule.  Specifically in the above example, if the rule does not specify the from or to property, then there is no need to add to the function body a check of the corresponding message property for this rule.  And if none of these properties is specified in the rule, then the action specified in the rule is simply written into the resulting array without any checks. <br><br>  When using the same nested loop, to achieve this behavior, we would have to insert additional checks into the loop body, calculated at each iteration, which, of course, imposes additional costs. <br><br><h2>  3. Himself, all by yourself! </h2><br>  Further, I was still honored to get away from regular expressions and wrote the match (value, pattern) function, which determines whether the address matches the specified pattern or not, returning true or false, respectively.  Initially, the function I used to operate with characters / strings, but this approach was not very effective, so it became mainly operate with ASCII codes, which are obtained via String.charCodeAt (index) (there was also an attempt to use String.codePointAt (index), but it did not pay off in terms of effectiveness).  The function is cumbersome and not very interesting, so I will not bring it here. <br><br>  To call the match function from getActions, I passed it with an additional parameter after from and to. <br><br><h2>  4. Sorry, you are definitely not suitable for us. </h2><br>  Looking for a way to further increase performance, I decided that an eigenfunction is, of course, great, but it should be called less often, and again focused on getActions.  Actually, at this stage, the task was to, on the basis of some signs, knowingly exclude some of the rules and not call a resource-intensive function for them, and the determination of these signs by itself should not take a lot of time. <br><br>  One of these signs was just the first character of the template.  It can only be used if it was not a "?"  or "*".  The second sign, length, could be used when there is no ‚Äú*‚Äù symbol in the pattern (at that time I had not yet thought that the minimum length of the address could be checked). <br><br>  In order not to call a bunch of methods in the from and to properties of the message being processed when checking each rule, at the beginning of the getActions function, we calculate additional variables and use them as necessary: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">from, to, match</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fb = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>), fb61 = fb == <span class="hljs-number"><span class="hljs-number">0x61</span></span>, fb74 == <span class="hljs-number"><span class="hljs-number">0x74</span></span> <span class="hljs-comment"><span class="hljs-comment">/*, ... */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tb = to.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>), tb66 = tb === <span class="hljs-number"><span class="hljs-number">0x66</span></span> <span class="hljs-comment"><span class="hljs-comment">/*, ... */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fl = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.length, fl14 = fl == <span class="hljs-number"><span class="hljs-number">14</span></span>, fl15 = fl == <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-comment"><span class="hljs-comment">/*, ... */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tl = to.length, tl16 = tl == <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-comment"><span class="hljs-comment">/*, ... */</span></span>; fb61 &amp;&amp; tb66 &amp;&amp; fl15 &amp;&amp; tl16 &amp;&amp; match(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-string"><span class="hljs-string">'abc@example.com'</span></span>) &amp;&amp; match(to, <span class="hljs-string"><span class="hljs-string">'fake@example.com'</span></span>) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'action 1'</span></span>); fb74 &amp;&amp; fl14 &amp;&amp; match(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-string"><span class="hljs-string">'test@gmail.com'</span></span>) &amp;&amp; match(to, <span class="hljs-string"><span class="hljs-string">'*@any.net'</span></span>) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'action 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return actions; }</span></span></code> </pre><br>  This change gave a noticeable increase in productivity.  But you can see that in any template that starts with the symbol "*" it is impossible to navigate either the first character or the length.  And such templates should definitely meet. <br><br><h2>  5. And a few more questions. </h2><br>  Therefore, the next step I decided to try to classify templates also by domain.  Since anywhere in the domain can also meet "*", then I decided that I would take from it the maximum possible level of the domain up to the 3rd.  Accordingly, at the beginning of the getActions function, it is necessary to select the level 1, 2, and 3 domains from the properties of the message from and to and form a large batch of variables indicating that the message address belongs to one or another domain. <br><br>  As far as I can remember now, the method is not that completely non-working, but with different test data, it manifested itself in different ways.  Distinguishing domains from addresses and preliminary calculation of variables at each iteration ate a lot of time.  Here I tried a lot of different options.  For example, I grouped rarely meeting domains to reduce the number of calculated variables at first (by the way, I also conducted similar groupings with the first characters and lengths), tried to calculate the hash of the domains and compare it.  But in the end, I still refused to compare domains. <br><br><h2>  6. Somewhere nearby </h2><br>  Meanwhile, the thought was all in my head, and not to try to build a single tree from the beginning (and then from the end) of the templates to the first ‚Äú*‚Äù symbol, and shove into its leaves lists of rules that need to be checked?  Either I just didn‚Äôt really like this method, and I subconsciously built it inefficiently, or it really takes so long to build, but after the first experiments I decided that the creation of this structure is a rather slow thing, and I don‚Äôt want to mess with it. <br><br><h2>  7. Why reinvent the wheel? </h2><br>  I went back to the previous version, but instead of classifying by domains, I simply added a check of the last character of the template. <br><br>  It seems all is well, but not very.  Now it turns out that when checking every rule before the call of functions, the match could be checked up to 6 variables (and initially I wanted to reduce the number of checks), and even calculate all of them for each message.  I didn't like it.  Besides, experimenting with the number of checks for each rule and their sequence, I came to the conclusion that, with such a long check, the three signs of benefit are not much more than two.  Hence the next step. <br><br><h2>  8. In cramped, not mad </h2><br>  I decided that comparing the lengths of addresses and patterns is the most useless feature, and I excluded features from the excluding rules.  Only the first and last character matches are left.  From the conditions of the competition, remember that in the lines there can only be characters with codes in the range from 0x20 to 0x7F, which means that all the first and last characters of the patterns can easily fit into one Integer variable and only make one comparison for each rule before calling match.  There was only the problem that some templates at the beginning or end could have the characters "?"  and "*", which should not participate in the comparison.  But this problem is easily solved if before comparing the values ‚Äã‚Äãto impose on them a mask that resets the extra octets.  We get about the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">from, to, match</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.charCodeAt(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.length<span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>) | (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>) | (to.charCodeAt(to.length<span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | to.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); (hash &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>) == <span class="hljs-number"><span class="hljs-number">0x6D616D66</span></span> &amp;&amp; match(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-string"><span class="hljs-string">'abc@example.com'</span></span>) &amp;&amp; match(to, <span class="hljs-string"><span class="hljs-string">'fake@example.com'</span></span>) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'action 1'</span></span>); (hash &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF00</span></span>) == <span class="hljs-number"><span class="hljs-number">0x6D747400</span></span> &amp;&amp; match(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-string"><span class="hljs-string">'test@gmail.com'</span></span>) &amp;&amp; match(to, <span class="hljs-string"><span class="hljs-string">'*@any.net'</span></span>) &amp;&amp; actions.push(<span class="hljs-string"><span class="hljs-string">'action 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return actions; }</span></span></code> </pre><br>  And of course, the imposition of masks on the hash is also logical to pre-calculate the variables (they can not be more than 16) at the beginning of the function, so as not to perform this operation for each rule. <br><br><h2>  9. Divide and conquer! </h2><br>  The match function worked quite well, but it was universal for all templates, and that was its drawback.  For templates that do not contain the "*" symbol, it was not necessary to go through all these additional procedures, but it is enough to compare two strings character-by-character considering the features of the "?"  in the template.  The same applies to templates containing only one character "*".  In this case, it is logical to check the parts of the template before "*" and after. <br><br>  As a result, instead of one match function, there are five of them: <br><br><ul><li>  m1 (value, pattern) - comparison, if there is no "*" symbol in the pattern. </li><li>  m2 (value, pattern) - comparison, if the characters "*" are many. </li><li>  m3 (value, pattern, bl, el) - if one character "*" is in the middle of the pattern, then analysis of bl symbols at the beginning of the line and el at the end. </li><li>  m4 (value, pattern, bl) - if one character is "*" at the end of the pattern, then analysis of bl symbols at the beginning. </li><li>  m5 (value, pattern, el) - if one character is "*" at the beginning of the pattern, then the analysis of el characters is at the end. </li></ul><br>  In addition, I am passing the template to these functions as an array of character codes, and not as a string (so as not to pull the String.charCodeAt (index) method once again, I don‚Äôt really know if it has benefited). <br><br>  Accordingly, in the process of its formation, the getActions function is substituted for calls to the necessary functions (which are still passed through additional parameters).  At the same time, the consecutive "*" characters are removed from the templates, since this does not affect the result, and the comparison function is not.  (In the final solution, the implementation of this process is inside the createPatternMatchFunc function.) <br><br><h2>  10. Only shhh ... </h2><br>  There is one weak point in this decision.  In the worst case, if suddenly all templates begin with the same character, and even end with the same character, all of them will have the same hash and the template validation functions inside getActions will be called for absolutely all rules (if the addresses in the message , of course, fit). <br><br>  In this case, it would be logical to compare not the first, but the second or third characters from the beginning and end of the pattern (provided that they were not "*").  But how to determine which option is most optimal? <br><br>  I went the following way: <br><br><ol><li>  For the first and last three positions of the templates I calculated the frequency of occurrence of certain character codes; </li><li>  For each position, calculated the standard deviation of these frequencies; </li><li>  I chose at the beginning and end of the position with the minimum standard deviation (but not those in which there is only one character code). </li></ol><br>  In principle, it all worked, but the process of forming the getActions function slowed down, which affected the overall speed of the filter.  In addition, I was not bothered by the idea that the position with two variants of codes with equal frequencies and the position with eight variants of codes with equal frequencies have the same standard deviations, although it is logically clear that the second option is more appropriate for use.  Given the small performance failure, I did not try to balance all this, but simply returned to the analysis of the first and last characters (we were promised real data). <br><br><h2>  11. Practical magic and not only. </h2><br><ul><li>  During the experiments, it turned out that the string is better to first read the length property into a variable, and subsequent manipulations with this variable.  Even if it is used once.  So faster. </li><li>  To declare several variables in a row is faster with one var, separated by a comma, than with several variables separated by a semicolon. </li><li>  Passing comparison functions through getActions function parameters is slower than putting them in a global and calling from there. </li><li>  Changing the original messages object is more efficient than creating a new result object. </li><li>  It doesn‚Äôt matter whether you put == or === everywhere. </li></ul><br>  At this stage, the decision was sent for review. <br><br><h2>  12. Of the unfulfilled </h2><br>  To test the performance of my solution, I prepared test data, which included 600,000 messages and 1000 rules.  And among the messages there was not one with a pair of duplicate addresses.  Perhaps that is why I somehow had no idea about caching the results. <br><br>  By adding the caching of the getActions result, with the data used in the contest, on my machine I got a performance increase of 15% for large-data and 2% for xlarge-data (on my data, the performance degraded by 13%).  That is, when sending the solution in this form, probably in the final table, my result would be about 248 and 2303 ms instead of 292 and 2351 ms, respectively, and the article would be called ‚Äú2nd place in 12 steps‚Äù.  But, alas and oh! <br><br>  Thanks to the organizers, waiting for new contests! </div><p>Source: <a href="https://habr.com/ru/post/275343/">https://habr.com/ru/post/275343/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275331/index.html">To recursion through permutations</a></li>
<li><a href="../275333/index.html">JavaScript application, or why do we need Razor in ASP.NET MVC?</a></li>
<li><a href="../275337/index.html">Writing your spring-boot-starter</a></li>
<li><a href="../275339/index.html">Own search engine in the distributions of The Pirate Bay</a></li>
<li><a href="../275341/index.html">Patching modern application for use under Windows 2000</a></li>
<li><a href="../275347/index.html">Purple Encryption Machine</a></li>
<li><a href="../275351/index.html">Dynamic Interrupt Management in ARM</a></li>
<li><a href="../275353/index.html">HTML5 analog clock with JavaScript logic</a></li>
<li><a href="../275355/index.html">Anonymous Father Frost 2015-2016 - Post boasting New Year's gifts</a></li>
<li><a href="../275359/index.html">Office lighting control over Wi-Fi. Part 1: Atmel WINC1500 Wi-Fi Module</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>