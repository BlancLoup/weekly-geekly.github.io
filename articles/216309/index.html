<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SQL Server wait statistics or please tell me where it hurts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How many times have you experienced performance problems with SQL Server and decided exactly where to look? 

 One of the most rarely used SQL Server ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SQL Server wait statistics or please tell me where it hurts</h1><div class="post__text post__text-html js-mediator-article">  How many times have you experienced performance problems with SQL Server and decided exactly where to look? <br><br>  One of the most rarely used SQL Server performance troubleshooting methodologies is called ‚ÄúWaits and Queues‚Äù (also known as ‚ÄúWaiting Statistics‚Äù).  The basic premise of the methodology is that SQL Server constantly keeps track of which threads have to wait.  You can ask SQL Server for this information in order to reduce the list of possible causes of performance problems.  ‚ÄúExpectations‚Äù is what SQL Server is tracking.  "Queues" are resources that streams can access.  The system usually captures a huge amount of expectations, and they all mean waiting for access to various resources.  For example, waiting for PAGEIOLATCH_EX means that the stream is waiting to read a page of data from disk to the buffer pool.  Waiting for LCK_M_X means that the thread is waiting to be able to impose an exclusive lock on something. <br><br>  The great news is that SQL Server <b>knows</b> exactly what the performance issues are, and all you need to do is ask him ... and then correctly interpret what he will say, which can be a little more difficult. <br><a name="habracut"></a><br>  The following information is for people who are worried about each expectation and understand what causes it.  Expectations <b>always</b> arise.  This is how the SQL Server scheduling system works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The thread uses the processor and has the status of ‚Äúrunning‚Äù (RUNNING) until it is faced with the need to wait for access to the resource.  In this case, it is placed in an unordered list of threads in the "suspended" state (SUSPENDED).  At the same time, the next thread in the queue of threads waiting for access to the processor, organized according to the FIFO principle (the first to arrive - first dropped), and having the status of ‚Äúready for execution‚Äù (RUNNABLE) gets access to the processor and becomes ‚Äúrunning‚Äù.  If a thread in the "paused" state receives a notification that its resource is available, it becomes "ready for execution" and placed at the end of the queue of threads ready for execution.  The flow continues its cyclical movement along the chain ‚Äúis being executed‚Äù - ‚Äúsuspended‚Äù - ‚Äúis ready for execution‚Äù until the task is completed.  You can see the processes and their states using the Dynamic Management View (DMV) sys.dm_exec_requests. <br><br>  SQL Server tracks the time elapsed between the exit of the thread from the ‚Äúrunning‚Äù state and its return to this state, defining it as ‚Äúwait time‚Äù and time spent in the ‚Äúready to run‚Äù state, defining it as ‚Äútime signal wait time ‚Äù, i.e.  how long it takes for the thread after receiving a signal about the availability of resources in order to gain access to the processor.  We need to understand how much time the thread spends in the ‚Äúsuspended‚Äù state, called the ‚Äúresource wait time‚Äù, subtracting the signal wait time from the total wait time. <br><br>  An excellent source of information that I recommend reading about this is the new (2014) waiting statistics document <a href="https://www.sqlskills.com/help/sql-server-performance-tuning-using-wait-statistics/">"Tuning SQL Server Performance Using Expectancy Statistics: A Guide for a Newbie"</a> (English), which I advise you to read.  There is also a much older document ( <a href="http://download.microsoft.com/download/4/7/a/47a548b9-249e-484c-abd7-29f31282b04d/Performance_Tuning_Waits_Queues.doc">"Adjusting performance using expectations and queues"</a> (English) with a lot of useful information, but quite obsolete at the moment. The best manual on various types of expectations (and classes of short-term locks) - my comprehensive library of <a href="https://www.sqlskills.com/help/waits/">expectations</a> (English) and <a href="https://www.sqlskills.com/help/latches/">short-term blocking</a> (English). <br><br>  You can query SQL Server for accumulated wait statistics using DMV sys.dm_os_wait_stats.  Many people prefer to wrap a DMV call into some kind of summary code.  Below is the latest version of my script as of 2016, which works with all versions and includes wait types for SQL Server 2016 (see the version of the script for use in Azure <a href="https://sqlperformance.com/2016/03/sql-performance/tuning-azure-sql-database">here</a> ): <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> [Waits] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [wait_type], [wait_time_ms] / <span class="hljs-number"><span class="hljs-number">1000.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [WaitS], ([wait_time_ms] - [signal_wait_time_ms]) / <span class="hljs-number"><span class="hljs-number">1000.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [ResourceS], [signal_wait_time_ms] / <span class="hljs-number"><span class="hljs-number">1000.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [SignalS], [waiting_tasks_count] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [WaitCount], <span class="hljs-number"><span class="hljs-number">100.0</span></span> * [wait_time_ms] / <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span> ([wait_time_ms]) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [Percentage], ROW_NUMBER() <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> [wait_time_ms] <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">RowNum</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_os_wait_stats <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> [wait_type] <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( N<span class="hljs-string"><span class="hljs-string">'BROKER_EVENTHANDLER'</span></span>, N<span class="hljs-string"><span class="hljs-string">'BROKER_RECEIVE_WAITFOR'</span></span>, N<span class="hljs-string"><span class="hljs-string">'BROKER_TASK_STOP'</span></span>, N<span class="hljs-string"><span class="hljs-string">'BROKER_TO_FLUSH'</span></span>, N<span class="hljs-string"><span class="hljs-string">'BROKER_TRANSMITTER'</span></span>, N<span class="hljs-string"><span class="hljs-string">'CHECKPOINT_QUEUE'</span></span>, N<span class="hljs-string"><span class="hljs-string">'CHKPT'</span></span>, N<span class="hljs-string"><span class="hljs-string">'CLR_AUTO_EVENT'</span></span>, N<span class="hljs-string"><span class="hljs-string">'CLR_MANUAL_EVENT'</span></span>, N<span class="hljs-string"><span class="hljs-string">'CLR_SEMAPHORE'</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- Maybe uncomment these four if you have mirroring issues N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE', N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE', N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX', -- Maybe uncomment these six if you have AG issues N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE', N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'MEMORY_ALLOCATION_EXT', N'ONDEMAND_TASK_QUEUE', N'PREEMPTIVE_XE_GETTARGETSTATE', N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'PWAIT_DIRECTLOGCONSUMER_GETNEXT', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', N'QDS_ASYNC_QUEUE', N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'QDS_SHUTDOWN_QUEUE', N'REDO_THREAD_PENDING_WORK', N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP', N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY', N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK', N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES', N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_RECOVERY', N'WAIT_XTP_HOST_WAIT', N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN', N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') AND [waiting_tasks_count] &gt; 0 ) SELECT MAX ([W1].[wait_type]) AS [WaitType], CAST (MAX ([W1].[WaitS]) AS DECIMAL (16,2)) AS [Wait_S], CAST (MAX ([W1].[ResourceS]) AS DECIMAL (16,2)) AS [Resource_S], CAST (MAX ([W1].[SignalS]) AS DECIMAL (16,2)) AS [Signal_S], MAX ([W1].[WaitCount]) AS [WaitCount], CAST (MAX ([W1].[Percentage]) AS DECIMAL (5,2)) AS [Percentage], CAST ((MAX ([W1].[WaitS]) / MAX ([W1].[WaitCount])) AS DECIMAL (16,4)) AS [AvgWait_S], CAST ((MAX ([W1].[ResourceS]) / MAX ([W1].[WaitCount])) AS DECIMAL (16,4)) AS [AvgRes_S], CAST ((MAX ([W1].[SignalS]) / MAX ([W1].[WaitCount])) AS DECIMAL (16,4)) AS [AvgSig_S], CAST ('https://www.sqlskills.com/help/waits/' + MAX ([W1].[wait_type]) as XML) AS [Help/Info URL] FROM [Waits] AS [W1] INNER JOIN [Waits] AS [W2] ON [W2].[RowNum] &lt;= [W1].[RowNum] GROUP BY [W1].[RowNum] HAVING SUM ([W2].[Percentage]) - MAX( [W1].[Percentage] ) &lt; 95; -- percentage threshold GO</span></span></code> </pre> <br><br>  The result of the query will show the expectations, grouped by percentage of all expectations in the system, in descending order.  The expectations that are (potentially) worth paying attention to are at the top of the list and represent a large part of the expectations that SQL Server spends time.  You see a large list of expectations that are removed from consideration - as I said earlier, they always arise and those listed above, we can, as a rule, ignore. <br><br>  You can also reset the statistics accumulated by the server using this code: <br><br><pre> <code class="sql hljs">DBCC SQLPERF (N'sys.dm_os_wait_stats', CLEAR); GO</code> </pre><br><br>  And, of course, you can come up with storing results every few hours or every day and do some time analysis to find out the direction of the changes, or automatically track problems in case they start to appear. <br>  You can also use Performance Dashboard to display the results graphically in SQL Server 2005 and Data Collector in SQL Server 2008. In SQL Server 2000, you can use DBCC SQLPERF (N'waitstats') . <br><br>  After you get the results, you will begin to think how to interpret them and where to look.  The document I referred to earlier has a wealth of information on most types of expectations (except those added in SQL Server 2008). <br><br>  Now I would like to provide the results of a study that I published some time ago.  I asked people to run the code presented above and report the results to me.  I received a huge amount of results - from 1823 servers - thanks! <br><br>  Below is a graphical representation of the results: <br><br><img src="https://habrastorage.org/files/ef7/967/167/ef796716729240fcb044ac3db081326b.jpg"><br><br>  I am not at all surprised by the top 4 results, as I have seen them again and again on the systems of my clients. <br><br>  In continuation of my article, I am going to list the most popular types of expectations provided by the survey respondents, in descending order, and comment in a few words what exactly they can mean if they are basic to your system.  The format of the list shows the number of systems from the respondents in which the specified type of waiting is the main one. <br><br><ul><li>  505: CXPACKET <br>  Means parallelism, but not necessarily a problem.  The coordinator thread in a parallel query always accumulates these expectations.  If parallel threads are not busy or one of the threads is blocked, then the waiting threads also accumulate waiting for CXPACKET, which leads to a more rapid accumulation of statistics on this type - this is the problem.  One thread can have more work than the others, and for this reason the entire request is blocked until the long thread finishes its work.  If this type of wait is combined with large wait numbers PAGEIOLATCH_XX, then it can be a scan of large tables due to incorrect nonclustered indexes or due to a poor query execution plan.  If this is not the reason, you can try using the MAXDOP option with values ‚Äã‚Äãof 4, 2, or 1 for problematic queries or for the entire server instance (set on the server with the ‚Äúmax degree of parallelism‚Äù parameter).  If your system is based on a NUMA scheme, try setting MAXDOP to a value equal to the number of processors in a single NUMA node in order to determine if this is the problem.  You also need to determine the effect of installing MAXDOP on mixed load systems.  To be honest, I would play with the ‚Äúcost threshold for parallelism‚Äù parameter (raising it to 25 for a start) before lowering the MAXDOP value for the entire instance.  And don't forget about the Resource Governor in the Enterprise version of SQL Server 2008, which allows you to set the number of processors for a specific group of server connections. </li><li>  304: PAGEIOLATCH_XX <br>  This is where SQL Server waits for a page of data from disk to memory.  This type of wait may indicate a problem in the I / O system (which is the first response to this type of wait), but why should the I / O system serve such a number of reads?  It is possible that pressure is exerted by the buffer pool / memory (not enough memory for a typical load), a sudden change in execution plans, leading to large parallel scans instead of searching, swelling of the plan cache, or some other reasons.  You should not assume that the main problem in the system I / O. </li><li>  275: ASYNC_NETWORK_IO <br>  Here, SQL Server waits for the client to finish receiving data.  The reason may be that the client requested too much data, or simply gets it sooo slow due to bad code - I almost never saw the problem in the network.  Clients often read one row at a time ‚Äî the so-called RBAR or ‚Äúrow by agonizing row‚Äù (Row-By-Agonizing-Row) ‚Äîbut instead of caching data on the client and notifying SQL Server of the end of reading immediately. </li><li>  112: WRITELOG <br>  The log management subsystem waits for the log to disk.  As a rule, it means that the input / input system cannot ensure timely recording of the entire log volume, but on high-loaded systems this may be caused by general log recording restrictions, which may mean that you should divide the load between several databases, or even make your transactions a little longer to reduce the number of log records per disk.  To verify that the cause is in the I / O system, use DMV sys.dm_io_virtual_file_stats to examine the I / O latency for the log file and see if it is the same as the WRITELOG delay time.  If the WRITELOG lasts longer, you have received internal contention for writing to disk and must share the workload.  If not, find out why you are creating such a large transaction log.  <a href="http://www.sqlperformance.com/2012/12/io-subsystem/trimming-t-log-fat">Here</a> (English) and <a href="http://www.sqlperformance.com/2013/01/io-subsystem/trimming-more-transaction-log-fat">here</a> (English) you can draw some ideas. <br>  <i>(translator's example: the following query allows you to get input / output delay statistics for each file of each database on the server in a simple and convenient way:</i> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- : .   &gt; 20  USE master GO SELECT cast(db_name(a.database_id) AS VARCHAR) AS Database_Name , b.physical_name --, a.io_stall , a.size_on_disk_bytes , a.io_stall_read_ms / a.num_of_reads '.   ' , a.io_stall_write_ms / a.num_of_writes '.   ' --, * FROM sys.dm_io_virtual_file_stats(NULL, NULL) a INNER JOIN sys.master_files b ON a.database_id = b.database_id AND a.file_id = b.file_id where num_of_writes &gt; 0 and num_of_reads &gt; 0 ORDER BY Database_Name , a.io_stall DESC</span></span></code> </pre></div></div></li><li>  109: BROKER_RECEIVE_WAITFOR <br>  Here the service broker is waiting for new messages.  I would recommend adding this wait to the exclude list and re-run the query with wait statistics. </li><li>  086: MSQL_XP <br>  Here, SQL Server is waiting for the execution of extended stored procedures.  This may indicate problems in the code of your extended stored procedures. </li><li>  074: OLEDB <br>  As the name suggests, this is waiting for interaction using OLEDB ‚Äî for example, with an associated server.  However, OLEDB is also used in DMV and the DBCC CHECKDB command, so do not think that the problem is necessarily in connected servers ‚Äî this could be an external monitoring system that over-uses DMV calls.  If this is indeed a connected server, then analyze the expectations on the connected server and determine what the problem is with the performance on it. </li><li>  054: BACKUPIO <br>  Shows when you backup directly to tape, which is sooo slow.  I would prefer to filter this wait.  <i>(comment of the translator: I met this type of expectations when writing a backup to a disk, but the small database was very long backed up, not having time to complete a technological break and causing problems with users' productivity. If this is your case, the input system may be I / O used for backups, you need to consider increasing its performance or review the maintenance plan (do not perform full backups during short technological interruptions, replacing them with differential ones)</i> </li><li>  041: LCK_M_XX <br>  Here, the thread simply waits for access to impose a lock on the object and means problems with locks.  This can be caused by unwanted escalation of locks or bad code, but it can also be caused by the fact that I / O operations take too long and hold locks longer than usual.  Look at the resources associated with locks using DMV sys.dm_os_waiting_tasks.  Do not assume that the main problem is in locks. </li><li>  032: ONDEMAND_TASK_QUEUE <br>  This is normal and is part of a background task system (such as a pending reset, cleaning in the background).  I would add this wait to the exclude list and re-execute the query with the wait statistics. </li><li>  031: BACKUPBUFFER <br>  Shows when you backup directly to tape, which is sooo slow.  I would prefer to filter this wait. </li><li>  027: IO_COMPLETION <br>  SQL Server is waiting for I / O completion and this type of wait can be an indicator of a problem with the I / O system. </li><li>  024: SOS_SCHEDULER_YIELD <br>  Most often this is a code that does not fall into other types of expectations, but sometimes it can be a concurrency in a cyclic lock. </li><li>  022: DBMIRROR_EVENTS_QUEUE <br>  022: DBMIRRORING_CMD <br>  These two types indicate that the database mirroring control system is sitting and waiting for what to do.  I would add these expectations to the exclusion list and re-execute the query with the wait statistics. </li><li>  018: PAGELATCH_XX <br>  This is a competition for access to copies of pages in memory.  The most well-known cases are the PFS, SGAM, and GAM competition <a href="http://www.sqlskills.com/blogs/paul/a-sql-server-dba-myth-a-day-1230-tempdb-should-always-have-one-data-file-per-processor-core/">arising in the tempdb database under certain types of loads</a> (English).  In order to find out which pages are competing for, you need to use DMV sys.dm_os_waiting_tasks in order to find out which pages are blocking.  On problems with the tempdb base, Robert Davis (his <a href="http://www.sqlservercentral.com/blogs/robert_davis/">blog</a> , <a href="https://twitter.com/SQLSoldier">twitter</a> ) wrote a good <a href="http://www.sqlservercentral.com/blogs/robert_davis/2010/03/05/Breaking-Down-TempDB-Contention/">article showing how to solve them</a> (Eng.) Another common reason I saw was a frequently updated index with competing index inserts using a serial key (IDENTITY). </li><li>  016: LATCH_XX <br>  This is a competition for any non-page structures in SQL Server ‚Äî so this is not related to I / O and data in general.  The reason for this type of delay can be quite difficult to understand and you need to use DMV sys.dm_os_latch_stats. </li><li>  013: PREEMPTIVE_OS_PIPEOPS <br>  Here, SQL Server switches to proactive scheduling mode in order to query Windows for something.  This type of wait was added in the 2008 version and has not yet been documented.  The easiest way to find out what it means is to remove the initial PREEMPTIVE_OS_ and search for what's left in MSDN - this will be the name of the Windows API. </li><li>  013: THREADPOOL <br>  This type says that there are not enough worker threads in the system to satisfy the request.  Usually the reason is a large number of highly parallelized requests trying to be executed.  <i>(note of the translator: this may also be the intentionally curtailed value of the max worker threads server parameter)</i> </li><li>  009: BROKER_TRANSMITTER <br>  Here Service Broker is waiting for new messages to be sent.  I would recommend adding this wait to the exclude list and re-run the query with wait statistics. </li><li>  006: SQLTRACE_WAIT_ENTRIES <br>  Part of the listener (trace) SQL Server'a.  I would recommend adding this wait to the exclude list and re-run the query with wait statistics. </li><li>  005: DBMIRROR_DBM_MUTEX <br>  This is one of the undocumented types and there is competition for sending the buffer, which is divided between the mirroring sessions (database mirroring).  It may mean that you have too many mirroring sessions. </li><li>  005: RESOURCE_SEMAPHORE <br>  Here the request is waiting for the memory to be executed (the memory used to process the request operators, such as sorting).  This may be a lack of memory at competitive load. </li><li>  003: PREEMPTIVE_OS_AUTHENTICATIONOPS <br>  003: PREEMPTIVE_OS_GENERICOPS <br>  Here, SQL Server switches to proactive scheduling mode in order to query Windows for something.  This type of wait was added in the 2008 version and has not yet been documented.  The easiest way to find out what it means is to remove the initial PREEMPTIVE_OS_ and search for what's left in MSDN - this will be the name of the Windows API. </li><li>  003: SLEEP_BPOOL_FLUSH <br>  This wait can often be seen and it means that the control point limits itself in order to avoid overloading the I / O system.  I would recommend adding this wait to the exclude list and re-run the query with wait statistics. </li><li>  002: MSQL_DQ <br>  Here, SQL Server waits until a distributed query is executed.  This may mean problems with distributed queries, or it may just be the norm. </li><li>  002: RESOURCE_SEMAPHORE_QUERY_COMPILE <br>  When there are too many competing recompilations of queries in the system, SQL Server limits their execution.  I don‚Äôt remember the level of the restriction, but this wait can mean excessive recompilation or perhaps too frequent use of one-time plans. </li><li>  001: DAC_INIT <br>  I have never seen this before and BOL says that the reason for the initialization of the administrative connection.  I can not imagine how this can be the priority of waiting on someone else's system ... </li><li>  001: MSSEARCH <br>  This type is normal for full-text operations.  If this is a preferential wait, it may mean that your system spends the most time on performing full-text queries.  You may consider adding this type of wait to the exclusion list. </li><li>  001: PREEMPTIVE_OS_FILEOPS <br>  001: PREEMPTIVE_OS_LIBRARYOPS <br>  001: PREEMPTIVE_OS_LOOKUPACCOUNTSID <br>  001: PREEMPTIVE_OS_QUERYREGISTRY <br>  Here, SQL Server switches to proactive scheduling mode in order to query Windows for something.  This type of wait was added in the 2008 version and has not yet been documented.  The easiest way to find out what it means is to remove the initial PREEMPTIVE_OS_ and search for what's left in MSDN - this will be the name of the Windows API. </li><li>  001: SQLTRACE_LOCK <br>  Part of the listener (trace) SQL Server'a.  I would recommend adding this wait to the exclude list and re-run the query with wait statistics. </li></ul><br><br>  Hope it was interesting!  Let me know if you are interested in something specifically or that you have read this article and enjoyed it! </div><p>Source: <a href="https://habr.com/ru/post/216309/">https://habr.com/ru/post/216309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216297/index.html">The digest of new gadgets and "ducks" from Madrobots # 1</a></li>
<li><a href="../216301/index.html">The logic of thinking. Part 13. Associative memory</a></li>
<li><a href="../216303/index.html">Java 8 Released</a></li>
<li><a href="../216305/index.html">Announcement and pre-order Unity 3D 5</a></li>
<li><a href="../216307/index.html">The book "Systems Engineering for Dummies": an electronic version of the book for everyone</a></li>
<li><a href="../216311/index.html">Volvo proposes to modify the roadbed for unmanned vehicles</a></li>
<li><a href="../216313/index.html">Tizen DevLab and Hackathon in Moscow</a></li>
<li><a href="../216315/index.html">ATM. Some features</a></li>
<li><a href="../216317/index.html">DNPric.es: the largest database of domain transactions</a></li>
<li><a href="../216319/index.html">Memo for the preparation of the IT budget</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>