<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "C ++ 17 STL. Standard Template Library ¬ª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The book describes the work with containers, algorithms, auxiliary classes, lambda expressions and other interesting tools that are rich in modern C +...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "C ++ 17 STL. Standard Template Library ¬ª</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/rd/cn/0u/rdcn0usi9pzh72z7-qnztyzj6ty.jpeg" align="left" alt="image">  The book describes the work with containers, algorithms, auxiliary classes, lambda expressions and other interesting tools that are rich in modern C ++.  Having mastered the material, you will be able to radically reconsider the usual approach to programming.  The advantage of the publication is in the detailed description of the standard C ++ template library, STL.  Its latest version was released in 2017.  In the book you will find more than 90 of the most realistic examples that demonstrate the power of STL.  Many of them will become basic building blocks for solving more universal tasks.  Armed with this book, you can effectively use C ++ 17 to create high-quality and high-performance software that is applicable in various industries. <br><br>  The following is an excerpt of ‚ÄúLambda expressions‚Äù. <br><a name="habracut"></a><br>  One of the important new features in C ++ 11 was lambda expressions.  In C ++ 14 and C ++ 17, they received new features, and this made them even more powerful.  But what is a lambda expression? <br><br>  Lambda expressions or lambda functions create closures.  A closure is a very general term for nameless objects that can be called as functions.  To provide such an opportunity in C ++, such an object must implement a function call operator (), with or without parameters.  Creating a similar object without lambda expressions before the appearance of C ++ 11 would look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs go">#include &lt;iostream&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> name_greeter { std::<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name; void operator()() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> &lt;&lt; name &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } }; name_greeter greet_john_doe {<span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>}; greet_john_doe(); }</code> </pre> <br>  Instances of the name_greeter structure obviously contain a string.  Please note: the type of this structure and the object are not nameless, unlike lambda expressions.  In terms of closures, it can be argued that they capture the string.  When the example instance is called as a function with no parameters, the string ‚ÄúHello, John Doe‚Äù is displayed, since we specified a string with that name. <br><br>  Starting from C ++ 11, it has become easier to create such closures: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { auto greet_john_doe ([] { std::cout &lt;&lt; "Hello, John Doe\n"; }); greet_john_doe(); }</span></span></span></span></code> </pre> <br>  That's all.  The whole name_greeter structure is replaced with a small [] {/ * to do something * /}, which at first glance looks strange, but in the next section we will consider all possible cases of its use. <br><br>  Lambda expressions help keep the code generic and clean.  They can be used as parameters for generalized algorithms to refine them when processing specific user-defined types.  They can also be used to wrap work packages and data so that they can be run in streams or simply save work and postpone the execution of the packages themselves.  After the advent of C ++ 11, many libraries were created that work with lambda expressions, since they became a natural part of the C ++ language.  Another use of lambda expressions is metaprogramming, since they can be evaluated during program execution.  However, we will not consider this question, since it does not relate to the topic of this book. <br><br>  In the current chapter, we will rely to a large extent on individual functional programming patterns, which may seem strange to newbies and even experienced programmers who have not yet worked with such patterns.  If in the following examples you see lambda expressions returning lambda expressions, which again return lambda expressions, then please do not get lost.  We are somewhat beyond the scope of the usual programming style to prepare for working with the modern C ++ language, in which functional programming templates are encountered more and more often.  If the code of an example looks too complicated, take the time to take a closer look at it.  As soon as you figure it out, complex lambda expressions in real projects will no longer confuse you. <br><br><h3>  Dynamic definition of functions using lambda expressions </h3><br>  Using lambda expressions, you can encapsulate the code to call it later or even in another place, since it is allowed to copy.  In addition, you can encapsulate the code several times with slightly different parameters, without having to implement a new function class for this task. <br><br>  The lambda expression syntax looked new in C ++ 11, and by C ++ 17 it has changed somewhat.  In this section, we will see what lambda expressions look like and what they mean. <br><br><h3>  How it's done </h3><br>  In this example, we will write a small program in which we will work with lambda expressions in order to understand the basic principles of interaction with them. <br><br>  1. To work with lambda expressions, no library support is needed, but we will display messages on the console and use strings, so we need the appropriate header files: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt;</span></span></span></span></code> </pre> <br>  2. In this example, all the action takes place in the function main.  We define two objects of functions that do not accept parameters, and return integer constants with values ‚Äã‚Äã1 and 2. Note: the return expression is surrounded by curly brackets {}, as is done in ordinary functions, and parentheses (), indicating a function without parameters , are optional, we do not specify them in the second lambda expression.  But square brackets [] must be present: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">just_one</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [](){ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">just_two</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [] { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } )</span></span></span></span>;</code> </pre> <br>  3. Now you can call both objects of functions simply by writing the name of the variables that are stored in them, and adding parentheses.  In this line, they cannot be distinguished from ordinary functions: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; just_one() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; just_two() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre> <br>  Let's forget about them and define another function object, called plus, - it takes two parameters and returns their sum: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [](</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r) { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l + r; } )</span></span></span></span>;</code> </pre> <br>  5. It is quite simple to use such an object, in this respect it is similar to any other binary function.  We indicated that its parameters are of type auto, so that the object will work with all data types for which the + operator is defined, for example, with strings. <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; plus(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; plus(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"a"</span></span>}, <span class="hljs-string"><span class="hljs-string">"b"</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre> <br>  6. No need to save the lambda expression in a variable to use it.  We can also define it in the place where it is needed, and then place the parameters for this expression in parentheses immediately after it (1, 2): <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> r){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l + r; }(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre> <br>  7. Next, we define a closure that contains an integer counter.  With each call, the value of this counter will increase by 1 and return the new value.  To indicate that the closure contains an internal counter, put the expression count = 0 in parentheses - it indicates that the count variable is initialized with the integer value 0. To allow it to change its own variables, we use the mutable keyword, because otherwise the compiler will not allow do it: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counter</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] () </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mutable</span></span></span></span><span class="hljs-function"><span class="hljs-params"> { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ++count; } )</span></span></span></span>;</code> </pre> <br>  8. Now call the function object five times and display the values ‚Äã‚Äãreturned by it in order to see that the counter value increases: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i {<span class="hljs-number"><span class="hljs-number">0</span></span>}; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; counter() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre> <br>  9. We can also take existing variables and grab them by reference instead of creating a copy of the value for the closure.  Thus, the value of the variable will increase in the closure and at the same time will be available outside of it.  To do this, we put the &amp; a construct in brackets, where the &amp; symbol means that we save the reference to the variable, but not the copy: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [&amp;a] { ++a; } )</span></span></span></span>;</code> </pre> <br>  10. If it works, then you can call this function object several times, and then see if the value of the variable a really changes: <br><br><pre> <code class="hljs cpp">incrementer(); incrementer(); incrementer(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Value of 'a' after 3 incrementer() calls: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre> <br>  11. The last example demonstrates currying.  It means that we take a function that takes some parameters, and then store it in another function object that takes fewer parameters.  In this case, we save the plus function and accept only one parameter, which will be passed to the plus function.  Another parameter is 10;  we keep it in the function object.  Thus, we get the function and call it plus_ten, because it can add the value 10 to the only parameter it takes. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus_ten</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [=] (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x) { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plus(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, x); } )</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; plus_ten(<span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br>  12. Before compiling and running the program, we will go through the code again and try to predict exactly which values ‚Äã‚Äãwill be displayed in the terminal.  Then run the program and take a look at the real output: <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ab <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> incrementer() calls: <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre> <br><h3>  How it works </h3><br>  What we have just done does not look too complicated: put the numbers together, then increment them and display them on the screen.  We even performed string concatenation using the function object, which was implemented to add numbers.  But for those who are still unfamiliar with the lambda expression syntax, this may seem confusing. <br><br>  So, first consider all the features associated with lambda expressions (Fig. 4.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ln/o4/c7/lno4c73cjrrvcgw8_9kze4my03e.png" alt="image"></div><br>  As a rule, you can omit most of these parameters to save some time.  The shortest lambda expression is [] {}.  It takes no parameters, captures nothing and, in fact, does nothing.  What does the rest mean? <br><br><h3>  Capture List </h3><br>  Determines exactly what we are capturing and whether we are capturing at all.  There are several ways to do this.  Consider two "lazy" options. <br><br>  1. If we write [=] () {...}, then we capture each external variable referenced by the closure by value;  that is, these values ‚Äã‚Äãwill be copied. <br><br>  2. The record [&amp;] () {...} means the following: all external objects referenced by the closure are captured only by reference, which does not lead to copying. <br><br>  Of course, you can set the capture settings for each variable separately.  The record [a, &amp; b] () {...} means that we capture variable a by value, and variable b by reference.  This will require more text to be printed, but as a rule, this method is safer, since we cannot accidentally capture something unnecessary from outside the circuit. <br><br>  In the current example, we defined a lambda expression as follows: [count = 0] () {...}.  In this special case, we are not capturing any variables from outside the closure limits, only defined a new variable named count.  The type of this variable is determined based on the value with which we initialized it, namely, 0, so that it is of type int. <br><br>  In addition, you can capture some variables by value, and others by reference, for example: <br><br>  ‚Ä¢ [a, &amp; b] () {...} - copy a and take a link to b; <br>  ‚Ä¢ [&amp;, a] () {...} - copy a and use the reference to any other transferred variable; <br>  ‚Ä¢ [=, &amp; b, i {22}, this] () {...} - we get a link to b, copy the value of this, initialize the new variable i with value 22 and copy any other used variable. <br><br>  <b>mutable (optional)</b> <br>  If the function object should be able to modify the variables it receives by copying ([=]), then it should be defined as mutable.  The same applies to invoking non-constant methods of captured objects. <br><br>  <b>constexpr (optional)</b> <br>  If we explicitly mark a lambda with the constexpr keyword, the compiler will generate an error when this expression does not meet the criteria of the constexpr function.  The advantage of using constexpr functions and lambda expressions is that the compiler can evaluate their result at compile time if they are called with parameters that are constant throughout the process.  This will lead to the fact that later in the binary file will be less code. <br><br>  If we do not explicitly indicate that lambda expressions are constexpr, but these expressions meet all the required criteria, then they will still be considered constexpr, only implicitly.  If it is necessary for the lambda expression to be constexpr, then it is better to explicitly set it as such, since otherwise, in the case of our incorrect actions, the compiler will start generating errors. <br><br>  <b>exception attr (optional)</b> <br>  Here it is determined whether the function object can throw exceptions if it encounters an error during the call. <br><br>  <b>return type (optional)</b> <br>  If you need to have full control over the returned type, it is probably not necessary for the compiler to automatically determine it.  In such cases, you can simply use the [] () -&gt; Foo {} construct, which will indicate to the compiler that we will always return objects of type Foo. <br><br><h3>  Add polymorphism by wrapping lambda expressions in std :: function </h3><br>  Suppose you need to write an observer function for some value that may change from time to time, which will alert other objects, such as gas pressure indicator, share prices, etc. When changing the value, a list of observer objects should be called then in their own way they will respond. <br><br>  To implement the task, you can put several objects of the observer function into a vector, all of them will take as a parameter a variable of type int, which represents the observed value.  We do not know what exactly these functions will do when called, but this is not interesting for us. <br><br>  What type will the function objects have in the vector?  We can use the type std :: vector &lt;void (*) (int)&gt; if we capture pointers to functions that have signatures like void f (int) ;.  This type will work with any lambda expression that captures something that has a completely different type in comparison with a normal function, since it is not just a pointer to a function, but an object that combines a certain amount of data with a function!  Think of the times before C ++ 11, when lambda expressions did not exist.  Classes and structures were a natural way of associating data with functions, and changing the types of members of a class will result in a completely different class.  It is natural that a vector cannot store values ‚Äã‚Äãof different types using the same type name. <br><br>  It is not necessary to indicate to the user that he can save objects to the functions of the observer, which do not capture anything, since this limits application options.  How to allow it to save any objects of functions, limiting only the call interface, which accepts a specific range of parameters as observable values? <br><br>  In this section, we will look at how to solve this problem using the std :: function object, which can act as a polymorphic shell for any lambda expression, no matter what values ‚Äã‚Äãit captures. <br><br><h3>  How it's done </h3><br>  In this example, we will create several lambda expressions that are significantly different from each other, but have the same call signature.  Then save them in one vector with std :: function. <br><br>  1. First, turn on the necessary header files: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;deque&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;list&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt;</span></span></span></span></code> </pre> <br>  2. We implement a small function that returns a lambda expression.  It takes a container and returns a function object that captures this container by reference.  The function object itself takes an integer parameter.  When this object receives an integer, it will add it to its container. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consumer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;container)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> value) { container.push_back(value); }; }</code> </pre> <br>  3. Another small helper function will display the contents of the container instance, which we will provide as a parameter: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i : c) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br>  4. In the main function, we will create objects of the deque, list and vector classes, each of which will store integers: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; d; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; l; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v;</code> </pre> <br>  5. Now we will use the consumer function for working with our d, l and v container instances: create consumer function objects for them and place them into the vector instance.  These function objects will capture a link to one of the container objects.  The latter have different types, like function objects.  However, the vector stores instances of type std :: function &lt;void (int)&gt;.  All function objects implicitly turn into objects of type std :: function, which are then stored in a vector: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt;&gt; consumers {consumer(d), consumer(l), consumer(v)};</code> </pre> <br>  6. Now put ten integer values ‚Äã‚Äãin all data structures, traversing the values ‚Äã‚Äãin the loop, and then looping through the objects of the consumer functions that we call with the recorded values: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;consume : consumers) { consume(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } }</code> </pre> <br>  7. All three containers should now contain the same ten numbers.  Let's display their contents: <br><br><pre> <code class="hljs swift"> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(d); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(l); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(v); }</code> </pre> <br>  8. Compiling and running the program will give the following result, which looks exactly as we expected: <br><br><pre> <code class="hljs ruby">$ ./std_function <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,</code> </pre> <br><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/all/product/s17-stl-standartnaya-biblioteka-shablonov">the publisher's website.</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610680/978544610680_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610680/978544610680_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley a 25% discount on the coupon - <b>C ++ 17 STL</b> </div><p>Source: <a href="https://habr.com/ru/post/353404/">https://habr.com/ru/post/353404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353374/index.html">"Holey beep": found a critical vulnerability in the "beeper" Linux</a></li>
<li><a href="../353376/index.html">Professional burnout: how to recognize and prevent</a></li>
<li><a href="../353398/index.html">Transcription of the twelfth release of the podcast "Procurator"</a></li>
<li><a href="../353400/index.html">Internship retrospective</a></li>
<li><a href="../353402/index.html">Flappy Bird: - Let's go</a></li>
<li><a href="../353406/index.html">How I pumped the skills of personal effectiveness</a></li>
<li><a href="../353408/index.html">Scientific programming: part 1</a></li>
<li><a href="../353410/index.html">Device and mechanism of work of Prometheus Operator in Kubernetes</a></li>
<li><a href="../353412/index.html">What is frozen on feature freeze</a></li>
<li><a href="../353414/index.html">Analysis of the main concepts of concurrency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>