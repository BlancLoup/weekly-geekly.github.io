<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ATmega16 + DS18B20 + LED + Matlab / Simulink = AR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I thought of somehow playing around with the DS18B20 sensors. And not just to get the temperature values ‚Äã‚Äã(which everyone can do), but somehow to vis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ATmega16 + DS18B20 + LED + Matlab / Simulink = AR</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/e2a/4a8/d70/e2a4a8d7092845e082baee85d185ebd2.bmp">  I thought of somehow playing around with the <a href="https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf">DS18B20</a> sensors.  And not just to get the temperature values ‚Äã‚Äã(which everyone can do), but somehow to visualize it.  There was a simple idea.  We put a webcam.  We light the light on an even frame, on an even one - simmer.  Subtract the picture - only the flash remains.  On it and look for the location of the sensor, which is physically attached to the LED in space.  And then the mathematical processing.  Well, all this in the simulator.  Under the cut described how to get beautiful pictures.  And for those who do not want to understand - I suggest to look at the experiments at the end of the article. <br><a name="habracut"></a><br><br clear="left"><h1>  Circuitry </h1><br>  Circuitry is extremely simple.  The heart is ATmega16.  All DS18B20 sensors hang on the same pin (in my case on PB0 PORTB port).  The pin itself is pulled to the supply voltage through a 4.7 kŒ© resistor.  The scheme is scalable.  The picture is clickable. <br><br> <a href=""><img src="https://habrastorage.org/files/1d6/87f/7dd/1d687f7ddbbc4e29858d20b4ceebcfe7.bmp"></a> <br><br>  All LEDs are connected to the PORTA port via limiting resistors.  A gray polygon means that this LED is physically connected to the DS18B20.  The reset pin is pulled to high through a 10 kŒ© resistor to avoid accidental reset due to interference.  The microcontroller is clocked with 16 MHz quartz.  Put as close as possible to the conclusions.  Loading capacities are used internal.  Configured through fyuzy.  Separately withdrawn connectors ICP (to fill the firmware) and UART for "communication".  Capacities C1 (electrolyte 10 ŒºF) and C2 (ceramics 100 nF).  Put as close as possible to the power pins of the microcontroller.  Used to avoid accidental drops during load transfer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Circuitry assembly</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/20a/9b3/6fa/20a9b36fade242d9b70e10be068168ad.jpg"></div></div><br><div class="spoiler">  <b class="spoiler_title">What is a gray polygon</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d61/bca/b30/d61bcab30e4041e6977ff8d55687d58a.jpg"></div></div><br><h1>  Firmware + work algorithm </h1><br>  The firmware was written in C in the <a href="http://www.atmel.com/Microsite/atmel-studio/">Atmel Studio 7</a> IDE.  Sources are posted on <a href="https://github.com/viktorpanasiuk/WebCamTemp/tree/master/Atmel%2520Studio%25207">GitHub</a> .  The code is the most documented. <br>  The project is divided into several levels of abstraction: <br><ul><li>  <b>Hardware</b> - the lowest level, the maximum binding to the hardware.  Work with the periphery of the microcontroller. </li><li>  <b>Middleware</b> - a link between Hardware and Drivers.  For example, the implementation of the protocol 1-Wire. </li><li>  <b>Drivers</b> - driver level.  For example, work with chip DS18B20. </li><li>  <b>Application</b> - the highest level of abstraction.  For example, receiving and transmitting temperature via UART. </li></ul><br>  Run through the main function.  First, there is a table of ROM addresses.  It is necessary that the address of the sensor physically associated with the zero LED (hanging on the PA0 port of the PORTA) be in the zero position, and so on.  For ROM, there is a function <b>sendROMToUART</b> .  It is necessary only to remember that the sensor must be on the bus alone, otherwise there will be a collision of addresses. <br><div class="spoiler">  <b class="spoiler_title">main</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ROM[][<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ROM_T)] = <span class="hljs-comment"><span class="hljs-comment">/* ROM array */</span></span> { {<span class="hljs-number"><span class="hljs-number">0x26</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-number"><span class="hljs-number">0x4B</span></span>, <span class="hljs-number"><span class="hljs-number">0x15</span></span>, <span class="hljs-number"><span class="hljs-number">0x89</span></span>, <span class="hljs-number"><span class="hljs-number">0x28</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// 0 {0x71, 0x00, 0x00, 0x04, 0x4A, 0xC0, 0x65, 0x28}, // 1 {0xA5, 0x00, 0x00, 0x04, 0x4A, 0xCB, 0xCE, 0x28}, // 2 {0x41, 0x00, 0x00, 0x04, 0x4A, 0xAC, 0x65, 0x28}, // 3 {0x22, 0x00, 0x00, 0x04, 0x4B, 0x06, 0x0D, 0x28}, // 4 {0x86, 0x00, 0x00, 0x04, 0x4A, 0xF6, 0x46, 0x28} // 5 }; uint8_t nDevices = sizeof(ROM) / sizeof(ROM_T); /* Number of DS18B20 devices */ initUART(MYUBRR); /* Initialization of UART with appropriate baudrate */ initTimer0(); /* Initialization of Timer/counter0 */ initLED(nDevices); /* Initialization of LEDs */ { /* DS18B20s initialization */ uint8_t nDevices = sizeof(ROM) / sizeof(ROM_T); /* Number of DS18B20 devices */ ROM_T *pROM = (ROM_T *)&amp;ROM; /* Pointer to ROM array */ initDQ(); /* Initialization of DQ pin */ while (nDevices--) /* For all DS18B20 */ initDS18B20(pROM++, RESOLUTION_11BIT); /* Initialization of DS18B20 with appropriate resolution */ } sei(); /* Global enable interrupts */ while (1) /* Infinite loop */ { sendTemperatureToUART((ROM_T *)&amp;ROM, nDevices); /* Execute function routine */ } }</span></span></code> </pre> </div></div><br>  Next is the initialization of the periphery and the DS-ok themselves with the appropriate resolution.  The sampling period of the temperature depends on it.  For 11 bits this is 375 ms.  In an infinite loop, the program continuously reads the temperature from each sensor and sends it to the UART. <br><br>  Work with LEDs is based on interruptions.  The UART receives the ID of the LED 2 times in a row on an even and odd frame.  At the first LED lights up.  It extinguishes its timer after a certain time (in my case 15 ms).  The second time just ignore.  The timer is configured in CTC mode so that the interruption occurs every 1 ms. <br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledID = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Current ledID value */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledID_prev = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Previous ledID value */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> duration = FLASH_DURATION; <span class="hljs-comment"><span class="hljs-comment">/* Flash duration value */</span></span> ISR(USART_RXC_vect) <span class="hljs-comment"><span class="hljs-comment">/* UART interrupt handler */</span></span> { ledID = UDR; <span class="hljs-comment"><span class="hljs-comment">/* Assign ledID to receive via UART value */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ledID != ledID_prev) <span class="hljs-comment"><span class="hljs-comment">/* If current ledID equal to previous value */</span></span> { turnOnLED(ledID); <span class="hljs-comment"><span class="hljs-comment">/* Turn on the ledID LED */</span></span> timer0Start(); <span class="hljs-comment"><span class="hljs-comment">/* Start Timer0 */</span></span> ledID_prev = ledID; <span class="hljs-comment"><span class="hljs-comment">/* Previous ledID assign to current */</span></span> duration = FLASH_DURATION; <span class="hljs-comment"><span class="hljs-comment">/* Update LED flash duration */</span></span> } } ISR(TIMER0_COMP_vect) <span class="hljs-comment"><span class="hljs-comment">/* Timer0 compare interrupt handler */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--duration == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* Decrement Duration value each 1ms and if it reach to 0 */</span></span> { timer0Stop(); <span class="hljs-comment"><span class="hljs-comment">/* Stop Timer0 */</span></span> turnOffAllLED(); <span class="hljs-comment"><span class="hljs-comment">/* Turn off all LEDs */</span></span> timer0Clear(); <span class="hljs-comment"><span class="hljs-comment">/* Clear Timer0 counter register */</span></span> } }</code> </pre></div></div><br>  The time sensitive parts of the code, which are 1-Wire signals, are wrapped in an <b>ATOMIC_BLOCK</b> construct.  All basic settings are in <b>global.h</b> .  The UART operates at a speed of 250000. Fast and error free for 16 MHz quartz.  The driver DS18B20 has the functionality minimum necessary for this project.  The rest - see the code.  There will be questions - ask, do not hesitate.  Separately, I want to remind you of the fusion settings.  They need to set the clocking ability from external quartz otherwise it will be from the internal oscillator (and it is at most 8 MHz and not very stable).  Well, program the CKOPT bit, otherwise quartz above 8 MHz will not start.  I have <b>High Fuse = 0xD9</b> , <b>Low Fuse = 0xFF</b> . <br><br><h1>  Simulink model + operation algorithm </h1><br>  <b>Matlab R2015b</b> version.  In addition to the built-in library, <b>Simulink</b> mainly used <b>Computer Vision System Toolbox</b> and <b>Image Aquisition Toolbox</b> .  The entire model and related files are uploaded to <a href="https://github.com/viktorpanasiuk/WebCamTemp/tree/master/Simulink">GitHub</a> .  Below is a detailed description with illustrative examples.  All pictures are clickable. <br><br><h2>  WebCamTemp module </h2><br> <a href=""><img align="left" src="https://habrastorage.org/files/f1d/b35/8bb/f1db358bbf3f4bb4b9b31dc3724daf27.bmp"></a>  Blocks of a COM port are marked in yellow.  Separately transmitter, receiver and configurator.  Port settings must match exactly the microcontroller (speed, parity, number of bits, etc.).  The receiver receives the temperature, grouping it into a one-dimensional array of size <b>[n 1] of</b> type <b>int16</b> , where <b>n</b> is the number of DS18B20 (I have 6).  Each element of this array is further divided by <b>16</b> .  This is from <a href="https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf">datasheet</a> page 6. The transmitter sends the current <b>Counter</b> value.  It just lights a certain LED.  Ticking from <b>0</b> to <b>n</b> .  Period 2 sample.  Blue are the blocks responsible for displaying / saving the video stream.  Green - blocks receiving video.  Actually the webcam itself.  There are a lot of settings, different, depending on the manufacturer.  The picture is issued in gray tones.  That's more interesting.  The <b>Diff</b> block makes the difference between the previous and current frames.  The <b>Downsample odd</b> block highlights only the difference lit ‚Äî not the lit LED, but not vice versa.  The <b>Downsample</b> block <b>even</b> skips only those frames in which the LED is extinguished. <br><br><div class="spoiler">  <b class="spoiler_title">Img diff</b> <div class="spoiler_text">  On the left is the original, on the right is the difference picture.  Further coordinates of the LEDs (respectively, of the sensors, too) are searched for.  It is better to look at the frames, but apparently there is no such possibility in YouTube.  You can set a speed of 0.25. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/tbpDALqIc0g%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiUcGRaD78-0X8le6wJsnGDzZ01tw" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Img gray</b> <div class="spoiler_text">  On the left is the original, on the right is the picture on which the map is subsequently superimposed.  After entering a stable mode, you can see that the LEDs do not blink.  Made to not bothered. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ATGUUmG77eo%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjfrM4I7teEk7aX3SDTbLFh3yjbBw" frameborder="0" allowfullscreen=""></iframe><br></div></div><br>  <b>Frame Rate Display</b> displays the current FPS.  All processing goes in the <b>LEDs</b> block.  We will consider it as follows. <br><br><h2>  LEDs module </h2><br> <a href=""><img align="left" src="https://habrastorage.org/files/636/73d/92d/63673d92d053459c9c0c226edded2d13.bmp"></a>  Violet grouped blocks for obtaining <a href="https://en.wikipedia.org/wiki/Gaussian_function">2D Gaussians</a> .  We need two: <b>Interference</b> and <b>Opacity</b> .  Different sigma.  Their center is at the maximum point (where the LED was on).  The coordinates are located in the <b>Maximum</b> block.  Instead of constantly generating such Gaussians (and the exponent is a very time-consuming mat. Operation), it was decided to cut them out.  For this, in the m-file, two <b>Int</b> and <b>Op are</b> generated with dimensions 2 times larger with the center in the middle, of which, further, the necessary branches are simply sprinkled with <b>Crop interference</b> and <b>Crop opacity</b> blocks. <br><br><div class="spoiler">  <b class="spoiler_title">Work example</b> <div class="spoiler_text">  Top left is the input delta image.  Bottom large - static image with a resolution twice as much as required.  The running rectangle is the area that is cut with the desired resolution.  At the top right - what we have at the exit.  It is better to look at a speed of 0.25. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/wGYyoVUJ8nQ%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhixYa4-cnDcOTa7yWIAJ4ktJSH37Q" frameborder="0" allowfullscreen=""></iframe><br></div></div><br>  Green outlined memory blocks.  Their purpose is to store the coordinates and gaussians for each LED.  Take a closer look below.  The <b>To color</b> block is designed for building temperature distribution and a color map.  It will also be discussed below.  Compositing signal composition block mixes two images <b>Image1</b> and <b>Image2</b> according to the following law: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/84a/62d/3d6/84a62d3d604b42c5b0923eb74d8d58d4.gif"></div><br>  The <b>Insert Text</b> block superimposes formatted text (in this case, temperature) on the image.  Accepts <b>n</b> variables and coordinates in <b>[XY]</b> format.  You can choose the font and its size.  The blocks inside the red box implement <a href="https://en.wikipedia.org/wiki/Moving_average">the moving average algorithm</a> .  Transitions become less jerky, which saves nerves and pleases the eye. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  On the left is the original, on the right is the moving average for 8 samples.  When the temperature of all sensors differ by a few tenths of degrees (a couple of sensor resolutions) such jerks take place. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Z8NgbGUZS50%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjsF1j5iXMzq-4ZkED2UkOHa_rEdg" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><h2>  Memory modules </h2><br>  <b>Memory Interference</b> and <b>Memory opacity</b> store 2D Gaussian sets, <b>Memory Pts</b> - coordinates for each LED. <br><br><div class="spoiler">  <b class="spoiler_title">Memory interference and Memory opacity</b> <div class="spoiler_text"> <a href=""><img align="left" src="https://habrastorage.org/files/06d/f15/23e/06df1523e1d245f7b824b151f7dfa0e3.bmp"></a>  These two modules are identical.  At the input <b>Address</b> is the cell number where the input Gaussian is written.  Comes from the counter.  Coincides with the number of the burning LED.  The <b>Delay</b> module of the <b>LEDs</b> module serves for additional synchronization (while the picture arrives, the counter has time to ottikat).  So everything is synchronized.  The <b>Enable</b> signal enables writing.  It is true if the maximum value is above the threshold (see the <b>Maximum</b> and <b>Threshold</b> block of the <b>LEDs</b> module).  If the value is false, the content of the cell does not change.  At the exit, everything is glued together in the third dimension.  It turns out such a sandwich size <b>[HW n]</b> , where <b>HxW</b> is the resolution of the webcam, and <b>n</b> is the number of sensors / LEDs. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Memory Pts</b> <div class="spoiler_text"> <a href=""><img align="left" src="https://habrastorage.org/files/f25/02b/441/f2502b4415bd4badad2de75142a84044.bmp"></a>  Identical to the previous two, with a few exceptions.  At the exit, everything is glued together not in the third but in the first dimension.  And the <b>Permute Matrix</b> block simply swaps the columns, since the coordinate format is <b>[YX]</b> , but <b>[XY] is</b> needed. <br></div></div><br><h2>  To color module </h2><br> <a href=""><img align="left" src="https://habrastorage.org/files/ff4/661/f73/ff4661f7313342bc87aab6257d405ee9.bmp"></a>  Green is <b>Opacity</b> processing.  We summarize the input array in the third dimension.  Normalize it to the maximum.  Multiply by the value of <b>gain</b> (from 0 to 1) <b>(1)</b> .  Total we have an array with Gaussians superimposed on each other and maximum <b>gain</b> .  Used as a <b>factor</b> for image blending.  Red ‚Äî Get a color temperature map.  There is a slightly different math, all the same Gaussians.  Described by the formula <b>(2)</b> .  Roughly speaking, the temperature at an arbitrary point is the weighted average of all sensors.  But the influence of each sensor as a percentage is proportional to the value of the Gaussians in it.  The sum of all is taken as 100%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/87a/e2d/4a3/87ae2d4a31ba4759bb9cf4d093fff846.gif"></div><br> <a href=""><img align="left" src="https://habrastorage.org/files/c51/f48/e29/c51f48e29b614eb28a0134f517ee49e8.bmp"></a>  It remains to consider how the temperature distribution turns into a color map.  The fact that circled in blue turns the specific temperature into a value between 0 and 1. In the red zone, the <b>Prelookup</b> block calculates the index by which the red, green, and blue value is searched.  An array of colors contains 64 values.  Intermediate are calculated by interpolation.  Of the features there are two modes: relative and absolute.  In the relative coldest and hottest place corresponds to the minimum and maximum of the input array.  In the absolute - some constant values.  In the first, it is more convenient to look at the temperature distribution profile.  In the other - her absolute changes. <br><br><h2>  m-file </h2><br>  It is executed at the beginning, before the simulation, introducing variables into the Workspace. <br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="matlab hljs">H = <span class="hljs-number"><span class="hljs-number">480</span></span>; <span class="hljs-comment"><span class="hljs-comment">% Height of image W = 640; % Width of image minT = 20; % Min temperature maxT = 25; % Max temperature sigmaInt = 40; % Sigma interference sigmaOp = 80; % Sigma opacity gain = 1.0; % Gain value T = 0.3; % Threshold value nAvr = 8; % number of means % ------------------------------------------------------ [M,N] = meshgrid(-W:W, -H:H); % Meshgrid function R = sqrt(M.^2 + N.^2); % Distance from the center Int = normpdf(R, 0, sigmaInt); % 2D gaussian for interference Op = normpdf(R, 0, sigmaOp); % 2D gaussian for opacity Int = Int/max(max(Int)); % Normalization of interference gaussian Op = Op/max(max(Op)); % Normalization of opacity gaussian clear MNR sigmaInt sigmaOp % Delete unused variables from memory load('MyColormaps','mycmap'); % Load colormap</span></span></code> </pre><br></div></div><br>  It contains the main control variables including: <br><ul><li>  <b>H</b> - video resolution in height. </li><li>  <b>W</b> - video resolution in width. </li><li>  <b>minT</b> is the minimum absolute temperature. </li><li>  <b>maxT</b> is the maximum absolute temperature. </li><li>  <b>sigmaInt</b> - Sigma Gaussian Interference. </li><li>  <b>sigmaOp</b> - sigma gaussians Opacity. </li><li>  <b>gain</b> is the maximum factor value. </li><li>  <b>T</b> - threshold to avoid errors. </li><li>  <b>nAvr</b> is the number of averages for the moving average. </li></ul><br>  <b>H</b> and <b>W</b> must match the current one in the WebCamera block.  <b>minT</b> and <b>maxT</b> affect the color map in absolute temperature mode.  <b>T is</b> set from 0 to 1. Sometimes the COM port and the webcam are out of sync.  The phase of the differential image can change by 180 ¬∞.  And where there should be a maximum - there is a minimum.  And the coordinate system can choose arbitrary - not corresponding to reality.  For this, there is a threshold system.  <b>nAvr</b> number of averages on a moving average.  The larger it is, the smoother the transitions, but relevance is lost (a time shift appears).  To understand the influence of the remaining variables, no clear examples can not figure out. <br><br><div class="spoiler">  <b class="spoiler_title">SigmaInt effect</b> <div class="spoiler_text">  With <img src="https://habrastorage.org/files/dd4/52e/fa0/dd452efa07f74879864a7da50c880f39.gif">  the picture degenerates into some sort of <a href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi partition</a> .  With <img src="https://habrastorage.org/files/5de/994/dd0/5de994dd0e834600b8fff948ae13eb07.gif">  the whole map will be of the same color as the average, from all sensors, temperature.  With an increase - the boundaries are blurred. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/cZV_ayNrWgE%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiWaOE2NUyg_5jL0mF-edIqy1a-Tw" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SigmaOp effect</b> <div class="spoiler_text">  Sets the decay rate of transparency from a distance. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/S8R4A9AKFZU%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhis2l6QQOSBJjYalD79O0pW_SNAWQ" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Effect of gain</b> <div class="spoiler_text">  Essentially sets the transparency of the map.  The value itself corresponds to the ‚Äútransparency‚Äù of the most ‚Äúnon-transparent‚Äù pixel of the map. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/mvKfUSIw3rI%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhTA2uHHYJj0z7KZ2B4Cic_SYm-Ng" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><h1>  Experiments </h1><br>  Below are some experiments. <br><br><h2>  Open window </h2><br>  Sensors are scattered on the bed by the window.  The window opens and closes after a while.  A vivid example of the difference in relative (left) and absolute (right) modes.  With the help of the first, it is convenient to consider the distribution, and the second - how the cold spreads or the heat recovers. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/AlDT9XyCSeo%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhTVhEw_s84a5lJykhtty7A2KNwjw" frameborder="0" allowfullscreen=""></iframe><br><br><h2>  Window sill </h2><br>  Sensors are located along the window sill.  The window opens - the profile is changing.  The coldest and warmest zones are clearly visible. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/OX8_0pjPLZg%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhifNsuyEV1NCrXyu-hjAPU2rzPolQ" frameborder="0" allowfullscreen=""></iframe><br><br><h2>  Top warmer? </h2><br>  They say the pier is warmer on top.  This experiment is a complete confirmation of this.  On the 10th second the window opens, on the 30th second it closes. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/pUDan07bd-E%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNlSwmg8WZTQaoeSuN9bfHqG2Opg" frameborder="0" allowfullscreen=""></iframe><br><br><h1>  Conclusion </h1><br>  Such a scheme will not replace a full-fledged thermal imager.  But he is not able to see the spread of air masses.  And at the price this design is incommensurably lower.  You can use a different color map.  You can take other functions instead of Gaussians.  You can even change the laws of construction.  Or rewrite to OpenCV + QT for speed and convenience.  But that which I planned was achieved.  Just <b>Just For Fun</b> . </div><p>Source: <a href="https://habr.com/ru/post/390985/">https://habr.com/ru/post/390985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../390975/index.html">Forecasts for 2016: three major trends in the semiconductor industry</a></li>
<li><a href="../390977/index.html">New Sony at MWC 2016: Xperia X, Xperia X Performance and Xperia XA</a></li>
<li><a href="../390979/index.html">Lenovo Ideacentre Stick 300: small yes deleted</a></li>
<li><a href="../390981/index.html">How "Motorika" makes prostheses for children</a></li>
<li><a href="../390983/index.html">Wolves and sheep, zombies and lobster traps: A concise dictionary of stock slang</a></li>
<li><a href="../390987/index.html">Sony bought the video of the Russian artist and blocked it on YouTube (again)</a></li>
<li><a href="../390989/index.html">Fairphone 2 Modular Phone Now Available</a></li>
<li><a href="../390993/index.html">The butterfly's eye has become a model for graphene rektenn with record-breaking light absorption</a></li>
<li><a href="../390995/index.html">MasterCard prepares customer verification options using selfies, voice timbre and heart rate</a></li>
<li><a href="../390997/index.html">9 drones that do not need registration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>