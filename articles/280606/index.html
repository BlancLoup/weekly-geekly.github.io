<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Collection and analysis of the logs of demons in Badoo</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In Badoo, a few dozen "samopisnyh" demons. Most of them are written in C, left alone in C ++ and five or six in Go. They work on about ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Collection and analysis of the logs of demons in Badoo</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In Badoo, a few dozen "samopisnyh" demons.  Most of them are written in C, left alone in C ++ and five or six in Go.  They work on about a hundred servers in four data centers. <br><br>  In Badoo, health checks and detection of problems with demons are on the shoulders of the monitoring department.  Colleagues using Zabbix and scripts check if the service is running, if it responds to requests, and also keep track of versions.  In addition, the department analyzes the statistics of demons and scripts working with them for anomalies, sharp jumps, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f91/d47/efe/f91d47efe21e414e96bbc89d4b087756.png"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, until recently we didn‚Äôt have a very important part - collecting and analyzing logs that each daemon writes locally to files on the server.  Often, it is this information that helps to catch the problem at a very early stage or after the fact to understand the reasons for the refusal. <br><br>  We built such a system and we hasten to share the details.  Surely some of you will have a similar task, and reading this article will save you from the mistakes that we managed to make. <br><a name="habracut"></a><br><h2>  Selection of tools </h2><br>  From the very beginning we shored cloud systems, because  in Badoo, it is customary not to give your data to the outside, if possible.  After analyzing the popular tools, we came to the conclusion that, most likely, one of the three systems will suit us: <br><br><ul><li>  <a href="http://www.splunk.com/">Splunk;</a> </li><li>  <a href="https://www.elastic.co/">ELK;</a> </li><li>  <a href="https://www.graylog.org/">Graylog 2.</a> </li></ul><br><br><h3>  Splunk </h3><br>  First of all, we tried Splunk.  Splunk is a turnkey system, a closed and paid solution, the cost of which directly depends on the traffic coming into the system.  We already use it for data in the billing department.  Colleagues are very satisfied. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f50/011/180/f500111802ca4039aedbe25936208cfb.png"></div><br><br>  We took advantage of their installation for tests and almost immediately faced with the fact that our traffic exceeded the existing and paid limits. <br><br>  Another nuance was that during testing, some employees complained about the complexity and "unintuitiveness" of the user interface.  Colleagues from the billing for this time already got the hand in communicating with Splunk and they had no problems, but still this fact is worth noting, because  A pleasant interface will be of great importance if we want our system to be actively used. <br><br>  On the technical part of Splunk, apparently, we are completely satisfied.  But its cost, closeness and inconvenient interface made us look further. <br><br><h3>  ELK: Elastic Search + Logstash + Kibana </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8bf/c49/fb0/8bfc49fb0e1c4cd5913a2d8c263ec4ac.png"></div><br><br>  ELK was next on the list.  ELK is probably the most popular to date system for collecting and analyzing logs.  And I want to say that this is not surprising, since  It is free, simple, flexible and powerful. <br><br>  ELK consists of three components: <br><ul><li>  Elastic Search.  Data storage and retrieval system based on the Lucene ‚Äúengine‚Äù; </li><li>  Logstash.  "Pipe" with a bunch of features through which data (possibly processed) get into Elastic Search; </li><li>  Kibana.  Web interface for searching and visualizing data from Elastic Search. </li></ul><br><br>  Getting started with ELK is very simple: just download three archives from the official website, unzip and run several binaries.  This simplicity allowed in a few days to test the system and understand how it suits us. <br><br>  And in general, she came up.  Technically, we could implement everything we needed, if necessary, write our own solutions and integrate them into the overall infrastructure. <br><br>  Despite the fact that ELK completely suited us, there was a third applicant. <br><br><h3>  Graylog 2 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5e9/496/73a/5e949673a90c4c4f9a382d0690eee280.png"></div><br><br>  In general, Graylog 2 is very similar to ELK: open source, easy to install, Elastic Search is also used and Logstash can be used.  The main difference is that Graylog 2 is a ready-to-use and ‚Äúsharpened‚Äù system specifically for collecting logs.  With its readiness for the end user, it is very similar to Splunk.  There is a user-friendly graphical interface with the ability to customize line parsing directly in the browser, and access restriction, and notifications. <br><br>  But we came to the conclusion that ELK will allow us to make a much more flexible system, customized for our needs;  will allow to expand, change components.  As a designer.  Did not like one part - replaced by another.  Did not want to pay for the watcher - made their system.  If in ELK all parts can be easily removed and replaced, in Graylog 2 there was a feeling that some parts would have to be torn out by the root, and some simply could not be implemented. <br><br>  Solved.  We will do on ELK. <br><br><h3>  Log shipping </h3><br>  At the earliest stage, we made a mandatory requirement that the logs should get into our collector and remain on the disk.  The system of collecting and analyzing logs is good, but any system gives some delay, can fail and nothing replaces the features that standard unix utilities like grep, AWK, sort, etc. give.  The programmer should have the opportunity to go to the server and see with their own eyes what is happening there. <br><br>  We could deliver logs to Logstash as follows: <br><ul><li>  use the available utilities from the ELK kit (logstash-forwarder, and now beats).  They are a separate daemon that monitors the file on disk and uploads it to Logstash; </li><li>  use your own development under the name LSD, which we deliver PHP logs.  In fact, it is also a separate daemon that monitors files with logs in the file system and floods them somewhere.  On the one hand, LSD took into account and solved all the problems that can occur when uploading a huge amount of logs from a huge number of servers, but the system is too "sharpened" to PHP scripts.  We would have to finish it; </li><li>  in parallel with writing to disk, write logs to the standard for UNIX syslog world. </li></ul><br><br>  Despite the shortcomings of the latter, this approach was very simple, and we decided to try it. <br><br><h2>  Architecture </h2><br><h3>  Servers and rsyslogd </h3><br>  Together with the system administrators, we sketched the architecture that seemed reasonable to us: we put one rsyslogd daemon on each server, one main rsyslogd daemon per platform, one Logstash per platform and one Elastic Search cluster closer to us, to Moscow, ie .  in Prague data center. <br><br>  In the pictures one of the servers looked like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d99/d7b/2f0/d99d7b2f0af44ab4810808600ac151d8.png"></div><br><br>  Since  in Badoo, docker is used here and there, then we planned to push the / dev / log socket inside the container with built-in tools. <br><br>  The final scheme was something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/96e/3e4/ae8/96e3e4ae8e6c4468b020787b55dc0f24.png"></div><br><br>  The scheme invented above looked quite resistant to data loss to begin with: each of the rsyslogd daemons, if it is impossible to transmit messages further, will save them to disk and send them when it ‚Äúgoes on‚Äù to work. <br><br>  The only data loss was possible if the very first rsyslog daemon did not work.  But at that moment we did not pay too much attention to this problem.  Still, logs are not so important information to spend a lot of time on it from the very beginning. <br><br><h3>  Log line format and Logstash </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/25f/a76/03c/25fa7603cc984a2d8fbcc9e6cf1b8320.gif"></div><br><br>  Logstash is a pipe for data to which lines are sent.  Inside they parse and go to Elastic Search in the form of ready-to-index fields and tags. <br><br>  Almost all of our services are built using our own library, libangel, which means that their log format is the same and looks like this: <br><br><pre><code class="bash hljs">Mar 04 04:00:14.609331 [NOTICE] &lt;shard6&gt; &lt;16367&gt; storage_file.c:1212 storage___update_dump_data(): starting dump (threaded, update)</code> </pre> <br><br>  The format consists of a common part, which is unchanged, and a part that the programmer sets himself when calling one of the functions for logging. <br><br>  In the general part, we see the date, time with microseconds, log level, label, PID, file name and line number in source, function name.  The most ordinary things. <br><br>  Syslog adds information from itself to this message: time, PID, server hostname, and so-called ident.  Usually, this is just the name of the program, but anything can be transferred there. <br><br>  We have standardized this ident and transfer the name, secondary name and version of the daemon there.  For example, <i>meetmaker-ru.mlan-1.0.0</i> .  Thus, we can distinguish logs from different demons, from different types of one demon (for example, country, replica) and have information about the running version of the daemon. <br><br>  Analysis of such a message is quite straightforward.  I will not cite the pieces from the configuration file in the article, but it all comes down to gradual biting and parsing of parts of the line using regular regular expressions. <br><br>  If some stage of parsing was unsuccessful, we add a special tag to the message, which further allows you to find such messages and monitor their number. <br><br>  I will mention about the analysis of time.  We have tried to take into account various options, and the default message time will be the time from the libangel message, i.e.  essentially the time when this message was generated.  If for some reason this time was not found, we will take the time from the syslog, i.e.  the time when the message went to the first local syslog daemon.  If for some reason this time is also unavailable, the message time will be the time that this message was received in Logstash. <br><br>  The resulting fields go to Elastic Search for indexing. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/d92/233/d28/d92233d284014ebcac27f71de5c3d52c.png"></a> </div><br><br><h3>  Elasticsearch </h3><br>  Elastic Search supports clustering mode when several nodes are combined into one network and work together.  Due to the fact that it is possible for each of the indexes to configure replication to another node, the cluster remains operable in case of failure of some nodes. <br><br>  The minimum number of nodes in a failover cluster is three, the first odd number that is greater than one.  This is due to the fact that for the internal algorithms to work, it is necessary that when the cluster is divided into parts, it is possible to select the majority.  An even number of nodes is not suitable for this. <br><br>  We allocated three servers for the Elastic Search cluster and set it up so that each index had one replica, as in the diagram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c42/f1b/0d2/c42f1b0d29cc496a997c04898db716d5.png"></div><br><br>  In this architecture, the failure of any of the cluster nodes is not fatal and does not lead to the inaccessibility of the cluster. <br><br>  In addition to the fault tolerance itself, with such a scheme it is convenient to do an update of the Elastic Search itself: we stop one of the nodes, update it, start it, update the other one. <br><br>  The fact that we store logs in Elastic Search allows us to easily divide all data into indices by day.  This partitioning has several advantages: <br><ul><li>  if the servers run out of disk space, it is very easy to delete old data.  This is a quick operation, and moreover, there is a ready-made Curator tool for deleting old data; </li><li>  during the search in the interval of more than one day, the search can be conducted in parallel.  Moreover, it can be conducted in parallel on one server or on several. </li></ul><br><br>  As already mentioned, we set up <a href="https://github.com/elastic/curator">Curator</a> to automatically remove old indexes when there is not enough disk space. <br><br>  In setting up Elastic Search, there are many subtleties associated with both Java and simply the fact that Lucene is used internally.  But all these subtleties are described both in official documentation and in numerous articles, so I will not go deep.  I‚Äôll only briefly mention that on the Elastic Search server you need to remember to allocate memory both for Java Heap and outside Heap (it will be used by Lucene), as well as to prescribe ‚Äúmappings‚Äù specifically for your fields in indexes in order to speed up work and reduce space consumption on disk. <br><br><h3>  Kibana </h3><br>  There‚Äôs nothing to talk about at all :-) They set up and work.  Fortunately, in the latest version, developers have added the ability to change the time zone in the settings.  Previously, the local time zone of the user was taken as default, which is very inconvenient, since  we have on servers everywhere and always UTC, and we are used to communicate on it. <br><br><h2>  Notification system </h2><br>  A very important part of the logging system and one of the main requirements was the availability of a notification system.  A system that, on the basis of rules or filters, would send out letters notifying on the rule triggering with a link to a page where you can see the details. <br><br>  There are two similar finished products in the ELK world: <br><ul><li>  <a href="https://www.elastic.co/products/watcher">Watcher</a> from the company Elastic; </li><li>  <a href="https://github.com/Yelp/elastalert">Elastalert</a> from <a href="http://www.yelp.com/">Yelp</a> . </li></ul><br><br>  Watcher is a closed product from Elastic that requires an active subscription.  Elastalert is an open source product written in Python.  Watcher we shallow almost immediately for the same reason as before - the closeness and complexity of expansion and adaptation for us.  Elastalert also showed itself to be a great product, but there were several drawbacks in it (though not very critical): <br><ul><li>  It is written in Python.  We love Python as a language for writing fast ‚Äúknee-length‚Äù scripts, but we don‚Äôt really want to see it as a final product in production; </li><li>  The ability to build letters that the system sends in response to an event is completely rudimentary.  And the beauty and convenience of writing is very important if we want others to have a desire to use the system. </li></ul><br><br>  Having played with Elastalert and having studied its source code, we decided to write a product in PHP by the platform department.  As a result, Denis Karasik <a href="https://habrahabr.ru/users/battlecat/" class="user_link">Battlecat</a> in 2 weeks wrote a product ‚Äúsharpened‚Äù for us: it is integrated into the backoffice and has only the necessary functionality. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/d85/806/aa6/d85806aa6c8e45f78a2c6339567426c5.png"></a> </div><br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/ffd/053/179/ffd053179a8e45cf92ad75fa9da4e6bb.png"></a> </div><br><br>  For each rule, the system automatically creates a basic dashboard in Kibana, the link to which will be in the letter.  When you click on the link, you will see messages and a schedule for exactly the time period specified in the notification. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/ee2/f69/462/ee2f6946269e47a0befe02fb75e50f35.png"></a> </div><br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/db2/78a/16f/db278a16f51348b4b5effeca62e0a965.png"></a> </div><br><br><h2>  "Rake" </h2><br>  At this stage, the first release of the system was ready, worked and could be used.  But, as we promised, the ‚Äúrake‚Äù was not long in coming. <br><br><h3>  Problem 1 (syslog + docker) </h3><br>  The standard way to communicate between the syslog daemon and the program is unix socket / dev / log.  As mentioned above, we forwarded it inside the container <a href="https://docs.docker.com/engine/userguide/containers/dockervolumes/">using standard</a> docker <a href="https://docs.docker.com/engine/userguide/containers/dockervolumes/">tools</a> .  This bundle worked fine until we needed to reboot the syslog daemon. <br><br>  Apparently, if a specific file is transferred, and not a directory, then when a file is deleted or re-created on the host system, it will no longer be available inside the container.  It turns out that any reboot of the syslog daemon leads to the termination of filling the logs from the docker containers. <br><br>  If you flip the entire directory, there can be a unix-socket inside without problems, and restarting the daemon will not break anything.  But then the configuration of all this wealth becomes complicated, as libc expects the socket to be in / dev / log. <br><br>  The second option we considered was to use UDP or TCP to send logs to the outside.  But here is the same problem as in the previous case: libc can only write in / dev / log.  We would have to write our syslog client, but at this stage we did not want to do this. <br><br>  In the end, we decided to start one syslog daemon in each container and continue writing to / dev / log with standard libc functions openlog () / syslog (). <br><br>  This was not a big problem, because  our system administrators still use the init system in each container, and do not start only one daemon. <br><br><h3>  Problem 2 (blocking syslog) </h3><br>  On the devel cluster, we noticed that one of the daemons periodically freezes.  Turning on the internal watchdog daemon, we got a few backtrace, which showed that the daemon hangs in syslog () -&gt; write (). <br><br><pre> <code class="bash hljs">==== WATCHDOG ==== tag: IPC_SNAPSHOT_SYNC_STATE start: 3991952 sec 50629335 nsec now: 3991953 sec 50661797 nsec Backtrace: /lib64/libc.so.6(__send+0x79)[0x7f3163516069] /lib64/libc.so.6(__vsyslog_chk+0x3ba)[0x7f3163510b8a] /lib64/libc.so.6(syslog+0x8f)[0x7f3163510d8f] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running(zlog1+0x225)[0x519bc5] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running[0x47bf7f] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running(storage_save_sync_done+0x68)[0x47dce8] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running(ipc_game_loop+0x7f9)[0x4ee159] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running(game+0x25b)[0x4efeab] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running(service_late_init+0x193)[0x48f8f3] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running(main+0x40a)[0x4743ea] /lib64/libc.so.6(__libc_start_main+0xf5)[0x7f3163451b05] /<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/meetmaker/bin/meetmaker-3.1.0_2782 | shard1: running[0x4751e1] ==== WATCHDOG ====</code> </pre><br><br>  Quickly downloading the libc sources and looking at the syslog client implementation, we realized that the syslog () function is synchronous and any delays on the rsyslog side will affect demons. <br><br>  Something with this had to be done, and the sooner the better.  But we did not have time ... <br><br>  After a couple of days, we stepped on the most unpleasant rake of modern architectures - cascading failure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/30d/895/0e4/30d8950e47f941c59d7a341be685a0db.gif"></div><br><br>  Rsyslog is configured by default so that if the internal queue for some reason is filled, it begins to "throttle" (eng. Throttle), i.e.  slow down the "record in yourself" new messages. <br><br>  It turned out that due to a programmer's oversight, one of the test servers began to send a huge number of messages to the log.  Logstash did not cope with such a stream, the main rsyslog queue overflowed and he very slowly read messages from other rsyslog.  Because of this, the queues of other rsyslog also overflowed and they very slowly read messages from demons. <br><br>  And the demons, as I said above, write to / dev / log synchronously and without any timeout. <br>  The result is predictable: because of one flooding test daemon, all the demons that write to the syslog with at least some significant frequency began to slow down. <br><br>  Another mistake was that we did not tell the system administrators about a potential problem, and it took more than an hour to figure out the reason and disable rsyslog. <br><br>  Not <a href="http://www.gossamer-threads.com/lists/rsyslog/users/7949">we alone attacked</a> this rake, it turns out.  And <a href="https://coreos.com/blog/eliminating-journald-delays-part-1.html">not</a> even <a href="https://coreos.com/blog/eliminating-journald-delays-part-1.html">with rsyslog</a> .  Synchronous calls in the demon's event loop are a luxury that is not allowed. <br><br>  Before us were several options: <br><ul><li>  walk away from syslog.  Go back to one of the other options that suggest that the demon is writing to disk, and already some other demon is completely independent reading from disk; </li><li>  continue to write to syslog synchronously, but in a separate thread; </li><li>  write your syslog client and send data to the syslog via UDP. </li></ul><br><br>  The best option, perhaps, is the first.  But we did not want to waste time on it and quickly did the third, i.e.  started writing syslog over UDP. <br><br>  As for Logstash, all the problems were solved by two launch parameters: an increase in the number of handlers and the number of simultaneously processed rows ( <i>-w 24 -b 1250</i> ). <br><br><h2>  Future plans </h2><br>  In the near future we plan to make a dashboard for our demons.  Such a dashboard, which will combine the existing and some new features: <br><br><ul><li>  viewing the daemon operability (‚Äútraffic light‚Äù), its basic statistics; </li><li>  graphs of the number of lines ERROR and WARNING in the logs, their viewing; </li><li>  failed alert system rules; </li><li>  SLA monitoring (monitoring latency responses) with the display of problematic services or requests; </li><li>  extraction from the logs of the demon of various stages.  For example, a note about at what stage of loading it is located, the loading time, the duration of some periodic processes, etc. </li></ul><br><br>  The presence of such a dashboard, in my opinion, will appeal to managers, programmers, administrators, and programmers. <br><br><h2>  Conclusion </h2><br>  We have built a simple system that collects the logs of all our demons, allows them to conveniently search for, build graphs and visualizations, notify us of problems by mail. <br><br>  The success of the system is evidenced by the fact that during its existence, we promptly discovered those problems that we would never have discovered or found after a long time, as well as the fact that other teams are beginning to use the infrastructure. <br><br>  If we talk about the load, then at the moment during the day comes from 600 to 2000 lines with logs per second, with periodic bursts of up to 10 thousand lines.  The system digests this load without any problems. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/747/6b0/a2c/7476b0a2c25542fbbb900111e39d324a.png"></a> </div><br><br>  The size of the daily index varies from ten to hundreds of gigabytes. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/919/a36/63a/919a3663ac424204839255702e7d684b.png"></a> </div><br><br>  Some might say that there are flaws in this system and that some ‚Äúrakes‚Äù could be circumvented by doing something different.  It's true.  But we program not for the sake of programming.  Our goal was achieved in a reasonably minimal time and the system is so flexible that the parts that do not distract us in the future can be improved or changed quite easily. <br><br>  <i>Marco Kevac, programmer in the C / C ++ development department</i> </div><p>Source: <a href="https://habr.com/ru/post/280606/">https://habr.com/ru/post/280606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280588/index.html">How to fly free to Paris with a girl and get a development contract</a></li>
<li><a href="../280596/index.html">How I VK Mobile Challenge accepted</a></li>
<li><a href="../280598/index.html">Trends in the development of cloud data centers</a></li>
<li><a href="../280602/index.html">As we broke up mobile Lenta.ru to the speed of light</a></li>
<li><a href="../280604/index.html">Legend of international avos</a></li>
<li><a href="../280608/index.html">Tuples in programming languages. Part 2</a></li>
<li><a href="../280610/index.html">The tale of Tsar Saltan about the potential of the Laplacian</a></li>
<li><a href="../280614/index.html">Cisco Routermate</a></li>
<li><a href="../280616/index.html">How the memory is arranged NetApp FAS: NVRAM, Kesh and Tetris</a></li>
<li><a href="../280618/index.html">Exploratory testing: when to use it and how to do it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>