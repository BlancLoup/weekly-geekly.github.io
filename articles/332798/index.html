<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of webhukov on the example of the interaction of third-party services with online cash registers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I asked our marketing team to draw an illustration and explained to a long time what webbooks are 



 Not so long ago, I was faced with the task of r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of webhukov on the example of the interaction of third-party services with online cash registers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/59/e4/91/59e4913b684b1602700691.jpeg"><br>  <sup>I asked our marketing team to draw an illustration and explained to a long time what webbooks are</sup> <br><br><p>  Not so long ago, I was faced with the task of realizing the work of webhukas in the Personal Account of the owner of the Drimkas cash register.  As it turned out, the network has almost no description and tutorials on how to do this.  I will tell how we implemented it without heavy crowns on a DB. </p><br>  The article will be useful for middle node.js developers. <br><a name="habracut"></a><br><h2>  <b>Where do we use webbooks?</b> </h2><br><p>  To understand the specifics, will have to start from afar. </p><br><p>  Drimkas produces online ticketing and <a href="https://kabinet.dreamkas.ru/">cloud service Drimkas Cabinet</a> .  All cash registers in real time send data on sales over the Internet to the tax - this is a requirement of the new law.  By connecting to the Cabinet, the cashier‚Äôs owner gets remote access to these sales statistics and other tools. </p><br><p>  The Drimkas office allows the cashier‚Äôs owner to monitor sales from the web interface, work with reports, create, edit and automatically load the product base on all cash desks, connect external accounting systems. </p><br><p>  We needed webhookies when we connected online stores to the Cabinet.  For online trading, too, need a cashier, only a paper receipt is not printed.  We decided to create a tool for them so that they could write the sale data in the FN from the usual json with the purchase data and transfer it to the CRF. </p><br><p>  Since the fiscalization operation may be delayed for a long time, exceeding the usual HTTP request, we needed to be given an opportunity to find out the status of this check.  Every time knocking at the Cabinet for the status of the check is not beneficial either for us or for the online store.  And with webhacks we kill two birds with one stone: The office makes a request only once, and the online store will receive a check as soon as it is ready. </p><br><p>  When we started to implement them, we decided to give access to this functionality to integrator services.  With their help, third-party services that are connected to the Cabinet, receive notifications about sales, opening / closing shifts, creating and editing products, making and withdrawing money.  We have not stopped so far, and we immediately translate all the important events into webbooks. </p><br><h3>  Our requirements for webhacks </h3><br><ul><li>  Webbooks should be called upon certain events; </li><li>  It should be possible to "subscribe" to certain of them, if we do not want to receive all the events; </li><li>  WebHooks should repeat requests until a third-party service accepts them; </li><li>  A webhook is deleted if it is not accepted within 24 hours; </li><li>  The last point we need when a third-party service does not respond to the request.  We assume that it has fallen, and sending new requests may drop it again.  Therefore, we do these repeated requests at certain intervals. </li></ul><br><h3>  Current stack backend </h3><br><p>  We write on node.js.  Koa is selected as a web framework.  We have two databases.  Postrges with sequelize, where highly related data is stored, for example, cash registers and users.  To store unrelated and unchangeable data ‚Äî checks, shifts ‚Äî we use MongoDB.  Queues on rabbitMQ are still commonly used to smooth out spasmodic loads.  Plus redis for cache. </p><br><h2>  <b>Webchuk implementation</b> </h2><br><h3>  We define events to call webbukov </h3><br><p>  To begin with, we will define the places where we want to call webbuki.  At the model level, we can use hooks in mongoose and in most cases sequelize. </p><br><p>  Historically, in our sequelize model, you cannot create a product with data immediately.  We create an empty product and change it immediately, so we had to add webbuk call handlers in all controllers. </p><br><p>  When there is no such problem, everything is quite simple.  Example from mongoose model: </p><br><pre><code class="javascript hljs">schema.static(<span class="hljs-string"><span class="hljs-string">'setStatus'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_id, status, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const res = await this.update({ _id }, { ‚Ä¶ }); await Webhook.send({ ... }); return res; });</span></span></code> </pre> <br><h3>  Event subscriptions </h3><br><p>  To define the concept of subscribing to certain events, we use bit masks. </p><br><p>  In the backend we store all the information about the types of events in one number, and send the front-ready json object to the front: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"types"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"products"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"receipts"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"shifts"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"encashments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devices"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operations"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }</code> </pre><br><p>  To pack a number in json and extract it back, we create virtual attributes in sequelize.  We install getters and setters in them.  Virtual fields are calculated on the fly, change to fields in the table, but the databases are not stored. </p><br><div class="spoiler">  <b class="spoiler_title">We pack the number in json and retrieve it back</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      import _ from 'lodash'; export const scopeBits = { products: 0, receipts: 1, shifts: 2, encashments: 3, devices: 4, operations: 5, }; /** *   ,    , *       *     UPPER CASE    . */ /* eslint-disable key-spacing */ const typeToTypes = { PRODUCT: { products: true }, RECEIPT: { receipts: true }, SHIFT: { shifts: true }, ENCASHMENT: { encashments: true }, DEVICE: { devices: true }, OPERATION: { operations: true }, }; /* eslint-enable key-spacing */ export function formMask(scope) { if (_.isEmpty(scope)) { return 0; } return _.reduce(Object.keys(scope), (mask, key) =&gt; { if (scope[key]) { mask |= 1 &lt;&lt; scopeBits[key]; } return mask; }, 0); } export function formEvents(mask) { return _.reduce(scopeBits, (memo, bit, scope) =&gt; { if (mask &amp; (1 &lt;&lt; bit)) { memo[scope] = true; } else { memo[scope] = false; } return memo; }, {}); } //   : subscribes: { type: DataTypes.INTEGER, allowNull: false, }, types: { type: DataTypes.VIRTUAL(DataTypes.INTEGER, ['subscribes']), get() { return this.constructor.formEvents(this.get('subscribes')); }, set(types) { this.setDataValue('subscribes', this.constructor.formMask(types)); }, },</span></span></code> </pre><br></div></div><br><h3>  CRUD for managing webhacks </h3><br><p>  The user manages the webhucks from the web interface or through the API.  Therefore, we need standard CRUD for this model. </p><br><div class="spoiler">  <b class="spoiler_title">Example of "creation", other methods are similar</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> editCols = [<span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'types'</span></span>, <span class="hljs-string"><span class="hljs-string">'isActive'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fields = _.pick(ctx.request.body.fields, editCols); fields.userId = ctx.state.user.id; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webhook = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Webhook.create(fields); ctx.body = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: webhook.id }; ctx.status = <span class="hljs-number"><span class="hljs-number">201</span></span>; }</code> </pre><br></div></div><br><h3>  Preparing for challenges </h3><br><p>  We do not call WebHooks in the static method of the Webhook class - this allows us to save resources of the main site.  This is the work of the workers - to do background tasks without interfering with the REST-API. </p><br><p>  When an event is generated on the site, we notify the workers about this: </p><br><div class="spoiler">  <b class="spoiler_title">Creating a static method Webhook.send</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { getClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../storage/redis'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { stringify, getChannel } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../storage/rabbitmq'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *  ,          * types: { products: true, devices: false, ...} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ userId, types }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mask = formMask(types); <span class="hljs-comment"><span class="hljs-comment">/** *        "" *      ,     , *         */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Webhook.sequelize.query(<span class="hljs-string"><span class="hljs-string">`SELECT id, url, subscribes FROM "Webhook" WHERE subscribes &amp; ? = ? AND "userId" = ? AND "isActive" = TRUE`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Webhook.sequelize.QueryTypes.SELECT, <span class="hljs-attr"><span class="hljs-attr">replacements</span></span>: [mask, mask, userId], }, ); } <span class="hljs-comment"><span class="hljs-comment">/** *     ,      sequelize *     SQL- */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** *     ¬´ ¬ª * type=PRODUCT|DEVICE|ENCASHMENT|RECEIPT|OPERATION|... * action=CREATE|UPDATE|DELETE */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ userId, type, action, itemId }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Redis const client = getClient(); const key = `webhooks:${userId}:${type}`; const isWebhooksExist = await client.existsAsync(key); let webhooks; if (!isWebhooksExist) { //   Postgres const types = typeToTypes[type]; webhooks = await search({ userId, types }); //   Redis,     await client.setAsync(key, JSON.stringify(webhooks), 'EX', 10); } else { webhooks = JSON.parse(await client.getAsync(key)); } _.each(webhooks, (w) =&gt; { const payload = stringify({ url: w.url, itemId, action, type, timestamp: Date.now(), }); /** *    .  ,  URL   : *   (, , , ...),   (, , ..) *  id  */ getChannel().sendToQueue('kab-webhooks-delayed-0', payload, { persistent: true }); }); }</span></span></code> </pre><br></div></div><br><p>  In short, what we are doing is looking for in the database all the webhacks for this user who has a subscription to the current event.  We cache them, even if nothing is found - if the user loads a bunch of goods, there will be extra requests to the database.  When there is a webbook, we throw a task into the queue with a timestamp, a link, an identifier, and an event type. </p><br><p>  There is a nuance: we save resources of the site, and we throw only the object identifier into the queue.  If possible, it is better to throw the object itself.  When an object is created and immediately deleted, two tasks fall into the queue.  The first task at execution will not be able to pull out the object's body from the base.  If you throw the entire body of the object, there will be no such problems. </p><br><h3>  Challenges and repeated calls webhukov </h3><br><p>  We use a message queue on the stack.  We chose 5 time intervals, and for each created a queue.  If the call failed on the first attempt, the webhuk moves to the next queue.  When a worker receives a task for input, he postpones his execution for the required amount of time from 0 milliseconds to a day.  After 24 hours, we call the webbook one last time and delete it. </p><br><img src="https://habrastorage.org/webt/59/e4/91/59e491ab4ab93650945752.png"><br>  <sup>An example of a webhook that can not be taken within a day.</sup> <br><br><p>  Each next task in the queue cannot be called earlier than the current one, since it was added there later.  Therefore, when we took the task out of the queue and saw that it was too early to call the webhost, we did not complete this task in order not to get the next one. </p><br><div class="spoiler">  <b class="spoiler_title">Challenges and repeated calls webhukov</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Bluebird <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'request'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { parse, getChannel, stringify } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../lib/storage/rabbitmq'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requestPostAsync = Bluebird.promisify(request.post); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> times = { <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'5sec'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">'1min'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">'1hour'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">'3hours'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">'1day'</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBodyById = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ({ itemId, type, action }) =&gt; { <span class="hljs-comment"><span class="hljs-comment">/**       */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handle = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (channel, msg, waitENUM, nextQueue) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = parse(msg); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { url, itemId, type, action, timestamp } = task; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBodyById({ itemId, type, action }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> estimatedTime = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(timestamp).getTime()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = times[waitENUM]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (estimatedTime &lt; wait) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Bluebird.delay(wait - estimatedTime); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> requestPostAsync(url, { <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { action, type, data, }, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">json</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">timeout</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>, }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.statusCode &lt; <span class="hljs-number"><span class="hljs-number">200</span></span> || response.statusCode &gt;= <span class="hljs-number"><span class="hljs-number">300</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); } channel.ack(msg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextQueue) { getChannel().sendToQueue(nextQueue, stringify(task)); } channel.nack(msg, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }; <span class="hljs-comment"><span class="hljs-comment">/* eslint-disable no-multi-spaces */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startConsume</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">channel</span></span></span><span class="hljs-function">) </span></span>{ channel.prefetch(<span class="hljs-number"><span class="hljs-number">2</span></span>); channel.consume(<span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-0'</span></span>, msg =&gt; handle(channel, msg, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-1'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">noAck</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); channel.consume(<span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-1'</span></span>, msg =&gt; handle(channel, msg, <span class="hljs-string"><span class="hljs-string">'5sec'</span></span>, <span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-2'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">noAck</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); channel.consume(<span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-2'</span></span>, msg =&gt; handle(channel, msg, <span class="hljs-string"><span class="hljs-string">'1min'</span></span>, <span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-3'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">noAck</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); channel.consume(<span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-3'</span></span>, msg =&gt; handle(channel, msg, <span class="hljs-string"><span class="hljs-string">'1hour'</span></span>, <span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-4'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">noAck</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); channel.consume(<span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-4'</span></span>, msg =&gt; handle(channel, msg, <span class="hljs-string"><span class="hljs-string">'3hour'</span></span>, <span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-5'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">noAck</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); channel.consume(<span class="hljs-string"><span class="hljs-string">'kab-webhooks-delayed-5'</span></span>, msg =&gt; handle(channel, msg, <span class="hljs-string"><span class="hljs-string">'1day'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), { <span class="hljs-attr"><span class="hljs-attr">noAck</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });} <span class="hljs-comment"><span class="hljs-comment">/* eslint-enable no-multi-spaces */</span></span></code> </pre><br></div></div><br><h3>  4 more facts </h3><br><p></p><ul><li>  It happens that tasks are queued in the wrong order - the next task in the queue must be completed before the current one.  For us, this is not critical.  The difference between them will not be more than 20 seconds - this is our request timeout. </li><li>  As time intervals, we selected the following set of values: 0 seconds, 5 seconds, 1 minute, 1 hour, 3 hours, and 24 hours. </li><li>  Requests that are not executed within 24 hours are not logged or stored.  If a third-party service has a downtime of the day, then there is nothing terrible about the undelivered vebhukhs, because the problems are of a different scale there. </li><li>  If the worker does not respond to the received event and simply terminates the connection, RabbitMQ will add this message to the queue again.  Thus, even if the application fell, the webhuk itself will not disappear anywhere. </li></ul><br></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332798/">https://habr.com/ru/post/332798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332780/index.html">The story of cyber espionage behind pharmacies</a></li>
<li><a href="../332786/index.html">How to make complicated simple. The history of the creation of "Project1917"</a></li>
<li><a href="../332790/index.html">Quantum computers: small particles for a big breakthrough</a></li>
<li><a href="../332792/index.html">GitLab CI: branches are no longer needed</a></li>
<li><a href="../332794/index.html">Results of SAP Coder 2017: smart refrigerator, recruiter virtual assistant and much more</a></li>
<li><a href="../332800/index.html">Anonymous workaholic: how to motivate yourself</a></li>
<li><a href="../332802/index.html">Pathfinder: how we make the interface for CRPG</a></li>
<li><a href="../332804/index.html">Simple form validation without JS</a></li>
<li><a href="../332806/index.html">Oculus Rift integration into desktop Direct3D application on the example of Renga</a></li>
<li><a href="../332808/index.html">How I revived VCSA 6.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>