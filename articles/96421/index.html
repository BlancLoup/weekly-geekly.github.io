<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dan Piponi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary: The article provides examples of tasks for which monads may be needed. 

 Instead of entry (translation started): 

 In many ‚Äúintroductions t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dan Piponi</h1><div class="post__text post__text-html js-mediator-article">  Summary: The article provides examples of tasks for which monads may be needed. <br><br>  Instead of entry (translation started): <br><br>  In many ‚Äúintroductions to monads‚Äù, monads are presented as something difficult to explain.  I want to show that it is in fact, they are not something difficult.  In fact, when confronted with various problems in functional programming, you will inexorably come to different solutions, which are often examples of monads.  And I hope that you learn to invent them, if you have not yet learned.  Looking ahead, I will say that these decisions are essentially the same solution.  After reading, you will probably better understand other works on monads, because you will recognize everything that you see as something that you have already invented. <br><a name="habracut"></a><br>  Many problems that monads try to solve are related to the problem of "side effects".  And we will start with them.  (I note that monads allow much more than the ability to work with side effects, in particular, many of the container objects can be represented as monads. Some introductions to monads do not connect these 2 types and concentrate on one or another type.) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Side Effects: Debugging Clean Functions </h2><br><br>  In imperative programming languages ‚Äã‚Äãsuch as C ++, functions behave differently from functions in the mathematical sense.  For example, suppose a C ++ function takes 1 argument, a floating point number, and returns a floating point number. <br>  Outwardly, it looks like a mathematical function acting from R to R, but a C ++ function can do something more than just returning a number that depends on the arguments.  It can read and write values ‚Äã‚Äãfrom global memory, as well as write output to the screen and receive input data from the user.  In a pure functional language, functions can only read what is passed through arguments and there is only one way to influence the outside world - the value returned. <br><br>  So, consider the following problem in a pure programming language: we have functions f and g acting R -&gt; R, and we want to change these functions so that they also output debug information.  In Haskell, f and g can be of the following types. <br><br> <code>f,g :: Float -&gt; Float</code> <br> <br>  How can we change the types f and g in order to allow for side effects?  Well, in fact, we have no choice.  If we want f 'and g' to create strings and floating-point numbers, then the only possible way is to return the string along with the floating-point numbers.  In other words, the functions f 'and g' must have types <br><br> <code>f',g' :: Float -&gt; (Float,String)</code> <br> <br>  We can depict it in the diagram. <br><pre>     x
     |
   + --- +
   |  f '|
   + --- +
    |  \ 
    |  |
   fx "f was called."
</pre><br><br>  We will call them "debug functions." <br><br>  Suppose we want to debug the composition of two such functions.  We can write a simple composition of the initial functions, <i>f</i> and <i>g</i> , in the form <i>f.</i>  <i>g</i> .  But for debugging functions, this cannot be done directly.  As we would like, that lines returned <i>f '</i> and <i>g'</i> united in the general debug line (one of <i>g '</i> and behind it from <i>f'</i> ).  But we cannot directly combine <i>f '</i> and <i>g'</i> because the type of the return value <i>g '</i> does not coincide with the type of the arguments <i>f'</i> .  We can write the solution code as follows: <br><br> <code>let (y,s) = g' x <br> (z,t) = f' y in (z,s++t) <br></code> <br><br>  We will depict it on the diagram. <br><br><pre>      x
      |
    + --- +
    |  g '|
    + --- +
     |  \   
   + --- + |  "g was called."
   |  f '|  |
   + --- + |
    |  \ |
    |  \ |
    |  + ---- +
    |  |  ++ |
    |  + ---- +
    |  |
 f (gx) "g was called. was called."
</pre><br><br>  Each time writing the composition of two functions in this way is difficult, and if we want to write such binding everywhere in our code, it will be a difficult task.  What we have to do is define a higher order function in order to implement this binding.  The difficulty lies in the fact that the output <i>g '</i> cannot be fed to the input <i>f'</i> and we need to "improve" <i>f '</i> .  To do this, we need to introduce a function, call it <i>bind</i> , with the following types <br><br> <code>bind f' :: (Float,String) -&gt; (Float,String)</code> <br> <br>  Which works so that <br><br> <code>bind :: (Float -&gt; (Float,String)) -&gt; ((Float,String) -&gt; (Float,String))</code> <br> <br>  bind should perform 2 tasks: it should (1) apply <i>f '</i> to the desired part <i>g' x</i> and (2) combine the string returned by <i>g '</i> with the string returned by <i>f'</i> . <br><br>  <strong>Exercise 1</strong> <br><br>  write <i>bind</i> function. <br><br>  <strong>Decision</strong> <br><br> <code>bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)</code> <br> <br>  Now we can write a composition of debugging functions, <i>f '</i> and <i>g'</i> .  Denote their composition as <i>f '¬∞ g'</i> .  Even if the output <i>g 'is</i> incompatible with the input <i>f'</i> , we have a fairly simple way to combine these operations.  And this leads to the following question: the existence of a ‚Äúsingle‚Äù function.  Usually 1 (the identity transformation) has the following properties <i>f √ó 1 = f</i> and <i>1 √ó f = f</i> .  We can find a debug function (let's call unit) such that <i>unit ¬∞ f = f ¬∞ unit = f</i> is executed.  Obviously, we can write a function that displays empty debugging information, and otherwise works as an identity transform. <br><br>  <strong>Exercise 2</strong> <br><br>  Enter <i>unit</i> . <br><br>  <strong>Decision</strong> <br> <code>unit x = (x,"")</code> <br> <br>  The <i>unit</i> function allows us to ‚Äúraise‚Äù functions to debug space.  In fact: <br><br> <code>lift fx = (fx,"")</code> <br> <br>  or more simply <i>lift f = unit.</i>  <i>f</i> .  The ‚Äúlifted‚Äù function performs the same as the original one and, which is logical, displays the empty string as a side effect. <br><br>  <strong>Exercise 3</strong> <br><br>  show that <i>lift f ¬∞ lift g = lift (f. g)</i> <br><br>  To summarize: the <i>bind</i> and <i>unit</i> functions allow us to create debugging functions directly and combine normal functions with debugging functions in a natural way. <br><br>  Believe it or not, by doing the exercises you defined your first monad.  Now it is perhaps not very clear which of the structures is a monad or what other monads might look like.  But instead of defining the monad now, I will use other, simpler exercises to lead to other monads in such a way that you yourself will understand their general structure worthy of its name.  I'm also sure that most people who are faced with a problem can themselves guess the <i>bind</i> function to combine debugging functions.  I'm also sure that you could have already come up with a monad, even if you did not realize that it was a monad. <br><br><h2>  Container: multivalued functions </h2><br><br>  Consider the functions <i>sqrt</i> and <i>cbrt</i> , which compute the square and cube root of a real number, respectively.  These functions operate from Float to Float (also <i>sqrt</i> should throw an exception for negative arguments). <br><br>  Now we will create complex versions of these functions.  For every complex number other than zero, there must be 2 square roots.  Similarly, every non-zero complex number has 3 cubic roots.  Thus, we define the <i>sqrt '</i> and <i>cbrt'</i> functions so that they return a list of numbers: <br><br> <code>sqrt',cbrt' :: Complex Float -&gt; [Complex Float]</code> <br> <br>  We will call them multivalued functions. <br><br>  Suppose we want to find a 6th root of a real number, in which case we can simply combine the square root and the cube root.  In other words, we can define a root of 6th degree as <i>x = sqrt (cbrt x)</i> . <br><br>  Consider a function that returns all 6 roots of the 6th power of a complex number using <i>sqrt '</i> and <i>cbrt'</i> .  We cannot simply write the union of these functions.  We must first calculate the cubic roots of a number, and then the square roots of the obtained values ‚Äã‚Äãand combine all the results into one long list.  To do this, we need to write a function (let's call it <i>bind</i> ) with the definition <br><br> <code>bind :: (Complex Double -&gt; [Complex Double]) -&gt; ([Complex Double] -&gt; [Complex Double])</code> <br> <br>  Here is a diagram describing the complete process.  We want to write <i>cbrt '</i> once, but still want to apply <i>sqrt'</i> to the resulting values. <br><pre>         64
         |
      + ------ +
      + sqrt '+
      + ------ +
    +8 / \ -8
  + ------ + + ------ +
  |  cbrt '|  |  cbrt '|
  + ------ + + ------ +
   |  |  |  |  |  |
   2  .  -2  .
</pre><br><br>  <strong>Exercise 4</strong> <br><br>  Write a bind implementation. <br><br>  <strong>Decision</strong> <br><br> <code>bind fx = concat (map fx)</code> <br> <br>  How can we write a unit for multivalued functions?  The unit returns 1 argument, so in the multi-valued version of the function we must return a list consisting of one element.  Let's call the function <i>unit</i> . <br><br>  <strong>Task 5</strong> <br><br>  Write down the unit. <br><br>  <strong>Decision</strong> <br><br> <code>unit x = [x]</code> <br> <br>  And again we define <i>f ¬∞ g = bind f.</i>  <i>g</i> and <i>lift lift f = unit.</i>  <i>f</i> .  Raising does what we intended ‚Äî it explicitly translates a normal function into a multi-valued one. <br><br>  <strong>Exercise 6</strong> <br><br>  Show that <i>f ¬∞ unit = unit ¬∞ f = f and lift f ¬∞ lift g = lift (fg)</i> <br><br>  Again, the above problem adamantly led us to the <i>bind</i> function. <br><br>  After doing the exercises, you created your second monad.  Perhaps you already understand the overall design pattern.  It is strange that these two different looking problems lead to common constructions. <br><br><h2>  More complex side effect example: random numbers </h2><br><br>  Haskell random numbers look like this. <br><br><pre>  random :: StdGen ‚Üí (a, StdGen) </pre><br><br>  The idea is that in order to generate a random number, we need a seed, and after generation we need to update it.  In a non-pure language, we can make the grain a global variable and the user does not need to work with it directly.  But in pure language, the grain must be transmitted and received explicitly (this is the so-called signature describing randomness).  Note that this problem is similar to the debugging cases described above in that they return additional information using a pair.  But in this issue, we also provide additional information. <br><br>  So, a function that is a random function <i>a -&gt; b</i> can be rewritten as a function <i>a ‚Üí StdGet ‚Üí (b, StdGen)</i> , where <i>StdGen</i> is a grain. <br><br>  Now we have to figure out how to make the composition of 2 random functions, f and g.  The "real" return value f must be passed to the first argument g.  Meanwhile, the grain returned by f by the second element of the pair must also be passed to g.  So we can write the type of the bind function. <br><br><pre>  bind :: (a ‚Üí StdGen ‚Üí (b, StdGen)) ‚Üí (StdGen ‚Üí (a, StdGen)) ‚Üí (StdGen ‚Üí (b, StdGen)) </pre><br><br>  <strong>Boom 7</strong> <br><br>  implement bind <br><br>  <strong>Decision</strong> <br><br><pre>  bind fx seed = let (x ', seed') = x seed in fx 'seed' </pre><br><br>  Now we have to come up with a unit.  She must have type <br><br><pre>  unit :: a ‚Üí (StdGen ‚Üí (a, StdGen)) </pre><br><br>  and leave the grain unmodified. <br><br>  <strong>Exercise 8</strong> <br><br>  Implement unit. <br><br>  <strong>Decision</strong> <br><br><pre>  unit xg = (x, g) </pre><br><br>  or simply <br><br><pre>  unit = (,) </pre><br><br>  Again, we can define the operations f ¬∞ g = bind fg and lift lift f = unit.  f.  Raising does what it is supposed to do ‚Äî it translates a normal function into a randomized one and leaves the grain unchanged. <br><br>  <strong>Exercise 9</strong> <br><br>  Show that f ¬∞ unit = unit ¬∞ f = f and lift f ¬∞ lift g = lift (fg) <br><br><h2>  Monads </h2><br><br>  Now it's time to go back to the beginning and notice the general structure. <br><br>  Define <br><br><pre> type Debuggable a = (a, String)
 type Multivalued a = [a]
 type Randomized a = StdGen -&gt; (a, StdGen)
</pre><br><br>  We use the variable m to implement Debuggable, Multivalued, or Randomized.  In each case, we encounter the same problem.  We have a function <i>a -&gt; mb</i> , but we must be able to apply this function to an object type <i>ma</i> instead of type <i>a</i> .  To do this, we define a binding function (called <i>bind</i> ) of type <i>(a -&gt; mb) -&gt; (ma -&gt; mb)</i> and introduce the <i>unit</i> transformation <i>unit :: a -&gt; ma</i> .  In addition, we require that the requirements be met: <i>f ¬∞ unit = unit ¬∞ f = f</i> and <i>lift f ¬∞ lift g = lift (fg)</i> , where ( <i>¬∞</i> ) and <i>lift</i> are defined in terms of <i>unit</i> and <i>bind</i> . <br><br>  Now, I can say what a monad is.  The triple of objects <i>(m, unit, bind)</i> is a monad, but in order to be a monad, they must satisfy the laws that you have proved above.  And I think that in each of the three cases, you can invent the <i>bind</i> function, even if you did not notice that all 3 cases are united by a common structure. <br><br>  So, I have to connect this with the definition of Haskell monads.  And the first thing I reflected and labeled with the word ' <i>bind</i> ' is the definition of the <i>bind</i> function, which is written as <i>&gt;&gt; &gt;&gt;</i> operator.  Then the bunch <i>fx is</i> rewritten as <i>x &gt;&gt; = f</i> .  Secondly, the <i>unit</i> is called <i>return</i> .  And thirdly, to override functions <i>&gt;&gt; =</i> and <i>return</i> , we must use type classes.  In Haskell, the Debuggable is the monad of the Writer, Multivalued is the monad of the List, and Randomized is the monad of the State.  If you check the definitions of the following things <br><br>  <a href="http://www.haskell.org/HOpenGL/newAPI/mtl/Control-Monad-Writer.html">Control.Monad.Writer</a> <a href="http://www.haskell.org/HOpenGL/newAPI/mtl/Control-Monad-List.html">Control.Monad.List</a> <a href="http://www.haskell.org/HOpenGL/newAPI/mtl/Control-Monad-State.html">Control.Monad.State</a> <br><br>  you will see, up to syntax sugar, and these are the definitions you wrote above.  This is how you were introduced to the monads! <br><br><h2>  Monad syntax </h2><br><br>  I don't want to spend a lot of time on this (and you can skip this section), because  There are a lot of better injections. <br><br>  You have already seen how the <i>bind</i> function can provide a convenient way to associate functions and eliminates the need to write fairly ugly code.  But Haskell goes further, and you don‚Äôt even need to directly use the <i>bind</i> function, you can ‚Äúask‚Äù Haskell to insert them automatically. <br><br>  Let's go back to the original debugging example using the official type classes.  Where we used the pair <i>(a, s)</i> we will use the <i>Writer (a, s) of</i> type <i>Writer Char</i> .  To get this pair, use the <i>runWriter</i> function.  Suppose we want to add 1, multiply by 2 and subtract 7, and write down what we are doing at each step.  Total we can write <br><br><pre> return 7 &gt;&gt; = (\ x -&gt; Writer (x + 1, "inc."))
     &gt;&gt; = (\ x -&gt; Writer (2 * x, "double."))
     &gt;&gt; = (\ x -&gt; Writer (x-1, "dec."))
</pre><br><br>  If we apply the <i>runWriter</i> function to this result, we get (15, ‚Äúinc.double.dec.‚Äù).  But the code is still not beautiful.  To improve it, use the do syntax.  The idea is that <br><br><pre> do x &lt;- y
     more code
</pre><br><br>  will be automatically rewritten by the compiler in <br><br><pre> y &gt;&gt; = (\ x -&gt; do
                 more code).
</pre><br><br>  Same <br><br><pre> do
     let x = y
     more code
</pre><br><br>  will be rewritten to <br><br><pre> (\ x -&gt; do
         more code) y
</pre><br><br>  and <br><br><pre> do
     expression
</pre><br><br>  and leaves just an expression. <br><br>  We can rewrite the code as follows: <br><pre> do
     let x = 7
     y &lt;- Writer (x + 1, "inc \ n")
     z &lt;- Writer (2 * y, "double \ n")
     Writer (z-1, "dec \ n")
</pre><br><br>  This record is very indicative.  When we write y &lt;- ..., we can assume that the expression on the right side is just x + 1 with some side effects caused by the operation. <br><br>  Another example.  We write our function of finding the root of 6 degrees in a bulky form <br><br><pre>  return 64 &gt;&gt; = (\ x -&gt; sqrt 'x) &gt;&gt; = (\ y -&gt; cbrt' y) </pre><br><br>  We can rewrite the code in more readable <br><pre> do
     let x = 64
     y &lt;- sqrt 'x
     z &lt;- cbrt 'y
     return z
</pre><br><br>  We can write code that looks like ordinary non-multi-valued code and implicitly invoke <i>bind</i> binding, which Haskell inserts automatically, making it multi-valued. <br><br>  Creating such a syntax is the work of genius.  Maybe you could invent it, but I‚Äôm sure I couldn‚Äôt.  But these additions are actually only syntactic sugar on top of the monads.  I‚Äôm sure you could come up with an underlying monad device. <br><br><h2>  Input Output </h2><br><br>  There remains one more thing that we must pay attention to before you fully understand the monads.  Communication with the outside world.  All that is written above can refer to any pure functional language.  But now let's pay attention to lazy pure functional languages.  In such languages, you have no idea in what order things will be calculated.  So, if you have a function that displays the message ‚ÄúEnter a number‚Äù and another function that requests a number, you cannot guarantee that the message will be written before the number is requested!  Look at an example of a random function, notice how a random grain is driven through all functions so that it can be used with every call to <i>random</i> .  Some sorting happens.  Suppose we have <i>x &gt;&gt; = f &gt;&gt; = g</i> since  <i>g</i> uses the grain returned by <i>f</i> we can be sure that <i>f will</i> generate a number before <i>g</i> .  And this shows that, in principle, monads can be used to streamline calculations. <br><br>  Now we propose the implementation of a random number in the compiler.  This is just a C or assembler code inserted into the Haskell executable.  This code is modified for I / O execution. We can guarantee that <i>f</i> is executed before <i>g</i> .  This is exactly as I / O works in Haskell, we do all I / O in the monad.  In this case, the function having type a-&gt; b and a side effect in the outside world becomes type a -&gt; IO b.  Type IO is a black box, we do not need to know what is in it.  (Maybe it works as an example of random, maybe not) We just need to know that in x &gt;&gt; = f &gt;&gt; = gf it is executed before g. <br><br><h2>  Category Theory </h2><br><br>  And finally.  Monads were invented in the context of category theory.  And I will leave this connection for another day. <br><br><h2>  Addition: complete sample code using random numbers </h2><br><br><pre> import random<font></font>
<font></font>
 bind :: (a -&gt; StdGen -&gt; (b, StdGen)) -&gt; (StdGen -&gt; (a, StdGen)) -&gt; (StdGen -&gt; (b, StdGen))
 bind fx seed = let (x ', seed') = x seed in fx 'seed'
 unit xg = (x, g)
 lift f = unit.  f
</pre><br><br>  And what we are going to do: we want to build 2 (decimal) numbers by following these steps <br><br>  (1) create a random number in the range [0.9] <br>  (2) multiply it by 10 <br>  (3) add another random number from the range [0.9] <br><br>  In general, this is the composition of something like this <i>addDigit.</i>  <i>(*ten).</i>  <i>addDigit</i> .  But we know that we have to pass a random grain through the entire code.  First, consider the definition of <i>addDigit</i> : <br><br><pre>  addDigit ng = let (a, g ') = random g in (n + a `mod` 10, g') </pre><br><br>  it returns a pair consisting of n + random numbers and a new seed.  Notice that it uses grain as an additional argument.  One can argue that the function may look like <i>addDigit n = let a = random in n + a `mod` 10</i> and it is portable in a non-clean language. <br><br>  Now we introduce the operation of multiplication by 10. This is a normal operation, which we can ‚Äúimprove‚Äù using lift.  Get <br><br><pre>  shift = lift (* 10) </pre><br><br>  And this is the decisive moment.  We cannot do composition, and instead we can use binding to convert functions to the format in which they can be combined.  Total <i>addDigit.</i>  <i>(* 10) .addDigit</i> turns into <br><br><pre> test :: Integer -&gt; StdGen -&gt; (Integer, StdGen)
 test = bind addDigit.  bind shift.  addDigit
</pre><br><br>  Now we will create a grain using my favorite number and run the code. <br><br><pre> g = mkStdGen 666
 main = print $ test 0 g
</pre><br><br>  Note that when writing the examples I did not specifically use the Monad type class.  Therefore, nothing was hidden from you and everything was done explicitly. </div><p>Source: <a href="https://habr.com/ru/post/96421/">https://habr.com/ru/post/96421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../96416/index.html">Dingoo A320 - a fruitful year!</a></li>
<li><a href="../96417/index.html">SCSS - a new portion of glaze from Sass</a></li>
<li><a href="../96418/index.html">WineGame 0.1.0</a></li>
<li><a href="../96419/index.html">Stop complicating</a></li>
<li><a href="../96420/index.html">Content Structuring and White SEO</a></li>
<li><a href="../96422/index.html">Transistors operating at a voltage of 0.2 V</a></li>
<li><a href="../96426/index.html">Markup independent elements</a></li>
<li><a href="../96428/index.html">Nokera N100: the first solar-powered bulb</a></li>
<li><a href="../96430/index.html">Microsoft: new thin Xbox 360 and LIVE in Russia</a></li>
<li><a href="../96431/index.html">Trac 0.12 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>