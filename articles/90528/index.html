<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Meta data. Towards ideals of data model management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is this post about 


1. This is a post-review of options for managing data models known to the author based on experience, rumors, and reading i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Meta data. Towards ideals of data model management</h1><div class="post__text post__text-html js-mediator-article"><h5>  What is this post about </h5><br><ol><li>  This is a post-review of options for managing data models known to the author based on experience, rumors, and reading instructions. </li><li>  Also this post is an attempt to classify existing options for managing data models. </li><li>  Finally, the idea and initial touches are given in the implementation of the data model management system, which should not contain the flaws of the previous ones. </li></ol><br><br><h5>  Definitions and limitations </h5><br>  It is assumed that the reader is (or someday becomes) an Enterprise Application developer, who often needs to write quickly and efficiently, but who is not afraid to climb into the wilds of JPA / JTA / RMI in order to ‚Äútweak‚Äù extra thin files with a file. <br><br>  Data is what is stored in the application database.  Information about customers, users, orders, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Metadata - a description of the data structure.  Description of what types of objects are stored in the database, what fields they have (attributes, elements), description of dependencies between objects.  In general, types can inherit attributes of the parent type, and one attribute can generally be present in two or more types unrelated by the inheritance relation. <br><br><a name="habracut"></a><br>  Enterprise Application works using (most often) Application Server (WebLogic, JBOSS) and some RDBMS (Oracle, Informix, MySQL).  Although the author does not see anything shameful in self-assembling an AS based on Tomcat / Hibernate / JOTM / DBCP / etc, this is very, very interesting, but beyond the scope of this topic. <br><br>  As RDBMS, it is assumed that one of those standard ones is supported by Hibernate / OpenJPA. <br><br>  The topic uses terms from XML Schema: namespace, type, attribute.  The last two to some extent correspond to the concepts of Java class (class object, bin) and property (property, aka get + set, sometimes also just a field, field). <br><br><h4>  Introduction  The simplest case </h4><br>  Large applications - most often it is not only applications with a large amount of data.  Most often these are applications that work with a large number of heterogeneous data that have a different structure in terms of business logic.  (By the way, the last is important - the data structure can be different at the DBMS level, at the application level and even inside it) <br><br>  The simplest case is the definition of a data model as a set of classes and corresponding to it a set of tables in the database.  Roughly speaking: one class - oda table in the database.  Each property of an object is represented by a property of a bean class and a column in the database.  However, this mechanism has drawbacks that manifest themselves in the development and use of Enterprise applications: <br><ul><li>  Adding or changing a data model will require changes in both the database structure and program code, followed by recompilation, etc. </li><li>  As a result, it is impossible to do this "on the fly" </li><li>  Difficult changes, such as moving an attribute from a child type to its parent type, will also require writing hand scripts (DDL + DML) to update the database structure. </li><li>  Changing the structure requires SQL / Java knowledge from a specialist. </li></ul><br><br>  It is necessary, however, to note the advantages of this approach: <br><ul><li>  Best price for good performance.  Literally ‚Äúout-of-the-box‚Äù we get the most transparent data storage structure, the most obvious for both the JPA layer (hibernate, etc) and the RDBMS (and its administrator). </li><li>  From the point of view of a business logic programmer who does not change the data structure, we also get the most convenient API out-of-the-box </li></ul><br><br>  Notice in the last sentence an important clarification - "business logic".  We are talking about the description of the processes of interaction of data structures, their change, etc. - that is, the code that should know and knows about the data structure.  But if, for example, we are talking about editing bins via the WEB interface (or in any other way), then to write an editor that can edit 80% of objects without knowing their structure (so-called generalized), we will have to deal with Reflection / Beans / etc and other, in principle, not very scary words.  (Scary - at the end of the topic). <br><br>  Modern design tools allow you to automate part of the processes associated with the update, for example, the database structure by code, or vice versa - to generate or update the code according to the description of the data structure.  Not sure, but I think there are tools for creating both the code and the database structure on the basis of some abstract data schema written, for example, in the form of an XML Schema.  (The code can be generated so accurately - see XML Beans, etc.).  However, all these tools work in ‚Äúoffline‚Äù and do not affect the running application (unless you, of course, do the update directly on the ‚Äúlive‚Äù, but nothing good happens). <br><br>  By the way, some of the auxiliary utilities can be forced and the molds for each type of objects to draw. <br><br><h4>  Flexible data structures </h4><br>  The most flexible can be considered a structure in which each object is stored as a record in the database in the form, well, for example, XML.  That is, a large-large table in which two columns are the object ID and its content in the form of XML.  As you correctly guess, the main drawback of this structure is the very low database performance at the moment when we need to calculate, for example, all the clients from the city of Moscow.  To do this, you have to parse the database every value. <br><br>  In order for the structure to remain flexible, but to load the database less, the object is divided into pieces and put into separate tables.  For example, <br>  - Objects: ID, mandatory field 1, mandatory field 2 <br>  - Values: object ID, attribute identifier, value <br><br>  You can go further and, without limiting flexibility, divide the attributes of different types into different tables or columns.  A similar scheme is successfully used in the application (cut) for processing data in several terabytes. <br><br>  More disadvantages: <br>  For flexibility you have to pay.  First, the data manipulation layer will have to be written independently.  Secondly, there is a great desire to save money and leave for the business logic API, which would reflect the structure of the database: <br>  - give object ID such <br>  - give the attribute ID such <br>  - update value <br>  - write down the ID attribute of such an object <br>  - update object version (+1) <br><br>  Of course, from the point of view of the programmer of the generalized data editor, it is very convenient to have methods like getAllAttributes ().  However, from the point of view of business logic, this is inconvenient, especially if you need to remember all the IDs of the necessary attributes (they can also be numeric). <br><br>  It should be noted, however, that the API in general does not have to coincide with the structure of the database.  The main thing is that 80% of actions are performed in the simplest and most obvious way.  That is, if we have clients in the database, getting the name of the client or its address should be one line of code like client.getAddress ().  However, for flexible structures, writing such shells can severely undermine performance, and secondly, structures tend to change ... <br><br>  However, if such a shell is not written by someone who is responsible for writing data access procedures, be prepared that in a couple of years you will have as many "simplified" data access shells as many initiative programmers work with the "standard" API. <br><br><h4>  Structures with disabilities </h4><br>  In this section, I would like to talk about one more approach, which is used in one <a href="https://sourceforge.net/projects/arpsite/">little-known CMS</a> . <br><br>  From a code point of view, access to the attributes of an object is done in the same way as with flexible structures ‚Äî through methods like getAttribute / getAllAttributes / etc.  However, for CMS, the main task of which is to edit objects separately (without relations between objects), as well as simply output the object to XML for further processing - this API is enough. <br><br>  Interestingly, the list of data types is stored in a configuration file.  Also in this file for each type is stored a list of attributes and their type.  Based on the configuration file, the structure of the tables is created or updated at startup.  Later on, on the fly, as the data structure changes, the tables are updated. <br><br>  Pros: <br>  - obvious data model for a DBMS <br>  - flexibility on the fly <br>  Minuses <br>  - from the point of business logic API is too flexible (see previous section) <br>  - you need to write your data access system, which at the moment, unfortunately, unlike system objects (users, groups, etc) ignores transactions, caches and other delights <br><br><h4>  Classification ... attempt </h4><br>  If we consider a meta model, then to describe it we need to answer the following questions: <br><ul><li>  What is the starting point for describing a model?  (Of course, it should be one point) Where is information about objects and their attributes stored? </li><li>  How is the data storage in the database organized? <ul><li>  Are the requirements of the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">first normal form</a> satisfied? </li><li>  Two different simple (non-multiple) attributes are stored: <ul><li>  in the form of two different columns </li><li>  in two different lines </li></ul></li></ul></li><li>  How is data access organized at the Application Server level? <ul><li>  standard JPA methods are used (EntityManager, etc) </li><li>  using their data access classes </li></ul></li><li>  How is data access organized at the level of business logic? <ul><li>  standard methods like getName (), getAddress (), etc are used </li><li>  used non-standard API like getAttribtute (ID ...) </li></ul></li><li>  Is there access to meta-data from the program? <ul><li>  there is, and you can even change </li><li>  there is </li><li>  only through Reflections / Hibernate Mapping / etc </li></ul></li></ul><br><h4>  I want ... perfect for the author </h4><br>  From the previous paragraph, the requirements for an ideal (from the point of view of the author) system for describing and operating data models are easily derived: <br>  - the description of the data structure should be in the database, which will allow you to quickly change the description of the model, perhaps through the application itself <br>  - the data itself should be stored in a normalized (up to 3-4 forms) database, where each type has its own data table.  The management system itself must take care of maintaining the database schema in accordance with the meta-data. <br>  - data access should be through standard JPA / EntityManager interfaces. <br>  - from the business logic point of view, the main fields of the main object types should be accessible through a simple API without additional resolving / casting / narrowing (that is, immediately after loading from the EntityManager) <br>  - but the system must also provide access to metadata.  Including for a specific object - getting a list of all fields. <br><br>  Currently, the author is engaged in writing such a system using: <br>  - Hibernate - as a data access driver <br>  - CGLIB / ASM - for dynamically constructing classes based on their description, including annotations for Hibernate <br>  - XML ‚Äã‚ÄãSchema - for describing data types and their attributes <br><br>  But more about that next time. </div><p>Source: <a href="https://habr.com/ru/post/90528/">https://habr.com/ru/post/90528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../90509/index.html">Approach to education in English</a></li>
<li><a href="../90510/index.html">Solar powered aircraft</a></li>
<li><a href="../90511/index.html">No, just friday. Banner Generator on appengine</a></li>
<li><a href="../90520/index.html">Windows 95 on iPad</a></li>
<li><a href="../90527/index.html">Section on RIF + CIB: ‚ÄúEffective marketing on the Internet: how to evaluate results and increase conversion?‚Äù</a></li>
<li><a href="../90529/index.html">How to teach computer science in Europe (and in the Czech Republic in particular)</a></li>
<li><a href="../90531/index.html">Redis is an advanced key-value repository. Experience of use in loaded projects</a></li>
<li><a href="../90532/index.html">Brother DCP-330C: learning to save paint</a></li>
<li><a href="../90533/index.html">How not to lose mail when they die DC or about the reliability of DNS</a></li>
<li><a href="../90534/index.html">Alan platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>