<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Core Data for iOS. Chapter number 3. Theoretical part</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, good day! 
 Today I want to start writing a series of lectures with practical tasks on the book ‚ÄúPro Core Data for iOS‚Äù by Michael Privat an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Core Data for iOS. Chapter number 3. Theoretical part</h1><div class="post__text post__text-html js-mediator-article">  Good day, good day! <br>  Today I want to start writing a series of lectures with practical tasks on the book ‚ÄúPro Core Data for iOS‚Äù by Michael Privat and Robert Warner, which you can buy from <a href="http://www.apress.com/9781430236566">this</a> link.  Each chapter will contain a theoretical and practical part. <br><br><img src="https://habrastorage.org/storage3/f39/8f2/7fe/f398f27fe69976e2305f4055fc97c9b2.png"><br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/191334/">Chapter number 1.</a>  <a href="http://habrahabr.ru/post/191334/">Getting Started</a> ( <a href="http://habrahabr.ru/post/191472/">Practical Part</a> ) </li><li>  <a href="http://habrahabr.ru/post/191580/">Chapter number 2.</a>  <a href="http://habrahabr.ru/post/191580/">Digest Core Data</a> ( <a href="http://habrahabr.ru/post/192090/">practical part</a> ) </li><li>  <a href="http://habrahabr.ru/post/192960/">Chapter number 3.</a>  <a href="http://habrahabr.ru/post/192960/">Data storage: SQLite and other options</a> </li><li>  Chapter 4  Creating a data model </li><li>  Chapter number 5.  We work with data objects </li><li>  Chapter number 6.  Processing Result Sets </li><li>  Chapter number 7.  Performance tuning and memory usage </li><li>  Chapter number 8.  Version Control and Migration </li><li>  Chapter number 9.  Managing tables using NSFetchedResultsController </li><li>  Chapter number 10.  Using Core Data in Advanced Applications </li></ul><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Introduction </h5><br>  In this chapter, we will create an application with two tables and a one-to-many relationship between them.  Imagine that you volunteered to follow the teams from the junior football league and their composition.  In our data model there will be two tables: Team (stores information about the team name and the color of their form) and Player (stores information about the team player - mailbox, name and surname).  It is clear that one team has many players, and the player belongs to the same team. <br>  We will create this application first using SQLite as a storage, and then we will try to use other options (storage in memory and arbitrary storage (atomic store)). <br><br><h5>  Interface </h5><br>  Let's call our application League Manager and it will consist of 4 screens: <br><ul><li>  Command list </li><li>  Add / Edit Team </li><li>  List of players </li><li>  Add / Edit Player </li></ul><br><br>  A screen with a list of teams displays locally saved football teams with the colors of their form.  There is a <code>+</code> button on the screen to add a new command and an <code>Edit</code> button to delete.  Here is the screen: <br><img src="https://habrastorage.org/getpro/habr/post_images/3c3/fbc/0a9/3c3fbc0a92605d51deb9437481fa3575.png" alt="image"><br><br>  The add / edit football team screen consists of two fields for entering the team name and the color of their form.  This screen is displayed after pressing the <code>+</code> button on the "Command List" screen to add a new command, or when you click on one of the commands from the list to edit it. <br><img src="https://habrastorage.org/getpro/habr/post_images/7b5/621/d57/7b5621d57ac6fededba19acdd563ed6b.png" alt="image"><br><br>  A screen with a list of players displays all the players of a particular team.  The transition to this screen is carried out after clicking on the blue arrow on the "List of commands" screen opposite each command: <br><img src="https://habrastorage.org/getpro/habr/post_images/55f/3e2/d2c/55f3e2d2c3f64b9cfa5240375a33e878.png" alt="image"><br><br>  As with the teams, when you click on <code>+</code> , a screen for adding a new player to the team appears, and when you click on <code>Edit</code> you can edit the player information. <br><img src="https://habrastorage.org/getpro/habr/post_images/f35/dc6/5d9/f35dc65d97f226e6cf49d2eaf1d8147c.png" alt="image"><br><br>  Now that we know <b>what</b> we have to do, we can proceed. <br><br><h5>  Using SQLite as Storage </h5><br>  Launch the XCode and create a new project. <br><img src="https://habrastorage.org/getpro/habr/post_images/651/d3b/ea6/651d3bea6d28aaef83ebc312e2d2f4ee.png" alt="image"><br><br>  We call it <b>LeagueManager</b> and write <b>book.coredata</b> as the company identifier. <br><img src="https://habrastorage.org/getpro/habr/post_images/13b/b4d/f70/13bb4df7032464b4dedb59fbec178c01.png" alt="image"><br><br>  After creating the project: <br><img src="https://habrastorage.org/getpro/habr/post_images/3fd/29d/b19/3fd29db199167e9c1be4cb9b25ad6946.png" alt="image"><br><br>  At this stage of creating an application, the most important component and part is the creation of a data model.  Open <code>*.xcdatamodeld</code> in the xcode: <br><img src="https://habrastorage.org/getpro/habr/post_images/dba/564/693/dba5646935a9649ecb541271d1f166d9.png" alt="image"><br><br>  Delete (pressing the <code>Delete</code> key) an existing <code>Event</code> entity that is not useful to us. <br><br>  Start by creating a <code>Team</code> entity: <br><img src="https://habrastorage.org/getpro/habr/post_images/c7c/ef6/4e4/c7cef64e4f8370e302c44bfe3231798d.png" alt="image"><br><br>  Create two attributes for the <code>Team</code> entity: <br><ul><li>  name (String) </li><li>  uniformColor (String) </li></ul><br>  We get the following picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/dea/c21/22f/deac2122f12df79d795470babcbaeb26.png" alt="image"><br><br>  In order to set one attribute type to several attributes at once, all you need to do is select them and select the right type for the right: <br><img src="https://habrastorage.org/getpro/habr/post_images/7ae/774/bf5/7ae774bf5feffc1b91b838a7b99b9056.png" alt="image"><br><br>  Next, create an <code>Player</code> entity with three attributes: <br><ul><li>  firstName (String) </li><li>  lastName (String) </li><li>  email (string) </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/d48/80c/0ad/d4880c0ad07d548fc7a783d09f7f8270.png" alt="image"><br><br><h5>  One-to-many relationship </h5><br>  To create a new relationship between <code>Team</code> and <code>Player</code> entities, you must first select the <code>Team</code> entity and in the <code>Relationships</code> section, click <code>+</code> and name the new communication <b>players</b> , for the <code>Destination</code> select the <code>Player</code> entity.  On the right, set the ‚ÄúTo-Many Relationship‚Äù flag with the selected <b>players</b> connection.  For the delete rule, select <code>Cascade</code> (when deleting a team, all players of the team will be automatically deleted). <br><img src="https://habrastorage.org/getpro/habr/post_images/1be/63d/32d/1be63d32d8b3d4081a2d723bdeb03fca.png" alt="image"><br><br>  Now you need to create a connection on the part of the player ( <code>Player</code> entity).  Add a <code>Player</code> entity connection called <code>team</code> , select <code>Team</code> in the <code>Destination</code> field, and select <code>players</code> in the <code>Invers</code> field (after that, don‚Äôt forget to set the <code>Inverse</code> field for the <code>players</code> connection in the <code>Team</code> entity) <br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/9b9/7fa/8f09b97fadcbd4902ec1f2bd996254be.png" alt="image"><br><br><h5>  User Interface Building </h5><br>  After the creation of the data model is completed, it is necessary to start writing code to display this data.  XCode automatically generates all the necessary code to display a list of commands;  the next task will be to slightly adjust it to work with the entities of the <code>Team</code> , and not the <code>Event</code> . <br><br>  We need a method to add a command to the repository, let's add it to the <code>MasterViewController.m</code> file, without having forgotten to describe it in <code>MasterViewController.h</code> . <br>  The code in <code>MasterViewController.h</code> now looks like this: <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;CoreData/CoreData.h&gt;</span></span></span><span class="hljs-meta"> @interface MasterViewController : UITableViewController </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSFetchedResultsControllerDelegate&gt;</span></span></span><span class="hljs-meta"> @property (nonatomic, strong) NSFetchedResultsController *fetchedResultsController; @property (nonatomic, strong) NSManagedObjectContext *managedObjectContext; - (void)insertTeamWithName:(NSString *)name uniformColor:(NSString *)uniformColor; - (void)saveContext; @end</span></span></code> </pre><br>  Open MasterViewController.m and correct the screen name as follows: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedString</span></span>(<span class="hljs-string"><span class="hljs-string">@"League Manager"</span></span>, <span class="hljs-string"><span class="hljs-string">@"League Manager"</span></span>);</code> </pre><br>  Now let's implement the method of adding a new command: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)insertTeamWithName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)name uniformColor:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)uniformColor { <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectContext</span></span> *context = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController managedObjectContext]; <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> *entity = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController fetchRequest] entity]; <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *newManagedObject = [<span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context]; [newManagedObject setValue:name forKey:<span class="hljs-string"><span class="hljs-string">@"name"</span></span>]; [newManagedObject setValue:uniformColor forKey:<span class="hljs-string"><span class="hljs-string">@"uniformColor"</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> saveContext]; }</code> </pre><br>  Now we will find a line like this: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> *entity = [<span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> entityForName:<span class="hljs-string"><span class="hljs-string">@"Event"</span></span> inManagedObjectContext:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.managedObjectContext];</code> </pre><br>  and replace with: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> *entity = [<span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> entityForName:<span class="hljs-string"><span class="hljs-string">@"Team"</span></span> inManagedObjectContext:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.managedObjectContext];</code> </pre><br>  Next, you need to make another small change to the existing code, replace this line: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span> *sortDescriptor = [[<span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span> alloc] iniWithKey:<span class="hljs-string"><span class="hljs-string">@"timestamp"</span></span> ascending:<span class="hljs-literal"><span class="hljs-literal">NO</span></span>];</code> </pre><br>  on: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span> *sortDescriptor = [[<span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span> alloc] iniWithKey:<span class="hljs-string"><span class="hljs-string">@"name"</span></span> ascending:<span class="hljs-literal"><span class="hljs-literal">NO</span></span>];</code> </pre><br>  After creating a new object, we set its properties to the values ‚Äã‚Äãthat were passed: <br><pre> <code class="objectivec hljs"> [newManagedObject setValue:name forKey:<span class="hljs-string"><span class="hljs-string">@"name"</span></span>]; [newManagedObject setValue:uniformColor forKey:<span class="hljs-string"><span class="hljs-string">@"uniformColor"</span></span>];</code> </pre><br>  After the object's properties have been changed, we need to save it, that's why the <code>saveContext</code> method is <code>saveContext</code> . <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)saveContext { <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectContext</span></span> *context = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController managedObjectContext]; <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(![context save:&amp;error]){ <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Unresolved error %@, %@"</span></span>, error, [error userInfo]); abort(); } }</code> </pre><br>  Adjust another method as follows: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)tableView commitEditingStyle:(<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellEditingStyle</span></span>)editingStyle forRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editingStyle == <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellEditingStyleDelete</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> saveContext]; } }</code> </pre><br><br><h5>  Table setup </h5><br>  The table cells are still configured to display <code>Event</code> entities, instead of the required <code>Team</code> entities.  We need to display two components in one cell of the table: the name of the team and the color of the form in which this team plays.  In order to achieve this, you must first change the style of the displayed table cell, as well as the <code>CellIdentifier</code> identifier used in the <code>cellForRowAtIndexPath:</code> method. <br>  Change this line: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>* CellIdentifier = <span class="hljs-string"><span class="hljs-string">@"Cell"</span></span>;</code> </pre><br>  on: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span>* CellIdentifier = <span class="hljs-string"><span class="hljs-string">@"TeamCell"</span></span>;</code> </pre><br>  And we change the type of cells being created with such: <br><pre> <code class="objectivec hljs">cell = [[<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> alloc] initWithStyle:<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellStyleDefault</span></span> reuseIdentifier:CellIdentifier];</code> </pre><br>  on: <br><pre> <code class="objectivec hljs">cell = [[<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> alloc] initWithStyle:<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellStyleValue1</span></span> reuseIdentifier:CellIdentifier];</code> </pre><br>  In the generated code, the <code>configureCell:atIndexPath:</code> method is present, in which the cell is actually configured for display.  But in the current form, the method works with the essence of the <code>Event</code> , and not the <code>Team</code> , so you need to make some adjustments. <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)configureCell:(<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> *)cell atIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *managedObject = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController objectAtIndexPath:indexPath]; cell.textLabel.text = [[managedObject valueForKey:<span class="hljs-string"><span class="hljs-string">@"name"</span></span>] description]; cell.detailTextLabel.text = [[managedObject valueForKey:<span class="hljs-string"><span class="hljs-string">@"uniformColor"</span></span>] description]; cell.accessoryType = <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellAccessoryDetailDisclosureButton</span></span>; }</code> </pre><br><br><h5>  Team building </h5><br>  While our application does little.  It can not create a team, can not create a player.  Now is the right time to launch the application for execution, to make sure that we are on the right path and everything works.  If for some reason you have errors when building the application, then try to go through all the steps again, recheck the data model. <br><br>  When you create an application from the <code>Master-Details View Application</code> template, another controller is created called <code>DetailViewController</code> .  You can use this class, but since we need to display information about the team and players, it is better to get rid of this controller and create new controllers with appropriate names. <br>  Delete the <code>#import DetailViewController.h</code> line from <code>MasterViewController.m</code> .  Find the <code>tableView:didSelectRowAtIndexPath:</code> method and clean its body.  As follows: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)tableView didSelectRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { }</code> </pre><br>  After that we can safely delete all three <code>DetailViewController</code> (.h, .m, .xib).  If we start the application and click on the + button, the application crashes.  This + is still bound to the <code>insertNewObject:</code> method that we deleted.  We need to attach to this button the ability to create a new team, or rather, to show a modal window with fields for entering information (team name and form color) about the new team.  The same window will be used to edit existing commands when you click on a cell with a command on the command list screen. <br>  Create a new class, the parent of our class will be a <code>UIViewController</code> : <br><img src="https://habrastorage.org/getpro/habr/post_images/5b6/281/d59/5b6281d59fb8269e2c69edb58758be5c.png" alt="image"><br>  Let's call this class <code>TeamViewController</code> and don't forget to tick the <code>With XIB for user interface</code> option. <br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/b18/6e9/5adb186e9db30d45e9f3a505085bcfbf.png" alt="image"><br><br>  Open <code>TeamViewController.h</code> .  In League Manager, the <code>MasterViewController</code> class manages <code>NSManagedObjectContext</code> , which means in <code>TeamViewController</code> will need a reference to this object management environment and the corresponding initialization method.  Since this controller will be responsible for editing the information about the command, during initialization it is worth passing the command object (for this we also need to create a property and add it to the initialization method).  The user interface of the command to add / edit a command will contain two text fields - for the name of the command and the color of their form, for them you must create the corresponding properties in <code>TeamViewController</code> .  On this screen there will also be two buttons - the save button (Save) of the new command and the Cancel button (Cancel).  In <code>TeamViewController</code> should be handler methods for pressing these buttons. <br><br> <code>TeamViewController.h</code> <br> <pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> @class MasterViewController; @interface TeamViewController : UIViewController { IBOutlet UITextField *name; IBOutlet UITextField *uniformColor; NSManagedObject *team; MasterVIewController *masterController; } @property (nonatomic, retain) UITextField *name; @property (nonatomic, retain) UITextField *uniformColor; @property (nonatomic, retain) NSManagedObject *team; @property (nonatomic, retain) MasterViewController *masterController; - (IBAction)save:(id)sender; - (IBAction)cancel:(id)sender; - (id)initWithMasterController:(MasterViewController *)aMasterController team:(NSManagedObject *)aTeam; @end</span></span></code> </pre><br>  Open <code>TeamViewController.m</code> , import <code>MasterViewController.h</code> , delete the <code>initWithNibName:</code> , add <a href="https://habrahabr.ru/users/synthesize/" class="user_link">synthesize</a> for <code>name</code> , <code>team</code> and <code>masterController</code> .  Add this initialization method: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithMasterController:(MasterController *)aMasterController team:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)aTeam { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.masterController = aMasterController; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.team = aTeam; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br>  If the application user wants to create a new command, then the aTeam parameter will be nil, and the <code>TeamViewController.m</code> controller will be responsible for creating a new <code>NSManagedObject</code> object.  In the case, if the user selects one of the existing commands for editing, it is up to the controller to fill in the text fields on the screen with relevant data from the command object (the name of the command and the color of the form).  We will add the last functionality to the <code>viewDidLoad</code> method: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(team != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ name.text = [team valueForKey:<span class="hljs-string"><span class="hljs-string">@"name"</span></span>]; uniformColor.text = [team valueForKey:<span class="hljs-string"><span class="hljs-string">@"uniformColor"</span></span>]; } }</code> </pre><br>  Now it remains to implement event handlers when you click on the Save and Cancel buttons: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)save:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(masterController != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(team != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ [team setValue:name.text forKey:<span class="hljs-string"><span class="hljs-string">@"name"</span></span>]; [team setValue:uniformColor.text forKey:<span class="hljs-string"><span class="hljs-string">@"uniformColor"</span></span>]; [masterController saveContext]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [masterController insertNewTeamWithName:name.text uniformColor:uniformColor.text]; } } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> dismissModalViewControllerAnimated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br>  The <code>cancel:</code> method <code>cancel:</code> simply removes the command edit / add window. <br> <code>TeamViewController.m</code> <br> <pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TeamViewController.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MasterViewController.h"</span></span></span><span class="hljs-meta"> @implementation TeamViewController @synthesize name; @synthesize uniformColor; @synthesize team; @synthesize masterController; - (id)initWithMasterController:(MasterController *)aMasterController team:(NSManagedObejct *)aTeam { if((self = [super init])){ self.masterController = aMasterController; self.team = aTeam; } return self; } - (void)didReceiveMemoryWarning{ [super didReceiveMemoryWarning]; } #pragma mark - View lifecycle - (void)viewDidLoad{ [super viewDidLoad]; if(team != nil){ name.text = [team valueForKey:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"name"</span></span></span><span class="hljs-meta">]; uniformColor.text = [team valueForKey:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uniformColor"</span></span></span><span class="hljs-meta">]; } } - (void)viewDidUnload{ [super viewDidUnload]; } - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { return (interfaceOrientation == UIInterfaceOrientationPortrait); } #pragma mark - Button handlers - (IBAction)save:(id)sender{ if(masterController != nil){ if(team != nil){ [team setValue:name.text forKey:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"name"</span></span></span><span class="hljs-meta">]; [team setValue:uniformColor.text forKey:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uniformColor"</span></span></span><span class="hljs-meta">]; [masterController saveContext]; } else { [masterController insertTeamWithName:name.text uniformColor:uniformColor.text]; } } [self dismissModalViewControllerAnimated:YES]; } - (IBAction)cancel:(id)sender{ [self dismissModalViewControllerAnimated:YES]; } @end</span></span></code> </pre><br>  After the code is written to interact with the elements of the user interface, we can proceed to the creation of this very user interface.  Open <code>TeamViewController.xib</code> , it should be empty from the beginning.  We install there two inscriptions, two text entry fields and two buttons, we connect the actions of the buttons with the corresponding handler methods.  The final view is something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/16f/fb9/5f9/16ffb95f9962959e4485e32b8bf22742.png" alt="image"><br><br>  Before launching the application for execution, go back to the <code>MasterViewController</code> and add the code to display a screen with information about the command.  We should display the edit command screen in two cases: 1) the user clicked on + 2) the user clicked on the command from the list.  Let's start by pressing the + button.  Declare a new method in <code>MasterViewController.h</code> : <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)showTeamView;</code> </pre><br>  Go to <code>MasterViewController.m</code> , import <code>TeamViewController.h</code> and implement the above method as follows: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)showTeamView{ TeamViewController *teamViewController = [[TeamViewController alloc] initWithMasterController:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> team:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> presentModalViewController:teamViewController animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br>  It now remains to "associate" clicking on + with the action.  Go to the <code>viewDidLoad</code> method and replace this code here: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span> *addButton = [[<span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span> alloc] initWithBarButtonSystemItem:<span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonSystemItemAdd</span></span> target:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> action:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(insertNewObject)];</code> </pre><br>  on that: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span> *addButton = [[<span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span> alloc] initWithBarButtonSystemItem:<span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonSystemItemAdd</span></span> target:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> action:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(showTeamView)];</code> </pre><br>  At this stage, the application can already create commands, but before launching the application for execution, I suggest adding the code to edit the commands right away: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)tableView didSelectRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>)indexPath{ <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *team = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> fetchedResultsController] objectAtIndexPath:indexPath]; TeamViewController *teamViewController = [[TeamViewController alloc] initWithMasterController:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> team:team]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> presentModalViewController:teamViewController animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br>  Run the application for execution: <br><img src="https://habrastorage.org/getpro/habr/post_images/0c0/b0d/836/0c0b0d836743b2b61c4a5ad25e763014.png" alt="image"><br><br>  Now we can add commands, edit them.  Add a few commands, in the list they will be sorted in lexicographical order. <br><img src="https://habrastorage.org/getpro/habr/post_images/c61/ec9/e8c/c61ec9e8c89dfad262e85ab4b66eee66.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/432/6a4/dc4/4326a4dc4ffc019904ca973db2143d4b.png" alt="image"><br><br>  You may notice that we can create teams with empty names or colors of forms.  If this were a real application, then we needed to take some interim measures from bad user data.  We deliberately left such a ‚Äúmistake‚Äù with data verification, because in Chapter 5 we will study the ways of data validation. <br>  Close the application, start again ... enjoy your work ... but, we finished only the work with the teams, and the players have yet to work.  This is what we will do in the next section. <br><br><h5>  User interface for managing players </h5><br>  To implement the player management user interface, we need two screens and corresponding controllers: one to display the list of players in the team, and the second to add a new player or edit an existing one.  In large part, these controllers are mirror copies of the controllers for working with commands, although they do not contain <code>NSFetchedResultsController</code> and the rest of the code for working with Core Data, instead they delegate interaction with Core Data <code>MasterViewController</code> . <br><br>  First we will create a controller and a screen to display a list of team players.  Create a new <code>PlayerListViewController</code> controller, set its parent class <code>UITableViewController</code> and uncheck the ‚ÄúWith XIB for user interface‚Äù option.  Open the file <code>PlayerListViewController.h</code> .  This class is responsible for displaying the list of players on the team, which means that a reference to the team object is necessary in this class.  Also, given the fact that this class delegates interaction with Core Data to the <code>MasterViewController</code> controller, a reference to the controller itself is also needed. <br>  The screen will have a + button for adding a new player.  Let's declare the corresponding click handler method. <br><br>  <b>PlayerListViewController.h</b> <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> @class MasterViewController; @interface PlayerListViewController : UITableVIewController { NSManagedObject *team; MasterViewController *masterViewController; } @property (nonatomic, retain) NSManagedObject *team; @property (nonatomic, retain) MasterViewController *masterController; - (id)initWithMasterController:(MasterViewController *)aMasterController team:(NSManagedObject *)aTeam; - (void)showPlayerView; - (NSArray *)sortPlayers; @end</span></span></code> </pre><br>  Open the <code>PlayerListViewController.m</code> file and import <code>MasterVIewController.h</code> , synthesize the <code>team</code> and <code>masterController</code> .  Change the generated method <code>initWithStyle:</code> to <code>initWithMasterController:</code> which takes two properties and saves as follows: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithMasterController:(MasterVIewController *)aMasterVIewController team:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)aTeam { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.masterController = aMasterController; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.team = aTeam; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br>  The automatically generated <code>viewDidLoad</code> method is <code>viewDidLoad</code> as follows: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-string"><span class="hljs-string">@"Player"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span> *addButton = [[<span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span> alloc] initWithBarButtonSystemItem:<span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonSystemItemAdd</span></span> target:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> action:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(showPlayerView)]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationItem.rightBarButtonItem = addButton; }</code> </pre><br>  <code>showPlayerView</code> ‚Äôll leave the <code>showPlayerView</code> method empty for now: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)showPlayerView{ }</code> </pre><br>  Adjust the viewWillAppear method: as follows: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewWillAppear:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)animated{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewWillAppear:animated]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView reloadData]; }</code> </pre><br>  The list of players in the table will be sorted alphabetically in a single section (section).  In order to get a list of all players on a team, call the <code>valueForKey:@"players"</code> method of the team object, which will return <code>NSSet*</code> players to us.  Below is the code to customize the table display: <br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)numberOfSectionInTableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)tableView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } - (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableVIew</span></span> *)tableView numberOfRowsInSection:(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)section { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *)[team valueForKey:<span class="hljs-string"><span class="hljs-string">@"players"</span></span>] count]; } - (<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> *)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableVIew</span></span> *)tableView cellForRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *CellIdentifier = <span class="hljs-string"><span class="hljs-string">@"PlayerCell"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cell == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ cell = [[<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> alloc] initWithStyle:<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellStyleValue1</span></span> reuseIdentifier:CellIdentifier]; } <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *player = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> sortPlayers] objectAtIndex:indexPath.row]; cell.textLabel.text = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:<span class="hljs-string"><span class="hljs-string">@"%@ %@"</span></span>, [[player valueForKey:<span class="hljs-string"><span class="hljs-string">@"firstName"</span></span>] description], [[player valueForKey:<span class="hljs-string"><span class="hljs-string">@"lastName"</span></span>] description]]; cell.detailTextLabel.text = [[player valueForKey:<span class="hljs-string"><span class="hljs-string">@"email"</span></span>] description]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre><br>  Above there is a call to the <code>sortPlayers</code> method, which returns a sorted array of players: <br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)sortPlayers{ <span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span> *sortLastNameDescriptor = [[<span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span> alloc] initWithKey:<span class="hljs-string"><span class="hljs-string">@"lastName"</span></span> ascending:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *sortDescriptors = [<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> arrayWithObjects:sortLastNameDescriptor, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *)[team valueForKey:<span class="hljs-string"><span class="hljs-string">@"players"</span></span>] allObjects] sortedArrayUsingDescriptors:sortDescriptors]; }</code> </pre><br>  In order to display the list of players on the team, go back to MasterViewController.m and add a method that will handle clicking on an additional accessory (blue cell element): <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableVIew</span></span> *)tableView accessoryButtonTappedForRowWithIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath{ <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *team = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController objectAtIndexPath:indexPath]; PlayerListViewController *playerListViewController = [[PlayerListViewController alloc] initWithMasterController:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> team:team]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController pushViewController:playerListViewController animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br>  Add import <code>PlayerListViewController.h</code> to <code>MasterViewController.m</code> .  Now build and run the application.  In the list of teams, we see previously created teams, when clicking on the accessory button, a list of players of the selected team opens (while the lists of players are empty, because we have not implemented the addition of a new player). <br><img src="https://habrastorage.org/getpro/habr/post_images/f9d/bc3/155/f9dbc3155b565dd77a3321328fc4d7f6.png" alt="image"><br><br><h5>  Adding, editing and deleting players </h5><br>  The application is almost ready;  the only thing worth realizing is adding / editing / deleting players. <br>  Create a new controller ( <code>UIViewController</code> ) with the corresponding XIB and call it <code>PlayerViewController</code> .  It will be similar to <code>TeamViewController</code> , but will contain three fields: <code>lastName</code> , <code>firstName</code> and <code>email</code> .  The controller also contains a link to <code>MasterViewController</code> in order to be able to use the previously written methods for working with Core Data.  There will also be two more properties: the teams in which the player plays and the player himself.  If the player's object is <code>nil</code> , then <code>PlayerViewController</code> knows that it is necessary to create a new player, otherwise - edit the player's data.  On the screen we will have three buttons: save, cancel and delete.  When requesting the removal of a player, we will request confirmation from the user in the form of a <code>UIActionSheeta</code> mapping, so it is imperative that <code>PlayerViewController</code> implement the <code>UIActionSheetDelegate</code> protocol <code>UIActionSheetDelegate</code> . <br><br>  <b>PlayerViewController.h</b> <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> @class MasterViewController; @interface PlayerViewController : UIViewController </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIActionSheetDelegate&gt;</span></span></span><span class="hljs-meta"> { IBOutlet UITextField *firstName; IBOutlet UITextField *lastName; IBOutlet UITextField *email; NSManagedObject *team; NSManagedObject *player; MasterViewController *masterViewController; } @property (nonatomic, retain) UITextField *firstName; @property (nonatomic, retain) UITextField *lastName; @property (nonatomic, retain) UITextField *email; @property (nonatomic, retain) NSManagedObject *team; @property (nonatomic, retain) NSManagedObject *player; @property (nonatomic, retain) MasterViewController *masterController; - (IBAction)save:(id)sender; - (IBAction)cancel:(id)sender; - (IBAction)confirmDelete:(id)sender; - (id)initWithMasterController:(MasterViewController *)aMasterController team:(NSManagedObject *)aTeam player:(NSManagedObject *)aPlayer; @end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now open </font></font><code>PlayerViewController.m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, import </font></font><code>MasterViewController.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and add </font></font><code>@synthesize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for all properties from the interface. </font><font style="vertical-align: inherit;">Add an initialization method to </font></font><code>PlayerVIewController.m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will receive an instance of the class </font></font><code>MasterViewController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a team and possibly a player object.</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithMasterController:(MasterViewController *)aMasterController team:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)aTeam player:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)aPlayer{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.masterController = aMasterController; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.team = team; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.player = player; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the method, </font></font><code>viewDidLoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add the code to fill in the text fields with the player's data, if it is not equal </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(player != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ firstName.text = [player valueForKey:<span class="hljs-string"><span class="hljs-string">@"firstName"</span></span>]; lastName.text = [player valueForKey:<span class="hljs-string"><span class="hljs-string">@"lastName"</span></span>]; email.text = [player valueForKey:<span class="hljs-string"><span class="hljs-string">@"email"</span></span>]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The next step is to implement button click handler methods: </font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)save:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(masterController != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(player != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ [player setValue:firstName.text forKey:<span class="hljs-string"><span class="hljs-string">@"firstName"</span></span>]; [player setValue:lastName.text forKey:<span class="hljs-string"><span class="hljs-string">@"lastName"</span></span>]; [player setValue:email.text forKey:<span class="hljs-string"><span class="hljs-string">@"email"</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [masterController insertPlayerWithTeam:team firstName:firstName.text lastName:lastName.text email:email.text]; } } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> dismissModelViewControllerAnimated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)cancel:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> dismissModalViewControllerAnimated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no </font><font style="vertical-align: inherit;">method </font></font><code>insertPlayerWithTeam:firstName:lastName:email:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the controller </font></font><code>MasterViewController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yet, but we will write it in just a couple of minutes. </font><font style="vertical-align: inherit;">First, we implement the </font></font><code>confirmDelete:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method that is called when you click on the ‚ÄúDelete‚Äù button. </font><font style="vertical-align: inherit;">This method will not immediately remove the player, but he will ask the user for confirmation to perform this action (this is done in order to avoid accidental clicks and deletions of the players). </font><font style="vertical-align: inherit;">Here is what the method will look like </font></font><code>confirmDelete:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)confirmDelete:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(player != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ <span class="hljs-built_in"><span class="hljs-built_in">UIActionSheet</span></span> *confirm = [[<span class="hljs-built_in"><span class="hljs-built_in">UIActionSheet</span></span> alloc] initWithTitle:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> cancelButtonTitle:<span class="hljs-string"><span class="hljs-string">@"Cancel"</span></span> destructiveButtonTitle:<span class="hljs-string"><span class="hljs-string">@"Delete Player"</span></span> otherButtonTitles:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; confirm.actionSheetStyle = <span class="hljs-built_in"><span class="hljs-built_in">UIActionSheetStyleBlackTranslucent</span></span>; [confirm showInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The delegate who will handle actions committed in </font></font><code>UIActionSheet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be the current class. </font><font style="vertical-align: inherit;">When you click on the button, the </font></font><code>UIActionSheet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method will be called </font></font><code>clickedButtonAtIndex:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which means you need to implement it. </font><font style="vertical-align: inherit;">In the method there will be a check on which button was pressed and, if the button is Delete, then the method (which we will later implement) of the player‚Äôs removal will be called:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)actionSheet:(<span class="hljs-built_in"><span class="hljs-built_in">UIActionSheet</span></span> *)actionSheet clickedButtonAtIndex:(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)buttonIndex{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIndex == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; masterController != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ [masterController deletePlayer:player]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> dismissModalViewControllerAnimated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now return to </font></font><code>MasterViewController.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and declare two methods that we have not yet implemented, but have already used:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)insertPlayerWithTeam:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)team firstName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)firstName lastName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)lastName email:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)email; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)deletePlayer:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)player;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we open </font></font><code>MasterViewController.m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and implement the methods:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)insertPlayerWithTeam:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)team firstName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)firstName lastName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)lastName email:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)email{ <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectContext</span></span> *context = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController managedObjectContext]; <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *player = [<span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span> insertNewObjectForEntityForName:<span class="hljs-string"><span class="hljs-string">@"Player"</span></span> inManagedObjectContext:context]; [player setValue:firstName forKey:<span class="hljs-string"><span class="hljs-string">@"firstName"</span></span>]; [player setValue:lastName forKey:<span class="hljs-string"><span class="hljs-string">@"lastName"</span></span>]; [player setValue:email forKey:<span class="hljs-string"><span class="hljs-string">@"email"</span></span>]; [player setValue:team forKey:<span class="hljs-string"><span class="hljs-string">@"team"</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> saveContext]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)deletePlayer:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)player{ <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectContext</span></span> *context = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fetchedResultsController managedObjectContext]; [context deleteObject:player]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> saveContext]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final step is to create a custom screen for adding / editing a player. </font><font style="vertical-align: inherit;">Select it </font></font><code>PlayerViewController.xib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bring it to the look shown in the image below and connect all the Actions with the corresponding buttons. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b9d/5b1/ea0/b9d5b1ea098e9f043571e4299f819542.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to display this screen it is necessary to return to the implementation of the method </font></font><code>showPlayerView:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we previously used. </font><font style="vertical-align: inherit;">Import to </font></font><code>PlayerListViewController.m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file </font></font><code>PlayerViewController.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)showPlayerVIew{ PlayerVIewController *playerViewController = [[PlayerVIewController alloc] initWithMasterController:masterController team:team player:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> presentModalViewController:playerVIewController animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also need to handle clicking on the cells in the player list table. </font><font style="vertical-align: inherit;">We find in the </font></font><code>PlayerListViewController.m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatically generated method </font></font><code>didSelectRowAtIndexPath:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and bring it to the following form:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableVIew</span></span> *)tableVIew didSelectRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath{ <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *player = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> sortPlayers] objectAtIndex:indexPath.row]; PlayerViewController *playerViewController = [[PlayerVIewController alloc] initWithMasterController:masterController team:team player:player]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> presentModalVIewController:playerViewController animated:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On this, the implementation of the team and player management application is complete. </font></font> Run the application.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add players, remove players, remove teams with players. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Validation of storage data </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second chapter, we have already figured out how to work with </font></font><code>sqlite3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to study the structure of the database that Core Data generates. </font><font style="vertical-align: inherit;">At the end of the section on working with SQLite storages, we will search our database </font></font><code>League_Manager.sqlite3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and start </font></font><code>sqlite3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passing the name of our database as an input parameter.</font></font><br><pre> <code class="bash hljs">sqlite3 ./5.0/Applications/CE79C20B-4CBF-47C3‚Äì9E7C- 9EC24FA22488/Documents/League_Manager.sqlite</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep your League Manager application running so you can switch between </font></font><code>sqlite3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">them and them, and see what happens. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start by looking at what tables were created:</font></font><br><pre> <code class="bash hljs">sqlite&gt; .tables ZPLAYER ZTEAM Z_METADATA Z_PRIMARYKEY</code> </pre><br> <code>ZPLAYER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stores entity data </font></font><code>Player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font></font><code>ZTEAM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- stores entity data </font></font><code>Team</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create three teams: Crew (Blue), Fire (Red), Revolution (Green). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a SQLite database, they will look something like this (depending on how many commands you have created and deleted):</font></font><br><pre> <code class="bash hljs">sqlite&gt; select * from ZTEAM; 1|2|3|Crew|Blue 2|2|1|Fire|Red 3|2|1|Revolution|Green</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As the quick check shows, there are no players in the League Manager application yet: </font></font><br><pre> <code class="bash hljs">sqlite&gt; select * from ZPLAYER;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open the list of players in the Crew team and add three new ones: Jordan Gordon, Pat Sprat, Bailey Staley. </font><font style="vertical-align: inherit;">After adding players you will need to see them in the list. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/3a2/253/b11/3a2253b11887f256f0129001623035be.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/864/961/6db/8649616db7f97ad0ce85ccc84871096c.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's override the team in </font></font><code>sqlite3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">displaying all players in the application:</font></font><br><pre> <code class="bash hljs">sqlite&gt; select * from ZPLAYER; 1|1|1|1|Jordan|Gordan|jgordon@example.com 2|1|1|1|Pat|Sprat|psprat@example.com 3|1|1|1|Bailey|Staley|bstaley@example.com</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now add a new player to the Fire team and call it Terry Gary. </font><font style="vertical-align: inherit;">We will display a list of all players of teams and the name of the team in which he plays:</font></font><br><pre> <code class="bash hljs">sqlite&gt; select ZTEAM.ZNAME, ZPLAYER.ZFIRSTNAME, ZPLAYER.ZLASTNAME from ZTEAM, ZPLAYER <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> ZTEAM.Z_PK = ZPLAYER.ZTEAM; Crew|Jordan|Gordon Crew|Pat|Sprat Crew|Bailey|Staley Fire|Terry|Gary</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Open the application, remove the Crew team's Pat Sprat player and re-request: </font></font><br><pre> <code class="bash hljs">sqlite&gt; select ZTEAM.ZNAME, ZPLAYER.ZFIRSTNAME, ZPLAYER.ZLASTNAME from ZTEAM, ZPLAYER <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> ZTEAM.Z_PK = ZPLAYER.ZTEAM; Crew|Jordan|Gordon Crew|Bailey|Staley Fire|Terry|Gary</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, we‚Äôll remove the Fire team, and it‚Äôs worth noting that not only the team itself, but also its only player Terry Gary has retired: </font></font><br><pre> <code class="bash hljs">sqlite&gt; select ZTEAM.ZNAME, ZPLAYER.ZFIRSTNAME, ZPLAYER.ZLASTNAME from ZTEAM, ZPLAYER <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> ZTEAM.Z_PK = ZPLAYER.ZTEAM; Crew|Jordan|Gordon Crew|Bailey|Staley</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not be afraid to look under the hood Core Data. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In most cases, your application will use a database as a SQLite data warehouse, so understanding how Core Data works with it can help you avoid difficulties and improve application performance.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In-memory persistent store usage </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous section, we built an application using Core Data and SQLite as a data warehouse. In this section we will discuss an alternative type of storage: storage in memory. Let's take a look at how you can change the type of data storage used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is easy to change the type of storage used; it‚Äôs enough only to </font></font><code>NSPersistentStoreCoordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specify a different type </font><font style="vertical-align: inherit;">when creating it </font></font><code>NSSQLiteStoreType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is what the modified method will look like </font></font><code>persistentStoreCoordinator:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><code>League_ManagerAppDelegate.m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span> *)persistentStoreCoordinator { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_persistentStoreCoordinator != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _persistentStoreCoordinator; <span class="hljs-comment"><span class="hljs-comment">// NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"League_Manager.sqlite"]; NSError *error = nil; _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; if(![_persistentStoreCoordinator addPersistentStoreWithType:NSInMemoryStoreType configuration:nil URL:nil options:nil error:&amp;error]){ NSLog(@"Unresolved error %@, %@", error, [error userInfo]); abort(); } return _persistentStoreCoordinator; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data storage type has been changed to in-memory storage. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing we will notice when the application is launched the next time is that all previously added data has disappeared. </font><font style="vertical-align: inherit;">This happened because we changed the type of data storage and did not migrate data from the old to the new. </font><font style="vertical-align: inherit;">In Chapter 8, we will look at how data can be migrated between two repositories. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The storage life cycle in memory begins when the Core Data stack is initialized and ends when the application is stopped.</font></font><br><br>  <b>Note</b> <br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with iOS 4 and the introduction of multitasking, switching to another application does not necessarily lead to the termination of your application. </font><font style="vertical-align: inherit;">Instead of completing, our application continues to work in the background, and therefore the data in the memory continues to remain.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reflecting on the different types of data storage, which are provided by default, it is difficult to think of a situation the first time in which it would be worth using in-memory storage, but there are such situations. For example, local caching of data received from a remote server. Imagine a situation where your application processes data from a remote server. If your application makes a lot of requests, it will be a good practice to speed up responses to these requests by choosing the most ‚Äúresponsive‚Äù type of storage. The remote server can transfer data in compressed form, on the mobile device will be unpacking and loading data into memory to speed up subsequent requests. In that case, you wantso that the data is updated each time (or updated with some frequency) and data loss when the application is shut down is not a problem.</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/b9b/270/2b9b9b27025f457b81bf9ad12e26cba1.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When developing your next application using Core Data, consider using in-memory storage whenever your application does not need to store data between runs. </font><font style="vertical-align: inherit;">In traditional applications in which it is necessary to store user data, this type of storage will not be popular.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Developing your own storage type </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic principle of Core Data is abstraction from the type of real storage. This abstraction allows you to change the default internal storage type (NSSQLiteStoreType, NSInMemoryStoreType, NSBinaryStoreType) without needing to change more than one row. In some cases, the default data warehouse may not suit your needs. In this case, Core Data has a present for you - the ability to create an arbitrary type of data storage yourself. In this section, we will create a new type of storage and use it in our League Manager application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we dive into the implementation, it is worth remembering that Core Data allows you to create </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only </font></font></b> <a href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atomic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">storage types. The atomic type of storage is the type in which the save operation saves all data on each of its entire calls. Unfortunately, this restriction does not allow you to create and use something more efficient than a SQLite database. In this section, we will develop the file type of the repository, the data in it will be stored using the comma separator (CSV), and to separate the values ‚Äã‚Äãwe will use the vertical bar (|). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Custom data stores should be inherited from the </font></font><code>NSAtomicStore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class (subclass </font></font><code>NSPersistentStore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) that provides the capabilities (methods) necessary to work with the data. To better understand how this works, imagine the two inner layers inside the Core Data Framework, as shown in the image below:</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/8ae/a92/ffb/8aea92ffbede8dfead25c4f09ec35748.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The user interacts with the layers </font></font><code>NSManagedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>NSManagedObjectContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The second layer directly stores the data and contains the data stores and data warehouse coordinator. </font><font style="vertical-align: inherit;">In the case of custom storage types, the data storage layer also contains </font></font><code>NSAtomicStoreCacheNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which stores objects containing the data itself. </font><font style="vertical-align: inherit;">Attitude </font></font><code>NSAtomicStoreCacheNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">towards </font></font><code>NSAtomicStore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the same as </font></font><code>NSManagedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font><code>NSManagedObjectContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialization of custom storage </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New custom data storage is responsible for transferring data between storage on the device and NSAtomicStoreCacheNodes, as well as transferring data between NSManagedObjects and NSAtomicStoreCacheNodes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first step in creating a custom data warehouse is to create a class for a new storage type. </font><font style="vertical-align: inherit;">The custom storage that will be developed in this section will be fully in the class </font></font><code>CustomStore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Add a new class to the League Manager that will inherit from the NSAtomicStore. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomStore.h</font></font></i> <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> @interface CustomStore : NSAtomicStore { } @end</span></span></code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomStore.m</font></font></i> <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CustomStore.h"</span></span></span><span class="hljs-meta"> @implementation CustomStore #pragma mark - NSPersistentStore - (NSString *)type { return [[self metadata] objectForKey:NSStoreTypeKey]; } - (NSString *)identifier { return [[self metadata] objectForKey:NSStoreUUIDKey]; } - (id)initWithPersistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator configurationName:(NSString *)configurationName URL:(NSURL *)url options:(NSDictionary *)options { self = [super initWithPersistentStoreCoordinator:coordinator configurationName:configurationName URL:url options:options]; return self; } + (NSDictionary *)metadataForPersistentStoreWithURL:(NSURL *)url error:(NSError **)error { return nil; } #pragma mark - NSAtomicStore - (BOOL)load:(NSError **)error { return YES; } - (id)newReferenceObjectForManagedObject:(NSManagedObject *)managedObject { return nil; } - (NSAtomicStoreCacheNode *)newCacheNodeForManagedObject:(NSManagedObject *)managedObject { return nil; } - (BOOL)save:(NSError **)error { return YES; } - (void)updateCacheNode:(NSAtomicStoreCacheNode *)node fromManagedObject:(NSManagedObject *)managedObject { } @end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All vaults in Core Data have a certain set of metadata that allows you to </font></font><code>NSPersistentStoreCoordinator'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manage different types of vaults. The </font></font><code>NSPersistentStore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metadata is presented in the form of a dictionary </font></font><code>NSDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The values ‚Äã‚Äãof the two keys are of particular interest: </font></font><code>NSStoreTypeKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>NSStoreUUIDKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The value for the key </font></font><code>NSStoreTypeKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must be a unique string identifying the type of storage, and </font></font><code>NSStoreUUIDKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the storage itself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create unique identifiers, add the following class method:</font></font><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)makeUUID { <span class="hljs-built_in"><span class="hljs-built_in">CFUUIDRef</span></span> uuidRef = <span class="hljs-built_in"><span class="hljs-built_in">CFUUIDCreate</span></span>(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CFStringRef</span></span> uuidStringRef = <span class="hljs-built_in"><span class="hljs-built_in">CFUUIDCreateString</span></span>(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, uuidRef); <span class="hljs-built_in"><span class="hljs-built_in">CFRelease</span></span>(uuidRef); <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *uuid = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithString:(__bridge <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)uuidStringRef]; <span class="hljs-built_in"><span class="hljs-built_in">CFRelease</span></span>(uuidStriingRef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uuid; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example in this chapter, two files are necessary for the operation of a custom data store. The first file, which has the extension txt, contains the data itself; The second file that has the plist extension contains metadata. To solve the problem of loading and saving metadata, we will add another method and finish the implementation of the method </font></font><code>metadataForPersistentStoreWithURL:error:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following method saves a file with metadata:</font></font><br><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)writeMetadata:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)metadata toURL:(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *)url { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *path = [[url relativePath] stringByAppendingString:<span class="hljs-string"><span class="hljs-string">@".plist"</span></span>]; [metadata writeToFile:path atomically:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Downloading metadata is a little more difficult, because in the case of the first download (access) to the repository, you need to create a file with metadata along with an empty data file (txt in our case). </font><font style="vertical-align: inherit;">Core Data expects to receive from the metadata repository and type the UUID, which allow to determine the order, how to work with this type of storage, so you must set the values for the keys </font></font><code>NSStoreTypeKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NSStoreUUIDKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Find the method </font></font><code>metadataForPersistentStoreWithURL:error:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and change its body so that it checks for the presence of the metadata file and, if there is no such file, it was created (with the specified keys) along with an empty storage file (text file).</font></font><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)metadataForPersistentStoreWithURL:(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *)url error:(<span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> **)error { <span class="hljs-comment"><span class="hljs-comment">// determine the filename for metadata file NSString *path = [[url relativePath] stringByAppendingString:@".plist"]; if(![[NSFileManager defaultManager] fileExistsAtPath:path]) { // create a dictionary and store the store type key (CustomStore) // and the UUID key NSMutableDictionary *metadata = [NSMutableDictionary dictionary]; [metadata setValue:@"CustomStore" forKey:NSStoreTypeKey]; [metadata setValue:[CustomStore makeUUID] forKey:NSStoreUUIDKey]; // write the metadata to the .plist file [CustomStore writeMetadata:metadata toURl:url]; // write an empty data file [@"" writeToURL:url atomically:YES encoding:[NSString defaultCStringEncoding] error:nil]; NSLog(@"Created new store at %@", path); } return [NSDictionary dictionaryWithContentsOfFile:path]; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With the metadata load / save methods available, we can complete the initialization method of the custom data store as follows: </font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithPersistentStoreCoordinator:(<span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span> *)coordinator configurationName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)configurationName URL:(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *)url options:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)options { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> initWithPersistentStoreCoordinator:coordinator configurationName:configurationName URL:url options:options]; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *metadata = [CustomStore metadataForPersistentStoreWithURL:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> URL] error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setMetadata:metadata]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relationship between NSManagedObject and NSAtomicStoreCacheNode </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for our custom data warehouse to work as it should, we need to implement three additional methods. </font><font style="vertical-align: inherit;">The first method creates a new referring object for the passed one </font></font><code>NSManagedObject'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The referencing objects are unique identifiers for each </font></font><code>NSAtomicStoreCacheNode'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(like the primary key, the relationship is the same as </font></font><code>NSObjectID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><code>NSManagedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Since a custom repository is responsible for translating between </font></font><code>NSManagedObject'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>NSAtomicStoreCacheNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it must be able to create a referring object for those just created </font></font><code>NSManagedObject'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To do this, we use the UUID again:</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)newReferenceObjectForManagedObject:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)managedObject { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *uuid = [CustomStore makeUUID]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uuid; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second method, which is useful to us, creates an instance of the </font></font><code>NSAtomicStoreCacheNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class for the corresponding </font></font><code>NSManagedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object. </font><font style="vertical-align: inherit;">When a new one </font></font><code>NSManagedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is created and the framework needs to save it, the method is called </font></font><code>newReferenceObjectForManagedObject:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>NSAtomicCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keeps track of relationships between </font></font><code>NSObjectID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and referencing objects. </font><font style="vertical-align: inherit;">When Core Data saves NSManagedObjects to local storage, a method is invoked </font></font><code>newCacheNodeForManagedObject:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that, as can be seen from its name, creates a new instance </font></font><code>NSAtomicStoreCacheNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that serves as an analogue of NSManagedObject.</font></font><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSAtomicStoreCacheNode</span></span> *)newCacheNodeForManagedObject:(<span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *)managedObject { <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectID</span></span> *oid = [managedObject objectID]; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> referenceID = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> referenceObjectForObjectID:oid]; <span class="hljs-built_in"><span class="hljs-built_in">NSAtomicStoreCacheNode</span></span>* node = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> nodeForReferenceObject:referenceID andObjectID:oid]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateCacheNode:node fromManagedObject:managedObject]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation </font></font><code>newCacheNodeForManagedObject:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">searches for a referencing object that was created for the corresponding NSManagedObject object and creates a new NSAtomicStoreCacheNode with copying all the fields from the NSManagedObject instance.</font></font></div><p>Source: <a href="https://habr.com/ru/post/192960/">https://habr.com/ru/post/192960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../192944/index.html">Get the list of graphic classes registered in TPicture.RegisterFileFormat</a></li>
<li><a href="../192948/index.html">A free High-Performance Computing School started at the University Innopolis</a></li>
<li><a href="../192950/index.html">Review of fresh materials, July-August 2013</a></li>
<li><a href="../192952/index.html">The French company produces a prototype of a smartphone that can be charged from solar and artificial light.</a></li>
<li><a href="../192954/index.html">Simple but effective Voice Activity Detection real-time algorithm</a></li>
<li><a href="../192964/index.html">Stiga rocket launch</a></li>
<li><a href="../192966/index.html">The digest of news from the world of mobile development for the last week ‚Ññ23 (September 2 - 8, 2013)</a></li>
<li><a href="../192972/index.html">BEM on Rails</a></li>
<li><a href="../192976/index.html">The digest of interesting news and materials from the world of PHP for the last two weeks, No. 25 (08.25.2013 - 09.09.2013)</a></li>
<li><a href="../192978/index.html">Algorithm Self-Organizing Incremental Neural Network (SOINN)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>