<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional Javascript Programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary : 

 Take a few higher-order functions, add partial application of functions, spice up fold with a map, and get Javascript DSL to work with th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional Javascript Programming</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/693/f11/156/693f11156ce1b06d8c2a34e630432622.jpg" width="20%" height="20%"><br><br>  <b>Summary</b> : <br><br>  Take a few higher-order functions, add partial application of functions, spice up fold with a map, and get Javascript DSL to work with the DOM. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Human language</b> : <br>  A simple and intuitive introduction to functional programming in pure and clear Javascript. <br><br>  Unlike <a href="http://habrahabr.ru/post/152889/">"Through thorns to Haskell"</a> everything is chewed (perhaps even too much) and laid out on the shelves. <br><br>  Reading the article will unmask the myth of the inapplicability of AF in real life.  You will be able to look at the solution of the same problem from different points of view.  Just like in the picture. <br><br><a name="habracut"></a><br><br><h1>  Functions </h1><br>  Let's start with a simple definition of a function. <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a+b); };</code> </pre> <br><br>  You can write the same code differently. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> add = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a + b); };</code> </pre><br><br>  One of the great advantages of Javascript is that the functions in it are full-fledged objects.  Real First Class Citizen. <br>  In contrast, for example, from Java, where the function cannot exist separately from the object. <br><br>  The above function works with side effects, that is, changes the state of the external world.  This is reflected in the use of <b>console.log ()</b> . <br><br>  Now consider an example of a pure function. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> add = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; };</code> </pre><br><br>  Pure functions do not produce side effects.  You transfer some data to them, and they give you data back.  They are very easy to analyze.  They are easier to test.  No need to check external dependencies.  Therefore, in most cases, pure functions are preferable to functions with side effects. <br>  But, on the other hand, a program consisting solely of pure functions does not have practical meaning.  It does not read or display anything. <br>  Therefore, it will be logical to write programs in such a way as to separate the pure functions from the functions with side effects and thus simplify your life. <br><br>  So, the first rule of functional programming is to use pure functions. <br><br><h1>  Higher order functions </h1><br>  We go further.  Since functions are objects, we can transfer them to other functions.  And higher-order functions are functions that return functions, or that take functions as parameters. <br><br>  Here is a simple example of a function that also returns a function. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAdder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">base</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base + num; } }</code> </pre><br><br>  And an example of its use. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> add2 = makeAdder(<span class="hljs-number"><span class="hljs-number">2</span></span>); add2(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//5 add2(7); //9</span></span></code> </pre><br><br>  Simple and obvious. <br><br>  But a fairly well-known example of a higher order function. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> el = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"btn"</span></span>); el.addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ });</code> </pre><br><br>  <b>addEventListener</b> takes a function as a parameter.  That is, <b>addEventListener</b> is a higher order function. <br><br>  And the handler function will be called when an event occurs. <br><br>  Perhaps you are more familiar with another option: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"input[type=submit]"</span></span>).on(<span class="hljs-string"><span class="hljs-string">"clink"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... });</span></span></code> </pre><br><br>  Or another thousand and one ways that jQuery allows you to describe handlers. <br><br>  So once again the definition: <br>  FVPs are functions that either return functions or accept functions as parameters. <br><br><h1>  Cycles </h1><br><br>  Old acquaintances. <br>  By cycle we mean a standard frontal solution.  About <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; ++<span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br><br>  Or so <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(n--){ <span class="hljs-comment"><span class="hljs-comment">// ... } // ...</span></span></code> </pre><br><br>  Why do we use cycles?  Let's look at a few standard use cases and see that cycles are not always the best solution. <br><br>  The first option is bypassing arrays and lists. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l&lt; arr.length; i&lt;l; ++i){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr[i]); }</code> </pre><br><br>  Typically, this bypass is used in conjunction with side effects.  And usually these effects are a little more useful than a simple output to the console. <br><br>  The second option - pulling data from the lists <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l= tweeps.length; i&lt; l; ++i) { names.push(tweeps[i].name); }</code> </pre><br>  In this case - a list of Twitter users. <br>  Using a cycle, we get a list of the names of our users. <br><br>  Another use case is data aggregation in the list: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> html = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l = items.length, i&lt;l, i++){ html += <span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span> + items[i] + <span class="hljs-string"><span class="hljs-string">'&lt;/li&gt;'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.list.innerHTML = html;</code> </pre><br><br>  That is, we aggregate the data in the list, and get another data structure at the output. <br><br><h1>  foreach </h1><br>  I said that cycles are not always the best solution, but what alternatives are there at all? <br><br>  What can replace such a cycle? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">1</span></span>; l = arr.length; i&lt; l; ++i){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr[i]); }</code> </pre><br><br>  For example <b>foreach</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.forEach arr.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(item); });</code> </pre><br><br>  Instead of running through the list with our hands, we can use <br>  array method.  Let's transfer there the function processing each element and we will receive the necessary result. <br><br>  But what is the <em>fundamental</em> difference between this <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">1</span></span>; l = arr.length; i&lt; l; ++i){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr[i]); }</code> </pre><br><br>  and by this <br><br><pre> <code class="javascript hljs">arr.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(item); });</code> </pre><br>  ? <br><br>  Unfortunately, the syntax for describing functions in JS is quite verbose, so we did not receive significant savings in the amount of written text. <br><br>  But there is something else.  Looking at the code, we can say what attention is paid to in each of the implementations. <br><br>  The first section is focused on the very mechanics of the cycle.  Take a number, increment it by one, get an array element by index, perform an action. <br><br>  The second example is much easier to understand.  We do something with each item in the list. <br><br>  In the second example, the level of abstraction is much higher.  And it allows you to approach the solution of the problem from the other side. <br><br>  So, for what we can use cycles: <br><ul><li>  Side effects </li><li>  Transformation </li><li>  Filters </li><li>  Combination of elements </li><li>  Another bunch of options </li></ul><br><br><h1>  map </h1><br>  Let's look at another function that is in Javascript. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>, l= tweeps.length, i&lt; l; ++i){ names.push(tweeps[i].name); }</code> </pre><br><br>  This is an abstraction that corresponds to the transformation list. <br>  Using <b>map</b> we can solve this problem much easier. <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//Array.prototype.map var names = tweeps.map(function (tweep){ return tweep.name; });</span></span></code> </pre><br><br>  We got rid of temporary variables, from the description of the cycle.  Direct and understandable code.  And since the processing function is quite short, we can fit everything in one line. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = tweeps.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.name;});</code> </pre><br><br>  I am not a fan of writing a single-line code.  But how many ideas can be expressed in one line indicates the expressiveness of your API. <br>  Now look for the mention on Twitter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"mentioned by"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l= tweeps.length; i &lt; l; ++i){ str += tweeps[i].name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&lt; tweeps.length<span class="hljs-number"><span class="hljs-number">-1</span></span>) {str += <span class="hljs-string"><span class="hljs-string">", "</span></span>} }</code> </pre><br><br>  A rather clumsy example.  There may be a bunch of errors with indexing and getting an array element. <br>  Let's analyze what we are really doing in this example: <br><br><ul><li>  We take out user names </li><li>  We combine user names (at the end of the list there should not be a comma) </li><li>  Use comma as a separator </li></ul><br><br>  Rewrite using <b>map</b> and <b>join</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"mentioned by "</span></span> + tweeps.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.name; }).join(<span class="hljs-string"><span class="hljs-string">", "</span></span>);</code> </pre><br><br>  Opportunities to make mistakes became much less. <br>  But can it be done better?  :) <br>  Let's introduce another higher order function that we will use to access the properties of objects. <br><br>  Let's call her <em>prop</em> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object[name]; } }</code> </pre><br><br>  At first glance, it is quite meaningless.  We give her a name, <br>  and it returns to us the function where the object is transferred from which we pull out the required field. <br><br>  Some confusing explanation came out.  Let's just try to use this function on a real task. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"Mentioned by "</span></span> + tweeps.map(prop (<span class="hljs-string"><span class="hljs-string">"name"</span></span>)).join(<span class="hljs-string"><span class="hljs-string">", "</span></span>);</code> </pre><br><br>  So, another one-liner.  Pretty good expressiveness.  And the <b>prop</b> function is not so useless. <br><br><h1>  reduce </h1><br>  This is a great-grandmother for for, foreach, while and other similar structures.  This function is also known as <em>fold</em> . <br><br>  Again, let's start with a primitive example. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalLength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; buffers.length; i++){ total.Length += buffers[i].length; }</code> </pre><br><br>  Just summarize the length of the buffers. <br>  What steps should we take? <br><ul><li>  Get buffer lengths </li><li>  Sum lengths </li></ul><br><br>  Use the function, Luke. <br><br>  First we use <b>map</b> to get a list containing buffer lengths. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalLength = buffers. map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffer</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer.length; })</code> </pre><br><br>  And in the second step, we use <b>reduce</b> to get their sum. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalLength = buffers. map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffer</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer.length; }). reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, curr</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum+curr;}, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  If you are not familiar with reduce, then it works very simply.  It transfers the battery function, which will be applied to each element and the initial value for the battery function. <br><br>  Somehow too difficult again.  Let's just see what happens if we apply <b>reduce</b> to a simple list. <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>].reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, curr</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum+curr;}, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [10, 5, 15, 10, 10] // sum curr // =&gt; 0, 10 =&gt; 10 // =&gt; 10, 5 =&gt; 15 // =&gt; 15, 15 =&gt; 30 // =&gt; 30, 10 =&gt; 40 // =&gt; 40, 10 =&gt; 50</span></span></code> </pre><br><br>  So with the help of reduce we can easily sum up the elements of the list. <br><br>  But we already had something similar.  Compare. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prev, curr</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev + curr;}</code> </pre><br>  and <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a+b; }</code> </pre><br>  Therefore, we can slightly simplify our function of calculating the total length of buffers. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalLength = buffers. map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffer</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer.length; }). reduce(add, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  Now it became clearer?  <b>reduce</b> simply adds all the elements of the list using the <b>add</b> function.  The initial value of the sum is zero.  What could be easier? <br><br>  But this simplification does not end there.  Compare <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buffer</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer.length; }</code> </pre><br>  and <br><pre> <code class="javascript hljs">prop(<span class="hljs-string"><span class="hljs-string">"length"</span></span>)</code> </pre><br><br>  Pants are turning ... <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalLength = buffers. map(prop(<span class="hljs-string"><span class="hljs-string">"length"</span></span>)). reduce(add, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  In elegant shorts. <br><br>  Well and, naturally, we can write it in one line. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalLength = buffers.map(prop(<span class="hljs-string"><span class="hljs-string">"length"</span></span>)).reduce(add, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  Using convolution (reduce) instead of cycles allows us to think at a different level of abstraction.  We perform operations on the list, and not at the level of each element. <br><br><h1>  Asynchronous calls </h1><br><br>  But using <b>reduce aka fold</b> to sum lists is a very simplified example.  The idea is much more powerful.  Let's take another example. <br><br>  One of the problems with using Javascript in the browser is that everything runs in one thread, and therefore we must use callbacks. <br><br>  Task. <br><ul><li>  Download multiple scripts </li><li>  Glue them </li><li>  preserve the order of scripts when gluing </li></ul><br>  That is, you need to write a function like this: <br><br><pre> <code class="javascript hljs">combine([<span class="hljs-string"><span class="hljs-string">"/jquery.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"/underscore.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"/backbone.js"</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// content    ,    . });</span></span></code> </pre><br><br>  Let's write the implementation of the <b>combine</b> function.  First - the frontal approach. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l = scripts.length; i&lt; l; ++i){ <span class="hljs-comment"><span class="hljs-comment">// .... } }</span></span></code> </pre><br><br>  To get scripts, it would be logical to use jQuery.ajax: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l = scripts.length; i&lt; l; ++i){ jQuery.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: scripts[i], <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .... } }); } }</span></span></code> </pre><br>  Such code will not slow down the browser, since requests to the server will be sent asynchronously.  That is, there will be 3 parallel queries during execution. <br><br>  Let's write a handler for successful script download. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l = scripts.length; i&lt; l; ++i){ jQuery.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: scripts[i], <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ data[i] = response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.length === scripts.length){ callback(data.join(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } } }); } }</code> </pre><br><br>  It seems to be a function ready.  But there are two but. <br>  Firstly, it is ugly, secondly - it will not work. <br><br>  What could be the problem?  Javascript scopes.  In this language, the area of ‚Äã‚Äãvisibility is not block by block, but functional.  that is, all 3 functions will see the same value of the variable i.  Since the cycle will work before the responses from the server arrive, all three functions will work with i == 3; <br>  This problem is solved in the standard way - we cache the value of the loop variable.  But it cannot be said that the code from this has become more beautiful. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l = scripts.length; i&lt; l; ++i){ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{ jQuery.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: scripts[i], <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ data[i] = response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.length === scripts.length){ callback(data.join(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } } }); }(i)); } }</code> </pre><br><br>  Almost even works.  In order to get rid of closures and tricky variables, you can use foreach <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data []; scripts.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">script,i</span></span></span><span class="hljs-function">)</span></span>{ jQuery.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: scripts[i], <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ data[i] = response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.length === scripts.length){ callback(data.join(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } } }); }); } }</code> </pre><br><br>  Better, of course, but still scary.  By the way, the code will still not work correctly.  It can be finished to working condition, but this will create additional difficulties in the development and subsequent support. <br><br><h1>  Continuation Passing Style </h1><br>  To get rid of headaches, use the library. <br><br>  <a href="http://github.com/caolan/async">github.com/caolan/async</a> <br><br>  For work we will use such a thing as CPS. <br><br>  It sounds much worse than it actually is.  This is a function that takes another function as a parameter, and when the first function completes, it calls the parameter function instead of retrun. <br><br>  Wrap jQuery.ajax in such a way as to get the desired result. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ajax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, callback</span></span></span><span class="hljs-function">)</span></span>{ jQuery.ajax({<span class="hljs-attr"><span class="hljs-attr">url</span></span>: url, <span class="hljs-attr"><span class="hljs-attr">success</span></span>: callback}); }</code> </pre><br><br>  The function receives callback as a parameter, and we have not described an error handler.  In the real code, it must be, but for simplicity, we will forget about it. <br>  What happens if you use the async library?  It turns out something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.map(scripts, ajax, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">contents</span></span></span><span class="hljs-function">)</span></span>{ callback(contents.join(<span class="hljs-string"><span class="hljs-string">""</span></span>)); }); }</code> </pre><br><br>  We have a ready-made map function that works in an asynchronous world.  By the way, the current implementation will ensure the correct order of gluing the scripts, unlike our frontal example. <br><br>  Compare with what was: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l = scripts.length; i&lt; l; ++i){ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{ jQuery.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: scripts[i], <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ data[i] = response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.length === scripts.length){ callback(data.join(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } } }); }(i)); } }</code> </pre><br><br>  Since map is already a natural way of writing programs for me, I would never write the code above.  I would think how to adapt a map to an asynchronous environment.  And if there were no async library, I would have written an asynchronous map myself. <br><br>  The functional approach makes it much easier to look at things.  And implement more beautiful solutions. <br><br><h1>  Partial application of functions </h1><br><br>  Another idea that came from functional programming, and can be very useful if you know how to prepare it correctly. <br><br>  As an example, we will create DOM elements. <br>  (Approx. Translator: cull.dom - library, author, which he created for one of the projects. But the functions in it are obvious and simple.) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ul = cull.dom.el(<span class="hljs-string"><span class="hljs-string">"ul"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//document.createElement("ul") ul.nodeType === 1 // true</span></span></code> </pre><br><br>  You can also set property attributes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ul = cull.dom.el(<span class="hljs-string"><span class="hljs-string">"ul"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">"bands"</span></span>});</code> </pre><br><br>  And specify child elements <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> li = cull.dom.el(<span class="hljs-string"><span class="hljs-string">"li"</span></span>, <span class="hljs-string"><span class="hljs-string">"Tom Waits"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ul = cull.dom.el(<span class="hljs-string"><span class="hljs-string">"ul"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">"bands"</span></span>}, li);</code> </pre><br><br>  If you use them inside each other, you can get some kind of DSL for HTML. <br><br><pre> <code class="javascript hljs">va ul = cull.dom.el(<span class="hljs-string"><span class="hljs-string">"ul"</span></span>, <span class="hljs-attr"><span class="hljs-attr">className</span></span>:<span class="hljs-string"><span class="hljs-string">"bands"</span></span>}, cull.dom.el(<span class="hljs-string"><span class="hljs-string">"li"</span></span>, <span class="hljs-string"><span class="hljs-string">"Tom Waits"</span></span>));</code> </pre><br><br>  And now let's get down to the discussion of the partial application of functions.  Remember one of the first examples? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAdder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">base</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base + num; } }</code> </pre><br>  It returns a function that will add two numbers.  Naturally, if necessary, we can use named functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAdder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">base</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(base, num); } }</code> </pre><br><br>  And now we see that the function <b>makeAdder</b> takes the function <b>add</b> and fixes one of its arguments.  You get an addition function, in which one of the arguments is a constant <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> add2 = cull.partial(add, <span class="hljs-number"><span class="hljs-number">2</span></span>); add2(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//7</span></span></code> </pre><br><br>  Now we have a rather interesting opportunity - to make our DSL for creating DOM elements even more beautiful. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ul = cull.partial(cull.dom.el, <span class="hljs-string"><span class="hljs-string">"ul"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> li = cull.partial(cull.dom.el, <span class="hljs-string"><span class="hljs-string">"li"</span></span>);</code> </pre><br><br>  And we can build HTML lists like this <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = ul({<span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">"bands"</span></span>}, [li(<span class="hljs-string"><span class="hljs-string">"Diamanda Galas"</span></span>), li(<span class="hljs-string"><span class="hljs-string">" "</span></span>), li(<span class="hljs-string"><span class="hljs-string">"John Zorn"</span></span>)]);</code> </pre><br><br>  If you, like me, don't like programming at the level of string variables, this is a great way to simplify your life.  You will now have auto-completion code, and other nice things.  And your code is very similar to plain HTML. <br>  And since our approach is quite beautiful, we can create functions for all elements of the document in advance: <br><br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"br"</span></span>, <span class="hljs-string"><span class="hljs-string">"code"</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>, ...].forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tagName</span></span></span><span class="hljs-function">)</span></span>{ cull.dom.el[tagName] = cull.partial(cull.dom.el, tagName); });</code> </pre><br><br>  Thus, we will create a function for each HTML element. <br>  Of course, the namespace is not always convenient to use completely, so we will simplify even further. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = cull.dom.el; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = ul({<span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">"bands"</span></span>}, [e.li(<span class="hljs-string"><span class="hljs-string">"Pan Sonic"</span></span>), e.li(<span class="hljs-string"><span class="hljs-string">" "</span></span>), e.li(<span class="hljs-string"><span class="hljs-string">"Muslimgauze"</span></span>)]);</code> </pre><br><br>  Now we are not tied to global variables and functions, which is good. <br><br><h1>  Function composition </h1><br><br>  Here is another example of a simple questionnaire application. <br><img src="http://habrastorage.org/storage2/af3/435/018/af3435018e9981504e2be750b0866d28.png"><br><br>  You must answer each block.  Each block contains several questions.  After answering one block, we proceed to the next. <br><br>  Each block can be thought of as a panel, which can be in query mode, result mode, or inactive. <br><br><img src="http://habrastorage.org/storage2/80c/943/06e/80c94306ea1ced77b4b8c034881c2c0a.png"><br><br>  Each panel can have different fields.  String, numeric, dates. <br>  Fields can be in two modes - editing or result. <br><br>  We will see how to approach this problem using a functional approach. <br><br>  Remember our favorite <b>prop</b> function? <br><br><pre> <code class="javascript hljs">tweeps.map(prop(<span class="hljs-string"><span class="hljs-string">"name"</span></span>));</code> </pre><br><br>  She has a twin brother <em>func</em> . <br><br><pre> <code class="javascript hljs">tweeps.map(func(<span class="hljs-string"><span class="hljs-string">"to.String"</span></span>));</code> </pre><br>  It returns a function that you can apply to objects. <br><br>  Now we calculate the result of each block in the questionnaire <br><br><pre> <code class="javascript hljs">buildSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components.map(func(<span class="hljs-string"><span class="hljs-string">"buildSummary"</span></span>))); }</code> </pre><br><br>  The principle should be obvious.  We return a div in which there will be elements created by the <b>buildSummary</b> function for each block of the questionnaire. <br><br>  In this example, each component itself knows how to present its result.  But sometimes the panel should display the result in a specific way. <br><br>  Therefore, we can write 2 functions: <b>buildSummary</b> and <b>getSummary</b> . <br><br>  The first is building a complete presentation, including html tags. <br>  The second returns an object that contains the required results. <br><br>  And as soon as we needed clever processing of the results, all the beauty began to crumble. <br><br><pre> <code class="javascript hljs">buildSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"div"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; l=<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components.length; i&lt;l; ++i) { p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.CreateElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components[i].getSummary().text; div.appendChild(p); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div; }</code> </pre><br><br>  However, we are already functionally oriented enough to improve this piece of code.  The first obvious improvement is to use foreach. <br><br><pre> <code class="javascript hljs">buildSummary : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"div"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">component</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = component.getSummary().text; div.appendChild(p); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div; }</code> </pre><br><br>  We got rid of loop variables, but is it possible to use <b>map</b> ? <br><br><pre> <code class="javascript hljs">buildSummary : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">component</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = component.getSummary().text; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; })); }</code> </pre><br><br>  Short, but far from ideal.  The main problem in this expression: <br><pre> <code class="javascript hljs">component.getSummary().text;</code> </pre><br><br>  The problem is, not one thing happens here, but three things: <br><ol><li>  Getting the result via getSummary () </li><li>  Getting the text property </li><li>  Wrapping the result in the <b>p</b> tag </li></ol><br><br>  What about several map functions? <br><br><pre> <code class="javascript hljs">buildSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components. map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">component</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> component.getSummary(); }).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">summary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summary.text; }).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = text; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; })); }</code> </pre><br><br>  The functional style is obvious, but it looks scary.  And it is very inconvenient to read. <br><br>  But let's look at the code once more.  What do we have here? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> component.getSummary();</code> </pre><br><br>  Here we call the object method.  But we created a special function for this, <b>func</b> . <br><br><pre> <code class="javascript hljs">buildSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components. map(func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>)). map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">summary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summary.text; }).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = text; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; })); }</code> </pre><br><br>  And here? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">summary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summary.text; }</code> </pre><br><br>  We get access to the property of the object.  And for this, too, there is a convenient function. <br><br><pre> <code class="javascript hljs">buildSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components. map(func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>)). map(prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)). map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = text; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; })); }</code> </pre><br>  Remained last site. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"p"</span></span>); p.innerHTML = text; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre><br><br>  Here we create a DOM element and set its internal property.  We have something similar in our DSL, isn't it? <br><br><pre> <code class="javascript hljs">buildSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components. map(func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>)). map(prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)). map(p)); }</code> </pre><br>  It's almost beautiful now.  But there is one nuance.  We make 3 passes through the list.  In some cases this may be normal, but in general it is somewhat suboptimal.  What can be done? <br><br>  It's time to use composition of functions.  We want to make one function do what the three do. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose( [p, prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>), func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>)]);</code> </pre><br><br><h2>  How do we implement compose? </h2><br>  Piecemeal.  To begin, create synonyms to not write a lot of code. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callGetSummary = func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getText = prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose([p, getText, callGetSummary]);</code> </pre><br><br>  Everything is simple and obvious.  We go further.  Let us see what happens when we call the <b>summarize</b> function. <br><br><h3>  Step one </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callGetSummary = func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getText = prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose([p, getText, callGetSummary]); <span class="hljs-comment"><span class="hljs-comment">// summarize(obj); // =&gt; callGetSummary(obj)</span></span></code> </pre><br>  The object is transferred to the last function from the list, namely <b>getSummary</b> .  It returns an object of type <b>summary</b> .  And this object is passed to the next function, <b>getText.</b> <br><br><h3>  Step Two </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callGetSummary = func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getText = prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose([p, getText, callGetSummary]); <span class="hljs-comment"><span class="hljs-comment">// summarize(obj); // =&gt; getText(callGetSummary(obj))</span></span></code> </pre><br><br>  As a result of the second step, we get the string that is contained in the <b>text</b> property.  And after that the line will fall into the function that will create a DOM object <b>p for us</b> . <br><br><h3>  Step Three </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callGetSummary = func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getText = prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose([p, getText, callGetSummary]); <span class="hljs-comment"><span class="hljs-comment">// summarize(obj); // =&gt; p(getText(callGetSummary(obj)))</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an example of a simple composition, when a parameter is passed from a function to a function sequentially. </font><font style="vertical-align: inherit;">You can create a composition, when the parameter will be passed to each function, and the output will be a list of results. </font><font style="vertical-align: inherit;">Or something else. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So back to our long-suffering example.</font></font><br><br><pre> <code class="javascript hljs">builSummary: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose( [p, prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>), func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>)]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.components.map(summarize)); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we created a function to calculate the results. </font><font style="vertical-align: inherit;">And then applied the map. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">summarize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">does not know at all what object it works with. </font><font style="vertical-align: inherit;">These are three different abstractions that are connected exclusively by the compose function. </font><font style="vertical-align: inherit;">Therefore, we can take summarize to a separate entity.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> summarize = compose( [p, prop(<span class="hljs-string"><span class="hljs-string">"text"</span></span>), func(<span class="hljs-string"><span class="hljs-string">"getSummary"</span></span>)]); <span class="hljs-comment"><span class="hljs-comment">// ... builSummary: function() { return div(this.components.map(summarize)); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It looks cool and beautiful, but what about performance? </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performance issues </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for - 5M operations per second </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEach - 1.5M operations per second </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce - 1.5M operations per second </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with DOM - 50K operations per second </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So you should not worry about the functional approach, but about the brakes of working with DOM. </font><font style="vertical-align: inherit;">Of course, it all depends on your task, so if in doubt, take measurements. </font><font style="vertical-align: inherit;">Especially on mobile devices.</font></font><br><br><h1>  Conclusion </h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use pure functions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use higher order functions (map, reduce). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use small abstractions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many small abstractions can be easily assembled into one big powerful thing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS You can watch </font></font><a href="http://cjohansen.no/talks/2012/javazone/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slides of the</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> original performance at </font><a href="http://cjohansen.no/talks/2012/javazone/"><font style="vertical-align: inherit;">cjohansen.no/talks/2012/javazone</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PPS And why isn‚Äôt there a functional programming programming hub?</font></font></div><p>Source: <a href="https://habr.com/ru/post/154105/">https://habr.com/ru/post/154105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154091/index.html">Optimization of lead collection for the site accompanying the project</a></li>
<li><a href="../154097/index.html">Features of uploading files to HTML5</a></li>
<li><a href="../154099/index.html">New for web designer in October 2012</a></li>
<li><a href="../154101/index.html">Apple, Facebook, Google, Microsoft Launch WebPlatform</a></li>
<li><a href="../154103/index.html">Jpg, transparency, canvas, animation</a></li>
<li><a href="../154107/index.html">The new user authentication system uses the unique characteristics of video cards.</a></li>
<li><a href="../154109/index.html">Can neural networks help copy the brain?</a></li>
<li><a href="../154111/index.html">Ruby Codecademy Course</a></li>
<li><a href="../154117/index.html">Making an information widget for the Drupal site</a></li>
<li><a href="../154119/index.html">A small item has fallen off from Curiosity!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>