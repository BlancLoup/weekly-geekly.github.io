<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Error Handling in C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Errors, alas, are unavoidable, so their processing takes a very important place in programming. And if algorithmic errors can be identi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Error Handling in C</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/9f0/658/511/9f0658511b7b48f7b67b68f6174c12f2.jpg"><br><br><h3>  Introduction </h3><br>  Errors, alas, are unavoidable, so their processing takes a very important place in programming.  And if algorithmic errors can be identified and corrected during the writing and testing of the program, then run-time errors cannot be avoided in principle.  Today we look at the functions of the standard library ( <a href="https://en.wikipedia.org/wiki/C_standard_library">C Standard Library</a> ) and <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> , used in error handling. <br><a name="habracut"></a><br><h3>  Errno variable and error codes </h3><br><h4>  <a href="https://en.wikipedia.org/wiki/Errno.h">&lt;errno.h&gt;</a> </h4><br>  <b>errno</b> is a variable storing the integer code of the last error.  Each stream has its own local version of <b>errno</b> , which is the reason for its security in a multithreaded environment.  Usually, <b>errno</b> is implemented as a macro that expands into a function call that returns a pointer to an integer buffer.  When the program starts, the <b>errno</b> value is zero. <br><br>  All error codes have positive values, and can be used in preprocessor directives <b>#if</b> .  For convenience and portability, the <code>&lt;errno.h&gt;</code> header file defines macros that correspond to error codes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The ISO C standard defines the following codes: <br><br><ul><li>  <b>EDOM</b> - ( <b>E</b> rror <b>dom</b> ain) domain error. </li><li>  <b>EILSEQ</b> - ( <b>E</b> rror <b>i</b> nva <b>l</b> id <b>seq</b> uence) wrong byte sequence. </li><li>  <b>ERANGE</b> - ( <b>E</b> rror <b>range</b> ) the result is too large. </li></ul><br>  Other error codes (several dozen) and their descriptions are defined in the POSIX standard.  In addition, the specifications of standard functions usually indicate the error codes used by them and their descriptions. <br><br>  A simple script prints error codes, their symbolic names and descriptions to the console: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use strict; use warnings; use Errno; foreach my $err (sort keys (%!)) { $! = eval "Errno::$err"; printf "%20s %4d %s\n", $err, $! + 0, $! }</span></span></code> </pre> <br>  If the function call fails, it sets the <b>errno</b> variable to a nonzero value.  If the call is successful, the function usually does not check and does not change the <b>errno</b> variable.  Therefore, before calling a function, it must be set to <code>0</code> . <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* convert from UTF16 to UTF8 */</span></span> errno = <span class="hljs-number"><span class="hljs-number">0</span></span>; n_ret = iconv(icd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **) &amp;p_src, &amp;n_src, &amp;p_dst, &amp;n_dst); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n_ret == (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) <span class="hljs-number"><span class="hljs-number">-1</span></span>) { VJ_PERROR(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == E2BIG) <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">" Error : input conversion stopped due to lack of space in the output buffer\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EILSEQ) <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">" Error : input conversion stopped due to an input byte that does not belong to the input codeset\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EINVAL) <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">" Error : input conversion stopped due to an incomplete character or shift sequence at the end of the input buffer\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* clean the memory */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(p_out_buf); errno = <span class="hljs-number"><span class="hljs-number">0</span></span>; n_ret = iconv_close(icd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n_ret == (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) <span class="hljs-number"><span class="hljs-number">-1</span></span>) VJ_PERROR(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  As you can see, the error descriptions in <a href="https://www.freebsd.org/cgi/man.cgi%3Fquery%3Diconv%26apropos%3D0%26sektion%3D3%26manpath%3DFreeBSD%2B11.0-stable%26arch%3Ddefault%26format%3Dhtml">the</a> <code>iconv()</code> function <a href="https://www.freebsd.org/cgi/man.cgi%3Fquery%3Diconv%26apropos%3D0%26sektion%3D3%26manpath%3DFreeBSD%2B11.0-stable%26arch%3Ddefault%26format%3Dhtml">specification</a> are more informative than in <code>&lt;errno.h&gt;</code> . <br><br><h3>  Errno functions </h3><br>  Having received the error code, I want to immediately get a description of it.  Fortunately, ISO C offers a whole host of useful features. <br><br><h4>  <a href="https://en.wikipedia.org/wiki/C_string_handling">&lt;stdio.h&gt;</a> </h4><br> <code>void perror(const char *s);</code> <br> <br>  Prints <b>stder with the</b> contents of <code>s</code> , followed by a colon, a space, and an error message.  Then it prints the newline character <code>'\n'</code> . <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // perror example // // Created by Ariel Feinerman on 23/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; int main(int argc, const char * argv[]) { // Generate unique filename. char *file_name = tmpnam((char[L_tmpnam]){0}); errno = 0; FILE *file = fopen(file_name, "rb"); if (file) { // Do something useful. fclose(file); } else { perror("fopen() "); } return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br><h4>  <a href="https://en.wikipedia.org/wiki/C_string_handling">&lt;string.h&gt;</a> </h4><br>  char * strerror (int errnum); <br>  Returns a string describing the error <code>errnum</code> .  The language of the message depends on the locale (German, Hebrew and even Japanese), but usually only English is supported. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // strerror example // // Created by Ariel Feinerman on 23/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; int main(int argc, const char * argv[]) { // Generate unique filename. char *file_name = tmpnam((char[L_tmpnam]){0}); errno = 0; FILE *file = fopen(file_name, "rb"); // Save error number. errno_t error_num = errno; if (file) { // Do something useful. fclose(file); } else { char *errorbuf = strerror(error_num); fprintf(stderr, "Error message : %s\n", errorbuf); } return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  <code>strerror()</code> not a safe function.  First, the string returned by it is not constant.  However, it can be stored in static or in dynamic memory, depending on the implementation.  In the first case, changing it will result in a run-time error.  Secondly, if you decide to save a pointer to a string, and then call a function with a new code, all previous pointers will point to a new row, because it uses one buffer for all rows.  Third, its behavior in a multithreaded environment is not defined in the standard.  However, in <a href="https://en.wikipedia.org/wiki/QNX">QNX,</a> it is declared as thread safe. <br><br>  Therefore, in the new <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">ISO standard C11</a> , two very useful functions were proposed. <br><br> <code>size_t strerrorlen_s(errno_t errnum);</code> <br> <br>  Returns the length of the string describing the error <code>errnum</code> . <br><br> <code>errno_t strerror_s(char *buf, rsize_t buflen, errno_t errnum);</code> <br> <br>  Copies the string with the <code>errnum</code> error <code>errnum</code> to the <code>buf</code> buffer of length <code>buflen</code> . <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // strerror_s example // // Created by Ariel Feinerman on 23/02/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __STDC_WANT_LIB_EXT1__ 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; int main(int argc, const char * argv[]) { // Generate unique filename. char *file_name = tmpnam((char[L_tmpnam]){0}); errno = 0; FILE *file = fopen(file_name, "rb"); // Save error number. errno_t error_num = errno; if (file) { // Do something useful. fclose(file); } else { #ifdef __STDC_LIB_EXT1__ size_t error_len = strerrorlen_s(errno) + 1; char error_buf[error_len]; strerror_s(error_buf, error_len, errno); fprintf(stderr, "Error message : %s\n", error_buf); #endif } return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Functions are included in Annex K (Bounds-checking interfaces), which caused a lot of <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm">controversy</a> .  It is not required to be executed and is not fully implemented in any of the free libraries.  <a href="https://en.wikipedia.org/wiki/Watcom_C/C%252B%252B">Open Watcom C / C ++</a> (Windows), <a href="https://code.google.com/archive/p/slibc">Slibc</a> (GNU libc) and <a href="https://sourceforge.net/projects/safeclib">Safe C Library</a> (POSIX), in the latter, unfortunately, these two functions are not implemented.  However, they can be found in commercial development environments and real-time systems, <a href="https://www.embarcadero.com/products/rad-studio">Embarcadero RAD Studio</a> , <a href="http://www.tenasys.com/tenasys-products/development-tools/overview-sdk">INtime RTOS</a> , <a href="https://en.wikipedia.org/wiki/QNX">QNX</a> . <br><br>  The <a href="http://pubs.opengroup.org/onlinepubs/9699919799">POSIX.1-2008 standard</a> defines the following functions: <br><br> <code>char *strerror_l(int errnum, locale_t locale);</code> <br> <br>  Returns a string containing a localized description of the <code>errnum</code> error using <code>locale</code> .  Safe in multithreaded environment.  Not implemented on <a href="https://en.wikipedia.org/wiki/MacOS">Mac OS X</a> , <a href="https://en.wikipedia.org/wiki/FreeBSD">FreeBSD</a> , <a href="https://en.wikipedia.org/wiki/NetBSD">NetBSD</a> , <a href="https://en.wikipedia.org/wiki/OpenBSD">OpenBSD</a> , <a href="https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris,</a> and other commercial UNIX.  Implemented in Linux, <a href="https://en.wikipedia.org/wiki/MINIX_3">MINIX 3</a> and <a href="https://en.wikipedia.org/wiki/Illumos">Illumos</a> (OpenSolaris). <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // strerror_l example ‚Äì works on Linux, MINIX 3, Illumos // // Created by Ariel Feinerman on 23/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;locale.h&gt; int main(int argc, const char * argv[]) { locale_t locale = newlocale(LC_ALL_MASK, "fr_FR.UTF-8", (locale_t) 0); if (!locale) { fprintf(stderr, "Error: cannot create locale."); exit(EXIT_FAILURE); } // Generate unique filename. char *file_name = tmpnam((char[L_tmpnam]){0}); errno = 0; FILE *file = fopen(tmpnam(file_name, "rb"); // Save error number. errno_t error_num = errno; if (file) { // Do something useful. fclose(file); } else { char *error_buf = strerror_l(errno, locale); fprintf(stderr, "Error message : %s\n", error_buf); } freelocale(locale); return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">Error message : Aucun fichier ou dossier de ce <span class="hljs-built_in"><span class="hljs-built_in">type</span></span></code> </pre> <br> <code>int strerror_r(int errnum, char *buf, size_t buflen);</code> <br> <br>  Copies the string with the <code>errnum</code> error <code>errnum</code> to the <code>buf</code> buffer of length <code>buflen</code> .  If <code>buflen</code> less than the length of the string, the excess is trimmed.  Safe in multithreaded environment.  Implemented in all UNIX. <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // strerror_r POSIX example // // Created by Ariel Feinerman on 25/02/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #define MSG_LEN 1024 int main(int argc, const char * argv[]) { // Generate unique filename. char *file_name = tmpnam((char[L_tmpnam]){0}); errno = 0; FILE *file = fopen(file_name, "rb"); // Save error number. errno_t error_num = errno; if (file) { // Do something useful. fclose(file); } else { char error_buf[MSG_LEN]; errno_t error = strerror_r (error_num, error_buf, MSG_LEN); switch (error) { case EINVAL: fprintf (stderr, "strerror_r() failed: invalid error code, %d\n", error); break; case ERANGE: fprintf (stderr, "strerror_r() failed: buffer too small: %d\n", MSG_LEN); case 0: fprintf(stderr, "Error message : %s\n", error_buf); break; default: fprintf (stderr, "strerror_r() failed: unknown error, %d\n", error); break; } } return EXIT_SUCCESS; }</span></span></span></span></code> </pre><br>  Alas, no analogue of <code>strerrorlen_s()</code> in POSIX was determined, so the length of the string can only be determined experimentally.  Usually 300 characters are enough for the eyes  <a href="https://en.wikipedia.org/wiki/GNU_C_Library">The GNU C Library</a> implementation of <code>strerror()</code> uses a buffer with a length of 1024 characters.  But you never know, and suddenly? <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // strerror_r safe POSIX example // // Created by Ariel Feinerman on 23/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #define MSG_LEN 1024 #define MUL_FACTOR 2 int main(int argc, const char * argv[]) { // Generate unique filename. char *file_name = tmpnam((char[L_tmpnam]){0}); errno = 0; FILE *file = fopen(file_name, "rb"); // Save error number. errno_t error_num = errno; if (file) { // Do something useful. fclose(file); } else { errno_t error = 0; size_t error_len = MSG_LEN; do { char error_buf[error_len]; error = strerror_r (error_num, error_buf, error_len); switch (error) { case 0: fprintf(stderr, "File : %s\nLine : %d\nCurrent function : %s()\nFailed function : %s()\nError message : %s\n", __FILE__, __LINE__, __func__, "fopen", error_buf); break; case ERANGE: error_len *= MUL_FACTOR; break; case EINVAL: fprintf (stderr, "strerror_r() failed: invalid error code, %d\n", error_num); break; default: fprintf (stderr, "strerror_r() failed: unknown error, %d\n", error); break; } } while (error == ERANGE); } return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">File : /Users/ariel/main.c Line : 47 Current <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> : main() Failed <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> : fopen() Error message : No such file or directory</code> </pre> <br><h3>  Macro <a href="http://en.cppreference.com/w/c/error/assert">assert ()</a> </h3><br><h4>  <a href="https://en.wikipedia.org/wiki/Assert.h">&lt;assert.h&gt;</a> </h4><br> <code>void assert(expression)</code> <br> <br>  A macro that checks the <code>expression</code> condition (its result must be a number) at run time.  If the condition is not satisfied ( <code>expression</code> is zero), it prints the values <code>__FILE__</code> , <code>__LINE__</code> , <code>__func__</code> and <code>expression</code> as strings to <b>stderr</b> , and then calls the <code>abort()</code> function. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // assert example // // Created by Ariel Feinerman on 23/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;math.h&gt; int main(int argc, const char * argv[]) { double x = -1.0; assert(x &gt;= 0.0); printf("sqrt(x) = %f\n", sqrt(x)); return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">Assertion failed: (x &gt;= 0.0), <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> main, file /Users/ariel/main.c, line 17.</code> </pre> <br>  If the <code>NDEBUG</code> macro <code>NDEBUG</code> defined before including <code>&lt;assert.h&gt;</code> , then <code>assert()</code> expanded to <code>((void) 0)</code> and does nothing.  Used for debugging purposes. <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // assert_example // // Created by Ariel Feinerman on 23/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> #NDEBUG <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;math.h&gt; int main(int argc, const char * argv[]) { double x = -1.0; assert(x &gt;= 0.0); printf("sqrt(x) = %f\n", sqrt(x)); return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">sqrt(x) = nan</code> </pre> <br><h3>  <a href="http://en.cppreference.com/w/c/program/atexit">Atexit ()</a> , <a href="http://en.cppreference.com/w/c/program/exit">exit (),</a> and <a href="http://en.cppreference.com/w/c/program/abort">abort ()</a> functions </h3><br><h4>  <a href="http://pubs.opengroup.org/onlinepubs/9699919799">&lt;stdlib.h&gt;</a> </h4><br> <code>int atexit(void (*func)(void));</code> <br> <br>  Registers the functions called upon the normal completion of the program in the reverse order of their registration.  You can register up to 32 functions. <br><br> <code>_Noreturn void exit(int exit_code);</code> <br> <br>  Causes normal program termination, returns the number <code>exit_code</code> on Wednesday.  The ISO C standard defines only three possible values: <code>0</code> , <code><a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_SUCCESS</a></code> and <code><a href="http://en.cppreference.com/w/c/program/EXIT_status">EXIT_FAILURE</a></code> .  In this case, functions registered through <code>atexit()</code> are called, input-output streams are reset and closed, temporary files are deleted, after which control is transferred to the environment.  The <code>exit()</code> function is called in <code><a href="http://en.cppreference.com/w/c/language/main_function">main()</a></code> when executing a return or reaching the end of a program. <br><br>  The main advantage of <code>exit()</code> is that it allows you to terminate the program not only from <code>main()</code> , but also from any nested function.  For example, if in a deeply nested function a certain condition is fulfilled (or not fulfilled), after which further program execution loses all meaning.  Such a reception (early exit) is widely used when writing daemons, system utilities and parsers.  In interactive programs with an infinite main loop, <code>exit()</code> can be used to exit the program by selecting the desired menu item. <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // exit example // // Created by Ariel Feinerman on 17/03/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; void third_2(void) { printf("third #2\n"); // Does not print. } void third_1(void) { printf("third #1\n"); // Does not print. } void second(double num) { printf("second : before exit()\n"); // Prints. if ((num &lt; 1.0f) &amp;&amp; (num &gt; -1.0f)) { printf("asin(%.1f) = %.3f\n", num, asin(num)); exit(EXIT_SUCCESS); } else { fprintf(stderr, "Error: %.1f is beyond the range [-1.0; 1.0]\n", num); exit(EXIT_FAILURE); } printf("second : after exit()\n"); // Does not print. } void first(double num) { printf("first : before second()\n") second(num); printf("first : after second()\n"); // Does not print. } int main(int argc, const char * argv[]) { atexit(third_1); // Register first handler. atexit(third_2); // Register second handler. first(-3.0f); return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">first : before second() second : before <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() Error: -3.0 is beyond the range [-1.0; 1.0] third <span class="hljs-comment"><span class="hljs-comment">#2 third #1</span></span></code> </pre> <br> <code>_Noreturn void abort(void);</code> <br> <br>  Causes a program to crash if the signal has not been intercepted by a signal handler.  Temporary files are not destroyed, closing threads is determined by the implementation.  The most important difference between the abort () and <code>exit(EXIT_FAILURE)</code> calls is that the first one sends the <code>SIGABRT</code> signal to the program, it can be intercepted and the necessary actions can be taken before the program ends.  A <a href="https://en.wikipedia.org/wiki/Core_dump">core dump file of the</a> program is recorded, if enabled.  When launched in the debugger, it intercepts the <code>SIGABRT</code> signal and stops the execution of the program, which is very convenient in debugging. <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // abort example // // Created by Ariel Feinerman on 17/02/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; void third_2(void) { printf("third #2\n"); // Does not print. } void third_1(void) { printf("third #1\n"); // Does not print. } void second(double num) { printf("second : before exit()\n"); // Prints. if ((num &lt; 1.0f) &amp;&amp; (num &gt; -1.0f)) { printf("asin(%.1f) = %.3f\n", num, asin(num)); exit(EXIT_SUCCESS); } else { fprintf(stderr, "Error: %.1f is beyond the range [-1.0; 1.0]\n", num); abort(); } printf("second : after exit()\n"); // Does not print. } void first(double num) { printf("first : before second()\n"); second(num); printf("first : after second()\n"); // Does not print. } int main(int argc, const char * argv[]) { atexit(third_1); // register first handler atexit(third_2); // register second handler first(-3.0f); return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">first : before second() second : before <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() Error: -3.0 is beyond the range [-1.0; 1.0] Abort <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span>: 6</code> </pre> <br>  Debugger output: <br><br><pre> <code class="bash hljs">$ lldb abort_example (lldb) target create <span class="hljs-string"><span class="hljs-string">"abort_example"</span></span> Current executable <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> to <span class="hljs-string"><span class="hljs-string">'abort_example'</span></span> (x86_64). (lldb) run Process 22570 launched: <span class="hljs-string"><span class="hljs-string">'/Users/ariel/abort_example'</span></span> (x86_64) first : before second() second : before <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() Error: -3.0 is beyond the range [-1.0; 1.0] Process 22570 stopped * thread <span class="hljs-comment"><span class="hljs-comment">#1: tid = 0x113a8, 0x00007fff89c01286 libsystem_kernel.dylib`__pthread_kill + 10, queue = 'com.apple.main-thread', stop reason = signal SIGABRT frame #0: 0x00007fff89c01286 libsystem_kernel.dylib`__pthread_kill + 10 libsystem_kernel.dylib`__pthread_kill: -&gt; 0x7fff89c01286 &lt;+10&gt;: jae 0x7fff89c01290 ; &lt;+20&gt; 0x7fff89c01288 &lt;+12&gt;: movq %rax, %rdi 0x7fff89c0128b &lt;+15&gt;: jmp 0x7fff89bfcc53 ; cerror_nocancel 0x7fff89c01290 &lt;+20&gt;: retq (lldb)</span></span></code> </pre> <br>  In case of a critical error, the <code>abort()</code> function must be used.  For example, if an error occurred while allocating memory or writing a file.  Any further action may aggravate the situation.  If you complete the execution in the usual way, which is used to reset the input / output streams, you can lose still intact data and temporary files, so the best solution would be to write a dump and instantly terminate the program. <br><br>  In the case of a non-critical error, for example, you could not open the file, you can safely exit via <code>exit()</code> . <br><br><h3>  <a href="http://en.cppreference.com/w/c/program/setjmp">Setjmp ()</a> and <a href="http://en.cppreference.com/w/c/program/longjmp">longjmp ()</a> functions </h3><br>  Here we come to the most interesting - the functions of nonlocal transitions.  <code>setjmp()</code> and <code>longjmp()</code> work on the <b>goto</b> principle, but unlike it, they allow you to jump from one place to another within the entire program, rather than one function. <br><br><h4>  <a href="https://en.wikipedia.org/wiki/Setjmp.h">&lt;setjmp.h&gt;</a> </h4><br> <code>int setjmp(jmp_buf env);</code> <br> <br>  Stores information about the execution context of a program (microprocessor registers, etc.) to <code>env</code> .  Returns <code>0</code> if it was called directly or <code>value</code> , if from <code>longjmp()</code> . <br><br> <code>void longjmp(jmp_buf env, int value);</code> <br> <br>  Restores the execution context of a program from <code>env</code> , returns control to <code>setjmp()</code> and passes it <code>value</code> . <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // setjmp simple // // Created by Ariel Feinerman on 18/02/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;setjmp.h&gt; static jmp_buf buf; void second(void) { printf("second : before longjmp()\n"); // prints longjmp(buf, 1); // jumps back to where setjmp was called ‚Äì making setjmp now return 1 printf("second : after longjmp()\n"); // does not prints // &lt;- Here is the point that is never reached. All impossible cases like your own house in Miami, your million dollars, your nice girl, etc. } void first(void) { printf("first : before second()\n"); second(); printf("first : after second()\n"); // does not print } int main(int argc, const char * argv[]) { if (!setjmp(buf)) first(); // when executed, setjmp returned 0 else // when longjmp jumps back, setjmp returns 1 printf("main\n"); // prints return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">first : before second() second : before longjmp() main</code> </pre> <br>  Using <code>setjmp()</code> and <code>longjmp</code> (), you can implement an exception mechanism.  In many high-level languages ‚Äã‚Äã(for example, in <a href="https://en.wikipedia.org/wiki/Perl">Perl</a> ), exceptions are implemented through them. <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* // main.c // exception simple // // Created by Ariel Feinerman on 18/02/17. // Copyright 2017 Feinerman Research, Inc. All rights reserved. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;setjmp.h&gt; #define str(s) #s static jmp_buf buf; typedef enum { NO_EXCEPTION = 0, RANGE_EXCEPTION = 1, NUM_EXCEPTIONS } exception_t; static char *exception_name[NUM_EXCEPTIONS] = { str(NO_EXCEPTION), str(RANGE_EXCEPTION) }; float asin_e(float num) { if ((num &lt; 1.0f) &amp;&amp; (num &gt; -1.0f)) { return asinf(num); } else { longjmp(buf, RANGE_EXCEPTION); // | @throw } } void do_work(float num) { float res = asin_e(num); printf("asin(%f) = %f\n", num, res); } int main(int argc, const char * argv[]) { exception_t exc = NO_EXCEPTION; if (!(exc = setjmp(buf))) { // | do_work(-3.0f); // | @try } // | else { // | fprintf(stderr, "%s was hadled in %s()\n", exception_name[exc], __func__); // | @catch } // | return EXIT_SUCCESS; }</span></span></span></span></code> </pre> <br>  Conclusion: <br><br><pre> <code class="bash hljs">RANGE_EXCEPTION was hadled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> main()</code> </pre> <br>  Attention!  The <code>setjmp()</code> and <code>longjmp</code> () functions are primarily used in system programming, and their use in client code is not recommended.  Their use worsens the readability of the program and can lead to unpredictable errors.  For example, what happens if you jump not up the stack - into the calling function, but into a parallel one that has already completed its execution? <br><br><h3>  Information </h3><br><ul><li>  ISO / IEC C ( <a href="https://en.wikipedia.org/wiki/C89">89/99/11</a> ) </li><li>  <a href="http://www.unix.org/version4">Single UNIX Specifcation, Version 4, 2016 Edition</a> </li><li>  <a href="http://pubs.opengroup.org/onlinepubs/9699919799">The Open Group Base Specifications Issue 7, 2016 Edition (POSIX.1-2008)</a> </li><li>  <a href="https://www.securecoding.cert.org/confluence/display/c/SEI%2BCERT%2BC%2BCoding%2BStandard">SEI CERT C Coding Standard</a> </li><li>  programming information </li><li>  reference information of the operating system ( <a href="https://en.wikipedia.org/wiki/Man_page">man pages</a> ) </li><li>  header files (/ usr / include) </li><li>  library sources ( <a href="https://en.wikipedia.org/wiki/C_standard_library">C Standard Library</a> ) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/324642/">https://habr.com/ru/post/324642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324632/index.html">On the market, a cow man sold (computational solution)</a></li>
<li><a href="../324634/index.html">Visa has allowed banks to charge an additional fee from a client for withdrawing cash at ‚Äúforeign‚Äù ATMs.</a></li>
<li><a href="../324636/index.html">UX for application localization: a developer's guide</a></li>
<li><a href="../324638/index.html">90+ free resources for self-study online</a></li>
<li><a href="../324640/index.html">A revolution in javascript. Literally</a></li>
<li><a href="../324644/index.html">On technical aspects of external and internal motivation</a></li>
<li><a href="../324646/index.html">Rust, Eclipse and STM32</a></li>
<li><a href="../324648/index.html">How I started programming better</a></li>
<li><a href="../324650/index.html">Count to three: two</a></li>
<li><a href="../324654/index.html">Infrastructure migration to the ‚Äúcloud‚Äù in steps: what difficulties arise and where</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>