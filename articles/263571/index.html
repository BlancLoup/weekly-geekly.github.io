<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SoC: we write framebuffer implementation for controller in FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings 

 Last time, we stopped by raising DMA to FPGA. 
 Today we are implementing a primitive LCD controller in the FPGA and write a framebuffer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SoC: we write framebuffer implementation for controller in FPGA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a63/5af/c38/a635afc38da84c6a8882ae9550030d48.jpg"><br><br>  Greetings <br><br>  <a href="http://habrahabr.ru/company/metrotek/blog/248145/">Last time,</a> we stopped by raising DMA to FPGA. <br>  Today we are implementing a primitive LCD controller in the FPGA and write a framebuffer driver for working with this controller. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You will once again make sure that developing for FPGA and writing drivers for Linux is very simple, but interesting. <br><br>  Also at the end there is a small survey - I want to know the opinion of the community.  If not difficult, please vote. <br><br><a name="habracut"></a><br>  It so happened that in HPS on <a href="https://www.altera.com/products/fpga/cyclone-series/cyclone-v/overview.html">Cyclone V</a> there is no integrated graphics controller.  And we can‚Äôt live without a display - where to take <a href="http://metrotek.spb.ru/b3et.html">the measurement results</a> . <br><br>  Of course, you can do without the software implementation of the framebuffer (with the addition of all sorts of usefulness in the form of deferred_io and double buffering).  But it, all the same, will not be very bright and definitely will not be as interesting as what we choose. <br><br>  And we choose the implementation of a very simple, but fully working LCD controller in the FPGA, which will remove the unnecessary load from the CPU in the form of writing data to the display. <br><br>  We will use LCD based on the <a href="http://www.newhavendisplay.com/app_notes/ILI9341.pdf">ILI9341</a> chip. <br><br>  So, plan for today: <br><ul><li>  Thinking about architecture </li><li>  We study our LCD </li><li>  Writing Linux Driver </li><li>  Developing a module in FPGA </li><li>  Configuring something in the U-boot </li><li>  Debugging </li></ul><br><br><h3>  Architecture </h3><br>  What is a <a href="https://ru.wikipedia.org/wiki/Linux_framebuffer">framebuffer</a> in Linux? <br>  In a nutshell - this is just a memory area, writing to which results in the display of what is written on the display. <br><br>  From userspace, access is performed through the device file <b>/ dev / fb [N]</b> . <br>  Standard system calls are usually implemented - open (), close (), read (), write (), lseek () and mmap (). <br><br>  In the driver, most of the functions perform one task - to update a frame that is stored in memory. <br>  Sometimes there are also functions that copy data from the memory to the LCD, if this is not implemented in hardware. <br><br>  All structures and functions are well described in detail in these articles - a <a href="http://habrahabr.ru/post/164635/">link once</a> and a <a href="http://habrahabr.ru/post/213775/">link two</a> . <br>  There is no sense to duplicate information, so we will analyze only what affects our architecture. <br><br>  So, we have several functions that are designed to update data in memory.  They have a slightly different signature.  Using these functions, you can redraw both the entire frame or just a few pixels. <br><br>  After updating the frame, you need to make it hit the LCD.  Naturally, copying only the modified part of the frame requires a smaller amount of data to be transferred.  And if we copied the data using the CPU, then we would definitely be worth considering. <br>  But we will copy the DMA controller in the FPGA, so we will not worry about it and will redraw the entire frame. <br><br>  The next question is when to redraw the frame.  One simple solution is to perform drawing synchronously, that is, at the end of each function that updates the data in memory.  This works well in all cases except using mmap (). <br>  After the mapping is complete, it is not so easy to determine when the userspace process has changed the contents of the memory.  This task can be solved with the help of <b>deferred_io</b> (and at the same time you can identify specific pages of memory that have been updated and need to be redrawn).  But we want our implementation to be as simple and clear as possible, so we will do it differently. <br><br>  Our controller in the FPGA will render the entire frame at a frequency of n FPS.  And it will do it asynchronously with respect to updating memory driver functions.  Thus, all that needs to be done in the driver is the initialization of the LCD and FPGA controller.  And even we will not need to implement the data recording in the memory of the framebuffer, for this we already have standard functions. <br><br>  The controller in the FPGA will also be fairly simple.  His tasks: <br><ul><li>  Read data from the specified area on the interface <b>fpga2sdram</b> or <b>fpga2hps</b> </li><li>  Transfer read data to LCD, forming the necessary transactions </li><li>  Enable the CPU to directly access the interface to the LCD </li><li>  Issue the specified FPS </li></ul><br><br><h3>  Description of our LCD </h3><br>  All we need to know about the LCD is how to initialize it and what the write transaction looks like. <br><br>  Initialization will be considered when we get to the driver, and now we will study the transaction. <br>  We will have to implement them both in FPGA (for data transfer) and in the driver (for adjusting the display). <br><br>  <a href="http://www.newhavendisplay.com/app_notes/ILI9341.pdf">ILI9341</a> supports multiple interfaces.  I use a parallel 16-bit interface called 8080 by the name of the Intel processor in which it first appeared.  Here are the signals that are there (the more common name is first indicated, and the name from the datasheet on ILI9341 is shown in brackets): <br><ul><li>  CS (CSX) - chip-select, active level 0. The chip select signal, I have got to the ground. </li><li>  RST (RESX) - reset, active level 0. Reset signal, I have got a GPIO HPS. </li><li>  RS (D / CX) - register select.  If the signal is 0, then a command is issued on the DATA bus, otherwise, the data. </li><li>  WR (WRX) - write strobe.  Strobe entry. </li><li>  RD (RDX) - read strobe.  Strobe reading. </li><li>  DATA (D) - data or command, depending on the RS. </li></ul><br>  The write transaction is extremely simple: <br><div class="spoiler">  <b class="spoiler_title">Write transaction</b> <div class="spoiler_text"><br><img src="https://habrastorage.org/files/6d7/937/2b4/6d79372b41ef4466b460baa19f7753e2.png"><br></div></div><br>  The read transaction is not more difficult, but we will not need it, so we will not consider it. <br><br><h3>  Linux driver </h3><br>  What do we have in the driver? <br><br>  First, the functions for reading / writing FPGA registers.  You can read more about what status control registers are and how to use them, <a href="http://habrahabr.ru/company/metrotek/blog/263005/">see</a> my <a href="https://habrahabr.ru/users/ishevchuk/" class="user_link">ishevchuk</a> colleague‚Äôs <a href="https://habrahabr.ru/users/ishevchuk/" class="user_link">article</a> . <br><div class="spoiler">  <b class="spoiler_title">CSR read / write functions</b> <div class="spoiler_text"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fpga_write_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg, u16 val)</span></span></span><span class="hljs-function"> </span></span>{ iowrite16(val, fpga_regs + <span class="hljs-number"><span class="hljs-number">2</span></span>*reg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> u16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fpga_read_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg)</span></span></span><span class="hljs-function"> </span></span>{ u16 tmp; tmp = ioread16(fpga_regs + <span class="hljs-number"><span class="hljs-number">2</span></span>*reg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fpga_set_bit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> tmp = fpga_read_reg(reg); set_bit(bit, &amp;tmp); fpga_write_reg(reg, tmp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fpga_clear_bit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> tmp = fpga_read_reg(reg); clear_bit(bit, &amp;tmp); fpga_write_reg(reg, tmp); }</code> </pre> </div></div><br>  Secondly, the functions for direct recording in the LCD commands and data.  They will be used to initialize the display. <br>  The functions are absolutely ‚Äúclumsy‚Äù - we simply make the transaction as it is shown in the datasheet (and later in this article). <br><div class="spoiler">  <b class="spoiler_title">LCD data / command write functions</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">static</span></span> void lcd_write_command(u16 val) { /* <span class="hljs-type"><span class="hljs-type">Write</span></span> command code */ fpga_write_reg(<span class="hljs-type"><span class="hljs-type">LCD_DATA_CR</span></span>, val); /* <span class="hljs-type"><span class="hljs-type">WR</span></span> and <span class="hljs-type"><span class="hljs-type">RS</span></span> low, <span class="hljs-type"><span class="hljs-type">RD</span></span> high */ fpga_write_reg(<span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR</span></span>, <span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR_RD</span></span>); ndelay(<span class="hljs-number"><span class="hljs-number">1</span></span>); /* <span class="hljs-type"><span class="hljs-type">RS</span></span> low, <span class="hljs-type"><span class="hljs-type">WR</span></span> and <span class="hljs-type"><span class="hljs-type">RD</span></span> high */ fpga_write_reg(<span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR</span></span>, <span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR_RD</span></span> | <span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR_WR</span></span>); ndelay(<span class="hljs-number"><span class="hljs-number">1</span></span>); /* <span class="hljs-type"><span class="hljs-type">All</span></span> control signals high */ fpga_write_reg(<span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR</span></span>, <span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR_RD</span></span> | <span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR_WR</span></span> | <span class="hljs-type"><span class="hljs-type">LCD_CTRL_CR_RS</span></span>); } static void lcd_write_data(u16 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">) { /* </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Write</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> */ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpga_write_reg</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_DATA_CR</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">); /* </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WR</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">low</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RD</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">and</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RS</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">high</span></span></span><span class="hljs-class"> */ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpga_write_reg</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_RD</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_RS</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ndelay</span></span></span><span class="hljs-class">(1); /* </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">All</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signals</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">high</span></span></span><span class="hljs-class"> */ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpga_write_reg</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_RD</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_RS</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_WR</span></span></span><span class="hljs-class">); }</span></span></code> </pre></div></div><br>  Well and, actually, our simple initialization LCD. <br><div class="spoiler">  <b class="spoiler_title">LCD initialization function</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">static</span></span> void lcd_init(struct fb_info *info) { // <span class="hljs-type"><span class="hljs-type">Clear</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> fpga_write_reg(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_DATA_CR</span></span></span><span class="hljs-class">, 0); // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">All</span></span></span><span class="hljs-class"> control signals high fpga_write_reg(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_RD</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_RS</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LCD_CTRL_CR_WR</span></span></span><span class="hljs-class">); mdelay(100); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_DISPLAY_ON</span></span></span><span class="hljs-class">); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_SLEEP_OUT</span></span></span><span class="hljs-class">); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_INVERTION_OFF</span></span></span><span class="hljs-class">); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_MEM_ACCESS_CTRL</span></span></span><span class="hljs-class">); lcd_write_data(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MY</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MX</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MV</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BGR</span></span></span><span class="hljs-class">); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_PIXEL_FORMAT</span></span></span><span class="hljs-class">); lcd_write_data(0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x0055</span></span></span><span class="hljs-class">); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_COLUMN_ADDR</span></span></span><span class="hljs-class">); lcd_write_data(0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x0000</span></span></span><span class="hljs-class">); lcd_write_data(0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x0000</span></span></span><span class="hljs-class">); lcd_write_data((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DISPLAY_WIDTH</span></span></span><span class="hljs-class">-1) &gt;&gt; 8); lcd_write_data((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DISPLAY_WIDTH</span></span></span><span class="hljs-class">-1) &amp; 0xFF); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_PAGE_ADDR</span></span></span><span class="hljs-class">); lcd_write_data(0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x0000</span></span></span><span class="hljs-class">); lcd_write_data(0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x0000</span></span></span><span class="hljs-class">); lcd_write_data((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DISPLAY_HEIGHT</span></span></span><span class="hljs-class">-1) &gt;&gt; 8); lcd_write_data((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DISPLAY_HEIGHT</span></span></span><span class="hljs-class">-1) &amp; 0xFF); lcd_write_command(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ILI9341_MEM_WRITE</span></span></span><span class="hljs-class">); }</span></span></code> </pre></div></div><br>  Briefly about the commands used. <br><br>  ILI9341_DISPLAY_ON (0x29) and ILI9341_SLEEP_OUT (0x11), although unexpected, turn on the display and take it out of sleep mode. <br><br>  ILI9341_MEM_ACCESS_CTRL (0x36) is the setting for the direction of memory scanning. <br><br>  ILI9341_PIXEL_FORMAT (0x3a) is an image format, we have 16 bits per pixel. <br><br>  ILI9341_COLUMN_ADDR (0x2a) and ILI9341_PAGE_ADDR (0x2b) define the working area of ‚Äã‚Äãour display. <br><br>  ILI9341_MEM_WRITE (0x2c) - this command says that data transactions will follow.  In this case, the current position is set to the initial column and row, which were set, respectively, using ILI9341_COLUMN_ADDR and ILI9341_PAGE_ADDR.  After each transaction, the column will automatically increment by 1. When the column becomes equal to the final one, a transition to the next row will occur.  When both the column and the row become equal to the end position, the position returns to the initial one. <br><br>  Thus, after the ILI9341_MEM_WRITE command, the controller in the FPGA can simply ‚Äúin a circle‚Äù send data from the memory to the LCD without worrying about anything else. <br><br>  The last thing that interests us in the driver is the probe function. <br><div class="spoiler">  <b class="spoiler_title">Driver probe function</b> <div class="spoiler_text"><pre> <code class="hljs rust"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fb_info</span></span></span></span> *info; int ret; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> vmem_size; unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *vmem; dma_addr_t dma_addr; pdev-&gt;dev.dma_mask = &amp;platform_dma_mask; pdev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="hljs-number"><span class="hljs-number">32</span></span>); vmem_size = (etn_fb_var.width * etn_fb_var.height * etn_fb_var.bits_per_pixel) / <span class="hljs-number"><span class="hljs-number">8</span></span>; vmem = dmam_alloc_coherent(&amp;pdev-&gt;dev, vmem_size, &amp;dma_addr, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!vmem) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"FB: dma_alloc_coherent error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } memset(vmem, <span class="hljs-number"><span class="hljs-number">0</span></span>, vmem_size); info = framebuffer_alloc(<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;pdev-&gt;dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!info) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; info-&gt;screen_base = vmem; info-&gt;fbops = &amp;etn_fb_ops; info-&gt;fix = etn_fb_fix; info-&gt;fix.smem_start = dma_addr; info-&gt;fix.smem_len = vmem_size; info-&gt;var = etn_fb_var; info-&gt;flags = FBINFO_DEFAULT; info-&gt;pseudo_palette = &amp;etn_fb_pseudo_palette; <span class="hljs-comment"><span class="hljs-comment">/* Get FPGA registers address */</span></span> fpga_regs = devm_ioremap(&amp;pdev-&gt;dev, FPGA_REGS_BASE, REGSIZE); <span class="hljs-comment"><span class="hljs-comment">/* Disable refreshing */</span></span> fpga_write_reg(LCD_DMA_CR, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd_init(info); set_dma_addr(dma_addr); set_fps(fps); <span class="hljs-comment"><span class="hljs-comment">/* Enable refreshing */</span></span> fpga_set_bit(LCD_DMA_CR, LCD_DMA_CR_REDRAW_EN); ret = register_framebuffer(info); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { framebuffer_release(info); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } platform_set_drvdata(pdev, info); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre></div></div><br>  What is happening in it? <br>  First, we allocate memory in a DMA-compatible zone using the <b>dmam_alloc_coherent ()</b> function.  In this case, we get two addresses that "point" to the selected area.  One will be used in the driver, and the second we will write a FPGA so that the DMA controller can read data from this area. <br><br>  A few words about DMA mappings.  They are of two types: <br><ul><li>  Streaming </li><li>  Matched (Coherent or Consistent) </li></ul><br>  Consistent mappings are available simultaneously to the processor and device.  Upon access, each party is guaranteed to receive ‚Äúfresh‚Äù data.  Most often used when a buffer exists throughout the life of the driver.  An example of use is our framebuffer memory. <br><br>  When using stream mappings, access is possible strictly in turn.  Most often created at the time of a single operation. <br>  Theoretically, it can be more productive.  An example is receiving / sending network packets. <br><br>  Let's go back to the probe function.  Next we fill in <b>fb_info</b> . <br>  Then we map the FPGA address space in order to be able to read and write to the control status registers. <br><br>  After that we write the required FPS value and our DMA-address in the FPGA (remembering to translate it into the word number, if necessary). <br><br>  Then we turn on the drawing in FPGA and register our framebuffer.  All is ready! <br><br><br><h3>  FPGA module </h3><br>  We got to the module in the FPGA.  Here, too, everything is simple. <br>  Let me remind you that we need to implement: <br><ul><li>  Direct CPU access to the LCD </li><li>  Reading framebuffer memory </li><li>  Forming transaction records in the direction of the LCD </li><li>  Getting the right FPS </li></ul><br>  To ensure direct access of the CPU to the LCD, we naturally will use control registers. <br>  And the usual multiplexer - when control comes from the CPU, signals from the registers are switched to the LCD interface, otherwise signals from the module to the FPGA.  The selection occurs depending on the state of the finite state machine, which is described below. <br>  Primitive code: <br><div class="spoiler">  <b class="spoiler_title">LCD bus MUX</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( state == IDLE_S ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lcd_bus_if.data &lt;= lcd_ctrl_if.data; lcd_bus_if.rd &lt;= lcd_ctrl_if.rd; lcd_bus_if.wr &lt;= lcd_ctrl_if.wr; lcd_bus_if.rs &lt;= lcd_ctrl_if.rs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // Send data transactions from FPGA. <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lcd_bus_if.data &lt;= lcd_data_from_fpga; lcd_bus_if.rd &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; lcd_bus_if.wr &lt;= lcd_wr_from_fpga; lcd_bus_if.rs &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre></div></div><br>  The next task is to read the data from the memory and write it to the LCD.  Here you need to think a little. <br>  We cannot continuously read data, since the reading interface's bandwidth is much greater than the speed at which we will write data to the LCD (remember that we need to comply with the timeframes specified in the documentation). <br><br>  That is, we need to artificially limit the speed of reading.  There are the following options for this: <br><ul><li>  Read and write to the LCD in sequence - read, write, read, write, etc. </li><li>  Calculate the speed with which we need to read data, and maintain it </li><li>  Use FIFO </li></ul><br>  The first option will lead to the fact that the data on the LCD will come with large (by the FPGA standards) pauses. <br>  Considering the applied task (we hardly need to get an FPS greater than 50), it is quite possible that this is enough for us. <br>  But it is too clumsy and ugly.  Therefore, this option is dismissed. <br><br>  The second option is to calculate the speed at which data should be read from memory, so that we can get a continuous stream to the LCD.  It is also quite a working option, especially considering that we have no strict requirements for the constancy of the output flow rate.  But, in general, due to the variable latency in read transactions, we would still have to use a buffer for rate matching. <br><br>  The third option is very simple and fairly reliable.  Its essence is that we use a FIFO - a buffer in which we write read data from memory at high speed.  When in the buffer the place comes to an end we suspend reading.  At the same time, we can continuously read data from the buffer and form transactions on the LCD at a constant speed.  As soon as a place appears in the FIFO, we again resume reading from the memory. <br><br>  We choose the third option.  First we need a FIFO: <br><div class="spoiler">  <b class="spoiler_title">FIFO instance</b> <div class="spoiler_text"><pre> <code class="vhdl hljs"> buf_fifo #( .AWIDTH ( FIFO_AWIDTH ), .DWIDTH ( AMM_DATA_W ) ) buf_fifo ( .clock ( clk_i ), .aclr ( ), .wrreq ( fifo_wr_req ), .data ( fifo_wr_data ), .rdreq ( fifo_rd_req ), .q ( fifo_rd_data ), .almost_full ( ), .full ( ), .empty ( fifo_empty ), .usedw ( fifo_usedw ) );</code> </pre></div></div><br>  To determine the moment of suspension of reading it is not enough to know how the FIFO is already filled.  After all, we also have read transactions that are now ‚Äúin progress.‚Äù  That is, the data, the reading of which we have already requested, but which have not yet been delivered to us. <br>  We need to know the number of such transactions at the moment.  To do this, each time a read request is executed, we will increase the corresponding counter, and when we receive confirmation of the read data, decrease it. <br><div class="spoiler">  <b class="spoiler_title">Pending transactions calculation</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">// Count <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> read transactions <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> progress logic [FIFO_AWIDTH-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pending_read_cnt; always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>( { read_req_w, amm_if.read_data_val } ) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b01</span></span>: pending_read_cnt &lt;= pending_read_cnt - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b10</span></span>: pending_read_cnt &lt;= pending_read_cnt + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; endcase</code> </pre></div></div><br>  As a result, we will stop reading when the amount of words and transactions ‚Äúin process‚Äù recorded in the FIFO is almost equal to the depth of our queue.  As ‚Äúalmost‚Äù we will choose 50 free words: <br><div class="spoiler">  <b class="spoiler_title">Stop reading</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">logic stop_reading; assign stop_reading = ( pending_read_cnt + fifo_usedw ) &gt; ( <span class="hljs-number"><span class="hljs-number">2</span></span>**FIFO_AWIDTH - <span class="hljs-symbol"><span class="hljs-symbol">'d50</span></span> );</code> </pre></div></div><br>  Forming read transactions themselves on <b>Avalon MM is</b> primitive.  The main thing is to increment the address correctly depending on the type of interface: <b>fpga2sdram</b> or <b>fpga2hps</b> (for a more detailed description of the interfaces and differences, see <a href="http://habrahabr.ru/company/metrotek/blog/248145/">here</a> ): <br><div class="spoiler">  <b class="spoiler_title">Read transactions</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">// fpga2sdram used word address, so we must added <span class="hljs-number"><span class="hljs-number">1</span></span> every <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>, // fpga2hps used byte address, so we must added <span class="hljs-number"><span class="hljs-number">8</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">bit</span></span> iface). logic [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] addr_incr; assign addr_incr = ( USE_WORD_ADDRESS == <span class="hljs-number"><span class="hljs-number">1</span></span> ) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : ( AMM_DATA_W &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> ); always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( state == IDLE_S ) amm_if.address &lt;= lcd_ctrl_if.dma_addr; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( read_req_w ) amm_if.address &lt;= amm_if.address + addr_incr; // Always read <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> word assign amm_if.byte_enable = '<span class="hljs-number"><span class="hljs-number">1</span></span>; // We don<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> burst now assign amm_if.burst_count = <span class="hljs-number"><span class="hljs-number">1</span></span>; assign amm_if.read = ( state == READ_S ); // Remove Quartus warnings assign amm_if.write_data = '<span class="hljs-number"><span class="hljs-number">0</span></span>; assign amm_if.write = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre></div></div><br>  We learned to read the data, now we need to learn how to write them in LCD.  To do this, we will make a simple finite state machine for two states: if there is data in the FIFO, the automaton changes to the sending transaction state.  And after the end of the recording, it returns to IDLE: <br><div class="spoiler">  <b class="spoiler_title">FSM for writing to LCD</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">enum int <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> { LCD_IDLE_S, LCD_WRITE_S } lcd_state, lcd_next_state; always_ff @( posedge clk_i ) lcd_state &lt;= lcd_next_state; always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lcd_next_state = lcd_state; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>( lcd_state ) LCD_IDLE_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !fifo_empty ) lcd_next_state = LCD_WRITE_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> LCD_WRITE_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( lcd_word_cnt == <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d31</span></span> ) lcd_next_state = LCD_IDLE_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign fifo_rd_req = ( lcd_state == LCD_IDLE_S ) &amp;&amp; ( lcd_next_state == LCD_WRITE_S );</code> </pre></div></div><br>  It must be remembered that one transaction before the LCD is the transmission of 16 bits of data, and each word in the FIFO has a size of 64 bits (depending on the interface settings of fpga2sdram / fpga2hps).  Therefore, for each word read, we will form 4 transactions. <br>  It is simple to form them - for this we only need to make one counter and use the necessary digits in it: <br><div class="spoiler">  <b class="spoiler_title">Read transactions</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">// ILI9341 Data transaction from FPGA: // __ __ __ __ __ __ __ __ __ // clk/<span class="hljs-number"><span class="hljs-number">4</span></span> | __| |__| |__| |__| |__| |__| |__| |__| |__| | // // data | ///&lt; split[<span class="hljs-number"><span class="hljs-number">0</span></span>] | split[<span class="hljs-number"><span class="hljs-number">1</span></span>] | split[<span class="hljs-number"><span class="hljs-number">2</span></span>] | split[<span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;//// // // _______________________________________________ // rd | xxxx xxxx // // _____ _____ _____ _____ // wr | xxxx_____| |_____| |_____| |_____| xxxx // // _______________________________________________ // rs | xxxx xxxx logic [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] fifo_rd_data_split; assign fifo_rd_data_split = fifo_rd_data; logic [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lcd_data_from_fpga; logic lcd_wr_from_fpga; logic [<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] lcd_word_cnt; always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( lcd_state == LCD_IDLE_S ) lcd_word_cnt &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lcd_word_cnt &lt;= lcd_word_cnt + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; assign lcd_data_from_fpga = fifo_rd_data_split[ lcd_word_cnt[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>] ]; assign lcd_wr_from_fpga = ( lcd_state == LCD_IDLE_S ) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : lcd_word_cnt[<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre></div></div><br>  Almost all.  It remains to make the main state machine that will manage all of the above. <br>  The logic of his work is simple - if our LCD controller module is turned on, then one frame needs to be drawn. <br>  To implement a given FPS, there is a ‚Äústate-pause‚Äù in which waiting for the required number of cycles takes place. <br>  After that, reading data from the memory starts (writing to the LCD will start automatically as soon as data appears in the FIFO). <br>  When the entire frame is read, it remains only to wait for the completion of the transactions to the LCD: <br><div class="spoiler">  <b class="spoiler_title">Main FSM</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">logic [<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] word_cnt; always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( state == IDLE_S ) word_cnt &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( read_req_w ) word_cnt &lt;= word_cnt + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; logic reading_is_finished; assign reading_is_finished = ( word_cnt == WORD_IN_FRAME - <span class="hljs-number"><span class="hljs-number">1</span></span> ) &amp;&amp; read_req_w; logic stop_reading; assign stop_reading = ( pending_read_cnt + fifo_usedw ) &gt; ( <span class="hljs-number"><span class="hljs-number">2</span></span>**FIFO_AWIDTH - <span class="hljs-symbol"><span class="hljs-symbol">'d50</span></span> ); logic all_is_finished; assign all_is_finished = ( pending_read_cnt == <span class="hljs-number"><span class="hljs-number">0</span></span> ) &amp;&amp; ( fifo_usedw == <span class="hljs-number"><span class="hljs-number">0</span></span> ) &amp;&amp; ( lcd_state == LCD_IDLE_S ); enum int <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> { IDLE_S, FPS_DELAY_S, READ_S, WAIT_READIND_S, WAIT_WRITING_S } state, next_state; always_ff @( posedge clk_i ) state &lt;= next_state; // FIXME: // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> lcd_ctrl_if.redraw_en == <span class="hljs-number"><span class="hljs-number">1</span></span> // CPU have one takt <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lcd_ctrl_if.dma_busy // Fix: add WAIT_WRITING_S -&gt; FPS_DELAY_S path always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> next_state = state; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>( state ) IDLE_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( lcd_ctrl_if.redraw_stb || lcd_ctrl_if.redraw_en ) next_state = FPS_DELAY_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> FPS_DELAY_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fps_delay_done_w ) next_state = READ_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> READ_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( reading_is_finished ) next_state = WAIT_WRITING_S; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( stop_reading ) next_state = WAIT_READIND_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> WAIT_READIND_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !stop_reading ) next_state = READ_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> WAIT_WRITING_S: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( all_is_finished ) next_state = IDLE_S; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre></div></div><br>  Everything, our LCD controller is ready. <br><br><h3>  U-boot setup </h3><br>  In the <a href="http://habrahabr.ru/company/metrotek/blog/248145/">last article</a> I wrote that the inclusion of the <b>fpga2sdram</b> interface must be done in the <b>U-boot</b> .  Otherwise, during a read transaction, the system will completely freeze.  To do this, add the following lines to the environment: <br><div class="spoiler">  <b class="spoiler_title">u-boot-env.txt</b> <div class="spoiler_text"><pre> <code class="bash hljs">... fpgadata=0x10000000 fpgafile=/lib/firmware/fpga/fpga.rbf fpgaboot=setenv fpga2sdram_handoff 0x3fff; ext2load mmc 0:2 <span class="hljs-variable"><span class="hljs-variable">${fpgadata}</span></span> <span class="hljs-variable"><span class="hljs-variable">${fpgafile}</span></span>; fpga load 0 <span class="hljs-variable"><span class="hljs-variable">${fpgadata}</span></span> <span class="hljs-variable"><span class="hljs-variable">${filesize}</span></span> bridge_enable_handoff=mw <span class="hljs-variable"><span class="hljs-variable">$fpgaintf</span></span> <span class="hljs-variable"><span class="hljs-variable">${fpgaintf_handoff}</span></span>; go <span class="hljs-variable"><span class="hljs-variable">$fpga2sdram_apply</span></span>; mw <span class="hljs-variable"><span class="hljs-variable">$fpga2sdram</span></span> <span class="hljs-variable"><span class="hljs-variable">${fpga2sdram_handoff}</span></span>; mw <span class="hljs-variable"><span class="hljs-variable">$axibridge</span></span> <span class="hljs-variable"><span class="hljs-variable">${axibridge_handoff}</span></span>; mw <span class="hljs-variable"><span class="hljs-variable">$l3remap</span></span> <span class="hljs-variable"><span class="hljs-variable">${l3remap_handoff}</span></span> bootcmd=run fpgaboot; run bridge_enable_handoff; run mmcboot ...</code> </pre></div></div><br><h3>  Debugging </h3><br>  In principle, everything should work without problems, so we have nothing to debug. <br>  But, since we were a bit lazy and did not write a testbench for our FPGA module, then for peace of mind you should look at the work of the module in SignalTap. <br><br>  Here are the transactions from the CPU: <br> <a href=""><img src="https://habrastorage.org/files/ff4/1c1/ef7/ff41c1ef75484d7f8100ac68974d5e45.png"></a> <br><br>  We see a record of commands 0x29, 0x11, 0x36 and data 0xE8.  That's right. <br><br>  And this is what transactions from FPGA look like: <br> <a href=""><img src="https://habrastorage.org/files/63f/8d7/f14/63f8d7f1411b43fd87e0647b77245bd7.png"></a> <br><br>  And here, too, everything is as we planned. <br><br>  Hooray!  We have a LCD controller in FPGA. <br>  Thanks to those who read to the end!  Good luck! <br><br><h3>  useful links </h3><br>  <a href="https://github.com/Des333/soc-fb">Sources on github</a> <br>  <a href="http://metrotek.spb.ru/ethond.html">The device on which all the work was done</a> <br>  <a href="https://www.kernel.org/doc/Documentation/fb/framebuffer.txt">Documentation for writing framebuffer drivers</a> <br>  <a href="http://www.newhavendisplay.com/app_notes/ILI9341.pdf">ILI9341 documentation</a> <br><br><h3>  Comment on previous article </h3><br>  <a href="http://habrahabr.ru/company/metrotek/blog/248145/">In the last article,</a> I measured the bandwidth of the <b>fpga2sdram</b> interface. <br>  Unfortunately, I made a mistake.  Namely, the PLL clock was set to 125 MHz, not 25 MHz, as it really is. <br>  Because of this, the multiplier and divider coefficients for the PLL were calculated incorrectly. <br>  As a result, DDR3 worked at 66 MHz instead of the 333 MHz. <br><br>  With the correct coefficients and interface width of 256 bits, the bandwidth is about 16-17 Gbit / s, which corresponds to the theoretical for the DDR3 interface with a width of 32 bits and a frequency of 333 MHz. <br><br>  I apologize! <br><br><h3>  Small survey </h3><br>  I want to know the opinion of the community.  If not difficult, please vote. </div><p>Source: <a href="https://habr.com/ru/post/263571/">https://habr.com/ru/post/263571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263549/index.html">Multithreaded SOCKS 4 server on Qt</a></li>
<li><a href="../263551/index.html">Quick start with PHPixie 3</a></li>
<li><a href="../263555/index.html">Qucs project news: release candidate available with circuit simulation support in SPICE</a></li>
<li><a href="../263565/index.html">Magic of tensor algebra: Part 13 - SKA Maxima in problems of transforming tensor expressions. Angular velocity and acceleration in the parameters of Rodrigues-Hamilton</a></li>
<li><a href="../263569/index.html">With LINQ on "Life"</a></li>
<li><a href="../263575/index.html">An example of solving a typical OOP problem in the Haskell language</a></li>
<li><a href="../263577/index.html">Competition of the user design from the Roketbank or how to order a bank card with the Habr logo</a></li>
<li><a href="../263581/index.html">Welcome to FPConf.ru</a></li>
<li><a href="../263591/index.html">Review and video of reports on information security from the conference SECR-2014</a></li>
<li><a href="../263595/index.html">When Chef and Puppet are not the solution. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>