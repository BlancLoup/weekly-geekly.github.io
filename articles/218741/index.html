<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RabbitMQ monitoring in Zabbix and hidden features of Zabbix key</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Faced with the task of monitoring a large number of metrics in the RabbitMQ cluster, there was a desire to create a universal parser fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RabbitMQ monitoring in Zabbix and hidden features of Zabbix key</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Faced with the task of monitoring a large number of metrics in the RabbitMQ cluster, there was a desire to create a universal parser for JSON data.  The task was complicated by the fact that metrics appear and disappear dynamically while the cluster is running, plus the developers constantly want to collect / calculate something new.  Unfortunately, in Zabbix there is no possibility to collect data in this form out of the box.  But there is such a handy feature as zabbix_trapper, which allows you to make flexible customization.  The article will talk about not using the standard way of using zabbix_trapper items.  I didn‚Äôt want every time the developers asked to add new metrics, change the script that collects data and sends it to zabbix.  Hence the idea to use the actual zabbix key itself as an instruction for collecting a new metric.  The point is the following, we use the zabbix key as a command, with a predefined syntakis.  That is, the zabbix key in this case will serve as an instruction similar to keys of the zabbix_agent type. <br><a name="habracut"></a><br>  According to the official Zabbix documentation, item key has some restrictions on valid characters.  After playing a bit with the creation of keys like zabbix trapper I found that, for example, a key of the form: <br><br>  <b>some.thing.here [one: two: three] [foo = x, bar = y]</b> <br><br>  are created in zabbiks without errors.  That is, the restrictions only work on the fact that outside [] brackets, at least one [az] [AZ] character must also be in front of the brackets.  Having the ability to create such keys, we can invent our own key syntax and program quite flexible logic in it.  It remains only to write a handler invented syntax that will do all the basic work.  Finally, by writing a dock for this handler and putting the code in public, the entire Zabbix community will have the opportunity to exchange such ‚Äúas if‚Äù plugins. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, the article turned out to be a bit difficult to understand, so in order to better understand the concept, I would advise you first to familiarize yourself with the RabbitMQ API, at least just to see what the data looks like and what the API provides (see off site). <br><br>  References to the code are given at the end of the article. <br><br><h4>  How it works </h4><br>  First we create in Zabbix front-end items of zabbix_trapper type according to the developed syntax (the syntax will be described below).  Next, run the handler (rmq_data_collect.pl - then collector) in the crown with the frequency of collecting information, say 1 minute.  Now the collector interacts with the Zabbix server and the RabbitMQ server as indicated in the diagram: <br><img src="https://habrastorage.org/getpro/habr/post_images/574/ef6/b98/574ef6b983af0d328903a6d53ae21d2c.png"><br>  Those.  The script makes 3 basic steps: <br><br>  1) Requests a list of items from Zabbix server that should be collected. <br>  2) Retrieves all the necessary data from RabbitMQ according to the list of items above. <br>  3) Sends all collected data to Zabbix server / proxy to the corresponding item. <br><br>  When first processed, the handler can interact either via Zabbix API or directly with the database.  In my implementation, the interaction occurs with the Zabbix proxy base.  This approach is more convenient when using distributed monitoring with some Zabbix proxy servers.  In this case, the script must be installed on the zabbix proxy server, and the data for the connection to the database of the same proxy must be specified in the script configuration. <br><br>  In addition to the handler, the disciver will also be considered, which is used for low level discovery.  Next we will talk about the current implementation of monitoring for RabbitMQ, the theory and examples of customization. <br><br><h4>  What is implemented </h4><br>  The RabbitMQ API documentation describes 9 API urls + there is also a federation-links, which is put on a Rebbit by a separate plugin.  Maybe there is something else.  In the current implementation of my scripts, the following API paths can be monitored: <br><br>  -nodes <br>  -connections <br>  -queues <br>  -bindings <br>  -federation-links <br><br>  This was enough for my tasks, in case some other API paths are needed, then you need to add them to map_rmq_elements (see the comments on the code). <br><br><h4>  Install and configure scripts </h4><br>  To monitor RabbitMQ, you need to install and configure 2 scripts (Collector and Discoverer) + ZabbixProxyDB.pm.  Scripts can be installed both on a Zabbix server and on a proxy, depending on your Zabbix configuration. <br><br><h5>  Collector </h5><br>  <i>rmq_data_collect.pl</i> - Used for processing zabbiks keys and collecting data from rabbitmq. <br><br>  <b>Using</b> <br><br>  It has one input parameter. <br><br>  $ 1 is the full name of the RabbitMQ host in Zabbix, if RabbitMQ is not running as a cluster.  In case rebbit works as a cluster, $ 1 is the common part of the host name in the cluster, i.e.  hostnames in a classer must be specified according to a specific rule.  For example, host names in a cluster: <br>  - rmq-host1 <br>  - rmq-host2 <br>  - rmq-host3 <br>  In this case, $ 1 should be ‚Äúrmq-host". The script will request from Zabbix server / proxy a list of all hosts with names containing ‚Äúrmq-host‚Äù, then go through this list, requesting the necessary data to the RabbitMQ API. After the first successful response data from any of the hosts will be collected and written to a file for sending by zabbix_sender. At the time of this writing, there is a flaw in the code if more than one host from the RabbitMQ cluster does not respond, nothing will happen to the current implementation. with SQL query to the database, so far the only way. <br>  The collector must be registered in crontab with a frequency equal to the frequency of data collection from the rebbit.  The list of required modules can be found in the script itself. <br><br><h5>  Discoverer </h5><br>  <i>rmq_data_discover.pl</i> - Used for low-level discovery in Zabbix (low level discovery or LLD). <br><br>  <b>Using</b> <br>  It has 3 required input parameters: <br><br>  $ 1 is the full name of the RabbitMQ host in Zabbix, if RabbitMQ is not running as a cluster.  For a cluster, the principle is the same as that of a collector.  After the first successful response, passing through the list will stop and the message will be compiled for low-level discovery. <br><br>  $ 2 - regexp for which the selection of metrics will occur at the time of the script.  Not to be confused with the regexp filter on the Zabbiks side in the LLD settings.  This separation is convenient in some cases. <br><br>  $ 3 - RabbitMQ API path, any of the list of supported (see p. What is implemented). <br><br>  The script must be installed in the externalscripts folder specified in the Zabbix proxy / server configuration.  Examples of setting up LLD rules are given at the end of the article. <br><br><h6>  Zabbix hosts configuration example </h6><br>  There is a rabbitmq cluster consisting of three hosts.  The hosts themselves are individually monitored by zabbix agents, the Template_Linux template, which contains the standard metrics for CPU, memory, etc.  A separate host ‚Äúrmq-host‚Äù has been created for cluster metrics.  The host name for the entire cluster is the common part of the host names in the cluster.  This is a prerequisite in the current implementation, otherwise sampling from the database will not work correctly. <br><img src="https://habrastorage.org/getpro/habr/post_images/2c0/805/67c/2c080567cecc33abb3d1ac87e24866d8.jpg"><br><br><h4>  Key Syntax </h4><br>  Now let's talk about the Rebbit syntax I developed.  As mentioned above, in Zabbix items should be of type zabbix trapper. <br><br>  To monitor a rebbit, there are two types of item, simple and aggregated, their syntax is slightly different.  Simple items are used to select the values ‚Äã‚Äãof individual parameters.  Aggregated items are used to select an array of values ‚Äã‚Äãfor a given condition and aggregate them.  In both cases, the conditions may not be specified (optional). <br><br><h6>  Simple values </h6><br>  <b>Syntax</b> : &lt;path.to.value.inside.json&gt; [$ type: $ api_path: $ element_name] <br><br>  &lt;path.to.value.inside.json&gt; - The path to the value inside each element of the array. <br><br>  $ type - may be the name of VHOST or ‚Äúgeneral‚Äù, in the case of VHOST, the search for values ‚Äã‚Äãwill be carried out by the specified VHOST, ‚Äúgeneral‚Äù is the keyword necessary for values ‚Äã‚Äãthat do not apply to specific VHOSTs. <br><br>  $ api_path - RabbitMQ API path, any of the supported (see p. What is implemented). <br><br>  $ element_name is the unique identifier of the array element at the specified $ api_path, for federation-links, this is exchange, for bindings this is the destination, for the rest of the name. <br><br><h6>  Aggregated Values </h6><br>  <b>The general syntax is:</b> &lt;path.to.value.inside.json | rmq&gt; [aggregated: $ api_path: $ func] [$ conditions] <br><br>  aggregated - is a keyword, after which the collector (rmq_data_collect.pl) understands that the key syntax should be parsed as for a value of an aggregated type. <br><br>  $ api_path - the path to the API, any of the supported (see p. What is implemented). <br><br>  $ func - 2 functions are implemented, sum and count. <br><br>  $ conditions is an optional parameter; if set, then the aggregation will take into account only those elements in the data array that fit the condition.  The syntax of the conditions is as follows: [condition1 = ‚Äúcond1‚Äù, condition2 = ‚Äúcond2‚Äù, condition3 = ‚Äúcond3‚Äù, etc].  Quotes are required.  The condition itself is Perl regexp. <br><br>  <b>Sum function</b> <br>  Syntax: &lt;path.to.value.inside.json&gt; [aggregated: $ api_path: sum] [$ conditions] <br><br>  The sum function sums the values ‚Äã‚Äãlocated at the specified path &lt;path.to.value.inside.json&gt; inside each element of the array, obtained from $ api_path, and matching the condition $ condition. <br><br>  &lt;path.to.value.inside.json&gt; - The path to the value inside each element of the array obtained by the RabbitMQ API path. <br><br>  <b>Count function</b> <br><br>  Syntax: rmq [aggregated: $ api_path: count] [$ conditions] <br><br>  The count function counts the number of elements in the array obtained from $ api_path that match the condition. <br><br>  rmq - is a mandatory word, but not used at all (there can be absolutely any set of letters).  This is due to the limitations of Zabbix on an item's key of type ‚Äúzabbix_trapper‚Äù - an item cannot begin with a square bracket. <br><br><h4>  Examples </h4><br>  <b>Aggregated values</b> <br><img src="https://habrastorage.org/getpro/habr/post_images/1da/d61/7db/1dad617db10b7b390bc64ecedcece9e0.jpg"><br>  1) It counts the sum of the elements of running in the array of nodes.  Note: In the event that the rabbitmq node is working, running returns 1, respectively, but at the output we get the number of working nodes. <br><br>  2) Count the number of elements in the queues array, where name = ^ system-queue1 $.  Since  The condition value is always treated as regexp. You must set the beginning and end of the line (^ $) to avoid an error if something else falls under the regexp.  At the output we get the number of queues named system-queues1 <br><br>  3) It counts the total number of elements in the array of nodes.  Those.  number of tuned nodes in the claser. <br><br>  4) It counts the total number of elements in the connections array.  Those.  number of connections to the cluster at the moment. <br><br>  5) Count the number of elements in the connections array, for which type = ‚Äú^ direct $‚Äù and protocol = ‚Äú^ Direct \ s0-9-1 $‚Äù. <br><br>  Examples for simple values ‚Äã‚Äãare further in LLD.  Since  it is not convenient to set them statically, most of the queues constantly appear and disappear. <br><br><h4>  Low level discovery </h4><br>  In the case of a large rabbitmq cluster configuration, it is reasonable to use Zabbix low-level detection.  The use of rmq_data_discover.pl is described above.  Here I will give examples and values ‚Äã‚Äãreturned by the script. <br><br>  The values ‚Äã‚Äãreturned by the script and which can be used in LLD: <br><br>  Connections <br><br>  "{#VHOST}" =&gt; $ vhost, <br>  "{#NAME}" =&gt; $ name, <br>  "{#NODE}" =&gt; $ node, <br><br>  Nodes <br><br>  "{#NODENAME}" =&gt; $ name, <br><br>  Bindings <br><br>  "{#SOURCE}" =&gt; $ queueSource, <br>  "{#VHOST}" =&gt; $ vhost, <br>  "{#DESTINATION}" =&gt; $ queueDest, <br>  "{#THRESHOLD}" =&gt; $ threshold, <br><br>  Note: all elements with an empty source are ignored. <br><br>  Queues <br><br>  "{#VHOST}" =&gt; $ vhost, <br>  "{#QUEUE}" =&gt; $ queueName, <br><br>  Federations <br><br>  ‚Äú{#VHOST‚Äù} =&gt; $ vhost, <br>  ‚Äú{#EXCHANGE} =&gt; $ name <br><br><h4>  LLD examples </h4><br>  Examples of running rules for each API path: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/ddd/a21/9ffddda21e8725c991d02b799a4e66f2.jpg"><br><br><h5>  Examples of site prototypes </h5><br>  In the <b>API path queues,</b> we can collect statistics on processed messages, without worrying about the number of queues. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6e/4b4/0c4/c6e4b40c44763180e3b9b20e3fd081cb.jpg"><br><br>  1) The value of the idle_since field.  The only field that has processing inside rmq_data_collector.pl.  As a result, we get a timestamp from which the queue is inactive. <br><br>  2) The ack value inside the message_stats element. <br><br>  3) The remaining values ‚Äã‚Äãwork with message_stats as well as item 2 <br><br><h6>  Example for connections </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/c02/255/f79/c02255f7946802b8de99838c93ae5bfc.jpg"><br><br>  Aytem counts the number of elements in the connections array with the given type, protocol for each {#VHOST}. <br><br><h6>  Example for nodes </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/5ee/729/e63/5ee729e63a9c67013bd8d7bee5880162.jpg"><br><br>  1) Count the number of connections to each node. <br>  2) Returns the value of the running field for each element of the nodes array.  At the output we get the health status of each node. <br><br><h4>  Summarize </h4><br>  I hope it turned out not too confusing.  If something is not clear, I will answer all questions in the comments. <br><br>  The advantage of the described approach in creating custom keys that are specialized for a specific software is obvious.  There is no need to change the code of Zabbix itself.  Already, we can create such plugins, write documentation on them and share ready-made solutions on the Internet.  If we develop the idea of ‚Äã‚Äãcreating customized keys in Zabbix further, then ideally I would like to see it, perhaps, in the form of a new feature.  Having a similar plugin now, when you need to add some sort of new metric on RabbitMQ, you just need to create a corresponding item, as is done for zabbix_agent. <br><br>  Script code here: <a href="https://github.com/mfocuz/zabbix_plugins">github.com/mfocuz/zabbix_plugins</a> </div><p>Source: <a href="https://habr.com/ru/post/218741/">https://habr.com/ru/post/218741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218731/index.html">GWT, Java 8 and Future</a></li>
<li><a href="../218733/index.html">We write REST API on Vert.x. Part 1: Setting Up the Environment</a></li>
<li><a href="../218735/index.html">Experience of using ESPD</a></li>
<li><a href="../218737/index.html">QlikView. Create your first application? ...</a></li>
<li><a href="../218739/index.html">What if there is no Android device at hand? Review of Android emulators</a></li>
<li><a href="../218743/index.html">How to use handlebars</a></li>
<li><a href="../218745/index.html">[video] How to avoid unplanned rollback: analysis of 7 real negotiation situations</a></li>
<li><a href="../218747/index.html">Solar charging for lithium battery</a></li>
<li><a href="../218749/index.html">JoysMaker R2 Black - 3D printer for the inexperienced</a></li>
<li><a href="../218751/index.html">We work asynchronously in PHP or the story of another chat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>