<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Manage growing workloads in Postgres: 5 tips from Instagram</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the number of active Instagram users has steadily increased, Postgres has remained our solid foundation and consistent data store for most user-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Manage growing workloads in Postgres: 5 tips from Instagram</h1><div class="post__text post__text-html js-mediator-article">  Since the number of active Instagram users has steadily increased, Postgres has remained our solid foundation and consistent data store for most user-generated data.  And although less than a year ago we wrote about how we store a large amount of data on Instagram at 90 likes per second, we are now processing more than 10,000 likes per second - and our basic data storage technology has not changed. <br><br>  Over the past two and a half years, we realized a few things and picked up a couple of tools for scaling Postgres and we want to share them - what we would like to know when launching Instagram.  Some of them are specific to Postgres, others are also presented in other databases.  To know how we scale Postgres horizontally, see our <a href="http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram">Sharding and IDs</a> post <a href="http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram">on Instagram</a> <br><br><a name="habracut"></a><br><h4>  1. Partial Indexes </h4><br>  If you often use filters for a specific characteristic in your queries, and this characteristic is presented in a smaller part of the rows of your database, partial indexes can help you a lot. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, when searching for tags on Instagram, we are trying to bring up tags by which many photos can be found.  Although we use technologies such as ElasticSearch for more biased searches in our application, this is the only case where the database does a good job on its own.  Let's take a look at how Postgres works when searching for tags, sorting them by the number of photos: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tags <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'snow%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> media_count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN Limit (cost=1780.73..1780.75 rows=10 width=32) (actual time=215.211..215.228 rows=10 loops=1) -&gt; Sort (cost=1780.73..1819.36 rows=15455 width=32) (actual time=215.209..215.215 rows=10 loops=1) Sort Key: media_count Sort Method: top-N heapsort Memory: 25kB -&gt; Index Scan using tags_search on tags_tag (cost=0.00..1446.75 rows=15455 width=32) (actual time=0.020..162.708 rows=64572 loops=1) Index Cond: (((name)::text ~&gt;=~ 'snow'::text) AND ((name)::text ~&lt;~ 'snox'::text)) Filter: ((name)::text ~~ 'snow%'::text) Total runtime: 215.275 ms (8 rows)</code> </pre> <br>  Notice Postgres has to sort 15 thousand lines to get the right result.  And since tags (for example) are a template with a long tail, we can instead try first to show tags for which there are 100 or more photos, so: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> tags (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> text_pattern_ops) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> media_count &gt;= <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  And our query plan now looks like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tags <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'snow%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> media_count &gt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> media_count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN Limit (cost=224.73..224.75 rows=10 width=32) (actual time=3.088..3.105 rows=10 loops=1) -&gt; Sort (cost=224.73..225.15 rows=169 width=32) (actual time=3.086..3.090 rows=10 loops=1) Sort Key: media_count Sort Method: top-N heapsort Memory: 25kB -&gt; Index Scan using tags_tag_name_idx on tags_tag (cost=0.00..221.07 rows=169 width=32) (actual time=0.021..2.360 rows=924 loops=1) Index Cond: (((name)::text ~&gt;=~ 'snow'::text) AND ((name)::text ~&lt;~ 'snox'::text)) Filter: ((name)::text ~~ 'snow%'::text) Total runtime: 3.137 ms (8 rows)</code> </pre><br>  Note that Postgres should now bypass only 169 lines, which is much faster.  The Postgres query scheduler is also good at calculating constraints - if you later decide that you want to receive only tags for which there are at least 500 photos, i.e.  from a subset of the index - it will still use the correct partial index. <br><br><h4>  2. Functional Indexes (Functional Indexes) </h4><br>  For some of our tables, we need to index rows (for example, 64-character base64 tokens), rather long, in order to create an index on them - this will result in duplication of a large amount of information.  In this case, Postgres functional indexes can be very useful: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> tokens (<span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(token, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>))</code> </pre><br>  Thus, Postgres, using an index, finds a set of records by a prefix, and then filters them, finding the necessary one.  The index at the same time takes up 10 times less space than if we were doing an index on the entire line. <br><br><h4>  3. pg_reorg for compression </h4><br>  After a period of time, Postgres tables may be fragmented on disk (due to Postgres' competitive MVCC model, for example).  Also, most often, the insertion of rows is not in the order in which you want to receive them.  For example, if you frequently request all likes created by a single user, it would be nice if those likes were recorded on disk continuously to minimize searches on the disk. <br><br>  Our solution for this is to use the pg_reorg utility, which performs these steps in the table optimization process: <br><ol><li>  Gets an exclusive lock on the table </li><li>  Creates a temporary table to accumulate changes, and adds a trigger to the source table, which replicates any changes to this temporary table. </li><li>  Makes CREATE TABLE using SELECT FROM ... ORDER BY, which creates a new table in indexed order on disk. </li><li>  Synchronizes changes from the temporary table that occurred after SELECT FROM was run. </li><li>  Switches to the new table </li></ol><br>  There are some features in obtaining locks, etc., but this is a description of the general approach.  We checked this tool and ran a number of tests before running it in production, and we did a lot of reorganizations on hundreds of machines without any problems. <br><br><h4>  4. WAL-E for archiving and WAL backups </h4><br>  We use and contribute to the development of <a href="https://github.com/heroku/WAL-E">WAL-E</a> , the Heroku platform toolkit for the continuous archiving of Postgres WAL (Write-Ahead Log) files.  Using WAL-E greatly simplified our backup and launch process for a new replica database. <br><br>  In essence, WAL-E is a program that archives all WAL files generated by your PG server on Amazon S3 using Postgres archive_command.  These WAL files can be used, in combination with a backup database, to restore the database to any point, starting with this backup.  The combination of normal backups and WAL files gives us the ability to quickly launch a new replica of a read-only or failover slave (replica in case of failure of the main base). <br><br>  We made a simple wrapper script for monitoring duplicate failures when archiving a file, and it <a href="https://gist.github.com/4550560">is available on GitHub</a> . <br><br><h4>  5. Auto-commit mode and asynchronous mode in psycopg2 </h4><br>  After some time, we began to use the more advanced features of psycopg2, the Python driver for Postgres. <br><br>  The first is autocommit mode.  In this mode, psycopg2 does not require BEGIN / COMMIT for any requests; instead, each request is launched in a separate transaction.  This is particularly useful for database query requests, for which the use of transactions does not make sense.  Switching on mode is very simple: <br><br><pre> <code class="python hljs">connection.autocommit = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  This significantly reduced communication between our servers and databases, as well as reduced CPU costs on database machines.  Later, we used the PGBouncer to distribute connections, which allowed connections to return to the pool faster. <br><br>  More details on how this works in Django <a href="http://thebuild.com/blog/2009/11/07/django-postgresql-and-autocommit/">here</a> . <br><br>  Another useful feature in psycopg2 is the ability to register a <a href="http://initd.org/psycopg/docs/advanced.html">wait_callback</a> to call subroutines.  Its use allows you to make parallel requests on several connections at a time, which is useful for requests involving multiple nodes - the socket wakes up and notifies when data is available for processing (we use the Python select module for handling awakenings).  It also works well with co-op multithreaded libraries such as an eventlet or gevent.  An example implementation is <a href="">psycogreen</a> . <br><br>  In general, we are very satisfied with Postgres performance and reliability.  If you are interested in working on one of the largest Postgres assemblies, along with a small team of infrastructure hackers, we are at infrajobs &lt;dog&gt; instagram.com <br><br>  <i>From the translator:</i> <i><br></i>  <i>I ask translation errors and spelling in lichku.</i>  <i>And if you are interested in working on mobile applications in a small, but very proud team, located in St. Petersburg - we are also in touch, and consider proposals!</i> </div><p>Source: <a href="https://habr.com/ru/post/171217/">https://habr.com/ru/post/171217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171203/index.html">What is -1. # IND and -1. # J?</a></li>
<li><a href="../171207/index.html">Main rules of the project manager</a></li>
<li><a href="../171209/index.html">Connect to the TFS service without entering LiveID credentials</a></li>
<li><a href="../171211/index.html">Four-dimensional printing - the materials themselves are collected in the shape you need</a></li>
<li><a href="../171213/index.html">19 ffmpeg commands for every need</a></li>
<li><a href="../171219/index.html">Writing scripts for Cisco AXL</a></li>
<li><a href="../171223/index.html">Roskomnadzor about Spamhaus</a></li>
<li><a href="../171225/index.html">AVCONV - video conversion for video tags HTML5 and the imposition of watermark</a></li>
<li><a href="../171227/index.html">Habraobzor Highscreen Explosion or inexpensive analog Samsung Galaxy 3</a></li>
<li><a href="../171229/index.html">Technology of non-surgical removal of cholesterol deposits. Future is near</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>