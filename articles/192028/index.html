<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[NES] Writing level editor for Prince of Persia. Chapter Three First lines of code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chapter One , Chapter Two , Chapter Three , Chapter Four , Chapter Five , Epilogue 

 Disclaimer 
 The research process is a very entertaining process...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[NES] Writing level editor for Prince of Persia. Chapter Three First lines of code</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/187876/">Chapter One</a> , <a href="http://habrahabr.ru/post/191880/">Chapter Two</a> , <b>Chapter Three</b> , <a href="http://habrahabr.ru/post/192546/">Chapter Four</a> , <a href="http://habrahabr.ru/post/192832/">Chapter Five</a> , <a href="http://habrahabr.ru/post/193406/">Epilogue</a> <br><br><h5>  Disclaimer </h5><br>  The research process is a very entertaining process.  When you scatter the binary porridge that is in the file, it turns out a very slim architecture that is hidden behind the veil of those funny squiggles that are displayed in a hex editor (or even worse - in a text editor).  The approach to the research process does not necessarily have to be accompanied by subtle technologies; sometimes it is easier to break everything up with a hammer and study the fragments.  Well, as in childhood. <br><br><a name="habracut"></a><br><h5>  Open HEX-editor </h5><br>  Jumping between the data stubs, I found that starting at offset 0x18010 in the ROM file, the first room begins to transform when the data changes.  But first, look at the data: <br> <code>E0 E0 E0 01 21 01 21 01 14 14 13 13 21 03 00 14 14 14 14 14 14 14 14 14 0E 03 0B 21 01 14 ...</code> <br>  We can say that these data quite fall under what we assumed earlier.  One can see quite slender rows of duplicate bytes (that is, clearly not a code), and they, by the eye, are not similar to any encrypted data.  Let's first try to carefully change E0 to E1: <br><img src="https://habrastorage.org/storage3/83b/186/726/83b186726dbbb4ac3cac3620498fd5f1.png"><br>  There was a platform that never was. <br>  Adding successively to each byte one by one, we make sure that one byte is responsible for one unit in the room.  Therefore, a data block with a size of 30 bytes is responsible for the room (the room consists of 10x3 blocks). <br>  This could be understood using the debugger, but what makes this or that code difficult to say at once, and what it does afterwards with this data is a rebus.  It is easier (but not safer!) To use the good old ‚Äúspear‚Äù method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Looking around </h6><br>  Since one byte is responsible for one block in a room, it would be nice to understand for which type of block a certain value of byte is responsible.  When searching, it turns out that there are 32 different blocks, some of which draw graphic garbage, and some of them destroy the game.  Once there are 32 blocks, this means that the first 5 bits of the values ‚Äã‚Äãare responsible for the type of block.  Changing the remaining three bits in a byte, we find out that they are responsible for the characteristics of the block.  For example, the value # 04 is a closed grille, and # 24 is an open. <br>  And finally, if we iterate through the bytes outside of this 30-byte block, make sure that other rooms change.  Here, however, the order of the rooms is some kind of chaotic.  The same chaotic order was when we changed the unit in another data block earlier and the prince appeared in one room, then in another.  We didn‚Äôt succeed in biting us then. <br><br>  Consider that block closer.  We recall that the displacement of that block is 0x18340 and go to it.  We put a two instead of one and the prince jumps to another room.  Let's try to find this room by editing the data in the previous block.  Looking over it, we find out that this is the next 30 bytes after the first 30-byte block responsible for the first room.  Therefore, that one is the room number.  And the room number is the 30-byte block number.  Well, then the rooms are numbered, and numbered from one. <br><br>  Well, now we know that our rooms have a serial number, which means that this serial number is stored somewhere in the memory.  While we do not need to look for him, but remember for the future. <br><br>  At the moment we know that there is an indefinite size data array from which rooms are built.  Each room is described by a block of 30 bytes.  After the rooms there is a certain data structure with an indefinite size.  Let's call it the ‚Äúheader‚Äù of the level.  And after ... Actually, how do you know what goes next?  Turn to what we already know. <br><br><h6>  We arrange the rooms </h6><br>  Let's try to calculate how many rooms we fit between the beginning and the ‚Äúheading‚Äù, considering that one room is 30 bytes in this array: <br>  <code>0x182E9 - 0x18010 + 1 = 0x2DA = 730 </code> . <br>  30 is not divisible.  Dead end?  As if not so.  Let's try to make a level map with room numbers.  We can do this for now only by moving the prince by changing the first byte of the ‚Äúheader‚Äù.  By successively moving it from room to room, we find that it either ends up in another room, or the game does not start at all.  Exclude numbers that fail, and the rest will be placed in accordance with their position in the game: <br><img src="https://habrastorage.org/storage3/dc8/a9b/cf9/dc8a9bcf96ee38db93c8f39fd8273360.png"><br>  It is difficult to say what the developers were guided by, but if you do not rely on the numbers, the scheme is quite plausible. <br><br>  Let's try to compare these rooms with what we have in our array.  From 1 to 12 rooms we have on the scheme, but 13 (and then 18 and 24) is missing.  We consider its offset: <code>0x18010 + 12( )*30( ) = 0x18010 + 0x168 = 0x18178</code> . <br>  Turn and see: <br> <code>FF 14 14 14 E1 03...</code> <br>  #FF?  And then what comes next?  We go to room 14 and see that in it in the upper left corner there are 3 "concrete" blocks, then a platform, and then a column.  It is very similar to the fact that the first three "concrete" blocks of the fourteenth room are described by numbers # 14, the platform is # E1, and the column is # 03.  Consequently, for #FF there is already a description of room No. 14, and room No. 13 itself has been reduced to one byte, #FF.  It looks like #FF is a kind of marker, meaning that the room is missing.  The situation is similar for both 18 and 24 rooms. <br>  But numbers 25 and higher, apparently, no longer exist, since after the #FF marker, which tells us that room 24 is not present, there is a set of data that doesn‚Äôt look like the previous ones: <br> <code>05 00 00 02 06 03 01 00 02 09 00 00...</code> <br>  You can, of course, play around with these numbers, but let's look at our scheme. <br><br><ul><li>  The first room is surrounded by rooms 05 and 02; </li><li>  The second room is surrounded by rooms 06, 01 and 03; </li><li>  The third room is surrounded by rooms 02 and 09; </li><li>  ... </li></ul><br>  The same numbers appear in the found array.  Let's try to guess. <br><ul><li>  To the left of the first room is the fifth; </li><li>  To the left of the second - the sixth; </li><li>  To the left of the third - the second; </li></ul><br>  It can be seen that the numbers 5, 6 and 2 stand on a multiple of 4 places.  So, the environment of one room is described by a four-byte structure, the first of which is the room number on the left.  Based on the level map, it can be seen that the remaining three bytes describe the rooms on the right, above and below.  Moreover, if there is no room, then there will be 0 at the appropriate place. The number of these structures is exactly 24, after which the ‚Äúheading‚Äù of the level begins.  If so, then we can build a maximum of 24 rooms (then, by studying the code, we will be convinced of this). <br><br><h6>  We call the guard! </h6><br>  Last time, we found an array of pointers to some data structures, which we called "headers."  Moreover, when reading the array, a doubled sequence number of the level was used as an index.  So the next two bytes in this array are a pointer to the same structure, but of the second level.  We study and its: <br>  Array of pointers: <code>D9 82 61 86 91 89 ...</code> <br><ul><li>  First level: <code>D9 82</code> -&gt; <code>$82D9</code> -&gt; offset in the file <code>0x182E9</code> ; </li><li>  Second level: <code>61 86</code> -&gt; <code>$8661</code> -&gt; offset in the file <code>0x18671</code> ; </li><li>  ... </li></ul><br>  We meet there the following data: <br>  <code>05 0D FF 1E 9E ...</code> (funny, here too, after the first three bytes, the numbers ending in 0x0E again go) <br><br>  Here is the first number # 05, so the prince starts in the room with the sequence number 5. But the next two bytes are no longer zeros. <br>  If you play with them, we find out that # 0D is the position of the prince in the room.  The total possible positions are 10x3 = 30, where 10 is the width of the room, which means # 0D = 13 is the position 3x1, that is, it will be in the place of the fourth block on the left and in the place of the second one from the top.  The next byte with the value #FF is its direction: if #FF, it will turn around and look to the left, if not #FF, then it will remain to look to the right.  The only strange thing is that in the first level he does not change his position.  But we will find out later. <br><br>  Let's see what follows the first three bytes. <br>  As we remember, in the first level, when the first byte was changed, a guard appeared in the room.  So these numbers are somehow responsible for the presence of the guard in the room. <br><br>  Let's go back to the first level and write # 02 (as last time) to the fourth field.  The guard appeared very close to the prince.  We put # 03.  Appeared, but already far away.  Looking through the values ‚Äã‚Äãdown to # 1D, we make sure that this byte is responsible for the position of the guard.  But when we put 0x1E it disappears.  But 0x1E = 30 in the decimal representation, which means that if we set the limit value of the position, this will mean that there is no guard in the room.  Apparently, the remaining bytes are responsible for the guards in other rooms.  That is, the next byte is responsible for the presence of the guard in the second room, then in the third, and so on.  However, this is confirmed by a simple check.  Also, by checking it turns out that only the first 5 bits of the values ‚Äã‚Äãare responsible for the position of the guard, the remaining 3 bits are not used, no matter how we twist them. <br><br><h6>  Putting it all together: Builders, architects and guards </h6><br>  So we have the following data structures: <br><ul><li>  "Bricks" of which rooms are built.  The structure of an unfixed value; </li><li>  The layout of the rooms.  Fixed in length (4x24 bytes); </li><li>  A small structure that describes how and where the prince will appear (3 bytes) - the ‚Äúheader‚Äù of the level; </li><li>  A structure describing the location of the guards by room (24 bytes). </li></ul><br>  But after all, what's inconvenient: the pointer that we have (from the array of pointers) leads us to the ‚Äútitle‚Äù, which means we will have to count the beginning of the level shift.  Let's take a look at the debugger and see how it is considered. <br>  We know that our beginning is at offset 0x18010, which means it will be in memory right at $ 8000.  But we have several banks, so we will track only the right one.  We will not count its number, we will simply tell the debugger that we are interested in reading at $ 8000, with the first byte being equal to # E0 (the first block in the first room of the first level): <br><img src="https://habrastorage.org/storage3/e99/1a3/ac6/e991a3ac63abaff5f6c08c517abf87a9.png"><br><br>  The first stop hi to us to the procedure: <br><pre> <code class="hljs mel">$C0F6:<span class="hljs-number"><span class="hljs-number">20</span></span> C7 C0 JSR $C0C7 $C0F9:A5 <span class="hljs-number"><span class="hljs-number">52</span></span> LDA $0052 = #$00 $C0FB:<span class="hljs-number"><span class="hljs-number">18</span></span> CLC $C0FC:<span class="hljs-number"><span class="hljs-number">65</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>D ADC $006D = #$00 $C0FE:<span class="hljs-number"><span class="hljs-number">85</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>E STA $000E = #$00 $C100:A5 <span class="hljs-number"><span class="hljs-number">53</span></span> LDA $0053 = #$00 $C102:<span class="hljs-number"><span class="hljs-number">65</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>E ADC $006E = #$80 $C104:<span class="hljs-number"><span class="hljs-number">85</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>F STA $000F = #$80 $C106:<span class="hljs-number"><span class="hljs-number">8</span></span>C <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-number"><span class="hljs-number">04</span></span> STY $040B = #$03 $C109:A0 <span class="hljs-number"><span class="hljs-number">00</span></span> LDY #$00 $C10B:B1 <span class="hljs-number"><span class="hljs-number">0</span></span>E LDA ($0E),Y @ $8000 = #$E0 ;; &lt;&lt;&lt;&lt;&lt;  $C10D:AC <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-number"><span class="hljs-number">04</span></span> LDY $040B = #$03 $C110:<span class="hljs-number"><span class="hljs-number">60</span></span> RTS</code> </pre><br><br>  In cells $ 0E: $ 0F we have the address $ 8000.  He got there from familiar $ 6D cells: $ 6E, to which values ‚Äã‚Äãfrom $ 52 and $ 53 cells were added.  In cells $ 52, $ 53 are now zeros, so we are interested, as in $ 6D: $ 6E are numbers # 00 and # 80. <br>  At the very beginning of the procedure, we see a call to another procedure at $ C0C7.  We climb there: <br><pre> <code class="hljs mel">$C0C7:<span class="hljs-number"><span class="hljs-number">20</span></span> D5 C0 JSR $C0D5 $C0CA:BD <span class="hljs-number"><span class="hljs-number">3</span></span>A EB LDA $EB3A,X @ $EB3A = #$00 $C0CD:<span class="hljs-number"><span class="hljs-number">85</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>D STA $006D = #$00 $C0CF:BD <span class="hljs-number"><span class="hljs-number">3</span></span>B EB LDA $EB3B,X @ $EB3B = #$80 $C0D2:<span class="hljs-number"><span class="hljs-number">85</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>E STA $006E = #$80 $C0D4:<span class="hljs-number"><span class="hljs-number">60</span></span> RTS</code> </pre><br><br>  At the beginning we see the call to the familiar procedure sub_C0D5 (which returns to us in the X register the doubled ordinal level number), and then the reading from the last bank.  We consider the rule we developed: <code>$EB3A+0x10010=0x1EB4A</code> <br><br>  We look: <br> <code>00 80 31 83 9B 86 C1 89 ...</code> <br>  For sure.  Pointers to our "bricks".  If we climb in the vicinity of this code, we will see three similar procedures - they go almost one after the other.  We have seen two of them, and the third (0x1EB82) refers to an array that leads to the room layout structure. <br><br>  Like everyone collected?  As if not so. <br><br><h6>  Open the door </h6><br>  In principle, we can rebuild the level from the foundation and up to the roof, but what about the bars?  They also need to be able to manage.  Let's try to study their behavior. <br><br>  We place the prince in room number 5, since there are two lattices in it at once and as many as three buttons.  One of them closes the lattice, and the other two - open.  Then I had a stupor: how could I link the buttons with the bars, being a developer? <br><img src="http://habrastorage.org/storage3/fc1/ff8/fc8/fc1ff8fc8e662101c3ee7a2b8075b543.png"><br><br>  To begin with, what we can do now is to move a button or a grid and look at the effect. <br>  The first lattice after moving has ceased to open.  The button when moving also stopped working.  But if you swap two buttons (‚Äúhigh‚Äù and ‚Äúlow‚Äù), then the ‚Äúlow‚Äù button (in the image it is two positions to the left of the ‚Äúhigh‚Äù on which the prince stands, is not visible) began to open, and ‚Äúhigh ¬ªClose.  So, the positions (as before, we will be counting from zero, and the rooms from one) of the buttons and grids are uniquely connected, but how?  I wrote down these positions in the bar and got this label: <br> <code>Button Room - Button Position : Door Room - Door Position</code> <br>  <code>05 - 02 : 05 - 09</code> - the ‚Äúlow‚Äù button closes the second grid. <br>  <code>05 - 04 : 05 - 05 + 05 - 09</code> - the first ‚Äúhigh‚Äù button opens both grids. <br>  <code>05 - 08 : 05 - 09</code> - the second ‚Äúhigh‚Äù button opens only the second grid. <br><br>  Reflecting on this table, I somehow mechanically climbed into the HEX-editor and decided to look again at the ‚Äúheading‚Äù of the level.  Contrary to my expectations, after the end of the array, placing the rooms of the guards, did not begin the second level, but an array of some more data.  The second level began immediately after them. <br> <code>05 02 01 05 09 05 04 00 05 09 05 04 00 05 05 05 08 00 05 09 ...</code> <br>  The bytes almost exactly repeated my entries in the table, only instead of a colon there were either 00 or 01. Considering that, opposite the first record, I have the word ‚Äúcloses‚Äù, and opposite the others ‚Äúopens‚Äù, it is easy to see that 00 says that in this bundle the grating will open, and 01 - close.  The audit showed that it is so.  Now we have also found the mechanics responsible for the door opening mechanism. <br><br><h5>  Editor </h5><br>  Well, the editor is almost ready?  It is enough to take three offsets, define from them pointers to three structures (Rooms, level geometry and "header") and display in the editor.  As if not so. <br><br>  The algorithm for placing rooms is quite simple: starting from the initial room, we ‚Äúinterrogate‚Äù recursively the neighboring rooms, placing them on a coordinate grid.  The first room we will have is at (0,0), the room on the left is at (-1, 0), the bottom room is at (0, 1), and so on.  Then we take the ‚Äúmost negative‚Äù coordinates X and Y, and add their absolute values ‚Äã‚Äãto the coordinates of all the rooms.  Thus, we get a map of the entire level. <br><br>  Everything is fine, but at the 10th level, the algorithm throws an exception: they say that room No. 1 refers to room No. 3, and room No. 3, in turn, refers to 00, which means that there are no rooms above it.  In the game, we also can‚Äôt get ‚Äúunder‚Äù room number 1 (level 10 begins with it). <br>  Approximately sketching room number 3, it became clear that this is the very starting room with which the game begins.  In it, we are offered to go to the right and start the game again, or to the left, where we type the password and get to the appropriate level. <br>  Room number 3 has a neighbor - room number 12.  And yes, there is a bottle and an exit door in it. <br><br>  Thus, it will be enough for us in the editor to take into account these rooms, and to draw the level map. <br><br><h5>  nesprinted </h5><br>  We came close to writing the editor.  We have almost everything to do construction.  We can only figure out how to convert the dungeon in the palace and vice versa.  We are able to change the appearance, but not the color yet. <br><br>  I have not thought about the name of the editor for a long time: there is PrincEd, which is for the DOS version, and we have NESPrincEd, which is for the NES version. <br>  At this stage, I thought that now it was enough to write a shell and the editor was ready.  How then was I mistaken ... And in the fourth chapter, which is called "He himself runs!"  Or a skeleton in the closet ‚Äù, we will see this. </div><p>Source: <a href="https://habr.com/ru/post/192028/">https://habr.com/ru/post/192028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../192014/index.html">Facebook attacks generate $ 200 million in profits for attackers every year</a></li>
<li><a href="../192016/index.html">The Chinese offer 10TB for everyone</a></li>
<li><a href="../192020/index.html">The fs module interface from the Node.js API is partially ported to browser (client) JavaScript</a></li>
<li><a href="../192022/index.html">Attachment of the link layer ARP-spoofing and how to protect the Cisco switch</a></li>
<li><a href="../192024/index.html">A quick note about utf-8 in Mojolicious</a></li>
<li><a href="../192036/index.html">MS Lync 2013 integration with Aastra MX-ONE 5.0 (Direct SIP)</a></li>
<li><a href="../192038/index.html">About prime numbers, cryptography and brain damage</a></li>
<li><a href="../192044/index.html">GPSS-WORLD basics of simulation using live examples</a></li>
<li><a href="../192046/index.html">Examine deep packet inspection from RETN</a></li>
<li><a href="../192048/index.html">iPhone, meet Haskell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>