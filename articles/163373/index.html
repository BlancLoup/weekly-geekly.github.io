<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Its game with JavaScript and Canvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not long ago, I was curious how tolerably modern browsers support HTML5 and I have not found the best 
 Ways to write the simplest 2D platformer. In a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Its game with JavaScript and Canvas</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d96/b35/156/d96b351565a2abcbfcbfe3b2d9795a9c.png" align="left" alt="image">  Not long ago, I was curious how tolerably modern browsers support HTML5 and I have not found the best <br>  Ways to write the simplest 2D platformer.  In addition to the pleasure of developing toys and improving skills in the use of JavaScript, during the <s>entertainment of</s> painstaking work, a certain amount of experience was gained and the main rakes were found empirically, many of which I had to step on.  In this article I will try to briefly and with examples summarize what I learned from my work.  Those wishing to create their own high-performance JavaScript application that effectively works with graphics, please under the cat. <br><a name="habracut"></a><br><h4>  General remarks </h4><br>  JavaScript code is very critical to platform resources.  Despite the fact that almost all modern engines have ceased to interpret the JS code stupidly, the speed of its execution is still very much inferior to the speed of the ‚Äúnative‚Äù code.  Meanwhile, even the simplest game is a lot of code that should have time to execute between rendering two adjacent animation frames.  In addition, JS is a very specific language and writing a bulk code on it is associated with a number of difficulties.  Taken together, this can cause the JS application to stop meeting expectations and quickly <a href="http://habrahabr.ru/post/151337/">bring disappointment</a> .  I will try to systematize a little the conclusions to which I arrived through experiments. <br><br><h5>  1. Compatibility </h5>  If we decided to use HTML5 and Canvas in particular, then let us no longer be concerned about compatibility with old browsers - under them still will not work.  Thus, you can safely use the basic innovations of ECMAScript 5. On the other hand, do not offend the contempt of the good old users of software, like IE6.  It is advisable to notify them of the reasons why they see a gray square as a <s>figure</s> , instead of our wonderful animation.  Make it simple, it‚Äôs enough to diagnose support for Canvas and used language constructs. <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"gameArea"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"color:red"</span></span></span><span class="hljs-tag">&gt;</span></span>Your browser doesn't support HTML5 Canvas.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> (</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>)</span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">if</span></span></span><span class="javascript">(</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">typeof</span></span></span><span class="javascript"> ({}.__defineGetter__) != </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"function"</span></span></span><span class="javascript"> &amp;&amp; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">typeof</span></span></span><span class="javascript"> (</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Object</span></span></span><span class="javascript">.defineProperty) != </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"function"</span></span></span><span class="javascript">) alert(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"Your browser doesn't support latest JavaScript version."</span></span></span><span class="javascript">);})() </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Everything is good, but the trouble is that the problems of cross-browser compatibility are not completely exhausted.  Among modern browsers there is no consensus about the names of standard functions.  The solution is either to refuse to use them altogether, or to make expensive adapters.  For example, I could not deny myself the use of property descriptors and this had its negative consequences.  How to use them cross-browser is well described <a href="http://habrahabr.ru/post/117803/">here</a> and <a href="http://habrahabr.ru/post/108295/">here</a> .  But how to get them to work quickly remains a mystery. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  2. Code optimization is easy to break </h5>  Not so long ago, a very useful article about <a href="http://habrahabr.ru/post/154537/">the V8 engine for Chromium</a> jumped on Habr√©.  The most important thing that I was able to learn is the hidden classes and code optimization for working with them.  Indeed, JS often provokes a change in the structure of an object after its construction.  You should not do this if the goal is to create fast and easily supported code.  As soon as I realized this, the work on the game went more fun, and the code became cleaner and faster. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> myObject(); mo.id = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    //     . var v; v = 12; //,  var v = 12; v = ‚Äú12‚Äù; //  ,        var v = 15; //  ,     </span></span></code> </pre><br>  You also need to strive to reduce the scope of the variable to the minimum - this increases the likelihood of code optimization. <br><br><h5>  3. In JS, there are no classes, inheritance, or other class-oriented programming. </h5>  You should not strain the engine with the implementation of classes using prototyping - the benefit is doubtful, and the code slows down several times (Opera)!  Complicated prototypical inheritance and honestly organized transfer of the basic functionality to the heirs are brought down by the already not the best optimization. <br><br><h5>  4. Pay for using </h5>  In the course of developing a game or any other resource-intensive application, inevitably you have to cache ‚Äúexpensive‚Äù resources, for example, pre-calculated animations or dynamically loaded scripts.  Any resource has a lifetime, after which it is not needed.  And here it is important to get rid of it correctly. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resCache = { <span class="hljs-attr"><span class="hljs-attr">res1</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> getCostlyResource() }<span class="hljs-comment"><span class="hljs-comment">//      resCache.res1 = null;</span></span></code> </pre><br>  Most likely, the memory will not be freed by the garbage collector (GC).  It will be collected at an arbitrary point in time, and it will turn out to be the most inappropriate, because GC will try to remove all the garbage that has accumulated by that moment.  This is better: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> resCache.res1; resCache.res1 = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  At first glance - nothing complicated, but in more complex cases, nuances appear, and the behavior of delete is <a href="http://habrahabr.ru/post/150723/">not always obvious</a> . <br><br><h5>  5. Closures and properties are enemies of speed </h5>  Closures are a basic feature of a functional language.  It seems that this particular place should be optimized as much as possible with the JS engine.  But, practice shows that it is not.  Here is a <b><a href="http://gasizdat.ru/projects/game2/h.html">small test</a></b> that compares the speed of various ways to access object data ( <a href="">test code</a> ). <br>  Result for different browsers and platforms (ms): <br><table><tbody><tr><th>  Windows XP (x86), Core 2 Duo, 3 GHz </th><th>  Opera 12 </th><th>  Firefox 17 </th><th>  Chrome 23 </th></tr><tr><td>  No closures, direct access to object fields </td><td>  9 </td><td>  6 </td><td>  17 </td></tr><tr><td>  No closures, data access via methods </td><td>  sixteen </td><td>  eleven </td><td>  28 </td></tr><tr><td>  Closures, access via methods </td><td>  34 </td><td>  12 </td><td>  23 </td></tr><tr><td>  Closures, access through properties </td><td>  387 </td><td>  899 </td><td>  489 </td></tr></tbody></table><table><tbody><tr><th>  Windows 7 (x64), Core i3-2100, 3.1 GHz </th><th>  Opera 12 </th><th>  Chrome 23 </th><th>  IE 10 </th></tr><tr><td>  No closures, direct access to object fields </td><td>  7 </td><td>  five </td><td>  15 </td></tr><tr><td>  No closures, data access via methods </td><td>  13 </td><td>  eleven </td><td>  13 </td></tr><tr><td>  Closures, access via methods </td><td>  27 </td><td>  9 </td><td>  14 </td></tr><tr><td>  Closures, access through properties </td><td>  222 </td><td>  315 </td><td>  99 </td></tr></tbody></table>  Surprisingly, Opera looks better in the test.  Unfortunately, the overall conclusion is disappointing, closures are optimized only in Chrome, and access through properties is a great luxury that can slow down the application by an order of magnitude. <br><br><h4>  Notes on the graphics engine </h4><br>  Programming graphics in JavaScript is a separate large topic that I can touch on later if there is a demand.  Here I tried to highlight a few simple tricks that were easy to use and they gave a good result. <br><br><h5>  1. Frame by frame animation. </h5>  There are two approaches to creating animations: event and frame by frame.  The first one is suitable mainly for simple tasks, like the button illumination when hovering the mouse, and can be executed in the corresponding handlers.  The second is suitable for performing complex animation tasks that must ‚Äúlive their own lives‚Äù, regardless of user actions, for example, dynamic games. <br>  When creating a game, the easiest way (and cheaper in terms of computing resources) is to rely on the gameplay, relying on frame rate stability.  You can try to use <a href="https://developer.mozilla.org/ru/docs/DOM/window.requestAnimationFrame">the frame request animation</a> from those browsers that support it.  This is not so easy to do, because this method has become the de facto standard and for some reason did not fall into ECMAScript 5. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> raf = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.requestAnimationFrame || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.msRequestAnimationFrame || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.mozRequestAnimationFrame || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitRequestAnimationFrame; <span class="hljs-comment"><span class="hljs-comment">//     : var myRedrawFunc = function () { /*     */ raf(myRedrawFunc) } raf(myRedrawFunc);</span></span></code> </pre><br>  The benefit of RequestAnimationFrame is mainly that when the animation is not loaded (when the rendering process itself takes less than half the frame time), it allows for greater smoothness of animation and reduces resource consumption on mobile platforms.  But in reality this may not be the case.  To the inconvenience of its use can be attributed to a fixed frame rate (60 fps) and the lack of compensation for the duration of the next frame, if the previous one was delayed. <br>  However, what to do if raf === null?  This can happen if your application falls into the hands of Opera, which traditionally goes its own way.  Then the good old setTimeout will help us.  As a result, the code will look something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fps = <span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frameTimeCorrection = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastFrameTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> to = <span class="hljs-number"><span class="hljs-number">1000</span></span>/fps; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myRedrawFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now_time = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); frameTimeCorrection += now_time - lastFrameTime - to; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(frameTimeCorrection &gt;= to) frameTimeCorrection = to - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   lastFrameTime = now_time; if(raf) raf(redrawFunc); else setTimeout(myRedrawFunc, to - frameTimeCorrection); }; myRedrawFunc ();</span></span></code> </pre> <br>  The disadvantage of this approach is obvious - if the frame calculation will slow down more than can be adjusted - the game process will cease to be calculated in real time.  But you can go to the trick.  As a rule, the cause of the brakes is the drawing of elements of the next frame, since  for the browser engine this is an invoice operation.  Therefore, you can write the code so that when the time correction does not cope (the condition if (frameTimeCorrection&gt; = to) works), in the next frame you can only calculate the game world without redrawing it.  There will be so-called.  " <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B0%25D0%25B3_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B3)">Lag</a> " which in the game looks less annoying than slow motion. <br><br><h5>  2. Draw only what is visible on the canvas. </h5>  The most simple and proven over the years the way of animation - <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B9%25D1%2582_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0)">sprites</a> .  The peculiarity of this method lies in the fact that in order to create the illusion of movement, the sprites move in the game space by changing the coordinates of their rendering.  As a rule, the gaming space significantly exceeds the size of the frame rendering area and if the gaming space is large and the sprites draw a lot of time, they will take a lot of time.  The context methods of the canvas are elements of the DOM, and accessing them is very expensive.  One of the optimizations is to draw only what is visible in the frame.  In the <b><a href="http://gasizdat.ru/projects/game2/h.html">above test</a></b> , initially 9000 ‚Äúsmart‚Äù sprites are created and displayed on the canvas, which, when redrawing, monitor their coordinates, and do not use canvas methods if they are out of frame.  Then 9000 ‚Äúsilly‚Äù sprites are created that don't follow the scope ( <a href="">test code</a> ). <br>  Test results (fps): <br><table><tbody><tr><th>  Windows XP (x86), Core 2 Duo, 3 GHz </th><th>  Opera 12 </th><th>  Firefox 17 </th><th>  Chrome 23 </th></tr><tr><td>  Smart Sprites </td><td>  47 </td><td>  35 </td><td>  25 </td></tr><tr><td>  "Stupid" sprites </td><td>  15 </td><td>  14 </td><td>  12 </td></tr></tbody></table><table><tbody><tr><th>  Windows 7 (x64), Core i3-2100, 3.1 GHz </th><th>  Opera 12 </th><th>  Chrome 23 </th><th>  IE 10 </th></tr><tr><td>  Smart Sprites </td><td>  56 </td><td>  32 </td><td>  61 </td></tr><tr><td>  "Stupid" sprites </td><td>  nineteen </td><td>  15 </td><td>  51 </td></tr></tbody></table>  The difference is palpable (and Chrome <s>oh</s> again let us down - the myth has been debunked). <br><br><h5>  3. We cache <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">rasterization</a> </h5>  Rasterization by means of the graphic engine is a rather resource-intensive occupation.  Therefore, an important optimization is caching the rasterization results in memory.  The easiest way is to create a separate outline and rasterize vector graphics in it.  Remember the pointer to it in the cache and in the main drawing area display the memorized result.  For illustration, take the rasterization of 1000 text sprites.  In <b><a href="http://gasizdat.ru/projects/game2/h.html">the performance test</a></b> , 800 text sprites are drawn alternately at intervals of 20 seconds.  First with caching the result of rasterization, then without caching ( <a href="">test code</a> ). <br>  Test results (fps): <table><tbody><tr><th>  Windows XP (x86), Core 2 Duo, 3 GHz </th><th>  Opera 12 </th><th>  Firefox 17 </th><th>  Chrome 23 </th></tr><tr><td>  Rasterization caching </td><td>  23 </td><td>  32 </td><td>  60 </td></tr><tr><td>  No caching </td><td>  five </td><td>  12 </td><td>  47 </td></tr></tbody></table><table><tbody><tr><th>  Windows 7 (x64), Core i3-2100, 3.1 GHz </th><th>  Opera 12 </th><th>  Chrome 23 </th><th>  IE 10 </th></tr><tr><td>  Rasterization caching </td><td>  33 </td><td>  61 </td><td>  61 </td></tr><tr><td>  No caching </td><td>  five </td><td>  56 </td><td>  23 </td></tr></tbody></table>  With this approach, it is important to maintain a balance between memory, cache reset rate and rasterization speed.  So, if the text changes dynamically and rather intensively (say, once in 10 animation frames), then its caching can only worsen the overall performance, since  the caching operation itself will incur more overhead than rasterization. <br><br><h5>  4. Dynamic resource loading </h5>  If the animation is based on bitmap sprites, then before you can draw them on the canvas, you should load these same maps into the browser's image cache.  To do this, it is enough to create an Image element and transfer the url of the image resource as a source.  The difficulty is to wait for the moment when the browser loads the image into its cache.  To do this, you can use the onload event, in which, increment the counter of already loaded images.  As soon as the value of this counter matches the number of pictures added to the download, the resource will become persistent, and we can execute the basic game code. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _imgs = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _addedImageCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _loadedImgsCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addSpriteSource = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); img.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ _loadedImgsCount++; }; img.src = src; _imgs[src] = img; _addedImageCount++; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getLoadedImagePc() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _loadedImgsCount * <span class="hljs-number"><span class="hljs-number">100</span></span> / _addedImageCount; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getImage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _imgs[src]; } } <span class="hljs-comment"><span class="hljs-comment">//  Cache.addSpriteSource("img1.jpg"); Cache.addSpriteSource("img2.jpg"); //,    function waitImagesLoading() { var pc = Cache. getLoadedImagePc(); if(pc &lt; 100) setTimeout(waitImagesLoading, 200); /*        */ } waitImagesLoading();</span></span></code> </pre><br>  In my toy, I decided to describe each level in a separate script file.  It is clear that static loading of such scripts is harmful, since  only one of them is needed at a time.  The problem was solved by the same approach as in the case of loading images. <br>  There is only one caveat - the Script object has no events, but this is not a problem, since  In the code for dynamically loaded scripts, you can insert the global function of registering the script in the cache.  Then we proceed in the same way as loading images - we wait asynchronously until the script registers the types described in it, and then we create the necessary instances of the registered types. <br>  In order for the user to not be bored - you can show the percentage of loading all the necessary resources. <br><br><h5>  5. Fractional coordinates </h5>  Drawing on the canvas raster or vector primitives, you can specify fractional coordinates and dimensions.  As a result, the graphics engine of the browser is forced to smooth the displayed image.  If simplified, this happens because the virtual pixel of the rasterized image will not match the pixel on the screen.  As a result, smoothing algorithms will turn on, which can significantly affect performance. <br>  In <b><a href="http://gasizdat.ru/projects/game2/h.html">the performance test</a></b> , alternately with an interval of 20 seconds, sprites with integer and fractional coordinates ( <a href="">test code</a> ). <br>  Test results (fps): <br><table><tbody><tr><th>  Windows XP (x86), Core 2 Duo, 3 GHz </th><th>  Opera 12 </th><th>  Firefox 17 </th><th>  Chrome 23 </th></tr><tr><td>  Whole coordinates and sizes </td><td>  57 </td><td>  60 </td><td>  60 </td></tr><tr><td>  Fractional coordinates and sizes </td><td>  50 </td><td>  52 </td><td>  60 </td></tr></tbody></table><table><tbody><tr><th>  Windows 7 (x64), Core i3-2100, 3.1 GHz </th><th>  Opera 12 </th><th>  Chrome 23 </th><th>  IE 10 </th></tr><tr><td>  Whole coordinates and sizes </td><td>  60 </td><td>  61 </td><td>  61 </td></tr><tr><td>  Fractional coordinates and sizes </td><td>  60 </td><td>  61 </td><td>  61 </td></tr></tbody></table>  It should be clarified here that in the case of a 64-bit platform, the situation is saved by a better graphics adapter, which obviously takes on the task of anti-aliasing and anti-aliasing.  In the case of relatively fast moving sprites (tens of pixels per second), you can get along with whole coordinates and sizes.  However, the coordinates and dimensions themselves must be considered in fractional values ‚Äã‚Äãin order not to lose accuracy with a smooth change of parameters.  This approach is quite justified, when all values ‚Äã‚Äãof coordinates and dimensions are calculated and stored without rounding, and before direct output to the canvas, they are rounded off using Math.floor. <br><br><h4>  Instead of a conclusion. </h4><br>  The modern development of JavaScript, HTML5 and support of these features by various browsers already allow writing productive interactive graphic applications, which in most tasks will give odds to traditional flash programming. </div><p>Source: <a href="https://habr.com/ru/post/163373/">https://habr.com/ru/post/163373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../163357/index.html">HP 655 laptop video review</a></li>
<li><a href="../163361/index.html">Object versioning in S3</a></li>
<li><a href="../163365/index.html">Creating a convenient CAE system based on pre / post-processor GiD and any calculation program</a></li>
<li><a href="../163369/index.html">Help, we are captured</a></li>
<li><a href="../163371/index.html">High Frequency Trading (HFT) using FPGA</a></li>
<li><a href="../163375/index.html">Store on Guideman - discount for Habrahabra</a></li>
<li><a href="../163377/index.html">MIT researchers have discovered a new state of matter</a></li>
<li><a href="../163383/index.html">Letters of torrent happiness from a big brother</a></li>
<li><a href="../163387/index.html">A little bit about Z-Wave technology</a></li>
<li><a href="../163389/index.html">VMC - webcam on Mars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>