<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebGL Application Performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kirill Dmitrenko (Yandex) 
 Hello! My name is Kirill Dmitrenko, the last 4.5 years I have been working in Yandex as a front-end developer. And all thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebGL Application Performance</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b8c/735/d69/b8c735d6934b26602989654386facfeb.jpg"><br><br><h3>  Kirill Dmitrenko (Yandex) </h3><br>  Hello!  My name is Kirill Dmitrenko, the last 4.5 years I have been working in Yandex as a front-end developer.  And all this time I was haunted by the panorama.  When I came to the company, I did internal services for panoramas, after that I solved problems on panoramas on large Yandex cards, and recently made a web player of panoramas on Canvas 2D, HTML and WebGL.  Today I want to talk to you about the performance of WebGL applications. <br><a name="habracut"></a><br>  First, we will look at what WebGL is, then we will discuss how to measure the performance of WebGL applications, and finish by discussing some optimizations of WebGL applications and how I managed to apply them in the panorama player. <br><br>  So what is WebGL?  WebGL is an API that gives a web platform access to graphics card resources, i.e.  it allows you to draw hardware-accelerated graphics, including three-dimensional, directly in the browser, directly from your Javascript. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The structure of a WebGL application can, in a sense, be compared to how our ancestors saw the universe.  Well, at least with one of these visions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eff/f71/f2a/efff71f2a8d3bcc50598d783d5938706.png"><br><br>  Those.  This is a kind of world that relies on elephants, and they, in turn, stand on a big turtle.  And in this picture a world in which all logic, all meaning, and everything happens, will be our application.  And our WebGL application will rely on three main types of resources: <br><br><ol><li>  Buffers - such large blocks of bytes, where we put our geometry, which we want to show to the user, our models. </li><li>  Textures - pictures that we want to impose on our models so that they look more beautiful, more natural, look like objects of the real world. </li><li>  Shaders are small programs that run directly on the GPU and tells the GPU how we want to show our geometry, how we want our textures to be applied to it, etc. </li></ol><br>  And all these resources live, are born and die in the context of the WebGL context.  WebGL context is such a big turtle in our picture, through it we get access to all resources, we create them and, besides, there is still a big state in it that tells how we connect these resources to each other, how we we link together these buffers, shaders, textures, and how we use the results of shader calculations.  Those.  a great condition that affects rendering.  And, of course, it would be cool for our application to work faster. <br><br>  But before talking about optimization, you first need to learn how to measure.  It is impossible to improve what we cannot measure.  And the simplest tool that allows us to do this is the frame count per second. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c2/310/ae8/9c2310ae87ae490ceab0689c9882ac9b.png"><br><br>  It is available in Chrom, it is easy to do it yourself, and with it, in general, everything is clear, that is,  if we have a lot of frames per second, then this is good, few frames are bad.  But one thing to keep in mind is that the FPS in the application is limited by the refresh rate of the user's screen.  For most users in the wild, this is 60 Hz, i.e.  60 frames per second, and therefore it does not matter whether we generate our frame in 5 ms, 10 ms ... There will always be 60 frames.  The frame per second counter must be treated with a certain amount of skepticism.  And yet, if we have few frames per second, the application slows down, we start looking for bottlenecks in it.  We are starting to try to optimize it. <br><br>  I usually think in such cases as you - turn on the profiler, start profiling the application, look at the functions in which my JavaScript spends the most time, examine these functions under the microscope and try to do something with them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e25/b68/d0e/e25b68d0e2663a6f32614fbeebd1dada.png"><br><br>  However, in the case of OpenGL applications, the profiler faces a problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4f/22b/381/f4f22b381cd91dff8e9ad15d4a8b22ff.png"><br><br>  The fact is that the WebGL API is partially asynchronous, i.e.  all draw calls are asynchronous, some other calls are also asynchronous.  What does this mean, for example, with draw calls?  That when, the call returned control to our JS, then the drawing did not end by this moment, it will end sometime later.  Moreover, it may begin even later than we regained control.  Those.  all that the draw call does is - it generates some command, puts it in the buffer and returns to us and says: ‚ÄúGo!  Farther!".  Accordingly, in the profiler such calls will not come up to the top, and even if our drawing is slow, we will not see it. <br><br>  But not everything is so bad, some calls are still synchronous, and some calls, they are not only synchronous, but they also synchronize our context in a malicious way.  Those.  They not only do the work that we put on them synchronously, they also, while blocking our application while waiting for the end of the execution of all the tasks that we put on the context before that, i.e.  all drawings, all some state changes, etc.  Just such problems profiler helps us catch. <br><br>  And with drawing, another tool called EXT_disjoint_timer_query can help us. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/ccf/596/8ffccf596e8c4de7172c4615e337c2cb.png"><br><br>  This is an extension for WebGL, it is still terribly experimental, i.e.  This is another draft extension.  It allows you to measure the execution time of our teams on the GPU.  At the same time, which is very cool, it makes it asynchronous.  Those.  it does not synchronize our context in any way superfluous, it does not add much runtime overheads, i.e.  All the code we write to measure the performance of the application can be ship directly into production, directly to users.  And, for example, collect statistics.  Or, even better, based on these data, on the basis of these measurements, adjust the picture quality to the user's equipment, i.e.  On smartphones, show users one picture, on tablets - a better quality, because there is usually more powerful hardware, and on desktops, where there is a very powerful hardware, show the coolest picture with the coolest effects.  But at the same time, you need to write some code around it - this is a small minus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38f/88e/db4/38f88edb47781a0915fd5e464db21428.png"><br><br>  EXT_disjoint_timer_query allows you to measure the execution time of the first or several calls directly on the GPU.  It also allows you to set accurate time measurements in the pipeline.  Those.  it allows, for example, to measure how much time our GL teams go from our JS to the GPU, i.e.  what are our delays in the pipeline. <br><br>  Another EXT_disjoint_timer_query is a synchronous API, it allows you to create query objects for the driver, for the WebGL implementation, and work with query objects goes with it.  You create a query object and say: ‚ÄúNo, I want to put an exact time stamp on this object or start measuring the execution time of a group of commands with it‚Äù.  After that, you finish building the frame and usually to the next frame, though, perhaps later, you will be able to see the measurement results in nanoseconds, which is quite accurate.  And these measurements can be used. <br><br>  Let us summarize the conclusions about the measurements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e1/5a1/0da/6e15a10da7af9faf4cf1bf105d96ebf2.png"><br><br>  We have a frame count per second as a kind of quality characteristic of the application, which allows you to tell us whether we are slowing down or not.  And if we slow down, then the JS profiler will help us with finding bottlenecks on the CPU in our JS, in some kind of math, in some kind of supporting code.  EXT_disjoint_timer_query will help us with finding the bottlenecks on the GPU. <br><br>  Ok, we learned to measure performance, we learned to look for bottlenecks, now we need to understand what to do with them further.  Here we discuss only some of the optimization.  Computer graphics is such a large area of ‚Äã‚Äãhacks, deceptions and optimizations of strange ones.  We will discuss only some general optimizations, the way I applied them in the panorama player. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/ad7/459/5a5ad745984f192fd94fc745f26371ce.png"><br><br>  And the first rule that needs to be adopted on the way to the fast GL application is to work carefully with the WebGL state.  As I said at the very beginning, in a WebGL context there is a large chunk of state that affects rendering and you need to work with it carefully.  In particular, you do not need to make calls to get * and read *, i.e.  calls that request the current state of the context or read data from the video card.  If we really need it.  Why?  Because these calls, not only are synchronous, they can also cause the synchronization of the entire context, thereby slowing down our applications.  In particular, the getError () method, which checks whether we have an error in working with the WebGL context.  It should be called only in development, never in development.  And it is necessary to minimize state switching, not to do it too often, because each switching costs us something, including it can also cause context synchronization, and generally does not do any useful work. <br><br>  How can it look like in our code? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95f/fc9/7f7/95ffc97f7de2e7f070b6e9566b3a4627.png"><br><br>  In particular, it may look something like this, i.e.  nested loops, where in the outer loops we switch more expensive states, we switch them less often, and in more nested loops we switch states that are cheaper to switch.  In particular, connecting framebuffers or switching shader programs is quite expensive switching, they are almost guaranteed to cause synchronization and, in general, take a long time.  And switching textures and shader parameters - they are faster, they can be done more often. <br><br>  But in this remarkable design can be further optimized. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d2/d9b/bd0/6d2d9bbd0dc87c173b05250dfee7d4d2.png"><br><br>  You can make fewer draw calls and more work for each, i.e.  Each draw call adds some overhead to the validation of the state, to send this data to the video card.  And this overhead would be good to blur.  And you can blur it in one way only - by making these calls smaller, adding less overheads, while doing more work for each call.  In particular, you can put several objects, several models that we want to draw, in one buffer with data.  And if they use textures, then all these textures should be put in one big picture, which is usually called texture atlas.  And in this way we will bring several objects to the fact that they will require the same state for drawing, and we will be able to draw them in one call. <br><br>  There is such a good technique, called Instancing, which allows you to draw several copies of the same object with different parameters in one call.  A good example of Instancing optimization is the particle system.  I wanted to show the logo of our wonderful conference we are at, drawn using a particle system, i.e.  these are small objects, small models, of which there are a lot of them, there were 50 thousand of them. And in the first case, I drew each of them separately, with a naive approach.  And in the second case, I used a special extension. <br><br>  In general, using extensions is a good practice, they often have very cool features, without which it is difficult or impossible to do some things.  On the contrary, it is necessary to use them carefully, i.e.  you should always leave a siding in the code that will work without extensions. <br><br>  I used ANGLE_instanced_arrays there, which implements Instancing for WebGL, i.e.  I put all my parameters for all copies of the objects into a large buffer, told WebGL that this is a buffer with copy parameters, and - hop!  and it was drawn.  And then there was a beautiful effect, that from 10 to 60 FPS everything went up there. <br><br>  What did we have with this business in panoramas? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/71b/1c3/05271b1c3bdf40bda705bd7c7b311c8c.png"><br><br>  In panoramas, the minimization of context switching was actually free.  Why did this happen?  Because our task itself was so, i.e.  we draw in the player first a panorama, then object signatures, and then controls, transition arrows and a quick transition washer.  And from this formulation it followed that we draw the same objects side by side in the code.  In this case, we applied Instancing for markers, i.e.  we draw all markers, all object labels in one draw call.  And we also do not generate draw calls for panorama sectors that are not visible.  Why generate a call for something we still won't see on the screen?  Those.  a technique commonly called viewport culling or frustrum culling. <br><br>  And in this place, it is important to say that in Yandex we have spherical panoramas, i.e.  this is some kind of picture superimposed on a sphere.  When you open the player, you are ‚Äústanding‚Äù in the center of this picture and look outside.  So it looks, if you look outside the sphere, and not from the inside. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a22/7de/d9f/a227ded9f59d28fceab7e1c1c898e53a.png"><br><br>  This is the panoramic structure, the panoramic picture coming from the server, i.e.  we have it in an equal-rectangular projection, and we keep it in this way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b92/564/0cf/b925640cff138a00064515836875b813.png"><br><br>  We also cut it into small sectors so that it is convenient to work with it in WebGL: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/eef/6b6/6cceef6b6067fc8144761f2bd9135e1b.png"><br><br>  WebGL cannot create very large textures. <br><br>  And for each such sector, we can calculate whether it falls on our screen or not.  If it does not fall, we not only exclude it from the list for drawing, we also delete the resources it occupies, so  save memory.  As soon as it becomes visible again, we allocate an empty texture for it, and we reload this image from the browser cache. <br><br>  Somehow it looks like in geometry, i.e.  each sector of the texture corresponds to a sector in the geometry of the sphere, and this is how it is drawn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffd/30b/f91/ffd30bf9196447c1301c8d7840b00803.png"><br><br>  Another big and terrible sin in WebGL applications is Overdraw. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9dc/7a6/ce6/9dc7a6ce6def8c837b78cbe3d1de650f.png"><br><br>  What is Overdraw?  This is when we count the pixels several times.  For example, as in the diagram shown on the slide.  If we first draw a rectangle, then a circle, and then a triangle, it turns out that part of the rectangle, and after that, we considered part of the circle in vain.  We still do not see them, and the resources spent on them.  It would be nice to avoid it.  There are different techniques for this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f5/beb/cf7/2f5bebcf78004c89cb4668872745a235.png"><br><br>  The first is to count, as we do with texture sectors, invisible objects, i.e.  Objects that are closed by other objects from us, on the CPU in our JS and do not draw them, do not generate draw calls for them.  This technique is called occlusion culling.  It's not always easy to do in JS, JS is not very fast with math. <br><br>  You can apply simpler techniques, for example, sort objects by depth, i.e.  draw them from near to far, and then the video card itself will be able to exclude from this calculation those pixels that it will know for sure that they will not get on the screen, that they are farther than those that are already in the frame. <br><br>  And if it is difficult to do this, for example, because objects are extended or slyly self-intersect, you can make a Depth pre-pass, i.e.  using very simple shaders to fill the depth buffer, thus telling the video card the distance of each pixel from the screen, etc., the video card can apply exactly the same optimization as in the previous case. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/685/f11/2e7/685f112e78791895bf8ca432333a0ae7.png"><br><br>  In the panoramas we faced overdrow, solving another problem.  It should be that the panoramic image is sawed on the server in several sizes, in several resolutions, and we want to display to the user the size of the image that is most suitable for the current zoom player or the current zoom panorama.  However, at the same time we want to show him the best quality that we already have, which is not always optimal, may be of lower quality.  What does this look like? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a4/867/894/1a4867894ae524ebd0f916898f6ff79f.png"><br><br>  First we draw the worst quality of the picture, the most blurry, the most soapy, because it comes the fastest.  After that, we draw on top of it everything that we have better quality. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1d/2a1/d69/e1d2a1d6937395b62d8f4e39725124ec.png"><br><br>  And here it is clear that not all parts of the picture we have, some are missing and they are transparent and through them we see less quality. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f9/5c7/629/7f95c76291a95b118163ff3e7f5f6a63.png"><br><br>  And after that we draw the best quality that we have, which can also be partially transparent, because more details of the picture have not arrived yet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f7/5a4/75e/9f75a475eaed7cd76c67398d166c045d.png"><br><br>  And again we have openings through which the previous layer is visible: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0f9/dfa/ad20f9dfab09f8dc6c74b039bab0cfbc.png"><br><br>  Thus, in four passes, we generate a panorama picture on the screen for the user.  Why did this happen?  Because, firstly, a part of the texture can be transparent, and it was not very trivial to calculate which, generally speaking, transparent, and which less quality parts of the texture, are closed with parts of better quality.  Therefore, I had to suffer so much.  On Retina-screens it was very slow, because there are a lot of pixels, and it didn‚Äôt work very well on mobiles. <br><br>  How did we get around this?  If you look closely at this scheme, which I have just shown, then we can assume that, generally speaking, this operation can be done at one time.  Those.  Once collapsing these layers into one kind of intermediate buffer, it can be called a cache, and then only draw it in the frame.  Exactly what we did. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7d/a8b/22d/d7da8b22de8f05bfc95605f1945ececb.png"><br><br>  Suppose we have arrived data of poor quality, i.e.  on the right we have the data, on the left - a panoramic texture, well, a piece of it.  Good quality data flew in from us - we rendered the texture.  Better data arrived - we painted its texture on top of existing bad data.  Very good data arrived - and we also drew them on top.  We always have one picture that is offline collected from the arriving data. <br><br>  Of course, everything is not always so good, the network is unpredictable, and the data may not come in that order.  But solving the problem is quite simple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36b/617/cd9/36b617cd99e51780a17c4a36d27c0e94.png"><br><br>  Again a bad picture flies to us, then the best picture flies in, we draw it on top.  And then a smaller picture arrives; we, of course, do not display it.  We leave the best quality we already have.  So  we reduce several passes of rendering the panorama to one, and this hastened us on different devices, including Retina-devices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fce/60b/36a/fce60b36ad567e4c733a82563303537b.png"><br><br>  Often our rendering code, which is written on WebGL, works very quickly, it is capable of outputting 60 fps on smartphones, tablets, and desktop computers.  But any code around that is inevitably present in our web application, code that updates the DOM, code that loads resources, code that handles user events, UI events, it starts to slow us down, i.e.  it takes control for a long time, causing delays in animations, delays in rendering and slows down our application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11e/f2d/732/11ef2d7325d4e79a1087f449555188d6.png"><br><br>  With this code, it seems, nothing can be done, except to break it into small parts, i.e.  if we have 100 pictures loaded, then we don‚Äôt need to load 100 at once, we need to load 10, dozen, and five, as convenient.  And write a scheduler that will execute this code only when there really is a time for it, when it will not slow down the animation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d00/b8a/76e/d00b8a76e0cf1088664a668dd5da71c1.png"><br><br>  For us in panoramas, this code was loading of tiles and crowding out the invisible parts of the panorama, about which I spoke at the very beginning.  We did it very simply with him - we never do this while the panorama is moving, because if we have a static picture, it doesn't matter what our fps is, how many frames per second we show, maybe 1, maybe 60 - the user is not notice differences, the picture does not move, nothing changes on the screen.  Therefore, we wait until the animation is over and recalculate visible tiles, recalculate visible sectors, textures.  We create requests and manage resources. <br><br>  In addition, the sources of problems were the events of the player's software interface.  A player is a widget that is embedded in large maps, and large maps use some external events in order to display some of their additional interface elements. <br><br>  With API events we acted quite simply.  First of all, we slaughtered them, i.e.  those events that need to be generated constantly, for example, while the direction of the user's gaze changes, the direction of gaze in the panorama, we have eroded these events,  significantly reduced the frequency of their generation.  But even this was not enough, for example, many problems in this place were created by the browser history browser API.  We tried to update the link in the address bar for each change event, but it terribly slowed down everything.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so a special event was made that told the external code that the panorama had stopped and you could do hard work. The same scheme, by the way, is applied in the Yandex Maps API. There are special events for which you can do some more difficult work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's draw conclusions about optimization. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab2/1ea/8b5/ab21ea8b580582ae27ebe5d42ae54c6b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first and most important thing is that you need to carefully work with the state, because in the most unexpected place a malicious synchronization may occur, slow down our application. Do not call the reading state, do not read if there is no urgent need to read data from the video card and not cause a get error in production.</font></font> It's the most important. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make smaller draw calls and more work for each of them, so </font><font style="vertical-align: inherit;">we blur the overhead they add. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid overdraw by a variety of techniques, any that suit your application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the scheduler for the code around, i.e. </font><font style="vertical-align: inherit;">scheduler for a code that supports rendering, and so that it does not take control for a long time and does not slow down.</font></font><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmikis@yandex-team.ru</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://github.com/dmikis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profile on Github</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://www.facebook.com/dmikis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profile on Facebook</font></font></a> <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the conference of developers of high-loaded <a href="http://www.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl">HighLoad ++</a> systems.</font> <font color="gray"><br><br> ,      ,   ¬´ ¬ª. <br>   HighLoad++   <a href="https://www.youtube.com/user/profyclub/"> </a>  YouTube,                 :( <br><br>      - Frontend Conf       WebGL:</font> <ul><li> <a href="http://frontendconf.ru/2017/abstracts/2603%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl"> 3D-  </a> /   (Avito); </li><li> <a href="http://frontendconf.ru/2017/abstracts/2478%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl">  Web-   </a> /   (Liberty Global); </li><li> <a href="http://frontendconf.ru/2017/abstracts/2477%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl">  GLSL </a>      Web-         ,      ? /   (Liberty Global); </li><li> <a href="http://frontendconf.ru/2017/abstracts/2467%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web immersion or virtual reality with WebVR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / Tatyana Kuznetsova (DevExpress).</font></font></li></ul><br><br>  Interesting?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we are waiting for you </font></font><a href="http://frontendconf.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the conference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">But this is for the money. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or for free </font></font><a href="https://habrahabr.ru/article/328338/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the broadcast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which we organize together with Habr :). </font><font style="vertical-align: inherit;">It will not be broadcast by Frontend Conf itself, but by the best reports from the whole </font></font><a href="http://ritfest.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dwebgl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">festival</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote></div><p>Source: <a href="https://habr.com/ru/post/328526/">https://habr.com/ru/post/328526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328512/index.html">Turns the screen on Android without pain</a></li>
<li><a href="../328516/index.html">Using NES-game research tools on the example of parsing the Felix The Cat compression format</a></li>
<li><a href="../328518/index.html">Preview Rambler.iOS # 9</a></li>
<li><a href="../328520/index.html">Zero-day vulnerabilities in Wordpress and Vanilla Forums allow you to hack sites remotely</a></li>
<li><a href="../328522/index.html">Where is the money on the road (an algorithm that allows one and a half times to reduce costs in a taxi)</a></li>
<li><a href="../328528/index.html">How protocols are arranged in Elixir</a></li>
<li><a href="../328530/index.html">Why don't you answer my question?</a></li>
<li><a href="../328532/index.html">Heisenbag 2017 Piter: Call for Testing</a></li>
<li><a href="../328534/index.html">Video shooting training with a mentor</a></li>
<li><a href="../328536/index.html">Voting started for YiiConf reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>