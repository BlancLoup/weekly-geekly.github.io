<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IP KVM DIY 2.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At this time, I will present a kind of "bugfix" for the device from the previous article . Another version of the implementation, see the following . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IP KVM DIY 2.0</h1><div class="post__text post__text-html js-mediator-article">  At this time, I will present a kind of "bugfix" for the device from the previous <a href="https://habrahabr.ru/post/325918/">article</a> .  Another version of the implementation, see the <a href="https://geektimes.ru/post/292155/">following</a> . <br><br>  Having looked at the resulting bike, an idea came to correct how badly it could be.  Namely: <br><br><ul><li>  expand remote control capabilities; </li><li>  reduce the cost; </li><li>  come up with something with the transfer of video that would be at least a little more comfortable to work remotely. </li></ul><a name="habracut"></a><br>  I‚Äôll just say something from the video that didn‚Äôt come up, I‚Äôm going to have to be content with what we have, but let's not talk about sad things. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And so proceed, with clean hands, a cold head and a warm heart.  The components have changed dramatically instead of the Raspberry PI, we will use the Orange PI and instead of the Arduino UNO only the very microcircuit (Atmega16u2) that was discussed in the last article. <br><br>  The number of components has not changed: <br><br>  1. UVC video capture card: <br><br><img src="https://habrastorage.org/files/e24/04b/a77/e2404ba77ae94301b2bb656fa7a2a933.jpg"><br><br>  2. VGA to AV Converter: <br><br><img src="https://habrastorage.org/files/093/7af/93b/0937af93b8524cf296185938bb8380af.jpg"><br><br>  Experimented with another converter, here with this: <br><br><img src="https://habrastorage.org/files/083/0f5/4f5/0830f54f581b44f3ba69530f2334b6e8.jpg"><br><br>  But the miracle did not happen, the video quality did not improve, but on the contrary. <br><br>  3. Atmega16u2: <br><br><img src="https://habrastorage.org/files/d38/32f/4a0/d3832f4a098f4cf8abe96103b11496a3.jpg"><br><br>  4. Orange PI in my case Orange pi PC model: <br><br><img src="https://habrastorage.org/files/082/454/607/08245460786e465582426a27049bf149.jpg"><br><br>  A few words about this micro computer.  It is based on the Allwinner H3 processor (a good cheap 4-core processor on the AWP architecture), 1 GB of RAM 3 USB, HDMI, and so on, a full description is not difficult to find on the Internet. <br><br><h1>  Preparatory stage </h1><br><h4>  Install the operating system on Orangepi </h4><br>  <a href="http://www.orangepi.org/orangepibbsen/forum.php%3Fmod%3Dviewthread%26tid%3D342">Here is a link</a> to the forum, in this forum thread there is a lot of useful information, but of course everything is in English, we are interested in the OrangePI-PC_Ubuntu_Vivid_Mate.img distribution, you can download it from mega.nz or Google Drive.  We find the Download from Mega or Google Drive line in the header, click on the desired link, download it. <br><br>  The procedure for transferring an image to a USB flash drive is the same as for a flash drive; on Windows, you can use win32 disk imager writer on Linux with the dd command. <br><br>  A small digression.  Orange pi and similar microcomputers built on Chinese Allwinner processors are pretty much inferior to hardware not by hardware (hardware), but by software (software), more precisely by capabilities and OS "completeness", so to speak.  A trimmed kernel, an un-optimized file system, a huge number of bugs, these are not all problems.  This situation arose due to the fact that the processor manufacturer initially focused on tablets (maybe even smart phones) running Android, and from the manufacturer‚Äôs point of view, there wasn‚Äôt any economic expediency in a full-fledged Linux distribution.  The Linux kernel was trimmed to the very tomatoes, from a full life turned into a vegetable, capable only of primitive actions.  For a long time there were Linux distributions on the core of the android, probably a kind of cheap marketing ploy, and so it would have continued if not for the enthusiasts. <br><br>  But back to our sheep.  Distribution recorded, the system is running. <br><br><h4>  Adjust the motion </h4><br>  Go to the console.  <code>orangepi</code> <code>root</code> or <code>root</code> <code>orangepi</code> password <br><br>  Update packages: <br><br><pre> <code class="bash hljs">sudo apt-get update &amp;&amp; sudo apt-get upgrade ‚Äìy</code> </pre> <br><h4>  Set Motion </h4><br>  All settings as in the previous article: <br><br><div class="spoiler">  <b class="spoiler_title">Fragment of the article</b> <div class="spoiler_text"><pre> <code class="bash hljs">sudo apt-get install motion -y</code> </pre> <br>  We edit the autorun config: <br><br><pre> <code class="bash hljs">sudo nano /etc/default/motion</code> </pre> <br>  In the line <code>start_motion_daemon</code> set 'yes'.  Save changes Ctrl + x, y, Enter. <br><br>  We edit the config of the motion itself (a): <br><br><pre> <code class="bash hljs">sudo nano /etc/motion/motion.conf</code> </pre> <br>  Change the parameter values ‚Äã‚Äãas follows: <br><br>  The parameter defines the launch of the application as a service: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">daemon</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span></code> </pre> <br>  These parameters determine the resolution of the transmitted image, there is no sense in setting a higher resolution, since  video capture is limited to PAL or SECAM standards, the resolution of which is 720x576.  This is by the way an annoying flaw, but more on that later. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">width</span></span> <span class="hljs-number"><span class="hljs-number">800</span></span> height <span class="hljs-number"><span class="hljs-number">600</span></span></code> </pre> <br>  Frame rate: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">framerate</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span></code> </pre> <br>  Disable screenshots saving: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">output_normal</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span></code> </pre> <br>  Image transfer quality: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">webcam_quality</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br>  Frame rate: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">webcam_maxrate</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span></code> </pre> <br>  Cancel restrictions on connections from other ip <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">webcam_localhost</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span></code> </pre> <br>  Save changes Ctrl + x, y, Enter. <br></div></div><br>  The console is not closing yet. <br><br><h4>  Preparing to compile </h4><br>  For the transfer of control, we will write a program, everything will be described below in more detail, in the meantime, we will make basic preparations. <br><br>  Install everything you need to compile, our program will be in C: <br><br><pre> <code class="bash hljs">sudo apt-get install build-essential -y</code> </pre> <br>  Install the ncurses library, using it we will capture the key values: <br><br><pre> <code class="bash hljs">sudo apt-get install ncurses -y</code> </pre> <br>  We make ourselves the owner of the serial port so that we can record: <br><br><pre> <code class="bash hljs">sudo chown orangepi /dev/ttyS2</code> </pre> <br>  Open the kernel module loading config in the editor: <br><br><pre> <code class="bash hljs">sudo nano /etc/modules</code> </pre> <br>  Uncomment the <code>gpio-sunxi</code> .  With this action we activate gpio, more precisely, the module for working with it, why I‚Äôll tell you later. <br><br>  Editing autorun: <br><br><pre> <code class="bash hljs">sudo nano /etc/rc.local</code> </pre> <br>  Add in front of the <code>exit</code> line the following <code>chown -R orangepi /sys/devices/platform/*</code> .  This command will make the orangepi user own the virtual files that are responsible for interacting with the GPIO port. <br><br>  In theory, it would be better to create a group, assign rights, add a user to the group, but this is all a demonstration model (therefore, a character from a famous cartoon is recalled), and so it will come down.  Of course, I do not in any way forbid you to do everything as it should. <br><br>  Save the changes and reboot: <br><br><pre> <code class="bash hljs">sudo reboot</code> </pre> <br>  Let's digress a bit on the hardware. <br><br><h4>  Atmega16u2 </h4><br>  To transfer control, it was decided to use the Atmega16u2 microcircuit directly without the participation of unnecessary microcontrollers and ArduinoIDE, and run the executable code, you guessed it, right on the microcomputer. <br><br>  Let us analyze the logic of the Arduin in the previous article. <br><br>  The key values ‚Äã‚Äãwere received via the serial port on the Atmega328p microcontroller (large oblong chip on Arduino UNO) which of the arrays specified in HIDKeyboard.h passed the key codes, so-called ‚ÄúUSB HID keyboard keycodes‚Äù to the Atmega16u2 microcontroller (again on the serial port), which in turn sent via USB to the target computer.  Serial ‚Üí Atmega328p ‚Üí Serial ‚Üí Atmega16u2 ‚Üí USB <br><br>  In general, Atmega328p played the role of intermediary, and of course it is logical to remove it, which we will do, for this we will rewrite the code that was for Arduin under Orangepi, and connect Atmega16u2 directly. <br><br>  Naturally bare chip will not work, you need at least a minimum binding. <br>  I advise you to read the review at <a href="http://payalo.net/index.php%3Fnewsid%3D104">this</a> link. For our purposes, the USB powered version is perfect <br><img src="https://habrastorage.org/files/f92/8ab/5e1/f928ab5e12d24c4980e6ba59b80aba9e.jpg"><br><br>  As you can see, the scheme is very simple, even a beginner can cope with it, not a lot of elements can be managed with hinged mounting, only it is better to fix the crystal oscillator so as not to dangle in the air.  The generator by the way should be 16 megahertz if suddenly it is not clear from the scheme.  And do not pay attention to the fact that the circuit for ATmega32u2 is suitable for ATmega16u2 and for ATmega8u2 too. <br><br>  If there is an Arduino UNO board you can use it, you should connect to the tx contacts - ‚Ññ 0, rx -‚Ññ 1 and preferably remove the Atmega328p mikruha so that it doesn‚Äôt consume any power and does not clog the serial port air. <br><br>  I don‚Äôt need to remind you about the logical levels, everything is the same as in the previous article, the serial port Orange PI is similar to Raspberry PI running at 3.3 volts and matching of voltages is necessary. <br><br>  For ATmega16u2 firmware, you need to close the <b>Reset</b> leg with the ground for a second and fill the firmware with the <b>Flip</b> program <br><img src="https://habrastorage.org/files/645/df8/710/645df8710f44479daa5848a534693518.jpg"><br>  I will not describe in detail, it was already the last time.  At this training is over let's get to the point. <br><br><h1>  We write the program </h1><br>  For the transfer of keys and remote control of the converter, we will write a small program. <br><br><h4>  Theory </h4><br>  At first there was a rush to simply port the sources from UNO-HIDKeyboard-Library, this is the library for the Arduino IDE (files HIDKeyboard.cpp and HIDKeyboard.h) that was used last time, but the functionality was not enough for the idea, so why not write your own program. <br><br>  I present to your attention the Linux-Remote-HIDKeyboard, the name is so-so, but you also need to call it something, hereinafter referred to as LRHIDKeyboard.cpp or rkeysend (compiled binary). <br><br>  The source will consist of 2 files LRHIDKeyboard.cpp and HIDKeyboard.h.  HIDKeyboard.h is the same header file from the UNO-HIDKeyboard-Library library.  Arrays are stored in this file to convert to ‚ÄúUSB HID keyboard keycodes‚Äù, but I took the liberty of correcting errors and expanding arrays, compatibility with HIDKeyboard.cpp is preserved, so if needed, you can also use it for arduin. <br><br>  USB HID keyboard keycodes are key codes delivered via USB, you can read more <a href="http://www.usb.org/developers/hidpage/Hut1_12v2.pdf">here</a> (pdf). <br><br>  In the HIDKeyboard.h header file, two arrays are the first to define regular keys, the second is for keys with the shift pressed.  The decimal number obtained when capturing from the terminal is compared with the number of the array element and is replaced with this element that looks something like ‚Äú0x7f‚Äù (hexadecimal number).  Example key "a" has the value "4" in decimal notation or "04" in hexadecimal, key "ESCAPE" "41" in decimal or "29" in hexadecimal, a hexadecimal number indicating the press of any key is sent to the chip. <br><br><h4>  Practice </h4><br>  Open the console Orangepi create a directory where the program will be stored like this: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~ mkdir PROG <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> PROG</code> </pre> <br>  We create the files <code>HIDKeyboard.h</code> and <code>LRHIDKeyboard.cpp</code> : <br><br><pre> <code class="bash hljs">touch HIDKeyboard.h touch LRHIDKeyboard.cpp</code> </pre> <br>  Open in the editor HIDKeyboard.h: <br><br><pre> <code class="bash hljs">nano HIDKeyboard.h</code> </pre> <br>  Copy the contents of the listing: <br><br><div class="spoiler">  <b class="spoiler_title">Listing HIDKeyboard.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> HIDKeyboard_h #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIDKeyboard_h </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//#include "Arduino.h" /**************************************************************************** * SPECIAL CHARACTER DEFINES * * These are the HID values for keys that do not output characters * ****************************************************************************/ // HID Values of Function Keys #define F1 0x3a #define F2 0x3b #define F3 0x3c #define F4 0x3d #define F5 0x3e #define F6 0x3f #define F7 0x40 #define F8 0x41 #define F9 0x42 #define F10 0x43 #define F11 0x44 #define F12 0x45 // HID Values of Special Keys #define ENTER 0x28 #define ESCAPE 0x29 #define BACKSPACE 0x2a #define TAB 0x2b #define SPACEBAR 0x2c #define CAPSLOCK 0x39 #define PRINTSCREEN 0x46 #define SCROLLLOCK 0x47 #define PAUSE 0x48 #define INSERT 0x49 #define HOME 0x4a #define PAGEUP 0x4b #define DELETE 0x4c #define END 0x4d #define PAGEDOWN 0x4e #define RIGHTARROW 0x4f #define LEFTARROW 0x50 #define DOWNARROW 0x51 #define UPARROW 0x52 // HID Values of Keypad Keys #define NUMLOCK 0x53 #define KEYPADSLASH 0x54 #define KEYPADSTAR 0x55 #define KEYPADMINUS 0x56 #define KEYPADPLUS 0x57 #define KEYPADENTER 0x58 #define KEYPAD1 0x59 #define KEYPAD2 0x5a #define KEYPAD3 0x5b #define KEYPAD4 0x5c #define KEYPAD5 0x5d #define KEYPAD6 0x5e #define KEYPAD7 0x5f #define KEYPAD8 0x60 #define KEYPAD9 0x61 #define KEYPAD0 0x62 #define KEYPADPERIOD 0x63 // HID Values of System Keys #define KEYBOARDAPPLICATION 0x65 #define KEYBOARDPOWER 0x66 #define VOLUMEMUTE 0x7f #define VOLUMEUP 0x80 #define VOLUMEDOWN 0x81 // Common-use modifiers #define LCTRL 0x01 #define SHIFT 0x02 #define ALT 0x04 #define GUI 0x08 /**************************************************************************** * * ASCII-&gt;HID LOOKUP TABLE * * Taken from the HID Table definition at * http://www.usb.org/developers/devclass_docs/Hut1_11.pdf * * This array maps the ASCII value of a type-able character to its * corresponding HID value. * * Example: * 'a' = ASCII value 97 = HID value 0x04 * HIDTable['a'] = HIDTable[97] = 0x04 * * </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> * "Shift Modified" HID values are the same as the non Shift-Modified values * for any given character, eg the HID value for '2' is equal to the * HID value for '@'. The Shift-Modified value is sent by setting the * modifier value (buf[0]) to the corresponding modifier value in the * modifier table. * ****************************************************************************/ const static uint8_t HIDTable[] = { 0x00, // 0 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x2b, 0x28, // 10 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 20 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, // 30 0x00, 0x2c, 0x1e, 0x34, 0x20, 0x21, 0x22, 0x24, 0x34, 0x26, // 40 0x27, 0x25, 0x2e, 0x36, 0x2d, 0x37, 0x38, 0x27, 0x1e, 0x1f, // 50 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x33, 0x33, 0x36, // 60 0x2e, 0x37, 0x38, 0x1f, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, // 70 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, // 80 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, // 90 0x2f, 0x31, 0x30, 0x23, 0x2d, 0x35, 0x04, 0x05, 0x06, 0x07, // 100 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, // 110 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, // 120 0x1c, 0x1d, 0x2f, 0x31, 0x30, 0x35, 0x4c, 0x00, 0x00, 0x00, // 130 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 140 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 150 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 160 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 170 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 180 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 190 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 200 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 210 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 220 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 230 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 240 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 250 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x52, 0x50, // 260 0x4f, 0x4a, 0x2a, 0x00, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, // 270 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x00, 0x00, 0x00, 0x00, // 280 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 290 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 300 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 310 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 320 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, // 330 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x4b, 0x00, // 340 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 350 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, // 360 }; /**************************************************************************** * * ASCII-&gt;MODIFIER LOOKUP TABLE * * Looks up whether or not the HID report should use the SHIFT modifier. * * Example: * The character '2' and the character '@' have different ASCII values but * the same HID value. This table uses the ASCII value to determine if * we should hold shift while sending the key. eg: * * HIDTable['2'] = 0x1f and modifierTable['2'] = 0 * HIDTable['@'] = 0x1f and modifierTable['@'] = SHIFT * * There's probaly a better way to do this, but it's functional. * ****************************************************************************/ const static uint8_t modifierTable[] = { 0x00, // 0 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 10 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 20 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 30 0x00, 0x00, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, 0x00, SHIFT, // 40 SHIFT, SHIFT, SHIFT, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 50 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, SHIFT, 0x00, SHIFT, // 60 0x00, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, // 70 SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, // 80 SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, SHIFT, // 90 0x00, 0x00, 0x00, SHIFT, SHIFT, 0x00, 0x00, 0x00, 0x00, 0x00, // 100 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 110 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 120 0x00, 0x00, SHIFT, SHIFT, SHIFT, SHIFT, 0x00 // 127 }; class HIDKeyboard { public: // Constructor HIDKeyboard(); // Public functions void begin(); // Starts the required serial communication (9600 baud) void pressKey(uint8_t modifier, uint8_t key); // Looks up key in HIDTable and sends with a modifier void pressKey(uint8_t key); // Sends key report without modifier (modifier = 0) void pressSpecialKey(uint8_t modifier, uint8_t specialKey); // Sends specialKey with a modifier void pressSpecialKey(uint8_t specialKey); // Sends specialKey without modifier void releaseKey(); // Releases keys (clears key and modifier) void print(char* sequence); // Prints string &lt;sequence&gt; void println(char* sequence); // Prints string &lt;sequence&gt; followed by a carriage return private: // HID report buffer uint8_t buf[8]; // In report, buf[0] = modifier and buf[2] = key HID value }; #endif</span></span></span></span></code> </pre><br></div></div><br>  save Ctrl + x, y, Enter <br><br>  And again: <br><br><pre> <code class="bash hljs">nano LRHIDKeyboard.cpp</code> </pre> <br>  Copy the contents of the listing: <br><br><div class="spoiler">  <b class="spoiler_title">Listing LRHIDKeyboard.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;termios.h&gt; #include &lt;time.h&gt; #include &lt;ncurses.h&gt; #include "HIDKeyboard.h" char myport[] = "/dev/ttyS2"; //  serial port     //        char nul[] = ""; char menu[] = "/sys/class/gpio_sw/PA14/data"; // char zoom[] = "/sys/class/gpio_sw/PD14/data"; // char kup[] = "/sys/class/gpio_sw/PC4/data"; // char kdn[] = "/sys/class/gpio_sw/PC7/data"; // char klf[] = "/sys/class/gpio_sw/PG8/data"; // char krt[] = "/sys/class/gpio_sw/PA21/data"; // uint8_t buf[8] = { 0 }; /* Keyboard report buffer */ int open_port(char *devname) // serial port { int fd; fd = open(devname, O_RDWR | O_NOCTTY | O_NDELAY); if(fd == -1) // { printw("Port is not open! %s" , devname); return -1; } else { fcntl(fd, F_SETFL, 0); printw("Open port %s", devname); } //  struct termios port_settings; cfsetispeed(&amp;port_settings, B9600); cfsetospeed(&amp;port_settings, B9600); port_settings.c_cflag &amp;= ~PARENB; port_settings.c_cflag &amp;= ~CSTOPB; port_settings.c_cflag &amp;= ~CSIZE; port_settings.c_cflag |= CS8; tcsetattr(fd, TCSANOW, &amp;port_settings); return(fd); } int alt_check(int check) //   ALT,     ALT,   "0" { if(check == 27) { nodelay(stdscr,TRUE); check = getch(); if (check == -1) return ESCAPE; //     Esc nodelay(stdscr,FALSE); return check; } //else return 0; return 0; } int hot_key(int fd, int alt, int vchar) // { if(alt != 0) { if (alt == 330) // "Alt" + "Delete"  Ctrl + Alt + Delete { vchar = 0; buf[0] = 0x04|0x01; buf[2] = HIDTable[alt]; write(fd, buf, 8); return 0; } if (alt == 114) // "Alt" + "r"  Win + r { vchar = 0; buf[0] = 0x08; buf[2] = HIDTable[alt]; write(fd, buf, 8); return 0; } if (alt == 52) // "Alt" + "4"  Alt + F4 { vchar = 0; buf[0] = 0x04; buf[2] = 0x3d; write(fd, buf, 8); return 0; } if (alt == 116) // "Alt" + "t"  Alt + Tab { vchar = 0; buf[0] = 0x04; buf[2] = 0x2b; write(fd, buf, 8); return 0; } if (alt == 44) // "Alt" + ","  Alt + Shift { vchar = 0; buf[0] = 0x04|0x02; write(fd, buf, 8); return 0; } if (alt == 46) // "Alt" + "."  Ctrl + Shift { vchar = 0; buf[0] = 0x01|0x02; write(fd, buf, 8); return 0; } } else { if (vchar == 17) //   "Ctrl" + "q" { endwin(); exit(0); } //  *nul = '\0'; if (vchar == 28) strcpy(nul, menu); // "Ctrl" + "\" if (vchar == 31) strcpy(nul, zoom); // "Ctrl" + "/" if (vchar == 566) strcpy(nul, kup); // "Ctrl" + "up" if (vchar == 525) strcpy(nul, kdn); // "Ctrl" + "down" if (vchar == 545) strcpy(nul, klf); // "Ctrl" + "left" if (vchar == 560) strcpy(nul, krt); // "Ctrl" + "right" FILE *f = fopen(nul, "w"); //  if (f != '\0') { fwrite("1", 1, 1, f); int wrt = fclose(f); //   usleep(70000); if (wrt == 0) { FILE *f = fopen(nul, "w"); fwrite("0", 1, 1, f); fclose(f); } else printf("error write file: %s", nul); return 0; } return vchar; } } int send_key(int fd, int altkey, int getkey) //  { if (altkey == ESCAPE) { buf[0] = 0x00; buf[2] = 0x29; write(fd, buf, 8); return 1; } if (altkey != 0) { buf[0] = 0x04; buf[2] = HIDTable[altkey]; write(fd, buf, 8); return 1; } else { if (getkey == 0) return 0; //printf("KEY NAME : %s - %d\n", keyname(getkey),getkey); //  buf[0] = modifierTable[getkey]; buf[2] = HIDTable[getkey]; write(fd, buf, 8); return 1; } return(-1); } int release_key(int fd) //    { buf[0] = 0; buf[2] = 0; write(fd, buf, 8); } int main(void) { initscr(); keypad(stdscr,TRUE); //    raw(); //   int fd = open_port(myport); printw("\nHOT KEYS: Alt + Delete = Ctrl + Alt + Delete Alt + r = Win + r Alt + 4 = Alt + F4 Alt + t = Alt + Tab Alt + , = Alt + Shift Alt + . = Ctrl + Shift"); printw("\nGPIO: MENU = Ctrl + \\ ZOOM = Ctrl + / UP = Ctrl + up DOWN = Ctrl + down LEFT = Ctrl + left RIGHT = Ctrl + right"); printw("\n Exit = Ctrl + q"); move(10,1); refresh(); while (fd != -1) { int pkey = getch(); int alt = alt_check(pkey); int hot = hot_key(fd, alt, pkey); send_key(fd, alt, hot); release_key(fd); } endwin(); }</span></span></span></span></code> </pre><br></div></div><br>  Save Ctrl + x, y, Enter. <br><br><h4>  Compile </h4><br><pre> <code class="bash hljs">g++ LRHIDKeyboard.cpp -o rkeysend -lncurses</code> </pre> <br>  <b>rkeysend</b> is the name of the executable file obtained during the compilation process. <br>  <b>The -lncurses</b> connection when compiling the ncurses library is used to capture the keys in the terminal and send text messages to the same terminal. <br><br>  If the compilation was successful, you can proceed to the GPIO ports. <br><br><h1>  Converter control </h1><br>  A ‚Äúfreshly compiled‚Äù program can not only transfer keys, but also control the converter.  I will explain why.  First, you can adjust the image, brightness, contrast, sharpness, etc.  Secondly, I already wrote about the resolution of the image obtained from the converter = 720x576.  So, the converter has a mode of displaying only a part of the image, while the resolution does not change, in other words, you can see more fine details of the image using this mode. <br><br>  The converter will be controlled by GPIO.  GPIO, as you already know, general-purpose input / output, or if in Russian, I liked the rather accurate definition from Wikipedia ‚Äúgeneral purpose input / output interface‚Äù, which is a microcomputer's way of interacting with the outside world. <br><br><h4>  Connecting Orangepi PC to the converter </h4><br>  And so we Connect the converter with GPIO.  The converter has physical control buttons: left, right, bottom, top, menu, and zoom.  They are connected by the following principle as in the picture.  The illustration shows only the principle of the buttons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ce1/5c1/503/ce15c15036f44d40b4f4b5ad1788e6b9.jpg"></div><br>  The converter has a port on which it measures the voltage and, in accordance with the required level, performs the action: opens the menu, enlarges the image, moves the image, etc. <br><br>  To control the buttons I used bipolar transistors with optical input AOT128A: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/86e/ada/db1/86eadadb18df41d5bf46b2e198220273.jpg"></div><br>  The emitter and collector of the transistor are soldered to the ground and the contact of the button.  The cathode of the transistor is connected (soldered) to the ground.  The anode of the transistor is connected to the desired GPIO port via a 33 Ohm resistor. <br><br><img src="https://habrastorage.org/files/09a/32f/bae/09a32fbae00a4ef1b27501ae51b3fc06.jpg"><br>  If you change something, remember: <br><br>  The control voltage at the anode of this transistor is not more than 1.6V; when this value is exceeded, the transistor starts to heat up strongly and thermal breakdown can occur.  The power source for Orangepi and for the converter is desirable to use the same, otherwise the picture may change due to the potential difference. <br><br>  We connect the transistor anodes to the following GPIO ports: <b>PA14</b> - menu, <b>PD14</b> - zoom, <b>PC4</b> - top, <b>PC7</b> - bottom, <b>PG8</b> - left, <b>PA21</b> - right. <br><br>  The serial port for connecting the ATmega16u2 microcircuit is located on Ports 11 (RX) and 13 (TX).  We connect as indicated in the image <br><img src="https://habrastorage.org/files/82c/b4b/49d/82cb4b49d6104810a20ad4be678e5ccb.jpg"><br>  Well, now everything is connected.  At first, I wanted to control the converter on a single field-effect transistor using a single port, but somehow I didn‚Äôt ask, the PWM ripple is transmitted to the transistor and as a result, the resistance starts to float on it, there are options for smoothing filters, but this would greatly complicate the design.  There is also an option to use a digital potentiometer via SPI or I2C, here everything is in your hands, dare. <br><br><h1>  Launch </h1><br>  Check whether everything is connected as it should: <br><br><ol><li>  Orangepi GPIO to Converter </li><li>  Converter for VGA to Computer (slave) </li><li>  AV output converter to AV input video capture card </li><li>  Video capture card to USB Orangepi </li><li>  Orangepi to ATmega8U2 / 16U2 / 32U2 microcircuit </li><li>  ATmega8U2 / 16U2 / 32U2 chip via USB to computer (slave) </li><li>  Computer (master) on SSH to Orangepi </li></ol><br><h4>  Run the program </h4><br>  Ha Orangepi we launch the compiled program, there should appear the inscriptions with the indication of the open serial port and key combinations.  Something like that. <br><br><img src="https://habrastorage.org/files/a0a/98b/05b/a0a98b05b6214dfc85d03ba848432584.jpg"><br><br>  There are keyboard shortcuts to call the Task Manager or change the layout, for example, to press the Ctrl + Alt + Del computer under your control in the terminal, enter ‚ÄúAlt + Del‚Äù, possible combinations are written when the program starts on top of the terminal window. <br><br>  The video, as in the previous article, transmits motion, available at <code>orangepi:8081</code> .  Well, that's all, all the necessary information for repeating the experience is stated, the mission is completed. <br><br><h1>  Let's sum up: </h1><br><h4>  Video transfer </h4><br>  The video remains very low quality due to the fact that it is transmitted via the AV input, but now we have remote control of the converter and if you select the desired item in the menu - you can watch the screen in parts in the same resolution. <br><br>  There are possible solutions to the problem with video quality, only they have one major drawback: the price: <br><br>  1. <a href="http://www.ebay.com/itm/Velocap-U2m-USB-2-0-HDMI-1080P-Video-Capture-Card-hardware-encode-/172350001507">Velocap U2m usb 2.0 hdmi</a> <br>  2. <a href="https://ru.aliexpress.com/item/VOXLINK-XI100D-1080P-60FPS-UVC-USB-3-0-HDMI-Capture-Dongle-USB2-0-HDMI-Capture-Card/32762919488.html">UVC USB 3.0 HDMI</a> <br><br>  I did not try these options, for it is expensive, maybe someone from reading the article will risk. <br>  You can probably save money on the microcomputer board by changing the Orangepi PC to the Orangepi one or Orangepi Zero, its cost is about 500 rubles.  But there may be problems with Orangepi Zero, there is a different processor, respectively, another distribution with a different core, in which the necessary drivers and modules may not be available. <br><br><h4>  Cost price </h4><br>  VGA to AV Converter about 700rub. <br>  The video capture card is about 500 rubles. <br>  Orangepi PC about 1000 rub. <br>  ATmega8U2 / 16U2 / 32U2 approximately 150rub. <br><br>  <b>Total:</b> 2350 rub. <br><br>  Well, this article came to an end, thanks to everyone who read it.  I hope in practice you will succeed.  Although I was not able to implement all of my plans, the result was interesting, especially for such a price.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the resulting device needs some work, but I think it still has a right to exist. </font><font style="vertical-align: inherit;">I give all my work as it is, without any guarantees, in good hands.</font></font> Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/326112/">https://habr.com/ru/post/326112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326102/index.html">Online cash vs blockchain: you did not know this, but thought about it?</a></li>
<li><a href="../326104/index.html">Not soon the fence is built, especially a beautiful data center. How we build the data center "Avantage". Part 1</a></li>
<li><a href="../326106/index.html">PostgreSQL indexes - 2</a></li>
<li><a href="../326108/index.html">A little about the lines in C, or several options to optimize non-optimizable</a></li>
<li><a href="../326110/index.html">It's very simple</a></li>
<li><a href="../326114/index.html">Primitives for implementing 1-Wire master using PWM and ICP for STM8L and STM32</a></li>
<li><a href="../326116/index.html">The subtleties of Scala: we study CanBuildFrom</a></li>
<li><a href="../326118/index.html">Editors ONLYOFFICE v.4.3: yes, we added footnotes</a></li>
<li><a href="../326120/index.html">5 courses that will help start your way in the design of games</a></li>
<li><a href="../326122/index.html">Test Lossless Image Optimizers (PNG and JPG)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>