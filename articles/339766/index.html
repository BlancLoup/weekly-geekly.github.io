<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Python for complex tasks: the science of data and machine learning"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrozhiteli! This book is a guide to a variety of computational and statistical methods, without which any intensive data processing, research an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Python for complex tasks: the science of data and machine learning"</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/piter/blog/339766/"><img src="https://habrastorage.org/webt/59/dc/7d/59dc7db578d00991150128.jpeg" align="left" alt="image"></a>  Hi, Habrozhiteli!  This book is a guide to a variety of computational and statistical methods, without which any intensive data processing, research and advanced development is unthinkable.  Readers who already have programming experience and want to use Python effectively in the field of Data Science will find answers to all kinds of questions in this book, for example: how to read this data format into a script?  How to transform, clear this data and manipulate it?  How to visualize this type of data?  How to use this data to understand the situation, get answers to questions, build statistical models or implement machine learning? <br><br>  Below the cut is a review of the book and an excerpt "Histograms, splits by intervals and density" <br><a name="habracut"></a><br><h3>  Who is this book for? </h3><br>  ‚ÄúHow exactly should I learn Python?‚Äù Is one of the most frequently asked questions to me (the author) at various technology conferences and meetings.  It is asked by technology-interested students, developers, or researchers, often with considerable experience writing code and using computational and digital tools.  Most of them do not need the Python programming language in their pure form, they would like to study it in order to use it as a tool for solving problems that require calculations with processing large amounts of data. <br><br>  This book was not intended as an introduction to Python or to programming in general.  I assume that the reader is familiar with the Python language, including a description of functions, assigning variables, calling methods on objects, managing the flow of program execution, and solving other simple tasks.  It should help Python users learn how to use the Python data research tools stack ‚Äî libraries such as IPython, NumPy, Pandas, Matplotlib, Scikit-Learn, and appropriate tools ‚Äî for efficient storage, manipulation, and understanding of data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  General structure of the book </h3><br>  Each chapter of the book is devoted to a specific package or tool, which is an essential part of the Python toolkit for data exploration. <br><br><ul><li>  IPython and Jupyter (Chapter 1) provide a computing environment in which many Python-based data researchers work. </li><li>  NumPy (Chapter 2) - Provides an ndarray object for efficient storage and handling of dense data sets in Python. </li><li>  Pandas (Chapter 3) - Provides a DataFrame object for efficient storage and handling of named / column data in Python. </li><li>  Matplotlib (Chapter 4) - provides opportunities for a variety of flexible data visualization in Python. </li><li>  Scikit-Learn (Chapter 5) ‚ÄîProvides efficient Python implementations of most important and well-known machine learning algorithms. </li></ul><br>  The PyData world is much wider than the packages presented, and it is growing day by day.  With this in mind, I (the author) use every opportunity in the book to refer to other interesting works, projects, and packages that extend the limits of what can be done in Python.  Nonetheless, today these five packages are fundamental to much of what can be done in the application of the Python programming language to data exploration.  I believe that they will also retain their importance as the ecosystem grows. <br><br><h3>  Excerpt  Histograms, breaks by intervals and density </h3><br>  A simple bar graph can be of great benefit in the initial analysis of a data set.  Earlier, we saw an example of using the Matplotlib library function (see the Comparisons Masks and Boolean section of Chapter 2) to create a simple one-line histogram after performing all the usual imports (Fig. 4.35): <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]: %matplotlib <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.style.use(<span class="hljs-string"><span class="hljs-string">'seaborn-white'</span></span>) data = np.random.randn(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]: plt.hist(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/88/59dc88e680bfc173912501.png" alt="image"></div><br>  The hist () function has many parameters to configure both the calculation and the display.  Here is an example of a histogram with detailed user settings (Fig. 4.36): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]: plt.hist(data, bins=<span class="hljs-number"><span class="hljs-number">30</span></span>, normed=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.5</span></span>, histtype=<span class="hljs-string"><span class="hljs-string">'stepfilled'</span></span>, color=<span class="hljs-string"><span class="hljs-string">'steelblue'</span></span>, edgecolor=<span class="hljs-string"><span class="hljs-string">'none'</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/89/59dc8950621bb559444019.png" alt="image"></div><br>  The plt.hist docstring function contains more information about other customization options available.  The combination of the histtype = 'stepfilled' option with the given alpha transparency seems to me very convenient for comparing the histograms of several distributions (Fig. 4.37): <br><br><pre> <code class="hljs lua">In[<span class="hljs-number"><span class="hljs-number">4</span></span>]: x1 = np.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>.normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) x2 = np.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>.normal(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) x3 = np.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>.normal(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) kwargs = dict(histtype=<span class="hljs-string"><span class="hljs-string">'stepfilled'</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.3</span></span>, normed=True, bins=<span class="hljs-number"><span class="hljs-number">40</span></span>) plt.hist(x1, **kwargs) plt.hist(x2, **kwargs) plt.hist(x3, **kwargs);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/89/59dc89ce4d1e2484999237.png" alt="image"></div><br>  If you need to calculate a histogram (that is, count the number of points in a given interval) and not display it, at your service the np.histogram () function: <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">In</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]: counts, bin_edges = np.histogram(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, bins=5) print(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counts</span></span></span><span class="hljs-class">) [ 12 190 468 301 29]</span></span></code> </pre> <br><h3>  Two-dimensional histograms and intervals by intervals </h3><br>  In the same way that we created one-dimensional histograms, breaking the sequence of numbers into intervals, you can also create two-dimensional histograms by distributing points over two-dimensional intervals.  Consider several ways to perform.  Let's start with a description of the x and y data arrays obtained from the multidimensional Gaussian distribution: <br><pre> <code class="hljs lua">In[<span class="hljs-number"><span class="hljs-number">6</span></span>]: mean = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] cov = <span class="hljs-string"><span class="hljs-string">[[1, 1], [1, 2]]</span></span> x, y = np.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>.multivariate_normal(mean, cov, <span class="hljs-number"><span class="hljs-number">10000</span></span>).T</code> </pre> <br><h3>  Function plt.hist2d: two-dimensional histogram </h3><br>  One of the easiest ways to draw a two-dimensional histogram is to use the Mattlotlib library's plt.hist2d function (Fig. 4.38): <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">12</span></span>]: plt.hist2d(x, y, bins=<span class="hljs-number"><span class="hljs-number">30</span></span>, cmap=<span class="hljs-symbol"><span class="hljs-symbol">'Blues</span></span>') cb = plt.colorbar() cb.set_label(<span class="hljs-symbol"><span class="hljs-symbol">'counts</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bin') #   </code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/8a/59dc8ae17e435571117679.png" alt="image"></div><br>  The plt.hist2d function, like the plt.hist function, has many additional parameters for fine-tuning the chart and splitting into intervals, described in detail in its docstring.  In the same way as the plt.hist function has the equivalent of np.histogram, so the plt.hist2d function has the equivalent of np.histogram2d, which is used as follows: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]: counts, xedges, yedges = np.histogram2d(x, y, bins=<span class="hljs-number"><span class="hljs-number">30</span></span>)</code> </pre> <br>  For a generalization of the partitioning of the histogram into a number of dimensions greater than 2, see the function np.histogramdd. <br><br><h3>  Function plt.hexbin: hexagonal split into intervals </h3><br>  A two-dimensional histogram creates a mosaic representation of the squares along the coordinate axes.  Another geometric shape for a similar mosaic representation is a regular hexagon.  For these purposes, the Matplotlib library provides the plt.hexbin function - a two-dimensional data set, divided by intervals on a grid of hexagons (Fig. 4.39): <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">9</span></span>]: plt.hexbin(x, y, gridsize=<span class="hljs-number"><span class="hljs-number">30</span></span>, cmap=<span class="hljs-symbol"><span class="hljs-symbol">'Blues</span></span>') cb = plt.colorbar(<span class="hljs-keyword"><span class="hljs-keyword">label</span></span>=<span class="hljs-symbol"><span class="hljs-symbol">'count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bin') #   </code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/90/59dc901317eca125455169.png" alt="image"></div><br>  The plt.hexbin function has a lot of interesting parameters, including the ability to set the weight for each point and change the output value for each interval to any summary indicator of the NumPy library (average weights, standard deviation of weights, etc.). <br><br><h3>  Nuclear density estimation </h3><br>  Another frequently used method for estimating densities in a multidimensional space is kernel density estimation (KDE).  We will look at it in more detail in the ‚ÄúLook deeper: nuclear density distribution‚Äù section in Chapter 5, but for now, we can say that KDE can be represented as a way of ‚Äúsmearing‚Äù points in space and adding up the results to obtain a smooth function.  The scipy.stats package has an extremely fast and easy KDE implementation.  Here is a short example of using KDE on the above data (fig. 4.40): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.stats <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gaussian_kde #      [Ndim, Nsamples] data = np.vstack([x, y]) kde = gaussian_kde(data) #      xgrid = np.linspace(<span class="hljs-number"><span class="hljs-number">-3.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) ygrid = np.linspace(<span class="hljs-number"><span class="hljs-number">-6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) Xgrid, Ygrid = np.meshgrid(xgrid, ygrid) Z = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()])) #       plt.imshow(Z.reshape(Xgrid.shape), origin=<span class="hljs-string"><span class="hljs-string">'lower'</span></span>, aspect=<span class="hljs-string"><span class="hljs-string">'auto'</span></span>, extent=[<span class="hljs-number"><span class="hljs-number">-3.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.5</span></span>, <span class="hljs-number"><span class="hljs-number">-6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], cmap=<span class="hljs-string"><span class="hljs-string">'Blues'</span></span>) cb = plt.colorbar() cb.set_label("density") # </code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/90/59dc90d5b4bf0894491955.png" alt="image"></div><br>  The smoothing length of the KDE method allows you to effectively choose a compromise between smoothness and detail (one example of the ubiquitous tradeoffs between displacement and dispersion).  There is an extensive literature on the selection of an appropriate smoothing length: the gaussian_kde function uses a rule of thumb to find a quasi-optimal smoothing length for input data. <br><br>  The SciPy ecosystem also has other implementations of the KDE method, each with its own strengths and weaknesses, such as the sklearn.neighbors.KernelDensity and statsmodels.nonparametric.kernel_density.KDEMultivariate methods.  Using the Matplotlib library for KDE-based visualizations requires writing unnecessary code.  The Seaborn library, which we will discuss in the ‚ÄúRendering with the Seaborn Library‚Äù section of this chapter, suggests an API with much more succinct syntax for creating such visualizations. <br><br><h3>  User legend settings on graphs </h3><br>  Greater clarity of the graphics is provided by setting labels for various elements of the graph.  We have previously considered the creation of a simple legend, here we demonstrate the possibility of customizing the location and appearance of the legends in Matplotlib. <br>  Using the plt.legend () command, you can automatically create the simplest legend for any marked chart elements (Fig. 4.41): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.style.use(<span class="hljs-string"><span class="hljs-string">'classic'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]: %matplotlib <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]: x = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) fig, ax = plt.subplots() ax.plot(x, np.sin(x), <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'Sine'</span></span>) #  ax.plot(x, np.cos(x), <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'Cosine'</span></span>) #  ax.axis(<span class="hljs-string"><span class="hljs-string">'equal'</span></span>) leg = ax.legend();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/91/59dc91878861a507297834.png" alt="image"></div><br>  There are many options for custom settings such graphics that we may need.  For example, you can set the location of the legend and disable the frame (Fig. 4.42): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]: ax.legend(loc=<span class="hljs-string"><span class="hljs-string">'upper left'</span></span>, frameon=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) fig</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/91/59dc91d0aeb07177335481.png" alt="image"></div><br>  You can also use the ncol command to set the number of columns in the legend (Fig. 4.43): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]: ax.legend(frameon=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, loc=<span class="hljs-string"><span class="hljs-string">'lower center'</span></span>, ncol=<span class="hljs-number"><span class="hljs-number">2</span></span>) fig</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/93/59dc9324f0b7c169872952.png" alt="image"></div><br>  You can use a rounded rectangular frame (fancybox) for the legend or add a shadow, change the transparency (alpha factor) of the frame or field near the text (fig. 4.44): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]: ax.legend(fancybox=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, framealpha=<span class="hljs-number"><span class="hljs-number">1</span></span>, shadow=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, borderpad=<span class="hljs-number"><span class="hljs-number">1</span></span>) fig</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/93/59dc936ec2ae9751324097.png" alt="image"></div><br>  For more information about the available settings for legends, see the plt.legend docstring function. <br><br><h3>  Select items for the legend </h3><br>  By default, the legend includes all tagged items.  If we do not need this, we can indicate which elements and labels should be present in the legend using the objects returned by the graphing commands.  The plt.plot () command can draw multiple lines in one call and return a list of created line instances.  To specify which elements to use, it is enough to transfer any of them to the plt.legend () function together with the specified labels (Fig. 4.45): <br><br><pre> <code class="hljs lua">In[<span class="hljs-number"><span class="hljs-number">7</span></span>]: y = np.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x[:, np.newaxis] + np.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span> * np.arange(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> = plt.plot(x, y) # <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>      plt.Line2D plt.legend(<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>[:<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-string"><span class="hljs-string">'first'</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>]); # , </code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/93/59dc93ffa5f1c861788295.png" alt="image"></div><br>  Usually in practice it is more convenient for me to use the first method, indicating the labels directly for the elements that need to be displayed in the legend (Fig. 4.46) <br><br><pre> <code class="hljs matlab">In[<span class="hljs-number"><span class="hljs-number">8</span></span>]: plt.<span class="hljs-built_in"><span class="hljs-built_in">plot</span></span>(x, y[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], label=<span class="hljs-string"><span class="hljs-string">'first'</span></span>) plt.<span class="hljs-built_in"><span class="hljs-built_in">plot</span></span>(x, y[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], label=<span class="hljs-string"><span class="hljs-string">'second'</span></span>) plt.<span class="hljs-built_in"><span class="hljs-built_in">plot</span></span>(x, y[:, <span class="hljs-number"><span class="hljs-number">2</span></span>:]) plt.<span class="hljs-built_in"><span class="hljs-built_in">legend</span></span>(framealpha=<span class="hljs-number"><span class="hljs-number">1</span></span>, frameon=True);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/94/59dc9452577f5441670204.png" alt="image"></div><br>  Note that by default, the legend ignores all elements for which the label attribute is not set. <br><br><h3>  Setting the legend for points of various sizes </h3><br>  Sometimes the default legend capacity is not enough for our schedule.  Suppose you use points of different sizes to visualize certain characteristics of the data and would like to create a legend that reflects this.  Here is an example in which we will reflect the population of California cities using point size.  We need a legend with a point size scale, and we will create it by displaying tagged data on the chart without the tags themselves (Fig. 4.47): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">9</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd cities = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'data/california_cities.csv'</span></span>) #     lat, lon = cities[<span class="hljs-string"><span class="hljs-string">'latd'</span></span>], cities[<span class="hljs-string"><span class="hljs-string">'longd'</span></span>] population, area = cities[<span class="hljs-string"><span class="hljs-string">'population_total'</span></span>], cities[<span class="hljs-string"><span class="hljs-string">'area_total_km2'</span></span>] #     , #     ,    plt.scatter(lon, lat, label=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, c=np.log10(population), cmap=<span class="hljs-string"><span class="hljs-string">'viridis'</span></span>, s=area, linewidth=<span class="hljs-number"><span class="hljs-number">0</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.5</span></span>) plt.axis(aspect=<span class="hljs-string"><span class="hljs-string">'equal'</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'longitude'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'latitude'</span></span>) plt.colorbar(label=<span class="hljs-string"><span class="hljs-string">'log$_{10}$(population)'</span></span>) plt.clim(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) #  : #           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> area <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>]: plt.scatter([], [], c=<span class="hljs-string"><span class="hljs-string">'k'</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.3</span></span>, s=area, label=str(area) + <span class="hljs-string"><span class="hljs-string">' km$^2$'</span></span>) plt.legend(scatterpoints=<span class="hljs-number"><span class="hljs-number">1</span></span>, frameon=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, labelspacing=<span class="hljs-number"><span class="hljs-number">1</span></span>, title=<span class="hljs-string"><span class="hljs-string">'City Area'</span></span>) #  plt.title(<span class="hljs-string"><span class="hljs-string">'California Cities: Area and Population'</span></span>); #  :   </code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/95/59dc95bfa4d48399720847.png" alt="image"></div><br>  The legend always refers to any object on the graph, so if we need to display an object of a particular type, we must first draw it on the graph.  In this case, the objects we need (gray circles) are not on the graph, so we go to the trick and display empty lists on the chart.  Please note that the legend lists only those graph elements for which a label is specified. <br><br>  We have created by displaying empty lists marked objects, which are then collected in the legend.  Now the legend gives us useful information.  This strategy can be used to create more complex visualizations. <br><br>  Note that in the case of similar geographic data, the graph would become clearer if the state borders and other cartographic elements are displayed on it.  A great tool for this is the optional Basemap utility set for the Matplotlib library, which we will look at in the ‚ÄúDisplaying Geographic Data with a Basemap‚Äù section of this chapter. <br><br><h3>  Display several legends </h3><br>  Sometimes when plotting a graph, it is necessary to add several legends to it for the same coordinate system.  Unfortunately, the Matplotlib library does not greatly simplify this task: using the standard legend interface, you can create only one legend for the entire schedule.  If you try to create a second legend using the plt.legend () and ax.legend () functions, it will simply override the first one.  This problem can be solved by creating a new painter (artist) initially for the legend, then manually adding the second painter to the chart using the ax.add_artist () low-level method (Fig. 4.48): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]: fig, ax = plt.subplots() lines = [] styles = [<span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'--'</span></span>, <span class="hljs-string"><span class="hljs-string">'-.'</span></span>, <span class="hljs-string"><span class="hljs-string">':'</span></span>] x = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): lines += ax.plot(x, np.sin(x - i * np.pi / <span class="hljs-number"><span class="hljs-number">2</span></span>), styles[i], color=<span class="hljs-string"><span class="hljs-string">'black'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'equal'</span></span>) #       ax.legend(lines[:<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-string"><span class="hljs-string">'line A'</span></span>, <span class="hljs-string"><span class="hljs-string">'line B'</span></span>], #  ,  B loc=<span class="hljs-string"><span class="hljs-string">'upper right'</span></span>, frameon=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) #        <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> matplotlib.legend <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Legend leg = Legend(ax, lines[<span class="hljs-number"><span class="hljs-number">2</span></span>:], [<span class="hljs-string"><span class="hljs-string">'line C'</span></span>, <span class="hljs-string"><span class="hljs-string">'line D'</span></span>], #  ,  D loc=<span class="hljs-string"><span class="hljs-string">'lower right'</span></span>, frameon=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) ax.add_artist(leg);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/96/59dc96ed54d74124352746.png" alt="image"></div><br>  We briefly reviewed the low-level drawing objects that make up any graph of the Matplotlib library.  If you look at the source code for the ax.legend () method (recall that you can do this in the IPython shell notepad using the legend ?? command), you will see that this function simply consists of the logic of creating a suitable Legend painter, which is then saved in the attribute legend_ and added to the picture when drawing graphics. <br><br><h3>  Custom color scale settings </h3><br>  Graphic legends display the discrete label correspondence to discrete points.  In the case of continuous labels based on the color of dots, lines or areas, a tool such as a color scale is perfect.  In the Matplotlib library, the color scale is a separate coordinate system that provides the key to the meaning of the colors on the graph.  Since this book is printed in black and white, there is an additional online application for this section, in which you can look at the original color charts (https://github.com/jakevdp/PythonDataScienceHandbook).  Let's start with setting up a notebook for plotting graphs and importing the necessary functions: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.style.use(<span class="hljs-string"><span class="hljs-string">'classic'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]: %matplotlib <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre> <br>  The simplest color scale can be created using the plt.colorbar function (Fig. 4.49): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]: x = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) I = np.sin(x) * np.cos(x[:, np.newaxis]) plt.imshow(I) plt.colorbar();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/97/59dc97a1e5c23418054987.png" alt="image"></div><br>  Next, we will look at a few ideas for customizing the color scale and using them effectively in different situations.  You can set a color map using the cmap argument of the function for creating a visualization (Fig. 4.50): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]: plt.imshow(I, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>);</code> </pre> <br>  All available color maps are contained in the plt.cm namespace.  You can get a complete list of built-in options using TAB autocompletion in the IPython shell: <br><br><pre> <code class="hljs xml">plt.cm.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TAB</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  But the possibility of choosing a color map is only the first step, it is much more important to choose among the available options!  The choice turns out to be much more subtle than you might expect. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/98/59dc980d62aec932613670.png" alt="image"></div><br><h3>  Choosing a color map </h3><br>  Comprehensive consideration of the choice of colors in the visualization is beyond the scope of this book, but on this issue you can read the article Ten Simple Rules for Better Figures ( <a href="http://journals.plos.org/ploscompbiol/article%3Fid%3D10.1371/journal.pcbi.1003833">‚ÄúTen simple rules for improving drawings‚Äù</a> ).  The online documentation of the <a href="http://matplotlib.org/1.4.1/users/colormaps.html">Matplotlib library</a> also contains interesting information on choosing a color map. <br><br>  You should be aware that there are three different categories of color cards: <br><br><ul><li>  consecutive color maps.  Consist of one continuous sequence of colors (for example, binary or viridis); </li><li>  divergent color cards.  Usually contain two well distinguishable colors reflecting positive and negative deviations from the mean (for example, RdBu or PuOr); </li><li>  high-quality color maps.  They mix colors without any clear order (for example, rainbow or jet). </li></ul><br>  The jet color map, used by default in the Matplotlib library up to version 2.0, is an example of a quality color map.  Her choice as the default color map was very unfortunate, since quality color maps are poorly suited to reflect quantitative data: they usually do not reflect a uniform increase in brightness when moving along the scale. <br><br>  This can be demonstrated by converting the jet color scale into a black and white representation (Fig. 4.51): <br><br><pre> <code class="hljs python">In[<span class="hljs-number"><span class="hljs-number">5</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> matplotlib.colors <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LinearSegmentedColormap <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grayscale_cmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmap)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       """</span></span> cmap = plt.cm.get_cmap(cmap) colors = cmap(np.arange(cmap.N)) <span class="hljs-comment"><span class="hljs-comment">#  RGBA       # . http://alienryderflex.com/hsp.html RGB_weight = [0.299, 0.587, 0.114] luminance = np.sqrt(np.dot(colors[:, :3] ** 2, RGB_weight)) colors[:, :3] = luminance[:, np.newaxis] return LinearSegmentedColormap.from_list(cmap.name + "_gray", colors, cmap.N) def view_colormap(cmap): """      """ cmap = plt.cm.get_cmap(cmap) colors = cmap(np.arange(cmap.N)) cmap = grayscale_cmap(cmap) grayscale = cmap(np.arange(cmap.N)) fig, ax = plt.subplots(2, figsize=(6, 2), subplot_kw=dict(xticks=[], yticks=[])) ax[0].imshow([colors], extent=[0, 10, 0, 1]) ax[1].imshow([grayscale], extent=[0, 10, 0, 1]) In[6]: view_colormap('jet')</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/9b/59dc9b454ed66599568182.png" alt="image"></div><br>  Note the bright bands in the achromatic image.  Even in full color, this uneven brightness means that certain parts of the range of colors will attract attention, potentially leading to an emphasis on irrelevant colors. <br>  parts of the data set.  It is better to use color maps such as viridis (used by default, starting from version 2.0 of the Matplotlib library), specially designed to evenly change the brightness over a range.  Thus, they are not only consistent with our color perception, but also are converted for printing purposes in shades of gray (Fig. 4.52): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">7</span></span>]: view_colormap(<span class="hljs-string"><span class="hljs-string">'viridis'</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/9b/59dc9b96c57b2264557421.png" alt="image"></div><br>  If you prefer rainbow color schemes, a cubehelix colormap (Fig. 4.53) is a good option for continuous data: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]: view_colormap(<span class="hljs-string"><span class="hljs-string">'cubehelix'</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/9c/59dc9c118e413503370384.png" alt="image"></div><br>  In other cases, for example, to display positive and negative deviations from the mean, such two-color color scale maps like RdBu (short for Red - Blue - "red - blue") may be convenient.  However, as you can see in fig.  4.54, such information will be lost upon transition to shades of gray! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">9</span></span>]: view_colormap(<span class="hljs-string"><span class="hljs-string">'RdBu'</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/dc/9c/59dc9caa24ad2292229367.png" alt="image"></div><br>  Next we will see examples of using some of these color maps. <br>  There are many color maps in the Matplotlib library, to view their list, you can use the IPython shell to view the contents of the plt.cm sub-module.  A more basic approach to using colors in the Python language can be found in the tools and documentation for the Seaborn library (see the "Rendering with the Seaborn Library" section of this chapter). <br><br>  ¬ªIn more detail with the book can be found <a href="https://www.piter.com/collection/new/product/python-dlya-slozhnyh-zadach-nauka-o-dannyh-i-mashinnoe-obuchenie">publisher site</a> <br>  ¬ª <a href="http://storage.piter.com/upload/contents/978549603068/978549603068_X.pdf">Table of Contents</a> <br>  ¬ª <a href="http://storage.piter.com/upload/contents/978549603068/978549603068_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley a discount of 20% for the coupon - <b>Python</b> </div><p>Source: <a href="https://habr.com/ru/post/339766/">https://habr.com/ru/post/339766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339754/index.html">Educated youth. About patterns and processes</a></li>
<li><a href="../339756/index.html">Non-satellite positioning and navigation systems</a></li>
<li><a href="../339758/index.html">IdM implementation. Part 1: What is IdM and what functionality does it apply to?</a></li>
<li><a href="../339760/index.html">[Translation] How I learned to program AI for the last two months</a></li>
<li><a href="../339762/index.html">DevOps now - like version control ten years ago, everyone will be there soon</a></li>
<li><a href="../339770/index.html">Javascript es8 and transition to async / await</a></li>
<li><a href="../339772/index.html">WeChat. Serialize the object - get SMS</a></li>
<li><a href="../339774/index.html">Memorize Less, Know More: Operator Tips</a></li>
<li><a href="../339782/index.html">Black triangles</a></li>
<li><a href="../339784/index.html">The relationship between the number of combinations and the binomial coefficients</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>