<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithreading in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust began as a project that solved two difficult problems: 



- How to ensure security (working with memory) in system programming? 
- How to make m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithreading in Rust</h1><div class="post__text post__text-html js-mediator-article">  Rust began as a project that solved two difficult problems: <br><br><ul><li>  How to ensure security (working with memory) in system programming? </li><li>  How to make multi-threaded programming painless? </li></ul><br>  Initially, these problems did not seem to be related to each other, but to our surprise, their solution turned out to be the same ‚Äî <strong>problems with multithreading solve the same tools that provide security</strong> . <br><br>  Errors of working with memory and errors when working with several threads are often reduced to the fact that the code accesses some data in spite of the fact that it should not do this.  The secret weapon of Rust against this is the concept <em>of data ownership</em> , a way to control access to data, which system programmers try to adhere on their own, but which Rust checks statically. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From the point of view of security of working with memory, this means that you can not use the garbage collector <em>and at the same time</em> not be afraid of segfolts, because Rust will not allow you to make a mistake. <br><br>  In terms of multi-threading, this means that you can use different paradigms (message passing, shared state, lock-free data structures, pure functional programming), and Rust will avoid the most common pitfalls. <br><br>  Here are some features of multi-threaded programming in Rust: <br><a name="habracut"></a><br><ul><li>  <a href="http://static.rust-lang.org/doc/master/std/sync/mpsc/index.html">Channels</a> transfer ownership of the data that is sent through them, so you can send a pointer through one channel from one stream to another and not be afraid that there will be a race for access through this pointer.  <strong>Rust channels provide thread isolation</strong> . </li><li>  <a href="http://static.rust-lang.org/doc/master/std/sync/struct.Mutex.html">Locks</a> (lock'i) own the data they protect, and Rust guarantees that access to this data can be obtained only when the lock is captured.  The state is never shared between threads randomly.  <b>The concept of "synchronize data, not code" in Rust is obligatory</b> . </li><li>  For each data type, it is known whether it can be <a href="http://static.rust-lang.org/doc/master/std/marker/trait.Send.html">sent</a> between streams or whether it can be <a href="http://static.rust-lang.org/doc/master/std/marker/trait.Sync.html">accessed</a> from several streams simultaneously, and Rust ensures the security of these actions;  therefore, data races are excluded, even for lock-free data structures.  <strong>Thread safety is not just reflected in the documentation - it is the law</strong> . </li><li>  Moreover, you can <a href="http://static.rust-lang.org/doc/master/std/thread/fn.scoped.html">use a</a> stack of one thread from another, and Rust will statically ensure its existence as long as other threads use it.  <strong>Even the riskiest forms of data sharing are guaranteed to be safe in Rust.</strong> </li></ul><br>  All these advantages derive from the data ownership model, and all the locks, channels, lock-free data structures, etc. described above are defined in the libraries, and not in the language itself.  This means that the Rust approach to multithreading is very expandable - new libraries can implement other paradigms and help prevent new classes of errors simply by providing a new API based on Rust features related to data ownership. <br><br>  The purpose of this post is to show how this is done. <br><br><h2>  Basics: Data Ownership </h2><br><blockquote>  We'll start by reviewing the ownership and borrowing systems in Rust.  If you are already familiar with them, then you can skip both parts of the "basics" and go directly to multithreading.  If you want to understand these concepts deeper, I highly recommend <a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">this article written by Yehuda Katz</a> .  In the official <a href="http://doc.rust-lang.org/book/ownership.html">book of Rust</a> you will find even more detailed explanations. <br></blockquote><br>  In Rust, each value has a "domain of ownership", and the transfer or return of a value means the transfer of ownership ("transfer") to a new area.  When the area ends, all values ‚Äã‚Äãthat it owns by this moment are destroyed. <br><br>  Consider a few simple examples.  Suppose we create a vector and put several elements into it: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_vec</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-comment"><span class="hljs-comment">//    make_vec vec.push(0); vec.push(1); //   , `vec`  }</span></span></code> </pre> <br>  The scope in which the value is created becomes its owner.  In this case, the area that owns the <code>vec</code> is the body of <code>make_vec</code> .  The owner can do with the <code>vec</code> anything, in particular, change, adding elements.  At the end of the scope, it still owns the <code>vec</code> , and therefore it is automatically destroyed. <br><br>  It becomes more interesting if the vector is transferred to another function or returned from a function: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_vec</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); vec.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); vec.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); vec <span class="hljs-comment"><span class="hljs-comment">//      } fn print_vec(vec: Vec&lt;i32&gt;) { //  `vec`     , //    `print_vec` for i in vec.iter() { println!("{}", i) } //  `vec`  } fn use_vec() { let vec = make_vec(); //     print_vec(vec); //    `print_vec` }</span></span></code> </pre><br>  Now, just before the end of the scope, <code>make_vec</code> , <code>vec</code> passed out as the return value ‚Äî it is not destroyed.  The calling function, for example, <code>use_vec</code> , acquires ownership of the vector. <br><br>  On the other hand, the <code>print_vec</code> function takes the <code>vec</code> parameter, and ownership is passed <em>to it by the</em> calling function.  Since <code>print_vec</code> does not transfer ownership to <code>vec</code> any further, the vector is destroyed when leaving this scope. <br><br>  Once ownership of the value has been transferred somewhere else, it can no longer be used.  For example, consider the <code>use_vec</code> function: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_vec</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vec = make_vec(); <span class="hljs-comment"><span class="hljs-comment">//     print_vec(vec); //    `print_vec` for i in vec.iter() { //   `vec` println!("{}", i * 2) } }</span></span></code> </pre><br>  If you try to compile this option, the compiler will give an error: <br><br><pre> <code class="hljs sql">error: <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> moved <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-string"><span class="hljs-string">`vec`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec.iter() { ^~~</code> </pre><br>  The compiler reports that <code>vec</code> no longer available - ownership has been transferred somewhere else.  And this is very good, because by this time the vector has already been destroyed. <br><br>  The catastrophe is prevented. <br><br><h2>  Basics: Borrowing </h2><br>  So far, the code is not very convenient, because we do not need <code>print_vec</code> destroy the vector that is passed to it.  In fact, we would like to give <code>print_vec</code> <em>temporary</em> access to the vector and be able to continue using it afterwards. <br><br>  Here we need <em>borrowing</em> .  In Rust, if you have a value, you can give it temporary access to the functions that you call.  <b>Rust will automatically verify that these ‚Äúloans‚Äù will not act longer than the object that is being borrowed ‚Äúlives‚Äù.</b> <br><br>  To borrow a value, you need to create a <em>link</em> to it (the link is one of the types of pointers) using the <code>&amp;</code> operator: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_vec</span></span></span></span>(vec: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;) { <span class="hljs-comment"><span class="hljs-comment">//  `vec`    //    for i in vec.iter() { println!("{}", i) } //     } fn use_vec() { let vec = make_vec(); //     print_vec(&amp;vec); //      `print_vec` for i in vec.iter() { //   `vec` println!("{}", i * 2) } //  vec  }</span></span></code> </pre><br>  Now <code>print_vec</code> accepts the vector reference, and <code>use_vec</code> gives the "loan" vector: <code>&amp;vec</code> .  Since the borrowing is temporary, <code>use_vec</code> retains ownership of the vector and can continue to use it after <code>print_vec</code> returns control (and the <code>vec</code> expired). <br><br>  Each link is valid only in a specific scope, which the compiler automatically determines.  Links come in two forms. <br><br><ul><li>  Immunitable <code>&amp;T</code> link that allows sharing, but prohibits changes.  There may be several <code>&amp;T</code> links on the same value, but the value itself cannot be changed as long as these links exist. </li><li>  A mutable <code>&amp;mut T</code> reference that allows modification, but not sharing.  If a value exists on the <code>&amp;mut T</code> link, there are no other links at that time to the same value, but the value can be changed. </li></ul><br>  Rust checks that these rules are executed; at compile time, borrowing has no overhead during program execution. <br><br>  Why do we need two types of links?  Consider a function of the following form: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_all</span></span></span></span>(from: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, to: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> from.iter() { to.push(*i); } }</code> </pre><br>  This function passes through each element of the vector, placing them all in a different vector.  The iterator (created by the <code>iter()</code> method) contains references to the vector in the current and end positions, and the current position "moves" in the end direction. <br><br>  What happens if we call this function with the same vector in both arguments? <br><br><pre> <code class="rust hljs">push_all(&amp;vec, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec)</code> </pre><br>  This will lead to disaster!  When we put new elements into a vector, sometimes it will need to change the size, for which a new memory is allocated, into which all elements are copied.  In the iterator, there will be a "hanging" link in the old memory, which will lead to unsafe memory work, i.e.  to segfault or something else worse. <br><br>  Fortunately, Rust guarantees that while there is a mutable borrowing, there can be no other references to the object, and therefore the code above will lead to a compilation error: <br><br><pre> <code class="hljs pgsql">error: cannot borrow `vec` <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mutable because it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> borrowed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> push_all(&amp;vec, &amp;mut vec); ^~~</code> </pre><br>  The catastrophe is prevented. <br><br><h2>  Messaging </h2><br>  Now, after we briefly examined what ownership and borrowing are, let's see how these concepts come in handy in multi-threaded programming. <br><br>  There are many approaches to writing multi-threaded programs, but one of the simplest of them is the transfer of messages when streams or actors communicate by sending messages to each other.  Proponents of this style especially pay attention to the fact that it links data sharing and communication between actors: <br><br><blockquote>  Do not communicate through memory sharing;  on the contrary, share through communication. <br>  - <a href="http://golang.org/doc/effective_go.html">Effective Go</a> <br></blockquote><br>  <strong>Possession of data in Rust makes it very easy to convert this tip to a rule that is checked by the compiler.</strong>  Consider this API for working with channels (although the <a href="http://static.rust-lang.org/doc/master/std/sync/mpsc/index.html">channels in the standard Rust library are</a> slightly different): <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(chan: &amp;Channel&lt;T&gt;, t: T); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recv</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(chan: &amp;Channel&lt;T&gt;) -&gt; T;</code> </pre><br>  Channels are generic types that are parameterized by the type of data they pass through themselves (this is indicated by <code>&lt;T: Send&gt;</code> ).  A <code>Send</code> restriction to <code>T</code> means that <code>T</code> can be safely transferred between threads.  We will come back to this later, but for now it‚Äôs enough for us to know that <code>Vec&lt;i32&gt;</code> is <code>Send</code> . <br><br>  As always, passing <code>T</code> to the <code>send</code> function also means transferring ownership of <code>T</code>  It follows that such code will not compile: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  chan: Channel&lt;Vec&lt;i32&gt;&gt; let mut vec = Vec::new(); //  -  send(&amp;chan, vec); print_vec(&amp;vec);</span></span></code> </pre><br>  Here, the thread creates a vector, sends it to another thread, and then continues to use it.  The stream that received the vector could change it at the time when the first stream is still running, so calling <code>print_vec</code> could lead to a race or, for example, an error like use-after-free. <br><br>  Instead, the Rust compiler will <code>print_vec</code> error on the <code>print_vec</code> call: <br><br><pre> <code class="hljs sql">Error: <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> moved <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-string"><span class="hljs-string">`vec`</span></span></code> </pre><br>  The catastrophe is prevented. <br><br><h2>  Locks </h2><br>  Another way to work with many threads is to organize the communication of threads through a passive shared state. <br><br>  In multithreading with shared state of notoriety.  It is very easy to forget to take a lock, or somehow change the wrong data at the wrong time, with a catastrophic result ‚Äî so easy that many programmers refuse to do this multithreaded programming completely. <br><br>  Rust's approach is as follows: <br><br><ol><li>  One way or another, shared state multithreading is the fundamental programming style required for system code, maximum performance and for implementing other styles of multi-threaded programming. </li><li>  In fact, the problem lies in a <em>randomly</em> shared state. </li></ol><br>  The purpose of Rust is to provide you with tools to help you use the shared state, both when you use locks and when you use a lock-free data structure. <br><br>  Rust streams are "isolated" automatically from each other thanks to the concept of data ownership.  Recording can occur only when the stream has mutable access to the data: either due to the fact that the stream owns them, or due to the presence of a mutable link.  Anyway, it is guaranteed <strong>that the stream will be the only one who at a given time can access the data</strong> .  Consider the implementation of locks in Rust to understand how this works. <br><br>  Here is a simplified version of their API (the version <a href="http://static.rust-lang.org/doc/master/std/sync/struct.Mutex.html">in the standard library is</a> more ergonomic): <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//    fn mutex&lt;T: Send&gt;(t: T) -&gt; Mutex&lt;T&gt;; //   fn lock&lt;T: Send&gt;(mutex: &amp;Mutex&lt;T&gt;) -&gt; MutexGuard&lt;T&gt;; //    ,   fn access&lt;T: Send&gt;(guard: &amp;mut MutexGuard&lt;T&gt;) -&gt; &amp;mut T;</span></span></code> </pre><br>  This interface is rather unusual in several aspects. <br><br>  First, the <code>Mutex</code> type has a type parameter <code>T</code> , meaning the <strong>data protected by this lock</strong> .  When you create a mutex, you transfer ownership of the data to it, immediately losing access to it.  (After the lock is created, it remains in the untapped state) <br><br>  Next, you can use the <code>lock</code> function to block the stream until it seizes the lock.  A feature of this function is that it returns a special fuse value, <code>MutexGuard&lt;T&gt;</code> .  This object automatically releases the lock after it is destroyed - there is no separate <code>unlock</code> function here. <br><br>  The only way to access the data is the <code>access</code> function, which turns the mutable link to the fuse into a mutable link to the data (with a shorter lifetime): <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_lock</span></span></span></span>(mutex: &amp;Mutex&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       ; //        let mut guard = lock(mutex); //        //   let vec = access(&amp;mut guard); // vec   `&amp;mut Vec&lt;i32&gt;` vec.push(3); //     ( `guard` ) }</span></span></code> </pre><br>  Here we can note two key points: <br><br><ul><li>  the mutable link that is returned by the <code>access</code> function cannot act longer than the <code>MutexGuard</code> from which it was derived; </li><li>  the lock is released only when <code>MutexGuard</code> destroyed. </li></ul><br>  It turns out that <strong>Rust does not violate the rules for working with locks: it will not give you the opportunity to gain access to the data protected by the mutex if you have not captured it first</strong> .  Any attempt to work around this will result in a compilation error.  For example, consider this erroneous "refactoring": <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_lock</span></span></span></span>(mutex: &amp;Mutex&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vec = { <span class="hljs-comment"><span class="hljs-comment">//   let mut guard = lock(mutex); //      access(&amp;mut guard) //   ,   }; //   ,    vec.push(3); }</span></span></code> </pre><br>  The Rust compiler generates an error that indicates exactly the problem: <br><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">error</span></span>: `guard` does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> live long enough <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>(&amp;mut guard) ^~~~~</code> </pre><br>  The catastrophe is prevented. <br><br><h2>  Thread Safety and Trait Send </h2><br>  It is logical to separate data types into those that are "thread-safe" and those that are not.  Data structures that are safe to use from multiple threads use tools to synchronize within themselves. <br><br>  For example, two types of smart pointers are supplied with Rust, using reference counting: <br><br><ul><li>  <code>Rc&lt;T&gt;</code> , which implements reference counting using simple read / write operations.  It is not thread safe. </li><li>  <code>Arc&lt;T&gt;</code> , which releases reference counting using <em>atomic</em> operations.  It is thread safe. </li></ul><br>  Atomic hardware operations used in <code>Arc</code> are computationally more expensive than simple operations used in <code>Rc</code> , so <code>Rc</code> preferable in a normal situation.  On the other hand, it is very important to ensure that <code>Rc&lt;T&gt;</code> never transmitted between threads, because this can lead to races breaking the link count. <br><br>  The usual approach comes down to thorough documentation.  In most languages, there is no <em>semantic</em> difference between thread-safe and unsafe types. <br><br>  In Rust, the entire set of types is divided into two types - those that implement the <a href="http://static.rust-lang.org/doc/master/std/marker/trait.Send.html"><code>Send</code></a> trait, which means that these types can be safely moved between streams and those that do not implement it ( <code>!Send</code> ), which, respectively, means the opposite.  If all components of a type are <code>Send</code> , then he himself is a <code>Send</code> , which covers most types.  Some basic types are not thread-safe in nature, so types such as <code>Arc</code> can be explicitly marked as <code>Send</code> , which means a hint to the compiler: "Believe me, I provided all the necessary synchronization here." <br><br>  Naturally, <code>Arc</code> is <code>Send</code> , and <code>Rc</code> is not. <br><br>  We have already seen that <code>Channel</code> and <code>Mutex</code> work only with <code>Send</code> data.  Since they are the very bridge through which data travels between streams, they also provide the guarantees associated with the <code>Send</code> . <br><br>  Thus, Rust programmers can take advantage of <code>Rc</code> and other types of data that are unsafe for use in a multi-threaded environment, being sure that if they try to randomly transfer such types to another stream, the Rust compiler will report: <br><br><pre> <code class="hljs rust">`Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;&gt;` cannot <span class="hljs-keyword"><span class="hljs-keyword">be</span></span> sent between threads safely</code> </pre><br>  The catastrophe is prevented. <br><br><h2>  Stack sharing: scoped </h2><br>  Until now, all data structures were created on a heap, which was then used from several threads.  But what if we need to start a thread that uses data that "lives" on the stack of the current thread?  It may be dangerous: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-comment"><span class="hljs-comment">// fill the vector thread::spawn(|| { print_vec(&amp;vec) }) }</span></span></code> </pre><br>  The child thread accepts a reference to <code>vec</code> , which, in turn, is on the <code>parent</code> stack.  When <code>parent</code> returns, the stack is cleared, but the child thread does not know about it.  Oh! <br><br>  To avoid such memory problems, the main API for running threads in Rust looks like this: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;F&gt;(f: F) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>, ...</code> </pre><br>  The restriction <code>'static</code> means, roughly speaking, that no borrowed data should be used in the closure.  In particular, this means that code like <code>parent</code> above will not compile: <br><br><pre> <code class="hljs perl">error: <span class="hljs-string"><span class="hljs-string">`vec`</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> live long enough</code> </pre><br>  In essence, this eliminates the possibility that the <code>parent</code> stack can be cleared when other threads are still using it.  The catastrophe is prevented. <br><br>  But there is another way to guarantee security: make sure the parent stack stays in order until the child thread terminates.  Such a pattern is called fork-join-programming and is often used when developing parallel divide-and-conquer algorithms.  Rust supports this approach using a <a href="http://static.rust-lang.org/doc/master/std/thread/fn.scoped.html">special function</a> to start a child thread: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scoped</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F&gt;(f: F) -&gt; JoinGuard&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, ...</code> </pre><br>  This API has two key differences from <code>spawn</code> , described above. <br><br><ul><li>  Using the parameter <code>'a</code> instead of <code>'static</code> .  This parameter denotes the scope, which is the upper limit of all borrowings inside the closure <code>f</code> . </li><li>  The presence of the return value, <code>JoinGuard</code> .  As its name suggests, <code>JoinGuard</code> ensures that the parent thread joins the child thread (waiting for it), implicitly performing the join operation in the destructor (if it has not been explicitly executed yet). </li></ul><br>  Due to the use of the <code>'a</code> parameter, the <code>JoinGuard</code> object <strong>cannot go out of scope, covering all the data that is borrowed by the closure <code>f</code></strong> .  In other words, Rust ensures that the parent thread will wait for the child thread to complete before clearing its stack (which the child thread can access). <br><br>  Therefore, the above example can be corrected as follows: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-comment"><span class="hljs-comment">//   let guard = thread::scoped(|| { print_vec(&amp;vec) }); //   ,  //     }</span></span></code> </pre><br>  Thus, in Rust you can freely use the data placed on the stack in the child threads, being sure that the compiler will check for the presence of all the necessary synchronization operations. <br><br>  <strong>Translator's note</strong> .  Literally on the same day that this article came out, the opportunity <a href="https://github.com/rust-lang/rust/issues/24292">was found</a> to violate the guarantees provided by <code>scoped</code> in a safe code.  Because of this, the <code>thread::scoped</code> was <a href="https://github.com/rust-lang/rust/pull/24385">urgently destabilized</a> , so it cannot be used with the beta version of the compiler, but only with nightly.  This problem is planned to somehow fix for release 1.0. <br><br><h2>  Data race </h2><br>  Now we have examined enough examples to finally make a fairly strict statement about the Rust approach to multithreading: the <strong>compiler prevents all <em>data races</em></strong> . <br><br><blockquote>  A data race occurs when an unsynchronized access to data from multiple streams, provided that at least one of these hits is a record. <br></blockquote><br>  Synchronization here refers to tools such as low-level atomic operations.  In fact, the statement about preventing all data races is such a way to say that you cannot accidentally ‚Äúshare a state‚Äù between threads.  Any access to data, including their change, must necessarily be carried out using <em>some</em> form of synchronization. <br><br>  Data races are only one (albeit very important) example of a race condition, but by preventing them, Rust helps to avoid other, hidden forms of racing.  For example, it is important to ensure that the atomicity of the update simultaneously several sections of memory: other threads "see" either all updates at once or none of them.  In Rust, the presence of a <code>&amp;mut</code> type reference to all relevant memory areas at the same time <strong>ensures that their changes are atomic</strong> , because no other thread can access them for reading. <br><br>  It is worth stopping for a second to comprehend this guarantee in the context of the entire set of programming languages.  Many languages ‚Äã‚Äãprovide memory security with a garbage collector, but garbage collection does not help prevent data races. <br><br>  Instead, Rust uses data ownership and borrowing to implement its two key positions: <br><br><ul><li>  safety of work with memory without garbage collection; </li><li>  multithreading without data races. </li></ul><br><h2>  Future </h2><br>  When Rust was first created, the channels were built into the language, and in general the approach to multithreading was quite categorical. <br><br>   Rust'     <em></em> . ,    ,  <code>Send</code> ,    ,         - ,  . <br><br>    ,    ,       Rust    ,          .  ,  <a href="https://github.com/carllerche/syncbox">syncbox</a>  <a href="https://github.com/huonw/simple_parallel">simple_parallel</a> , ‚Äî    ,            .  Stay with us! </div><p>Source: <a href="https://habr.com/ru/post/256211/">https://habr.com/ru/post/256211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256199/index.html">Analysis of ARPD on the example of several small mobile applications and games</a></li>
<li><a href="../256201/index.html">CLRium: continue the tour of the cities. Ekaterinburg and Peter</a></li>
<li><a href="../256203/index.html">How and why do I write articles on Habrahabr. Personal experience</a></li>
<li><a href="../256207/index.html">Using LevelDB</a></li>
<li><a href="../256209/index.html">The story of creating another robot. Part Two, "it's alive!"</a></li>
<li><a href="../256213/index.html">How to make JSON Vulnerability Protection in the server response under Yii2</a></li>
<li><a href="../256215/index.html">Breaking gas leakage sensor</a></li>
<li><a href="../256217/index.html">What you need to know about migration to Russia by September 1, 2015 from foreign infrastructure</a></li>
<li><a href="../256221/index.html">Microsoft Research Conference - Cloud Computing for Microsoft Azure, May 19 at MSU</a></li>
<li><a href="../256223/index.html">Industrial processor sources will be available for universities.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>