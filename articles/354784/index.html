<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operating systems from scratch; level 3 (upper half)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this part we will add interrupt handling and take on the scheduler. Finally, we will have elements of a multitasking operating system! Of course th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operating systems from scratch; level 3 (upper half)</h1><div class="post__text post__text-html js-mediator-article"><p><img align="left" width="300" src="https://habrastorage.org/webt/tb/sf/r2/tbsfr2zq21gutxjorkqc3cnbjyg.gif">  In this part we will add interrupt handling and take on the scheduler.  Finally, we will have elements of a multitasking operating system!  Of course this is only the beginning of the topic.  One timer interrupt, one system call, the basic part of a simple thread scheduler.  Nothing complicated.  However, with this we will prepare a springboard for creating a full-fledged system that will deal with the most genuine processes without any ‚Äúbut‚Äù.  Just like in these your linups and others.  Until the end of <em>this</em> course, a little less than half is left </p><br><p>  <a href="https://habr.com/post/349248/">Null lab</a> </p><br><p>  First Laba: the <a href="https://habr.com/post/351082/">younger half</a> and the <a href="https://habr.com/post/351774/">older half</a> </p><br><p>  The second laba: the <a href="https://habr.com/post/352414/">younger half</a> and the <a href="https://habr.com/post/353024/">older half</a> </p><br><p>  Third Laba: the <a href="https://habr.com/post/353994/">younger half</a> </p><a name="habracut"></a><br><h3 id="subfaza-e-vozvrat-iz-isklyucheniy">  Subphase E: Returns from Exceptions </h3><br><p> In this subphase, we will write code to return from the exception handler of any types, shapes and colors.  The main work will be carried out in the file <code>kernel/ext/init.S</code> and the folder <code>kernel/src/traps</code> . </p><br><h4 id="obzor">  Overview </h4><br><p>  If you try to delete an infinite loop from <code>handle_exception</code> , then most likely Raspberry Pi will enter the exception loop.  Those.  improperly processed exceptions will occur again and again, and in some cases our debug shell will crash.  This is all due to the fact that when the exception handler tries to return to the point where the code was executed, the state of the processor (especially the data in the registers) has changed without taking into account what happened in this code itself. </p><br><p>  For example, consider the following code: </p><br><pre> <code class="hljs css">1: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x3</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#127</span></span> 2: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x4</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#127</span></span> 3: <span class="hljs-selector-tag"><span class="hljs-selector-tag">brk</span></span> 10 4: <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x3</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x4</span></span> 5: <span class="hljs-selector-tag"><span class="hljs-selector-tag">beq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">safety</span></span> 6: <span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">oh_no</span></span></code> </pre> <br><p>  When a <code>brk</code> exception occurs, our exception vector is called, which ultimately causes a <code>handle_exception</code> .  This same <code>handle_exception</code> function, which is compiled by Rust, will among other things use the <code>x3</code> and <code>x4</code> registers for its dirty deeds.  When our exception handler returns to the place where the call is <code>brk</code> , the state <code>x3</code> and <code>x4</code> is not at all what we expect it to be.  Accordingly, the correct condition is not guaranteed for the <code>beq</code> instruction in line 5.  Maybe the code will jump to <code>safety</code> , and maybe not. </p><br><p>  As a result, in order for our exception handler to use the entire state of the process at its discretion, we need to make sure that we save the entire processing context (registers, etc.) before this same processor starts its work.  After the handler completes its sacred mission, we will need to restore the previously saved context.  All in the name of the fact that the external code worked flawlessly.  The process of saving / restoring context itself is called a context switch. </p><br><blockquote>  <strong>Why a context <em>switch</em> ?</strong> <br><br>  It seems that the word <em>switching</em> here is not very appropriate.  We kind of just go back to the same context, right? <br><br>  In some cases it is.  However, in reality we rarely want to return to the same execution context.  More often we want to change this very context in order for the processor to do all sorts of different useful things.  For example, when we need to implement switching between different <em>processes</em> , we will replace one context with another.  In this way we will achieve multitasking.  When we implement <em>system calls,</em> we will need to change the value of the registers in order to implement the returned values.  Even in the case of breakpoints, we need to change the <code>ELR</code> register in order for the next command to be executed (otherwise the <code>brk</code> handler will be called again and again). </blockquote><p>  In this subphase we will be engaged in the preservation / restoration of the context.  The structure that will contain our saved context will be called the trap frame.  The undocumented TrapFrame structure can be found in the <code>kernel/src/traps/trap_frame.rs</code> .  We will use this structure to access the saved registers from Rust.  On the other hand, we will fill this structure in assembly code.  It remains only to pass a pointer to this structure via the <code>tf</code> parameter to the <code>handle_exception</code> function. </p><br><h4 id="trap-frame">  Trap frame </h4><br><img title="There simply must be a similar picture." src="https://habrastorage.org/webt/nn/jz/vq/nnjzvqyzzokkwps_ql7g52-gh8g.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Trap Frame is the name we give to a structure that contains the entire processor context.  The name "trap frame" comes from the term "trap" (trap), which is a general term for describing the mechanism by which a processor triggers a higher level of privilege when a certain event occurs.  I do not know about the good fit term for this all in Russian.  I think in this case it will be more convenient to use only the English term. <br><p>  There are various ways to create a trap frame, but their essence is the same.  We need to save all the state, which is necessary for execution, into RAM.  Most implementations put the entire state on the stack.  After we fill the stack with the contents of the registers, the pointer to the top of the stack will become our pointer to the <em>trap</em> .  It is this variation that we will use in the future. </p><br><p>  At this point, we need to save the following portions of the state of the Cortex-A53 core: </p><br><ul><li>  <code>x0</code> ... <code>x30</code> - i.e.  all 64-bit registers, of which as many as 31 pieces. </li><li>  <code>q0</code> ... <code>q31</code> - all 128-bit registers SIMD / FP. </li><li>  <code>pc</code> - program counter. <br>  The register is responsible for this <code>ELR_ELx</code> .  It may or may not be a PC.  One way or another, this is the address where we should return after executing the exception handler.  Usually <code>ELR_ELx</code> contains either PC directly or <code>PC + 4</code> , i.e.  address of the next command. </li><li>  <code>PSTATE</code> - processor status flags. <br>  Recall that the state of the probe is passed to us through the <code>SPSR_ELx</code> register at the previous <code>ELx</code> level. </li><li>  <code>sp</code> is a pointer to the stack boundary. <br>  Its contents can be accessed through <code>SP_ELs</code> for the exception level <code>s</code> . </li><li>  <code>TPIDR</code> - 64-bit value of the current "process ID". <br>  The value can be obtained from <code>TPIDR_ELs</code> for the exception level <code>s</code> . </li></ul><br><p>  This is all we need to save in our trap frame.  We will save on the stack before calling the exception handler.  After the handler returns control to the assembler code, we need to return this state as it was there.  After we put everything we need on the stack, its contents should look something like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af0/470/b02/af0470b02b703a107c20c608ef03c8d5.svg" alt="trap frame"></p><br><p>  Note the <code>SP</code> and <code>TPIDR</code> in this structure.  They should be exactly the stack pointers and the <em>source</em> thread ID, and not part of the interrupt state.  Since the only possible source we will have is <code>EL0</code> , they can be obtained through reading <code>SP_EL0</code> and <code>TPIDR_EL0</code> .  In this case, the current <code>SP</code> (which is used by the exception vector) will indicate the beginning of the trap frame.  Immediately after we put the necessary values ‚Äã‚Äãon this very stack, of course. </p><br><p>  After we fill the stack with the required values, we will pass a pointer to the top of the stack as the third argument to <code>handle_exception</code> .  Type this argument: <code>&amp;mut TrapFrame</code> .  As already mentioned, this very <code>TrapFrame</code> can be found in the file <code>kernel/src/traps/trap_frame.rs</code> .  You need to add this structure. </p><br><blockquote>  <strong>What is the thread ID?</strong> <br><br>  The <code>TPIDR</code> register (which is <code>TPIDR_ELx</code> ) allows the OS to store some information about what is being executed.  Later we will implement the processes and we will store the process identifier in this register.  Right now we will just save and restore this register. </blockquote><br><h4 id="predpochtitelnyy-adres-vozvrata-iz-isklyucheniya">  Preferred return address from exclusion </h4><br><p>  When an exception occurs at the <code>ELx</code> level requiring processing, the CPU stores the preferred return address in <code>ELR_ELx</code> .  Details can be found in the documentation ( <a href="https://web.stanford.edu/class/cs140e/docs/ARMv8-Reference-Manual.pdf">ref</a> : D1.10.1).  Here's what from there: </p><br><ol><li>  For asynchronous exceptions, this is the address of the first command that has not yet been executed, or is not fully executed at the moment our exception occurred. </li><li>  For synchronous exceptions (except system calls), this is the address of the instruction that generates this exception. </li><li>  For instructions that generate exceptions, this is the address of the instruction that follows the instruction that generates the exception. </li></ol><br><p>  The <code>brk</code> instruction belongs to the second category.  Thus, if we want to continue execution after the <code>brk</code> command, we need to make sure that the address of the next instruction is in <code>ELR_ELx</code> .  Since all instructions in AArch64 are 32 bits in size, it will be enough for us to overwrite this value with <code>ELR_ELx + 4</code> . </p><br><h4 id="realizaciya">  Implementation </h4><br><p>  Start by implementing <code>context_save</code> and <code>context_restore</code> from the <code>os/kernel/ext/init.S</code> .  The <code>context_save</code> subroutine should put all the necessary registers on the stack, and then call <code>handle_exception</code> , passing all the necessary arguments to this function, including the trap frame as the third argument.  After you <code>context_restore</code> this out, <code>context_restore</code> subroutine.  This routine should restore the context back. </p><br><p>  Pay attention to the instructions that are created by the macro <code>HANDLER</code> .  There are already saving and restoring <code>x0</code> and <code>x30</code> .  You should not touch these registers when saving / restoring in <code>context_{save, restore}</code> procedures.  However, these registers must lie in the trap frame. </p><br><p>  In order to minimize the loss of performance when switching context, you should put on the stack and remove the values ‚Äã‚Äãfrom the stack like this: </p><br><pre> <code class="hljs markdown">//      <span class="hljs-code"><span class="hljs-code">`x1`</span></span>, <span class="hljs-code"><span class="hljs-code">`x5`</span></span>, <span class="hljs-code"><span class="hljs-code">`x12`</span></span>  <span class="hljs-code"><span class="hljs-code">`x13`</span></span> sub SP, SP, #32 stp x1, x5, [SP] stp x12, x13, [SP, #16] //      <span class="hljs-code"><span class="hljs-code">`x1`</span></span>, <span class="hljs-code"><span class="hljs-code">`x5`</span></span>, <span class="hljs-code"><span class="hljs-code">`x12`</span></span>  <span class="hljs-code"><span class="hljs-code">`x13`</span></span> ldp x1, x5, [SP] ldp x12, x13, [SP, #16] add SP, SP, #32</code> </pre> <br><p>  Make sure the <code>SP</code> always 16 byte aligned.  You will find that with this approach, <code>reserved</code> will be created in our trap frame.  This most <code>reserved</code> should be filled with zeros. </p><br><p>  Once you are done with these two routines, <code>TrapFrame</code> into the <code>TrapFrame</code> structure of <code>kernel/src/traps/trap_frame.rs</code> .  Make sure that the order and size of the fields exactly match what you save in <code>context_save</code> and pass in as the <code>tf</code> parameter. </p><br><p>  Finally, add an <code>ELR</code> increase of <code>4</code> to <code>handle_exception</code> before returning from the <code>brk</code> exception handler.  Once you successfully implement context switching, your kernel should work fine after exiting the debug shell.  When everything is ready - go to the next step. </p><br><blockquote>  The contents of your trap frame do not have to correspond exactly to the diagram, but must contain all the same data. <br><br>  And don't forget that the <code>qn</code> registers are 128 bits! <br><br>  <strong>Tips:</strong> <br><br>  In order to call <code>handle_exception</code> you will need to save / restore registers that are not part of the trap frame. <br><br>  Rust has types <code>u128</code> and <code>i128</code> for values ‚Äã‚Äãof 128 bits. <br><br>  Use the <code>mrs</code> and <code>msr</code> to read / write special registers. <br><br>  Our <code>context_save</code> version takes about 45 instructions. <br><br>  Our <code>context_restore</code> version takes about 41 instructions. <br><br>  And our <code>TrapFrame</code> consists of 68 fields with a total size of 800 bytes. </blockquote><br><hr><br><blockquote>  <strong>How can I lazily handle registers for floating-point numbers?</strong>  [lazy-float] <br><br>  Saving and restoring all 128-bit SIMD / FP registers is quite expensive.  They occupy as many as 512 bytes out of 800 in the <code>TrapFrame</code> structure!  It would be ideal to process these registers only if they were actually used by the source of the exception or the purpose of the context switch. <br><br>  The AArch64 architecture allows us to selectively enable / disable the use of these registers.  How could we use this opportunity to lazily load these registers only when they are actually used?  But at the same time be able to use these registers freely in your code.  What code do you write for the exception handler?  Do I need to either modify the structure of the <code>TrapFrame</code> in order to add any additional state and how it is add.  condition should be maintained? </blockquote><br><h2 id="faza-2-eto-process">  Phase 2: This is the process </h2><br><p>  In this part we will move on to the most delicious.  We will implement user processes.  Let's start with the implementation of the <code>Process</code> structure, which will work with the state of our process.  Then we run the first process.  After that, we implement a round-robin process scheduler.  To do this, we will need to implement an interrupt controller driver and enable the timer interrupt.  Next, we will run our scheduler when a timer interrupt occurs and deal with the context switch in order to make the transition to the next process.  Finally, we implement the first system call: <code>sleep</code> . </p><br><p>  At the end of this phase, we will already have a minimal, but quite fully-fledged multi-tasking operating system.  Currently, processes will share physical memory with the kernel and other processes.  However, in the next phase we will deal with this misunderstanding and implement virtual memory.  All in order to isolate processes from each other and protect the core memory from playful writers of user-space programs. </p><br><h3 id="subfaza-a-process">  Subphase A: Process </h3><br><p>  In this subphase we will implement everything necessary for the functioning of the <code>Process</code> type from the file <code>kernel/src/process/process.rs</code> .  All this code is useful to us in the next subphase. </p><br><h4 id="chem-yavlyaetsya-process">  What is the process? </h4><br><p>  A process is a container for code and data that is executed, managed, and protected by the kernel.  In fact, this is the only part of the code that applies to everything outside the kernel.  Either the code is executed as part of a process, or the code is executed as part of the kernel.  There are quite a few different operating system architectures (especially when it comes to purely research pieces), but almost all of them have a concept that can be considered user processes. </p><br><p>  In most cases, processes are performed with a limited set of privileges (in our case it is <code>EL0</code> ).  All in the name of the fact that the kernel could provide the necessary level of stability and security of the entire system as a whole.  If one of the processes breaks down, then we do not want the same fate to befall the rest of the processes.  Moreover, we do not want the result of this to be a complete collapse of the entire system.  In addition, we do not want processes to interfere with each other.  If one process is frozen, then we want the remaining processes to still run.  Thus processes imply isolation.  They work to some extent independently of each other.  Probably you see all these properties every day: when your browser hangs, the rest of the work continues or freezes too? </p><br><p>  In any case, the implementation of processes consists in creating structures and algorithms for protecting, isolating, executing and managing unreliable code and data. </p><br><h4 id="chto-vnutri-processa">  What is inside the process? </h4><br><p>  To implement the processes, we need to track the code and process data and all kinds of supporting information.  All in order so that we can easily and freely manage the state of processes and isolate processes from each other.  This all means that we need to track: </p><br><ul><li>  <strong>Stack</strong> <br>  Each process requires its own unique stack.  When implementing processes, we need to allocate a section of memory that is suitable for use as a process stack.  And, of course, we will need to change the process stack pointer so that it points to this memory area. </li><li>  <strong>Heap</strong> <br>  In order to work with dynamic memory, each process will need to allocate its own heap.  At the very beginning, the heap will be completely empty, but it can be expanded with special system calls.  For the time being we will leave this topic and return to it in the future. </li><li>  <strong>Code</strong> <br>  The process is practically useless if it does not execute any code.  Therefore, our kernel will need to somehow load the process code into memory and transfer control to this code when necessary. </li><li>  <strong>Virtual address space</strong> <br>  Since we do not want to give processes the ability to access the memory of the kernel and the memory of other processes, each process will be limited to its own address space using such a thing as virtual memory. </li><li>  <strong>Scheduler Status</strong> <br>  In most cases, we assume that there may be more processes than the processor cores.  The kernel can execute only one command flow at a time.  Consequently, we need CPU time multiplexing mechanisms (and therefore we will have several instruction flows) for simultaneous execution of processes.  The task of the scheduler is to determine which process starts and at what point it will all happen.  In order to do this correctly, the planner needs to know whether any process is ready for planning or not.  The state of the scheduler that is stored in each process is exactly that. </li><li>  <strong>Execution status</strong> <br>  In order to properly multiplex the time of a sample between several processes, we will need to make sure that we save the process execution state when we stop the execution of this process.  Well, do not forget about the correct restoration of the state at the moment when we turn this process back on.  In fact, we have already done everything necessary to handle this state.  For this we needed to create <code>TrapFrame</code> .  Each process must properly store this state. </li></ul><br><p>  The stack, heap, and code constitute the entire physical state of the process.  The rest of the state is necessary to insulate, control and protect the process. </p><br><p>  The <code>Process</code> structure from <code>kernel/src/process/process.rs</code> will contain all this information.  At the moment (in this phase) all processes will use shared memory and there will be no fields for code, heap or virtual address space.  But we will add them later. </p><br><blockquote>  <strong>Should the process trust the kernel?</strong>  [kernel-distrust] <br><br>  On the whole, it is obvious that the kernel must relate to processes with obvious distrust.  But should processes trust the kernel?  If so, what should processes expect from the kernel? </blockquote><br><hr><br><blockquote>  <strong>What can go wrong if the two processes share stacks?</strong>  [isolated-stacks] <br><br>  Imagine two concurrent processes that share the same stack.  First, what will concurrent stack usage mean?  Secondly: why, with a high probability, these two processes will interfere with each other and quickly destroy each other?  Third: determine the properties of the processes that, in the event of a split of one stack, will be necessary for the quiet coexistence of the two processes without untimely death.  In other words, what rules should two such processes follow in order to use the same stack and not die at the same time? </blockquote><br><h4 id="realizaciya-1">  Implementation </h4><br><p>  It is time to implement everything you need for <code>Process</code> from the file <code>kernel/src/process/process.rs</code> .  ,  ,    <code>Stack</code> ,      <code>kernel/src/process/stack.rs</code> . ,   ,                 .     <code>State</code> ,      ,   .       <code>kernel/src/process/state.rs</code> .    ,           . </p><br><p>      <code>Process::new()</code> .    .            !    ‚Äî    . </p><br><blockquote> <strong>   ?</strong> [stack-drop] <br><br>  <code>Stack</code>  1MiB   .      16 .         ,  ,    ,    ? </blockquote><br><hr><br><blockquote> <strong>       ?</strong> [lazy-stacks] <br><br>  <code>Stack</code>  1MiB       .     .       ,           ,    ? </blockquote><br><hr><br><blockquote> <strong>      ?</strong> [stack-size] <br><br>          .       1MiB. ,        ,       ? ,     ,    ? </blockquote><br><h3 id="subfaza-b-pervyy-process">  B:   </h3><br><p>              ( <code>EL0</code> ).       <code>kernel/src/process/scheduler.rs</code>  <code>kernel/src/kmain.rs</code> . </p><br><h4 id="pereklyuchenie-kontekstov-processov">    </h4><br><p>   ,      .     <em></em>       : </p><br><ol><li>  trap frame     <code>trap_frame</code> . </li><li>  trap frame        <code>trap_frame</code> . </li><li>   ,  ,   . </li></ol><br><p>            .           .    ,     ? </p><br><p> ,  ,         .     ,    .   .   .            <code>trap_frame</code> .       trap frame?        !      2   <code>trap_frame</code> ,      . </p><br><p>          (    ),          .        .           .        . </p><br><p>  ,    ,       .  trap frame,   <code>context_save</code>      ,    <code>context_restore</code> .      1 .  ,     ,       . </p><br><h4 id="potoki-yadra">   </h4><br><p>           .     ,        .        ,   .         ()       ,       .  . Rust  ,        . </p><br><p>            ,        : // (threads).       ,  ,         . </p><br><p>       .         ,     <em> </em> .    ,             : </p><br><ol><li>  "" trap frame   . </li><li>  <code>context_restore</code> . </li><li>    <code>EL0</code> . </li></ol><br><p>          ,  ,         . </p><br><blockquote> <strong> <em> </em> .</strong> <br><br>  <em> </em>     ,   (   ,     )     ,     .   ,     ,    .      ,      ,     ,   . </blockquote><br><h4 id="realizaciya-2">  Implementation </h4><br><p>        <code>kmain.rs</code>   <code>SCHEDULER</code>   <code>GlobalScheduler</code> ,     <code>Scheduler</code> .       <code>kernel/src/process/scheduler.rs</code> .  <code>SCHEDULER</code>       . </p><br><p>  ,        ,    <code>start()</code>   <code>GlobalScheduler</code> .   ‚Äî   <code>start()</code> .  For this we need: </p><br><ol><li> <strong> <code>extern</code> -  ,    .</strong> <br>         .        ,  .    ,        . </li><li> <strong>  <code>Process</code>     trap frame.</strong> <br>     trap frame,      <code>context_restore</code> .   ,    <code>extern</code> -.          .         <code>EL0</code> . </li><li> <strong>     <code>context_restore</code> ,   <code>eret</code>    <code>EL0</code> .</strong> <br>   trap frame        .   : <br><ul><li>  <code>context_restore</code>    . <br> :    .    .      ,    ,    <code>context_restore</code> ,  ,         . </li><li>     ( <code>sp</code> )     ( <code>_start</code> ).    ,        <code>EL1</code>   . :      <code>ldr</code>  <code>adr</code>  <code>sp</code> .        ,        <code>sp</code> . </li><li>     <code>0</code> .          . </li><li>    <code>EL0</code>    <code>eret</code> . </li></ul></li></ol><br><p>        <a href="https://doc.rust-lang.org/unstable-book/language-features/asm.html"> </a> .   ,   <code>tf</code>    trap frame,           <code>x0</code> ,       <code>x1</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { asm!(<span class="hljs-string"><span class="hljs-string">"mov x0, $0 mov x1, x0"</span></span> :: <span class="hljs-string"><span class="hljs-string">"r"</span></span>(tf) :: <span class="hljs-string"><span class="hljs-string">"volatile"</span></span>); }</code> </pre> <br><p>       ‚Äî   <code>SCHEDULER.start()</code>  <code>kmain</code>        .  <code>kmain</code>     .          .    ,     <code>extern</code> -   <code>EL0</code>    . </p><br><p>   , ,           .     <code>brk</code>   <code>extern</code> -     : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_shell</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { asm!(<span class="hljs-string"><span class="hljs-string">"brk 1"</span></span> :::: <span class="hljs-string"><span class="hljs-string">"volatile"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { asm!(<span class="hljs-string"><span class="hljs-string">"brk 2"</span></span> :::: <span class="hljs-string"><span class="hljs-string">"volatile"</span></span>); } shell::shell(<span class="hljs-string"><span class="hljs-string">"user0&gt; "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { asm!(<span class="hljs-string"><span class="hljs-string">"brk 3"</span></span> :::: <span class="hljs-string"><span class="hljs-string">"volatile"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { shell::shell(<span class="hljs-string"><span class="hljs-string">"user1&gt; "</span></span>); } }</code> </pre> <br><p>           .         <code>LowerAArch64</code> ,       .     ,   ‚Äî    . </p><br><blockquote>  <strong>Tips:</strong> <br><br>      6 . <br><br>  ,     <code>T</code>  <code>Box&lt;T&gt;</code>  <code>&amp;*box</code> . <br><br>   ,     <code>unsafe</code> -. </blockquote><br><h3 id="subfaza-c-preryvanie-taymera">  C:   </h3><br><img src="https://habrastorage.org/webt/bn/x1/g3/bnx1g3-l0nbcentzcrs7mq2rfxu.gif"><br><br>          BCM2837.       ,        .      ,        .       <code>os/pi/src/interrupt.rs</code> , <code>os/pi/src/timer.rs</code>   <code>os/kernel/src/traps</code> . <br><h4 id="obrabotka-preryvaniy">   </h4><br><p>   AArch64  ‚Äî    ,    .      .         . </p><br><p>      ,          : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/99f/a09/0b2/99fa090b288c82d11f97f57860d92b08.svg" alt="int-chain"></p><br><p>         .  ,      ,  ,               . </p><br><blockquote> <strong>   ?</strong> <br><br>   ‚Äî     ,        ,       .        .        ,       . <br><br>      / .       ,          . </blockquote><br><h5 id="vneshnee-ustroystvo">   </h5><br><p>        .    ,     .              ,   . </p><br><h5 id="kontroller-preryvaniy">   </h5><br><p>      ,          CPU.        ,    . </p><br><p>        ,   ,        ,         .   ,     ,        ,        .  ,        ,     .     ,    ,     . </p><br><h5 id="processor">  </h5><br><p>     (unmasked)   ,     .     (masked) .    .    ,   ,    ,   ,   .     ,     .           . </p><br><p>         <code>EL0</code> ,         . </p><br><blockquote> <strong>   IRQ    IRQ?</strong> [reentrant-irq] <br><br>   IRQ      IRQ    .     ,       ?       IRQ? </blockquote><br><h5 id="vektory-isklyucheniy">   </h5><br><p>      .     IRQ ().        <code>handle_exception</code>  <code>kernel/src/traps/mod.rs</code>  ,      <code>handle_irq</code>  <code>kernel/src/traps/irq.rs</code> .  ,  ,    ,   ,      .  <code>handle_irq</code>      . </p><br><h4 id="realizaciya-3">  Implementation </h4><br><p>         <code>pi/src/interrupt.rs</code> .         7 <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">    BCM2873</a> .     /     IRQ,   <code>Interrupt</code> .  FIQ  BasicIRQ    . </p><br><p>      <code>tick_in()</code>     <code>pi/src/timer.rs</code> .        12 <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">    BCM2873</a> .   <code>tick_in()</code>         . </p><br><p>                <code>TICK</code> .       <code>GlobalScheduler::start()</code>  <code>kernel/src/process/scheduler.rs</code> .  <code>TICK</code>     . </p><br><p>     <code>handle_exception</code>  <code>kernel/src/traps/mod.rs</code>  ,       <code>handle_irq</code>  <code>kernel/src/traps/irq.rs</code> .   <code>handle_irq</code>               <code>TICK</code> , ,        <code>TICK</code> . </p><br><p>       ,      <code>TICK</code> .      <code>LowerAArch64</code> ,   (kind)   <code>Irq</code> .           .     ‚Äî    . </p><br><blockquote> <strong>   <code>TICK</code> !</strong> <br><br>        <code>TICK</code> .       2 .      ,    ,    ,  .          1  10 .    <code>TICK</code>   10  . </blockquote><br><h3 id="subfaza-d-planirovschik">  D:  </h3><br><p>       round-robin .      <code>kernel/src/process/scheduler.rs</code> , <code>kernel/src/process/process.rs</code>  <code>kernel/src/traps/irq.rs</code> . </p><br><h4 id="planirovanie">  </h4><br><p>         ,     .      -,     CPU.     .          .         ,     .   . </p><br><p>        .     round-robin .         .        ( <code>TICK</code> ),      .         ,      .   round-robin      . </p><br><p>           : </p><br><ul><li> <strong>Ready</strong> <br> ,    .   ,    . </li><li> <strong>Running</strong> <br> ,    . </li><li> <strong>Waiting</strong> <br> ,             ,     .  ,   ,     .       ,            .  Those.       . </li></ul><br><p>  <code>State</code>  <code>kernel/src/process/state.rs</code>   .       <code>State</code> ,      .  ,   <code>Waiting</code>  ,      ,  ,    . </p><br><p>        round-robin .  <code>C</code>   ,   -  3  5 . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/73c/42e/7a273c42ecba4c5acee0a66c18101e4e.svg" alt="round-robin"></p><br><p>    : </p><br><ol><li>        : <code>B</code> , <code>C</code> , <code>D</code>  ,     : <code>A</code> .   <code>C</code>    ,   ,    .    <code>A</code> ,     . </li><li>        <code>B</code> .          . </li><li>  <code>C</code>  ,  ,     .      .   <code>C</code>             <code>D</code> .    <code>D</code>  ,      . </li><li>      .  <code>A</code>        ,  <code>A</code>     . </li><li> <code>B</code>        . </li><li> <code>C</code>    .  ,    .      .    <code>C</code>     . </li></ol><br><blockquote> <strong>       ?</strong> [wait-queue] <br><br>   round-robin      :        ,  .         round-robin ?   ,   ( / )  /? </blockquote><br><h4 id="struktura-koda">   </h4><br><p>  <code>Scheduler</code>  <code>kernel/src/process/scheduler.rs</code>     ,   .       <code>Scheduler::add()</code> .          .      <code>TPIDR</code> . </p><br><p>      ,   <code>Scheduler::switch()</code> .        <code>new_state</code> ,   trap frame   ,         trap frame.   ,   ,   ,     . </p><br><p>  ,  ,     ,     <code>process.is_ready()</code> ,    <code>kernel/src/process/process.rs</code> .    <code>true</code> ,    <code>Ready</code> ,     . </p><br><p>       <code>TICK</code> .  ,              .      <code>GlobalScheduler</code>     <code>add()</code>  <code>switch()</code>  <code>Scheduler</code> . </p><br><blockquote> <strong>     ?</strong> [new-state] <br><br>  <code>scheduler.switch()</code> ,       .  ,    ,     .     ? </blockquote><br><h4 id="realizaciya-4">  Implementation </h4><br><p>        round-robin .    : </p><br><ol><li> <strong>  <code>Process::is_ready()</code>  <code>kernel/src/process/process.rs</code></strong> <br>  <a href="https://doc.rust-lang.org/nightly/std/mem/fn.replace.html">mem::replace()</a>     . </li><li> <strong>     <code>Scheduler</code>  <code>kernel/src/process/scheduler.rs</code> .</strong> <br>    <code>switch()</code> ,       ,    ,    .           .  ,       ,    <code>wfi</code> (wait for interrupt).      ,           ,          .          <code>aarch64.rs</code> . </li><li> **    <code>GlobalScheduler::start()</code> . <br>          ,    .         ,    . </li><li> <strong>    .</strong> <br>  <code>SCHEDULER.switch()</code>      ,        . </li></ol><br><p>   ,     <code>GlobalScheduler::start()</code> .             .        ( <code>extern</code> -)    ,  ,        . ,          . </p><br><p>     ,    ,     <code>TICK</code> .           .    ‚Äî    . </p><br><blockquote> <strong>      !</strong> <br><br> <strong>    <code>unsafe</code>       !</strong> <br><br>  <a href="https://doc.rust-lang.org/nightly/std/mem/fn.replace.html">mem::replace()</a>     <code>state</code> . <br><br> <strong>   ,    ?</strong> [wfi] <br><br>   <code>wfi</code>     ,      ,    .       <code>wfi</code> ,      .    ,    ? <br><blockquote> <strong></strong> :   ,       . </blockquote><br></blockquote><br><h3 id="subfaza-e-sleep">  E: Sleep </h3><br><p>        <code>sleep</code>    .      <code>kernel/src/shell.rs</code>    <code>kernel/src/traps</code> . </p><br><h4 id="sistemnye-vyzovy">   </h4><br><p>   ‚Äî    ,     .    <code>svc #n</code> ,      <code>Svc(n)</code> ,  <code>n</code> ‚Äî ,    .    ,  <code>brk #n</code>   <code>Brk(n)</code> ,   ,          <code>svc</code>    .   ‚Äî  ,           ,        . </p><br><p>        100          .         <code>sleep</code> .              .      . </p><br><h4 id="soglashenie-o-sistemnyh-vyzovah">     </h4><br><p>  ,         ,       .        ,    unix- .   : </p><br><ul><li>   <code>n</code>    <code>svc #n</code> . </li><li>  7      <code>x0</code> ... <code>x6</code> . </li><li>  7      <code>x0</code> ... <code>x6</code> . </li><li>  <code>x7</code>     . <br><ul><li>   <code>x7</code>  <code>0</code> ‚Äî  . </li><li>   <code>x7</code>  <code>1</code> ‚Äî     . </li><li>   <code>x7</code>  -  ‚Äî           . </li></ul></li><li>           . </li></ul><br><p>    ,         <code>7</code> ,       <code>u32</code>  <code>u64</code> ,        <code>u64</code> ,     ,   <a href="https://doc.rust-lang.org/unstable-book/language-features/asm.html"> </a> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syscall_7</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>), Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result_one: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result_two: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { asm!(<span class="hljs-string"><span class="hljs-string">"mov w0, $3 mov x1, $4 svc 7 mov $0, x0 mov $1, x1 mov $2, x7"</span></span> : <span class="hljs-string"><span class="hljs-string">"=r"</span></span>(result_one), <span class="hljs-string"><span class="hljs-string">"=r"</span></span>(result_two), <span class="hljs-string"><span class="hljs-string">"=r"</span></span>(error) : <span class="hljs-string"><span class="hljs-string">"r"</span></span>(a), <span class="hljs-string"><span class="hljs-string">"r"</span></span>(b) : <span class="hljs-string"><span class="hljs-string">"x0"</span></span>, <span class="hljs-string"><span class="hljs-string">"x1"</span></span>, <span class="hljs-string"><span class="hljs-string">"x7"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(Error::from(error)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((result_one, result_two)) } }</code> </pre> <br><p>  .         ,   . </p><br><blockquote> <strong>        ?</strong> [syscall-error] <br><br>  unix-  ,  Linux,     ( <code>x0</code>   )    .           .        .    ,    ?    ? </blockquote><br><h4 id="sistemnyy-vyzov-sleep">   Sleep </h4><br><p>   <code>sleep</code>    <code>1</code>    .          <code>u32</code> .  ,      .          <code>u32</code> .  ,          .      : </p><br><pre> <code class="rust hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span>) sleep(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span></code> </pre> <br><blockquote> <strong>         ?</strong> [sleep-elapsed] <br><br>    (   )   ,      ?   ,   ,    ?   ,       ? </blockquote><br><h4 id="realizaciya-5">  Implementation </h4><br><p>      <code>sleep</code> .     <code>handle_exception</code>  <code>kernel/src/traps/mod.rs</code> . ,            <code>handle_syscall</code>  <code>kernel/src/traps/syscalls.rs</code> .     <code>handle_syscall</code> .      <code>sleep</code>       .    <code>Box&lt;FnMut&gt;</code> ,    .      : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> boxed_fnmut = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |p| { <span class="hljs-comment"><span class="hljs-comment">//  `p` });</span></span></code> </pre> <br><p>     <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html">  Rust</a> . </p><br><p>      <code>sleep &lt;ms&gt;</code>   .     <code>ms</code>       (    ). </p><br><p>   ,  <code>sleep</code>    . ,          ,     .           .  ,     ,    .       ‚Äî      . </p><br><blockquote> <strong></strong> : <br><br>    <code>sleep</code>    . <br><br> ,        . <br><br>  <code>u32</code>  <a href="https://doc.rust-lang.org/nightly/std/str/trait.FromStr.html">FromStr</a> . </blockquote><br><hr><br><p>     ,  .     .      ,       .             .      .  ,    . </p></div><p>Source: <a href="https://habr.com/ru/post/354784/">https://habr.com/ru/post/354784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354774/index.html">The device of special effects for games under NES. Part 2</a></li>
<li><a href="../354776/index.html">How I learned to read</a></li>
<li><a href="../354778/index.html">Rhinoceros, python and shot through foot at the conference SMARTRHINO-2018</a></li>
<li><a href="../354780/index.html">Building and installing GNURadio from GIT under Ubuntu and Debian</a></li>
<li><a href="../354782/index.html">How to make the state open, Part 1: Downloading road accident statistics with your own hands</a></li>
<li><a href="../354786/index.html">Obtaining a work permit in the Czech Republic: the case of a dual labor card</a></li>
<li><a href="../354788/index.html">Designers and developers: sworn friends and best enemies</a></li>
<li><a href="../354792/index.html">Affiliate program and API capabilities on hosting virtual servers VPS.house</a></li>
<li><a href="../354794/index.html">3 minutes to improve any meeting</a></li>
<li><a href="../354796/index.html">I made an API for screenshots of sites, and some guy started mining through it cryptocurrency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>