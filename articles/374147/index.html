<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Christmas gifts, part two: Specter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part One: Meltdown . 

 Despite the power of Meltdown's vulnerability, the happiness brought by this New Year would not have been complete, if not for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Christmas gifts, part two: Specter</h1><div class="post__text post__text-html js-mediator-article">  Part One: <a href="https://geektimes.ru/post/297029/">Meltdown</a> . <br><br>  Despite the power of Meltdown's vulnerability, the happiness brought by this New Year would not have been complete, if not for the second part of the discovery, not limited to Intel-Specter processors. <br><br>  Speaking very, very briefly, Specter is a fundamental vulnerability to processors in Meltdown in the sense that it also represents a hardware feature and exploits indirect channels of data leakage.  Specter is more difficult in practical implementation, but it is not limited to Intel processors, but extends - albeit with nuances - to all modern processors that have a cache and a transition prediction mechanism.  That is, all modern processors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Strictly speaking, Specter is not one vulnerability - at the start two different mechanisms are declared (CVE-2017-5753 and CVE-2017-5715), and the authors note that there may be many less obvious options. <br><br>  At its core, Specter is similar to Meltdown, since it is also based on the fact that during speculative code execution, the processor can execute instructions that it would not execute under the condition of strictly sequential (non-speculative) calculation, and although later the result of their execution discarded, its footprint remains in the processor cache and can be used. <br><a name="habracut"></a><br>  The Branch Prediction Unit, the branch prediction unit, the task of which is to estimate the probability with which it will go along one or another path after any condition, <i>without prior calculation of this condition</i> .  The prediction unit works statistically, that is, it accumulates data on similar branches that have been completed at the moment, and on their basis predicts the outcome of each subsequent branch. <br><br>  That is, for example, if the code <i>if (a &lt;b)</i> , for calculating which it is necessary to load <i>a</i> and <i>b</i> long and sadly, gave <i>true a</i> thousand times in a row, then for the thousand first time it is possible to decide with great confidence that now it will be <i>true</i> before <i>a</i> and <i>b were</i> loaded from memory and the check actually occurred. <br><br>  What is even more interesting is that processors do not distinguish between the processes in which this condition is calculated.  Therefore, if in the process of malware.exe a thousand times in a row such an if gave <i>true</i> , then the processor will assume that the first similar if in the process of word.exe also returns <i>true</i> . <br><br>  This is quite logical, since in different programs there can be a lot of very similar constructions, therefore it is more efficient to train the prediction unit on the entire data stream than on one specific process. <br><br>  In fact, I have just described the mechanism by which the malware.exe program can control the progress of the word.exe program without having any formally approved rights. <br><br>  Until January 3 of this year, it was considered that there is no danger ‚Äî after all, if something goes wrong with word.exe, the processor ultimately recognizes the speculative computing branch as invalid, drops the pipeline to its original state and recount all over again, this time already consistently.  Word.exe will not even notice anything, except for a small unevenness in the pace of execution of instructions by the processor. <br><br>  This place is still similar to Meltdown, but further differences begin.  As we remember, Meltdown does not work on processors that are on time - before the actual end of the execution of a sequence of commands - check the conditions of access of the process to someone else's memory, even in the case of speculative execution. <br><br>  Specter does not have such a problem, because Specter does not imply any direct access to other people's memory, even with speculative execution.  Instead, Specter makes sure that the attacked process (this can be either the core of the system or another user program) gives information about the contents of its own memory. <br><br>  Imagine the following code in the code of the attacked process, with the variable <i>x</i> being the result of some user input that we can influence: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (x &lt; array1_size) { <span class="hljs-attribute"><span class="hljs-attribute">y</span></span> = array2[array1[x]]; }</code> </pre> <br>  Now we take and write in our program, which exploits a vulnerability, the most similar construction, and execute it many, many times, and each time an honestly calculated condition gives <i>true</i> , the array indices are completely valid, and in general everything is fine.  The branch prediction block thus collects statistics, saying that this construction is always calculated to be <i>true</i> , therefore, having met it, you can not wait for the end of the condition calculation, but go directly to the content. <br><br>  And now we pass such data to the attacked program that <i>x</i> suddenly jumps out somewhere far beyond the array1 array.  <i>If there were no</i> speculative execution, the processor would consider the condition x &lt;array1_size, find it invalid and jump further.  But it is there, and the prediction block gives it that x &lt;array1_size will almost certainly be executed, so while the value of array1_size is slowly and sadly sucked from somewhere in memory, in order to actually perform the comparison, the processor starts to execute the body of this piece of code. <br><br>  An important point in the attack, by the way, is the item ‚Äúslow and sad‚Äù - if array1_size is ready somewhere in the cache, the processor may not bother with speculative calculation, but simply quickly calculate the condition.  Therefore, array1_size should be in RAM, where it will take a long time to get it. <br><br>  The value of <i>x</i> is chosen so that it points to the address in the memory area of ‚Äã‚Äãthe program being attacked, which we want to read.  Suppose it stores the value of <i>k</i> , and we also need this value to have already been loaded into the cache earlier. <br><br>  The latter is often not very difficult to achieve - if, for example, we want to steal a private key from a data encryption program, it‚Äôs enough for the previous action to simply absolutely legally ask the program to encrypt something, then it will turn to this key itself, and the processor, respectively, will drag it in the cache.  Let me remind you that another condition was the absence of other variables involved in the process in the cache, but this can be implemented by simply clogging the cache with rubbish on behalf of the attacking process, or even simply instructing to force a reset of the cache, if there is one on the attacked processor. <br><br>  So, everything is adjusted so that the processor <i>reads array1 [x]</i> , which will be equal to <i>k</i> , which it does.  Since <i>k</i> is in the cache, the processor gets it almost instantly, substitutes <i>array1</i> as an index and requests the value corresponding to <i>array2 [k]</i> from RAM. <br><br>  After this intricate chain, the value of <i>array1_size</i> finally arrives, the processor calculates the condition, recognizes it as invalid and throws out the results of all the above-described calculations.  He numbered the kingdom and put an end to it.  Everywhere except the cache. <br><br>  What is especially cynical, the basic possibility of an attack was provided to us by checking the array index, which is necessary to ensure the security of the code. <br><br>  It doesn‚Äôt become much simpler further, since we now have to figure out what is in the cache - and it is supposed to go there on behalf of a third-party process, that is, unlike Meltdown, we cannot directly touch the memory. <br><br>  Nevertheless, and here can find their own methods.  For example, if array2 has sufficiently valid indices (at least k pieces), and we can encourage the program to read it from the outside in a more or less direct way, then the read operation on the index <i>k</i> will be faster than on other indexes, since it has already been cached. <br><br>  As it is easy to see, the method is not simple and straightforward to implement - however, subject to an attack on a specific software, known to an attacker and, if possible, available in source codes in the same version and on the same system that the attack is supposed to be, it can be implemented. <br><br>  Unlike Meltdown, this method may leave traces in the system if the program being attacked, for example, reports input data that causes the index overflow in the array used in the attack. <br><br>  Just as in the case of Meltdown, an attacking program does not require any special privileges for itself, except for the possibility of launching itself on the attacked system.  Theoretically, an attack can be made even from a JS script in the browser and other interpreted languages, in which it is possible to organize a timer with an accuracy suitable for distinguishing the speed of obtaining a variable from the cache and from RAM. <br><br>  This was the <b>first Specter version</b> , which I find it difficult to give a short name to.  To the second, a simple, well-known Russian ear name is asked: <b>Gadgets</b> . <br><br>  No, the gadget in this case is not your iphone.  A gadget is something that can be used to pull your passwords out of your iPhone without your knowledge. <br><br>  A gadget is a sequence of commands in the address space of the attacked program, which can be used to attack.  The task of such a sequence is to organize data leakage, if not directly, then through the cache using the mechanism described above, so the sequence can be quite short and also not associated at all with any software vulnerabilities - direct data leakage beyond the limits of the memory area being attacked by the program, I remind you, it does not happen. <br><br>  An important point: this sequence is not created and is not introduced by the attacker, that is, again, de jure no invasion of the program under attack occurs.  The attacker simply finds the piece of code he needs in the body of the attacked program or any of the libraries loaded by it;  Moreover, in some cases, it does not even need a preliminary analysis of the software - directly on the attacked system, you can try to find the desired sequence in the commonly used system libraries in situ, it is logical to assume that the attacked program also uses these libraries. <br><br>  Researchers at Google used the BPF feature at all. This is a mechanism that exists in Linux and FreeBSD and allows user applications to hook their filter to the system kernel, for example, to track I / O streams.  In this case, of course, it does not matter at all what this filter will do - it is important that in some place it was the sequence of commands we need. <br><br>  <b>Nota bene</b> : a version was born of this that Specter‚Äôs vulnerability does not apply when BPF is turned off.  <b>It is not</b> . <br><br>  To transfer the execution of the attacked program to the desired sequence, an approach similar to the above-described training of the branch prediction block is used - there is a similar transition prediction block in the processor that tries to guess at what address the transition will be performed with the next instruction of the indirect transition (we all remember these instructions on Meltdown, but here they play a different role). <br><br>  To simplify the work, this block does not perform translation between virtual and real addresses, which means it can be trained in the attacker's address space for certain actions in the attacker's address space. <br><br>  That is, if we know that the instruction we need in the attacked program lies at 123456, and also in this program there is a regularly executed indirect transition.  In the attacking program, we write a construction that is as close as possible to the transition to the attacked, but always performing the transition at 123456. In our address space, of course, an absolutely valid and legal transition.  What exactly we have at the address 123456, does not matter. <br><br>  After a while, the transition prediction block is absolutely sure that all transitions of this type lead to the address 123456, therefore, when the attacked program - from our submission or on its own initiative - reaches a similar transition, the processor joyfully begins the speculative execution of instructions from the address 123456. <i>address space of the attacked program</i> . <br><br>  After some time, the real address of the transition will be calculated, the processor realizes the error and discards the results of speculative execution, however, as in all other cases of Meltdown and Specter, there will be traces of it in the cache. <br><br>  And what to do with traces in the cache, you already know. <br><br>  In general, according to the description of this entire puzzling procedure, it is quite obvious that it is much more difficult to operate Specter than Meltdown - but, on the other hand, most of the existing processors are affected to some degree or another. <br><br><h4>  Who is affected? </h4><br>  We can assume that all processors are newer than the Pentium MMX, but there are nuances. <br><br><ol><li>  Intel processors are all susceptible </li><li>  The new ARM cores <a href="https://developer.arm.com/support/security-update">are all susceptible</a> .  The latest kernels without speculative code execution were the Cortex-A7 and Cortex-A53.  Cortex-A7 in wildlife is also found in embedded systems, from Raspberry Pi 3 to system-on-module on iMX6UL and iMX6ULL, but on Cortex-A53 many mid-level smartphones are built - there it is known as Snapdragon 625, Snapdragon 410, Mediatek MT6752 etc. </li><li>  AMD's processors, according to the company, are ‚Äúvirtually unaffected‚Äù by an attack using gadgets officially called Branch Target Injection or Indirect Branch Poisoning. </li><li>  There is no information about other cores, but most likely, the Specter's first variant (Bounds Check Bypass) is all susceptible, and the second depends on the implementation of a specific transition prediction architecture </li></ol><br>  Why AMD is "practically not exposed" to the attack through the redirection of indirect transitions, the company does not disclose.  The MMU cannot be involved here, since all requests are carried out strictly within the address space of the program being attacked.  It can be assumed that AMD has a different transition prediction mechanism, possibly tracking, skeptical about the idea of ‚Äã‚Äãtransferring such predictions between different processes.  Characteristically, AMD does not speak about the complete impossibility of an attack, only about "almost zero probability." <br><br>  At the same time, AMD, just like Intel and ARM, is subject to the first type of Specter attack, through the training of branch prediction block. <br><br><h4>  Is it true that AMD is subject to a second type Specter attack only on Linux and only when BPF is enabled? </h4><br>  Not. <br><br>  On Linux with BPF enabled, the attack was shown in a Google Project Zero document, it was also noted there that it could not be performed on an AMD processor without BPF - however, apparently, this was caused only by the fact that researchers could not find it in the compiled kernel sequences of commands chosen by them for attack.  In practice, firstly, attacks can be carried out not only against the core of the system, but also against any programs running in the system and the libraries they use, and secondly, the necessary sequences of commands can be different.  Therefore, although one specific attack could be carried out in a particular case only through BPF, this has nothing to do with the general question of vulnerability to Specter attacks. <br><br><h4>  Processor manufacturers promise easy and fast fix </h4><br>  First, see the remark in the first part about the attitude to the current statements of manufacturers. <br><br>  Secondly, Specter, unlike Meltdown, is not a specific attack - these are just two of the most obvious of the whole spectrum (I‚Äôm aware that the "specter" translates wrong, but it really hurts to ask) sophisticated attacks that use targeted training processor blocks predict program execution. <br><br><h4>  What will we do next, how will we continue to live? </h4><br>  Not very clear yet. <br><br>  First, it is likely that processor manufacturers will further tune their architecture in order to exclude or obscure known attacks.  But we will see the result only in two or three years, and besides, the existing freedom in the algorithms of processors is due to the desire to increase their performance - in both cases we deal with Specter in that the processor learns to perform one process faster using the example of another process. , thereby actually allowing the second process to control the progress of the first. <br><br>  Globally, all problems would be solved by more accurate handling of the cache, for example, zeroing the results of speculative execution in the event of pipeline flushing or storing such results into a separate cache with transferring them to the main one only after successful execution - but both options also entail additional overhead. <br><br>  Compiler patches are also being developed to provide protection against Specter‚Äôs second attack ‚Äî options for gcc and llvm based <a href="https://support.google.com/faqs/answer/7625886">on Google‚Äôs suggestions are</a> already being presented. <br><br>  They are based on a rather simple thing: the substitution of an indirect transition to a return from a function.  Returning from a function works a little differently than an indirect transition, the transition prediction block does not affect it.  In fact, this is a cheater trick.  It would be a double pleasure, but, as usual, there are nuances. <br><br>  First, the fix does not affect the Specter of the first type. <br><br>  Secondly, every magic comes with a price.  Although Google in the official message carefully avoids the question of the quantitative measurement of the overhead, in practice one ‚Äúprotected‚Äù indirect transition is on average ten times heavier.  The effect for a particular application depends on its structure, language and compiler - for the Linux kernel it is within 2%, for other applications it can be much more. <br><br>  In this regard, at the moment it is ‚Äúofficially considered‚Äù that in order to ensure an ‚Äúacceptable‚Äù level of protection, it is enough to rebuild the kernel and single critical applications, and everything else is unlikely to attack. <br><br>  Thirdly, there is no specter-wide patch for Specter at the moment, and it is not foreseen - not from one of the options.  Minimal protection from the second option requires a complete recompilation of the system kernel and, probably, in most OSs it will be implemented not earlier than the release of the next major version.  Protection from the first option is currently represented solely in the form of searching for and removing the sequence from the Linux kernel code used in the Google Project Zero demonstration on Intel. <br><br>  Processor manufacturers began to slowly update their microcode, but so far no one really appreciated the efficiency and performance losses as a result of these updates.  Intel has released two updates - IBRS, Indirect Branch Restricted Speculation, and IBPB, Indirect Branch Prediction Barriers;  as it is not difficult to notice by name, both belong to Specter‚Äôs second type of attack. <br><br><h4>  TL: DR </h4><br>  A global error that is present in approximately all existing processors.  It would be a complete ass if it were not for the high complexity of the practical implementation, because of which hackers will score on it. <br><br>  AMD seems to be half safer than others, although it is not clear why. <br><br><h4>  TL: DR - the difference with Meltdown </h4><br><br>  Meltdown uses an <i>error</i> in the Intel and ARM processors, due to which the processor ignores memory access rights during the speculative execution of instructions. <br><br>  Specter uses a <i>feature of the</i> work of branch prediction and transition algorithms in modern processors, due to which one process can influence the likelihood of speculative execution of instructions in another process. <br><br>  <a href="https://geektimes.ru/post/297065/">Part three: did we behave well</a> </div><p>Source: <a href="https://habr.com/ru/post/374147/">https://habr.com/ru/post/374147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../374137/index.html">Low-frequency resonance in the maze: the benefits and harms of increasing sound power by 200 times</a></li>
<li><a href="../374139/index.html">Nakraudfandili: 15 most successful projects of 2017</a></li>
<li><a href="../374141/index.html">Let the new, in 2018 ...</a></li>
<li><a href="../374143/index.html">Kaluza-Klein Partner Particles, Part 1</a></li>
<li><a href="../374145/index.html">Astronautics 2018 - overview of missions and launches</a></li>
<li><a href="../374149/index.html">How to manage a microcontroller, without attracting the attention of orderlies</a></li>
<li><a href="../374151/index.html">How not to become dependent on public opinion, and why is it not disgraceful to be a bydlokoder?</a></li>
<li><a href="../374153/index.html">Intel Core Processors with Radeon Vega Graphics Officially Presented</a></li>
<li><a href="../374155/index.html">The choice of HashFlare: five promising cryptocurrencies that are worth paying attention to in 2018</a></li>
<li><a href="../374157/index.html">WD My Cloud backdoor for everyone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>