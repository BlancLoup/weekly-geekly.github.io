<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a Reliable Udp Protocol for .Net</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Internet has changed a long time ago. One of the main Internet protocols, UDP, is used by applications not only to deliver datagrams and broadcast...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a Reliable Udp Protocol for .Net</h1><div class="post__text post__text-html js-mediator-article">  The Internet has changed a long time ago.  One of the main Internet protocols, <abbr title="User Datagram Protocol">UDP, is</abbr> used by applications not only to deliver datagrams and broadcasts, but also to provide peer-to-peer connections between network nodes.  Due to its simple device, this protocol has a lot of not previously planned methods of use, however, protocol flaws, such as the lack of guaranteed delivery, have not disappeared anywhere.  This article describes the implementation of the guaranteed delivery protocol over UDP. <br><div class="spoiler">  <b class="spoiler_title">Content:</b> <div class="spoiler_text">  <a href="https://habr.com/ru/post/250227/">Introduction</a> <br>  <a href="https://habr.com/ru/post/250227/">Protocol requirements</a> <br>  <a href="https://habr.com/ru/post/250227/">Reliable UDP header</a> <br>  <a href="https://habr.com/ru/post/250227/">General principles of the protocol</a> <br>  <a href="https://habr.com/ru/post/250227/">Timeouts and protocol timers</a> <br>  <a href="https://habr.com/ru/post/250227/">Reliable UDP transmission state diagram</a> <br>  <a href="https://habr.com/ru/post/250227/">Deeper into the code.</a>  <a href="https://habr.com/ru/post/250227/">Transmission Control Unit</a> <br>  <a href="https://habr.com/ru/post/250227/">Deeper into the code.</a>  <a href="https://habr.com/ru/post/250227/">States</a> <br><ul><li>  <a href="https://habr.com/ru/post/250227/">DisposeByTimeout method</a> <br></li><li>  <a href="https://habr.com/ru/post/250227/">ProcessPackets method</a> <br></li><li>  <a href="https://habr.com/ru/post/250227/">ReceivePacket method</a> <br></li><li>  <a href="https://habr.com/ru/post/250227/">SendPacket method</a> <br></li></ul><br>  <a href="https://habr.com/ru/post/250227/">Deeper into the code.</a>  <a href="https://habr.com/ru/post/250227/">Creating and making connections</a> <br>  <a href="https://habr.com/ru/post/250227/">Deeper into the code.</a>  <a href="https://habr.com/ru/post/250227/">Closing the connection by timeout</a> <br>  <a href="https://habr.com/ru/post/250227/">Deeper into the code.</a>  <a href="https://habr.com/ru/post/250227/">Data transfer recovery</a> <br>  <a href="https://habr.com/ru/post/250227/">Reliable UDP API</a> <br>  <a href="https://habr.com/ru/post/250227/">Conclusion</a> <br>  <a href="https://habr.com/ru/post/250227/">Useful links and articles</a> <br></div></div><br><h3><a name="intro"></a>  Introduction </h3><br>  The original architecture of the Internet meant a uniform address space in which each node had a global and unique IP address and could communicate directly with other nodes.  Now the Internet, in fact, has a different architecture - one area of ‚Äã‚Äãglobal IP addresses and many areas with private addresses hidden behind <abbr title="Network Address Translation">NAT</abbr> devices. <a name="habracut"></a>  In such an architecture, only devices located in the global address space can easily communicate with anyone on the network because they have a unique, global, routable IP address.  A node that is in a private network can connect to other nodes on the same network, as well as connect to other well-known nodes in the global address space.  This interaction is achieved largely due to <abbr title="Network Address Translation">the network address translation mechanism</abbr> .  NAT devices, such as Wi-Fi routers, create special entries in the translation tables for outgoing connections and modify the IP addresses and port numbers in the packets.  This allows you to establish an outgoing connection to nodes in the global address space from a private network.  But at the same time, NAT devices usually block all incoming traffic, unless separate rules are established for incoming connections. <br><br>  This architecture of the Internet is sufficiently correct for client-server interaction, when clients can be in private networks, and servers have a global address.  But it makes it difficult to directly connect two nodes between <i>different</i> private networks.  Direct connection of two nodes is important for ‚Äúpeer-to-peer‚Äù applications, such as voice transmission (Skype), remote access to a computer (TeamViewer), or online games. <br><br>  One of the most effective methods for establishing peer-to-peer connections between devices located in different private networks is called ‚Äúhole punching‚Äù.  This technique is most commonly used with applications based on the UDP protocol. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But if your application requires guaranteed data delivery, for example, you transfer files between computers, then using UDP will cause many difficulties due to the fact that UDP is not a guaranteed delivery protocol and does not provide delivery of packets in order, unlike TCP. <br><br>  In this case, to ensure guaranteed packet delivery, it is required to implement an application-level protocol that provides the necessary functionality and works over UDP. <br><br>  <i>Just want to note that there is a TCP hole punching technique for establishing TCP connections between nodes in different private networks, but due to the lack of support for it by many NAT devices, it is usually not considered as the main way to connect such nodes.</i> <br><br>  Further in this article I will consider only the implementation of the guaranteed delivery protocol.  The implementation of UDP hole punching techniques will be described in the following articles. <br><br><h3><a name="requirements"></a>  Protocol requirements </h3><br><ol><li>  Reliable packet delivery implemented through positive feedback mechanism (so-called positive acknowledgment) </li><li>  The need for efficient transfer of big data, i.e.  protocol must avoid unnecessary packet retransmissions </li><li>  It should be possible to cancel the delivery confirmation mechanism (the ability to function as a "pure" UDP protocol) </li><li>  Ability to implement command mode, with confirmation of each message </li><li>  The basic unit of data transmission protocol must be a message </li></ol><br>  These requirements largely coincide with the requirements for the Reliable Data Protocol, described in <a href="http://tools.ietf.org/html/rfc908">rfc 908</a> and <a href="http://tools.ietf.org/html/rfc1151">rfc 1151</a> , and I based on these standards in the development of this protocol. <br><br>  To understand these requirements, let's look at the timing of data transfer between two nodes on the network protocols TCP and UDP.  Suppose that in both cases we have one package lost. <br><div class="spoiler">  <b class="spoiler_title">Transmission of non-interactive data via TCP:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ab9/4d7/837/ab94d7837d5e408eb78923e45f29ce10.jpg"><br></div></div><br>  As can be seen from the diagram, in case of packet loss, TCP will detect the lost packet and notify the sender of this by requesting the number of the lost segment. <br><div class="spoiler">  <b class="spoiler_title">Data transmission via UDP protocol:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d64/36f/e77/d6436fe7799b472cb4ad78f600aa4ea1.jpg"><br></div></div><br>  UDP takes no loss detection steps.  Control of transmission errors in the UDP protocol is completely on the application. <br><br>  Error detection in the TCP protocol is achieved by establishing a connection with the end node, maintaining the state of this connection, specifying the number of bytes sent in each packet header, and receiving notifications using the ‚Äúacknowledge number‚Äù confirmation number. <br><br>  Additionally, to improve performance (ie, sending more than one segment without receiving confirmation), the TCP protocol uses the so-called transmission window ‚Äî the number of bytes of data that the sender of the segment expects to receive. <br><br>  <i>More details on the TCP protocol can be found in <a href="http://tools.ietf.org/html/rfc793">rfc 793</a> , with UDP in <a href="http://tools.ietf.org/html/rfc768">rfc 768</a> , where they are, strictly speaking, defined.</i> <br><br>  From the above, it is clear that to create a reliable message delivery protocol over UDP (hereinafter referred to as <i>Reliable UDP</i> ), it is required to implement data transfer mechanisms similar to TCP.  Namely: <br><ul><li>  keep connection state </li><li>  use segment numbering </li><li>  use special confirmation packages </li><li>  use a simplified window mechanism to increase protocol bandwidth </li></ul>  Additionally required: <ul><li>  signal the beginning of the message to allocate resources for the connection </li><li>  signaling the end of the message, to transfer the received message to the upstream application and release the protocol resources </li><li> allow a protocol for specific connections to disable the delivery confirmation mechanism to function as a ‚Äúpure‚Äù UDP </li></ul><br><h3><a name="rudpheader"></a>  Reliable UDP header </h3><br>  Recall that a UDP datagram is encapsulated into an IP datagram.  The Reliable UDP packet is correspondingly wrapped in a UDP datagram. <br><div class="spoiler">  <b class="spoiler_title">Reliable UDP Header Encapsulation:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/60a/fbf/c14/60afbfc1465f4b8e93fbe9799461b433.jpg"><br></div></div><br>  The structure of the Reliable UDP header is quite simple: <br><br><img src="https://habrastorage.org/files/842/f0c/871/842f0c871b95471d9fa4411a241f26e3.jpg"><br><br><ul><li>  Flags - package control flags </li><li>  MessageType - message type, used by upstream applications to subscribe to certain messages </li><li>  TransmissionId - the number of the transmission, together with the address and port of the recipient uniquely identifies the connection </li><li>  PacketNumber - packet number </li><li>  Options - additional protocol options.  In the case of the first packet, it is used to indicate the size of the message. </li></ul><br>  Flags are as follows: <br><ul><li>  FirstPacket - first message pack </li><li>  NoAsk - the message does not require the inclusion of a confirmation mechanism </li><li>  LastPacket - the last message packet </li><li>  RequestForPacket - confirmation package or request for a lost package </li></ul><br><h3><a name="commonlogic"></a>  General principles of the protocol </h3><br>  Since Reliable UDP is focused on guaranteed message transfer between two nodes, it must be able to establish a connection with the other party.  To establish a connection, the sending side sends a packet with the FirstPacket flag, the answer to which will mean setting up the connection.  All reply packets, or, in other words, acknowledgment packets, always set the value of the PacketNumber field to one greater than the highest PacketNumber value of successfully received packets.  In the Options field for the first packet sent, the message size is recorded. <br><br>  A similar mechanism is used to terminate the connection.  The last batch of the message sets the LastPacket flag.  The reply packet indicates the number of the last packet + 1, which for the receiving party means successful delivery of the message. <br><div class="spoiler">  <b class="spoiler_title">Connection establishment and termination diagram:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9be/237/ced/9be237cedf0c4313ae77928b4fd73d56.jpg"><br></div></div><br>  When the connection is established, data transfer begins.  Data is transmitted in blocks of packets.  Each block, except the last, contains a fixed number of packets.  It is equal to the size of the receive / transmit window.  The last data block may have fewer packets.  After sending each block, the sending side waits for a confirmation of delivery, or a request to re-deliver the lost packets, leaving the receive / transmit window open to receive replies.  After receiving confirmation of the delivery of the block, the transmit / receive window is shifted and the next block of data is sent. <br><br>  The receiving party accepts packets.  Each packet is checked for entry into the transmission window.  Packages that do not enter the window and duplicates are eliminated.  Since  Since the window size is strictly fixed and the same for both the receiver and the sender, in the case of delivery of a block of packets without losses, the window is shifted to receive packets of the next data block and a delivery confirmation is sent.  If the window does not fill up after the period set by the working timer, a check will be launched on which packets have not been delivered and re-delivery requests will be sent. <br><div class="spoiler">  <b class="spoiler_title">Retransmission Diagram:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/201/d08/9e6/201d089e6d7d46c688a83fcf3f991d4f.jpg"><br></div></div><br><h3><a name="timers"></a>  Timeouts and protocol timers </h3><br>  There are several reasons why a connection cannot be established.  For example, if the receiving party is offline.  In this case, when trying to establish a connection, the connection will be closed on timeout.  The Reliable UDP implementation uses two timers to set timeouts.  The first, a work timer, is used to wait for a response from a remote host.  If it is triggered on the sending side, then the last sent packet is re-sent.  If the timer is triggered by the recipient, then it checks for lost packets and sends re-delivery requests. <br><br>  The second timer is necessary to close the connection in case of lack of communication between the nodes.  For the sender side, it starts immediately after the working timer is triggered, and waits for a response from the remote node.  If there is no response for the established period, the connection is terminated and the resources are released.  For the recipient side, the connection closure timer starts after the double operation of the working timer.  This is necessary for insurance against the loss of a confirmation package.  When the timer is triggered, the connection is also completed and resources are released. <br><br><h3><a name="states"></a>  Reliable UDP transmission state diagram </h3><br>  The principles of the protocol are implemented in a finite state machine, each state of which is responsible for a certain packet processing logic. <br>  Reliable UDP state diagram: <br><br><img src="https://habrastorage.org/files/0fb/5b1/713/0fb5b17135fb4a96a02d769a17002c4d.jpg"><br><br>  <b>Closed</b> - not really a state, it is the starting and ending point for the automaton.  For the <b>Closed</b> state, the transmission control block is taken, which, realizing an asynchronous UDP server, redirects packets to the appropriate connections and starts state processing. <br><br>  <b>FirstPacketSending</b> - the initial state in which the outgoing connection is located when sending a message. <br><br>  In this state, the first packet is sent for regular messages.  For messages without sending confirmation, this is the only state - the entire message is sent there. <br><br>  <b>SendingCycle</b> ‚Äî The ground state for sending message packets. <br><br>  Transition to it from the <b>FirstPacketSending</b> state <b>is</b> carried out after sending the first message packet.  All confirmations and requests for retransmissions come to this state.  Exit from it is possible in two cases - in case of successful delivery of the message or on time-out. <br><br>  <b>FirstPacketReceived</b> - the initial state for the recipient of the message. <br><br>  It checks the correctness of the start of the transfer, creates the necessary structures, and sends an acknowledgment that the first packet has been received. <br><br>  For a message consisting of a single packet and sent without using delivery confirmation, this is the only state.  After processing such a message, the connection is closed. <br><br>  <b>Assembling</b> - the main state for receiving message packets. <br><br>  It writes packages to the temporary storage, checks for packet loss, sends confirmation of block block delivery and full messages, and sends requests for the re-delivery of lost packets.  In case of successful receipt of the entire message, the connection goes to the <b>Completed</b> state, otherwise the output is timed out. <br><br>  <b>Completed</b> - closing the connection in case of successful receipt of the entire message. <br><br>  This state is necessary to assemble the message and for the case when the confirmation of the message delivery was lost on the way to the sender.  The exit from this state is made on a time-out, but the connection is considered to be closed successfully. <br><br><h3><a name="code-tcb"></a>  Deeper into the code.  Transmission Control Unit </h3><br>  One of the key elements of Reliable UDP is the transmission control block.  The task of this unit is to store current connections and auxiliary elements, distribute incoming packets to the appropriate connections, provide an interface for sending packets to the connection, and implement the protocol API.  The transmission control block receives packets from the UDP layer and forwards them to the state machine for processing.  To receive packets, it uses an asynchronous UDP server. <br><div class="spoiler">  <b class="spoiler_title">Some members of the ReliableUdpConnectionControlBlock class:</b> <div class="spoiler_text"><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReliableUdpConnectionControlBlock</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IDisposable { //     .      public ConcurrentDictionary</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tuple&lt;EndPoint, Int32</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">byte[]&gt; IncomingStreams { get; private set;} //     .     . public ConcurrentDictionary</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tuple&lt;EndPoint, Int32</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">byte[]&gt; OutcomingStreams { get; private set; } // connection record   . private readonly ConcurrentDictionary</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tuple&lt;EndPoint, Int32</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReliableUdpConnectionRecord&gt; m_listOfHandlers; //    . private readonly List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReliableUdpSubscribeObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_subscribers</span></span></span><span class="hljs-class">; //   </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Socket</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_socketIn</span></span></span><span class="hljs-class">; //     </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_port</span></span></span><span class="hljs-class">; //  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IP</span></span></span><span class="hljs-class">  </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPAddress</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_ipAddress</span></span></span><span class="hljs-class">; //    </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPEndPoint</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalEndpoint</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//    //    public StatesCollection States { get; private set; } //   .    TransmissionId private readonly RNGCryptoServiceProvider m_randomCrypto; //... }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Implement an asynchronous UDP server:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">void</span></span> Receive() { EndPoint connectedClient = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IPEndPoint(IPAddress.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); //   ,   socket.BeginReceiveFrom byte[] buffer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> byte[DefaultMaxPacketSize + ReliableUdpHeader.Length]; //         this.m_socketIn.BeginReceiveFrom(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length, SocketFlags.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> connectedClient, EndReceive, buffer); } private <span class="hljs-type"><span class="hljs-type">void</span></span> EndReceive(IAsyncResult ar) { EndPoint connectedClient = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IPEndPoint(IPAddress.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">int</span></span> bytesRead = this.m_socketIn.EndReceiveFrom(ar, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> connectedClient); // ,    Receive(); // ..       -     //  IAsyncResult.AsyncState byte[] bytes = ((byte[]) ar.AsyncState).<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead); //    ReliableUdpHeader <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReliableUdpStateTools.ReadReliableUdpHeader(bytes, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>)) { //    -   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //     <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> <span class="hljs-type"><span class="hljs-type">record</span></span><span class="hljs-string"><span class="hljs-string">'   Tuple&lt;EndPoint, Int32&gt; key = new Tuple&lt;EndPoint, Int32&gt;(connectedClient, header.TransmissionId); //   connection record    ReliableUdpConnectionRecord record = m_listOfHandlers.GetOrAdd(key, new ReliableUdpConnectionRecord(key, this, header.ReliableUdpMessageType)); //        record.State.ReceivePacket(record, header, bytes); }</span></span></code> </pre><br></div></div><br>  For each message transmission, a structure is created containing the connection information.  Such a structure is called a <i>connection record</i> . <br><div class="spoiler">  <b class="spoiler_title">Some members of the ReliableUdpConnectionRecord class are:</b> <div class="spoiler_text"><pre> <code class="hljs ruby">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReliableUdpConnectionRecord</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDisposable</span></span></span><span class="hljs-class"> { //     </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">byte</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IncomingStream</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">;</span></span> set; } /<span class="hljs-regexp"><span class="hljs-regexp">/      public ReliableUdpState State { get; set; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   connection record /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     public Tuple&lt;EndPoint, Int32&gt; Key { get; private set;} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     public int WindowLowerBound; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    public readonly int WindowSize; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     public int SndNext; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     public int NumberOfPackets; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (      Tuple) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     public readonly Int32 TransmissionId; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  IP endpoint ‚Äì    public readonly IPEndPoint RemoteClient; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,     IP  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    MTU ‚Äì (IP.Header + UDP.Header + RelaibleUDP.Header) public readonly int BufferSize; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    public readonly ReliableUdpConnectionControlBlock Tcb; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      BeginSendMessage/</span></span>EndSendMessage public readonly AsyncResultSendMessage AsyncResult; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     public bool IsNoAnswerNeeded; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     (    ) public int RcvCurrent; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      public int[] LostPackets { get; private set; } /<span class="hljs-regexp"><span class="hljs-regexp">/    .   bool. public int IsLastPacketReceived = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/... }</span></span></code> </pre><br></div></div><br><h3><a name="code-states"></a>  Deeper into the code.  States </h3><br>  The states implement the state machine Reliable UDP, in which the main packet processing takes place.  The abstract class ReliableUdpState provides an interface for the state: <br><br><img src="https://habrastorage.org/files/b2a/cb7/d46/b2acb7d4648a42099a3fb630ff08c9bd.jpg"><br><br>  All the logic of the protocol is implemented by the above classes, together with an auxiliary class that provides static methods, such as, for example, constructing a ReliableUdp header from a connection record. <br><br>  Further, we will consider in details the implementation of interface methods that define the basic algorithms of the protocol. <br><br><h4><a name="code-dispose"></a>  DisposeByTimeout method </h4><br>  The DisposeByTimeout method is responsible for releasing connection resources after a timeout and for signaling a successful / unsuccessful message delivery. <br><div class="spoiler">  <b class="spoiler_title">ReliableUdpState.DisposeByTimeout:</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeByTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> record</span></span></span><span class="hljs-function">)</span></span> { ReliableUdpConnectionRecord connectionRecord = (ReliableUdpConnectionRecord) record; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record.AsyncResult != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { connectionRecord.AsyncResult.SetAsCompleted(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } connectionRecord.Dispose(); }</code> </pre><br></div></div><br>  It is redefined only in the <b>Completed</b> state. <br><div class="spoiler">  <b class="spoiler_title">Completed.DisposeByTimeout:</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeByTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> record</span></span></span><span class="hljs-function">)</span></span> { ReliableUdpConnectionRecord connectionRecord = (ReliableUdpConnectionRecord) record; <span class="hljs-comment"><span class="hljs-comment">//      SetAsCompleted(connectionRecord); }</span></span></code> </pre></div></div><br><h4><a name="code-process"></a>  ProcessPackets method </h4><br>  The ProcessPackets method is responsible for additional processing of the package or packages.  It is called directly or via the packet idle timer. <br><br>  In the state of <b>Assembling, the</b> method is redefined and is responsible for checking for lost packets and transitioning to the <b>Completed</b> state if the last packet was received and successful <br><div class="spoiler">  <b class="spoiler_title">Assembling.ProcessPackets:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override <span class="hljs-type"><span class="hljs-type">void</span></span> ProcessPackets(ReliableUdpConnectionRecord connectionRecord) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.IsDone != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReliableUdpStateTools.CheckForNoPacketLoss(connectionRecord, connectionRecord.IsLastPacketReceived != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { //   ,     <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> seqNum <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> connectionRecord.LostPackets) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seqNum != <span class="hljs-number"><span class="hljs-number">0</span></span>) { ReliableUdpStateTools.SendAskForLostPacket(connectionRecord, seqNum); } } //     ,     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!connectionRecord.TimerSecondTry) { connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); connectionRecord.TimerSecondTry = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //      WaitForPacketTimer //     -     StartCloseWaitTimer(connectionRecord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.IsLastPacketReceived != <span class="hljs-number"><span class="hljs-number">0</span></span>) //   { //       ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); connectionRecord.State = connectionRecord.Tcb.States.Completed; connectionRecord.State.ProcessPackets(connectionRecord); //     //  ,  ,  //   ack         . //    -   //   Completed    StartCloseWaitTimer(connectionRecord); } //  ,  ack      <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!connectionRecord.TimerSecondTry) { ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); connectionRecord.TimerSecondTry = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //     StartCloseWaitTimer(connectionRecord); } }</code> </pre></div></div><br>  In the <b>SendingCycle</b> state <b>,</b> this method is called only by timer, and is responsible for re-sending the last message, as well as for turning on the connection closure timer. <br><div class="spoiler">  <b class="spoiler_title">SendingCycle.ProcessPackets:</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessPackets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.IsDone != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     // (     -   ,     ) ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.RetransmissionCreateUdpPayload(connectionRecord, connectionRecord.SndNext - 1)); //   CloseWait ‚Äì        StartCloseWaitTimer(connectionRecord); }</span></span></code> </pre></div></div><br>  In the <b>Completed</b> state, the method stops the working timer and passes the message to the subscribers. <br><div class="spoiler">  <b class="spoiler_title">Completed.ProcessPackets:</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessPackets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.WaitForPacketsTimer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) connectionRecord.WaitForPacketsTimer.Dispose(); <span class="hljs-comment"><span class="hljs-comment">//       ReliableUdpStateTools.CreateMessageFromMemoryStream(connectionRecord); }</span></span></code> </pre></div></div><br><h4><a name="code-receive"></a>  ReceivePacket method </h4><br>  In the <b>FirstPacketReceived</b> state <b>, the</b> main task of the method is to determine whether the first message packet actually came to the interface, and also collect a message consisting of a single packet. <br><div class="spoiler">  <b class="spoiler_title">FirstPacketReceived.ReceivePacket:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override <span class="hljs-type"><span class="hljs-type">void</span></span> ReceivePacket(ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, byte[] payload) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.FirstPacket)) //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; //    - FirstPacket  LastPacket -       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.FirstPacket) &amp; <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.LastPacket)) { ReliableUdpStateTools.CreateMessageFromSinglePacket(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, payload.<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(ReliableUdpHeader.Length, payload.Length)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.NoAsk)) { //    ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); } SetAsCompleted(connectionRecord); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } // <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> design  packet numbers   <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; ReliableUdpStateTools.InitIncomingBytesStorage(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>); ReliableUdpStateTools.WritePacketData(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, payload); //  - ,    connectionRecord.NumberOfPackets = (<span class="hljs-type"><span class="hljs-type">int</span></span>)Math.Ceiling((<span class="hljs-type"><span class="hljs-type">double</span></span>) ((<span class="hljs-type"><span class="hljs-type">double</span></span>) connectionRecord.IncomingStream.Length/(<span class="hljs-type"><span class="hljs-type">double</span></span>) connectionRecord.BufferSize)); //      (<span class="hljs-number"><span class="hljs-number">0</span></span>) connectionRecord.RcvCurrent = <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber; //      <span class="hljs-number"><span class="hljs-number">1</span></span> connectionRecord.WindowLowerBound++; //   connectionRecord.State = connectionRecord.Tcb.States.Assembling; //      //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.NoAsk)) { connectionRecord.CloseWaitTimer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Timer(DisposeByTimeout, connectionRecord, connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); connectionRecord.WaitForPacketsTimer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Timer(CheckByTimer, connectionRecord, connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); } }</code> </pre></div></div><br>  In the <b>SendingCycle</b> state <b>,</b> this method is redefined to receive delivery acknowledgments and retransmission requests. <br><div class="spoiler">  <b class="spoiler_title">SendingCycle.ReceivePacket:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override <span class="hljs-type"><span class="hljs-type">void</span></span> ReceivePacket(ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, byte[] payload) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.IsDone != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.RequestForPacket)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; //     //    + <span class="hljs-number"><span class="hljs-number">1</span></span>,     <span class="hljs-type"><span class="hljs-type">int</span></span> windowHighestBound = Math.Min((connectionRecord.WindowLowerBound + connectionRecord.WindowSize), (connectionRecord.NumberOfPackets)); //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber &lt; connectionRecord.WindowLowerBound || <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber &gt; windowHighestBound) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.CloseWaitTimer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) connectionRecord.CloseWaitTimer.Change(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); //    : <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber == connectionRecord.NumberOfPackets) { //   Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> connectionRecord.IsDone); SetAsCompleted(connectionRecord); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //      c  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.FirstPacket) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber == <span class="hljs-number"><span class="hljs-number">1</span></span>)) { //    SendPacket(connectionRecord); } //       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber == windowHighestBound) { //   / connectionRecord.WindowLowerBound += connectionRecord.WindowSize; //     connectionRecord.WindowControlArray.Nullify(); //    SendPacket(connectionRecord); } //      ‚Äì    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.RetransmissionCreateUdpPayload(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber)); }</code> </pre></div></div><br>  In the <b>Assembling</b> state, in the ReceivePacket method, the main work is done on assembling messages from incoming packets. <br><div class="spoiler">  <b class="spoiler_title">Assembling.ReceivePacket:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override <span class="hljs-type"><span class="hljs-type">void</span></span> ReceivePacket(ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, byte[] payload) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.IsDone != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; //        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.NoAsk)) { //   connectionRecord.CloseWaitTimer.Change(connectionRecord.LongTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); //   ReliableUdpStateTools.WritePacketData(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, payload); //       -   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.LastPacket)) { connectionRecord.State = connectionRecord.Tcb.States.Completed; connectionRecord.State.ProcessPackets(connectionRecord); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //     <span class="hljs-type"><span class="hljs-type">int</span></span> windowHighestBound = Math.Min((connectionRecord.WindowLowerBound + connectionRecord.WindowSize - <span class="hljs-number"><span class="hljs-number">1</span></span>), (connectionRecord.NumberOfPackets - <span class="hljs-number"><span class="hljs-number">1</span></span>)); //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber &lt; connectionRecord.WindowLowerBound || <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber &gt; (windowHighestBound)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.WindowControlArray.Contains(<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; //   ReliableUdpStateTools.WritePacketData(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>, payload); //    connectionRecord.PacketCounter++; //         connectionRecord.WindowControlArray[<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber - connectionRecord.WindowLowerBound] = <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber; //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber &gt; connectionRecord.RcvCurrent) connectionRecord.RcvCurrent = <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.PacketNumber; //   connectionRecord.TimerSecondTry = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.CloseWaitTimer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) connectionRecord.CloseWaitTimer.Change(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.Flags.HasFlag(ReliableUdpHeaderFlags.LastPacket)) { Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> connectionRecord.IsLastPacketReceived); } //      ,    //     <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.PacketCounter == connectionRecord.WindowSize) { //  . connectionRecord.PacketCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; //    connectionRecord.WindowLowerBound += connectionRecord.WindowSize; //     connectionRecord.WindowControlArray.Nullify(); ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); } //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.VolatileRead(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> connectionRecord.IsLastPacketReceived) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { //   ProcessPackets(connectionRecord); } }</code> </pre></div></div><br>  In the <b>Completed</b> state, the only task of the method is to send another confirmation of successful delivery of the message. <br><div class="spoiler">  <b class="spoiler_title">Completed.ReceivePacket:</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceivePacket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] payload</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        , //   ack     if (header.Flags.HasFlag(ReliableUdpHeaderFlags.LastPacket)) { ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); } }</span></span></code> </pre></div></div><br><h4><a name="code-send"></a>  SendPacket method </h4><br>  In the <b>FirstPacketSending</b> state <b>,</b> this method sends the first data packet, or, if the message does not require delivery confirmation, the entire message. <br><div class="spoiler">  <b class="spoiler_title">FirstPacketSending.SendPacket:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override <span class="hljs-type"><span class="hljs-type">void</span></span> SendPacket(ReliableUdpConnectionRecord connectionRecord) { connectionRecord.PacketCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; connectionRecord.SndNext = <span class="hljs-number"><span class="hljs-number">0</span></span>; connectionRecord.WindowLowerBound = <span class="hljs-number"><span class="hljs-number">0</span></span>; //     -    //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.IsNoAnswerNeeded) { //    <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.CreateUdpPayload(connectionRecord, ReliableUdpStateTools. CreateReliableUdpHeader(connectionRecord))); connectionRecord.SndNext++; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (connectionRecord.SndNext &lt; connectionRecord.NumberOfPackets); SetAsCompleted(connectionRecord); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //       ReliableUdpHeader <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> = ReliableUdpStateTools.CreateReliableUdpHeader(connectionRecord); ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.CreateUdpPayload(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>)); //   connectionRecord.SndNext++; //   connectionRecord.WindowLowerBound++; connectionRecord.State = connectionRecord.Tcb.States.SendingCycle; //   connectionRecord.WaitForPacketsTimer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Timer(CheckByTimer, connectionRecord, connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre></div></div><br>  In the <b>SendingCycle</b> state, this method sends a block of packets. <br><div class="spoiler">  <b class="spoiler_title">SendingCycle.SendPacket:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override <span class="hljs-type"><span class="hljs-type">void</span></span> SendPacket(ReliableUdpConnectionRecord connectionRecord) { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (connectionRecord.PacketCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; connectionRecord.PacketCounter &lt; connectionRecord.WindowSize &amp;&amp; connectionRecord.SndNext &lt; connectionRecord.NumberOfPackets; connectionRecord.PacketCounter++) { ReliableUdpHeader <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> = ReliableUdpStateTools.CreateReliableUdpHeader(connectionRecord); ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.CreateUdpPayload(connectionRecord, <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>)); connectionRecord.SndNext++; } //     ,     connectionRecord.WaitForPacketsTimer.Change( connectionRecord.ShortTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( connectionRecord.CloseWaitTimer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) { connectionRecord.CloseWaitTimer.Change( <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> ); } }</code> </pre></div></div><br><h3><a name="code-connection"></a>  Deeper into the code.  Creating and making connections </h3><br>  Now that we have learned about the basic states and methods used to process states, we can analyze a few more examples of the operation of the protocol. <br><div class="spoiler">  <b class="spoiler_title">Data transmission diagram in normal conditions:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/bca/0ed/d01/bca0edd0173846fa8b6b4eaae97ba028.jpg"><br></div></div><br>  Let us consider in detail the creation of a <i>connection record</i> for connecting and sending the first packet.  The initiator of the transfer is always the application that calls the API method to send the message.  Next, the StartTransmission method of the transmission control block is activated, which starts the data transfer for the new message. <br><div class="spoiler">  <b class="spoiler_title">Create outbound connection:</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript">private void StartTransmission(ReliableUdpMessage reliableUdpMessage, EndPoint endPoint, AsyncResultSendMessage asyncResult) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isListenerStarted == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.LocalEndpoint == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException( <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"You must use constructor with parameters or start listener before sending message"</span></span> ); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     StartListener(LocalEndpoint); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,   EndPoint  ReliableUdpHeader.TransmissionId byte[] transmissionId = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    transmissionId m_randomCrypto.GetBytes(transmissionId); Tuple&lt;EndPoint, Int32&gt; key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple&lt;EndPoint, Int32&gt;(endPoint, BitConverter.ToInt32(transmissionId, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_listOfHandlers.TryAdd(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReliableUdpConnectionRecord(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, reliableUdpMessage, asyncResult))) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ‚Äì      m_randomCrypto.GetBytes(transmissionId); key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple&lt;EndPoint, Int32&gt;(endPoint, BitConverter.ToInt32(transmissionId, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_listOfHandlers.TryAdd(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReliableUdpConnectionRecord(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, reliableUdpMessage, asyncResult))) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ‚Äì   <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Pair TransmissionId &amp; EndPoint is already exists in the dictionary"</span></span>); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     m_listOfHandlers[key].State.SendPacket(m_listOfHandlers[key]); }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Sending the first packet (FirstPacketSending status):</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendPacket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { connectionRecord.PacketCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; connectionRecord.SndNext = <span class="hljs-number"><span class="hljs-number">0</span></span>; connectionRecord.WindowLowerBound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... //       ReliableUdpHeader header = ReliableUdpStateTools.CreateReliableUdpHeader(connectionRecord); ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.CreateUdpPayload(connectionRecord, header)); //   connectionRecord.SndNext++; //   connectionRecord.WindowLowerBound++; //    SendingCycle connectionRecord.State = connectionRecord.Tcb.States.SendingCycle; //   connectionRecord.WaitForPacketsTimer = new Timer(CheckByTimer, connectionRecord, connectionRecord.ShortTimerPeriod, -1); }</span></span></code> </pre></div></div><br>  After sending the first packet, the sender enters the <b>SendingCycle</b> state ‚Äî wait for confirmation of the packet delivery. <br>  The receiving side, using the EndReceive method, accepts the sent packet, creates a new <i>connection connection record</i> and sends the packet, with a pre-parsed header, to the <b>FirstPacketReceived</b> state's ReceivePacket method for processing <br><div class="spoiler">  <b class="spoiler_title">Creating a connection on the receiving side:</b> <div class="spoiler_text"><pre> <code class="hljs ruby">private void EndReceive(IAsyncResult ar) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... /<span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ReliableUdpHeader header; if (!ReliableUdpStateTools.ReadReliableUdpHeader(bytes, out header)) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    -   return; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     connection record'   Tuple&lt;EndPoint, Int32&gt; key = new Tuple&lt;EndPoint, Int32&gt;(connectedClient, header.TransmissionId); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   connection record    ReliableUdpConnectionRecord record = m_listOfHandlers.GetOrAdd(key, new ReliableUdpConnectionRecord(key, this, header. ReliableUdpMessageType)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        record.State.ReceivePacket(record, header, bytes); }</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Receiving the first packet and sending a confirmation (FirstPacketReceived state):</b> <div class="spoiler_text"><pre> <code class="hljs ruby">public override void ReceivePacket(ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader header, byte[] payload) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!header.Flags.HasFlag(ReliableUdpHeaderFlags.FirstPacket)) /<span class="hljs-regexp"><span class="hljs-regexp">/   return; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ by design  packet numbers   0; if (header.PacketNumber != 0) return; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ReliableUdpStateTools.InitIncomingBytesStorage(connectionRecord, header); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ReliableUdpStateTools.WritePacketData(connectionRecord, header, payload); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  - ,    connectionRecord.NumberOfPackets = (int)Math.Ceiling((double) ((double) connectionRecord.IncomingStream.Length/</span></span>(double) connectionRecord.BufferSize)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      (<span class="hljs-number"><span class="hljs-number">0</span></span>) connectionRecord.RcvCurrent = header.PacketNumber; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-number"><span class="hljs-number">1</span></span> connectionRecord.WindowLowerBound++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   connectionRecord.State = connectionRecord.Tcb.States.Assembling; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/*    */</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ ... else { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); connectionRecord.WaitForPacketsTimer = new Timer(CheckByTimer, connectionRecord, connectionRecord.ShortTimerPeriod, -1); } }</span></span></code> </pre></div></div><br><h3><a name="code-close"></a>  Deeper into the code.  Closing the connection by timeout </h3><br>  Working out timeouts is an important part of Reliable UDP.  Consider an example in which a failure occurred at the intermediate node and the delivery of data in both directions became impossible. <br><div class="spoiler">  <b class="spoiler_title">Connection closure diagram on timeout:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/fcd/b34/bda/fcdb34bdad324e57be8c2d058d57fa3e.jpg"><br></div></div><br>  As can be seen from the diagram, the working timer at the sender is activated immediately after sending a block of packets.  This happens in the SendPacket method of the <b>SendingCycle</b> state. <br><div class="spoiler">  <b class="spoiler_title">Enable the work timer (SendingCycle state):</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendPacket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    // ... //     connectionRecord.WaitForPacketsTimer.Change( connectionRecord.ShortTimerPeriod, -1 ); if ( connectionRecord.CloseWaitTimer != null ) connectionRecord.CloseWaitTimer.Change( -1, -1 ); }</span></span></code> </pre></div></div><br>  Timer periods are set when creating a connection.  By default, ShortTimerPeriod is 5 seconds.  In the example, it is set to 1.5 seconds. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an incoming connection, the timer starts after receiving the last received data packet; this happens in the state's ReceivePacket method of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembling</font></font></b> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enable the work timer (Assembling state):</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceivePacket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] payload</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... //   connectionRecord.TimerSecondTry = false; connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, -1); if (connectionRecord.CloseWaitTimer != null) connectionRecord.CloseWaitTimer.Change(-1, -1); // ... }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the incoming connection, more packets did not arrive during the waiting time of the working timer. </font><font style="vertical-align: inherit;">The timer worked and called the ProcessPackets method, in which the lost packets were found and re-delivery requests were sent the first time.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sending re-delivery requests (Assembling status):</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">public override void ProcessPackets(ReliableUdpConnectionRecord connectionRecord) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/*    */</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      /<span class="hljs-regexp"><span class="hljs-regexp">/     ,     if (!connectionRecord.TimerSecondTry) { connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, -1); connectionRecord.TimerSecondTry = true; return; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WaitForPacketTimer /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -     StartCloseWaitTimer(connectionRecord); } else if (/</span></span>*      *<span class="hljs-regexp"><span class="hljs-regexp">/) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... StartCloseWaitTimer(connectionRecord); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ack      else { if (!connectionRecord.TimerSecondTry) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ack connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, -1); connectionRecord.TimerSecondTry = true; return; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     StartCloseWaitTimer(connectionRecord); } }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The variable TimerSecondTry is set to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This variable is responsible for restarting the working timer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sender also triggers a working timer and resends the last packet sent.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enable the connection closure timer (SendingCycle state):</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessPackets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... //     // ... //   CloseWait ‚Äì        StartCloseWaitTimer(connectionRecord); }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After that, the outgoing connection starts the timer to close the connection. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReliableUdpState.StartCloseWaitTimer:</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartCloseWaitTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connectionRecord.CloseWaitTimer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) connectionRecord.CloseWaitTimer.Change(connectionRecord.LongTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> connectionRecord.CloseWaitTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(DisposeByTimeout, connectionRecord, connectionRecord.LongTimerPeriod, <span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The timeout period for the connection closure timer is 30 seconds by default. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a short time, the working timer on the receiver side re-activates, requests are sent again, after which the connection closure timer is started at the incoming connection </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The sender reports a failed delivery to the parent application ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">see Reliable UDP API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Releasing connection record'a resources:</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { System.Threading.Monitor.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.LockerReceive); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsDone); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WaitForPacketsTimer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { WaitForPacketsTimer.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CloseWaitTimer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { CloseWaitTimer.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] stream; Tcb.IncomingStreams.TryRemove(Key, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> stream); stream = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Tcb.OutcomingStreams.TryRemove(Key, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> stream); stream = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; System.Threading.Monitor.Exit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.LockerReceive); } }</code> </pre></div></div><br><br><h3><a name="code-recover"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deeper into the code. </font><font style="vertical-align: inherit;">Data transfer recovery</font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Recovery Recovery Diagram with Packet Loss:</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/26e/4c0/d9f/26e4c0d9f8574f67ab5c99138fe22c1a.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As already discussed in closing the connection with a timeout, upon expiration of the working timer, the recipient will be checked for lost packets. </font><font style="vertical-align: inherit;">In the case of packet loss, a list of the number of packets that have not reached the recipient will be compiled. </font><font style="vertical-align: inherit;">These numbers are entered into the LostPackets array of the specific connection and re-delivery requests are sent.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sending requests for re-delivery of packages (Assembling state):</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessPackets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... if (!ReliableUdpStateTools.CheckForNoPacketLoss(connectionRecord, connectionRecord.IsLastPacketReceived != 0)) { //   ,     foreach (int seqNum in connectionRecord.LostPackets) { if (seqNum != 0) { ReliableUdpStateTools.SendAskForLostPacket(connectionRecord, seqNum); } } // ... } }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sender will accept the request for re-delivery and send the missing packets. </font><font style="vertical-align: inherit;">It is worth noting that at this moment the sender has already started the closure of the connection and, upon receipt of the request, it is reset.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resending lost packets (SendingCycle state):</font></font></b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceivePacket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] payload</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, -1); //     if (connectionRecord.CloseWaitTimer != null) connectionRecord.CloseWaitTimer.Change(-1, -1); // ... //      ‚Äì    else ReliableUdpStateTools.SendPacket(connectionRecord, ReliableUdpStateTools.RetransmissionCreateUdpPayload(connectionRecord, header.PacketNumber)); }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The retransmitted packet (packet # 3 in the diagram) is received by the incoming connection. </font><font style="vertical-align: inherit;">A check is performed to fill the receive window and normal data transfer is restored.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Check for getting into the reception window (Assembling state):</font></font></b> <div class="spoiler_text"><pre> <code class="hljs ruby">public override void ReceivePacket(ReliableUdpConnectionRecord connectionRecord, ReliableUdpHeader header, byte[] payload) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... /<span class="hljs-regexp"><span class="hljs-regexp">/    connectionRecord.PacketCounter++; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         connectionRecord.WindowControlArray[header.PacketNumber - connectionRecord.WindowLowerBound] = header.PacketNumber; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     if (header.PacketNumber &gt; connectionRecord.RcvCurrent) connectionRecord.RcvCurrent = header.PacketNumber; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   connectionRecord.TimerSecondTry = false; connectionRecord.WaitForPacketsTimer.Change(connectionRecord.ShortTimerPeriod, -1); if (connectionRecord.CloseWaitTimer != null) connectionRecord.CloseWaitTimer.Change(-1, -1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     else if (connectionRecord.PacketCounter == connectionRecord.WindowSize) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . connectionRecord.PacketCounter = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    connectionRecord.WindowLowerBound += connectionRecord.WindowSize; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     connectionRecord.WindowControlArray.Nullify(); ReliableUdpStateTools.SendAcknowledgePacket(connectionRecord); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... }</span></span></code> </pre></div></div><br><h3><a name="rudp-api"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reliable UDP API </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To interact with the data transfer protocol, there is an open class Reliable Udp, which is a wrapper over the transmission control block. </font><font style="vertical-align: inherit;">Here are the most important members of the class:</font></font><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> sealed <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ReliableUdp : IDisposable { //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IPEndPoint LocalEndpoint //   ReliableUdp   //      IP  //  .  <span class="hljs-number"><span class="hljs-number">0</span></span>     //    <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ReliableUdp(IPAddress localAddress, <span class="hljs-type"><span class="hljs-type">int</span></span> port = <span class="hljs-number"><span class="hljs-number">0</span></span>) //      <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ReliableUdpSubscribeObject SubscribeOnMessages(ReliableUdpMessageCallback callback, ReliableUdpMessageTypes messageType = ReliableUdpMessageTypes.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>, IPEndPoint ipEndPoint = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Unsubscribe(ReliableUdpSubscribeObject subscribeObject) //    // :   XP  <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> <span class="hljs-number"><span class="hljs-number">2003</span></span>  , ..  .NET Framework <span class="hljs-number"><span class="hljs-number">4.0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Task&lt;<span class="hljs-type"><span class="hljs-type">bool</span></span>&gt; SendMessageAsync(ReliableUdpMessage reliableUdpMessage, IPEndPoint remoteEndPoint, CancellationToken cToken) //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IAsyncResult BeginSendMessage(ReliableUdpMessage reliableUdpMessage, IPEndPoint remoteEndPoint, AsyncCallback asyncCallback, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> state) //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> EndSendMessage(IAsyncResult asyncResult) //   <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Dispose() }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Receiving a message is by subscription. </font><font style="vertical-align: inherit;">Delegate signature for callback method:</font></font><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReliableUdpMessageCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ReliableUdpMessage reliableUdpMessage, IPEndPoint remoteClient </span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Message: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ReliableUdpMessage { //  ,   <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ReliableUdpMessageTypes <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } //   <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> byte[] Body { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } //    <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ‚Äì      //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> NoAsk { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To subscribe to a specific type of message and / or to a specific sender, two optional parameters are used: ReliableUdpMessageTypes messageType and IPEndPoint ipEndPoint. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Types of messages:</font></font><br><pre> <code class="hljs ruby">public enum ReliableUdpMessageTypes : short { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Any = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   STUN server StunRequest = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   STUN server StunResponse = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   FileTransfer =<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The message is sent asynchronous; for this, the protocol implements </font></font><abbr title="Asynchronous Programming Model"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an asynchronous programming model</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IAsyncResult BeginSendMessage(ReliableUdpMessage reliableUdpMessage, IPEndPoint remoteEndPoint, AsyncCallback asyncCallback, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> state)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The result of sending a message will be true - if the message successfully reached the recipient and false - if the connection was closed due to a timeout: </font></font><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncResult asyncResult</span></span></span><span class="hljs-function">)</span></span></code> </pre><br><br><h3><a name="end1"></a>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Much has not been described in this article. Thread matching mechanisms, exception and error handling, implementation of asynchronous message sending methods. But the core of the protocol, the description of the packet processing logic, the setting up of the connection, and the processing of timeouts must be clarified for you. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The demonstrated version of the reliable delivery protocol is fairly stable and flexible, and meets previously defined requirements. But I want to add that the described implementation can be improved. For example, to increase bandwidth and dynamically change the periods of timers in the protocol, you can add mechanisms such as sliding window and </font></font><abbr title="Round-Trip Time"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTT</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the implementation of the </font><abbr title="Maximum Transmission Unit"><font style="vertical-align: inherit;">MTU</font></abbr><font style="vertical-align: inherit;"> detection mechanism would also be useful</font></font><abbr title="Maximum Transmission Unit"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">between the nodes of the connection (but only in the case of sending large messages). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for your attention, waiting for your comments and comments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS For those who are interested in details or just want to test the protocol, the link to the project on GitHube: </font></font><br> <a href="http://github.com/lihtarovich/ReliableUdp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project Reliable UDP</font></font></a> <br><br><h3><a name="links"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Useful links and articles </font></font></h3><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP protocol specification: </font></font><a href="http://tools.ietf.org/html/rfc793"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in English</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://rfc.com.ru/rfc793.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Russian</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP protocol specification: </font></font><a href="http://tools.ietf.org/html/rfc768"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in English</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://rfc.com.ru/rfc768.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Russian</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RUDP protocol discussion: </font></font><a href="http://tools.ietf.org/html/draft-ietf-sigtran-reliable-udp-00"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">draft-ietf-sigtran-reliable-udp-00</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliable Data Protocol: </font></font><a href="http://tools.ietf.org/html/rfc908"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rfc 908</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://tools.ietf.org/html/rfc%25201151"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rfc 1151</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple implementation of confirming delivery via UDP: </font></font><a href="http://msdn.microsoft.com/en-us/magazine/cc163648.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take Total Control Of Your Networking With .NET And UDP</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An article describing the mechanisms to overcome NATs: </font></font><a href="http://www.brynosaurus.com/pub/net/p2pnat/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peer-to-Peer Communication Across Network Address Translators</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing an </font></font><a href="http://msdn.microsoft.com/en-us/magazine/cc163467.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous Programming Model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="http://msdn.microsoft.com/en-us/magazine/cc163467.aspx"><font style="vertical-align: inherit;">Implementing the CLR Asynchronous Programming Model</font></a><font style="vertical-align: inherit;"> and </font></font><a href="http://blogs.msdn.com/b/nikos/archive/2011/03/14/how-to-implement-iasyncresult-in-another-way.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the IAsyncResult design pattern</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transferring asynchronous programming model in an asynchronous pattern, based on tasks (APM in the TAP): </font></font><br> <a href="http://msdn.microsoft.com/en-us/library/dd997423%2528v%3Dvs.100%2529.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the TPL and Traditional .NET Asynchronous Programming </font></font></a> <br> <a href="http://msdn.microsoft.com/en-us/library/hh873178%2528v%3Dvs.110%2529.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of Interop with Other Asynchronous Patterns and the Types</font></font></a> </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update: Thanks to </font></font><a href="https://habrahabr.ru/users/mayorovp/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayorovp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://habrahabr.ru/users/sidristij/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sidristij</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the idea of ‚Äã‚Äãadding a task to the interface. </font><font style="vertical-align: inherit;">Compatibility of the library with the old OS is not broken, because </font><font style="vertical-align: inherit;">The 4th framework supports both XP and 2003 server.</font></font></div><p>Source: <a href="https://habr.com/ru/post/250227/">https://habr.com/ru/post/250227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250209/index.html">PVS-Studio for Microsoft Visual Studio Community 2013</a></li>
<li><a href="../250217/index.html">Reduce development and testing time with Azure Web Sites and Visual Studio Online</a></li>
<li><a href="../250219/index.html">Technopark - 3 years</a></li>
<li><a href="../250221/index.html">Programmer fanatic</a></li>
<li><a href="../250223/index.html">The digest of interesting materials from the world of Drupal # 4</a></li>
<li><a href="../250229/index.html">PIC16F1503. Wheelbarrow for pumping - 2. Light</a></li>
<li><a href="../250231/index.html">We write full tweak for iOS using iOSOpenDev</a></li>
<li><a href="../250233/index.html">EveryLang - translate, check spelling, switch and show the current keyboard layout</a></li>
<li><a href="../250235/index.html">Oddities in the work of Yandex.Metro: debriefing and update applications</a></li>
<li><a href="../250237/index.html">HotSpot - margin notes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>