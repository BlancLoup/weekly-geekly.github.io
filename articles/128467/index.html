<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We do ourselves a remote-desktop client for a smartphone. Part 1: Server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I always wanted to have a portable remote desktop on my phone, so that, for example, when someone was knocking on ICQ, and I went out to the balcony t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We do ourselves a remote-desktop client for a smartphone. Part 1: Server</h1><div class="post__text post__text-html js-mediator-article">  I always wanted to have a portable remote desktop on my phone, so that, for example, when someone was knocking on ICQ, and I went out to the balcony to smoke, I could look at the phone, who was there, without leaving the balcony.  Well, or, for example, switch the track, taking a bath.  Yes, I know that all sorts of VNC clients have already been written, but I decided to make such a program myself. <br><br>  In the first part of the article, I will confine myself to creating a simple remote desktop application, in which both the server and the client will work on ordinary desktop computers.  In the second and third part, I will consider image compression and programming of the phone itself. <br><br>  I imagine the final functionality in the following way: a program residently hangs on the detope (server), which, on the incoming UDP packet, begins to send fragments of the image to the return address.  On the phone (client) displays sent fragments.  The user can move the display window or click inside it.  Information about shifts and clicks is transmitted to the server in the same way - via UDP. <br><a name="habracut"></a><br>  I apologize in advance for what I am writing in C #, as if it were Javascript - firstly, in the article I want to get by with short listings, secondly, the program is really simple and dilute complex data structures here why, well, thirdly, C # is no longer a pure-OOP language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Due to the small complexity of the program, I chose the simplest ‚Äúon the knee‚Äù development process known to me - consecutive simple complications. <br><br>  Let's start with the simplest program that just shows us a fragment of our own desktop, in motion: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">rd2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Form f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Form(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Windows.Forms.Timer() { Interval = <span class="hljs-number"><span class="hljs-number">40</span></span> }; timer.Tick += (s, e) =&gt; { Graphics g = f.CreateGraphics(); g.CopyFromScreen(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, f.Size); g.Dispose(); }; timer.Start(); Application.Run(f); } } }</code> </pre> <br>  Everything is simple: create a window, create a timer, based on the events from which the image will be captured and copied to the window, launch it.  Make sure everything works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/002/7c9/cc2/0027c9cc20dfad16d51dfa83c32d0082.png" alt="everything is working"><br><br>  Now add the drag and drop of the desktop inside the window.  Immediately after creating the form, insert: <br><pre> <code class="cs hljs">Point window_topleft = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(); Size mouse_prev_loc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mouse_lbdown = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; f.MouseDown += (s,e) =&gt; { mouse_lbdown = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; f.MouseUp += (s, e) =&gt; { mouse_lbdown = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; f.MouseMove += (s, e) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mouse_lbdown) window_topleft += mouse_prev_loc - (Size)(e.Location); mouse_prev_loc = (Size)e.Location; };</code> </pre><br>  The variable window_topleft is the coordinate of the upper left corner of the area that is displayed in the window.  Fix CopyFromScreen: <br><pre> <code class="cs hljs">g.CopyFromScreen(window_topleft.X, window_topleft.Y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, f.Size);</code> </pre> <br>  Fine!  It is dragged. <br><br>  Now we add the processing of clicks of the left mouse button, so that the click inside the window is translated into a click on what is displayed in this window.  In order to distinguish dragging from a click, I will memorize the coordinates at which the mouse button was pressed, and if the mouse was not moved too far by pressing, I would generate a mouse click instead of dragging.  Like this: <br><pre> <code class="cs hljs">Point mouse_down_loc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(); f.MouseDown += (s, e) =&gt; { mouse_lbdown = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; mouse_down_loc = e.Location; }; f.MouseUp += (s, e) =&gt; { mouse_lbdown = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Math.Abs(e.Location.X - mouse_down_loc.X) &lt;<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; Math.Abs(e.Location.Y - mouse_down_loc.Y) &lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> click_to_x = (window_topleft.X + mouse_down_loc.X) * <span class="hljs-number"><span class="hljs-number">65536</span></span> / Screen.PrimaryScreen.Bounds.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> click_to_y = (window_topleft.Y + mouse_down_loc.Y) * <span class="hljs-number"><span class="hljs-number">65536</span></span> / Screen.PrimaryScreen.Bounds.Height; mouse_event((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE), (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)click_to_x, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)click_to_y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); mouse_event((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(MOUSEEVENTF_LEFTUP | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE), (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)click_to_x, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)click_to_y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } };</code> </pre><br>  A mouse click is obtained from two consecutive calls to the WinAPI function mouse_event.  The first call is a button click (MOUSEEVENTF_LEFTDOWN), the second is a release (MOUSEEVENTF_LEFTUP).  Together with the push of a button, we transfer the movement (MOUSEEVENTF_MOVE) of the mouse to the desired coordinates, which are indicated by the absolute value (MOUSEEVENTF_ABSOLUTE).  Zero absolute mouse coordinates are located in the upper left corner of the primary screen (PrimaryScreen).  The point (65535, 65535) is located in the lower right corner of the same screen.  All other screens, if they are in the system, are adjacent to this square. <br><br>  Well, of course, you need to export yourself a mouse_event.  This declaration is located in the class declaration: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"user32.dll"</span></span></span><span class="hljs-meta">, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mouse_event</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cButtons, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExtraInfo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MOUSEEVENTF_MOVE = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MOUSEEVENTF_LEFTDOWN = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MOUSEEVENTF_LEFTUP = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MOUSEEVENTF_ABSOLUTE = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>;</code> </pre><br><h2>  What you should think about before moving on </h2><br>  UDP loses, delays and reorders packets.  In the task being solved, re-sending the packet is meaningless: by the time we determine that the packet has been lost, it is already time to refresh the screen again.  That is why I chose UDP, not TCP.  It is impossible to fight losses, but you need to adapt to them: the protocol should not have a long-lived state, and packet losses should not be fatal or spoil the picture for a long time. <br><br>  Transferring a fragment of a screen the size of a smartphone's screen, even at a frequency of 10 hertz, is 3 * 800 * 480 * 10 = 11520000 bytes per second.  This is almost 100 megabits.  Without compression can not do. <br>  There is no need to re-send parts of the screen that have not changed - there can be quite a lot of them.  But you can‚Äôt completely refuse to send unchanged parts - we have an unreliable channel, and, in fact, we do not know what is displayed on the client. <br><br>  Window size may vary.  For example, due to the rotation of the phone from portrait to landscape mode. <br>  However, it is impossible to take into account all these observations at once - work will arise from reflection.  Therefore, for starters, just ignore everything that is possible, for the sake of simplicity. <br><br><h2>  We split in two </h2><br>  And now we will begin to divide the available program into two - the server and the client.  Let them still remain within the same process, but let them work in different threads and are not dependent on each other by data. <br><br>  At this stage it would be possible to force the program to send datagrams to itself, but that would be too big a step.  To begin with, I chose the ConcurrentQueue as the channel of interaction between these two processes ‚Äî this is a thread-safe queue designed to implement the Producer-Consumer interaction.  On the direct channel, the server will deliver fragments of the image to the client, and the client, on the return channel, will deliver information about the viewing window shifts and mouse clicks. <br><br>  ConcurrentQueue in many properties is related to UDP, and when we debug the interaction through ConcurrentQueue, I hope to just replace the work with the queue to send and receive datagrams.  In order for such a replacement to be simple, you need to bring the program to ensure that the queues are transmitted byte sequences of small length. <br>  But first, I will use typed queues. <br>  We divide <br><br>  First, we define the data structures that will be used to send messages from the server to the client and back: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ImageChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Rectangle place; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Bitmap img; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ControlData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Action : <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> { Shift, Click }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Action action; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Point point; }</code> </pre><br>  So, the server sends an image to the client, indicating where it was located on its server, monitor.  Back - Shifts (Shift) and Mouse Clicks (Click);  Let's agree to use server coordinates everywhere. <br><br>  Now let's copy the existing Main function again, rename both copies to Server and Client, and write the new Main: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img_channel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlockingCollection&lt;ImageChunk&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;ImageChunk&gt;() ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> control_channel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlockingCollection&lt;ControlData&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;ControlData&gt;()); Server(control_channel, img_channel); Client(img_channel, control_channel); }</code> </pre><br>  It looks like a textual statement of a simple flowchart, right? <br><br>  Remove from the Server all that does not relate to capturing an image from the screen and add work with queues.  Also, I decided to fix the window size at 400x300 on the client and on the server so that the listing does not grow even a couple of paragraphs. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Server</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlockingCollection&lt;ControlData&gt; input, BlockingCollection&lt;ImageChunk&gt; output</span></span></span><span class="hljs-function">)</span></span> { Point window_topleft = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(); Size window_size = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(<span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Windows.Forms.Timer() { Interval = <span class="hljs-number"><span class="hljs-number">40</span></span> }; timer.Tick += (s, e) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ControlData incoming; while (input.TryTake(out incoming)) { switch (incoming.action) { case ControlData.Action.Click: mouse_event((uint)(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE), (uint)incoming.point.X, (uint)incoming.point.Y, 0, 0); mouse_event((uint)(MOUSEEVENTF_LEFTUP | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE), (uint)incoming.point.X, (uint)incoming.point.Y, 0, 0); break; case ControlData.Action.Shift: window_topleft = incoming.point; break; } } //        var b = new Bitmap(window_size.Width,window_size.Height); var g = Graphics.FromImage(b); g.CopyFromScreen(window_topleft.X, window_topleft.Y, 0, 0, window_size); g.Dispose(); output.Add(new ImageChunk() { img = b, place = new Rectangle(window_topleft, window_size) } ); }; timer.Start(); }</span></span></code> </pre><br>  From Client, we remove everything that Server now does for it: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Client</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlockingCollection&lt;ImageChunk&gt; input, BlockingCollection&lt;ControlData&gt; output</span></span></span><span class="hljs-function">)</span></span> { Form f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Form(){ ClientSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(<span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>) }; Point window_topleft = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(); Size mouse_prev_loc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mouse_lbdown = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Point mouse_down_loc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(); <span class="hljs-comment"><span class="hljs-comment">//    f.MouseDown += (s, e) =&gt; { mouse_lbdown = true; mouse_down_loc = e.Location; }; f.MouseUp += (s, e) =&gt; { mouse_lbdown = false; if (Math.Abs(e.Location.X - mouse_down_loc.X) &lt; 1 &amp;&amp; Math.Abs(e.Location.Y - mouse_down_loc.Y) &lt; 1) { int click_to_x = (window_topleft.X + mouse_down_loc.X) * 65536 / Screen.PrimaryScreen.Bounds.Width; int click_to_y = (window_topleft.Y + mouse_down_loc.Y) * 65536 / Screen.PrimaryScreen.Bounds.Height; output.Add(new ControlData() { action=ControlData.Action.Click, point=new Point(click_to_x,click_to_y) }); } }; f.MouseMove += (s, e) =&gt; { if (mouse_lbdown) { window_topleft += mouse_prev_loc - (Size)(e.Location); output.Add(new ControlData() { action = ControlData.Action.Shift, point = window_topleft } ); } mouse_prev_loc = (Size)e.Location; }; //    var timer = new System.Windows.Forms.Timer() { Interval = 40 }; timer.Tick += (s, e) =&gt; { ImageChunk incoming; //    -  if( ! input.TryTake(out incoming,5) ) return; Graphics g = f.CreateGraphics(); g.DrawImageUnscaled(incoming.img, incoming.place.X - window_topleft.X, incoming.place.Y - window_topleft.Y); g.Dispose(); incoming.img.Dispose(); }; timer.Start(); Application.Run(f); }</span></span></code> </pre><br>  The appearance of the application has not changed, so the screenshot will not be. <br><h2>  NB: by the way, you can fork here .. </h2><br>  ... and make yourself a remote desktop via pipes, via http, through RS232, etc. It is enough just to write serialization, compression and transport for objects that are queuing. <br><br>  In the next part of the article I will describe the compression, sharpened by the subsequent transfer via UDP.  A special feature of UDP is the small size of atomically transmitted data (packets), as well as the loss and reordering of packets. <br></div><p>Source: <a href="https://habr.com/ru/post/128467/">https://habr.com/ru/post/128467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128458/index.html">Centos release 5.7 released</a></li>
<li><a href="../128460/index.html">Cards, Money and QIWI Eggs</a></li>
<li><a href="../128463/index.html">Advanced Wire Storage</a></li>
<li><a href="../128464/index.html">Day killer</a></li>
<li><a href="../128466/index.html">Ways to bypass BIOS passwords</a></li>
<li><a href="../128469/index.html">C ++: how not to make a movie is not for everyone</a></li>
<li><a href="../128470/index.html">RIPE NCC submitted for public discussion a proposal for a scheme to pay for the allocated resources for the next year.</a></li>
<li><a href="../128471/index.html">Windows 8 Developer Preview on the tablet</a></li>
<li><a href="../128473/index.html">Intel and Google optimize Android for x86 architecture</a></li>
<li><a href="../128475/index.html">Eloquera 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>