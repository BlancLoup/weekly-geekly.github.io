<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GHIDRA, Playstation 1 executables, FLIRT signatures and PsyQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all, 





 I don‚Äôt know about you, but I always wanted to reverse the old console games, having a decompiler in stock as well. And now, this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GHIDRA, Playstation 1 executables, FLIRT signatures and PsyQ</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello to all, </p><br><p><img src="https://habrastorage.org/webt/er/4d/30/er4d30mv0sfltitbawtcyvprbsq.jpeg"></p><br><p>  I don‚Äôt know about you, but I always wanted to reverse the old console games, having a decompiler in stock as well.  And now, this joyful moment in my life has come - <strong><a href="https://ghidra-sre.org/">GHIDRA</a></strong> is out.  I will not write about what it is, you can easily google it.  And the reviews are so different (especially from retrogrades) that it will be difficult for a beginner to even decide to launch this miracle ... Here‚Äôs an example: ‚Äú <em>I‚Äôve been working for 20 years, and I look at your Hydra with great distrust, because the NSA. But I will start something and check it in business</em> ". <a name="habracut"></a></p><br><p>  If in a nutshell - run Hydra is not scary.  And what we get after the launch will block all your fear of bookmarks-and-backdoors from the omnipresent NSA. </p><br><p>  So, what am I talking about ... There is such a prefix: <em>Sony Playstation 1</em> ( <em>PS1</em> , <em>PSX</em> , <em>Ployka</em> ).  Under it was created a lot of cool games, there was a bunch of franchises that are still popular.  And I once wanted to find out how they work: what are the data formats, whether resource compression is used, try to translate something into Russian (I‚Äôll say right away, until I have translated a single game). </p><br><p> I started by writing a cool utility for working with the <code>TIM</code> format with a friend in <code>Delphi</code> (this is something like <code>BMP</code> from the Playstation world): <strong><a href="https://github.com/lab313ru/tim2view">Tim2View</a></strong> .  At one time I enjoyed success (and maybe even now).  Then I wanted to delve into the compression. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/95a/82d/ad5/95a82dad5e8cf1770315215ac1cb138e.png" alt="image"></p><br><p>  And then the problems started.  I was not yet familiar with the <code>MIPS</code> processor.  Undertook to study.  I was not familiar with <code>IDA Pro</code> either (I came to reverse games on the <code>Sega Mega Drive</code> later on the <code>Playstation</code> ).  But, thanks to the Internet, I learned that <code>IDA Pro</code> does support the download and analysis of <code>PS1</code> executable files: <strong>PS-X EXE</strong> .  I tried to upload the game file (it seems it was <strong>Lemmings</strong> ) with a strange name and extension, such as <code>SLUS_123.45</code> in Ida, got a bunch of assembler code lines (fortunately, I already had an idea of ‚Äã‚Äãwhat it was, thanks to Windows exe x86), and began to understand. </p><br><p><img src="https://habrastorage.org/webt/d8/d5/81/d8d581oddbuzq95aw7nyebedpzw.png"></p><br><p>  The first difficult place to understand was the conveyor of instructions.  For example, you see a call to a function, and immediately after it is loaded into the register of the parameter that should be used in this function.  In short, before any jumps and calls to functions, first the instruction following the jump / call is executed, and only then the call itself or the jump. </p><br><p>  After all the difficulties passed, I managed to write several game resource packers / unpackers.  But I was never engaged in studying the code.  Why?  Well, everything is trivial: there was a lot of code, access to the BIOS and functions that were practically impossible to understand (they were library-based, and the SDK was not available to me at the time), instructions working with three registers at the same time, no decompiler. </p><br><p>  And now, after many, many years, <code>GHIDRA</code> comes <code>GHIDRA</code> .  Among the platforms supported by the decompiler is <code>MIPS</code> .  Oh, joy!  Let's try to decompile something soon!  But ... I was waiting for a bummer.  <code>PS-X EXE</code> not supported by Hydra.  Do not worry, write your own! </p><br><h2 id="sobstvenno-kod">  Actually code </h2><br><p>  Enough lyrical digressions, let's write the code.  How to create your own loaders for <code>Ghidra</code> , I already had an idea about what I <a href="https://habr.com/ru/post/444562/">wrote earlier</a> .  Therefore, it remains only to find the <em>Memory Map of the</em> first ploy, the addresses of registers and, you can collect and load binaries.  No sooner said than done. </p><br><p>  The code was ready, registers and regions were added and recognized, but there was still a big white spot in the field of calls to library functions and BIOS functions.  And, unfortunately, Hydra did not have <code>FLIRT</code> support.  If not, let's add. </p><br><p>  The <code>FLIRT</code> format of the signatures is known and described in the <code>pat.txt</code> file, which can be found in the Ida SDK.  Also, Ida has a utility for creating these signatures specifically from the <code>Playstation</code> library files, and is called: <code>ppsx</code> .  I downloaded the SDK for a <code>PsyQ Playstation Development Kit</code> called <code>PsyQ Playstation Development Kit</code> , I found <code>lib</code> files there and tried to create at least some signatures from them - successfully.  It turns out tekstovichok in which each line has a specific format.  It remains to write the code that will parse these lines, and apply them to the code. </p><br><p><img src="https://habrastorage.org/webt/kw/0a/kc/kw0akcnlzbiwjctarj1h4axq8ri.png"></p><br><h3 id="patparser">  Pat parser </h3><br><p>  Since each line has a specific format, it will be logical to write a regular expression.  It turned out like this: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern linePat = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"^((?:[0-9A-F\\.]{2})+) ([0-9A-F]{2}) ([0-9A-F]{4}) ([0-9A-F]{4}) ((?:[:\\^][0-9A-F]{4}@? [\\.\\w]+ )+)((?:[0-9A-F\\.]{2})+)?$"</span></span>);</code> </pre> <br><p>  Well, to select later in the list of modules a separate offset, type, and function name, we write a separate regexp: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern modulePat = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"([:\\^][0-9A-F]{4}@?) ([\\.\\w]+) "</span></span>);</code> </pre> <br><p>  Now let's go through the components of each signature separately: </p><br><ol><li>  First comes the hex-sequence of bytes ( <em>0-9A-F</em> ), where some of them can be any (the dot character ".").  Therefore, we create a class that will store such a sequence.  I called it <code>MaskedBytes</code> : </li></ol><br><div class="spoiler">  <b class="spoiler_title">MaskedBytes.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> pat; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaskedBytes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes, masks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] getBytes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] getMasks() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> masks; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes.length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaskedBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] masks)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bytes = bytes; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.masks = masks; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MaskedBytes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MaskedBytes src, MaskedBytes add)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extend(src, add.getBytes(), add.getMasks()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MaskedBytes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MaskedBytes src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] addBytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] addMasks)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = src.getBytes().length; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] tmpBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length + addBytes.length]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] tmpMasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length + addMasks.length]; System.arraycopy(src.getBytes(), <span class="hljs-number"><span class="hljs-number">0</span></span>, tmpBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, length); System.arraycopy(addBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, tmpBytes, length, addBytes.length); System.arraycopy(src.getMasks(), <span class="hljs-number"><span class="hljs-number">0</span></span>, tmpMasks, <span class="hljs-number"><span class="hljs-number">0</span></span>, length); System.arraycopy(addMasks, <span class="hljs-number"><span class="hljs-number">0</span></span>, tmpMasks, length, addMasks.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaskedBytes(tmpBytes, tmpMasks); } }</code> </pre> </div></div><br><ol><li>  The length of the block from which the <code>CRC16</code> is calculated. </li><li>  <code>CRC16</code> , which uses its own polynomial ( <code>0x8408</code> ): </li></ol><br><div class="spoiler">  <b class="spoiler_title">CRC16 counting code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkCrc16</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resCrc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( bytes.length == <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> crc = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bytes.length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = bytes[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; ++x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((crc ^ a) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { crc = (crc &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) ^ <span class="hljs-number"><span class="hljs-number">0x8408</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { crc &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } a &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } crc = ~crc; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = crc; crc = (crc &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); crc &amp;= <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)crc == resCrc; }</code> </pre> </div></div><br><ol><li>  The total length of the "module" in bytes. </li><li>  List of global names (what we need). </li><li>  List of links to other names (also needed). </li><li>  Tail bytes. </li></ol><br><p>  Each name in the module has a specific type and offset from the beginning.  The type can be indicated by one of the symbols::, ^, @, depending on the type: </p><br><ul><li>  " <strong>: NAME</strong> ": global name.  It was for the sake of such names that I started everything; </li><li>  " <strong>: NAME @</strong> ": local name / label.  You can not designate, but let it be; </li><li>  " <strong>^ NAME</strong> ": link to the name. </li></ul><br><p>  On the one hand, everything is simple, but, the link can easily be not a reference to a function (and, accordingly, the jump will be relative), but to a global variable.  What, you say, is the problem?  And it is that in PSX it‚Äôs impossible to push a whole <code>DWORD</code> into a register with one instruction.  For this you need to download it in the form of halves.  The fact is, in <code>MIPS</code> size of the instruction is limited to four bytes.  And, it would seem, you just need to first get one half of one instruction, and then disassemble the next - and get the other half.  But everything is not so simple.  The first half can be downloaded instructions 5 back, and the link in the module will be given only after loading its second half.  I had to write a sophisticated parser (probably it can be modified). </p><br><p>  As a result, we create <code>enum</code> for three types of names: </p><br><div class="spoiler">  <b class="spoiler_title">ModuleType.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> pat; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ModuleType { GLOBAL_NAME, LOCAL_NAME, REF_NAME; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == GLOBAL_NAME; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLocal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == LOCAL_NAME; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == REF_NAME; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isGlobal()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Global"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLocal()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Local"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Reference"</span></span>; } } }</code> </pre> </div></div><br><p>  Let's write code that converts hexadecimal text sequences and points to <code>MaskedBytes</code> type: </p><br><div class="spoiler">  <b class="spoiler_title">hexStringToMaskedBytesArray ()</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> MaskedBytes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hexStringToMaskedBytesArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ MaskedBytes res = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = s.length(); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[len / <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] masks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[len / <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c1 = s.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c2 = s.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>); masks[i / <span class="hljs-number"><span class="hljs-number">2</span></span>] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ( (((c1 == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) ? <span class="hljs-number"><span class="hljs-number">0x0</span></span> : <span class="hljs-number"><span class="hljs-number">0xF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | (((c2 == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) ? <span class="hljs-number"><span class="hljs-number">0x0</span></span> : <span class="hljs-number"><span class="hljs-number">0xF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ); bytes[i / <span class="hljs-number"><span class="hljs-number">2</span></span>] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ( (((c1 == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) ? <span class="hljs-number"><span class="hljs-number">0x0</span></span> : Character.digit(c1, <span class="hljs-number"><span class="hljs-number">16</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | (((c2 == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) ? <span class="hljs-number"><span class="hljs-number">0x0</span></span> : Character.digit(c2, <span class="hljs-number"><span class="hljs-number">16</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ); } res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaskedBytes(bytes, masks); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> </div></div><br><p>  You can already think about the class that will store information about each individual function: the name of the function, the offset in the module, and the type: </p><br><div class="spoiler">  <b class="spoiler_title">ModuleData.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> pat; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ModuleType type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, String name, ModuleType type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset = offset; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type = type; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ModuleType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type; } }</code> </pre> </div></div><br><p>  And finally: a class that will store everything that is specified in each line of the <code>pat</code> file, that is, bytes, crc, a list of names with offsets: </p><br><div class="spoiler">  <b class="spoiler_title">SignatureData.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> pat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignatureData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MaskedBytes templateBytes, tailBytes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MaskedBytes fullBytes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> crc16Length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> crc16; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moduleLength; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;ModuleData&gt; modules; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignatureData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MaskedBytes templateBytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crc16Length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> crc16, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> moduleLength, List&lt;ModuleData&gt; modules, MaskedBytes tailBytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.templateBytes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fullBytes = templateBytes; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.crc16Length = crc16Length; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.crc16 = crc16; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moduleLength = moduleLength; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.modules = modules; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tailBytes = tailBytes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tailBytes != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> addLength = moduleLength - templateBytes.getLength() - tailBytes.getLength(); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] addBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[addLength]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] addMasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[addLength]; Arrays.fill(addBytes, (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0x00</span></span>); Arrays.fill(addMasks, (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0x00</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fullBytes = MaskedBytes.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.templateBytes, addBytes, addMasks); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fullBytes = MaskedBytes.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fullBytes, tailBytes); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MaskedBytes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemplateBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> templateBytes; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MaskedBytes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTailBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tailBytes; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MaskedBytes </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fullBytes; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCrc16Length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crc16Length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">short</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCrc16</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crc16; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getModuleLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleLength; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;ModuleData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getModules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modules; } }</code> </pre> </div></div><br><p>  Now the main thing: write code to create all these classes: </p><br><div class="spoiler">  <b class="spoiler_title">Parsing a single pat line</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;ModuleData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseModuleData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;ModuleData&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;ModuleData&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Matcher m = modulePat.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (m.find()) { String __offset = m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); ModuleType type = __offset.startsWith(<span class="hljs-string"><span class="hljs-string">":"</span></span>) ? ModuleType.GLOBAL_NAME : ModuleType.REF_NAME; type = (type == ModuleType.GLOBAL_NAME &amp;&amp; __offset.endsWith(<span class="hljs-string"><span class="hljs-string">"@"</span></span>)) ? ModuleType.LOCAL_NAME : type; String _offset = __offset.replaceAll(<span class="hljs-string"><span class="hljs-string">"[:^@]"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> offset = Integer.parseInt(_offset, <span class="hljs-number"><span class="hljs-number">16</span></span>); String name = m.group(<span class="hljs-number"><span class="hljs-number">2</span></span>); res.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModuleData(offset, name, type)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Parsing all lines of a pat file</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; lines)</span></span></span><span class="hljs-function"> </span></span>{ modulesCount = <span class="hljs-number"><span class="hljs-number">0L</span></span>; signatures = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;SignatureData&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> linesCount = lines.size(); monitor.initialize(linesCount); monitor.setMessage(<span class="hljs-string"><span class="hljs-string">"Reading signatures..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; linesCount; ++i) { String line = lines.get(i); Matcher m = linePat.matcher(line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.matches()) { MaskedBytes pp = hexStringToMaskedBytesArray(m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ll = Integer.parseInt(m.group(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ssss = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)Integer.parseInt(m.group(<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> llll = Integer.parseInt(m.group(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">16</span></span>); List&lt;ModuleData&gt; modules = parseModuleData(m.group(<span class="hljs-number"><span class="hljs-number">5</span></span>)); MaskedBytes tail = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.group(<span class="hljs-number"><span class="hljs-number">6</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { tail = hexStringToMaskedBytesArray(m.group(<span class="hljs-number"><span class="hljs-number">6</span></span>)); } signatures.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignatureData(pp, ll, ssss, llll, modules, tail)); modulesCount += modules.size(); } monitor.incrementProgress(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> </div></div><br><p>  Function creation code where one of the signatures was recognized: </p><br><div class="spoiler">  <b class="spoiler_title">Create function</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disasmInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program, Address address)</span></span></span><span class="hljs-function"> </span></span>{ DisassembleCommand cmd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DisassembleCommand(address, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); cmd.applyTo(program, TaskMonitor.DUMMY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program, FlatProgramAPI fpa, Address address, String name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFunction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isEntryPoint, MessageLog log)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fpa.getInstructionAt(address) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) disasmInstruction(program, address); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFunction) { fpa.createFunction(address, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEntryPoint) { fpa.addEntryPoint(address); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFunction &amp;&amp; program.getSymbolTable().hasSymbol(address)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } program.getSymbolTable().createLabel(address, name, SourceType.IMPORTED); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidInputException e) { log.appendException(e); } }</code> </pre> </div></div><br><p>  The most difficult place, as mentioned earlier, is the calculation of a link to another name / variable (perhaps the code needs to be improved): </p><br><div class="spoiler">  <b class="spoiler_title">Reference counting</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setInstrRefName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program, FlatProgramAPI fpa, PseudoDisassembler ps, Address address, String name, MessageLog log)</span></span></span><span class="hljs-function"> </span></span>{ ReferenceManager refsMgr = program.getReferenceManager(); Reference[] refs = refsMgr.getReferencesFrom(address); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (refs.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { disasmInstruction(program, address); refs = refsMgr.getReferencesFrom(address); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (refs.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { refs = refsMgr.getReferencesFrom(address.add(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (refs.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { refs = refsMgr.getFlowReferencesFrom(address.add(<span class="hljs-number"><span class="hljs-number">4</span></span>)); Instruction instr = program.getListing().getInstructionAt(address.add(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instr == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { disasmInstruction(program, address.add(<span class="hljs-number"><span class="hljs-number">4</span></span>)); instr = program.getListing().getInstructionAt(address.add(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instr == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } FlowType flowType = instr.getFlowType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (refs.length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !(flowType.isJump() || flowType.isCall() || flowType.isTerminal())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } refs = refsMgr.getReferencesFrom(address.add(<span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (refs.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { program.getSymbolTable().createLabel(refs[<span class="hljs-number"><span class="hljs-number">0</span></span>].getToAddress(), name, SourceType.IMPORTED); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidInputException e) { log.appendException(e); } }</code> </pre> </div></div><br><p>  And, the final touch - apply signatures: </p><br><div class="spoiler">  <b class="spoiler_title">applySignatures ()</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applySignatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteProvider provider, Program program, Address imageBase, Address startAddr, Address endAddr, MessageLog log)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(provider, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); PseudoDisassembler ps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PseudoDisassembler(program); FlatProgramAPI fpa = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlatProgramAPI(program); monitor.initialize(getAllModulesCount()); monitor.setMessage(<span class="hljs-string"><span class="hljs-string">"Applying signatures..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (SignatureData sig : signatures) { MaskedBytes fullBytes = sig.getFullBytes(); MaskedBytes tmpl = sig.getTemplateBytes(); Address addr = program.getMemory().findBytes(startAddr, endAddr, fullBytes.getBytes(), fullBytes.getMasks(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, TaskMonitor.DUMMY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { monitor.incrementProgress(sig.getModules().size()); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } addr = addr.subtract(imageBase.getOffset()); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] nextBytes = reader.readByteArray(addr.getOffset() + tmpl.getLength(), sig.getCrc16Length()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PatParser.checkCrc16(nextBytes, sig.getCrc16())) { monitor.incrementProgress(sig.getModules().size()); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } addr = addr.add(imageBase.getOffset()); List&lt;ModuleData&gt; modules = sig.getModules(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ModuleData data : modules) { Address _addr = addr.add(data.getOffset()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.getType().isGlobal()) { setFunction(program, fpa, _addr, data.getName(), data.getType().isGlobal(), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, log); } monitor.setMessage(String.format(<span class="hljs-string"><span class="hljs-string">"%s function %s at 0x%08X"</span></span>, data.getType(), data.getName(), _addr.getOffset())); monitor.incrementProgress(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ModuleData data : modules) { Address _addr = addr.add(data.getOffset()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.getType().isReference()) { setInstrRefName(program, fpa, ps, _addr, data.getName(), log); } monitor.setMessage(String.format(<span class="hljs-string"><span class="hljs-string">"%s function %s at 0x%08X"</span></span>, data.getType(), data.getName(), _addr.getOffset())); monitor.incrementProgress(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> </div></div><br><p>  Here you can talk about one interesting function: <code>findBytes()</code> .  With its help, you can search for specific sequences of bytes, with the specified bit masks for each byte.  The method is called like this: </p><br><pre> <code class="java hljs">Address addr = program.getMemory().findBytes(startAddr, endAddr, bytes, masks, forward, TaskMonitor.DUMMY);</code> </pre> <br><p>  The result is the address from which the bytes begin, or <code>null</code> . </p><br><h2 id="pishem-analizator">  We write analyzer </h2><br><p>  Let's do it nicely, and we will not use signatures if we don‚Äôt want, but let us choose this step to the user.  To do this, you will need to write your own code analyzer (you could see similar ones in this list - all of them, yes): </p><br><p><img src="https://habrastorage.org/webt/1o/wv/je/1owvjea6nuytmkwksxrhy9anyak.png"></p><br><p>  So, to get into this list, you will need to inherit from the <code>AbstractAnalyzer</code> class and override some methods: </p><br><ol><li>  Constructor.  It will have to call the constructor of the base class with the name, description of the analyzer, and its type (more on that later).  I look something like this: </li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PsxAnalyzer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"PSYQ Signatures"</span></span>, <span class="hljs-string"><span class="hljs-string">"PSX signatures applier"</span></span>, AnalyzerType.INSTRUCTION_ANALYZER); }</code> </pre> <br><ol><li>  <code>getDefaultEnablement()</code> .  Determines whether our analyzer is always available, or only when certain conditions are met (for example, if our loader is used). </li><li>  <code>canAnalyze()</code> .  Is it possible to use this analyzer at all in a downloadable binary file? <br>  Points 2 and 3 can, in principle, be checked with one single function: </li></ol><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPsxLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> program.getExecutableFormat().equalsIgnoreCase(PsxLoader.PSX_LOADER); }</code> </pre> <br><p>  Where <code>PsxLoader.PSX_LOADER</code> stores the name of the loader, and is defined earlier in it. </p><br><p>  Total, we have: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDefaultEnablement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isPsxLoader(program); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canAnalyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isPsxLoader(program); }</code> </pre> <br><ol><li>  <code>registerOptions()</code> .  It is not necessary to redefine this method, but if we need to ask the user, for example, the path to the pat-file, before analyzing, then this is best done in this method.  We get: </li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String OPTION_NAME = <span class="hljs-string"><span class="hljs-string">"PSYQ PAT-File Path"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File file = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Options options, Program program)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { file = Application.getModuleDataFile(<span class="hljs-string"><span class="hljs-string">"psyq4_7.pat"</span></span>).getFile(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { } options.registerOption(OPTION_NAME, OptionType.FILE_TYPE, file, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">"PAT-File (FLAIR) created from PSYQ library files"</span></span>); }</code> </pre> <br><p>  Here it is necessary to clarify.  The static <code>getModuleDataFile()</code> method of the <code>Application</code> class returns the full path to the file in the <code>data</code> directory that is in the tree of our module, and can store any necessary files that we want to refer to later. </p><br><p>  Well, the <code>registerOption()</code> method <code>registerOption()</code> an option with the name specified in <code>OPTION_NAME</code> , the <code>File</code> type (that is, the user will have the opportunity to select a file through a common dialog box), default value and description. </p><br><p>  Further.  Because  then we will not have a normal opportunity to refer to the registered option; you will need to override the <code>optionsChanged()</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optionsChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Options options, Program program)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.optionsChanged(options, program); file = options.getFile(OPTION_NAME, file); }</code> </pre> <br><p>  Here we just update the global variable according to the new value. </p><br><p>  The <code>added()</code> method.  Now the main thing: the method that will be called when the analyzer is started.  In it we will receive a list of addresses available for analysis, but we need only those that contain the code.  Therefore, you need to filter.  Summary Code: </p><br><div class="spoiler">  <b class="spoiler_title">Added method</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">added</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CancelledException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } Memory memory = program.getMemory(); AddressRangeIterator it = memory.getLoadedAndInitializedAddressSet().getAddressRanges(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!monitor.isCancelled() &amp;&amp; it.hasNext()) { AddressRange range = it.next(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { MemoryBlock block = program.getMemory().getBlock(range.getMinAddress()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block.isInitialized() &amp;&amp; block.isExecute() &amp;&amp; block.isLoaded()) { PatParser pat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PatParser(file, monitor); RandomAccessByteProvider provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RandomAccessByteProvider(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(program.getExecutablePath())); pat.applySignatures(provider, program, block.getStart(), block.getStart(), block.getEnd(), log); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { log.appendException(e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> </div></div><br><p>  Here we go through the list of addresses that are executable, and try to apply signatures there. </p><br><p><img src="https://habrastorage.org/webt/-b/ro/8_/-bro8_sgvplezfb3qhiu5dfjyzm.png"></p><br><h2 id="vyvody-i-finalochka">  Conclusions and finals </h2><br><p>  Look like that's it.  In fact, there is nothing super complicated here.  There are examples, the community is alive, you can calmly ask about what is not clear, as long as you write code.  The bottom line: the <code>Playstation 1</code> workload loader and analyzer. </p><br><p><img src="https://habrastorage.org/webt/c_/uw/ej/c_uwejjyu5edynkxyzlr6wboezw.png"></p><br><p>  All source codes are available here: <a href="https://github.com/lab313ru/ghidra_psx_ldr">ghidra_psx_ldr</a> <br>  Releases here: <a href="https://github.com/lab313ru/ghidra_psx_ldr/releases">Releases</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/448098/">https://habr.com/ru/post/448098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448080/index.html">Robo-footballer from beginners. Competitions in MIPT. Android & Arduino & Bluetooth</a></li>
<li><a href="../448082/index.html">[Before Monday] Dry Eye Syndrome</a></li>
<li><a href="../448084/index.html">Photo of a black hole - will it benefit?</a></li>
<li><a href="../448088/index.html">Production of plasma engines in Russia</a></li>
<li><a href="../448096/index.html">Julia in latex</a></li>
<li><a href="../448100/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ360 (April 7 - 14, 2019)</a></li>
<li><a href="../448102/index.html">Dream team from nothing: hiring IT specialists</a></li>
<li><a href="../448106/index.html">Developer Training 1C-Bitrix: sharing our approach to the "cultivation" of personnel</a></li>
<li><a href="../448110/index.html">Information Security of USB over IP Hardware Solutions</a></li>
<li><a href="../448114/index.html">8. Check Point Getting Started R80.20. NAT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>