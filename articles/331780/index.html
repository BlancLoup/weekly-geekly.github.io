<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>It's time to throw! Migration Experience from Objective-C to Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oleg Alekseenko, head of iOS Superjob development, talks about the company's experience in switching from Objective-C to Swift. 

 The article is base...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>It's time to throw! Migration Experience from Objective-C to Swift</h1><div class="post__text post__text-html js-mediator-article">  Oleg Alekseenko, head of iOS Superjob development, talks about the company's experience in switching from Objective-C to Swift. <br><br>  The article is based on the speech at RIT2017. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qjPw7uzCJb8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Superjob has 3 mobile apps for iOS: <br><br><ul><li>  Job search (resume creation, job search, etc.) </li><li>  Employee search (job creation, resume search) </li><li>  Production calendar (planning of working hours and vacations) </li></ul><br><a name="habracut"></a><br><img src="https://habrastorage.org/web/457/801/ab0/457801ab03194eb2b1c512bfc8d9bafd.png"><br><br>  Per day applications are downloaded more than 3 thousand times, the number of active users per day is more than 250 thousand. <br><br>  The first versions of applications developed in 2012.  All applications were originally written in Objective-C.  After 5 years, a new language, Swift, was released, we decided to switch to it.  What did we want to achieve? <br><br><ol><li>  <b>Increase code predictability.</b>  The application has a filter model with 20 parameters, and this model must implement a method (to be comparable).  Many places where changes are possible.  This all brings a lot of pain to the business logic, since when adding new properties everything should be taken into account in all sections of the application.  In Objective-C, you need to follow it with your hands, check all 100,500 places - the probability of an error increases.  Swift makes such a situation impossible in principle. <br><br></li><li>  <b>Migrate to objc libraries in advance.</b>  New libraries and UI components are written in Swift.  Older ones are not supported.  For example: the situation with Reactive Cocoa.  If you do not go today, then in five years we will have a dead piece in the application. <br><br></li><li>  <b>Increase the efficiency of the team and the stability of the project:</b> we have become more attractive to new employees, have adopted internal standards of work quality.  70% of new candidates for the Superjob development team wanted to write specifically on Swift. </li></ol><br><h3>  What specific steps in our case had to be done to go </h3><br>  <b>Increase Nullability</b> <br><br>  At the start - less than 5%.  Inability to start the transition here and now.  At the first attempt to implement Swift, there were many places in the application where Objective-C told us about the existence of an object, and in fact there was no object at run-time.  When we tried to transfer such an object to Swift, the application crashed. <br><img src="https://habrastorage.org/web/f06/3f2/041/f063f2041e2b414888872ed7d372f2ad.png"><br><br>  How to solve: <br><br><ul><li>  3 months for each modified file added Nullability. </li><li>  We wrote a script that prevents Pull Request to pass without tags. </li></ul><br>  What was achieved: in three months Nullability reached 60%.  This is the threshold from which to start the transition. <br><br>  Result: in 3 months we improved the quality of the code, the application stopped writing when writing code on Swift.  Laid the system for further development of applications on Swift. <br><br>  <b>We migrate in advance from objc libraries</b> <br><br>  We use CocoaPods as a dependency manager.  We had libraries connected through it.  They can be divided into two categories: <br><br><ul><li>  Those that are easily replaced by Swift-analog. </li><li>  Those who simply did not change, but demanded the writing of a migration or the selection of an analog (with the subsequent writing of a migration) on this fucking analog. <img src="https://habrastorage.org/web/3fd/59b/72c/3fd59b72cf0342aead5266681616a239.png"></li></ul><br>  In our case, the project was a library of ReactiveCocoa. <br><br><ul><li>  There is no understanding of what you get.  For example, this is how the call to the ReactiveCocoa method in Swift looks like <pre><code class="hljs pgsql">profileFacade.authorize(withLogin: <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: pass).doNext(block: ((<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>?) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)!)</code> </pre>  And the problem is just <pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">Any</span></span>?)</code> </pre>  since there is no idea what might come here. <br><br></li><li>  And therefore it is necessary every time to cast to the desired type and constantly remember why we cast <br><br><pre> <code class="hljs pgsql">profileFacade .authorize(withLogin: <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: pass) .subscribeNext { (response) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = response <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? SJAProfileModel { print("\(String(describing: user.name))") } }</code> </pre> <br></li></ul><br>  We define the decision criteria: <br><br>  ‚Ä¢ To make it easy to use. <br>  ‚Ä¢ To have strict typing. <br>  ‚Ä¢ Swift like API. <br><br>  In the end, chose RxSwift. <br><br><h3>  How we made ReactiveCocoa friends with RxSwfit </h3><br>  As a solution, we wrote a category on <em>RACSignal</em> , which turns untyped ReactiveCocoa signals into typed Observable RxSwfit.  First steps: create an Observable and subscribe to new RACSignal values.  When retrieving new data in RACSignal, we try to convert it to the type we specified in generic using convertBlock (we will consider it a little later).  If it does, then we forward the new typed value further to Observable subscribers.  And if not, then we report an error of casting to the required type. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RACSignal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rxMapBody</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(convertBlock: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">?)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Observable</span></span>.create() { observer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.subscribeNext( { anyValue <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> converted = convertBlock(anyValue) { observer.onNext(converted) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { observer.onError(<span class="hljs-type"><span class="hljs-type">RxCastError</span></span>.cannotConvertTypes) } }, ... ... ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Disposables</span></span>.create() { } } }</code> </pre> <br>  Then we have a public method, which internally calls the Observable creation function and closes the RACSignal values, which are converted to the required type specified in generic. <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RACSignal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rxMap</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type: T.</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = T.</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rxMapBody() { anyValue <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> = rx_cast(anyValue) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } } }</code> </pre> <br>  This solution is well suited for standard types and collections, for example NSArray is easily cast into swift Array, NSNumber is swift, but in ReactiveCocoa there is such a data structure as RACTuple.  There was a problem with it, because it just doesn‚Äôt work on the death of it, so, especially for RACTuple, I had to write a separate method that unpacks each value from the RACTuple and collects the carthage from them. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rxMapTuple</span></span></span><span class="hljs-function">&lt;Q, W&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Q, W)</span></span></span></span></span></span>.<span class="hljs-type"><span class="hljs-type">Type</span></span> = (<span class="hljs-type"><span class="hljs-type">Q</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;(<span class="hljs-type"><span class="hljs-type">Q</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rxMapBody() { anyValue <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> convertible = anyValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">RACTuple</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value: (<span class="hljs-type"><span class="hljs-type">Q</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>) = convertible.rx_convertTuple() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } }</code> </pre> <br>  And, like the kernel itself, the function of casting an untyped value to a typed one is made. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rx_cast</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">T</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">E</span></span> = <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ExpressibleByNilLiteral</span></span>.<span class="hljs-type"><span class="hljs-type">Type</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">E</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nilLiteral: ()) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">T</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  At the input of the function we pass any value that came to us from RACSignal, and the necessary type to which we need to lead.  If it turns out to bring the value to the type immediately, then the value itself is returned; if not, the second step is to check whether the type to which we are trying to cast is optional.  If so, then create a variable of this optional type with an empty value.  The last manipulations are needed, because if you do not create an optional variable, but simply return nil, the compiler will say that it cannot bring nil to the type T we need. <br><br>  Now you can call the rxMap function of RACSignal and transfer the required type that we expect in the subscribe block, and from this moment on onNext we will always get a user model <br><br><pre> <code class="hljs pgsql">profileFacade .authorize(withLogin: <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: pass) .rxMap(SJAProfileModel.self) .subscribe(onNext: { (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> }) .addDisposableTo(disposeBag)</code> </pre> <br>  It is necessary to make it more convenient and write extensions to the facade itself. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SJAProfileFacade</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(login: String, passwrod: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">SJAProfileModel</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.authorize(withLogin: login, password: passwrod).rxMap() } }</code> </pre> <br>  We immediately show in it that we are returning Observable, and inside we simply call rxMap (), and in this case it is not necessary to specify which type should be reduced to.  The type itself is pulled from the return value. <br>  As a result, we get rid of the need to type types each time, and we only do it once. <br><br><pre> <code class="hljs pgsql">profileFacade .authorize(<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: pass) .subscribe(onNext: { (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> }) .addDisposableTo(disposeBag)</code> </pre> <br>  <b>Objective doesn't just let go</b> <br><br>  A large amount of existing application code cannot be replaced immediately.  This leads to a problem: not all Swift features are available in Objective-C. <br><br>  What exactly is not available from what we need to use: <br><br><ul><li>  Struct </li><li>  Enum </li><li>  Moki </li></ul><br>  The solution is Sourcery. <br><br>  This solution is able to auto-generate code. <br><br>  It's easier to understand this with an example: we have a Resume structure that must satisfy the protocols Hashable, Equatable.  But if you implement them yourself, you always have to remember that you can not forget to take into account a new property.  You can trust all this to do Sourcery.  To do this, we point out that our struct Resume satisfies the two protocols, AutoHashable and AutoEquatable. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resume</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoHashable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoEquatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> middleName: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> birthDate: <span class="hljs-type"><span class="hljs-type">Date?</span></span> }</code> </pre> <br>  These protocols themselves are nothing of this kind. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthoHashable</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoEqutable</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  They are simply needed in order for Sourcery to understand which template to use for a particular structure. <br><br>  Now you can run Sourcery.  We get a file in which the implementation of the Hashable and Equatable protocols for Resume is automatically generated.  If we embed sourcery in the build phase, then we don‚Äôt have to worry that, adding new properties to our resume, we will forget to take them into account. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resume</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashValue: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combineHashes([key?.hashValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span>, name?.hashValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span>, firstName?.hashValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span>, lastName?.hashValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span>, middleName?.hashValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span>, birthDate?.hashValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resume</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> == </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: Resume, rhs: Resume)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> compareOptionals(lhs: lhs.key, rhs: rhs.key, compare: ==) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> compareOptionals(lhs: lhs.name, rhs: rhs.name, compare: ==) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> compareOptionals(lhs: lhs.firstName, rhs: rhs.firstName, compare: ==) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ... ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Hashbale and Equtable autogeneration templates are out of the box, but this does not limit us, as we can write a template for our needs.  For example, we have such an enum. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Conf</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Apps</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Backend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">WebScale</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Awesome</span></span> }</code> </pre> <br>  We want to build some kind of logic on the number of enums in enum, for this you can write a template and pass it to Sourcery. <br><br><pre> <code class="hljs swift">{% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enums</span></span></span><span class="hljs-class"> %} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extension</span></span></span><span class="hljs-class"> </span></span>{{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> }} </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfCases:<span class="hljs-type"><span class="hljs-type">Int</span></span> = {{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cases</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">count</span></span></span><span class="hljs-class">}} } </span></span>{% endfor %}</code> </pre> <br>  In this template, we scan all the types found.  If it is enum, then we create an extension for it, in which we declare a static variable with a quantity. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Conf</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfCases:<span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span> }</code> </pre> <br>  Therefore, we took the opportunity to write our templates to port the struct in Objective-c.  We had to use this trick so that in those places that have not yet been rewritten to Swift, we could work with a resume.  As a result, we automatically generate a class ResumeObjc from our structure, which we can use in the old Objective-c code. <br><br><img src="https://habrastorage.org/web/1a8/884/1d8/1a88841d8fb34984b0fa40a122c55342.png"><br><br>  On the example of mocks for tests <br><br>  When writing tests in Objective-c, we often used swizzling for mocks.  But in Swift this is impossible, so I had to create some ‚ÄúFakeProtocolClass‚Äù and there implement all the necessary methods, add specially additional variables that show whether the method was called or not.  Sourcery can help again, which automatically generates such mocks. <br><br><img src="https://habrastorage.org/web/f68/739/ba0/f68739ba03234d1a85dd5ff51ae5ff18.png"><br><br>  <b>Pump team</b> <br><br>  Over the past six months, three out of four candidates for interviews at Superjob talked about wanting to work on Swift. <br><br>  When switching to Swift, it was important to take into account organizational issues in the team, such as code style and work with resources.  The team has been working on Objective-C for many years, and everyone had their own vision about Swift.  Therefore, we needed a tool that would help direct the team in the right direction.  One of the most famous tools for the Swift codestyle is SwiftLint. <br><br>  SwiftLint allows you to enter your own rules.  This helped us to register the errors peculiar to our team, and quickly get rid of them.  For example, we wrote a rule that forbids the use of ReactiveCocoa in Swfit. <br><br><img src="https://habrastorage.org/web/cb1/0f5/6f5/cb10f56f57514c61a76c60560f7f5d09.png"><br><br>  We also wanted to unify the work with graphics, as the project went through several redesigns.  SwiftGen helped with this: when deleting an icon, it tells you where it was used. </div><p>Source: <a href="https://habr.com/ru/post/331780/">https://habr.com/ru/post/331780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331770/index.html">JQuery plugin - jdDialog. The principle of "transit calls"</a></li>
<li><a href="../331772/index.html">Cash registers go online: Russia's tax has opened a new market for application developers</a></li>
<li><a href="../331774/index.html">What is RQL</a></li>
<li><a href="../331776/index.html">SD-WAN "on the fingers": pros, cons, pitfalls</a></li>
<li><a href="../331778/index.html">As we wrote a strategic clicker on the hackathon ReactRiot</a></li>
<li><a href="../331784/index.html">Million WebSocket and Go</a></li>
<li><a href="../331786/index.html">The problem of continuous protection of web applications. View from the side of researchers and operators</a></li>
<li><a href="../331788/index.html">Petya.A, Petya.C, PetrWrap or PetyaCry? New virus threat for companies in Russia and Ukraine</a></li>
<li><a href="../331790/index.html">Early bury java</a></li>
<li><a href="../331792/index.html">IT & City Android hackathon in Nizhny Novgorod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>