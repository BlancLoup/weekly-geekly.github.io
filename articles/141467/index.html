<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The interaction architecture of the client and server parts of the Web application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wanted to tell you how I see the device architecture of the interaction between the server and client parts. And I would like to know to ask habrovc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The interaction architecture of the client and server parts of the Web application</h1><div class="post__text post__text-html js-mediator-article">  I wanted to tell you how I see the device architecture of the interaction between the server and client parts.  And I would like to know to ask habrovchan, what is bad or good such architecture. <br><img src="https://habrastorage.org/storage2/567/485/ddc/567485ddc1b5995b1207358359ca7353.png"><br><a name="habracut"></a><br><br><h4>  Client structure </h4><br>  Even outdated browsers offer us a set of features for creating rich interactive web applications.  And thanks to such libraries as jQuery, which offer not modest cross-browser and multiplatform solutions, the development of client parts is accelerated many times over.  Than webmasters use to the fullest, using a variety of interfaces for interaction between server and client parts. <br><br>  Why jQuery?  In this article, I use it just for example.  For interaction between the client and server parts of applications, it does not matter what you use: any library, your own development or bare javascript.  The main thing is to achieve the goal: for everything to work and work correctly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, many of us began the study of jquery with cycles of articles for beginners, introducing on our sites and dynamically loading content, and checking forms on the server side, and much more. <br><br>  Over time, the size of the code has grown: there are a lot of response handlers from the server part in the project.  Somewhere a whole page is requested and a piece of content is pulled out of it, somewhere there is a request for various files, somewhere JSON is expected, and XML is somewhere.  All this needs to be cleaned up so that the code is smaller, and it works faster, and it is easier to work with it. <br><br>  <b>First of all.</b>  Create a single interface to send requests. <br>  To do this, wrap $ .ajax into its own sugar function. <br><br>  Of course, $ .ajax can be configured via $ .ajaxSetup.  And it is more convenient and practical.  But then there are several problems. <br><ul><li>  Suddenly, you may need to send a request that is an exception to the general rules.  This problem is easily solved by resetting the settings using the ‚Äúglobal‚Äù option to ‚Äúfalse‚Äù. <br>  For example: <br><blockquote><code><font color="black"><font color="#008000">// -   </font> <br> $.ajaxSetup({ <br> url: <font color="#A31515">'mysite.ru/ajax.php'</font> , <br> dataType: <font color="#A31515">'xml'</font> <br> }); <br> <font color="#008000">/* ...    */</font> <br> $.ajax({ <br> url: <font color="#A31515">'ajax.mysite.ru'</font> , <br> data: { <br> action: <font color="#A31515">'do_something'</font> <br> username: <font color="#A31515">'my_username'</font> <br> }, <br> global: <font color="#0000ff">false</font> <font color="#008000">//  </font> <br> });</font> <br></code> </blockquote><br></li><li>  The second problem may arise when using ajaxSetup, when the functional refinement will be given to a third-party developer.  Looking at the code, it will see the $ .ajax functions that are familiar to it and will not understand that somewhere something global is being redefined.  And if they notice, there is no guarantee that he will not try to change something in him, and as a result, he will not break some old piece of code. </li></ul><br>  I prefer to wrap everything in a different function.  It‚Äôs not so practical, and it generates more code, but it‚Äôs safer to use.  Another programmer, seeing an unfamiliar function, will immediately pay attention to it.  And, probably, having looked, as other request goes, will make also.  And if they do not understand, then nothing will prevent the use of the standard $ .ajax function. <br><br><blockquote> <code><font color="black"><font color="#008000">// </font> <br> $.extend({ <br> gajax: <font color="#0000ff">function</font> (s) { <br> <font color="#008000">//   </font> <br> <font color="#0000ff">var</font> options = { <br> url: <font color="#A31515">"ajax.mysite.ru"</font> , <br> }; <br> <font color="#008000">//  </font> <br> $.extend( options, s, { action:s.action } ); <br> $.ajax( options ); <br> } <br> }); <br> <font color="#008000">// </font> <br> $.gajax({ <br> data: { <br> username: <font color="#A31515">'my_username'</font> <br> }, <br> action: <font color="#A31515">'do_something'</font> <br> }); <br></font></code> </blockquote><br>  <b>Secondly</b> , it is necessary to reduce the number of entry points for AJAX requests.  If the requests were sent both to index.php, and to request.pl, and to upload.xml, then this is a huge amount of work, and it often happens that it is impossible to do this without rewriting the entire server part again.  Although this should be done if you want to quickly and simply expand the client part.  Like all rules, it has exceptions.  About them below. <br><br>  <b>Third, the most important thing</b> : it is necessary to unify the response handler. <br><br>  For example, in our project all ajax requests go only to the ajax.php file.  It always returns some data in the form of XML, quite simply structured. <br><br>  A single response handler parses XML and decomposes: <br><br>  ‚Ä¢ A list of js-files that are required to process the response. <br>  ‚Ä¢ Callback functions that must be run, and which arguments to these functions must be passed. <br>  ‚Ä¢ Pieces of HTML code to be applied in the above functions. <br>  ‚Ä¢ A list of css files that are needed to decorate html code. <br><br><blockquote> <code><font color="black"><font color="#008000">// </font> <br> $.extend({ <br> gajax: <font color="#0000ff">function</font> (s) { <br> <font color="#0000ff">var</font> recognize = <font color="#0000ff">function</font> ( xml, s ) { <br> <font color="#008000">/*     ,        */</font> <br> <font color="#008000">//  xml ( jQuery   XML,      )</font> <br> <font color="#008000">//      js-,       </font> <br> <font color="#008000">//    ,   </font> <br> <font color="#008000">//      callback`</font> <br> <font color="#008000">//  html</font> <br> }; <br> <font color="#008000">//   </font> <br> <font color="#0000ff">var</font> options = { <br> url: <font color="#A31515">"ajax.mysite.ru"</font> , <br> success: <font color="#0000ff">function</font> (xml){ <br> recognize( xml, s ); <br> } <br> }; <br> $.extend( options, s, { action:s.action } ); <br> $.ajax( options ); <br> } <br> });</font> <br> <br></code> </blockquote><br>  When everything is laid out, load the missing js-files.  Perhaps one or more of the requested scripts have already been loaded previously loaded, so check it first.  Validation methods depend on the general architecture of javascript code. <br><br>  Then we load the styles.  The mechanisms for loading scripts and styles are almost identical.  Of course, styles are only needed when the data is displayed to the user, but by this point they should already be loaded. <br><br>  When all scripts are loaded, we start callback functions. <br><br>  It should be noted that to speed up the download, all js files are loaded asynchronously, and accordingly there may be a problem with the launch of callback functions.  After all, they can be in these files. <br>  The solution to this problem can be to create dependencies of functions on js files.  This, in turn, causes problems for the programmer to control these dependencies and transfer them along with the response to the client side. <br>  The second solution is to wait for the download of absolutely all the requested files and only then start executing the functions. <br>  How to make it beautiful, you can listen to this wonderful podcast <a href="http://habrahabr.ru/blogs/hpodcasts/138522/">habrahabr.ru/blogs/hpodcasts/138522</a> <br><br>  I chose the simplest solution for my projects - the second one.  I proceeded from the fact that loading the necessary js files is extremely rarely needed, because all the scripts on the server side are combined into packages.  And usually the package contains all the necessary callbacks in advance.  And if the file upload will be needed, it will require a maximum of one or two files, which will not delay the processing of the response. <br><br>  Let me remind you that by this moment the user still does not see any changes on the screen.  Well, we will show them them - we will begin to carry out functions.  The main thing to consider is that all response handler functions must be independent of each other.  They may depend on one large component (for example, the functions of the project core), but they do not have to be from each other.  This will allow you to move and integrate callback and other parts of the project without any special problems.  For example, displaying pop-up error messages may be required on all pages. <br><br>  Functions completed, the user works on. <br><br><h4>  Processing requests by the server </h4><br>  Now I would like to make out a situation when a request was sent that the server could not make out for some reason. <br><br>  With us, all requests are not only sent to one file, but all data in it is sent using the POST method.  On the server side, some ‚Äúaction‚Äù POST parameter is expected.  The value of this parameter determines which module of the site should work.  The pairs themselves with the expected values ‚Äã‚Äãand names of the modules are written in the configuration file.  If there is a corresponding module in the configuration - it is launched, if not - the default module is started, which is configured to return an error message. <br>  Also, we can write all the request parameters to the server log.  Analysis of the log then allows you to quickly track and correct the error.  Or, during the execution of the script, ban the user's IP for about 15 minutes for searching the values, if there is confidence that there are no errors in our application.  But this is extreme. <br><br><h4>  Processing erroneous requests on the client side </h4><br>  We must not forget about the processing of failed requests, for example, by timeout or the sudden disconnection of the user from the network. <br><br><blockquote> <code><font color="black"><font color="#008000">//   </font> <br> <font color="#0000ff">var</font> options = { <br> url: <font color="#A31515">"ajax.mysite.ru"</font> , <br> success: <font color="#0000ff">function</font> (xml){ <br> recognize( xml, s ); <br> }, <br> error: <font color="#0000ff">function</font> ( s,err ){ <br> <font color="#008000">//  </font> <br> <font color="#0000ff">if</font> ( s.status == 200 &amp;&amp; err == <font color="#A31515">'parsererror'</font> ) { <br> alert( s.responseText ); <br> } <br> <font color="#008000">//     </font> <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( err == <font color="#A31515">'timeout'</font> ) { <br> alert( <font color="#A31515">'Connection to the server was reset on timeout.'</font> ); <br> } <br> <font color="#008000">//  -    .</font> <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( s.status == 12029 || s.status == 0 ) { <br> alert( <font color="#A31515">'No connection with network.'</font> ); <br> } <br> };</font> <br></code> </blockquote><br><h4>  Caching </h4><br>  Let's return to the question about entry points.  From the point of view of writing beautiful code, specifying only one address for an entry point is not an entirely correct solution.  This is by no means contrary to my second advice.  I will try to make out all sides of this issue. <br><br>  How could one make everything beautiful?  - Send requests to specific addresses.  For example, ajax.php? Action = feedback or ajax.example.com/feedback.  This would save the request from unnecessary garbage.  When a module is defined that will process the data, it no longer needs this information.  Flies separately, cutlets separately.  Handsomely?  Handsomely. <br><br>  If there are no POST parameters in the request at all, then this is a good opportunity to use caching features on intermediate proxies or browser caches. <br>  A recommendation from Google for webmasters says that the lack of GET parameters in the http request provokes the proxy server to use the cache.  Therefore, a request without POST and GET parameters, for example ajax.mysite.com/footer, would be ideal for adding it to the proxy cache server.  Of the additional advantages, I note that if the answer comes from a proxy server, then our server will also be a little unloaded. <br>  When it may even need?  When we load parts of the page via ajax.  However, they are unchanged for a long time. <br><br>  But it is not necessary to use an ajax request without a GET or POST parameter, since there is a possibility of receiving non-actual data. <br>  Suppose we have a chat and we do not use web sockets.  Every second we go to the server to see new messages.  The user is caught for some proxy server.  The first request will succeed and return that there are no messages.  For all subsequent requests, the proxy server will return the initial response.  And it will disrupt the entire work of the chat.  Problems can be avoided by adding a parameter to the query.  That, in turn, will create the very garbage that we have tried so hard to avoid. <br><br>  In matters of caching, each time you need to approach individually and use what is necessary for the project. <br><br><h4>  Inventing a bicycle </h4><br>  In our project, the data in the request is sent only by the POST method, because the caching mechanism we have laid in that very unified interface for sending ajax requests.  By default, absolutely every request and response to it is remembered for 3600 seconds.  In a subsequent similar request, the cache will work, take the answer from the box and launch all the mechanisms for analyzing it at once, without sending a direct request to the server.  After all, we are sure that all styles and scripts are already in place. <br>  If you don‚Äôt need to remember the request-response pair, or simply reduce the cache lifetime, the server side reports this in the initial response, changing the cache time to 0 or a different number of seconds. <br><br>  Why only POST, but not the combined option?  It's easier to compare queries. <br>  The data sent via the ajax function in jQuery is a js object. <br>  The requested data is rather quickly compared with the objects in the cache, of course, if the client has a modern browser.  If the browser is old, you have to forcibly disable the cache. <br><br><h4>  Eventually </h4><br>  As a result, we get a stable working bunch of client and server parts.  And this bundle allows us to create safe and easy to further expand Web applications. <br><br>  The post is written in the name of saving nanoseconds and a variety of nerve cells of programmers who create their beautiful creations. </div><p>Source: <a href="https://habr.com/ru/post/141467/">https://habr.com/ru/post/141467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141460/index.html">Disaster recovery plan - confidence in the future for the entire company and a restful sleep in the IT department</a></li>
<li><a href="../141462/index.html">My friend computer</a></li>
<li><a href="../141463/index.html">Javascript asynchronous functions and this keyword</a></li>
<li><a href="../141464/index.html">From Syktyvkar to Yuzhno-Sakhalinsk - new panoramas on Yandex.Maps</a></li>
<li><a href="../141466/index.html">CS Center. Impressions</a></li>
<li><a href="../141468/index.html">HOSTKEY.ru action! - free months on windows vps</a></li>
<li><a href="../141469/index.html">Difficult SVG on the client and server</a></li>
<li><a href="../141470/index.html">Well, a very inexpensive telepresence robot based on a laptop and motorcycle carts. Continuation</a></li>
<li><a href="../141471/index.html">Google is building another data center in Oklahoma, USA</a></li>
<li><a href="../141472/index.html">How to plan performance tracking of e-commerce sites using Google Analytics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>