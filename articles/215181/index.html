<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How signals and slots work in Qt (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: this is the second part of the translation of the Olivier Goffart article on the internal architecture of signals and slots in Qt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How signals and slots work in Qt (part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/714/130/d7e/714130d7e1aef8bb3b86f2fcafd02c35.png"><br><br>  <i>From the translator: this is the second part of the translation of the <i>Olivier Goffart article</i> on the internal architecture of signals and slots in Qt 5, the translation of the first part <a href="http://habrahabr.ru/post/214379/">here</a> .</i> <br><a name="habracut"></a><br><h5>  New syntax in Qt5 </h5><br>  The new syntax is as follows: <br><br><pre><code class="cpp hljs">QObject::connect(&amp;a, &amp;Counter::valueChanged, &amp;b, &amp;Counter::setValue);</code> </pre> <br>  I have already described the advantages of the new syntax in <a href="http://woboq.com/blog/new-signals-slots-syntax-in-qt5.html">this</a> post.  In short, the new syntax allows you to check signals and slots at compile time.  It is also possible to automatically convert arguments if they are not of exactly the same type.  And, as a bonus, this syntax allows the use of lambda expressions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  New overloaded methods </h5><br>  Only a few necessary changes were made for this to work.  The basic idea is the new QObject :: connect overloads, which take pointers to functions as arguments, instead of char *.  These three new methods (pseudocode) are: <br><br><pre> <code class="cpp hljs">QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObject *sender, PointerToMemberFunction signal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObject *receiver, PointerToMemberFunction slot, Qt::ConnectionType type); QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObject *sender, PointerToMemberFunction signal, PointerToFunction method) QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObject *sender, PointerToMemberFunction signal, Functor method)</code> </pre><br>  The first method is the one closest to the old syntax: you connect the sender's signal to the receiver's slot.  The other two overload this connection by connecting a static function and a functor without a receiver to the signal.  All methods are very similar and in this post we will analyze only the first one. <br><br><h5>  Member function pointer </h5><br>  Before continuing my explanation, I would like to talk a little about member function pointers.  Here is a very simple code that declares a pointer to a function and calls it: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  myFunctionPtr   - //   void     int void (QPoint::*myFunctionPtr)(int); myFunctionPtr = &amp;QPoint::setX; QPoint p; QPoint *pp = &amp;p; (p.*myFunctionPtr)(5); //  p.setX(5); (pp-&gt;*myFunctionPtr)(5); //  pp-&gt;setX(5);</span></span></code> </pre><br>  Pointers to members and pointers to member functions are a common part of a C ++ subset, which is not very often used and therefore less well known.  The good news is that you do not need to know about it in order to use Qt and this new syntax.  All you need to remember is that you need to position &amp; in front of the signal name in your connection.  You do not need to cope with the magic operators :: *,. * Or -&gt; *.  These magic operators allow you to declare a pointer to a member function and access it.  The type of such pointers includes the return type, the class to which the function belongs, the types of all arguments, and the const specifier for the function. <br><br>  You cannot convert pointers to member functions to anything else, in particular, to void, because they have a different sizeof.  If the function is slightly different in the signature, you will not be able to convert from one to another.  For example, even the conversion <i>void (MyClass :: *) (int) const</i> to <i>void (MyClass :: *) (int) is</i> not allowed (you can do this with reinterpret_cast, but, in accordance with the standard, there will be undefined behavior (undefined behavior) ), if you try to call a function). <br><br>  Pointers to member functions are not just ordinary function pointers.  A normal function pointer is simply a pointer with an address where the function code is located.  But the pointer to a member function needs to store more information: the member function can be virtual and also with offset if it is hidden, in the case of multiple inheritance.  The sizeof of a pointer to a member function may even <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/02/09/70002.aspx">vary</a> , depending on the class.  That is why we need to have a special case to manipulate them. <br><br><h5>  Property type classes (type traits): QtPrivate :: FunctionPointer </h5><br>  Let me introduce you to a class of properties of type QtPrivate :: FunctionPointer.  A property class is basically an auxiliary class that returns some metadata about a given type.  Another example of a property class in Qt is <a href="http://code.woboq.org/qt5/qtbase/src/corelib/global/qtypeinfo.h.html">QTypeInfo</a> .  What we need to know as part of the implementation of the new syntax is information about a pointer to a function.  <i>The template &lt;typename T&gt; struct FunctionPointer</i> will give us information about T through its members: <br><ul><li>  ArgumentCount - a number representing the number of function arguments </li><li>  Object - exists, only for pointers to member functions, it is a typedef of a class, to a member function of which a pointer points </li><li>  Arguments - presents a list of arguments, typedef of a metaprogramming list </li><li>  call (T &amp; function, QObject * receiver, void ** args) is a static function that calls a function with the parameters passed </li></ul><br>  Qt still supports the C ++ 98 compiler, which means that we unfortunately cannot require support for templates with a variable number of arguments (the variadic template).  In other words, we need to specialize our function for a class of properties for each number of arguments.  We have four types of specialization: a regular function pointer, a pointer to a member function, a pointer to a constant member function, and functors.  For each type, we need specialization for each number of arguments.  We have support for up to six arguments.  We also have a specialization that uses templates with a variable number of arguments, for an arbitrary number of arguments, if the compiler supports templates with a variable number of arguments.  The FunctionPointer implementation is located at <a href="http://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobjectdefs_impl.h.html">qobjectdefs_impl.h</a> . <br><br><h5>  QObject :: connect </h5><br>  The implementation depends on a large number of template code.  I will not explain all this.  Here is the code for the first new overload from <a href="http://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobject.h.html">qobject.h</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func2&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> QMetaObject::<span class="hljs-function"><span class="hljs-function">Connection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QtPrivate::FunctionPointer&lt;Func2&gt;::Object *receiver, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> QtPrivate::FunctionPointer&lt;Func1&gt; SignalType; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> QtPrivate::FunctionPointer&lt;Func2&gt; SlotType; <span class="hljs-comment"><span class="hljs-comment">//   ,     Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) &gt;= int(SlotType::ArgumentCount), ""The slot requires more arguments than the signal provides.""); Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value), ""Signal and slot arguments are not compatible.""); Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;typename SlotType::ReturnType, typename SignalType::ReturnType&gt;::value), ""Return type of the slot is not compatible with the return type of the signal.""); const int *types; /* ...   ,   QueuedConnection ...*/ QtPrivate::QSlotObjectBase *slotObj = new QtPrivate::QSlotObject&lt;Func2, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotType::ArgumentCount&gt;::Value, typename SignalType::ReturnType&gt;(slot); return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), receiver, reinterpret_cast&lt;void **&gt;(&amp;slot), slotObj, type, types, &amp;SignalType::Object::staticMetaObject); }</span></span></code> </pre><br><br>  You noticed in the function signature that sender and receiver are not just QObject * as the documentation indicates.  In fact, these are pointers to the FunctionPointer :: Object typename.  To create an overload that is enabled only for pointers to member functions, <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE is</a> used, because an Object exists in a FunctionPointer only if the type is a pointer to a member function. <br><br>  Then we start with a bunch of Q_STATIC_ASSERT.  They should generate meaningful errors when compiling when the user made a mistake.  If the user has done something wrong, it will be important for him to see the error here, and not in the noodle of the template code in the _impl.h files.  We want to hide the internal implementation so that the user does not worry about it.  This means that if you ever see an incomprehensible error in the implementation details, it should be considered as an error that needs to be reported. <br><br>  Next, we create an instance of QSlotObject, which will then be passed to connectImpl ().  QSlotObject is a wrapper over the slot that will help trigger it.  It also knows the type of signal arguments and can do the appropriate type conversion.  We use List_Left only by passing the same number of arguments as in the slot, which allows you to connect a signal to a slot that has fewer arguments than the signal. <br><br>  QObject :: connectImpl is a private internal function that will perform the connection.  It has a syntax similar to the original one, with the difference that instead of storing the method index in the QObjectPrivate :: Connection structure, we store a pointer to QSlotObjectBase. <br><br>  The reason why we pass &amp; slot as void ** is to be able to compare it if the type is Qt :: UniqueConnection.  We also pass &amp; signal as void **.  This is a pointer to a pointer to a member function. <br><br><h5>  Signal index </h5><br>  We need to make a link between the signal pointer and the signal index.  We use <b>MOC</b> for this.  Yes, this means that this new syntax still uses <b>MOC</b> and that there are no plans to get rid of it :-).  <b>MOC</b> will generate qt_static_metacall code that compares the parameter and returns the correct index.  connectImpl will call the qt_static_metacall function with a pointer to a function pointer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Counter::qt_static_metacall(QObject *_o, QMetaObject::Call _c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **_a) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_c == QMetaObject::InvokeMetaMethod) { <span class="hljs-comment"><span class="hljs-comment">/* ....  ....*/</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_c == QMetaObject::IndexOfMethod) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *result = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *&gt;(_a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **func = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **&gt;(_a[<span class="hljs-number"><span class="hljs-number">1</span></span>]); { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Counter::*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span> *&gt;(func) == <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span>&gt;(&amp;Counter::valueChanged)) { *result = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Counter::*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp; )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span> *&gt;(func) == <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span>&gt;(&amp;Counter::someOtherSignal)) { *result = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Counter::*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span> *&gt;(func) == <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span>&gt;(&amp;Counter::anotherSignal)) { *result = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } } }</code> </pre><br>  Now, having a signal index, we can work with syntax similar to the previous one. <br><br><h5>  QSlotObjectBase </h5><br>  QSlotObjectBase is an object passed to connectImpl, which reflects the slot.  Before showing the current code, here is QObject :: QSlotObjectBase, which was in Qt5 alpha: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QSlotObjectBase</span></span></span><span class="hljs-class"> {</span></span> QAtomicInt ref; QSlotObjectBase() : ref(<span class="hljs-number"><span class="hljs-number">1</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~QSlotObjectBase(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QObject *receiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } };</code> </pre><br>  This is basically an interface that is designed to be reimplemented through template classes that implement the call and comparison of function pointers.  This is implemented by one of the QSlotObject, QStaticSlotObject, or QFunctorSlotObject template classes. <br><br><h5>  Fake virtual table </h5><br>  The problem is that every time you instantiate such an object, you need to create a virtual table that will contain not only a pointer to virtual functions but also a lot of information that we don‚Äôt need, such as <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a> .  This would lead to a lot of unnecessary data and the proliferation of binary files.  To avoid this, QSlotObjectBase was changed to not be a polymorphic class.  Virtual functions are emulated manually. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QSlotObjectBase</span></span></span><span class="hljs-class"> {</span></span> QAtomicInt m_ref; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*ImplFn)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> which, QSlotObjectBase* this_, QObject *receiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ret)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ImplFn m_impl; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Operation { Destroy, Call, Compare }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QSlotObjectBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ImplFn fn)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_ref.ref(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroyIfLastRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_ref.deref()) m_impl(Destroy, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret; m_impl(Compare, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, a, &amp;ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QObject *r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a)</span></span></span><span class="hljs-function"> </span></span>{ m_impl(Call, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, r, a, <span class="hljs-number"><span class="hljs-number">0</span></span>); } };</code> </pre><br>  m_impl is a normal pointer to a function that performs three operations that were previously previous virtual functions.  Repeated implementations are set to work in the constructor. <br><br>  Please do not need to go back to your code and change all the virtual functions to this way, because they read that it is good.  This is done only in this case, because almost every call to connect will generate a new different type (starting with a QSlotObject that has template parameters that depend on the signal signature and slot). <br><br><h5>  Protected, open and closed signals </h5><br>  Signals were protected in Qt4 and earlier.  It was a design choice that signals should be transmitted by an object when its state changes.  They should not be called from outside the object and calling a signal from another object is almost always a bad idea. <br><br>  However, with the new syntax, you should be able to get the signal address at the point at which you made the connection.  The compiler will only allow you to do this if you have access to the signal.  Writing &amp; Counter :: valueChanged will generate a compilation error if the signal was not open. <br><br>  In Qt5, we had to change signals from protected to open.  Unfortunately, this means that everyone can emit signals.  We have not found a way to fix this.  We tried the trick with the <i>emit keyword</i> .  We tried to return a special value.  But nothing worked.  I believe that the advantages of the new syntax will overcome the problems when the signals are now open. <br><br>  Sometimes it is even advisable to have the signal closed.  This is the case, for example, in QAbstractItemModel, where otherwise, developers usually emit a signal in a derived class that is not what the API wants.  They used a preprocessor trick that made the signals closed but broke the new connection syntax. <br><br>  A new hack was introduced.  QPrivateSignal is an empty structure declared closed in the Q_OBJECT macro.  It can be used as the last signal parameter.  Since it is closed, only the object has the right to create it to call the signal.  <b>The MOC will</b> ignore the last QPrivateSignal argument when generating signature information.  See <a href="http://code.woboq.org/qt5/qtbase/src/corelib/itemmodels/qabstractitemmodel.h.html">qabstractitemmodel.h</a> for an example. <br><br><h5>  More template code </h5><br>  The rest of the code is in <a href="http://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobjectdefs_impl.h.html">qobjectdefs_impl.h</a> and <a href="http://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobject_impl.h.html">qobject_impl.h</a> .  This is basically a boring template code.  I will no longer go deep into the details in this post, but I will go over several points that are worth mentioning. <br><br><h5>  Metaprogramming list </h5><br>  As mentioned earlier, FunctionPointer :: Arguments is a list of arguments.  The code should work with this list: iterate elementwise, get only a part of it, or select this element.  That is why QtPrivate :: List can appear as a list of types.  Some auxiliary classes for it are QtPrivate :: List_Select and QtPrivate :: List_Left, which return the Nth item in the list and the part of the list containing the first N items. <br><br>  The List implementation is different for compilers that support templates with a variable number of parameters and that do not support them.  With templates with a variable number of parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  The argument list simply hides the template parameters.  For example, the type of the list containing the arguments (int, Qstring, QObject *) would be: <br><br><pre> <code class="cpp hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, QString, QObject *&gt;</code> </pre><br>  Without templates with a variable number of parameters, it will look like a LISP style: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tail &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  Where Tail can be any other List or void, for the end of the list.  The previous example in this case looks like this: <br><br><pre> <code class="cpp hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;QString, List&lt;QObject *, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;&gt;&gt;</code> </pre><br><h5>  Trick ApplyReturnValue </h5><br>  In the function FunctionPointer :: call, args [0] is designed to get the return value of the slot.  If the signal returns a value, it will be a pointer to an object with the type of the return value of the signal, otherwise 0. If the slot returns a value, we must copy it into arg [0].  If it is void, we do nothing. <br><br>  The problem is that it is syntactically incorrect to use the return value of a function that returns void.  Should I duplicate a huge amount of code: once for the return value of void and the other for a value other than void?  No, thanks to the comma operator. <br><br>  In C ++, you can do this: <br><br><pre> <code class="cpp hljs">functionThatReturnsVoid(), somethingElse();</code> </pre><br>  You can replace the comma with a semicolon and all this would be good.  It becomes interesting when you call it with something other than void: <br><br><pre> <code class="cpp hljs">functionThatReturnsInt(), somethingElse();</code> </pre><br>  Here, the comma will be the callee operator that you can even overload.  This is what we do in <a href="http://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobjectdefs_impl.h.html">qobjectdefs_impl.h</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplyReturnValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; ApplyReturnValue(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data_) : data(data_) {} }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T &amp;value, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ApplyReturnValue&lt;U&gt; &amp;container) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container.data) *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;U*&gt;(container.data) = value; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>,(T, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ApplyReturnValue&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; &amp;) {}</code> </pre><br>  ApplyReturnValue is just a wrapper over void *.  Now, this can be used in the desired helper entity.  Here is an example of a case for a functor with no arguments: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function &amp;f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **arg)</span></span></span><span class="hljs-function"> </span></span>{ f(), ApplyReturnValue&lt;SignalReturnType&gt;(arg[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br>  This code is inline, so there will be no cost in terms of performance during execution. </div><p>Source: <a href="https://habr.com/ru/post/215181/">https://habr.com/ru/post/215181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215167/index.html">The Linux Foundation and EdX begin a free course on Introduction to Linux.</a></li>
<li><a href="../215171/index.html">Simple filter tapes VK for "bad" words and what he can become</a></li>
<li><a href="../215173/index.html">Statistics using javascript libraries and CDN</a></li>
<li><a href="../215175/index.html">Firefox Download Panel Improvements</a></li>
<li><a href="../215177/index.html">Radio-controlled switch do it yourself. Part 3 - Switch Software</a></li>
<li><a href="../215183/index.html">The digest of interesting news and materials from the world of PHP No. 37 (February 24 - March 9, 2014)</a></li>
<li><a href="../215185/index.html">Sample Application - Phonebook on AngularJS + Bootstrap v3</a></li>
<li><a href="../215189/index.html">Python Meetup: January Meeting</a></li>
<li><a href="../215197/index.html">Interesting and informative: the flight to the ISS on the PTK NP</a></li>
<li><a href="../215203/index.html">Is IntelliJ based .NET support a reality?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>