<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a cartoon water shader for the web. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the second part, we looked at buoyancy and foam lines. In this last part, we will apply underwater distortion as a post-processing effect. 

 Refra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a cartoon water shader for the web. Part 3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/a8e/0b0/bbda8e0b0fe175450f789f2a7ec94304.gif" alt="image"></div><br>  In the <a href="https://habr.com/post/416983/" rel="external">second part,</a> we looked at buoyancy and foam lines.  In this last part, we will apply underwater distortion as a post-processing effect. <br><br><h2>  Refraction and post-processing effects </h2><br>  Our goal is to visualize the refraction of light in water.  We have already <a href="https://gamedevelopment.tutsplus.com/tutorials/using-displacement-shaders-to-create-an-underwater-effect--cms-27191" rel="external">described</a> how to create this type of distortion in a fragment shader for a 2D scene.  Here the only difference is that we need to understand which area of ‚Äã‚Äãthe screen is under water and apply distortion only to it. <br><br><h3>  Post processing </h3><br>  In general, the post-processing effect is any effect applied to the entire scene after it is rendered, for example, shades of color or the <a href="https://www.shadertoy.com/view/Ms23DR" rel="external">effect of an old CRT screen</a> .  Instead of rendering the scene directly to the screen, we first render it into a buffer or texture, and then, having skipped the scene through our shader, we render it to the screen. <br><a name="habracut"></a><br>  In PlayCanvas, you can customize this post-processing effect by creating a new script.  Let's call it <strong>Refraction.js</strong> and copy into it as a template this template: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------   ------------------------// pc.extend(pc, function () { //  -      var RefractionPostEffect = function (graphicsDevice, vs, fs, buffer) { var fragmentShader = "precision " + graphicsDevice.precision + " float;\n"; fragmentShader = fragmentShader + fs; //      this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); this.buffer = buffer; }; //      pc.PostEffect RefractionPostEffect = pc.inherits(RefractionPostEffect, pc.PostEffect); RefractionPostEffect.prototype = pc.extend(RefractionPostEffect.prototype, { //      render, //    ,    , //       render: function (inputTarget, outputTarget, rect) { var device = this.device; var scope = device.scope; //       .  ,     scope.resolve("uColorBuffer").setValue(inputTarget.colorBuffer); //       .       . //          pc.drawFullscreenQuad(device, outputTarget, this.vertexBuffer, this.shader, rect); } }); return { RefractionPostEffect: RefractionPostEffect }; }()); //---------------  ------------------------// var Refraction = pc.createScript('refraction'); Refraction.attributes.add('vs', { type: 'asset', assetType: 'shader', title: 'Vertex Shader' }); Refraction.attributes.add('fs', { type: 'asset', assetType: 'shader', title: 'Fragment Shader' }); //  initialize       Refraction.prototype.initialize = function() { var effect = new pc.RefractionPostEffect(this.app.graphicsDevice, this.vs.resource, this.fs.resource); //     postEffects var queue = this.entity.camera.postEffects; queue.addEffect(effect); this.effect = effect; //       this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; }; Refraction.prototype.update = function(){ if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ this.swap(this); } }; Refraction.prototype.swap = function(old){ this.entity.camera.postEffects.removeEffect(old.effect); this.initialize(); };</span></span></code> </pre> <br>  This is similar to a regular script, but we define the <code>RefractionPostEffect</code> class, which can be applied to the camera.  For rendering, it needs vertex and fragment shaders.  Attributes are already configured, so let's create a <strong>Refraction.frag</strong> with the following contents: <br><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D uColorBuffer; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec4 color = texture2D(uColorBuffer, vUv0); gl_FragColor = color; }</code> </pre> <br>  And <strong>Refraction.vert</strong> with the base vertex shader: <br><br><pre> <code class="javascript hljs">attribute vec2 aPosition; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = vec4(aPosition, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); vUv0 = (aPosition.xy + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; }</code> </pre> <br>  Now attach the <strong>Refraction.js</strong> script to the camera and assign the corresponding attributes to the shaders.  When you start the game, you will see the scene in the same way as before.  This is an empty post effect that just re-renders the scene.  To make sure it works, let's try to give the scene a red hue. <br><br>  Instead of simply returning the color to Refraction.frag, try setting the red component to 1.0, which should give the image as shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/981/b78/937/981b78937b536280aeacdb3ef8c33897.png"></div><br><h3>  Distortion shader </h3><br>  To create an animated distortion, we need to add a uniform time variable, so let's create it inside this post effect constructor in Refraction.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RefractionPostEffect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">graphicsDevice, vs, fs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">"precision "</span></span> + graphicsDevice.precision + <span class="hljs-string"><span class="hljs-string">" float;\n"</span></span>; fragmentShader = fragmentShader + fs; <span class="hljs-comment"><span class="hljs-comment">//       this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); // &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    this.time = 0; };</span></span></code> </pre> <br>  Now inside the render function, we pass it to our shader to increase it: <br><br><pre> <code class="javascript hljs">RefractionPostEffect.prototype = pc.extend(RefractionPostEffect.prototype, { <span class="hljs-comment"><span class="hljs-comment">//      render, //      , //       render: function (inputTarget, outputTarget, rect) { var device = this.device; var scope = device.scope; //       .  ,     scope.resolve("uColorBuffer").setValue(inputTarget.colorBuffer); /// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniform-  scope.resolve("uTime").setValue(this.time); this.time += 0.1; //       .       . //          pc.drawFullscreenQuad(device, outputTarget, this.vertexBuffer, this.shader, rect); } });</span></span></code> </pre> <br>  Now we can use the same shader code from the tutorial on distortion in water, turning our full fragment shader into the following: <br><br><pre> <code class="javascript hljs">precision highp float; uniform sampler2D uColorBuffer; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec2 pos = vUv0; float X = pos.x*<span class="hljs-number"><span class="hljs-number">15.</span></span>+uTime*<span class="hljs-number"><span class="hljs-number">0.5</span></span>; float Y = pos.y*<span class="hljs-number"><span class="hljs-number">15.</span></span>+uTime*<span class="hljs-number"><span class="hljs-number">0.5</span></span>; pos.y += cos(X+Y)*<span class="hljs-number"><span class="hljs-number">0.01</span></span>*cos(Y); pos.x += sin(XY)*<span class="hljs-number"><span class="hljs-number">0.01</span></span>*sin(Y); vec4 color = texture2D(uColorBuffer, pos); gl_FragColor = color; }</code> </pre> <br>  If everything is done correctly, then the whole picture should look as if it is completely under water. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/a8e/0b0/bbda8e0b0fe175450f789f2a7ec94304.gif"></div><br><blockquote>  <em>Task 1: make the distortion apply only to the bottom of the screen.</em> </blockquote><br><h3>  Camera masks </h3><br>  We are almost done.  It remains for us to apply this distortion effect to the underwater part of the screen.  The easiest way I thought of is to re-render the scene with the surface of the water rendered in solid white, as shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/06f/284/41e06f284290afbf768f6f615360c8bf.png"></div><br>  It will be rendered into the texture that we use as a mask.  Then we will transfer this texture to our refraction shader, which will distort the pixel in the finished image only when the corresponding pixel in the mask is white. <br><br>  Let's add a boolean attribute to the surface of the water to know if it is used as a mask.  Add the following to Water.js: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'isMask'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>,<span class="hljs-attr"><span class="hljs-attr">title</span></span>:<span class="hljs-string"><span class="hljs-string">"Is Mask?"</span></span>});</code> </pre> <br>  Then, as usual, we can pass it to the shader using <code>material.setParameter('isMask',this.isMask);</code>  .  Then declare it in Water.frag and paint the pixel white if the attribute is true. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    uniform uniform bool isMask; //      ,    //    true if(isMask){ color = vec4(1.0); }</span></span></code> </pre> <br>  Make sure it works by turning on the ‚ÄúIs Mask?‚Äù Property in the editor and restarting the game.  It should look white, as in the image above. <br><br>  Now we need a second camera to re-render the scene.  Create a new camera in the editor and call it <strong>CameraMask</strong> .  We also duplicate the Water entity in the editor and name the <strong>WaterMask</strong> duplicate.  Make sure that the Water entity ‚ÄúIs Mask?‚Äù Is false and WaterMask is true. <br><br>  To order the new camera to render to the texture rather than to the screen, create a new script <strong>CameraMask.js</strong> and attach it to the new camera.  We create a <a href="https://developer.playcanvas.com/en/api/pc.RenderTarget.html" rel="external">RenderTarget</a> to capture the output of this camera: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize       CameraMask.prototype.initialize = function() { //  512x512x24-      var colorBuffer = new pc.Texture(this.app.graphicsDevice, { width: 512, height: 512, format: pc.PIXELFORMAT_R8_G8_B8, autoMipmap: true }); colorBuffer.minFilter = pc.FILTER_LINEAR; colorBuffer.magFilter = pc.FILTER_LINEAR; var renderTarget = new pc.RenderTarget(this.app.graphicsDevice, colorBuffer, { depth: true }); this.entity.camera.renderTarget = renderTarget; };</span></span></code> </pre> <br>  Now, after launching the application, you will see that this camera no longer renders the screen.  We can get the output of its target render in <strong>Refraction.js</strong> as follows: <br><br><pre> <code class="javascript hljs">Refraction.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cameraMask = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">'CameraMask'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maskBuffer = cameraMask.camera.renderTarget.colorBuffer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.RefractionPostEffect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.graphicsDevice, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vs.resource, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fs.resource, maskBuffer); <span class="hljs-comment"><span class="hljs-comment">// ... //     ,    };</span></span></code> </pre> <br>  Notice that I pass this mask texture as an argument to the post effect constructor.  We need to create a link to it in our constructor, so it will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">////       var RefractionPostEffect = function (graphicsDevice, vs, fs, buffer) { var fragmentShader = "precision " + graphicsDevice.precision + " float;\n"; fragmentShader = fragmentShader + fs; //       this.shader = new pc.Shader(graphicsDevice, { attributes: { aPosition: pc.SEMANTIC_POSITION }, vshader: vs, fshader: fs }); this.time = 0; //// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;    this.buffer = buffer; };</span></span></code> </pre> <br>  Finally, in the render function, we pass the buffer to our shader: <br><br><pre> <code class="javascript hljs">scope.resolve(<span class="hljs-string"><span class="hljs-string">"uMaskBuffer"</span></span>).setValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer);</code> </pre> <br>  Now, to make sure it all works, I'll leave it to you as a task. <br><br><blockquote>  Task 2: render uMaskBuffer to the screen to make sure that it is the output of the second camera. </blockquote><br>  You need to consider the following: the target render is configured in the initialize script of CameraMask.js, and it should be ready by the time you call Refraction.js.  If the scripts work differently, then we get an error.  To make sure they are working in the correct order, drag CameraMask to the top of the entity list in the editor, as shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/093/747/2d80937472cd112108f303959c35d4c1.png"></div><br>  The second camera should always look with the same look as the original one, so let's make sure that it always follows the position and rotation in the update of the CameraMask.js script: <br><br><pre> <code class="javascript hljs">CameraMask.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow.getPosition(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow.getRotation(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setPosition(pos.x,pos.y,pos.z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.setRotation(rot); };</code> </pre> <br>  In initialize, we define <code>CameraToFollow</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CameraToFollow = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">'Camera'</span></span>);</code> </pre> <br><h3>  Clipping mask </h3><br>  Both cameras now render the same thing.  We want the mask camera to render everything except real water, and the real camera renders everything except the water mask. <br><br>  For this we can use the bit mask of the camera clipping.  It works like <a href="https://www.aurelienribon.com/post/2011-07-box2d-tutorial-collision-filtering/" rel="external">collision masks</a> .  The object will be clipped (that is, not rendered) if the result of the bitwise <code>AND</code> between its mask and camera mask is 1. <br><br>  Suppose that Water has bit 2, and WaterMask has bit 3. All bits should be set for a real camera except 3, and all bits except 2 for a mask camera. The easiest way is to say "all bits except N", as follows in the following way: <br><br><pre> <code class="javascript hljs">~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; N) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Read more about bitwise operations <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" rel="external">here</a> . <br><br>  To customize the clipping masks of the camera, we can insert the following at the bottom of the initialize script of <strong>CameraMask.js</strong> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   ,  2 this.entity.camera.camera.cullingMask &amp;= ~(1 &lt;&lt; 2) &gt;&gt;&gt; 0; //   ,  3 this.CameraToFollow.camera.camera.cullingMask &amp;= ~(1 &lt;&lt; 3) &gt;&gt;&gt; 0; //      ,   : // console.log((this.CameraToFollow.camera.camera.cullingMask &gt;&gt;&gt; 0).toString(2));</span></span></code> </pre> <br>  Now in Water.js, we set the Bit 2 mask of the Water mesh, and <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      initialize  Water.js //    var bit = this.isMask ? 3 : 2; meshInstance.mask = 0; meshInstance.mask |= (1 &lt;&lt; bit);</span></span></code> </pre> <br>  Now one kind will be with ordinary water, and the second - with water of solid white color.  The image on the left shows the view from the source camera, and on the right is the view from the mask camera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/e1b/271/d55e1b271351df16edab549ca065837f.png"></div><br><h3>  Mask application </h3><br>  And now the last step!  We know that underwater areas are marked with white pixels.  We just need to check whether we are in the white pixel, and if we are not, then turn off the distortion in <strong>Refraction.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,      vec4 maskColor = texture2D(uMaskBuffer, pos); vec4 maskColor2 = texture2D(uMaskBuffer, vUv0); //     ? if(maskColor != vec4(1.0) || maskColor2 != vec4(1.0)){ //      pos = vUv0; }</span></span></code> </pre> <br>  And this should solve our problem! <br><br>  <em>It is also worth noting that since the texture for the mask is initialized at startup, then when the window is resized at runtime, it will no longer match the screen size.</em> <br><br><h3>  Smoothing </h3><br>  You may notice that the edges of the scene now look a bit sharp.  This happened because after applying the post-effect we lost the smoothing. <br><br>  We can apply additional smoothing on top of our effect as another post effect.  Fortunately, there is another variable in <a href="https://store.playcanvas.com/" rel="external">PlayCanvas store</a> that we can use.  Go to the <a href="https://store.playcanvas.com/item/57/fxaa-post-effect" rel="external">scripts assets page</a> , click on the big green download button, and select your project from the list that appears.  The script will appear at the root of the Assets window as <strong>posteffect-fxaa.js</strong> .  Just attach it to the Camera entity, and your scene will start to look much better! <br><br><h2>  Thoughts at the end </h2><br>  If you get to here, you can praise yourself!  In this tutorial we covered quite a few techniques.  Now you have to feel confident when working with vertex shaders, rendering in textures, applying post-processing effects, selectively clipping objects, using the depth buffer and working with blending and transparency.  Although we implemented all this in PlayCanvas, you can meet all these general concepts of computer graphics in one form or another on any platform. <br><br>  All of these techniques are also applicable to a variety of other effects.  One particularly interesting use found for vertex shaders was found in <a href="https://www.youtube.com/watch%3Fv%3Dl9NX06mvp2E" rel="external">the Abzu graphics report</a> , where the developers explain how they used vertex shaders to effectively animate tens of thousands of fish on the screen. <br><br>  Now you have a beautiful water effect that you can use in your games!  You can customize it and add your own details.  Much more can be done with water (I did not even mention any type of reflection).  Below are a couple of ideas. <br><br><h4>  Noise-based waves </h4><br>  Instead of just animating the waves using a combination of cosines and sines, you can sample the texture to make the waves look a bit more natural and less predictable. <br><br><h4>  Dynamic Foam Traces </h4><br>  Instead of completely static lines of water on the surface, you can draw textures as objects move to create dynamic traces of foam.  This can be done in many different ways, so this task itself can become a project. <br><br><h2>  Source </h2><br>  A complete PlayCanvas project can be found <a href="https://playcanvas.com/project/533435/overview/toon-water--tuts-tutorial" rel="external">here</a> .  In our repository there is also a <a href="https://github.com/OmarShehata/tutsplus-toon-water" rel="external">project port under Three.js</a> . </div><p>Source: <a href="https://habr.com/ru/post/417091/">https://habr.com/ru/post/417091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417081/index.html">North, will, hope, a country without borders (c), or How projects are made in the harsh Siberian conditions</a></li>
<li><a href="../417083/index.html">High loads of the World Cup 2018</a></li>
<li><a href="../417085/index.html">Browsers turn off the sound in your WebRTC application. Stop what?</a></li>
<li><a href="../417087/index.html">HPE Digitize 2018: event and live streaming</a></li>
<li><a href="../417089/index.html">Quantum computer: one photon to rule by all</a></li>
<li><a href="../417093/index.html">Modbus touch switches: why you need it and how to use it in a smart apartment</a></li>
<li><a href="../417097/index.html">JavaScript Metaprogramming</a></li>
<li><a href="../417099/index.html">As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 2</a></li>
<li><a href="../417101/index.html">Definition of Ready - what we forgot to tell us</a></li>
<li><a href="../417103/index.html">Spark SQL. A little bit about the query optimizer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>