<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reuse rows for high performance on React Native ListView</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reusing previously placed in-memory strings that go outside the screen when scrolling is a widely used technique to optimize the use of the ListView c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reuse rows for high performance on React Native ListView</h1><div class="post__text post__text-html js-mediator-article">  Reusing previously placed in-memory strings that go outside the screen when scrolling is a widely used technique to optimize the use of the ListView component, originally implemented in iOS and Android.  The default implementation of ListView as a component of React Native does not directly contain this optimization, but has a number of other nice advantages.  However, this is an excellent sample worth exploring.  Considering this implementation as part of the React study will also be an interesting thought experiment. <br><br><h2>  <font color="#f9a339">Lists are an important part of mobile application development.</font> </h2><br>  Lists are the heart and soul of mobile apps.  Lots of apps display lists: this is the list of posts in your Facebook app feed, lists of conversations in Messenger, a list of Gmail emails, a list of photos on Instagram, a list of tweets on Twitter, etc. <br><br>  As your lists become more complex, with a significant number of data sources, thousands of lines, media files requiring large amounts of memory, their development also becomes more difficult. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the one hand, you want to maintain the speed of your application, because  scrolling at 60 FPS has become the gold standard for native interaction experience (UX).  On the other hand, you want to keep memory consumption low, because mobile devices do not have excessive resources.  It is not always easy to fulfill both of these conditions. <br><br><img src="https://habrastorage.org/files/ef4/01d/b8e/ef401db8eddf41139377429bdbdebefc.jpg"><br><br><h2>  <font color="#f9a339">Search for the perfect implementation of the ListView</font> </h2><br>  The fundamental rule of software development is that no optimization can be foreseen for any scenario. <a name="habracut"></a>  Consider an example from another area: there is no database that is ideal for storing any data.  You may be familiar with SQL databases, which are great for some use cases, and NoSQL databases, which are optimal for other situations.  You are unlikely to develop your own database, therefore, as a software developer, you need to select the appropriate tool for solving a specific task. <br><br>  The same rule applies to the list view: you can hardly find a way to implement the list view, which would not only be suitable for any use case, but also maintain a high FPS speed and low need for memory. <br><br>  Roughly speaking, there are two types of options for using lists in a mobile application: <br><br>  ‚Ä¢ Almost identical strings with a very large data source.  Contact list lines look the same and have the same structure.  We want users to quickly browse the lines until they find what they are looking for.  Example: address book. <br>  ‚Ä¢ Strongly different strings and a small data source.  Here, all the lines are different and contain a different amount of text.  Some contain media.  In most cases, users will read messages one by one, and not view the entire stream.  Example: chat messages. <br>  The advantage of separating into different use cases is that you can offer different optimization techniques for each option. <br><br><h2>  <font color="#f9a339">Ready view of React Native lists</font> </h2><br>  React Native comes with a great ready-made ListView implementation.  It contains some very reasonable optimizations, such as ‚Äúlazy loading‚Äù of rows appearing on the screen when scrolling, reducing the number of redraws to a minimum, and drawing lines in different event cycles. <br><br>  Another interesting feature of the finished ListView implementation is that it is fully implemented in JavaScript over the native ScrollView component that is included with React Native.  If you have had experience developing for iOS or Android, this fact may seem strange.  Their native SDKs are based on the time-tested implementations of list views - UITableView for iOS and ListView for Android.  It is noteworthy that the React Native team decided not to use any of them. <br><br>  There may be various reasons for this, but I assume that this is related to previously defined use cases.  UITableView for iOS and ListView for Android use similar optimization techniques that work fine for the first use case ‚Äî for lists with almost identical rows and a very large data source.  The finished ListView React Native view is optimized for the second option. <br><br>  The main list in the Facebook ecosystem is the Facebook post feed.  The Facebook application was implemented in iOS and Android long before React Native.  Perhaps, initially, the tape implementation was really based on the native UITableView implementations in iOS and ListView in Android, and as you can imagine, it didn‚Äôt work as well as expected.  The tape is a classic example of the second use case.  Lines are very different, because  All publications are different - they differ in the volume of content, contain different types of media files and have a different structure.  Users consistently read publications in the feed and usually do not scroll through hundreds of lines at a time. <br><br><h2>  <font color="#f9a339">So why don't we consider reuse?</font> </h2><br>  If the second use case ‚Äî lists with very different strings and a small data source ‚Äî fits your needs, then you should consider choosing a ready-made ListView implementation.  If your case is described by the first use case, and you are not satisfied with the work of the finished implementation, we would recommend experimenting with alternatives. <br><br>  I remind you that the first use case is lists with almost identical lines and a very large data source.  For this scenario, the main optimization technique that has proven its effectiveness is string reuse. <br>  Since our data source is potentially very large, it is obvious that we cannot store all strings in memory at the same time.  To minimize memory consumption, we will store only those lines that are currently displayed on the screen.  Lines that are no longer visible as a result of scrolling will be freed, and new lines that become visible will be placed in memory. <br><br>  However, for the constant release and placement in memory of the lines when scrolling requires a very intensive work of the processor.  Using this native approach, we may not reach the desired speed of 60 FPS.  Fortunately, in this use case, the lines are almost the same.  This means that instead of releasing a line scrolled off the screen, we can create a new line from it, simply replacing the data displayed in it with data from the new line, thereby avoiding new allocations in memory. <br><br>  Let's move on to the practical part.  Let's prepare an example to experiment with this use case.  The example will contain 3,000 lines of data of the same structure: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Text, View, Dimensions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RecyclingListView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./RecyclingListView'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROWS_IN_DATA_SOURCE = <span class="hljs-number"><span class="hljs-number">3000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataSource = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;ROWS_IN_DATA_SOURCE; i++) dataSource.push(<span class="hljs-string"><span class="hljs-string">`This is the data for row # </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i+</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclingExample</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">View</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{flex:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">paddingTop:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">20</span></span></span></span><span class="xml"><span class="hljs-tag">,}}&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">RecyclingListView</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">renderRow</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.renderRow}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">numRows</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{dataSource.length}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rowHeight</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{50}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">View</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } renderRow(rowID) { return ( </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Text</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Dimensions.get</span></span></span></span><span class="xml"><span class="hljs-tag">('</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">window</span></span></span></span><span class="xml"><span class="hljs-tag">')</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.width</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">height:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">50</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">backgroundColor:</span></span></span></span><span class="xml"><span class="hljs-tag"> '#</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ffffff</span></span></span></span><span class="xml"><span class="hljs-tag">' }}&gt;</span></span></span><span class="xml">{dataSource[rowID]}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Text</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); view rawRecyclingExample.js hosted with by GitHub } }</span></span></code> </pre> <br><h2>  <font color="#f9a339">Using the native implementation of UITableView</font> </h2><br>  As noted earlier, native SDKs for iOS and Android have robust implementations that perform string rewriting.  Focus on iOS and use UITableView. <br><br>  You may wonder why we are not trying to implement this technique entirely in JavaScript.  This is an interesting question that deserves a detailed description in several separate blog entries.  However, in short, in order to rewrite the lines properly, we must always know the current scroll offset, since when scrolling, the lines must be overwritten.  Scroll events occur in the native zone, and to reduce the number of transitions through the <a href="http://tadeuzagallo.com/blog/react-native-bridge/">RN-bridge</a> , it makes sense to track them in it. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Objective-C</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#import</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">RNTableViewManager</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#import</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">RNTableView</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>" @<span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> RNTableViewManager RCT_EXPORT_MODULE() - (UIView *)view { <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[[RNTableView alloc]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">initWithBridge</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:self.bridge</span></span>]; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">RCT_EXPORT_VIEW_PROPERTY</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">rowHeight</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">RCT_EXPORT_VIEW_PROPERTY</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">numRows</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">NSInteger</span></span>) @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The wrapper itself will be executed in RNTableView.m, and will mainly deal with passing properties and using them in the right places.  There is no need to go into the details of the next implementation, as it still lacks some interesting parts. <br><br><pre> <code class="hljs kotlin">#<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"RNTableView.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"RCTConvert.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"RCTEventDispatcher.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"RCTUtils.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"UIView+React.h"</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> RNTableView()&lt;UITableViewDataSource, UITableViewDelegate&gt; <span class="hljs-meta"><span class="hljs-meta">@property</span></span> (strong, nonatomic) UITableView *tableView; <span class="hljs-meta"><span class="hljs-meta">@end</span></span> <span class="hljs-meta"><span class="hljs-meta">@implementation</span></span> RNTableView RCTBridge *_bridge; RCTEventDispatcher *_eventDispatcher; NSMutableArray *_unusedCells; - (instancetype)initWithBridge:(RCTBridge *)bridge { RCTAssertParam(bridge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((self = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> initWithFrame:CGRectZero])) { _eventDispatcher = bridge.eventDispatcher; _bridge = bridge; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ([_bridge respondsToSelector:NSSelectorFromString(@<span class="hljs-string"><span class="hljs-string">"parentBridge"</span></span>)] &amp;&amp; [_bridge valueForKey:@<span class="hljs-string"><span class="hljs-string">"parentBridge"</span></span>]) { _bridge = [_bridge valueForKey:@<span class="hljs-string"><span class="hljs-string">"parentBridge"</span></span>]; } _unusedCells = [NSMutableArray array]; [self createTableView]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self; } RCT_NOT_IMPLEMENTED(-initWithFrame:(CGRect)frame) RCT_NOT_IMPLEMENTED(-initWithCoder:(NSCoder *)aDecoder) - (void)layoutSubviews { [self.tableView setFrame:self.frame]; } - (void)createTableView { _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain]; _tableView.dataSource = self; _tableView.delegate = self; _tableView.backgroundColor = [UIColor whiteColor]; [self addSubview:_tableView]; } - (void)setRowHeight:(float)rowHeight { _tableView.estimatedRowHeight = rowHeight; _rowHeight = rowHeight; } - (NSInteger)numberOfSectionsInTableView:(UITableView *)theTableView { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } - (NSInteger)tableView:(UITableView *)theTableView numberOfRowsInSection:(NSInteger)section { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.numRows; } -(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.rowHeight; } <span class="hljs-comment"><span class="hljs-comment">//       @end</span></span></code> </pre><br><h2>  <font color="#f9a339">The key concept is to combine the native environment and JS</font> </h2><br>  We want our strings to be React components defined in JavaScript, because that is all the business logic.  But we also want them to be easily customized.  Since the real rewriting logic works in the native environment, we need to somehow ‚Äútransfer‚Äù these components to it from JS. <br><br>  It is best to pass the React components as children to our native component.  Using the native component from JS, adding the strings to JSX as child components, we force React Native to convert them into UIView views, which will be presented to the native component. <br><br>  The trick is that you do not need to create components from all rows of the data source.  Since our main goal is to reuse strings, only a small amount is needed to display on the screen.  Suppose that the screen simultaneously displays 20 lines.  This value can be obtained by dividing the screen height (736 logical points for iPhone 6 Plus) by the height of each row (in this case, 50), getting an approximate value of 15, and then adding a few additional lines. <br><br>  When these 20 lines are passed to our component as children of a subview for initialization, they are not displayed yet.  We keep them in the bank "unused cells." <br><br>  This is followed by the most interesting.  Native rewriting in UITableView works using the ‚ÄúdequeueReusableCell‚Äù method.  If a cell can be overwritten (from a string that is not displayed on the screen), the overwritten cell can also be returned using this method.  If a cell cannot be overwritten, our code will have to put a new one in memory.  The placement of new cells occurs only at the beginning, before we fill the screen with visible lines.  So, how to put in memory a new cell?  We will simply take one of the unused cells in our bank: <br><br><pre> <code class="hljs pgsql"> - (<span class="hljs-type"><span class="hljs-type">void</span></span>)insertReactSubview:(UIView *)subview atIndex:(NSInteger)atIndex { //        subview,        // [super insertSubview:subview atIndex:atIndex]; [_unusedCells addObject:subview]; } - (UIView*) getUnusedCell { UIView* res = [_unusedCells lastObject]; [_unusedCells removeLastObject]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res != nil) { res.tag = [_unusedCells count]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } - (UITableViewCell *)tableView:(UITableView *)theTableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *cellIdentifier = @"CustomCell"; TableViewCell *cell = (TableViewCell *)[theTableView dequeueReusableCellWithIdentifier:cellIdentifier]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell == nil) { cell = [[TableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; cell.cellView = [self getUnusedCell]; NSLog(@"Allocated childIndex %d for row %d", (<span class="hljs-type"><span class="hljs-type">int</span></span>)cell.cellView.tag, (<span class="hljs-type"><span class="hljs-type">int</span></span>)indexPath.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { NSLog(@"Recycled childIndex %d for row %d", (<span class="hljs-type"><span class="hljs-type">int</span></span>)cell.cellView.tag, (<span class="hljs-type"><span class="hljs-type">int</span></span>)indexPath.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>); } //      ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre><br>  The final element of our puzzle will be filling the new overwritten / created cell with data from the data source.  Since our rows are components of React, we will translate this process into React terminology: we need to assign new properties to the row component based on the correct row from the data source that we want to display. <br><br>  Since the change in properties occurs in the JS environment, we need to do this directly in JavaScript.  This means that you need to return a binding for one of our series.  We can do this by passing an event from the native environment to JS: <br><br>  <i>This is a complete implementation of the function, contains all the missing parts.</i> <br><pre> <code class="hljs objectivec"> - (<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> *)tableView:(<span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *)theTableView cellForRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *cellIdentifier = <span class="hljs-string"><span class="hljs-string">@"CustomCell"</span></span>; TableViewCell *cell = (TableViewCell *)[theTableView dequeueReusableCellWithIdentifier:cellIdentifier]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { cell = [[TableViewCell alloc] initWithStyle:<span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellStyleDefault</span></span> reuseIdentifier:cellIdentifier]; cell.cellView = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getUnusedCell]; <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Allocated childIndex %d for row %d"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)cell.cellView.tag, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)indexPath.row); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Recycled childIndex %d for row %d"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)cell.cellView.tag, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)indexPath.row); } <span class="hljs-comment"><span class="hljs-comment">//     JS NSDictionary *event = @{ @"target": cell.cellView.reactTag, @"childIndex": @(cell.cellView.tag), @"rowID": @(indexPath.row), @"sectionID": @(indexPath.section), }; [_eventDispatcher sendInputEventWithName:@"onChange" body:event]; return cell; }</span></span></code> </pre><br><h2>  <font color="#f9a339">Connect all together</font> </h2><br>  Next, for the final implementation of RecyclingListView.js, we need to bind our native component in JavaScript: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { requireNativeComponent, View } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-native'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReboundRenderer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ReboundRenderer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RNTableViewChildren = requireNativeComponent(<span class="hljs-string"><span class="hljs-string">'RNTableViewChildren'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROWS_FOR_RECYCLING = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclingListView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> binding = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;ROWS_FOR_RECYCLING; i++) binding.push(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">binding</span></span>: binding <span class="hljs-comment"><span class="hljs-comment">// childIndex -&gt; rowID }; } render() { const bodyComponents = []; for (let i=0; i&lt;ROWS_FOR_RECYCLING; i++) { bodyComponents.push( &lt;ReboundRenderer key={'r_' + i} boundTo={this.state.binding[i]} render={this.props.renderRow} /&gt; ); } return ( &lt;View style={{flex: 1}}&gt; &lt;RNTableView style={{flex: 1}} onChange={this.onBind.bind(this)} rowHeight={this.props.rowHeight} numRows={this.props.numRows} &gt; {bodyComponents} &lt;/RNTableView&gt; &lt;/View&gt; ); } onBind(event) { const {target, childIndex, rowID, sectionID} = event.nativeEvent; this.state.binding[childIndex] = rowID; this.setState({ binding: this.state.binding }); } }</span></span></code> </pre><br>  Another optimization that we want to add is to minimize the number of redraws.  Those.  we want the line to be redrawn only when it is rewritten and the binding changes. <br><br>  For this we need a ReboundRenderer.  The parameter of this simple JS component is the index of the row of the data source to which this component is currently bound (the ‚ÄúboundTo‚Äù parameter).  It is redrawn only when the binding is changed (using the standard optimization shouldComponentUpdate): <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'React'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ReboundRenderer = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">propTypes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">boundTo</span></span>: React.PropTypes.number.isRequired, <span class="hljs-attr"><span class="hljs-attr">render</span></span>: React.PropTypes.func.isRequired, }, <span class="hljs-attr"><span class="hljs-attr">shouldComponentUpdate</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nextProps</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextProps.boundTo !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.boundTo; }, <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReactElement</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ReboundRenderer render() boundTo='</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.boundTo); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.render(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.boundTo); }, }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = ReboundRenderer;</code> </pre><br>  A fully working example, containing mostly the code provided here, <a href="https://github.com/wix/list-view-experiments">can be found in this repository</a> . <br>  The repository also contains descriptions of several other experiments that may interest you.  The <a href="">tableview-children.ios.js</a> experiment also applies to this case. <br><br>  <i><b>Tal Kohl</b> is a full-stack developer specializing in the development of native mobile applications for iOS and Android.</i>  <i>React Native - his new hobby.</i>  <i>Tal was a co-founder of two technology companies, one of them now belongs to the platform for <a href="http://ru.wix.com/">creating websites</a> Wix.com.</i> <br><br>  Original article: <a href="http://blog.wix.engineering/2016/06/30/recycling-rows-for-high-performance-react-native-list-views/">Wix engineers blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/305834/">https://habr.com/ru/post/305834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305822/index.html">What can we learn from PokemonGO?</a></li>
<li><a href="../305824/index.html">Saydkik-suicide</a></li>
<li><a href="../305826/index.html">Transition from monolith to microservices</a></li>
<li><a href="../305828/index.html">Angular2-like registration of components and dependencies for knockoutjs</a></li>
<li><a href="../305832/index.html">After a year of using NodeJS to develop</a></li>
<li><a href="../305836/index.html">Mobile programmatic "on the fingers": the revolution will be velvet</a></li>
<li><a href="../305838/index.html">Big Data from A to Z. Part 5.2: Advanced hive features</a></li>
<li><a href="../305840/index.html">Basics of game design: 20 board games. Part Four: Train Ticket, Carcassonne, Colonialists</a></li>
<li><a href="../305842/index.html">Improving colors on the web (for eplofilov)</a></li>
<li><a href="../305844/index.html">Lenovo will fix a 0day ThinkPwn vulnerability in the firmware of its computers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>