<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous programming - event testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes you have to write tests for events, and it is inconvenient to do that ‚Äî additional methods and fields start to multiply very quickly. How to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous programming - event testing</h1><div class="post__text post__text-html js-mediator-article">  Sometimes you have to write tests for events, and it is inconvenient to do that ‚Äî additional methods and fields start to multiply very quickly.  How to test events in C # and I want to tell. <br><br><a name="habracut"></a><br>  To begin with an example.  I have an API that asynchronously downloads a web page.  To get the page, I subscribe to the event [ <a href="https://habr.com/ru/post/71410/" title="In this case, I am testing the MicrosoftSubscription.Sync.WebDataProvider class &amp; ndash; This is part of the Syndicated Client Experiences SDK, a framework that uses the well-known photoSuru application.">1</a> ] and thereby create another method in which my asserts actually live.  Naturally, the test method itself has to be blocked because  otherwise, the test runner will simply exit without waiting for my callback. <br><br><blockquote><code><font color="black">[TestFixture]&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">class</font> MyTests&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">private</font> ManualResetEvent waitHandle;&lt;br/&gt; <br> [Test] &lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> TestAsyncPageDownloading()&lt;br/&gt; <br> {&lt;br/&gt; <br> waitHandle = <font color="#0202E5">new</font> ManualResetEvent( <font color="#0202E5">false</font> );&lt;br/&gt; <br> ‚ãÆ&lt;br/&gt; <br> wdp.GetWebDataCompleted += wdp_GetWebDataCompleted;&lt;br/&gt; <br> wdp.GetWebDataAsync( <font color="#0202E5">new</font> Uri( <font color="#570000">"http://nesteruk.org/blog"</font> ), <font color="#0202E5">new</font> <font color="#0202E5">object</font> ());&lt;br/&gt; <br> <strong>waitHandle.WaitOne();</strong> <font color="#006400">//    assert'</font> <br> }&lt;br/&gt; <br> <font color="#0202E5">void</font> wdp_GetWebDataCompleted( <font color="#0202E5">object</font> sender, GetWebDataCompletedEventArgs e)&lt;br/&gt; <br> {&lt;br/&gt; <br> StreamReader sr = <font color="#0202E5">new</font> StreamReader(e.Stream);&lt;br/&gt; <br> <font color="#0202E5">string</font> s = sr.ReadToEnd();&lt;br/&gt; <br> <font color="#006400">//     test runner'</font> <br> Assert.Contains(s, <font color="#570000">"Dmitri"</font> , <font color="#570000">"My webpage should have my name."</font> );&lt;br/&gt; <br> <strong>waitHandle.Set();</strong> <font color="#006400">//  </font> <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  Unfortunately, this approach does not take into account the situation in which the test ‚Äúfreezes‚Äù and thus slows down the testing process.  To do this, we can add a timeout for the <code>WaitOne()</code> call, but then we must also test the probability that the callback will not be called at all.  To do this, we have to add another variable of type <code>bool</code> .  Here's what happens: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote> <code><font color="black"><font color="#0202E5">private</font> <font color="#0202E5">bool</font> callbackInvoked;&lt;br/&gt; <br> ‚ãÆ&lt;br/&gt; <br> [Test]&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> TestAsyncPageDownloading()&lt;br/&gt; <br> {&lt;br/&gt; <br> waitHandle = <font color="#0202E5">new</font> ManualResetEvent( <font color="#0202E5">false</font> );&lt;br/&gt; <br> wdp.GetWebDataCompleted += wdp_GetWebDataCompleted;&lt;br/&gt; <br> wdp.GetWebDataAsync( <font color="#0202E5">new</font> Uri( <font color="#570000">"http://nesteruk.org/blog"</font> ), <font color="#0202E5">new</font> <font color="#0202E5">object</font> ());&lt;br/&gt; <br> waitHandle.WaitOne( <strong>5000</strong> ); <font color="#006400">//   5    assert'</font> <br> <strong>Assert.IsTrue(callbackInvoked, <font color="#570000">"Callback method was never called"</font> );</strong> &lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0202E5">void</font> wdp_GetWebDataCompleted( <font color="#0202E5">object</font> sender, GetWebDataCompletedEventArgs e)&lt;br/&gt; <br> {&lt;br/&gt; <br> <strong>callbackInvoked = <font color="#0202E5">true</font> ;</strong> <font color="#006400">//      </font> <br> StreamReader sr = <font color="#0202E5">new</font> StreamReader(e.Stream);&lt;br/&gt; <br> <font color="#0202E5">string</font> s = sr.ReadToEnd();&lt;br/&gt; <br> <font color="#006400">//     test runner'</font> <br> Assert.Contains(s, <font color="#570000">"Dmitri"</font> , <font color="#570000">"My webpage should have my name."</font> );&lt;br/&gt; <br> waitHandle.Set(); <font color="#006400">//  </font> <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  In order to avoid multiplying the number of methods and variables in our test fixture, it would be useful to put the ‚Äúasynchronous tester‚Äù into a separate class that could be used as a manager. [ <a href="https://habr.com/ru/post/71410/" title="This approach was suggested by some vansickle in the comments on the page of my blog.">2</a> ] <br><br><blockquote> <code><font color="black"><font color="#0202E5">public</font> <font color="#0202E5">class</font> EventTester&lt;SenderType, ArgumentType&gt; : IDisposable&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">private</font> <font color="#0202E5">readonly</font> ManualResetEvent waitHandle;&lt;br/&gt; <br> <font color="#0202E5">private</font> <font color="#0202E5">readonly</font> Action&lt;SenderType, ArgumentType&gt; postHocTests;&lt;br/&gt; <br> <font color="#0202E5">private</font> <font color="#0202E5">bool</font> called;&lt;br/&gt; <br> <font color="#0202E5">private</font> IAsyncResult waitToken;&lt;br/&gt; <br> <font color="#0202E5">public</font> EventTester(Action&lt;SenderType, ArgumentType&gt; postHocTests)&lt;br/&gt; <br> {&lt;br/&gt; <br> waitHandle = <font color="#0202E5">new</font> ManualResetEvent( <font color="#0202E5">false</font> );&lt;br/&gt; <br> <font color="#0202E5">this</font> .postHocTests = postHocTests;&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> Handler(SenderType sender, ArgumentType args)&lt;br/&gt; <br> {&lt;br/&gt; <br> waitHandle.Set();&lt;br/&gt; <br> waitToken = postHocTests.BeginInvoke(sender, args, <font color="#0202E5">null</font> , <font color="#0202E5">null</font> );&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> Wait( <font color="#0202E5">int</font> mullisecondsTimeout)&lt;br/&gt; <br> {&lt;br/&gt; <br> called = waitHandle.WaitOne(mullisecondsTimeout);&lt;br/&gt; <br> }&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> Dispose()&lt;br/&gt; <br> {&lt;br/&gt; <br> Assert.IsTrue(called, <font color="#570000">"The event was never handled"</font> );&lt;br/&gt; <br> postHocTests.EndInvoke(waitToken);&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  What does this tester do?  First, it caches the callback method that needs to be called for post hoc tests.  Further, it provides the <code>Wait()</code> method, which is delegated to our <code>ManualResetEvent</code> and thus allows us to wait a while until an event handler is called.  As soon as it is called - we immediately run the final tests.  And then - a small trick - we implement <code>IDisposable()</code> and in the <code>Dispose()</code> method we check if the handler was called.  Since assert interrupts execution, the subsequent <code>EndInvoke()</code> will be called only when it is relevant. <br><br>  As for the test itself, now it looks like this: <br><br><blockquote> <code><font color="black">[Test]&lt;br/&gt; <br> <font color="#0202E5">public</font> <font color="#0202E5">void</font> BetterAsyncTest()&lt;br/&gt; <br> {&lt;br/&gt; <br> <font color="#0202E5">using</font> ( <font color="#0202E5">var</font> eventTester = <font color="#0202E5">new</font> EventTester&lt; <font color="#0202E5">object</font> , GetWebDataCompletedEventArgs&gt;(&lt;br/&gt; <br> (o, args) =&gt;&lt;br/&gt; <br> {&lt;br/&gt; <br> StreamReader sr = <font color="#0202E5">new</font> StreamReader(args.Stream);&lt;br/&gt; <br> <font color="#0202E5">string</font> s = sr.ReadToEnd();&lt;br/&gt; <br> Assert.Contains(s, <font color="#570000">"Dmitri"</font> , <font color="#570000">"My webpage should have my name."</font> );&lt;br/&gt; <br> }))&lt;br/&gt; <br> {&lt;br/&gt; <br> wdp.GetWebDataCompleted += eventTester.Handler;&lt;br/&gt; <br> wdp.GetWebDataAsync( <font color="#0202E5">new</font> Uri( <font color="#570000">"http://nesteruk.org/blog"</font> ), <font color="#0202E5">new</font> <font color="#0202E5">object</font> ());&lt;br/&gt; <br> eventTester.Wait(5000);&lt;br/&gt; <br> }&lt;br/&gt; <br> }&lt;br/&gt; <br></font></code> </blockquote><br>  This is certainly not the most readable test in the world, but at least it does not produce additional fields and methods in the class body.  Testing events as well as testing pairs of <code>BeginXxx()/EndXxx()</code> is a simple task, since it always predictably includes two elements - the call and the handler, the beginning and the end.  ‚ñ† <br><br>  Notes <br><ol><li>  <a href="https://habr.com/ru/post/71410/" title="Back to text">‚Üë</a> In this case, I'm testing the <code>MicrosoftSubscription.Sync.WebDataProvider</code> class is part of the <a href="http://windowsclient.net/wpf/starter-kits/sce.aspx">Syndicated Client Experiences SDK</a> , a framework that uses the well-known photoSuru application. </li><li>  <a href="https://habr.com/ru/post/71410/" title="Back to text">‚Üë</a> This approach was suggested by some vansickle in the comments on <a href="http://nesteruk.org/blog/post/How-to-unit-test-asynchronous-operations.aspx">my blog page</a> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/71410/">https://habr.com/ru/post/71410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../71391/index.html">Download and rename files</a></li>
<li><a href="../71402/index.html">Amateur futurology or my view of the future</a></li>
<li><a href="../71403/index.html">PC Pro survey result: 61% of people listen to music using the dynamics of their laptop</a></li>
<li><a href="../71407/index.html">Power push ups</a></li>
<li><a href="../71408/index.html">Downloading from Picasa directly to Facebook</a></li>
<li><a href="../71415/index.html">Habralyudi, do you listen to music using the dynamics of your laptop?</a></li>
<li><a href="../71416/index.html">Laziness - curse or find?</a></li>
<li><a href="../71418/index.html">301: the number of shame</a></li>
<li><a href="../71419/index.html">Do you have access to IPv6 Internet?</a></li>
<li><a href="../71420/index.html">Power pull-ups</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>