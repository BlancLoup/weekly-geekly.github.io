<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Escape from the dungeon types. We work with data, the type of which is determined dynamically.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When the result of a SQL query entails infinite type conversions to various possible types of fields. When the code is filled with obscure logic with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Escape from the dungeon types. We work with data, the type of which is determined dynamically.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/594/6f7/981/5946f7981e6844bcb17ba06cfbc0c40c.jpg"><br><br>  When the result of a SQL query entails infinite type conversions to various possible types of fields.  When the code is filled with obscure logic with a huge search of overloads by types of boost :: variant.  When you do not know how to take an argument of an arbitrary type using the RPC protocol.  Then a dynamic typing emulation mechanism in C ++ is required.  Extensible and easy to use, creating a clear API.  Such that does not require a predefined list of types and does not force you to work with pointers to the base class.  There is such a mechanism - double dispatch will help us! <br><a name="habracut"></a><br>  To understand what double dispatching is and how to prepare it correctly, efficiently and clearly in C ++, you first need to clarify what it is for, and go through the whole evolutionary path to this solution.  Without this explanation, the novice developer will go mad by the end of the reading, and the experienced developer will most likely drown in his own associations and draw the wrong conclusions.  Therefore, we will start from the very beginning - from the basics of dynamic typing and why it is needed in C ++. <br><br><h4>  Dynamic typing in C ++ </h4><br>  In C ++, typing is static, which allows you to track errors when working with typical operations at the compilation stage.  As a rule, in 90% of cases we know in advance either the type of the result of any operation or the base class of all possible values.  However, there is a class of tasks where the type of values ‚Äã‚Äãas a result of the operation is not known in advance and is calculated at the execution stage.  The classic example is the result of a query to the database, where, as a result of executing a SQL query, we get a set of serialized values ‚Äã‚Äãthat need to be unpacked into the appropriate types after the query has been executed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another example is the result of calling a remote function via the RPC protocol, the result will be known at runtime, and not always at the task setting stage we can predict the set of return values, especially if we solve a common problem with providing an intermediate API for your RPC protocol.  All the same is true for any potentially extensible functionality that works with a type system that it is more convenient to calculate at runtime, for example, the same function arguments or SQL query parameters, which are generally more convenient to generalize, but at the same time need to be stored somehow and transmit. <br><br>  We begin with a classic solution through the base class and its heirs. <br><br><blockquote>  There is a class of tasks where the type of values ‚Äã‚Äãas a result of the operation is not known in advance and is calculated at the execution stage.  A classic example is the result of a database query. </blockquote><br><h4>  Basic Interface and Inheritance </h4><br>  The classic solution through the basic interface in C ++ directly uses one of the OOP paradigms - polymorphism.  A general class is selected, usually abstract, it introduces a number of methods that are redefined as heirs, and work is done with a reference or pointer to the type of a common ancestor of the heir values. <br>  Consider a small example.  Suppose we have a task: to store different types of goods in stock.  Let any product have a name, an identifier of the category of goods in stock and a certain price.  The base interface class with this approach will look like this: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IGoods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TypeID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  If, suppose, we need to describe such a category of goods as candy, then we need a class - the successor of the basic interface with certain functions Name, TypeID and Price, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Candies</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IGoods { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TYPE_ID = <span class="hljs-number"><span class="hljs-number">9001</span></span>; Candies(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; name, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> price); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TypeID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TYPE_ID; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_price; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m_price; };</code> </pre><br>  As a result, you can fill the warehouse with all sorts of goods, such as candy, while operating only with links to the base class.  That is, as a rule, we do not need to know which heir class is really behind the link, since the warehouse doesn‚Äôt care what is stored in it, so that you can read the name of the product, price and article number. <br><br>  We get the following advantages: <br><br><ul><li>  extensibility is the main plus, you can create heirs in any library and work with them on general rights;  it does not work this way, for example, if you select the infinite switch method, at some point the system will suffocate from an excess of case variants in different parts of the same type code; </li><li>  dynamic typing - in fact, the type can be set at the execution stage, creating an instance of one or another heir class depending on the logic of the task, as a result, you can, for example, fill in the result of parsing a JSON object or a SQL query; </li><li>  visualization - the ability to very easily build a clear diagram for everyone with the tree of heirs, the very description of the base class implies the obviousness of the behavior of the class of the heir. </li></ul><br>  There are, however, and minuses, there are only three of them, but ignoring them, we will get a constant headache, because we lose all the advantages of the C ++ classes, reducing the work to pointers to the base interface class: <br><br><ul><li>  it is difficult to create - whatever you say, but filling up a warehouse, that is, creating objects of previously unknown heir classes, has to be done through factories; </li><li>  difficult to store - there are only two variants of the built-in types: a link and a pointer, and only a pointer can be stored.  Of course, storing a container filled with pointers is detrimental to the health of the application, and smart pointers come to the rescue, like std :: shared_ptr and std :: unique_ptr.  The first is quite heavy, the behavior of the second causes a sharp headache with any copying, explicit or implicit; </li><li>  difficult to copy - for the case of std :: unique_ptr, you should attend to the Clone method in the base class, as, indeed, for std :: shared_ptr, if we do not plan to refer to different data from different containers.  That is, we either cheat the user and copying the container does not copy the data in the usual sense of C ++, or further complicate the base class and all its descendants by adding a primitive cloning operation to it. </li></ul><br>  In fact, with this classic approach, the code in one place looks like a horror movie and instead of the usual constructor, a similar monster appears: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IGoods&gt;&gt; goods; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IGoods&gt; result = GoodsFactory::Create&lt;Candies&gt;(); goods.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result));</code> </pre><br>  In another place of the code, a formidable horror begins when accessing the elements of the collection through ‚Äúsmart‚Äù pointers. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IGoods&gt;&gt; another(goods.size()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(goods.begin(), goods.end(), another.begin(), [](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IGoods&gt;&amp; element) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element-&gt;Clone(); } );</code> </pre><br>  All this looks in the worst traditions of C ++, and therefore it is not surprising that most developers consider such constructions to be normal, even if they are rendered into the interface or shown in an open source system. <br><br>  Is it really that bad in C ++ and you can't get by with ordinary classes with generated copy and move constructors, assignment operators and other pleasures of life?  What prevents us from encapsulating all the logic of working with a pointer to the base class in an object of a container class?  Yes, in general, nothing. <br><br><h4>  Data class inheritance </h4><br>  It's time to rebuild the logic of the base class.  We will pack all the logic of working with the base interface into the usual C ++ class.  The base interface class will cease to be abstract, and class objects will receive the usual logic of designers and destructors, will be able to copy and assign values, but most importantly, we will not lose all the advantages of the previous approach, getting rid of the minuses! <br><br>  In other words, the base class receives some data in the form of a class whose behavior is determined by the successor classes whose data class is inherited from the data class of the base class ... does it sound confusing?  Now let's take an example, and everything will become clear. <br><br><blockquote>  The base class receives data in the form of a class similar to the interface class, whose behavior is determined by the data classes of the heirs.  Inheritance is obtained double: data classes are also inherited </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      API class object { public: object(); virtual ~object(); virtual bool is_null() const; virtual std::string to_string() const; protected: //    ! class data; private: std::shared_ptr&lt;data&gt; m_data; }; //     API //     #include class object::data { public: data() { } virtual ~data() { } virtual bool is_null() const { return true; } virtual std::string to_string() const { return "null"; } }; //      API //      ,   object class flower : public object { public: flower(std::string const&amp; name); virtual bool is_null() const override; virtual std::string to_string() const override; virtual std::string name() const; virtual void rename(std::string const&amp; name); protected: //    ! class data; }; //     API //     #include class flower::data : public object::data { public: static const std::string FLOWER_UNKNOWN; data() : m_name(FLOWER_UNKNOWN) { } data(std::string const&amp; name) : m_name(name) { } virtual bool is_null() const override { return false; } virtual std::string to_string() const override { return "flower: " + m_name; } virtual std::string name() const { return m_name; } virtual void rename(std::string const&amp; name) { m_name = name; } private: std::string m_name; };</span></span></code> </pre><br>  Actually heirs are usually more, and they, as a rule, appear in dependent libraries.  Now it's time to figure out what this fun design allows. <br><br><pre> <code class="cpp hljs">object rose = flower(<span class="hljs-string"><span class="hljs-string">"rose"</span></span>); object none; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;object&gt; garden; garden.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(rose)); garden.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(none)); garden[<span class="hljs-number"><span class="hljs-number">1</span></span>] = flower(<span class="hljs-string"><span class="hljs-string">"gladiolus"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(garden.begin(), garden.end(), [](object <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; element) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; element.to_string() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } );</code> </pre><br>  The implementation of the API class methods is obvious and proxies data manipulation methods.  The constructor of the ancestor does not create data and leaves a null pointer, the constructors of the heirs initialize the pointer of the ancestor with the heir of the data of the desired type. <br><br>  Now nothing prevents you from creating any new heir to the object class, asking it the logic to convert to a string and checking for the presence of a value.  For example, you can select the object class shoes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shoes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: shoes(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> price); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_null</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">discount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  The class shoes :: data is described by analogy with flower :: data.  However, now we can get a funny result when working with our garden with flowers from the previous example: <br><br><pre> <code class="cpp hljs">garden.push_back(shoes(<span class="hljs-number"><span class="hljs-number">100000000000L</span></span>L));</code> </pre><br>  So, you can leave in the garden shoes worth 100 billion Belarusian rubles.  Also, these shoes will unintentionally stumble upon picking up flowers, but we would have encountered the same problem in the initial approach with the interface to the base class.  If we meant that there should be only flowers in the garden, we would have done std :: vector.  Apparently, the author of the code decided to keep anything in his garden - from flowers and shoes to previously unknown rubbish, including an atomic reactor or the Egyptian pyramids, because now nothing prevents you from inheriting new classes from object. <br><br>  Welcome to the world of dynamic typing using ordinary C ++ classes with typical logic.  Although not!  Copying a class will only copy the link.  It's time to fix the last inconsistency with the logic of C ++ classes. <br><br><h4>  Copy when changing object </h4><br>  Our base object is the time to learn to do what the original interface did with the Clone method, that is, to copy the contents of the heir.  In this case, copying should be as gentle as possible and copy the data as late as possible.  This condition is the more critical, the larger the object and the more intense its copying, explicit or implicit.  Here we can use the principle of copying when changing the object data. <br><br>  Copying when changing, or copy-on-write (COW), in C ++ is implemented relatively simply, an example is the Qt library, where COW is used everywhere, including for strings (QString), which reduces the cost of copying these objects to the required minimum. <br><br>  The essence of the approach is as follows: <br><br><ul><li>  an object refers to data via an auxiliary type, like a pointer; </li><li>  object methods can be const and non-const, it is important to maintain the constancy of the method, due to the following points; </li><li>  when the object method is called, the call is proxied to the method call of the data class through the same auxiliary pointer type from the first item, for which two operators -&gt; are overloaded for this purpose, for better readability, const and non-const, respectively. </li></ul><br>  The constant overload option operator -&gt; simply calls the desired method directly on the data class, proxying the call to the outer class; <br>  The non-constant overload variant of operator -&gt; is a bit more interesting, it implies that the call changes the data.  Therefore, you need to make sure that we refer to our data that can be changed.  If the link to the data is not unique, that is, we have postponed the copying and refer to other people's data, then you need to copy your copy of the data and work with them by calling the desired method. <br><br><blockquote>  Copying when changing in C ++ is relatively easy to implement, through operator -&gt; overloading the encapsulated helper class.  It is important to overload both const and non-const operator overloads. </blockquote><br>  To be clear, let's get the most simplified version of this intermediate reference type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data_type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy_on_write</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: copy_on_write(data_type* data) : m_data(data) { } data_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data.get(); } data_type* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_data.unique()) m_data.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> data_type(*m_data)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data.get(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;data_type&gt; m_data; };</code> </pre><br>  In an amicable way, you need to secure this class for multi-threaded access, as well as from exceptions in the copying process, but, in principle, the class is simple enough to convey the basic idea of ‚Äã‚Äãimplementing COW in C ++.  It is also worth considering that in the copy constructor, the data class implies calling the virtual method for cloning data. <br><br>  Now all we have to do is change the data storage in the base object class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: copy_on_write&lt;data&gt; m_data; };</code> </pre><br>  Thus, we obtain the initialization of classes of heirs compatible with the base class, that is, in fact, dynamic typing.  In addition, we do not use pointers to an abstract class, we have the usual C ++ classes with constructors, destructors, copying and assigning, as simplified as possible to create their heirs.  The only complication is that proxy methods, which are reduced to m_data-&gt; method (arguments), turn out to be a plus, because besides the call itself, we have the ability to save diagnostic information, such as the stack trace, which will simplify our error tracking and exception generation with maintaining the call sequence up to method that generated the exception. <br><br>  In essence, we have obtained a hybrid of Pimpl and Double dispatch approaches for dynamic data typing, for which the type we get at the execution stage. <br><br><blockquote>  In fact, we got a hybrid of Pimpl and Double dispatch approaches for dynamic data typing. </blockquote><br><blockquote><h4>  Implement data class interface? </h4><br>  When implementing a data class, it is not necessary to duplicate all the methods of the external class, as is done with the Pimpl pattern.  The data class performs two main tasks: it hides the details of encapsulation in the implementation and provides access to the data in the implementation of the methods of the outer class.  It is quite enough to do get_ and set_ methods and some auxiliary functionality, and perform data processing directly in the methods of the outer class.  Thus we separate the implementation of the class and the details of the encapsulation. </blockquote><br><h4>  Using dynamic typing </h4><br>  So, let's say we have a remote function call protocol, as an option, this is a parameterization of the SQL query to the database.  We calculate the types of the arguments and the result at the execution stage if we make a general mechanism with providing the API to the end user, because it is not known in advance what the user wants to pass as arguments and which result types will be received from the remote side (sometimes it is not even known to the developer who writes on top of this API, because with a chain of calls, the arguments of the next call are often based on the results of the previous one). <br><br>  In such cases, when the base class is not only an interface for the heirs, but also a container for the data of the heir, we are able to describe any functionality that requires dynamic typing in terms of C ++ classes and objects. <br><br>  Consider an example SQL query.  The list of arguments for executing the query can be generated with the same Boost.Preprocessor for a function of an arbitrary number of arguments of type object. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  SQL-,  db::SqlQuery  db::SqlQuery query("select * from users as u where u.type = $(usertype) and u.registered &gt;= $(datetime) limit 10"); //    operator () db::SqlQueryResult result = query("admin", datetime::today()); //   std::for_each(result.begin(), result.end(), [](db::SqlQueryRow const&amp; row) { //    object login = row["login"]; if (login.is_null()) std::cout &lt;&lt; "not specified"; else std::cout &lt;&lt; row["login"]; //   if (row["status"] == "deleted") std::cout &lt;&lt; " (deleted)"; std::cout &lt;&lt; std::endl; } );</span></span></code> </pre><br>  As arguments db :: SqlQuery :: operator (), you can use an arbitrary set of object, in this case you need to define the template implicit type casting constructor for the general type object: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> value_type&gt; object(value_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; value); ... };</code> </pre><br>  In this case, we will need heirs from the object class of the type integer, boolean, floating, text, datetime, and others, whose data will be placed in the object when the object is initialized with the appropriate value.  In this case, the initialization of an object with an arbitrary type will be extensible and all that will be needed to set an object with the desired type is to write an appropriate specialization, like this for bool: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">boolean</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: boolean(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value) : object(value) { } ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; object::object(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value) : m_data(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> boolean::data(value)) { }</code> </pre><br>  The most important thing here is different, the result of the query is a table with data calculated on the remote side of the database at the time of execution.  However, we can safely bypass every line of the query result, getting an object of a completely specific type, and not some undereserialized data.  You can work with an object, it can overload comparison operations, you can, by analogy with the designer, make a template method for obtaining values ‚Äã‚Äãof a certain type, you can cast to a string, output to a stream.  The object of type object we have quite a container, which can be operated as an ordinary class object. <br><br>  Moreover, if you wish, you can add container logic to object and, in general, use one type for any value returned from the request.  That is, by overloading it with the begin (), end (), size (), and also operator [] methods: <br><br><pre> <code class="cpp hljs">object result = query(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>, datetime::today()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(result.begin(), result.end(), [](object <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; row) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(row.begin(), row.end(), [](object <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; cell) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; cell.to_string() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } );</code> </pre><br>  In principle, the idea can be modified to the point that you can use anything at all through the container and the base class object, but here you should not forget about common sense.  The idea of ‚Äã‚Äãstatic typing, which reveals errors at the compilation stage, is very good, and it is extremely unreasonable to abandon it wherever it is possible to use the typed dynamic imagination! <br><br><blockquote>  The idea of ‚Äã‚Äãstatic typing, which reveals errors at the compilation stage, is very good, and it is extremely unwise to refuse it everywhere! </blockquote><br>  However, dynamic typing is extremely useful in the very places for which it is intended - for values ‚Äã‚Äãwhose type is obtained dynamically, usually as a result of parsing the data stream.  Encapsulated in a base class, the interface for working with data of various types allows us to work with ordinary C ++ objects, creating and copying them with ordinary designers, and with an assignment operator, and copying can be made as deferred as possible (ideally forever) using the copy-on-write technique. <br><br>  At the same time, the base class is both an interface class for working with various data, and a container.  For convenience, you can define for the base class all the necessary operations: comparisons, indexing, mathematical and logical operations and operations with threads.  In general, you can implement the most readable and logical code, the most protected from errors of storing the pointer to the base class, copying and access from different streams.  This is especially useful if this API is developed for a wide range of tasks, when working with a set of types that are initially unknown, and the set of types can potentially expand. <br><br><blockquote><h4>  Dynamic typing is a responsibility! </h4><br>  You need to be extremely prudent when entering dynamic typing.  Remember that developers in scripting languages ‚Äã‚Äãoften envy the possibilities of C ++, C # and Java to check types before the algorithm is executed at the compilation stage.  Use the power of static typing, emulating the rejection of it only where it is justified!  As a rule, dynamic typing is needed to execute a generic API request to a remote server for serialized data (including a database request). </blockquote><br>  After deserialization already at the execution stage, a number of types can be obtained.  It is usually unjustified to refuse types obtained dynamically and to work with data serialized to text or byte stream, since data processing usually requires processing.  The convenience of parsing data and getting familiar C ++ types, working not with interface pointers, but with well-constructed classes of ordinary objects, is priceless. <br><br><h4>  New way </h4><br>  ,  ,    API  C++ ,  RPC-               .          ,       ,        .    ,         ,       .   copy-on-write        operator -&gt;  const  non-const ,    , , ,            .           ,      ,     ,       .          new ‚Äî    . <br><br> ,       ,   .         ,    , -  ,     .                         .        ,        Pimpl,        ,  . <br><br>    API,     C++.          ,             .        ,       ,           -   . <br><br>   API  ,        . ,  , ‚Äî     API,   . <br><br><img src="https://xakep.ru/wp-content/uploads/2014/10/cover_189_mid-326x420.jpg" alt="image"><br><br> <i>     #189. <br></i>  <i>Author: Vladimir <a href="http://habrahabr.ru/users/qualab/" class="user_link">Qualab</a> Kerimov, Lead C ++ Developer, Parallels</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/257891/">https://habr.com/ru/post/257891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257881/index.html">Analysis of accounts of one (not) reliable email-service</a></li>
<li><a href="../257883/index.html">Comparative analysis of HL7 and openEHR</a></li>
<li><a href="../257885/index.html">Courses on ethical hacking and penetration testing: updated program</a></li>
<li><a href="../257887/index.html">Python nightmares: the implicit `this`</a></li>
<li><a href="../257889/index.html">Fast cross-platform HTML5 application on Framework7</a></li>
<li><a href="../257893/index.html">Place and conquer! Use host new to optimize C ++ code.</a></li>
<li><a href="../257895/index.html">The sad story of forgotten characters. How not to go crazy when working with encodings in C ++</a></li>
<li><a href="../257897/index.html">That's the point, sailed! We learn to work with floating-point numbers and develop an alternative with fixed decimal precision.</a></li>
<li><a href="../257899/index.html">Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</a></li>
<li><a href="../257903/index.html">Introduction to functional programming in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>