<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go Way: how garbage collection accelerated</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go language in Twitch is used in many loaded systems. Simplicity, security, performance and readability make it a good tool for solving problems encou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go Way: how garbage collection accelerated</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://golang.org/">Go</a> language in <a href="https://www.twitch.tv/">Twitch is</a> used in many loaded systems.  Simplicity, security, performance and readability make it a good tool for solving problems encountered by services, such as video streaming and the correspondence service of millions of users. <br><br>  But this article is not another Go.  It is about how our use of this language pushes some of the boundaries of the current runtime implementation and how we react to the achievement of these borders. <br><br>  This is a story about how improving runtime from Go 1.4 to Go 1.6 gave us a 20-fold reduction in pauses when the garbage collector works, how we got another 10-fold reduction in pauses in Go 1.6 and how, passing our experience to the development team working over runtime Go, provided 10-fold acceleration in Go 1.7 without additional manual settings on our side. <br><a name="habracut"></a><br><h1>  The beginning of the saga of pauses for garbage collection </h1><br>  Our IRC-based chat system was first implemented on Go at the end of 2013.  It replaced the previous implementation in Python.  For its creation, pre-release versions of Go 1.2 were used, and the system was able to simultaneously serve up to 500,000 users from each physical host without any special tricks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When servicing each connection with a group of three gorutins (lightweight execution threads in Go), the program scrapped 1,500,000 gorutins per process.  And even with such a number of them, the only serious performance problem that we encountered in versions prior to Go 1.2 was the length of pauses for garbage collection.  The application stopped for tens of seconds each time the builder started, and this was unacceptable for our interactive chat service. <br><br>  Not only that each pause for garbage collection was very expensive, so the assembly was launched several times a minute.  We spent a lot of effort on reducing the number and size of allocated blocks of memory so that the collector runs less frequently.  For us, an increase in heap (heap) of only 50% every two minutes was a victory.  And although the pauses were less, they remained very long. <br><br>  After the release of Go 1.2, the pauses were reduced ‚Äújust‚Äù to a few seconds.  We distributed traffic across more processes, which made it possible to reduce the duration of pauses to a more comfortable value. <br><br>  Work on reducing memory allocation on our chat server continues to bring benefits even now, despite the development of Go, but splitting into several processes is a workaround for only certain versions of Go.  Such tricks do not stand the test of time, but are important for the solution of short-term tasks to ensure quality service.  And if we share with each other the experience of using workarounds, it will help to make improvements in runtime Go that will benefit the whole community, not just one program. <br><br>  Starting in Go 1.5 in August 2015, the Go garbage collector began to work mostly competitively and incrementally.  This means that almost all work is performed without a complete stop of the application.  In addition to the fact that the preparation and interruption phases are rather short, our program continues to work while the garbage collection process is already underway.  The transition to Go 1.5 instantly led to a 10-fold reduction in the pauses in our chat system: with a large load in the test environment, from two seconds to approximately 200 ms. <br><br><h1>  Go 1.5 - a new era of garbage collection </h1><br>  Although reducing the delay in Go 1.5 was in itself a holiday for us, the best feature of the new garbage collector was that it set the stage for further consistent improvements. <br><br>  Garbage collection in Go 1.5 still consists of two main phases: <br><br><ul><li>  Mark - first marked those memory areas that are still used; </li><li>  Sweep - all unused areas are prepared for reuse. </li></ul><br>  But each of these phases now consists of two stages: <br><br><ul><li>  Mark: <br><ul><li>  the application is suspended, waiting for the completion of the previous sweep-phase; </li><li>  then, simultaneously with the operation of the application, a search for used memory blocks is performed. </li></ul></li><li>  Sweep: <br><ul><li>  the application is paused again to interrupt the mark-phase; </li><li>  simultaneously with the operation of the application, unused memory is gradually being prepared for reuse. </li></ul></li></ul><br>  The <code>gctrace</code> runtime function allows you to display information on the results of each iteration of the garbage collection, including the duration of all phases.  For our chat server, it showed that most of the pause falls on the interruption of the mark phase, so we decided to focus our attention on this.  And although the Go development team responsible for runtime asked for bug reports from applications that have long pauses for garbage collection, we were slobs and kept it secret! <br><br>  Of course, we needed to collect more details about the work of the collector during pauses.  The basic packages in Go include a wonderful <a href="https://blog.golang.org/profiling-go-programs">user-level CPU profiler</a> , but for our task we used the perf tool from Linux.  While in the core, it allows you to get samples with higher frequency and visibility.  Monitoring kernel loops can help us debug slow system calls and make virtual memory management transparent. <br><br>  Below is a profile view of our chat server running Go 1.5.1.  <a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">The graph</a> (Flame Graph) is constructed using the <a href="https://github.com/brendangregg/FlameGraph">Brendan Gregg tool</a> .  Only those samples are included that have the <code>runtime.gcMark</code> function in the stack, in Go 1.5 approximating the time spent interrupting the mark-phase. <br><br><img src="https://habrastorage.org/files/126/8f3/2ff/1268f32fff1a496eb7bef1be847312cb.png"><br><br>  The peaks in the graph show an increase in the stack depth, and the width of each section reflects the CPU time.  On the colors and order on the X axis do not pay attention, they do not matter.  On the left side of the graph, we see that in almost each of the sample stacks, <code>runtime.gcMark</code> calls <code>runtime.parfordo</code> .  Having looked above, we notice that most of the time is taken by <code>runtime.markroot</code> <code>runtime.scang</code> , <code>runtime.scanobject</code> and <code>runtime.shrinkstack</code> . <br><br>  The <code>runtime.scang</code> function <code>runtime.scang</code> designed to rescan memory to help complete the mark-phase.  The essence of the interruption lies in ending the application‚Äôs memory scan, so this work is absolutely necessary.  It is better to figure out how to improve the performance of other functions. <br><br>  Go to <code>runtime.scanobject</code> .  This function has several tasks, but its execution during the interruption of the mark-phase in Go 1.5 is necessary for the implementation of finalizers (the function performed before the object is deleted by the garbage collector. - Note of the translator).  You may ask: ‚ÄúWhy does the program use so many finalizers that they significantly affect the duration of pauses during garbage collection?‚Äù In this case, the application is a chat server that processes messages from hundreds of thousands of users.  The main ‚Äúnetwork‚Äù packet in Go attaches a finalizer to each TCP connection to help manage the leaks of file descriptors.  And since each user gets their own TCP connection, this makes a small contribution to the duration of the interruption of the mark phase. <br><br>  It seemed to us that it was worthy of the Go team.  We wrote to the developers, and they really helped us with their tips on how to diagnose performance problems and how to highlight them in minimal test cases.  In Go 1.6, developers moved the scan of finalizers to the parallel mark-phase, which made it possible to reduce the pause in applications with a large number of TCP connections.  Many other improvements were made, as a result of the transition to Go 1.6, the pauses on our chat server were reduced by half compared to Go 1.5 - to 100 ms.  Progress! <br><br><h1>  Stack reduction </h1><br>  The approach to concurrency adopted in Go implies the cheapness of using a large number of Gorutin.  If an application that uses 10,000 OS threads can run slowly, for gorutin, that number is fine.  Unlike the traditional large fixed-size stacks, the gorutines start with a very small stack ‚Äî just 2 Kb ‚Äî that grows as needed.  At the beginning of a function call, Go checks whether the stack size is sufficient for the next call.  And if not, before continuing with the call, the stack of the gorutina <i>moves</i> to a larger memory area, overwriting pointers if necessary. <br><br>  Consequently, as the application runs, the gorutin stacks grow in order to fulfill the deepest challenges.  The task of the garbage collector is to return unused memory.  The function of the <code>runtime.shrinkstack</code> is responsible for moving the gorutin stacks to more suitable memory <code>runtime.shrinkstack</code> , which in Go 1.5 and 1.6 is performed during the interruption of the mark-phase, when the application pauses. <br><br><img src="https://habrastorage.org/files/354/dbb/3a3/354dbb3a3bb8403494c9fe4118ab3d03.png"><br><br>  This graph is recorded on pre-release version 1.6 dated October 2015.  <code>runtime.shrinkstack</code> takes about three-fourths of the samples.  If this function were performed while the application was running, we would get a serious reduction in pauses on our chat server and other similar applications. <br><br>  The Go runtime documentation explains how to disable stack reductions.  For our chat server, the loss of some part of the memory is a small fee for reducing pauses for garbage collection.  We did so by going to Go 1.6.  After turning off the stack reduction, the duration of the pauses was reduced to 30‚Äì70 ms, depending on the ‚Äúwind direction‚Äù. <br><br>  The structure and layout of our chat server almost did not change, but from multi-second pauses in Go 1.2 we reached 200 ms in Go 1.5, and then to 100 ms in Go 1.6.  In the end, most of the pauses were shorter than 70 ms, that is, we received an improvement of more than 30 times. <br><br>  But surely there should be potential for further improvement.  It's time to shoot the profile again! <br><br><h1>  Page fault'y ?! </h1><br>  Up to this point, the variation in the length of the pauses was small.  But now they began to vary widely (from 30 to 70 ms), without correlating with any <code>gctrace</code> results.  Here is a schedule of cycles during fairly long pauses of the interruption of the mark phase: <br><br><img src="https://habrastorage.org/files/477/1cb/e2e/4771cbe2eb59425698bbe3c1514780b3.png"><br><br>  When the garbage collector calls the <code>runtime.gcRemoveStackBarriers</code> , the system generates a page fault error, which causes the <code>page_fault</code> kernel function to be <code>page_fault</code> .  This reflects a wide "tower" to the right of the center of the graph.  Using page faults, the kernel distributes virtual memory pages (usually 4 KB in size) in physical memory.  Often, processes can accommodate huge amounts of virtual memory, which is converted to resident when the application is accessed only through page faults. <br><br>  The <code>runtime.gcRemoveStackBarriers</code> function converts the stack memory that the application recently accessed.  In fact, it is intended to remove stack barriers added some time before, at the beginning of the garbage collection cycle.  The system has enough memory available, it does not assign physical memory to some other, more active processes.  So why does access to it lead to errors? <br><br>  Hint may be hiding in our equipment.  For chat systems we use modern dual-processor servers.  Several memory banks are directly connected to each socket.  This configuration allows for non-uniform memory access (NUMA, Non-Uniform Memory Access).  When a thread (thread) is executed in socket core 0, it has faster access to the memory connected to this socket than to the rest of the memory.  The Linux kernel tries to reduce this difference by running threads on the kernel to which the memory they use is connected, and moving pages of physical memory ‚Äúcloser‚Äù to the corresponding threads. <br><br>  Given this scheme, let's take a closer look at the behavior of the <code>page_fault</code> kernel <code>page_fault</code> .  If you look at the call stack (above in the graph), you will see that the kernel calls <code>do_numa_page and migrate_misplaced_page</code> .  This means that the kernel moves the application's memory between banks of physical memory. <br><br>  The Linux kernel picked up the almost meaningless memory access patterns during the interruption of the mark-phase and because of them transfers memory pages that cost us dearly.  This behavior was very weak in the Go 1.5.1 chart, but when we noticed <code>runtime.gcRemoveStackBarriers</code> , it became much more noticeable. <br><br>  Here the benefits of profiling with perf are most clearly manifested.  This tool can show kernel stacks, while a user-level Go profiler would only show that Go functions are inexplicably slow.  Perf is much harder to use, it requires root access to view kernel stacks and in Go 1.5 and 1.6 it requires the use of a non-standard toolchain (GOEXPERIMENT = framepointer ./make.bash, in Go 1.7 will be standard).  But solving the problems described is worth the effort. <br><br><h1>  Migration Management </h1><br>  If using two sockets and two memory banks is difficult, let's reduce the number.  It is best to use the <code>taskset</code> command, which can force the application to work on the cores of only one socket.  As program threads access memory from a single socket, the kernel will transfer their data to the appropriate banks. <br><br><img src="https://habrastorage.org/files/ea5/0ce/82c/ea50ce82c235449692f026467f5a682d.png"><br><br>  After being tied to a single NUMA node, the duration of the interruption of the mark phase decreased to 10-15 ms.  Significant improvement compared to 200 ms in Go 1.5 or two seconds in Go 1.4.  The same result can be obtained without sacrificing half the server.  It is enough to set the process memory <code>MPOL_BIND</code> policy <code>set_mempolicy(2)</code> using <code>set_mempolicy(2)</code> or <code>mbind(2)</code> .  The profile shown was obtained on the pre-release version of Go 1.6 in October 2015.  The left side shows that execution of <code>runtime.freeStackSpans</code> takes a lot of time.  After this function has been moved to the garbage collection phase executed in parallel, it no longer affects the length of the pause.  Little can now be removed from the mark-phase interruption stage! <br><br><h1>  Go 1.7 </h1><br>  Up to Go 1.6, we disabled the stack reduction feature.  This had a minimal impact on the use of memory by our chat server, but significantly increased operational complexity.  For some applications, stack reduction plays a very large role, so we turned off this feature very selectively.  In Go 1.7, the stack is now reduced right while the application is running.  So we got the best of both worlds: low memory consumption without special settings. <br><br>  Since the appearance of a concurrently running garbage collector in Go 1.5, the runtime tracks whether each gorutin has been executed since its last scan.  During the interruption of the mark-phase, gorutines that have recently been executed and are scanned are again detected.  In Go 1.7 runtime maintains a hotel short list of such gorutin.  This allows you to no longer search the entire list of gorutins when the code is paused, and greatly reduces the number of memory accesses that can trigger the memory migration in accordance with NUMA algorithms. <br><br>  Finally, AMD64 compilers by default support frame pointers, so standard debugging and performance tools like perf can define the current function call stack.  Users who build their applications using Go packages prepared for their platform can, if necessary, select more advanced tools without learning the rebuild toolchain and rebuild / redeploy their apps.  This promises a good future in terms of further improvements in the performance of basic packages and Go runtime, when engineers like me and you will be able to collect enough information for high-quality reports. <br><br>  In the pre-release version of Go 1.7 of June 2016, the pauses for garbage collection became even smaller, without any additional tweaks.  At our server they are ‚Äúout of the box‚Äù close to 1 ms - ten times less compared to the configured Go 1.6 configuration! <br><br>  Our experience has helped the Go development team find a permanent solution to the problems we have encountered.  For applications like ours, when going from Go 1.5 to 1.6, profiling and tuning allowed us to reduce pauses by a factor of ten.  But in Go 1.7, developers were able to achieve an already 100-fold difference compared to Go 1.5.  Hats off to their efforts to improve runtime performance. <br><br><h1>  What's next </h1><br>  All this analysis is devoted to the curse of our chat server - pauses in work, but this is only one measure of the performance of the garbage collector.  Having solved the pause problem, the Go developers can now tackle the bandwidth problem. <br><br>  According to the description of the transaction collector ( <a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit">Transaction Oriented Collector</a> ), it uses the approach of transparent low-cost allocation and assembly of memory, which is not shared by the gorutines.  This will postpone the need for a full-fledged launch of the collector and reduce the total number of CPU cycles per garbage collection. </div><p>Source: <a href="https://habr.com/ru/post/305614/">https://habr.com/ru/post/305614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305602/index.html">Two in one: USB host and composite USB device</a></li>
<li><a href="../305604/index.html">Self-learning chess program</a></li>
<li><a href="../305606/index.html">The final hackathon of the contest "BudgetApps"</a></li>
<li><a href="../305608/index.html">OSX / Keydnap malware used to steal credentials on Apple OS X</a></li>
<li><a href="../305610/index.html">Network Infrastructure Virtualization and SDN Solution</a></li>
<li><a href="../305616/index.html">Strange letters of the Russian alphabet</a></li>
<li><a href="../305618/index.html">Customer support research in e-commerce</a></li>
<li><a href="../305620/index.html">Microsoft fixes vulnerabilities in Windows</a></li>
<li><a href="../305624/index.html">Exchange freelance vs. working directly - a few facts from the Payoneer survey</a></li>
<li><a href="../305630/index.html">Is Yarovoi the victim? The first provider left Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>