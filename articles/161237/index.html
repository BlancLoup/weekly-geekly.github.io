<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Verifying that a point belongs to a nonconvex polygon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Verifying that a point belongs to a nonconvex polygon in linear time is not at all difficult. One of the most common methods is to fire a beam and cou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Verifying that a point belongs to a nonconvex polygon</h1><div class="post__text post__text-html js-mediator-article">  Verifying that a point belongs to a nonconvex polygon in linear time is not at all difficult.  One of the most common methods is to fire a beam and count the number of intersection points.  However, it is necessary to carefully consider the cases when the points of the polygon fall on the ray.  This naturally raises the question of how to deal with these cases the easiest way? <a name="habracut"></a><br><br><h4>  Task statement </h4><br>  We will solve a variant of the problem in which the vertices of the polygon and the point being checked are given by integer coordinates up to 10 <sup>8</sup> .  For the lack of simplicity, we will not impose any restrictions on the vertices of the polygon.  Solve the coinciding vertices, vertices on the sides, self-tilting and zero area.  We prohibit self-intersections, otherwise it is not possible to determine the inside of the resulting broken line.  The program should return 0 if the point lies on the border of the polygon, otherwise it is necessary to output 1 if the point lies outside the polygon and -1 if the point lies inside the polygon. <br><br><h4>  General solution scheme </h4><br>  Let <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , ..., <i>x</i> <sub><i>n</i></sub> be the vertices of a polygon (they can be given either in a counterclockwise direction), <i>y</i> is the point that we need to check.  If <i>n</i> = 1, then it suffices to check the equality of <i>y</i> and <i>x</i> <sub>1</sub> .  Otherwise, we calculate the expression <i>F</i> ( <i>y</i> ) = <i>f</i> ( <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , <i>y</i> ) ¬∑ <i>f</i> ( <i>x</i> <sub>2</sub> , <i>x</i> <sub>3</sub> , <i>y</i> ) ¬∑¬∑¬∑ <i>f</i> ( <i>x</i> <sub><i>n</i> -1</sub> , <i>x</i> <sub><i>n</i></sub> , <i>y</i> ) ¬∑ <i>f</i> ( <i>x</i> <sub><i>n</i></sub> , <i>x</i> <sub>1</sub> , <i>y</i> ).  The function <i>f</i> ( <i>a</i> , <i>b</i> , <i>c</i> ) takes the values ‚Äã‚Äã1, 0, -1.  It determines whether the ray intercepted from point <i>c</i> along the <i>x</i> axis in the direction of increasing <i>x</i> intersects the segment ( <i>a</i> , <i>b</i> ) taking into account all extreme cases.  If it crosses, it will return -1.  If point <i>c</i> lies on the segment ( <i>a</i> , <i>b</i> ) it returns 0, otherwise it will return 1. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/9bc/6a5/023/9bc6a5023b1f16b79e4d5a55454ea45d.png" alt="1 and -1 cases"><br><br><h4>  Optimize the function <i>f</i> </h4><br>  The entire complexity of checking whether a point belongs to a polygon is concentrated in the function <i>f</i> .  Therefore, I had the idea to sort through its implementation and find the shortest among them.  It is clear that the first step in the function <i>f</i> is the calculation of the coordinates <i>a</i> and <i>b</i> relative to the point <i>c</i> .  Put these coordinates in the local variables <code>ax</code> , <code>ay</code> , <code>bx</code> and <code>by</code> .  To check the implementations, I built all possible segments ( <i>a</i> , <i>b</i> ) with coordinates no more than 5 and found the right answers for them.  In addition, I restricted the expressions that can be used in <i>f</i> to <code>signum(ax * by - ay * bx)</code> , <code>signum(ax)</code> , <code>signum(bx)</code> , <code>signum(ay)</code> , <code>signum(by)</code> .  Thus, the function <i>f</i> should return a response based on the value of these 5 values, which can be -1, 0 or 1. <br>  In the beginning, I tried to express the answer as a sign of a linear combination of these quantities.  Unfortunately, nothing came of it.  The next idea is to use a chain of nested ifs.  As the complexity of the program, select the number of ifs + number of returns.  As if conditions, we solve expressions of the form <i>v</i> <sub><i>i</i></sub> in <i>S</i> , where <i>v</i> <sub><i>i</i></sub> is one of the 5 <code>signum</code> expressions above, and <i>S</i> is the subset {-1, 0, 1}. <br>  Now you can run brute force.  As an input, the enumeration function takes a set of allowed values ‚Äã‚Äãfor each of 5 variables and a set of test numbers that satisfy these conditions.  As a result, the brute force function produces a tree of functions with minimal complexity, which passes all tests.  To speed up the search, all results are memorized and not re-calculated. <br>  The number of options turned out to be small enough to complete a brute force program completion in a few seconds.  As a result, the program with complexity 27 turned out to be the optimal one. After I allowed to return expressions of the form <i>v</i> <sub><i>i</i></sub> and - <i>v</i> <sub><i>i</i></sub> besides constants, the complexity dropped to 18. This is still too much.  Careful study of the program allowed us to detect the xor-like structure when checking the <code>ax</code> and <code>bx</code> signs.  Therefore, I added the <code>signum(ax * bx)</code> variable <code>signum(ax * bx)</code> and the complexity dropped to 13. The experiment with the addition of the variable <code>signum(ay * by)</code> reduced the complexity to 11. The result was the following function: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point a, Point b, Point middle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ax = ax - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ay = ay - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bx = bx - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> by = by - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ay * by &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = Long.signum(ax * by - ay * bx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ax * bx &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ay &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  It turned out to be a little shorter in the number of lines and noticeably shorter in the number of characters of the initial version that was used to generate tests.  The short length of this program makes it easy to remember: <br><ol><li>  At the beginning, we check whether the segment ( <i>a</i> , <i>b</i> ) does not lie strictly on one side of the ray.  In this case, the intersection is not exactly. </li><li>  Check the degenerate case where point <i>c</i> lies on the line ( <i>a</i> , <i>b</i> ).  The answer zero can be avoided only if the points lie on one side of the <i>y-</i> axis.  If both of them lie on the <i>y</i> axis, then the case when <i>c</i> does not lie on the segment ( <i>a</i> , <i>b</i> ) has already been considered in the previous paragraph. </li><li>  Xor-like code to check the intersection of the beam with the segment.  The sign of <code>s</code> depends on which point is below the ray.  Here you can put a minus of <code>s</code> in either of two cases;  sign less, replace with more or less or equal. </li><li>  We return 1 to the case when one point lies on the ray, and the other is on some fixed side of it.  Such intersections are not counted, so as not to count one intersection two times if the vertex of the polygon hit the ray. </li></ol><br><br>  But this is not the limit!  In this implementation, <code>ay</code> is multiplied by <code>by</code> .  Why not get rid of multiplication by replacing it with something like <code>ay &lt; 0 ^ by &lt; 0</code> ?  As a result, the result is not exactly the same, but you can add this variable to the search and see what happens.  The next start of the algorithm ... and it gives a solution with complexity 9!  The new version looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point a, Point b, Point middle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ax = ax - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ay = ay - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bx = bx - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> by = by - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = Long.signum(ax * by - ay * bx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ay &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ^ by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -s; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ax * bx &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Long.signum(ay * by); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  It can be improved a little more.  After checking for <code>ay &lt; 0 ^ by &lt; 0</code> <code>Long.signum(ay * by)</code> value <code>Long.signum(ay * by)</code> cannot be -1.  Therefore, the last lines can be rewritten as: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point a, Point b, Point middle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ax = ax - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ay = ay - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bx = bx - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> by = by - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = Long.signum(ax * by - ay * bx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ay &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ^ by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -s; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (ay == <span class="hljs-number"><span class="hljs-number">0</span></span> || by == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ax * bx &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  In this version, the two top level if'a can be rearranged.  Measurements show that it gives a small gain in operating time on all tests: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point a, Point b, Point middle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ax = ax - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ay = ay - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bx = bx - middle.x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> by = by - middle.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = Long.signum(ax * by - ay * bx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (ay == <span class="hljs-number"><span class="hljs-number">0</span></span> || by == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; ax * bx &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ay &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ^ by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (by &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -s; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  In the new algorithm, again, there is a large number of degrees of freedom.  In the expression <code>ay &lt; 0 ^ by &lt; 0</code> , instead of the less sign, you can use the sign more or lax sign.  The minus sign of <code>s</code> again be put in either of two cases.  The <code>by</code> variable can be changed in the nested if'e to <code>ay</code> . <br>  The hardest thing in the new algorithm is to understand the case of zero.  It simultaneously checks two independent cases. <br><img src="http://habrastorage.org/storage2/294/8ea/60b/2948ea60b425525c8a1f1d4b12776d8d.png"><br>  In the first case, one of the points of the segment ( <i>a</i> , <i>b</i> ) coincides with the point <i>c</i> , in the second case the segment is parallel to the <i>x</i> axis and passes through the point <i>c</i> .  These checks can be performed in other ways, but the method above is the shortest. <br><br>  Testing for performance at worst shows that on a 32-bit JVM, check2 is faster than check3.  On a 64-bit JVM, the result is not clear.  However, the difference in both cases is quite small - 5-10%.  Attempts to replace <code>ax * bx &lt;= 0</code> inequalities for some reason do not give noticeable improvements in either the 32-bit or 64-bit versions of the java machine. <br><br>  Sources for those who want to experiment: <a href="">PolyCheck.zip</a> </div><p>Source: <a href="https://habr.com/ru/post/161237/">https://habr.com/ru/post/161237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161223/index.html">No life, populated by robots</a></li>
<li><a href="../161229/index.html">On the occasion of the anniversary of SMS, its creator gave an interview - via SMS</a></li>
<li><a href="../16123/index.html">File database</a></li>
<li><a href="../161231/index.html">You have 1 new MMS. With you 90 rubles!</a></li>
<li><a href="../161235/index.html">iTunes Store and iTunes Match earned in Russia and the CIS</a></li>
<li><a href="../161239/index.html">Wio about the Start Screen in Windows 8</a></li>
<li><a href="../16124/index.html">The wolf went crazy</a></li>
<li><a href="../161243/index.html">The iTunes Store is now in Russia - long live the ruble!</a></li>
<li><a href="../161245/index.html">ABBYY Labs. Q & A Project: Demonstration of Opportunities</a></li>
<li><a href="../161247/index.html">Google releases second version of Maps Android API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>