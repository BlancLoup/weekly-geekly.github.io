<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Faster fast or deep optimization Median filtering for Nvidia GPUs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 In the previous post, I tried to describe how easy it is to take advantage of the GPU for image processing. The fate was such that I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Faster fast or deep optimization Median filtering for Nvidia GPUs</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br><p>  In the previous <a href="https://habrahabr.ru/post/305964/">post,</a> I tried to describe how easy it is to take advantage of the GPU for image processing.  The fate was such that I turned up the opportunity to try to improve the median filtering for the GPU.  In this post I will try to tell you how you can get even more performance from the GPU in image processing, in particular, using the example of median filtering.  We will compare the GTX 780 ti GPU with <a href="https://sourceforge.net/projects/simd/">optimized code</a> running on a modern Intel Core i7 Skylake 4.0 GHz processor with a set of AVX2 vector registers.  The achieved filtration rate by 3x3 square at 51 GPixels / sec for the GTX 780Ti GPU and specific filtration rate by 3x3 square at 10.2 GPixels / sec per 1 TFlops for single accuracy at this time are <u>the highest among all known in the world</u> . </p><a name="habracut"></a><br><p>  For clarity of what is happening, it is strongly recommended to read the previous <a href="https://habrahabr.ru/post/305964/">post</a> , since this post will be tips, recommendations and approaches for improving the already written version.  To remind you what we are doing: </p><br><ol><li>  For each point of the original image, a certain neighborhood is taken (in our case, 3x3 / 5x5). </li><li>  The points of this neighborhood are sorted by increasing brightness. </li><li>  The average point of the sorted neighborhood is written to the final image. </li></ol><br><h1>  3x3 square median filter </h1><br><p>  One of the ways to optimize the image processing code on the GPU is to find and select repeated operations and make them only once inside one warp.  In some cases, you will need to change the algorithm slightly.  Looking at the filtering, you can see that by loading a 3x3 square around one pixel, neighboring threads do the same logical operations and the same load from memory: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">__global__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__launch_bounds__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> mFilter_33</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> H, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> W, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * __restrict in, unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = threadIdx.x + blockIdx.x * blockDim.x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idy = threadIdx.y + blockIdx.y * blockDim.y * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; unsigned a[<span class="hljs-number"><span class="hljs-number">9</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; W - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z3 = <span class="hljs-number"><span class="hljs-number">0</span></span>; z3 &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++z3) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shift = <span class="hljs-number"><span class="hljs-number">8</span></span> * (<span class="hljs-number"><span class="hljs-number">3</span></span> - z3); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; z2 &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++z2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; z1 &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++z1) a[<span class="hljs-number"><span class="hljs-number">3</span></span> * z2 + z1] |= in[(idy - <span class="hljs-number"><span class="hljs-number">1</span></span> + z2) * W + idx - <span class="hljs-number"><span class="hljs-number">1</span></span> + z1] &lt;&lt; shift; <span class="hljs-comment"><span class="hljs-comment">// &lt;-----   warp   // 6    12  //  idy += BL_Y; } /*    */ } }</span></span></code> </pre> <br><p>  A little thought, you can improve the sorting, doing the same operation only once.  For clarity, I will show what sorting was and what has become, and what is the benefit of this approach. <br>  In the previous post I used Batcher‚Äôs already invented incomplete sorting for 9 elements, which allows us to find the median without using conditional operators for the minimum number of operations.  Imagine this sorting in the form of iterations, each of which sorts independent elements, but there are dependencies between the iterations.  For each iteration selected pairs of items to sort. <br>  Old sorting: </p><br><img src="https://habrastorage.org/files/9d2/58c/a8f/9d258ca8f5b04b60a20b4f063ffa7dd7.jpg"><br><p>  New Sort: </p><br><img src="https://habrastorage.org/files/c6b/70d/a10/c6b70da10c15488bb33016f3a5f71bba.png"><br><p>  In appearance, both approaches can be said to be the same.  But let's look at it from the point of view of optimization by the number of operations and the ability to use the calculated values ‚Äã‚Äãby other threads.  You can load and sort the columns only once, make exchanges between threads and calculate the median.  Clearly it will look like this: </p><br><img src="https://habrastorage.org/files/b58/121/a61/b58121a610044b67b73c51d58633c363.png"><br><p>  This algorithm corresponds to the following core.  For exchanges, I decided not to use shared memory, but new operations __shfl, which allow exchanging values ‚Äã‚Äãwithin one warp without synchronization.  Thus, it is possible partially not to do repeated calculations. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">__global__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOUNDS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BL_X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2048</span></span></span></span><span class="hljs-function"><span class="hljs-params"> / BL_X)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mFilter_3x3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> H, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> W, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * __restrict in, unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     int idx = threadIdx.x + blockIdx.x * blockDim.x; //   ,     warp'          idx = idx - 2 * (idx / 32); //   4,      4   int idy = threadIdx.y + blockIdx.y * blockDim.y * 4 + 1; unsigned a[9]; unsigned RE[3]; //          bool bound = (idxW &gt; 0 &amp;&amp; idxW &lt; 31 &amp;&amp; idx &lt; W - 1); //     RE[0] = in[(idy - 1) * W + idx] | (in[(idy + 0) * W + idx] &lt;&lt; 8) | (in[(idy + 1) * W + idx] &lt;&lt; 16) | (in[(idy + 2) * W + idx] &lt;&lt; 24); RE[1] = in[(idy + 0) * W + idx] | (in[(idy + 1) * W + idx] &lt;&lt; 8) | (in[(idy + 2) * W + idx] &lt;&lt; 16) | (in[(idy + 3) * W + idx] &lt;&lt; 24); RE[2] = in[(idy + 1) * W + idx] | (in[(idy + 2) * W + idx] &lt;&lt; 8) | (in[(idy + 3) * W + idx] &lt;&lt; 16) | (in[(idy + 4) * W + idx] &lt;&lt; 24); Sort(RE[0], RE[1]); Sort(RE[1], RE[2]); Sort(RE[0], RE[1]); //   a[0] = __shfl_down(RE[0], 1); a[1] = RE[0]; a[2] = __shfl_up(RE[0], 1); a[3] = __shfl_down(RE[1], 1); a[4] = RE[1]; a[5] = __shfl_up(RE[1], 1); a[6] = __shfl_down(RE[2], 1); a[7] = RE[2]; a[8] = __shfl_up(RE[2], 1); //   a[2] = __vmaxu4(a[0], __vmaxu4(a[1], a[2])); //   Sort(a[3], a[4]); a[4] = __vmaxu4(__vminu4(a[4], a[5]), a[3]); //   a[6] = __vminu4(a[6], __vminu4(a[7], a[8])); //    Sort(a[2], a[4]); a[4] = __vmaxu4(__vminu4(a[4], a[6]), a[2]); //  ,       if (idy + 0 &lt; H - 1 &amp;&amp; bound) out[(idy) * W + idx] = a[4] &amp; 255; if (idy + 1 &lt; H - 1 &amp;&amp; bound) out[(idy + 1) * W + idx] = (a[4] &gt;&gt; 8) &amp; 255; if (idy + 2 &lt; H - 1 &amp;&amp; bound) out[(idy + 2) * W + idx] = (a[4] &gt;&gt; 16) &amp; 255; if (idy + 3 &lt; H - 1 &amp;&amp; bound) out[(idy + 3) * W + idx] = (a[4] &gt;&gt; 24) &amp; 255; }</span></span></code> </pre> <br><p>  The second optimization is connected with the fact that each thread can process not 4 points at once, but, for example, 2 sets of 4 points each or N sets of 4 points each.  This is necessary in order to maximize the load of the device, since it is not enough for a 3x3 filter of one set of 4 points. </p><br><p>  The third optimization that can still be done is to perform the substitution of the width and height of the image.  There are several arguments to this: </p><br><ol><li>  Typically, the size of the pictures have fixed values, for example, popular Full HD, Ultra HD, 720p.  You can simply have a set of precompiled kernels.  This optimization gives about 10-15% of performance. </li><li>  Since Cuda Toolkit 7.5, it is possible to perform dynamic compilation, which allows you to perform value substitution at runtime. </li></ol><br><p>  Fully optimized code will look like this.  Varying the number of points, you can get maximum performance.  In my case, the maximum performance was achieved with numP_char = 3, that is, three sets of 4 points or 12 points per thread. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">__global__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BOUNDS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BL_X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2048</span></span></span></span><span class="hljs-function"><span class="hljs-params"> / BL_X)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mFilter_3x3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * __restrict in, unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = threadIdx.x + blockIdx.x * blockDim.x; idx = idx - <span class="hljs-number"><span class="hljs-number">2</span></span> * (idx / <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idxW = threadIdx.x % <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idy = threadIdx.y + blockIdx.y * blockDim.y * (<span class="hljs-number"><span class="hljs-number">4</span></span> * numP_char) + <span class="hljs-number"><span class="hljs-number">1</span></span>; unsigned a[numP_char][<span class="hljs-number"><span class="hljs-number">9</span></span>]; unsigned RE[numP_char][<span class="hljs-number"><span class="hljs-number">3</span></span>]; bool bound = (idxW &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; idxW &lt; <span class="hljs-number"><span class="hljs-number">31</span></span> &amp;&amp; idx &lt; W - <span class="hljs-number"><span class="hljs-number">1</span></span>); #<span class="hljs-function"><span class="hljs-function">pragma unroll </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; z &lt; numP_char; ++z)</span></span></span><span class="hljs-function"> </span></span>{ RE[z][<span class="hljs-number"><span class="hljs-number">0</span></span>] = in[(idy - <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] | (in[(idy - <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (in[(idy - <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (in[(idy - <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>); RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>] = in[(idy + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] | (in[(idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (in[(idy + <span class="hljs-number"><span class="hljs-number">2</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (in[(idy + <span class="hljs-number"><span class="hljs-number">3</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>); RE[z][<span class="hljs-number"><span class="hljs-number">2</span></span>] = in[(idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] | (in[(idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (in[(idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (in[(idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>); Sort(RE[z][<span class="hljs-number"><span class="hljs-number">0</span></span>], RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>]); Sort(RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>], RE[z][<span class="hljs-number"><span class="hljs-number">2</span></span>]); Sort(RE[z][<span class="hljs-number"><span class="hljs-number">0</span></span>], RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>]); a[z][<span class="hljs-number"><span class="hljs-number">0</span></span>] = __shfl_down(RE[z][<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); a[z][<span class="hljs-number"><span class="hljs-number">1</span></span>] = RE[z][<span class="hljs-number"><span class="hljs-number">0</span></span>]; a[z][<span class="hljs-number"><span class="hljs-number">2</span></span>] = __shfl_up(RE[z][<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); a[z][<span class="hljs-number"><span class="hljs-number">3</span></span>] = __shfl_down(RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] = RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>]; a[z][<span class="hljs-number"><span class="hljs-number">5</span></span>] = __shfl_up(RE[z][<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); a[z][<span class="hljs-number"><span class="hljs-number">6</span></span>] = __shfl_down(RE[z][<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); a[z][<span class="hljs-number"><span class="hljs-number">7</span></span>] = RE[z][<span class="hljs-number"><span class="hljs-number">2</span></span>]; a[z][<span class="hljs-number"><span class="hljs-number">8</span></span>] = __shfl_up(RE[z][<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); a[z][<span class="hljs-number"><span class="hljs-number">2</span></span>] = __vmaxu4(a[z][<span class="hljs-number"><span class="hljs-number">0</span></span>], __vmaxu4(a[z][<span class="hljs-number"><span class="hljs-number">1</span></span>], a[z][<span class="hljs-number"><span class="hljs-number">2</span></span>])); Sort(a[z][<span class="hljs-number"><span class="hljs-number">3</span></span>], a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>]); a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] = __vmaxu4(__vminu4(a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>], a[z][<span class="hljs-number"><span class="hljs-number">5</span></span>]), a[z][<span class="hljs-number"><span class="hljs-number">3</span></span>]); a[z][<span class="hljs-number"><span class="hljs-number">6</span></span>] = __vminu4(a[z][<span class="hljs-number"><span class="hljs-number">6</span></span>], __vminu4(a[z][<span class="hljs-number"><span class="hljs-number">7</span></span>], a[z][<span class="hljs-number"><span class="hljs-number">8</span></span>])); Sort(a[z][<span class="hljs-number"><span class="hljs-number">2</span></span>], a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>]); a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] = __vmaxu4(__vminu4(a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>], a[z][<span class="hljs-number"><span class="hljs-number">6</span></span>]), a[z][<span class="hljs-number"><span class="hljs-number">2</span></span>]); } #<span class="hljs-function"><span class="hljs-function">pragma unroll </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; z &lt; numP_char; ++z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idy + z * <span class="hljs-number"><span class="hljs-number">4</span></span> &lt; H - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; bound) out[(idy + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] = a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span> &lt; H - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; bound) out[(idy + <span class="hljs-number"><span class="hljs-number">1</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] = (a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idy + <span class="hljs-number"><span class="hljs-number">2</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span> &lt; H - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; bound) out[(idy + <span class="hljs-number"><span class="hljs-number">2</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] = (a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idy + <span class="hljs-number"><span class="hljs-number">3</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span> &lt; H - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; bound) out[(idy + <span class="hljs-number"><span class="hljs-number">3</span></span> + z * <span class="hljs-number"><span class="hljs-number">4</span></span>) * W + idx] = (a[z][<span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>; } }</code> </pre> <br><h1>  Median filter 5x5 square </h1><br><p>  Unfortunately, I did not manage to come up with any other sorting for the 5x5 square.  The only thing you can save on is to load and combine 4 points in an unsigned int.  I don‚Äôt see any point in citing a longer code, since all the transformations can be done by analogy with a 3x3 square. <br>  <a href="http://rge.u-strasbg.fr/reunions/belfort140213/pdf/Perrot.pdf">This article</a> describes some ideas for combining operations for two squares with an overlay of 20 elements.  But the forgetful selection sort method proposed by the authors still does more operations than Batcher‚Äôs incomplete sorting network for 25 elements, even when combining two adjacent 5x5 squares. </p><br><h1>  Performance </h1><br><p>  Finally, I will give some figures that I was able to get throughout the entire optimization process. </p><br><table><tbody><tr><th></th><th colspan="3">  Runtime, ms </th><th colspan="3">  Acceleration </th></tr><tr><td></td><td>  Scalar CPU </td><td>  AVX2 CPU </td><td>  GPU </td><td>  Scalar / GPU </td><td>  AVX2 / GPU </td></tr><tr><td>  3x3 1920x1080 </td><td align="center">  22.9 </td><td align="center">  0.255 </td><td align="center">  0.044 (47.1 GP / s) </td><td align="center">  520 </td><td align="center">  5.8 </td></tr><tr><td>  3x3 4096x2160 </td><td align="center">  97.9 </td><td align="center">  1.33 </td><td align="center">  0.172 (51.4 GP / s) </td><td align="center">  569 </td><td align="center">  7.73 </td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>  5x5 1920x1080 </td><td align="center">  134.3 </td><td align="center">  1.47 </td><td align="center">  0.260 (7.9 gp / s) </td><td align="center">  516 </td><td align="center">  5.6 </td></tr><tr><td>  5x5 4096x2160 </td><td align="center">  569.2 </td><td align="center">  6.69 </td><td align="center">  1,000 (8.8 gp / s) </td><td align="center">  569 </td><td align="center">  6.69 </td></tr></tbody></table><br><h1>  Conclusion </h1><br><p>  In conclusion, I would like to note that among all the found articles and implementations of median filtering for the GPU, the <a href="http://rge.u-strasbg.fr/reunions/belfort140213/pdf/Perrot.pdf">article</a> already mentioned is of interest ‚ÄúFine-tuned high-speed implementation of a GPU-based median filter‚Äù, published in 2013.  In this article, the authors proposed a completely different approach to sorting, namely, the forgetful selection method.  The essence of this method is that we take roundUp (N / 2) + 1 elements, we pass from left to right and back, thus obtaining the minimum and maximum elements at the edges.  Next, we forget these elements, add one of the remaining elements to the end and repeat the process.  When there is nothing to add, we will get an array of 3 elements, from which it will be easy to choose the median.  One of the advantages of this approach is the reduced number of registers used, compared with the known sorting. </p><br><p>  The article states that the authors obtained a result of 1.8 GPixels / sec on the Tesla C2050.  The power of this card in single precision is estimated at 1 TFlops.  The power involved in testing the 780Ti is estimated at 5 TFlops.  Thus, the specific calculation speed per 1 TFlops of the algorithm proposed by me is approximately 5.5 times more for a 3x3 square and 2 times more for a 5x5 square than the one proposed by the authors of the article.  This comparison is not entirely correct, but closer to the truth.  Also in this article it was mentioned that at that time their implementation was the fastest of all known. </p><br><p>  The achieved acceleration compared with the AVX2 version averaged 6 times.  If you use new cards based on the Pascal architecture, this acceleration may increase at least 2 times, which will be approximately 100 GPixels / sec. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308214/">https://habr.com/ru/post/308214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308200/index.html">What is executable business processes. Introduction to the subject area</a></li>
<li><a href="../308204/index.html">Working with DB in CleverStyle Framework</a></li>
<li><a href="../308206/index.html">Open Day at Kaspersky Lab</a></li>
<li><a href="../308208/index.html">Container Management with LXD</a></li>
<li><a href="../308212/index.html">At the request of readers, check the LDAP server code ReOpenLDAP</a></li>
<li><a href="../308216/index.html">1C, Linux, Excel, Word, OpenXML, ADO and Net Core</a></li>
<li><a href="../308218/index.html">You dissect the corpse using SOLID</a></li>
<li><a href="../308220/index.html">2D magic in detail. Part Four. Water</a></li>
<li><a href="../308224/index.html">HPE Synergy Pro Part I - Intro</a></li>
<li><a href="../308226/index.html">Who are you, Professor Malan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>