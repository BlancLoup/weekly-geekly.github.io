<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fixed point calculations. Basic Principles (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction or why this topic 
 Reading Habrahabr , I came across two topics, "floating" calculations with a floating point. 
 In one of them, the ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fixed point calculations. Basic Principles (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction or why this topic </h4><br>  Reading <a href="http://habrahabr.ru/">Habrahabr</a> , I came across two topics, "floating" calculations with a floating point. <br>  In <a href="http://habrahabr.ru/blogs/cpp/112953/">one of them, the</a> extract from the IEEE754 standard and the main problems in floating point calculations are given in sufficient detail and qualitatively, the <a href="http://habrahabr.ru/blogs/programming/130272/">other</a> is a short topic-note about the fact that not everything is so good at calculations on a PC.  In this case, recommendations are made in the case when the mathematical accuracy of the result is important, use integer calculations, ‚Äúfix a comma‚Äù or at least check the results produced by the platform (compiler + processor). <br>  In spite of the fact that the advice is practical, it is not so easy to understand how to use integer calculations where previously there was a floating point, especially without mathematical preparation.  In this sense, the <a href="http://habrahabr.ru/blogs/gdev/123816/">attempt of one of the ‚Äúhabrovchan‚Äù to</a> understand the fixed-point method of experiments is quite entertaining. <br>  This topic is a brief introduction that should give an idea of ‚Äã‚Äãfixed-point calculations.  Mathematics in this article should not scare anyone - everything is very primitive.  Immediately I ask you to forgive: among my friends, the well-established expression is precisely ‚Äúfixed point‚Äù ( <i>from English, fixed-point</i> ), and not ‚Äúcomma‚Äù, so I will adhere to this particular term. <br><a name="habracut"></a><br><h4>  Once again about the mantissa and the exhibitor </h4><br>  In computational mathematics, fractional values ‚Äã‚Äãare in the form of a pair of integers <i>(n, e)</i> : mantissas and exponents (in Russian is more true of the "exponent", but for brevity and by habit I will continue to use the word "exponent").  The pair represents a fractional number in the form <i>n * 2 <sup>-e</sup></i> . <br>  Exhibitor can be considered as the number of digits before the comma separating the fractional part of the number. <br>  If the exponent is a variable written to the register and unknown when compiled, <i>(n, e)</i> is called a floating point number.  If the exponent is known in advance, <i>(n, e)</i> is called a fixed-point number.  Numbers with a fixed point can be written in ordinary integer variables (registers) by saving only the mantissa.  Exhibitor is usually denoted by the letter <i>q</i> .  So, having found something in the comment to the variable in the spirit of " <i>q15 multiplier</i> ", we should consider this variable as a number with a fixed point and an exponent of 15. However, I will return to the question of notation, which is found in various source codes and articles. <br><br><h4>  Calculations </h4><br>  So, we figured out that when working with a fixed point, the exhibitor is not recorded anywhere and is kept ‚Äúin mind‚Äù. <br>  How to make calculations?  Computational arithmetic is an entire science with its own formulas, axioms and theorems.  The purpose of this article was not to give an introduction to this science.  The approaches given below are primarily aimed at programmers who solve engineering and applied problems, i.e.  such, where the ranges of allowable values ‚Äã‚Äãand the necessary accuracy of calculations are known and limited. <br>  Another limitation of the article is that the algorithms for trigonometric and other complex operations are not given here.  To make their full review in one article is unrealistic (and hardly necessary).  The article provides the basis necessary for understanding such algorithms (and developing your own) ‚Äîthe rules for performing basic operations (addition / subtraction, multiplication, division) and the general fixed-point calculation method. <br><br><h5>  Addition and subtraction </h5><br>  Adding is simple if we imagine in our mind that we have to add two decimal fractions ‚Äúin a column‚Äù on a piece of paper.  When performing this operation, the numbers are written in a column so that the commas separating the fractional part are located one under the other.  In binary arithmetic, such an operation is called the reduction of exponentials. <br>  If you go from the "paper" to the mathematical record, you get the following: <br>  Suppose there are two numbers <i>a = n1 * 2 <sup>-q1</sup></i> and <i>b = n2 * 2 <sup>-q2</sup></i> . <br>  Then: <br>  <i>a + b = n1 * 2 <sup>-q1</sup> + n2 * 2 <sup>-q2</sup> = (n1 + n2 * 2 <sup>(q1 - q2)</sup> ) * 2 <sup>-q1</sup></i> . <br>  The factor <i>2 <sup>(q1 - q2)</sup></i> with the second term essentially means an arithmetic shift to bring numbers to one exponent. <br>  It should be noted that the result of the calculation can also shift to bring the exponent to the desired value. <br>  C code snippet: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a = <span class="hljs-number"><span class="hljs-number">0x1000</span></span>L; <span class="hljs-comment"><span class="hljs-comment">// q15: a = 0.125 int32_t b = 0x20000L; // q20: b = 0.125 int32_t c = 0; // q25 c = (a &lt;&lt; 5) + b; // q20: (a * 2 ^ (20 - 15) + b); c = 0x40000L (0.25  q20) c &lt;&lt;= 5; // q25: c = 0x800000L (0.25  q25)</span></span></code> </pre> <br>  From the example it can be understood that in real calculations, even in such a simple operation as addition, there is room for thought.  Always keep in mind the questions: <br><ul><li>  sacrifice accuracy or not?  One can in fact lead the terms to a smaller exponential shift to the right and discard the lower digits. </li><li>  are the values ‚Äã‚Äãof variables limited?  A shift to the right in this case, for example, does not lead to a loss of accuracy. </li><li>  Is there an opportunity to expand the bit depth? </li></ul><br>  This is not a complete list, but it already shows that everything is not as simple as it may seem at first glance.  In most practical applications for each subject area, ranges of acceptable values ‚Äã‚Äãare known or can be obtained, so that working with a fixed point requires some experience or research.  Often, pre-code is written with a floating point, after which the ranges of values ‚Äã‚Äãare examined, and small values ‚Äã‚Äãare neglected. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Multiplication </h5><br>  Fixed-point multiplication can be performed without tricky alignments and reduction to a single exponent.  Nevertheless, multiplication is a rather dangerous operation, which most often results in loss of accuracy and requires special care in handling. <br>  Let's start with a mathematical description of multiplication: <br>  Suppose there are two numbers <i>a = n1 * 2 <sup>-q1</sup></i> and <i>b = n2 * 2 <sup>-q2</sup></i> . <br>  Then: <br>  <i>a * b = n1 * 2 <sup>-q1</sup> * n2 * 2 <sup>-q2</sup> = n1 * n2 * 2 <sup><b>- (q2 + q1)</b></sup></i> . <br>  From the expression it can be seen that the exponential numbers when multiplied are added: <i>2 <sup><b>- (q2 + q1)</b></sup></i> .  The bit size of the data in this article is not considered until it suffices to remember that for safe multiplication without overflow and loss of accuracy, the bit depth of the result should be no less than the total bit depth of the factors. <br>  Due to the addition of the exponentials, the multiplication result has to be corrected to perform further calculations.  When decreasing the exponent, the lower digits of the result are discarded.  That is, there is a loss of accuracy.  You can reduce the loss of accuracy (and sometimes you have to), but ways to deal with losses are always associated with overhead. <br>  C code snippet: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>L; <span class="hljs-comment"><span class="hljs-comment">// q16: a = 0.5 int32_t b = 0x100000L; // q21: b = 0.5 int32_t c = 0xC0000L; // q20: c = 0.75 int64_t d; //      ,    . d = (int64_t)a * (int64_t)b; // q37 = q16 * q21; d = 0x800000000L (0.25 in q37) d &gt;&gt;= 17; // q37 / 2 ^ 17 = q20 c += (int32_t)d; // q20: c = 0x100000 (1 in q20)</span></span></code> </pre><br>  I note that the 15 least significant digits of the multiplication result were discarded in order to bring the number to the format of the addendum.  It was possible, of course, to increase the digit capacity of the variable <i>c</i> , but, as I said, in practice, the ranges of values ‚Äã‚Äãare usually limited and the lower multiples are often neglected.  In addition, the possibility of non-zero higher-order bits in the original factors is not taken into account. <br>  But in this article, overflow handling is not considered. <br><br><h5>  Division </h5><br>  Let's start with the mathematical expression for division: <br>  Suppose there are two numbers <i>a = n1 * 2 <sup>-q1</sup></i> and <i>b = n2 * 2 <sup>-q2</sup></i> . <br>  Then: <br>  <i>a / b = n1 * 2 <sup>-q1</sup> / (n2 * 2 <sup>-q2</sup> ) = n1 / n2 * 2 <sup><b>- (q1 - q2)</b></sup></i> . <br>  The multiplier <i>2 <sup><b>- (q1 - q2)</b></sup></i> means that when the division is performed, the exponent decreases automatically.  If no action is taken, some of the significant digits are discarded automatically. <br>  The correction method is obvious - it is necessary to increase the divider width in advance so that, as a result of the division, to obtain the desired number of significant bits: <br>  <i>a / b = n1 * 2 <sup>-q1</sup> <b>* 2 <sup>q3</sup></b> / (n2 * 2 <sup>-q2</sup> ) = n1 / n2 * 2 <sup><b>- (q1 - q2 + q3)</b></sup></i> . <br>  Thus, the quotient of the quotient is increased by <i>q3</i> rank. <br>  C code snippet: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a = <span class="hljs-number"><span class="hljs-number">0x4000</span></span>L; <span class="hljs-comment"><span class="hljs-comment">// q15: a = 0.5 int32_t b = 0x80000L; // q20: b = 0.5 int32_t c = 0; // q25 int64_t d; //      . d = (int64_t)a &lt;&lt; 30; // q45: d = 0x200000000000; (0.5 in q45) c = (int32_t)(d / (int64_t)b); // q25: c = 0x2000000; (1 in q25)</span></span></code> </pre><br>  Obviously, if the number of bits exceeds 32 bits, the problem cannot be solved so easily.  However, for simple engineering calculations, 32-bit numbers are usually more than enough. <br>  There is one simple way to significantly reduce the loss of accuracy when dividing - the preliminary rationing of the dividend.  Rationing is actually the maximum shift of the mantissa to the left, at which no significant bits are discarded.  You can determine by how much you can shift the number by counting the leading zeros in the dividend, for which there are special algorithms (or even processor hardware instructions). <br>  After dividing the quotient should be shifted to the right by the same number of bits to restore the exponent. <br>  The above code snippet may look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a = <span class="hljs-number"><span class="hljs-number">0x4000</span></span>L; <span class="hljs-comment"><span class="hljs-comment">// q15: a = 0.5 int32_t b = 0x80000L; // q20: b = 0.5 int32_t c = 0; // q25 int norm_shift = norm(a); //   . norm_shift = 16 c = ((a &lt;&lt; norm_shift) / b); // q(-5): c = 0x800 (1*2^norm in q(-5)) c &lt;&lt;= (30 - norm); // q25: c = 0x2000000; (1 in q25)</span></span></code> </pre><br>  As you can see, the loss of accuracy in this case did not happen without increasing the bit depth of the dividend. <br>  However, this is not always the case, and if you want to stay within a certain bit depth (for example, 32 bits), you have to implement the division algorithmically.  In a review article, it is hardly worth plunging into such a jungle - to understand the process of division and the difficulties associated with it, the description already given is sufficient. <br><br><h4>  Notation adopted in the literature and various sources </h4><br>  In the last section of the article I would like to once again return to the generally accepted notation used in the description of algorithms with a fixed point. <br>  This is quite an important point that you have to pay attention to when reading other people's sources. <br>  The most common are two options for designating a fixed-point number: <br><ol><li>  Q <i>M</i> - where <i>M</i> is the number of digits after the comma.  Used in article </li><li>  Q <i>N.M</i> - where <i>N</i> is the number of digits before the decimal point without taking into account the sign bit, and <i>M</i> - after. </li></ol><br>  The minus of the first notation is obvious: when working with a variable, you have to refer to the declaration of a variable (remember its bit depth) and perform some calculations in your head in order to figure out how to bring the exponent to the desired one.  Moreover, if we recall rounding <i>(int32_t) d</i> in the multiplication example, it can be noted that with comments in this notation, it is difficult to understand whether shifting or discarding significant bits will lead to an error. <br>  When using comments in the second notation, you can simply record the accuracy of the calculations, which eliminates the need to remember how the variable is declared. <br>  Let me explain with an example: <br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Q15 b = 0x8000; // Q15 int32_t c = a + b; // ???     ,      . a = 0x2000; // Q0.15 b = 0x8000; // Q16.15 c = a + b; // Q0.15 + Q16.15 = Q16.15: 16 + 15 = 31  + 1  </span></span></code> </pre><br>  Comments in the second notation are obviously more convenient. <br>  I will not argue here about the benefits of comments (they are far from everywhere), let me just say that for myself I always describe the types of variables when calculating, so as not to be mistaken and not be confused with bringing the exhibitors. <br>  If there are no comments in principle, reading and understanding the code is of course more complicated, but, confused, you can always add such decoding in Q-notation to understand where ‚Äúthis left shift by 4, and then the right shift by 10,‚Äù came from. <br>  I note that in the recently released <a href="http://www.google.com/">Google</a> source codes of the <a href="http://en.wikipedia.org/wiki/VoIP">VoIP</a> engine GIPS ( <a href="http://www.webrtc.org/">webrtc</a> ) in the comments most often just write Q, implying that all the bits of the number are allocated to the fractional part.  Personally, this is very confusing, because  you have to rummage through definitions to clarify how the code works. <br>  For myself, I use another notation that differs from the above and is close to the MATLAB toolbox for working with a fixed point.  It binds mathematics to the digit capacity of variables and simplifies life when it is necessary to evaluate the result of an operation (bitness and exponent). <br>  I note the numbers with a fixed point in my comments as <i>QN.M</i> , where <i>N</i> is the digit capacity of the number, <i>M</i> is the number of decimal places. <br>  Let me explain why I found such a scheme convenient for myself: <br><ol><li>  Knowing the digit capacity of a number it is always possible to predict the digit capacity of the result, i.e.  select a variable type sufficient to represent it. </li><li>  I am personally inconvenient for reading a record of the form <i>Q (-N) .M</i> , which appears in the second notation after performing the shift to the right and the lack of digits for the fractional part.  For example, the record for a 16-bit number, in which the exponent is 18 ( <i>n * 2 <sup>-18</sup></i> ), looks like <i>q16.18</i> for me, and for the second notation, <i>q (-3) .18</i> .  The entry in the first notation, as already mentioned, in any case makes it necessary to refer to the definition to understand the accuracy of the calculations, but in this case it is still not clear without a definition: whether the leading significant bits have already been dropped or not. </li><li>  Having made the calculations according to my notation, it is easier for me to see into the variable of what bitness the result will fit, and how to align the exponents.  For example, <i>q32.15 * q16.4 = q48.19</i> .  It is immediately obvious that for a complete presentation of the result you need 48-bit.  In the second notation, the record looks like <i>q16.15 * q11.4 = q27.19</i> , and you have to calculate that <i>27 + 19 = 47 + 1 digit from the first factor + 1 digit from the second = 48 bits</i> .  Trifle, but nice.  Especially when there are many source codes. </li></ol><br><h4>  On the pros and cons of using a fixed point </h4><br>  Such a detailed description, even for basic operations, can scare off engineers and programmers from using a fixed point in calculations, especially if they have already developed the habit of floating point without tracking the result.  However, there are advantages to using a fixed point, some of which are not obvious. <br>  In order to finally decide whether you need it, you can use the following summary of fixed-point calculations. <br>  <b>Pros:</b> <br><ul><li>  Need to think. </li><li>  Predictable result.  With the right approach to coding, the result of the calculations will be the same on any platform (processor + compiler) up to discharge.  For this phenomenon, there is a special term ‚Äú <i>bit-exactness</i> ‚Äù (from English, <i>bit-exactness</i> ).  A properly coded algorithm is always bit-stripped and, therefore, can be explored on a non-target platform.  This is especially useful when debugging on the target platform is difficult or impossible and you can only remove input data. </li><li>  Full control over the behavior of the code.  The fixed point eliminates the appearance of "surprises" associated with the implementation features of the floating point on the platform used. </li><li>  Automatic ‚Äúfiltering‚Äù of negligible values.  In a floating point, computation errors can accumulate, this does not happen at a fixed point (by discarding small values) or the error accumulation process can be controlled algorithmically. </li><li>  Algorithmically controlled range of variable values.  Floating comma gives more freedom in calculations, but the result can go beyond the limits of permissible, which leads to the need to control it separately.  At a fixed point, this problem is solved automatically during the development and debugging of the algorithm. </li><li>  Portability algorithms.  This plus is fairly correlated with the first, but it is worth noting that integer calculations are much better supported by many non-x86 processors than floating-point calculations.  So, having once developed an algorithm at a fixed point, it becomes much easier to port it to various ‚Äúweak‚Äù platforms.  Sometimes integer calculations are generally the only thing available on the target platform. </li><li>  Ability to control the complexity of calculations by reducing the accuracy in the development of the algorithm. </li><li>  Sometimes it's interesting. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  Need to think. </li><li>  A reduced (in the simplest case) range of values ‚Äã‚Äãof variables compared to a floating point. </li><li>  The need to algorithmically control the range of values ‚Äã‚Äãof variables.  Much of the development time is spent on correct scaling and selection of ranges. </li><li>  The need to monitor the bit at each stage of computation. </li><li>  The need to write your own framework of basic functions (trigonometric, logarithmic, etc.) or modify the existing one. </li><li>  The need to dive into the application area when developing an algorithm. </li><li>  The need to improve the culture of writing and maintaining code - one cannot do without using our own developments at a fixed point.  In a floating point, you can most often, without thinking, rewrite the math "head on", using ready-made functions. </li></ul><br><br><h4>  As a conclusion </h4><br>  I did not touch on such (basic!) Problems in calculations with a fixed point as overflow of the result and zero drift in rounding and methods of dealing with them.  The text has already turned out to be voluminous and, possibly, boring, in order to complement it with details. <br>  In my turn, I paid quite a lot of attention to the generally accepted notation when writing operations with a fixed point in order to facilitate reading the special literature and writing my own sources (and, possibly, understanding the second part of the article).  Yes, comments with calculations in Q-notation saved me from serious debugging and source code analysis more than once. <br>  If the topic will be in demand, I will add the article with the following part, in which I will describe the above points and try to tell you how, in general, you can transfer the algorithm from a floating point to a fixed one. <br>  NB Mathematicians, please do not worry, I think you are better acquainted with the illuminated question. <br><br><h4>  Links </h4><br><ul><li>  <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dai0033a/index.html">Fixed Point Arithmetic on ARM</a> </li><li>  <a href="http://www.ti.com/lit/wp/spry061/spry061.pdf">Comparing Fixed-and Floating-Point DSPs (SPRY061)</a> </li><li>  <a href="http://www.digitalsignallabs.com/fp.pdf">Fixed-Point Arithmetic: An Introduction - Digital Signal Labs</a> </li><li>  <a href="http://www.google.com/">Google</a> </li></ul><br><br><h4>  <b>UPDATES:</b> </h4><br><ul><li>  The notation that I use, as it turned out, came to me from MATLAB.  I still could not remember where I had dug it in due time.  Thanks <a href="https://habrahabr.ru/users/nerudo/" class="user_link">nerudo</a> , recalled.  The fixed-point toolbox of the specified package uses just a pair of ‚Äúnumber of bits‚Äù + ‚Äúnumber of bits per fractional part‚Äù to create objects, and with an explicit indication: a signed or unsigned number. </li><li>  Despite the fact that the examples abound in 8-, 16-, 32- and 64-bit words, I did not try to bind the description only to x86 and other General Purpose processors.  Simply, firstly, it is easier to give examples in C, and, secondly, I am far from being an expert on FPGA, ASIC, etc. (read VERILOG, etc.), which allow you to choose an arbitrary bit of a number in order to tell clearly about them .  Perhaps people more knowledgeable in the question will be able to supplement the article with their topics with examples. </li><li>  The notation descriptions do not say what to do with unsigned numbers.  In general, the original sources, in which I saw them, also say nothing about signs.  Basically it was assumed that all numbers are signed.  On the move, I cannot say how the authors saw the writing of signed numbers.  I will only note that in my / matlab notation I added the letter 'u' after Q to mark an unsigned number. </li></ul><br></div><p>Source: <a href="https://habr.com/ru/post/131171/">https://habr.com/ru/post/131171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131163/index.html">Advertising & Marketing Contest</a></li>
<li><a href="../131164/index.html">From bike to maven</a></li>
<li><a href="../131165/index.html">Shooting Full HD video is now possible on the Canon 50d</a></li>
<li><a href="../131166/index.html">Browser Pattern and Javascript Call Context</a></li>
<li><a href="../131167/index.html">Build Android project: exclude unnecessary files</a></li>
<li><a href="../131172/index.html">The head of RIM in Russia answered the questions Nomobile.ru and habraludey</a></li>
<li><a href="../131174/index.html">Ciklum Java Subbotnik in Minsk - as it were</a></li>
<li><a href="../131175/index.html">What to do if you are at risk of 38 billion (or less) for copyright infringement</a></li>
<li><a href="../131177/index.html">Dynamic cards, SMS driver and resource monetization</a></li>
<li><a href="../131179/index.html">Roundcube + hMailServer or own mail in a small organization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>