<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Little Brave Arkanoid (Part 3 - Box2D)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, as I promised, we will breathe life into our Arcanoid . Make the ball move, colliding with bricks, and bricks, at the same time, break. In prin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Little Brave Arkanoid (Part 3 - Box2D)</h1><div class="post__text post__text-html js-mediator-article">  Today, as I promised, we will breathe life into our <a href="http://habrahabr.ru/post/165667/">Arcanoid</a> .  Make the ball move, colliding with bricks, and bricks, at the same time, break.  In principle, the game physics in arcanoid is not so very complex and completely realizable on its own.  The only non-trivial moment in it is collision tracking.  But this is exactly what ‚Äúadult‚Äù physical engines are best at! <br><br>  So why not use them?  Moreover, if we design Box2D as a <a href="http://www.madewithmarmalade.com/">Marmalade</a> module, subsequently, we will be able to use it in other applications, possibly requiring more sophisticated ‚Äúphysics‚Äù.  Let's do it. <br><a name="habracut"></a><br>  The technique of designing Box2D in the form of a subproject is completely analogous to that used in relation to LibYAML in the previous <a href="http://habrahabr.ru/post/166357/">article</a> .  The only difference is that Box2D has much more source files.  Therefore, if there is no desire to repeat the routine rewriting of their names in the mkf-file, already done by me, you can take the finished module directly from <a href="https://github.com/GlukKazan/mf/tree/master/modules/box2d">GitHub</a> .  The Box2D distribution is taken <a href="http://code.google.com/p/box2d/downloads/detail%3Fname%3DBox2D_v2.2.1.zip%26can%3D2%26q%3D">from here</a> . <br><br>  So, add Box2D to our project: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">arcanoid.mkb</b> <div class="spoiler_text"><pre><code class="diff hljs">#!/usr/bin/env mkb options { module_path="../yaml" + module_path="../box2d" } subprojects { iwgl yaml + box2d } includepath { ./source/Main ./source/Model } files { [Main] (source/Main) Main.cpp Main.h Quads.cpp Quads.h Desktop.cpp Desktop.h IO.cpp IO.h [Model] (source/Model) Bricks.cpp Bricks.h Ball.cpp Ball.h Board.cpp Board.h } assets { (data) level.json }</code> </pre> <br></div></div><br>  ... and we are trying to compile all this, simultaneously making cosmetic corrections to Box2D from the discharge ‚Äúlet's make the compiler happy‚Äù: <br><br><div class="spoiler">  <b class="spoiler_title">Collision \ b2BroadPhase.h</b> <div class="spoiler_text"><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- for (int32 i = 0; i &lt; m_moveCount; ++i) + for (int32 j = 0; j &lt; m_moveCount; ++j) { - m_queryProxyId = m_moveBuffer[i]; + m_queryProxyId = m_moveBuffer[j]; ... } ... while (i &lt; m_pairCount) { ... }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common \ b2Math.h</b> <div class="spoiler_text"><pre> <code class="diff hljs">/// A 2D column vector. struct b2Vec2 { /// Default constructor does nothing (for performance). - b2Vec2() {} + b2Vec2(): x(0.0f), y(0.0f) {} /// Construct using coordinates. b2Vec2(float32 x, float32 y) : x(x), y(y) {} ... float32 x, y; };</code> </pre><br></div></div><br>  If after this you get a binding error: <br><br><img src="https://habrastorage.org/storage2/741/53c/8b5/74153c8b59ee0c47c609f49a78024c04.png"><br><br>  ... then it most likely means that you, like me, like MSVS 2003. GCC, at the same time, builds the project without errors, but we, of course, would like to be able to run it under the debugger too.  Anyway, MSVS 2003 will have to be abandoned.  In principle, it is enough to switch to MSVS 2005, but I immediately installed MSVS 2010, since it was at hand.  Switching itself is done using the Marmalade Configuration Utility. <br><br><img src="https://habrastorage.org/storage2/f65/35e/ac9/f6535eac9ab44019b4d1c888a1cbbe91.png"><br><br>  Well then, it's time to get down to business.  If in the first article we dealt with the ‚Äúworld of illusions‚Äù, in the second with the ‚Äúworld of ideas‚Äù, now it‚Äôs time to create a ‚Äúreal world‚Äù that we will be responsible for the physical interactions of objects.  Add new files to the project: <br><br><div class="spoiler">  <b class="spoiler_title">arcanoid.mkb</b> <div class="spoiler_text"><pre> <code class="diff hljs">#!/usr/bin/env mkb options { module_path="../yaml" module_path="../box2d" } subprojects { iwgl yaml box2d } includepath { ./source/Main ./source/Model } files { [Main] (source/Main) Main.cpp Main.h Quads.cpp Quads.h Desktop.cpp Desktop.h IO.cpp IO.h + World.cpp + World.h [Model] (source/Model) Bricks.cpp Bricks.h Ball.cpp Ball.h Board.cpp Board.h + IBox2DItem.h } assets { (data) level.json }</code> </pre><br></div></div><br>  The IBox2DItem interface will be responsible for sending events from Box2D to our data model.  For our purposes, so far only two methods are enough: <br><br><div class="spoiler">  <b class="spoiler_title">IBox2DItem.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _I_BOX2D_ITEM_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _I_BOX2D_ITEM_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Box2D.h&gt; class IBox2DItem { public: virtual void setXY(int X, int Y) {} virtual bool impact(b2Body* b) {return false;} }; #endif // _I_BOX2D_ITEM_H_</span></span></span></span></code> </pre><br></div></div><br>  Yes, I know that the interface should contain only abstract methods (originally it was), but then it turned out to be more convenient to have some default implementation, and the rename class was lazy.  In any case, this question is of no fundamental importance in the context of our article. <br><br>  The setXY method will allow us to transfer changes in the coordinates of moving objects (so that these changes can be displayed on the screen), and the impact method will allow us to track collisions of objects a little later. <br><br><div class="spoiler">  <b class="spoiler_title">World.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _WORLD_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _WORLD_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;Box2D.h&gt; #include "Desktop.h" #include "IBox2DItem.h" const int HALF_MARGIN = 10; const int V_ITERATIONS = 10; const int P_ITERATIONS = 10; const float FRICTION = 0.0f; const float RESTITUTION = 1.0f; const float DYN_DENSITY = 0.0f; const float R_INVIS = 0.0f; const float EPS = 1.0f; const float SPEED_SQ = 10.0f; using namespace std; class World { private: bool isStarted; int HandleX, HandleH, HandleW; uint64 timestamp; int width, height; b2World* wp; b2Body* ground; b2Body* ball; b2Body* handle; b2Body* createBox(int x, int y, int hw, int hh, IBox2DItem* userData = NULL); float32 getTimeStep(); void start(); public: World(): width(0), height(0), wp(NULL) {} void init(); void release(); void update(); void refresh(); b2Body* addBrick(int x, int y, int hw, int hh, IBox2DItem* userData) {return createBox(x, y, hw, hh, userData);} b2Body* addBall(int x, int y, int r, IBox2DItem* userData); b2Body* addHandle(int x, int y, int hw, int hh, IBox2DItem* userData); void moveHandle(int x, int y); typedef vector&lt;b2Body*&gt;::iterator BIter; }; extern World world; #endif // _WORLD_H_</span></span></span></span></code> </pre><br></div></div><br>  For this module, we consider the implementation in more detail: <br><br><div class="spoiler">  <b class="spoiler_title">World.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3e.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"World.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Ball.h"</span></span></span><span class="hljs-meta"> World world; void World::init() { isStarted = false; width = desktop.getWidth(); height = desktop.getHeight(); b2Vec2 gravity(0.0f, 0.0f); wp = new b2World(gravity); ground = createBox(width/2, -HALF_MARGIN, width/2, HALF_MARGIN); createBox(-HALF_MARGIN, height/2, HALF_MARGIN, height/2); createBox(width/2, height + HALF_MARGIN, width/2, HALF_MARGIN); createBox(width + HALF_MARGIN, height/2, HALF_MARGIN, height/2); ball = NULL; handle = NULL; } void World::release() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (wp != NULL) { delete wp; wp = NULL; ball = NULL; handle = NULL; } } ...</span></span></code> </pre><br></div></div><br>  Methods init and release are engaged in the correct creation and destruction of the main objects of the "world".  I draw attention to the fact that we set gravity to 0 (we will have weightlessness), and surround the playing field with four ‚Äúwalls‚Äù (one of them can then be easily removed). <br><br>  Next, we define methods for creating game objects: <br><br><div class="spoiler">  <b class="spoiler_title">World.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">... b2Body* World::createBox(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hw, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hh, IBox2DItem* userData) { b2BodyDef def; def.type = b2_staticBody; def.position.Set(x, y); b2Body* r = wp-&gt;CreateBody(&amp;def); b2PolygonShape box; box.SetAsBox(hw, hh); b2FixtureDef fd; fd.shape = &amp;box; fd.density = <span class="hljs-number"><span class="hljs-number">0</span></span>; fd.friction = FRICTION; fd.restitution = RESTITUTION; r-&gt;CreateFixture(&amp;fd); r-&gt;SetUserData(userData); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } b2Body* World::addBall(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r, IBox2DItem* userData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { wp-&gt;DestroyBody(ball); } b2BodyDef def; def.type = b2_dynamicBody; def.linearDamping = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; def.angularDamping = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; def.position.Set(x, y); ball = wp-&gt;CreateBody(&amp;def); b2CircleShape shape; shape.m_p.SetZero(); shape.m_radius = r + R_INVIS; b2FixtureDef fd; fd.shape = &amp;shape; fd.density = DYN_DENSITY; fd.friction = FRICTION; fd.restitution = RESTITUTION; ball-&gt;CreateFixture(&amp;fd); ball-&gt;SetBullet(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); ball-&gt;SetUserData(userData); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ball; } ...</code> </pre><br></div></div><br>  Here we create a rectangular object (wall or brick) and a ball.  In addition to the form they differ in type.  Bricks are static (fixed) objects, and the ball is dynamic.  Box2D requires dividing game objects into these two types, for performance reasons.  Also, we set such physical properties of objects as elasticity, friction coefficient, etc.  For convenience, they are defined by constants in the h-file. <br><br>  In our case, absolutely elastic collisions (RESTITUTION = 1) are modeled, in the absence of friction (FRICTION = 0).  We also set the linearDamping and angularDamping parameters to zero, which are responsible for the inhibition of a moving object by the ‚Äúenvironment‚Äù.  Initially, the idea was to expose a non-zero value of FRICTION so that there was an opportunity to ‚Äútwist‚Äù the ball with a racket, but it had to be abandoned.  When setting FRICTION to any non-zero value, the movement of the ball very quickly degenerates into a pure movement either vertically or horizontally. <br><br>  In userData for body and fixture, you can store any pointer.  We will store there a pointer to the IBox2DItem interface of the corresponding objects in our model. <br><br><div class="spoiler">  <b class="spoiler_title">World.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">... float32 World::getTimeStep() { uint64 t = s3eTimerGetMs(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(t - timestamp); timestamp = t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (float32)r / <span class="hljs-number"><span class="hljs-number">1000.0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::start() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ball-&gt;ApplyLinearImpulse(ball-&gt;GetWorldVector(b2Vec2(<span class="hljs-number"><span class="hljs-number">-10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>)), ball-&gt;GetWorldPoint(b2Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>))); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isStarted) { isStarted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; start(); timestamp = s3eTimerGetMs(); srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)timestamp); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { float32 timeStep = getTimeStep(); wp-&gt;Step(timeStep, V_ITERATIONS, P_ITERATIONS); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::refresh() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { b2Vec2 pos = ball-&gt;GetPosition(); Ball* b = (Ball*)ball-&gt;GetUserData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { b-&gt;setXY(pos.x, pos.y); } } }</code> </pre><br></div></div><br>  In the update method, we calculate the next iteration of the existence of the ‚Äúworld‚Äù by the Step method, in which three arguments are passed.  The first argument is the time interval for which the calculation is made.  In the <a href="http://tigrojop.ru/files/translate/box2d/box2d-manual-2.1.0-rus.html">Box2D</a> user manual it is recommended to use an interval of ~ 1/60 seconds.  Also, it is strongly recommended that it be constant.  The following two parameters determine the number of iterations when performing calculations and directly affect the quality of the simulation.  I pass the value 10 in both parameters. <br><br>  When you first call the update method, we give the ball the initial speed.  Since all the collisions are perfectly elastic, the speed of the ball after the collisions does not decrease and a single initial velocity is quite enough for us.  If necessary, we can adjust the speed between calls to the update method (in no case should we perform any manipulations with objects in the context of the b2World.Step call, this will most likely lead to immediate memory corruption). <br><br>  The task of the refresh method is to retrieve the modified coordinates of the ball (after the next calculation step) and transfer the changed coordinates to the IBox2DItem interface. <br><br>  We make the necessary changes to the model: <br><br><div class="spoiler">  <b class="spoiler_title">Bricks.h</b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _BRICKS_H_ #define _BRICKS_H_ #include "IwGL.h" #include "s3e.h" #include "Desktop.h" +#include "World.h" +#include "IBox2DItem.h" #define BRICK_COLOR_1 0xffffff00 #define BRICK_COLOR_2 0xff50ff00 #define BRICK_HALF_WIDTH 20 #define BRICK_HALF_HEIGHT 10 #include &lt;vector&gt; using namespace std; -class Bricks { +class Bricks: public IBox2DItem { private: struct SBrick { SBrick(int x, int y): x(x), y(y), + body(NULL), + isBroken(false), hw(BRICK_HALF_WIDTH), hh(BRICK_HALF_HEIGHT), ic(BRICK_COLOR_1), oc(BRICK_COLOR_2) {} SBrick(const SBrick&amp; p): x(px), y(py), + body(p.body), + isBroken(p.isBroken), hw(p.hw), hh(p.hh), ic(p.ic), oc(p.oc) {} int x, y, hw, hh, ic, oc; + int isBroken; + b2Body* body; }; vector&lt;SBrick&gt; bricks; public: Bricks(): bricks() {} + void init() {} + void release() {} void refresh(); void clear(){bricks.clear();} void add(SBrick&amp; b); typedef vector&lt;SBrick&gt;::iterator BIter; friend class Board; }; #endif // _BRICKS_H_</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bricks.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "Bricks.h" #include "Quads.h" void Bricks::refresh() { for (BIter p = bricks.begin(); p != bricks.end(); ++p) { + if (p-&gt;isBroken) continue; CIwGLPoint point(p-&gt;x, p-&gt;y); point = IwGLTransform(point); int16* quadPoints = quads.getQuadPoints(); uint32* quadCols = quads.getQuadCols(); if ((quadPoints == NULL) || (quadCols == NULL)) break; *quadPoints++ = point.x - p-&gt;hw; *quadPoints++ = point.y + p-&gt;hh; *quadCols++ = p-&gt;ic; *quadPoints++ = point.x + p-&gt;hw; *quadPoints++ = point.y + p-&gt;hh; *quadCols++ = p-&gt;oc; *quadPoints++ = point.x + p-&gt;hw; *quadPoints++ = point.y - p-&gt;hh; *quadCols++ = p-&gt;ic; *quadPoints++ = point.x - p-&gt;hw; *quadPoints++ = point.y - p-&gt;hh; *quadCols++ = p-&gt;oc; } } void Bricks::add(SBrick&amp; b) { + b.body = world.addBrick(bx, by, b.hw, b.hh, (IBox2DItem*)this); bricks.push_back(b); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ball.h</b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _BALL_H_ #define _BALL_H_ #include &lt;vector&gt; #include "IwGL.h" #include "s3e.h" #include "Desktop.h" +#include "World.h" +#include "IBox2DItem.h" #define MAX_SEGMENTS 7 #define BALL_COLOR_1 0x00000000 #define BALL_COLOR_2 0xffffffff #define BALL_RADIUS 15 using namespace std; -class Ball { +class Ball: public IBox2DItem { private: struct Offset { Offset(int dx, int dy): dx(dx), dy(dy) {} Offset(const Offset&amp; p): dx(p.dx), dy(p.dy) {} int dx, dy; }; vector&lt;Offset&gt; offsets; int x; int y; + b2Body* body; public: void init(); void release() {} void refresh(); virtual void setXY(int X, int Y); typedef vector&lt;Offset&gt;::iterator OIter; }; #endif // _BALL_H_</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ball.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "Ball.h" #include "Quads.h" #include "Desktop.h" #include &lt;math.h&gt; #define PI 3.14159265f void Ball::init(){ x = desktop.getWidth() / 2; y = desktop.getHeight()/ 2; float delta = PI / (float)MAX_SEGMENTS; float angle = delta / 2.0f; float r = (float)desktop.toRSize(BALL_RADIUS); for (int i = 0; i &lt; MAX_SEGMENTS; i++) { offsets.push_back(Offset((int16)(cos(angle) * r), (int16)(sin(angle) * r))); angle = angle + delta; offsets.push_back(Offset((int16)(cos(angle) * r), (int16)(sin(angle) * r))); angle = angle + delta; offsets.push_back(Offset((int16)(cos(angle) * r), (int16)(sin(angle) * r))); } + body = world.addBall(x, y, (int)r, (IBox2DItem*)this); } void Ball::setXY(int X, int Y) { x = X; y = Y; } void Ball::refresh() { CIwGLPoint point(x, y); point = IwGLTransform(point); OIter o = offsets.begin(); int r = desktop.toRSize(BALL_RADIUS); for (int i = 0; i &lt; MAX_SEGMENTS; i++) { int16* quadPoints = quads.getQuadPoints(); uint32* quadCols = quads.getQuadCols(); if ((quadPoints == NULL) || (quadCols == NULL)) break; *quadPoints++ = point.x + (r / 4); *quadPoints++ = point.y + (r / 4); *quadCols++ = BALL_COLOR_2; *quadPoints++ = point.x + o-&gt;dx; *quadPoints++ = point.y + o-&gt;dy; *quadCols++ = BALL_COLOR_1; o++; *quadPoints++ = point.x + o-&gt;dx; *quadPoints++ = point.y + o-&gt;dy; *quadCols++ = BALL_COLOR_1; o++; *quadPoints++ = point.x + o-&gt;dx; *quadPoints++ = point.y + o-&gt;dy; *quadCols++ = BALL_COLOR_1; o++; } }</code> </pre><br></div></div><br>  Here all changes are obvious.  Next, make changes to Main: <br><br><div class="spoiler">  <b class="spoiler_title">Main.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "Main.h" #include "s3e.h" #include "IwGL.h" #include "Desktop.h" +#include "World.h" #include "IO.h" #include "Quads.h" #include "Board.h" Board board; void init() { desktop.init(); io.init(); quads.init(); + world.init(); board.init(); } void release() { + world.release(); io.release(); desktop.release(); } int main() { init(); { while (!s3eDeviceCheckQuitRequest()) { io.update(); if (io.isKeyDown(s3eKeyAbsBSK) || io.isKeyDown(s3eKeyBack)) break; + world.update(); quads.update(); desktop.update(); board.update(); board.refresh(); + world.refresh(); quads.refresh(); io.refresh(); desktop.refresh(); } } release(); return 0; }</code> </pre><br></div></div><br>  Now the program can be launched for execution.  What do we see?  The ball is moving, but somehow very slowly.  Rebound after collisions are not observed.  Manipulations with initial speed do not change the apparent speed of the ball.  All this suggests that we are doing something wrong. <br><br>  Think about what it could be?  We set all dimensions on the scale of screen coordinates.  For myself, I usually consider the unit of measurement in Box2D to be 1 meter.  Even with a screen resolution of 320x480, it turns out that we are trying to simulate an arkanoid of some absolutely unimaginably epic dimensions (moreover, the simulated physics will depend on the size of the screen of the device, and this is completely useless).  In addition, Box2D does not perform very well calculations with objects of this size.  Usually, the recommended size of the world should not exceed tens of meters.  Make adjustments: <br><br><div class="spoiler">  <b class="spoiler_title">World.h</b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _WORLD_H_ #define _WORLD_H_ #include &lt;vector&gt; #include &lt;Box2D.h&gt; #include "Desktop.h" #include "IBox2DItem.h" +const float W_WIDTH = 10.0f; const int HALF_MARGIN = 10; const int V_ITERATIONS = 10; const int P_ITERATIONS = 10; const float FRICTION = 0.0f; const float RESTITUTION = 1.0f; const float DYN_DENSITY = 0.0f; const float R_INVIS = 0.0f; const float EPS = 1.0f; const float SPEED_SQ = 10.0f; using namespace std; class World { private: bool isStarted; int HandleX, HandleH, HandleW; uint64 timestamp; int width, height; b2World* wp; b2Body* ground; b2Body* ball; b2Body* handle; b2Body* createBox(int x, int y, int hw, int hh, IBox2DItem* userData = NULL); float32 getTimeStep(); void start(); + float toWorld(int x); + int fromWorld(float x); public: World(): width(0), height(0), wp(NULL) {} void init(); void release(); void update(); void refresh(); b2Body* addBrick(int x, int y, int hw, int hh, IBox2DItem* userData) {return createBox(x, y, hw, hh, userData);} b2Body* addBall(int x, int y, int r, IBox2DItem* userData); typedef vector&lt;b2Body*&gt;::iterator BIter; }; extern World world; #endif // _WORLD_H_</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">World.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "s3e.h" #include "World.h" #include "Ball.h" World world; void World::init() { isStarted = false; width = desktop.getWidth(); height = desktop.getHeight(); b2Vec2 gravity(0.0f, 0.0f); wp = new b2World(gravity); ground = createBox(width/2, -HALF_MARGIN, width/2, HALF_MARGIN); createBox(-HALF_MARGIN, height/2, HALF_MARGIN, height/2); createBox(width/2, height + HALF_MARGIN, width/2, HALF_MARGIN); createBox(width + HALF_MARGIN, height/2, HALF_MARGIN, height/2); ball = NULL; handle = NULL; } void World::release() { if (wp != NULL) { delete wp; wp = NULL; ball = NULL; handle = NULL; } } +float World::toWorld(int x) { + return ((float)x * W_WIDTH) / (float)desktop.getWidth(); +} +int World::fromWorld(float x) { + return (int)((x * (float)desktop.getWidth()) / W_WIDTH); +} b2Body* World::createBox(int x, int y, int hw, int hh, IBox2DItem* userData) { b2BodyDef def; def.type = b2_staticBody; - def.position.Set(x, y); + def.position.Set(toWorld(x), toWorld(y)); b2Body* r = wp-&gt;CreateBody(&amp;def); b2PolygonShape box; - box.SetAsBox(hw, hh); + box.SetAsBox(toWorld(hw), toWorld(hh)); b2FixtureDef fd; fd.shape = &amp;box; fd.density = 0; fd.friction = FRICTION; fd.restitution = RESTITUTION; r-&gt;CreateFixture(&amp;fd); r-&gt;SetUserData(userData); return r; } b2Body* World::addBall(int x, int y, int r, IBox2DItem* userData) { if (ball != NULL) { wp-&gt;DestroyBody(ball); } b2BodyDef def; def.type = b2_dynamicBody; def.linearDamping = 0.0f; def.angularDamping = 0.0f; - def.position.Set(x, y); + def.position.Set(toWorld(x), toWorld(y)); ball = wp-&gt;CreateBody(&amp;def); b2CircleShape shape; shape.m_p.SetZero(); - shape.m_radius = r + R_INVIS; + shape.m_radius = toWorld(r) + R_INVIS; b2FixtureDef fd; fd.shape = &amp;shape; fd.density = DYN_DENSITY; fd.friction = FRICTION; fd.restitution = RESTITUTION; ball-&gt;CreateFixture(&amp;fd); ball-&gt;SetBullet(true); ball-&gt;SetUserData(userData); return ball; } float32 World::getTimeStep() { uint64 t = s3eTimerGetMs(); int r = (int)(t - timestamp); timestamp = t; return (float32)r / 1000.0f; } void World::start() { if (ball != NULL) { ball-&gt;ApplyLinearImpulse(ball-&gt;GetWorldVector(b2Vec2(-10.0f, -10.0f)), ball-&gt;GetWorldPoint(b2Vec2(0.0f, 0.0f))); } } void World::update() { if (!isStarted) { isStarted = true; start(); timestamp = s3eTimerGetMs(); srand((unsigned int)timestamp); } else { float32 timeStep = getTimeStep(); wp-&gt;Step(timeStep, V_ITERATIONS, P_ITERATIONS); } } void World::refresh() { if (ball != NULL) { b2Vec2 pos = ball-&gt;GetPosition(); Ball* b = (Ball*)ball-&gt;GetUserData(); if (b != NULL) { - b-&gt;setXY(pos.x, pos.y); + b-&gt;setXY(fromWorld(pos.x), fromWorld(pos.y)); } } }</code> </pre><br></div></div><br>  Now, regardless of the size of the screen, the "width" of our world will be 10 (meters).  We start and make sure that the ball began to fly at normal speed and bounce off the walls.  Now, we will make the "bricks" disappear after the ball collides with them. <br><br><div class="spoiler">  <b class="spoiler_title">Bricks.h</b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _BRICKS_H_ #define _BRICKS_H_ #include "IwGL.h" #include "s3e.h" #include "Desktop.h" #include "World.h" #include "IBox2DItem.h" #define BRICK_COLOR_1 0xffffff00 #define BRICK_COLOR_2 0xff50ff00 #define BRICK_HALF_WIDTH 20 #define BRICK_HALF_HEIGHT 10 #include &lt;vector&gt; using namespace std; class Bricks: public IBox2DItem { private: struct SBrick { SBrick(int x, int y): x(x), y(y), body(NULL), isBroken(false), hw(BRICK_HALF_WIDTH), hh(BRICK_HALF_HEIGHT), ic(BRICK_COLOR_1), oc(BRICK_COLOR_2) {} SBrick(const SBrick&amp; p): x(px), y(py), body(p.body), isBroken(p.isBroken), hw(p.hw), hh(p.hh), ic(p.ic), oc(p.oc) {} int x, y, hw, hh, ic, oc; int isBroken; b2Body* body; }; vector&lt;SBrick&gt; bricks; + virtual bool impact(b2Body* b); public: Bricks(): bricks() {} void init() {} void release() {} void refresh(); void clear(){bricks.clear();} void add(SBrick&amp; b); typedef vector&lt;SBrick&gt;::iterator BIter; friend class Board; }; #endif // _BRICKS_H_</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bricks.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "Bricks.h" #include "Quads.h" void Bricks::refresh() { for (BIter p = bricks.begin(); p != bricks.end(); ++p) { if (p-&gt;isBroken) continue; CIwGLPoint point(p-&gt;x, p-&gt;y); point = IwGLTransform(point); int16* quadPoints = quads.getQuadPoints(); uint32* quadCols = quads.getQuadCols(); if ((quadPoints == NULL) || (quadCols == NULL)) break; *quadPoints++ = point.x - p-&gt;hw; *quadPoints++ = point.y + p-&gt;hh; *quadCols++ = p-&gt;ic; *quadPoints++ = point.x + p-&gt;hw; *quadPoints++ = point.y + p-&gt;hh; *quadCols++ = p-&gt;oc; *quadPoints++ = point.x + p-&gt;hw; *quadPoints++ = point.y - p-&gt;hh; *quadCols++ = p-&gt;ic; *quadPoints++ = point.x - p-&gt;hw; *quadPoints++ = point.y - p-&gt;hh; *quadCols++ = p-&gt;oc; } } +bool Bricks::impact(b2Body* b) { + for (BIter p = bricks.begin(); p != bricks.end(); ++p) { + if (p-&gt;body == b) { + p-&gt;isBroken = true; + return true; + } + } + return false; +} void Bricks::add(SBrick&amp; b) { b.body = world.addBrick(bx, by, b.hw, b.hh, (IBox2DItem*)this); bricks.push_back(b); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">World.h</b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _WORLD_H_ #define _WORLD_H_ #include &lt;vector&gt; #include &lt;Box2D.h&gt; #include "Desktop.h" #include "IBox2DItem.h" const float W_WIDTH = 10.0f; const int HALF_MARGIN = 10; const int V_ITERATIONS = 10; const int P_ITERATIONS = 10; const float FRICTION = 0.0f; const float RESTITUTION = 1.0f; const float DYN_DENSITY = 0.0f; const float R_INVIS = 0.0f; const float EPS = 1.0f; const float SPEED_SQ = 10.0f; using namespace std; -class World { +class World: public b2ContactListener { private: bool isStarted; int HandleX, HandleH, HandleW; uint64 timestamp; int width, height; b2World* wp; b2Body* ground; b2Body* ball; b2Body* handle; b2Body* createBox(int x, int y, int hw, int hh, IBox2DItem* userData = NULL); float32 getTimeStep(); + vector&lt;b2Body*&gt;* broken; void start(); + void impact(b2Body* b); + virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse); float toWorld(int x); int fromWorld(float x); public: World(): broken(), width(0), height(0), wp(NULL) {} void init(); void release(); void update(); void refresh(); b2Body* addBrick(int x, int y, int hw, int hh, IBox2DItem* userData) { return createBox(x, y, hw, hh, userData); } b2Body* addBall(int x, int y, int r, IBox2DItem* userData); + typedef vector&lt;b2Body*&gt;::iterator BIter; }; extern World world; #endif // _WORLD_H_</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">World.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "s3e.h" #include "World.h" #include "Ball.h" World world; void World::init() { + broken = new vector&lt;b2Body*&gt;(); isStarted = false; width = desktop.getWidth(); height = desktop.getHeight(); b2Vec2 gravity(0.0f, 0.0f); wp = new b2World(gravity); + wp-&gt;SetContactListener(this); ground = createBox(width/2, -HALF_MARGIN, width/2, HALF_MARGIN); createBox(-HALF_MARGIN, height/2, HALF_MARGIN, height/2); createBox(width/2, height + HALF_MARGIN, width/2, HALF_MARGIN); createBox(width + HALF_MARGIN, height/2, HALF_MARGIN, height/2); ball = NULL; handle = NULL; } void World::release() { if (wp != NULL) { delete wp; wp = NULL; ball = NULL; handle = NULL; } + delete broken; } float World::toWorld(int x) { return ((float)x * W_WIDTH) / (float)desktop.getWidth(); } int World::fromWorld(float x) { return (int)((x * (float)desktop.getWidth()) / W_WIDTH); } b2Body* World::createBox(int x, int y, int hw, int hh, IBox2DItem* userData) { b2BodyDef def; def.type = b2_staticBody; def.position.Set(toWorld(x), toWorld(y)); b2Body* r = wp-&gt;CreateBody(&amp;def); b2PolygonShape box; box.SetAsBox(toWorld(hw), toWorld(hh)); b2FixtureDef fd; fd.shape = &amp;box; fd.density = 0; fd.friction = FRICTION; fd.restitution = RESTITUTION; r-&gt;CreateFixture(&amp;fd); r-&gt;SetUserData(userData); return r; } b2Body* World::addBall(int x, int y, int r, IBox2DItem* userData) { if (ball != NULL) { wp-&gt;DestroyBody(ball); } b2BodyDef def; def.type = b2_dynamicBody; def.linearDamping = 0.0f; def.angularDamping = 0.0f; def.position.Set(toWorld(x), toWorld(y)); ball = wp-&gt;CreateBody(&amp;def); b2CircleShape shape; shape.m_p.SetZero(); shape.m_radius = toWorld(r) + R_INVIS; b2FixtureDef fd; fd.shape = &amp;shape; fd.density = DYN_DENSITY; fd.friction = FRICTION; fd.restitution = RESTITUTION; ball-&gt;CreateFixture(&amp;fd); ball-&gt;SetBullet(true); ball-&gt;SetUserData(userData); return ball; } float32 World::getTimeStep() { uint64 t = s3eTimerGetMs(); int r = (int)(t - timestamp); timestamp = t; return (float32)r / 1000.0f; } void World::start() { if (ball != NULL) { ball-&gt;ApplyLinearImpulse(ball-&gt;GetWorldVector(b2Vec2(-10.0f, -10.0f)), ball-&gt;GetWorldPoint(b2Vec2(0.0f, 0.0f))); } } +void World::impact(b2Body* b) { + IBox2DItem* it = (IBox2DItem*)b-&gt;GetUserData(); + if (it != NULL) { + if (it-&gt;impact(b)) { + for (BIter p = broken-&gt;begin(); p != broken-&gt;end(); ++p) { + if (*p == b) return; + } + broken-&gt;push_back(b); + } + } +} +void World::PostSolve(b2Contact* contact, const b2ContactImpulse* impulse) { + impact(contact-&gt;GetFixtureA()-&gt;GetBody()); + impact(contact-&gt;GetFixtureB()-&gt;GetBody()); +} void World::update() { if (!isStarted) { isStarted = true; start(); timestamp = s3eTimerGetMs(); srand((unsigned int)timestamp); } else { float32 timeStep = getTimeStep(); wp-&gt;Step(timeStep, V_ITERATIONS, P_ITERATIONS); } } void World::refresh() { + for (BIter p = broken-&gt;begin(); p != broken-&gt;end(); ++p) { + wp-&gt;DestroyBody(*p); + } + broken-&gt;clear(); if (ball != NULL) { b2Vec2 pos = ball-&gt;GetPosition(); Ball* b = (Ball*)ball-&gt;GetUserData(); if (b != NULL) { b-&gt;setXY(fromWorld(pos.x), fromWorld(pos.y)); } } }</code> </pre><br></div></div><br>  Here, as I said above, it is important not to try to delete an object when calculating the next iteration of b2World.Step (this is exactly what happens if you try to delete an object directly in PostSolve).  Also, do not assume that PostSolve will be called once.  It is quite possible that it will work, for example, twice for one ‚Äúbrick‚Äù.  If we add an object to a broken without first checking it, we will try to destroy it twice, which inevitably leads to memory destruction.  Since a large number of objects cannot accumulate in broken, we are quite happy with the performance of a linear search for an object in a vector. <br><br>  There are very few.  Add a racket.  Initially, I wanted to make the racket a dynamic object, limiting its vertical movement with PrismaticJoint.  To move it horizontally, it would be possible to temporarily create a MouseJoint.  But then, I decided that <a href="http://ru.wikipedia.org/wiki/KISS_%2528%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF%2529">it should be easier</a> . <br><br>  The fact is that the decision to make a racket a dynamic object is not very successful.  Box2D will have to keep track of the collision of dynamic objects all the time, and this task is so complicated that even Box2D does not cope with it very well.  Installing SetBullet helps, but there are cases when the ball will fly through the racket, which, of course, is completely unacceptable, in our case.  Therefore, the racket will be a static object.  We will simply destroy it between the steps of calculation and create it in a new place, if necessary.  Among other things, this method is much easier to implement. <br><br>  We make the necessary changes to the project: <br><br><div class="spoiler">  <b class="spoiler_title">arcanoid.mkb</b> <div class="spoiler_text"><pre> <code class="diff hljs">#!/usr/bin/env mkb options { module_path="../yaml" module_path="../box2d" } subprojects { iwgl yaml box2d } includepath { ./source/Main ./source/Model } files { [Main] (source/Main) Main.cpp Main.h Quads.cpp Quads.h Desktop.cpp Desktop.h IO.cpp IO.h + TouchPad.cpp + TouchPad.h [Model] (source/Model) Bricks.cpp Bricks.h Ball.cpp Ball.h Board.cpp Board.h + Handle.cpp + Handle.h } assets { (data) level.json }</code> </pre><br></div></div><br>  A slightly modified TouchPad module is taken <a href="http://www.drmop.com/index.php/2011/09/24/marmalade-sdk-tutorial-touch-and-multi-touch/">from here</a> : <br><br><div class="spoiler">  <b class="spoiler_title">TouchPad.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _TOUCHPAD_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _TOUCHPAD_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3ePointer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_TOUCHES 3 enum EMessageType { emtNothing = 0x00, emtTouchEvent = 0x10, emtTouchIdMask = 0x03, emtTouchMask = 0x78, emtMultiTouch = 0x14, emtTouchOut = 0x18, emtTouchDown = 0x30, emtTouchUp = 0x50, emtTouchOutUp = 0x58, emtTouchMove = 0x70, emtSingleTouchDown = 0x30, emtSingleTouchUp = 0x50, emtSingleTouchMove = 0x70, emtMultiTouchDown = 0x34, emtMultiTouchUp = 0x54, emtMultiTouchMove = 0x74 }; struct Touch { int x, y; bool isActive, isPressed, isMoved; int id; }; class TouchPad { private: bool IsAvailable; bool IsMultiTouch; Touch Touches[MAX_TOUCHES]; Touch* findTouch(int id); static void HandleMultiTouchButton(s3ePointerTouchEvent* event); static void HandleMultiTouchMotion(s3ePointerTouchMotionEvent* event); public: static bool isTouchDown(int eventCode); static bool isTouchUp(int eventCode); bool isAvailable() const { return IsAvailable; } bool isMultiTouch() const { return IsMultiTouch; } Touch* getTouchByID(int id); Touch* getTouch(int index) { return &amp;Touches[index]; } Touch* getTouchPressed(); int getTouchCount() const; bool init(); void release(); void update(); void clear(); }; extern TouchPad touchPad; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _TOUCHPAD_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">TouchPad.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TouchPad.h"</span></span></span><span class="hljs-meta"> TouchPad touchPad; bool TouchPad::isTouchDown(int eventCode) { return (eventCode &amp; emtTouchMask) == emtTouchDown; } bool TouchPad::isTouchUp(int eventCode) { return (eventCode &amp; emtTouchMask) == emtTouchUp; } void TouchPad::HandleMultiTouchButton(s3ePointerTouchEvent* event) { Touch* touch = touchPad.findTouch(event-&gt;m_TouchID); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch != NULL) { touch-&gt;isPressed = event-&gt;m_Pressed != 0; touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; touch-&gt;id = event-&gt;m_TouchID; } } void TouchPad::HandleMultiTouchMotion(s3ePointerTouchMotionEvent* event) { Touch* touch = touchPad.findTouch(event-&gt;m_TouchID); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch != NULL) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch-&gt;isActive) { touch-&gt;isMoved = true; } touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; } } void HandleSingleTouchButton(s3ePointerEvent* event) { Touch* touch = touchPad.getTouch(0); touch-&gt;isPressed = event-&gt;m_Pressed != 0; touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; touch-&gt;id = 0; } void HandleSingleTouchMotion(s3ePointerMotionEvent* event) { Touch* touch = touchPad.getTouch(0); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch-&gt;isActive) { touch-&gt;isMoved = true; } touch-&gt;isActive = true; touch-&gt;x = event-&gt;m_x; touch-&gt;y = event-&gt;m_y; } Touch* TouchPad::getTouchByID(int id) { for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].isActive &amp;&amp; Touches[i].id == id) return &amp;Touches[i]; } return NULL; } Touch* TouchPad::getTouchPressed() { for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].isPressed &amp;&amp; Touches[i].isActive) return &amp;Touches[i]; } return NULL; } Touch* TouchPad::findTouch(int id) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!IsAvailable) return NULL; for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].id == id) return &amp;Touches[i]; } for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!Touches[i].isActive) { Touches[i].id = id; return &amp;Touches[i]; } } return NULL; } int TouchPad::getTouchCount() const { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!IsAvailable) return 0; int r = 0; for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Touches[i].isActive) { r++; } } return r; } void TouchPad::update() { for (int i = 0; i &lt; MAX_TOUCHES; i++) { Touches[i].isMoved = false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsAvailable) { s3ePointerUpdate(); } } void TouchPad::clear() { for (int i = 0; i &lt; MAX_TOUCHES; i++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!Touches[i].isPressed) { Touches[i].isActive = false; } Touches[i].isMoved = false; } } bool TouchPad::init() { IsAvailable = s3ePointerGetInt(S3E_POINTER_AVAILABLE) ? true : false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!IsAvailable) return false; for (int i = 0; i &lt; MAX_TOUCHES; i++) { Touches[i].isPressed = false; Touches[i].isActive = false; Touches[i].isMoved = false; Touches[i].id = 0; } IsMultiTouch = s3ePointerGetInt(S3E_POINTER_MULTI_TOUCH_AVAILABLE) ? true : false; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsMultiTouch) { s3ePointerRegister(S3E_POINTER_TOUCH_EVENT, (s3eCallback)HandleMultiTouchButton, NULL); s3ePointerRegister(S3E_POINTER_TOUCH_MOTION_EVENT, (s3eCallback)HandleMultiTouchMotion, NULL); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { s3ePointerRegister(S3E_POINTER_BUTTON_EVENT, (s3eCallback)HandleSingleTouchButton, NULL); s3ePointerRegister(S3E_POINTER_MOTION_EVENT, (s3eCallback)HandleSingleTouchMotion, NULL); } return true; } void TouchPad::release() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsAvailable) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (IsMultiTouch) { s3ePointerUnRegister(S3E_POINTER_TOUCH_EVENT, (s3eCallback)HandleMultiTouchButton); s3ePointerUnRegister(S3E_POINTER_TOUCH_MOTION_EVENT, (s3eCallback)HandleMultiTouchMotion); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { s3ePointerUnRegister(S3E_POINTER_BUTTON_EVENT, (s3eCallback)HandleSingleTouchButton); s3ePointerUnRegister(S3E_POINTER_MOTION_EVENT, (s3eCallback)HandleSingleTouchMotion); } } }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _IO_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IO_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TouchPad.h"</span></span></span><span class="hljs-meta"> class IO { private: bool KeysAvailable; public: void init(); void release(); void update(); void refresh(); bool isKeyDown(s3eKey key) const; }; extern IO io; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _IO_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3e.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IO.h"</span></span></span><span class="hljs-meta"> IO io; void IO::init() { touchPad.init(); } void IO::release() { touchPad.release(); } void IO::update() { touchPad.update(); s3eKeyboardUpdate(); } void IO::refresh() { touchPad.clear(); } bool IO::isKeyDown(s3eKey key) const { return (s3eKeyboardGetState(key) &amp; S3E_KEY_STATE_DOWN) == S3E_KEY_STATE_DOWN; }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now, add the module Handle: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Handle.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _HANDLE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _HANDLE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IwGL.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s3e.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Desktop.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"World.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IBox2DItem.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HANDLE_COLOR 0xffff3000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HANDLE_H_WIDTH 40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HANDLE_H_HEIGHT 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HANDLE_H_POS 50 class Handle: public IBox2DItem { private: int x; int y; int touchId; public: void init(); void release() {} void refresh(); void update(); virtual void setXY(int X, int Y); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// _HANDLE_H_</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Handle.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Handle.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Quads.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TouchPad.h"</span></span></span><span class="hljs-meta"> void Handle::init() { x = desktop.getWidth() / 2; y = desktop.getHeight(); touchId = -1; } void Handle::setXY(int X, int Y) { x = X; y = Y; } void Handle::refresh() { CIwGLPoint point(x, y); point = IwGLTransform(point); int16* quadPoints = quads.getQuadPoints(); uint32* quadCols = quads.getQuadCols(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((quadPoints == NULL) || (quadCols == NULL)) return; *quadPoints++ = point.x - desktop.toRSize(HANDLE_H_WIDTH); *quadPoints++ = point.y + desktop.toRSize(HANDLE_H_HEIGHT); *quadCols++ = HANDLE_COLOR; *quadPoints++ = point.x + desktop.toRSize(HANDLE_H_WIDTH); *quadPoints++ = point.y + desktop.toRSize(HANDLE_H_HEIGHT); *quadCols++ = HANDLE_COLOR; *quadPoints++ = point.x + desktop.toRSize(HANDLE_H_WIDTH); *quadPoints++ = point.y - desktop.toRSize(HANDLE_H_HEIGHT); *quadCols++ = HANDLE_COLOR; *quadPoints++ = point.x - desktop.toRSize(HANDLE_H_WIDTH); *quadPoints++ = point.y - desktop.toRSize(HANDLE_H_HEIGHT); *quadCols++ = HANDLE_COLOR; world.addHandle(x, y, desktop.toRSize(HANDLE_H_WIDTH), desktop.toRSize(HANDLE_H_HEIGHT), (IBox2DItem*)this); } void Handle::update() { Touch* t = NULL; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touchId &gt; 0) { t = touchPad.getTouchByID(touchId); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { t = touchPad.getTouchPressed(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (t != NULL) { touchId = t-&gt;id; world.moveHandle(t-&gt;x, t-&gt;y); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { touchId = -1; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And make changes to the World and Board: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">World.h</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _WORLD_H_ #define _WORLD_H_ #include &lt;vector&gt; #include &lt;Box2D.h&gt; #include "Desktop.h" #include "IBox2DItem.h" const float W_WIDTH = 10.0f; const int HALF_MARGIN = 10; const int V_ITERATIONS = 10; const int P_ITERATIONS = 10; const float FRICTION = 0.0f; const float RESTITUTION = 1.0f; const float DYN_DENSITY = 0.0f; const float R_INVIS = 0.0f; const float EPS = 1.0f; const float SPEED_SQ = 10.0f; using namespace std; class World: public b2ContactListener { private: bool isStarted; + bool isHandleCreated; int HandleX, HandleH, HandleW; uint64 timestamp; int width, height; b2World* wp; b2Body* ground; b2Body* ball; b2Body* handle; b2Body* createBox(int x, int y, int hw, int hh, IBox2DItem* userData = NULL); float32 getTimeStep(); vector&lt;b2Body*&gt;* broken; void start(); void impact(b2Body* b); virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse); float toWorld(int x); int fromWorld(float x); public: World(): broken(), width(0), height(0), wp(NULL) {} void init(); void release(); void update(); void refresh(); b2Body* addBrick(int x, int y, int hw, int hh, IBox2DItem* userData) {return createBox(x, y, hw, hh, userData);} b2Body* addBall(int x, int y, int r, IBox2DItem* userData); + b2Body* addHandle(int x, int y, int hw, int hh, IBox2DItem* userData); + void moveHandle(int x, int y); typedef vector&lt;b2Body*&gt;::iterator BIter; }; extern World world; #endif // _WORLD_H_</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">World.cpp</b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "s3e.h" #include "World.h" #include "Ball.h" World world; void World::init() { broken = new vector&lt;b2Body*&gt;(); isStarted = false; width = desktop.getWidth(); height = desktop.getHeight(); b2Vec2 gravity(0.0f, 0.0f); wp = new b2World(gravity); wp-&gt;SetContactListener(this); ground = createBox(width/2, -HALF_MARGIN, width/2, HALF_MARGIN); createBox(-HALF_MARGIN, height/2, HALF_MARGIN, height/2); createBox(width/2, height + HALF_MARGIN, width/2, HALF_MARGIN); createBox(width + HALF_MARGIN, height/2, HALF_MARGIN, height/2); ball = NULL; handle = NULL; } void World::release() { if (wp != NULL) { delete wp; wp = NULL; ball = NULL; handle = NULL; } delete broken; } float World::toWorld(int x) { return ((float)x * W_WIDTH) / (float)desktop.getWidth(); } int World::fromWorld(float x) { return (int)((x * (float)desktop.getWidth()) / W_WIDTH); } b2Body* World::createBox(int x, int y, int hw, int hh, IBox2DItem* userData) { b2BodyDef def; def.type = b2_staticBody; def.position.Set(toWorld(x), toWorld(y)); b2Body* r = wp-&gt;CreateBody(&amp;def); b2PolygonShape box; box.SetAsBox(toWorld(hw), toWorld(hh)); b2FixtureDef fd; fd.shape = &amp;box; fd.density = 0; fd.friction = FRICTION; fd.restitution = RESTITUTION; r-&gt;CreateFixture(&amp;fd); r-&gt;SetUserData(userData); return r; } b2Body* World::addBall(int x, int y, int r, IBox2DItem* userData) { if (ball != NULL) { wp-&gt;DestroyBody(ball); } b2BodyDef def; def.type = b2_dynamicBody; def.linearDamping = 0.0f; def.angularDamping = 0.0f; def.position.Set(toWorld(x), toWorld(y)); ball = wp-&gt;CreateBody(&amp;def); b2CircleShape shape; shape.m_p.SetZero(); shape.m_radius = toWorld(r) + R_INVIS; b2FixtureDef fd; fd.shape = &amp;shape; fd.density = DYN_DENSITY; fd.friction = FRICTION; fd.restitution = RESTITUTION; ball-&gt;CreateFixture(&amp;fd); ball-&gt;SetBullet(true); ball-&gt;SetUserData(userData); return ball; } +b2Body* World::addHandle(int x, int y, int hw, int hh, IBox2DItem* userData) { + HandleW = hw; HandleH = hh; + if (handle != NULL) { + wp-&gt;DestroyBody(handle); + } + b2BodyDef def; + def.type = b2_staticBody; + def.position.Set(toWorld(x), toWorld(y)); + handle = wp-&gt;CreateBody(&amp;def); + b2PolygonShape box; + box.SetAsBox(toWorld(hw), toWorld(hh)); + b2FixtureDef fd; + fd.shape = &amp;box; + fd.density = DYN_DENSITY; + fd.friction = FRICTION; + fd.restitution = RESTITUTION; + handle-&gt;CreateFixture(&amp;fd); + handle-&gt;SetUserData(userData); + return handle; +} +void World::moveHandle(int x, int y) { + isHandleCreated = true; + HandleX = x; +} float32 World::getTimeStep() { uint64 t = s3eTimerGetMs(); int r = (int)(t - timestamp); timestamp = t; return (float32)r / 1000.0f; } void World::start() { if (ball != NULL) { ball-&gt;ApplyLinearImpulse(ball-&gt;GetWorldVector(b2Vec2(-10.0f, -10.0f)), ball-&gt;GetWorldPoint(b2Vec2(0.0f, 0.0f))); } } void World::impact(b2Body* b) { IBox2DItem* it = (IBox2DItem*)b-&gt;GetUserData(); if (it != NULL) { if (it-&gt;impact(b)) { for (BIter p = broken-&gt;begin(); p != broken-&gt;end(); ++p) { if (*p == b) return; } broken-&gt;push_back(b); } } } void World::PostSolve(b2Contact* contact, const b2ContactImpulse* impulse) { impact(contact-&gt;GetFixtureA()-&gt;GetBody()); impact(contact-&gt;GetFixtureB()-&gt;GetBody()); } void World::update() { if (!isStarted) { isStarted = true; start(); timestamp = s3eTimerGetMs(); srand((unsigned int)timestamp); } else { float32 timeStep = getTimeStep(); wp-&gt;Step(timeStep, V_ITERATIONS, P_ITERATIONS); } } void World::refresh() { for (BIter p = broken-&gt;begin(); p != broken-&gt;end(); ++p) { wp-&gt;DestroyBody(*p); } broken-&gt;clear(); + if (isHandleCreated) { + if (handle != NULL) { + int y = fromWorld(handle-&gt;GetPosition().y); + IBox2DItem* data = (IBox2DItem*)handle-&gt;GetUserData(); + if (HandleX &lt; HandleW) { + HandleX = HandleW; + } + if (HandleX &gt; desktop.getWidth() - HandleW) { + HandleX = desktop.getWidth() - HandleW; + } + handle = addHandle(HandleX, y, HandleW, HandleH, data); + b2Vec2 pos = handle-&gt;GetPosition(); + data-&gt;setXY(fromWorld(pos.x), fromWorld(pos.y)); + } + } if (ball != NULL) { b2Vec2 pos = ball-&gt;GetPosition(); Ball* b = (Ball*)ball-&gt;GetUserData(); if (b != NULL) { b-&gt;setXY(fromWorld(pos.x), fromWorld(pos.y)); } } }</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Board.h</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">#ifndef _BOARD_H_ #define _BOARD_H_ #include &lt;yaml.h&gt; #include &lt;vector&gt; #include &lt;String&gt; #include "Bricks.h" #include "Ball.h" +#include "Handle.h" #define MAX_NAME_SZ 100 using namespace std; enum EBrickMask { ebmX = 0x01, ebmY = 0x02, ebmComplete = 0x03, ebmWidth = 0x04, ebmHeight = 0x08, ebmIColor = 0x10, ebmOColor = 0x20 }; class Board { private: struct Type { Type(const char* s, const char* n, const char* v): s(s), n(n), v(v) {} Type(const Type&amp; p): s(ps), n(pn), v(pv) {} string s, n, v; }; Bricks bricks; Ball ball; + Handle handle; yaml_parser_t parser; yaml_event_t event; vector&lt;string&gt; scopes; vector&lt;Type&gt; types; char currName[MAX_NAME_SZ]; int brickMask; int brickX, brickY, brickW, brickH, brickIC, brickOC; bool isTypeScope; void load(); void clear(); void notify(); const char* getScopeName(); void setProperty(const char* scope, const char* name, const char* value); void closeTag(const char* scope); int fromNum(const char* s); public: Board(): scopes(), types() {} void init(); void release(); void refresh(); void update(); typedef vector&lt;string&gt;::iterator SIter; typedef vector&lt;Type&gt;::iterator TIter; }; #endif // _BOARD_H_</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Board.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">#include "Board.h" #include "Desktop.h" const char* BOARD_SCOPE = "board"; const char* LEVEL_SCOPE = "level"; const char* TYPE_SCOPE = "types"; const char* TYPE_PROPERTY = "type"; const char* WIDTH_PROPERTY = "width"; const char* HEIGHT_PROPERTY = "height"; const char* IC_PROPERTY = "inner_color"; const char* OC_PROPERTY = "outer_color"; const char* X_PROPERTY = "x"; const char* Y_PROPERTY = "y"; void Board::init() { ball.init(); bricks.init(); + handle.init(); load(); } void Board::release() { + handle.release(); bricks.release(); ball.release(); } ... void Board::refresh() { bricks.refresh(); ball.refresh(); + handle.refresh(); } +void Board::update() { + handle.update(); +}</code> </pre><br></div></div><br>  That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now, we have a working prototype of the Arcanoid game, which can be built for both Android and iPhone. </font></font><br></div><p>Source: <a href="https://habr.com/ru/post/166929/">https://habr.com/ru/post/166929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166917/index.html">Mobile development. Template Gallery</a></li>
<li><a href="../166919/index.html">Proxmox cluster storage. Part two. Launch</a></li>
<li><a href="../166921/index.html">Examples of working with Web Audio from the BBC</a></li>
<li><a href="../166923/index.html">How to know the color of borscht? Colorchuzer will help</a></li>
<li><a href="../166927/index.html">Late 70s Calculator - B3-18A Electronics</a></li>
<li><a href="../166931/index.html">What languages ‚Äã‚Äãto translate the project in the first place?</a></li>
<li><a href="../166933/index.html">Epson has introduced a 0.48-inch display with a resolution of 1024 * 768 pixels</a></li>
<li><a href="../166935/index.html">Integration of 1C: CRM and Asterisk using PHP-AGI and 1C web services</a></li>
<li><a href="../166939/index.html">Surprise from kernel32 for network resources (MS12-081, a detailed analysis of the vulnerability in the Microsoft File Handling Component)</a></li>
<li><a href="../166943/index.html">Dell Latitude 10: Tablet Replacing Laptop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>