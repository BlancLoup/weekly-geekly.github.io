<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to pass an elephant through the eye of a needle. Processing the maximum amount of data in the shortest time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What you will hear from apologists of the same Java or C # about development in C / C ++! Ostensibly this language is outdated and no one writes on it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to pass an elephant through the eye of a needle. Processing the maximum amount of data in the shortest time</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c03/c82/975/c03c82975acd44caa357b60e28f1db65.jpg"><br><br>  What you will hear from apologists of the same Java or C # about development in C / C ++!  Ostensibly this language is outdated and no one writes on it.  That's only when you need to create a no latency or low latency service, or you need to save memory and execution time of a bottleneck for processing large amounts of data, then you immediately resort to the help of ‚Äúarchaic‚Äù C / C ++ developers.  Just because these guys are able to manually manage the memory and are perfectly aware of the stuffing of this or that high-level operation.  Today our task is to get one step closer to these guys. <br><a name="habracut"></a><br><h4>  Under the hood of a race car </h4><br>  The business logic of a network application is usually not the place where they prefer to use C ++ as a development language.  As a rule, higher-level languages ‚Äã‚Äãare chosen for networking between application clients and database servers.  But sooner or later, the application grows to a level where it is cheaper to optimize it than to purchase new servers.  In this case, we will have a fascinating attraction of embedding the implementation of a part of business logic in C / C ++ into well-established logic in C #, Java, Python, Ruby or JavaScript.  Here you are probably waiting for the most amusing surprise: in C ++ you need to be able to handle large amounts of data efficiently.  Skills in Java or C # will quickly nullify all optimization attempts if you just try to write about the same C ++ code. <br><br>  The fact is that new should be used as economically as possible, and the irrational use of containers that are not quite suitable for the situation will make a perfectly logical code absolutely unsuitable in practice.  It is possible that after the ‚Äúoptimization‚Äù performed by an employee who is not fully qualified specifically in C ++, the execution time may remain approximately the same or even increase.  Someone will spread his hands, they say, tried, but everything is so optimized as much as possible.  Someone will try to convince colleagues of the incredible speed of a high-level language.  Our task is not to waste the money of the company.  So that the resources spent on embedding C / C ++ in critical parts of the code not only were not in vain, but paid for themselves many times over.  It‚Äôs not the specialists who shrug their hands and say ‚Äúwell, they could not,‚Äù but those who are trying to achieve the impossible.  After all, it only seems impossible, and nothing complicated in this lesson will be.  All that is required is to remember a few important things that will come in handy when processing data in C ++. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  We choose the tools carefully </h4><br>  If you have not yet had the luck to read Scott Meyers' excellent book, Effective Use of STL, I highly recommend it.  Without a detailed understanding of which situation a particular container is needed for in C ++, using STL would be akin to repairing asphalt in the rain.  I will give some basic advice, but it is important to thoroughly understand the purpose of different containers and the structure of their methods. <br><br>  The first thing to always remember: `std :: vector` is not an array, but a vector.  Use this container if you need exactly vectorization of a continuous piece of memory in the form of similar elements.  If regular addition and removal is required at an uncontrolled size, then `std :: vector` is hardly useful.  When you need an array with element-by-element access and an inexpensive increase in size, look better in the direction of `std :: deque`.  After all, if we don‚Äôt have enough reserved memory, it will first allocate a new continuous (!) Block, and then transfer data from the old memory of the `std :: vector` object to the new element-wise.  Since we consider the processing of large amounts of data in the shortest time, the redistribution of memory for already existing objects is not at all what you want to spend CPU time on. <br><br>  The second prerequisite is to carefully select a container with a unique key to value relationship.  In the case of big data, it's probably easiest to build `std :: unordered_map` right away and try to change it as little as possible.  The fact is that taking on a key in `std :: unordered_map` is much more efficient than in` std :: map`, again for large amounts of data you do not need to build and keep in memory a red-black tree with an exorbitant number of nodes.  But if the key-value ratio changes frequently (the relationships are removed, new ones are added, and this is done quite intensively), then it is easier to accept the maintenance of `std :: map` than to rebuild the internal representation of` std :: unordered_map`.  After all, inside `std :: unordered_map`, in fact, an array of chains of values, and the more often we change the key-value relationship, the less effective its use becomes.  Even faster key retrieval will not save here: rebuilding large arrays is always expensive. <br><br>  The third important point is logic.  First write the most efficient algorithm, and then see what is logically suitable for storing data when it is working.  Always try to choose a container in the only obvious way.  You need a set of unique values ‚Äã‚Äã- take `std :: set`, you need a dictionary that rarely changes - feel free to use` std :: unordered_map`, you need an array, and you don‚Äôt know its size in advance - you will most likely need `std :: deque`, if the array size is known in advance, then the usual `std :: vector` may come up. <br><br>  The fourth is performance measurements.  You should always check your decision about choosing a container or algorithm by benchmarking with testing runtime on similar containers.  Thus, it may be that the sorted `std :: vector` pairs of keys - the value may be more efficient in processing than the logically appropriate` std :: map`, built on this relationship. <br><br>  You can have any ideological views on the program code, but the only authority you should trust is the profiler, which provides measurements of the execution time of the code with different versions of its construction. <br><br><h4>  Text Costs </h4><br>  First and foremost, what should be learned when working with text: `std :: string` is not the only way to save and process text or part of it.  In the case of a substring, it is not necessary to make millions of new containers for each piece of a large string `std :: string`, it is enough to indicate the beginning and end of each substring.  It is better to have your own structure with a pair of begin / end iterators on the source line than for each substring to build a new continuous block of memory and copy into it a part of the text already stored in the source line. <br><br>  Example: we find all the words in the text represented as a pointer to a null-terminated string.  For simplicity, let our words be separated by a semicolon. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> word_type&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_words</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *text, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">deque</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;word_type&gt;&amp; result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *start = text; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *finish = text + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(text); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; finish) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* last = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(start, <span class="hljs-string"><span class="hljs-string">';'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!last) last = finish; result.push_back(word_type(start, last)); start = last + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br>  As a `word_type`, we will try both the standard` std :: string`, and our own type, which stores a pointer to the beginning and end of the substring in the original string. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">one_word</span></span></span><span class="hljs-class"> {</span></span> one_word(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *begin, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *end) : m_begin(begin), m_end(end) { } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *m_begin, *m_end; };</code> </pre><br>  As a result of simple comparative measurements, it turns out that if you do not spend time generating absolutely unnecessary intermediate lines in the `std :: string` containers, the code starts to run 15‚Äì20 times faster.  If the majority of words do not fit into the 16-char buffer that was originally reserved in `std :: string`, then in addition we have to dynamically allocate new blocks of memory to store substrings.  Our class `one_word` during initialization fills only two fields of the type pointer to a character, and this is enough to go through the spacing later. <br><br>  With a special disregard for any optimization, the Boost library suffers, so if you suddenly decide to use `boost :: split` or` boost :: regex`, remember this solution when the profiler shows the performance creep when parsing a string with massive implicit creation of all sorts of unnecessary rubbish . <br><br><h4>  JSON, XML and all-all </h4><br>  To work with text protocols should be approached as carefully as possible.  As the previous example shows, the slightest miscalculation when creating auxiliary objects can kill the performance with a code that is completely harmless at first glance. <br><br>  For each of the common protocols there is a whole bunch of libraries.  But you should remember simple truths. <br><br>  First and foremost.  You almost never need to build a full tree for the XML / JSON / YAML structure when reading it from anywhere.  Usually, it all comes down to extracting a series of similar values. <br><br>  Second: do not refrain from reinventing the wheel, if the task is critical in terms of performance, and the case you have is so private that abandoning the beaten path will be the right decision. <br><br>  Third: when serializing, <b>please</b> try to get by generating into a buffer on the stack.  If this is not possible, then write in `std :: string` with a reserve call in advance.  The code will never be effective if you first trash all the RAM using `std :: stringstream`, and then also collect a string from it, additionally sticking together what you can immediately assemble into a result. <br><br>  As a home task, compare in performance the generation of a large text configuration in the same XML with and without `std :: stringstream`.  RAM in the form of cheese with a bunch of holes of fragmentation does not have to speed. <br><br><h4>  The base will respond </h4><br>  When requesting a database, we do not know at the compilation stage what kind of value will come to us.  More precisely, we can build a query string, we can even wrap it in a simple SQL-like ORM on the C ++ side, but most importantly, at the compilation stage, we almost never know what the database says in response. <br><br>  In this regard, dynamically typed languages ‚Äã‚Äãwith attribute generation on the fly, such as Python, Ruby and JavaScript, have a distinct advantage over compiled languages ‚Äã‚Äãwith static typing. <br><br>  You can, of course, make all sorts of types like `IntField`,` FloatField` and other `* Field` with a common ancestor like` BaseField`, and then go through all the branches of the code, using references and pointers.  This will lead to the fragmentation of a single, in general, response from the database - it will turn out to be pushed into small memory cells. <br><br>  However, recalling the <a href="http://habrahabr.ru/company/xakep/blog/257891/">first</a> <a href="http://habrahabr.ru/company/xakep/blog/257893/">three</a> <a href="http://habrahabr.ru/company/xakep/blog/257895/">lessons of</a> our academy, we can easily bypass the limitations of the C ++ language and at the same time get a digestible API.  All that remains is to minimize the cost of dynamic memory allocation for each field in each record.  This is not so difficult to do. <br><br>  Classic DBMS, in response to a SQL query, give us table data, that is, we know the format of each record, even at the execution stage, and not at the compilation stage.  According to the record structure, we can initially allocate memory for all the data of all the fields in total.  In the future, the good old placement placement will help us break the field values ‚Äã‚Äãby the prepared memory cells.  It looks like this: <br><br><ol><li>  From the metadata of the query, we learn the data type of each field in the query results.  For each type on the database side, we have a similar type on the business logic side.  Scalar data is data with a fixed size, allocating memory for them means leaving space in the buffer, they don‚Äôt even need a constructor.  Slightly more complicated with data that allocates additional memory on the heap, such as `std :: string` for representing the type` text`.  However, `std :: string` itself has a certain size, so we can say that for any type of field in the database we know the type and size on the business logic side. </li><li>  Next, we simply add the sizes of the record field types and get the size of the data block for each record.  To allocate memory for the entire result of the query, we can allocate memory once for all fields.  It turns out that we climbed into the heap after the memory only once, immediately after reading the fields from the metadata of the query result.  The complexity of the operation is multiple to the number of fields as a result of the request: even if a thousand fields are requested, this is much easier than allocating memory for 1000 √ó * number of records as a result * for incomprehensible IField *. </li><li>  For the convenience of data processing, we still have to build a certain class field.  It will be a container with dynamically typed data from the <a href="http://habrahabr.ru/company/xakep/blog/257891/">first</a> <a href="http://habrahabr.ru/company/xakep/blog/257893/">two</a> lectures of the ‚ÄúC ++ Academy‚Äù.  In fact, each will be by value, but the type is optionally stored - it corresponds to the type as a result of a query in the corresponding data cell, or NULL. </li><li>  Since the vast majority of data types stored in the database are textual, it may make sense to inline small strings with a limited size on the database side not into `std :: string`, which will crawl into a heap, but directly into the` field` memory.  In this case, we will get a good optimization when allocating memory, but we will have to suffer with the implementation of the necessary methods, since the `char m_text [SIZE]` alone will not do anything, and the capabilities of the pure C on working with strings and memory are not adapted to work with database. </li><li>  Now the main thing: allocating memory for each type in the record, we create these fields using the `new (&lt;where&gt;) construction Type (&lt;parameters&gt;)`. </li></ol><br>  Here is how it should look in the implementation.  The main class is a field container that is dynamically typed from any type you use in the database.  If you only have scalar types, text data and NULL, you‚Äôll have something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> value_type&gt; field(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* address, value_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; value); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> value_type&gt; field&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (value_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; value); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> value_type&gt; <span class="hljs-function"><span class="hljs-function">value_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_null</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: data* m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class">:</span></span>:data {...}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> value_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data_holder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> field::data { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: data_holder(); <span class="hljs-comment"><span class="hljs-comment">// NULL data_holder(value_type const&amp; value); &lt;  &gt; private: value_type m_value; }; template &lt;typename value_type&gt; field::field(void* address, value_type const&amp; value) : m_data(new(address) data_holder(value)) { }</span></span></code> </pre><br>  If swapping and deleting fields are rare as a result of a query, then safely vectorize the memory for the entire block.  If you actively play tag data with the data inside the results, then your choice is an array of memory decks, where the memory for each cell is allocated separately.  In this case, the model from the <a href="http://habrahabr.ru/company/xakep/blog/257893/">second</a> lecture of the ‚ÄúC ++ Academy‚Äù is more suitable, where we store the memory for object implementation in the class data and initialize it via the 'placement new` inside the implementation, which in this case, on the one hand, will allow using the record as a full-fledged std :: deque` of homogeneous objects, and on the other, it limits the use of big data inside objects.  It will no longer be possible to inline lines into the memory of records, but it will be easy to play with the presence and order of fields, which is important for, for example, non-relational databases, or for proxy logic with additional processing of the results obtained from other business logic, which we do not directly influence. we can  Then the field type itself will look a bit different: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//     template &lt;typename value_type&gt; field(value_type const&amp; value); &lt;  &gt; private: data* m_data; uint8_t m_buffer[MAX_FIELD_SIZE]; };</span></span></code> </pre><br>  Now you understand the thoroughness with which I described the mechanisms of dynamic typing at the <a href="http://habrahabr.ru/company/xakep/blog/257891/">beginning</a> of the Academy course, and why in the second lesson we talked about saving memory when placing data of a previously unknown type inside a class. <br><br>  Whichever way you choose, a single block of memory for the entire record or even for the entire result of the query on the business logic side or flexible control of the field deck in each record will still be better than mass memory allocation for each field and working with them through pointers on the interfaces between which there will be a constant type conversion. <br><br><h4>  Quiet!  Recording! </h4><br>  In both cases, the recording class will work like this: <br><br><ol><li>  Initialization with some set of field information. </li><li>  Memory allocation by meta-information will occur only once. </li><li>  Then, in the cycle, the list of record fields is filled, with an offset from the total memory for each subsequent record field. </li><li>  If the information about the fields came immediately with the values, then immediately initialize the fields together with the values ‚Äã‚Äãdirectly to the desired address. </li></ol><br>  The implementation of the record will look slightly different depending on whether you have a monolithic data block for the entire record, or is it a set of interchangeable elements of the same type with dynamically typed content.  I will give an example of how the implementation of a record for a single memory block might look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: record(query_result <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; result, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row); <span class="hljs-comment"><span class="hljs-comment">//      field field [const]&amp; operator[](&lt;    int, char const*  std::string const&amp;&gt;) [const]; private: std::vector&lt;uint8_t&gt; m_buffer; std::vector&lt;field&gt; m_fields; }; record::record(query_result const&amp; result, size_t row) { size_t buffer_size = std::accumulate( result.types().begin(), result.types().end(), 0, [](size_t init, field::type type){ return init + type.size(); }); m_buffer.resize(buffer_size); m_fields.reserve(result.types().size()); for(size_t offset=0, index=0; index&lt;result.types().size(); ++index) { m_fields.push_back(field(offset,result[row][index])); offset += result.type_of(index).size(); } }</span></span></code> </pre><br>  If we use the maximum acceleration and use one block of memory for the entire result of the query, the write code will change slightly: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      record(void* address, query_result const&amp; result, size_t row); &lt;    &gt; private: std::vector&lt;field&gt; m_fields; &lt;     &gt; };</span></span></code> </pre><br><h4>  The most important optimization </h4><br>  It is important to remember that it is cool to lay out the fields from the query results by the presentation fields on the side of business logic, but very often it is not necessary.  If you need to directly generate JSON by the result of the client database API, then it is not necessary to create the darkness of `record` objects with a bunch of` field` objects in each.  Even if optimized, this action is superfluous.     ,      JSON, XML, YAML        . <br><br>                   ,  ,   ,    .         bool, ,    hello  ,       `[[¬´hello¬ª]]`,   true. <br><br>       ‚Äî      . <br><br><h4>    </h4><br> ,   , ‚Äî  C++,   ,      ,        ,    ‚Äî         .  Java, C#  Python       ,    C/C++,  ,        .           ,  ,  ,            .      `std::vector&lt;uint8_t&gt;`  ,  `uint8_t packet_buffer[MAX_PACKET_SIZE]`      . <br><br>  C++,   ,           ,    .         ,     .    ,     ,   ,  :      (  Java),     . <br><br>  C++      ,    ,    ,      .         `std::map` ‚Äî        `vector of vector`  `T**`.      `std::string`           . <br><br>  ‚Äî        ,       .    - ?    ,  ,      .      ! <br><br><img src="https://xakep.ru/wp-content/uploads/2015/04/cover_195_low-326x420.jpg" alt="image"><br><br> <i>     #195. <br> :  <a href="http://habrahabr.ru/users/qualab/" class="user_link">Qualab</a> ,  ++   Parallels</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/258961/">https://habr.com/ru/post/258961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258951/index.html">Cross-compiling Qt5 for Linux for Win x32 / x64 / static / shared</a></li>
<li><a href="../258953/index.html">Let unit-testing begin (Objective-C)</a></li>
<li><a href="../258955/index.html">Master Tehnokub</a></li>
<li><a href="../258957/index.html">TypeScript: general impressions</a></li>
<li><a href="../258959/index.html">Serialization, sir! Today for dinner byte porridge, cooked from C ++ objects</a></li>
<li><a href="../258963/index.html">Krovi: Big Data - as dream. 10th series: Standard bummer</a></li>
<li><a href="../258965/index.html">NOT Arduino for 55 cents</a></li>
<li><a href="../258967/index.html">Sensors and microcontrollers. Part 1. The materiel</a></li>
<li><a href="../258973/index.html">Content Iconification</a></li>
<li><a href="../258977/index.html">Some interesting and useful things for web developer # 44</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>