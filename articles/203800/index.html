<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>L√∂b and m√∂b: strange loops in Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a fairly free translation of the article. The fact is that despite the construction in one line, the material is difficult to understand. 
 Ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>L√∂b and m√∂b: strange loops in Haskell</h1><div class="post__text post__text-html js-mediator-article"> <i>This is a fairly free translation of the article.</i>  <i>The fact is that despite the construction in one line, the material is difficult to understand.</i> <i><br></i>  <i>Taking into account that in the comments of the <a href="http://habrahabr.ru/post/203690/">Prelude or how to fall in love with Haskell, they</a> asked that the code was clear, I made enough remarks, and I hope that the code will be clear to those who are far from Haskel.</i> <br><br>  Let's start with the most difficult - from the very title: many of his words are incomprehensible. <br>  Haskell is a pure and lazy functional language. <br>  Loeb is a German mathematician, which we will talk about later. <br>  Well, and finally, the most interesting - strange loop. <br><img src="https://habrastorage.org/getpro/habr/post_images/756/f29/e8e/756f29e8e6433d9f4b789c443bcbbec7.jpg"><br>  Strange loops are tangled categories, when moving up or down in a hierarchical system, you find the same thing from where you started moving. <br>  Often such loops contain self-referential links. <br>  For example, recursive acronyms have such a strange loop: "PHP - PHP: Hypertext Preprocessor". <br>  Well, today the most mysterious word containing strange loops is the notion of "I." <br><br>  Strange loops excite people with their beauty.  And it is very nice when you find them in the most unexpected places.  Very interesting functions with strange loops can be written on Haskell. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The German mathematician Loeb migrated to Great Britain in the 39th year of the twentieth century.  Loeb, in particular, developed mathematical logic and the world is primarily known for the Loeb Theorem.  This theorem developed Godel's works on the incompleteness of mathematics.  Loeb's theorem on the relationship between the provability of an assertion and the assertion itself, it states that <br><br>  <b>in any theory that includes Peano's axiomatics (the axiomatics about natural numbers), for any statement <code>P</code> provability of the statement ‚Äúif provable <code>P</code> , then <code>P</code> true‚Äù is possible only in the case of provability of the statement <code>P</code> .</b> <br><br>  All this complexity of the statement can be written symbolically: <br><img src="https://habrastorage.org/getpro/habr/post_images/221/130/619/221130619ced5d4f8cc02b87a2a76459.png"><br><br>  Is it possible to write such a function on Haskell ?!  Can!  And just one line! <br><a name="habracut"></a><br><h4>  Loeb </h4><br>  <code>loeb</code> is one of those functions on Haskele that looks charming, crazy, simple and complex at the same time. <br><ol><li>  The function is very easy to write </li><li>  The function is difficult to understand </li><li>  Easy to use function </li><li>  Function is explainable </li></ol><br><h5>  Implementation </h5><br>  Feel smart?  Let's change this, introducing you to the <code>loeb</code> function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">loeb</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; f (fa -&gt; a) -&gt; fa loeb x = go <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> go = fmap ($ go) x</code> </pre><br>  Feel all beauty ?!  Then skip to the next section. <br>  Not?  Hmm ... maybe you just do not know Haskell well?  Then I will explain in more detail. <br>  Some shrewd ones will ask why there are two lines here, not just one, and they will be right.  But only partially.  The fact is that the first line is the signature: the declaration, with which types, with how many parameters the function works.  However, this line is optional - if you do not write it, the interpreter (and the compiler) themselves will display the types: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">loeb</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; f (fa -&gt; a) -&gt; fa</code> </pre><br>  The signature is divided into three parts - first we write the name of the function, then we say that we want to declare the type, put <code>::</code> , then we‚Äôll write restrictions on the parameters to the fat arrow ( <code>=&gt;</code> ) - I‚Äôll explain it a little bit below until it matters.  And finally - the types themselves: <br>  <code>f (fa -&gt; a) -&gt; fa</code> , look how close the record is to the Loeb theorem: <img src="https://habrastorage.org/getpro/habr/post_images/221/130/619/221130619ced5d4f8cc02b87a2a76459.png">  - yes one to one! <br>  I note, the function is written without using library functions! <br><br>  Before explaining what a signature means, as long as we go through the function itself, let's not waste time on trifles, and write the function in 3 lines, as any decent haskelist will do: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">loeb</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; f (fa -&gt; a) -&gt; fa loeb x = go <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> go = fmap ($ go) x</code> </pre><br>  Here you can see that the word <code>where</code> is a service one and makes it possible to define an internal function. <br><br>  How to read? ... Oh, yes, I must say that in Haskell there are no extra brackets, and where in most languages ‚Äã‚Äãthey write <br>  <code>f (x, y, z) = ...</code> , in Haskell they write only <code>fxyz = ...</code> <br><br>  From the code it is clear that the <code>loeb</code> function is a function of one argument <code></code> and it is determined through the function <code>go</code> . <br><br>  The function <code>go</code> defined by the Functor and the function <code>fmap</code> .  The <code>fmap</code> function itself is a generalization of the <code>map</code> function for lists and is defined as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre><br>  This is just a declaration.  OOP classes have nothing to do with type classes.  In our case, we don‚Äôt need to especially understand the first line, it just says that <code>f</code> will be polymorphic in the function <code>fmap</code> . <br>  So look carefully at the signature, to understand what it means. <br>  It is said that the function <code>fmap</code> is a function of two arguments - <code>(a -&gt; b)</code> and <code>fa</code> , the output is type <code>fb</code> . <br>  It is easy to understand that <code>(a -&gt; b)</code> is a function of one argument, taking some value as an input (generally we call this type <code>a</code> , it can be any ‚Äî for example, a string, a number, or a file) and the output is also some or a type (we denote it by <code>b</code> , remembering that <code>b</code> in particular may be <code>a</code> ). <br>  <code>fa</code> - can be understood as a kind of complex value depending on <code>a</code> and it will be easier to understand if you read as <code>f(a)</code> <br>  If you open the definitions of a functor in math, you will see surprising similarities. <br>  That is, if we ignore the full understanding, and go to the intuitive one, it can be seen that the function <code>fmap</code> applies the function to the value through <code>f</code> , and, as a rule, it is so. <br><br>  For our needs, it is not necessary to fully understand the full power of the functors, let's consider only the lists: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> [] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap = map</code> </pre><br>  It came out easier - for lists, the <code>fmap</code> function <code>fmap</code> completely analogous to the <code>map</code> function.  Well, the <code>map</code> function already all imperatives know, this application of the function to all the members of the list.  In Haskell, it is determined very simply: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">map</span></span> :: (a -&gt; b) -&gt; [a] -&gt; [b] map _ [] = [] map f (x:xs) = fx : map f xs</code> </pre><br>  We look at the signature: here everything is already familiar - a function of two arguments - a function of one parameter and a list.  The result is a modified list. <br>  The second line says that for an empty list, regardless of the function ("_" - we say that we do not need to know its value) will be an empty list. <br>  For other cases, we can divide the list into head and the rest ( <code>x : xs</code> , notice the letter <code>s</code> , in English, this means the plural, they say many <code>x</code> -s in <code>xs</code> ) and return another list, where we use the function for the head, and tail we recursively apply our described function. <br><br><div class="spoiler">  <b class="spoiler_title">Why fmap = map?</b> <div class="spoiler_text">  For those who understand how the <code>map</code> function <code>map</code> , but do not fully understand how <code>fmap = map</code> can be done - everything is quite simple, replace <code>f</code> with <code>[]</code> <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; [] a -&gt; [] b</code> </pre><br>  Well, this is the same as <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> </pre><br></div></div><br><br>  Well, go to our definition again: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">go</span></span> = fmap ($ go) x</code> </pre><br>  What is the function with the dollar?  Surely without Uncle Sam, and there was not enough?  Well that you, same pure language!  <code>$</code> Is an ordinary function-operator, called an applicative function and is determined elementarily: <br><pre> <code class="haskell hljs">($) :: (a -&gt; b) -&gt; a -&gt; b f $ x = fx</code> </pre><br>  No, it did not seem to you, the applicative function does nothing, but it is often used instead of brackets. <br><br>  Well, so as not to confuse you, let's rewrite the <code>loeb</code> function using lambda expressions: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">loeb</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; f (fa -&gt; a) -&gt; fa loeb x = go <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> go = fmap (\z -&gt; z go) x</code> </pre><br>  It is easy to read the lambda expressions: <code>\z -&gt; z go</code> means that the lambda function (a slash resembles the Greek letter lambda - <code>Œª</code> ) from one variable <code>z</code> , and the arrow <code>-&gt;</code> read like <code>=</code> <br><br>  Great, we could read!  Now it remains to understand her! <br><br><h4>  What is <code>loeb</code> doing? </h4><br><br>  <i>Short version:</i> <code>loeb</code> calculates the result in terms of itself, but this is more crazy than what you felt when you first heard about recursion. <br><br>  <i>Detailed version:</i> What is <code>loeb</code> use for?  Where is it useful?  For example, you can make a spreadsheet (like Exel) for a list functor - []: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xs</span></span> :: [a] xs = [...] fs :: [[a] -&gt; a] fs = [...] rs :: [a] rs = [ f xs | f &lt;- fs ] <span class="hljs-comment"><span class="hljs-comment">-- r = f xs</span></span></code> </pre><br>  Suppose we have a list <code>xs :: [a]</code> .  And we have a list of functions that collapse the lists to values, <code>fs :: [[a] -&gt; a]</code> .  We take and for each function from the list we apply to the list of elements, thus obtaining a new value <code>r</code> .  Collect all <code>r</code> in the list <code>rs</code> . <br><pre> <code class="haskell hljs">[ f xs | f &lt;- fs ]</code> </pre><br>  it is difficult to understand, but still - we in each cell of the list apply the function (from the list) to the list of values, read from right to left. <br><br>  For these actions, we calculated <code>rs</code> from the list of <code>xs</code> values ‚Äã‚Äãand the list of <code>fs</code> functions. <br><br>  And now the most important thing - you can not take a list of <code>xs</code> values, and use <code>rs</code> instead.  In other words, the function <code>f</code> is applied to the list of results, which itself generates! <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fs</span></span> :: [[a] -&gt; a] fs = [...] rs :: [a] rs = [ f rs | f &lt;- fs ]</code> </pre><br>  Of course, this all relies on the strongest laziness, as long as <code>rs</code> is calculated in terms of itself.  You can combine both functions to not have your own definitions of <code>fs</code> , and they will be just the <code>rs</code> parameter: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">rs</span></span> fs = [ f (rs fs) | f &lt;- fs ]</code> </pre><br>  If you look closely, then for lists <code>rs = loeb</code> <br><br>  Thus, the <code>loeb</code> function takes a list of functions, and calculates a list of results that it generates, and applies itself to the list just generated.  Strange?  Check?  Ringed?  I bet no! <br><br><h5>  Examples with <code>loeb</code> </h5><br>  An example that will help you understand how to work with this function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fs</span></span> = [ const <span class="hljs-number"><span class="hljs-number">1</span></span> , succ . (!! <span class="hljs-number"><span class="hljs-number">0</span></span>) , succ . (!! <span class="hljs-number"><span class="hljs-number">1</span></span>) , succ . (!! <span class="hljs-number"><span class="hljs-number">2</span></span>) ]</code> </pre><br>  Here <code>const a _ = a</code> is a function of two variables, which always returns the value of the first, <code>succ x = inc</code> increment for numbers (more precisely, this is a generalization of the increment for any enumerated values), <code>(!!)</code> is the function of pulling the <code>n</code> element from the list , <code>(.)</code> - functional composition of 2 functions, first applies the right function, then the left one, in our case, first pulls an element from the list, then increments. <br><br>  Here we have described the list of elements in terms of previous results.  <code>const 1</code> we have the first element, and it always returns 1, after that you can get the value of the second element - <code>succ . (!! 0)</code>  <code>succ . (!! 0)</code> , and further along the chain - the third, fourth and fifth. <br><pre> <code class="haskell hljs">&gt; loeb fs [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]</code> </pre><br><br>  The interesting part is that the order does not necessarily have to be from left to right.  The order can be inverted, the main thing is not to achieve circular recursion (in this case, the function will not be able to finish the calculations). <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fs</span></span> = [ succ . (!! <span class="hljs-number"><span class="hljs-number">1</span></span>) , succ . (!! <span class="hljs-number"><span class="hljs-number">3</span></span>) , succ . (!! <span class="hljs-number"><span class="hljs-number">0</span></span>) , const <span class="hljs-number"><span class="hljs-number">1</span></span> ] &gt; loeb fs [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre><br>  Does the truth look like a spreadsheet ?!  One value in the cell is known, and the others depend on each other in some way.  When the calculation ends, each cell has a specific value.  It looks like a generalization of a fixed point combinator. <br><br><h4>  Spreadsheets! </h4><br>  The above example is similar to a one-dimensional table.  But you can take other functors that are closer to reality, arrays, for example! <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Text.Printf loeb :: Functor f =&gt; f (<span class="hljs-title"><span class="hljs-title">fa</span></span> -&gt; <span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; fa loeb x = go where go = fmap ($ <span class="hljs-title"><span class="hljs-title">go</span></span>) x <span class="hljs-comment"><span class="hljs-comment">--   e = val 0 --     val = const -- ,   (10 %)    vat ix = (* 0.1) . (! ix) --    sum' ixs = \arr -&gt; foldl' (\acc ix -&gt; acc + arr ! ix) 0 ixs spreadsheet = listArray ((0,0), (4,4)) -- Prices | VAT | Effective prices + total [ val 1, vat (0,0), sum' [(0,i) | i &lt;- [0..1]], e, e , val 3, vat (1,0), sum' [(1,i) | i &lt;- [0..1]], e, e , val 5, vat (2,0), sum' [(2,i) | i &lt;- [0..1]], e, e , val 2, vat (3,0), sum' [(3,i) | i &lt;- [0..1]], e, e , e, e, sum' [(i,2) | i &lt;- [0..3]], e, e ] printArr :: Array (Int, Int) Double -&gt; IO () printArr arr = forM_ [0..4] $ \i -&gt; do forM_ [0..4] $ \j -&gt; printf "%4.1f " (arr ! (i,j)) printf "\n" main = printArr $ loeb spreadsheet</span></span></code> </pre><br>  Let's run! <br>  At the output we get: <br><pre> <code class="haskell hljs"> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">3.0</span></span> <span class="hljs-number"><span class="hljs-number">0.3</span></span> <span class="hljs-number"><span class="hljs-number">3.3</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">5.5</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-number"><span class="hljs-number">0.2</span></span> <span class="hljs-number"><span class="hljs-number">2.2</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">12.1</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre><br>  where in the first knee we have prices (using <code>val</code> ), in the second column we have taxes of what is left, in the third column the effective price, and below the total sum of all effective prices.  Now you can see, order and buy everything!  Magic!  :-) <br><br><h4>  <code>moeb</code> function </h4><br><br>  <code>moeb</code> is the result of the game with the definition of the <code>loeb</code> function: what if we want to abstract from the <code>fmap</code> .  For starters, this will make the signature under the function just crazy! <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- [m]oeb = multi-loeb :-) moeb :: (((a -&gt; b) -&gt; b) -&gt; c -&gt; a) -&gt; c -&gt; a moeb fx = go where go = f ($ go) x</span></span></code> </pre><br>  And in new terms you can redefine <code>loeb</code> , it will only be a special case of <code>moeb</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">loeb</span></span> = moeb fmap</code> </pre><br>  And what other functions can be used for the parameter of the <code>moeb</code> function <code>moeb</code> that it can be used? <br>  Well, for example, if we have a function <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">id</span></span> :: a -&gt; a id x = x</code> </pre><br>  Then: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">moeb</span></span> id x = id ($ moeb id x) x = ($ moeb id x) x = x (moeb id x) <span class="hljs-comment"><span class="hljs-comment">--    ,   fix -- fix f = f (fix f) fix = moeb id</span></span></code> </pre><br>  As you can see, <code>moeb</code> is a generalization of the <code>fix</code> function. <br><br>  There are other functions that can be used as <code>moeb</code> parameters, such as <code>traverse</code> and <code>foldMap</code> , but I still don‚Äôt know why you can use it for something useful. </div><p>Source: <a href="https://habr.com/ru/post/203800/">https://habr.com/ru/post/203800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../203788/index.html">COLT released with Source Maps support</a></li>
<li><a href="../203792/index.html">Review of the smartphone Meizu MX3</a></li>
<li><a href="../203794/index.html">Winamp fans suggest AOL make it open source</a></li>
<li><a href="../203796/index.html">Tricky java tasks</a></li>
<li><a href="../203798/index.html">ASUS MeMO Pad 10 (ME102A) Tablet Review</a></li>
<li><a href="../203802/index.html">ASUS X102 BA laptop review</a></li>
<li><a href="../203806/index.html">Can a robot pass a university math exam?</a></li>
<li><a href="../203808/index.html">ASUS MeMO Pad 8 (ME180A) Tablet Review</a></li>
<li><a href="../203810/index.html">Ocean simulation on WebGL</a></li>
<li><a href="../203812/index.html">Nokia: Now a fluorescent detector of nanoparticles and viruses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>