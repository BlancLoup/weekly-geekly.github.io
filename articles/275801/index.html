<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust and Blab's Paradox</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few weeks ago, I came across a comparative analysis of Rust, D and Go from Andrei Alexandrescu. Andrew, a respected member of the C ++ community and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust and Blab's Paradox</h1><div class="post__text post__text-html js-mediator-article"><img align="right" width="336" height="480" src="https://habrastorage.org/getpro/habr/post_images/002/f4c/143/002f4c1432994cc3182acbf78805d701.jpg"><p>  A few weeks ago, I came across a <a href="https://www.quora.com/Which-language-has-the-brightest-future-in-replacement-of-C-between-D-Go-and-Rust-And-Why">comparative analysis of Rust, D and Go</a> from Andrei Alexandrescu.  Andrew, a <a href="http://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315">respected member of the C ++ community</a> and the main developer <a href="http://dlang.org/">of the D programming language</a> , delivered a crushing blow at the end of his narration, making something that looks like a rather insightful observation: </p><br><br><p>  <i>Reading the code on Rust makes jokes about how "friends do not allow friends to miss the day of the legs" and causes comic images of men with a barbeque torso balancing on skinny legs.</i>  <i>Rust puts safety and jewelry handling of memory at the forefront.</i>  <i>In fact, this is quite rarely a real problem, and this approach makes the process of thinking and writing code a monotonous and boring process.</i> </p><br><br><p>  After several meetings with Andrew, after seeing some of his speeches, I became convinced that he <i>likes to joke</i> .  However, let's swallow the bait.  This joke is funny only because it looks funny, or maybe because there is only a joke in it? </p><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  The paradox of blab </h3><br><p>  Every time, reflecting on the benefits of certain possibilities of programming languages, I return to Paul Graham <a href="http://www.nestor.minsk.by/sr/2003/07/30710.html">'s</a> essay <a href="http://www.nestor.minsk.by/sr/2003/07/30710.html">"Beating Mediocrity</a> . <a href="http://www.nestor.minsk.by/sr/2003/07/30710.html">"</a>  It tells of an interesting phenomenon among programmers, which he calls the ‚ÄúParadox of Blab‚Äù.  For those who do not know, the paradox sounds like this: Suppose there is a programmer who uses a certain language, the Blub.  In terms of its expressiveness, Blab is somewhere in the middle of a continuum of abstractness among all programming languages.  It is not the most primitive, but also not the most powerful programming language. </p><br><br><p>  When our BAB-programmer looks at the "lower" part of the spectrum of programming languages, he easily notices that these languages ‚Äã‚Äãare less expressive than his favorite Blab.  But when our hypothetical programmer looks at the "upper" part of the spectrum, he usually does not realize that he is actually looking up.  Here is how Paul describes it: </p><br><br><p>  <i>All he sees is simply "weird" languages.</i>  <i>Perhaps he perceives them as equivalent to Blabu, only in them there is still a lot of dumb and incomprehensible garbage.</i>  <i>Blab for our programmer is quite enough, since he himself thinks on Blaba.</i> </p><br><br><p>  I remember when I first read it, I thought: ‚Äúwow, that's pretty insightful.‚Äù  Who would have thought that years later this concept would firmly take root in my way of thinking when I started trying to teach people how to program. </p><br><br><p>  As a language project manager at Microsoft, I‚Äôm working on <a href="http://www.typescriptlang.org/">TypeScript</a> , a typed version of Javascript.  Without fail, when I speak to an audience primarily of JavaScript developers and try to convey the idea of ‚Äã‚Äãhow great it would be to try to add a bit of strong typing in Javascript, people look gloomy at me.  Every time.  Even if it is not required.  Even after I describe the half-dozen benefits.  As Paul said, it just looks weird.  For JavaScript programmers, TypeScript looks basically the same as JavaScript, plus a bunch of dumb and incomprehensible stuff. </p><br><br><p>  After talking with the commands of other programming languages, as well as watching more and more people at conferences, I realized that watching Paul was not only accurate, but also surprisingly universal.  Most programmers are ready to fight back with all their might, seeing a new programming language that they never used.  New, alien features cause them an allergic reaction.  Only after working with new features for quite a long time, they begin to understand that all this is not just useless pribludiny. </p><br><br><p>  In short, the Blab's paradox is something with which we, as programmers, must reckon with, into which we have a tendency to flow, and from which we should get out, putting all our efforts. </p><br><br><p>  Let's just do it.  Let's take a look at some of the strangest and most useless features of Rust.  And then we will see if we can crank up the deblabization. </p><br><br><h3>  Strange garbage number 1.  Rust style polymorphism </h3><br><p>  Let's write a program on Rust, which uses a bit of polymorphism to print two different structures.  I‚Äôll show you the code first, and then we‚Äôll cover it in detail. </p><br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> fmt::Display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">write!</span></span>(f, <span class="hljs-string"><span class="hljs-string">"(x: {})"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> fmt::Display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Bar { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">write!</span></span>(f, <span class="hljs-string"><span class="hljs-string">"(x: {}, y: {})"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_me</span></span></span></span>&lt;T: fmt::Display&gt;(obj : T) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Value: {}"</span></span>, obj); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo {x: <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bar = Bar {x: <span class="hljs-number"><span class="hljs-number">5</span></span>, y: <span class="hljs-number"><span class="hljs-number">10</span></span>}; print_me(foo); print_me(bar); }</code> </pre> <br><p>  What is it vyrvlaglaznoe!  Yes, there is polymorphism here, but it‚Äôs not even close to OOP.  This code uses generalizations, and not only generalizations, but there are a lot of limitations in this approach.  And what is this <code>impl</code> ? </p><br><br><p>  Let's take in parts.  I create two structures to store our values.  The next step is to implement something for them called <code>fmt::Display</code> .  In C ++, we would overload the <code>&lt;&lt;</code> operator for <code>ostream</code> .  The result would be the same.  Now I can call the print function, passing my structures directly. </p><br><br><p>  This is half the story. </p><br><br><p>  Next we have the <code>print_me</code> function.  This function is generalized and takes anything if it can <code>fmt::Display</code> .  Fortunately, we have just made sure that our structures can do this. </p><br><br><p>  Everything else is simple.  We create several instances of the structures and print them to <code>print_me</code> . </p><br><br><p>  Fuh ... had to work hard.  This is how polymorphism is done in Rust.  All essence in generalizations. </p><br><br><p>  Now let's switch to C ++ for a moment.  Many, especially newbies, could not immediately think of using patterns, and would have followed the path of object-oriented polymorphism: </p><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class Foo { public: int x; virtual void print(); }; class Bar: public Foo { public: int y; virtual void print(); }; void Foo::print() { std::cout &lt;&lt; "x: " &lt;&lt; this-&gt;x &lt;&lt; '\n'; } void Bar::print() { std::cout &lt;&lt; "x: " &lt;&lt; this-&gt;x &lt;&lt; " y: " &lt;&lt; this-&gt;y &lt;&lt; '\n'; } void print(Foo foo) { foo.print(); } void print2(Foo &amp;foo) { foo.print(); } void print3(Foo *foo) { foo-&gt;print(); } int main() { Bar bar; bar.x = 5; bar.y = 10; print(bar); print2(bar); print3(&amp;bar); }</span></span></span></span></code> </pre><br><p>  Pretty simple, isn't it?  Ok, here's a little quiz for you: what exactly will C ++ code print? </p><br><br><p>  If you have not guessed, do not be discouraged.  You are in good company. </p><br><br><p>  If you guessed it - my congratulations!  Now think for a minute how much you need to know about C ++ to give the correct answer.  From what I see, you need to understand how the stack works, how objects are copied, when they are copied, how pointers work, how links work, how virtual tables are organized, and what dynamic dispatching is.  Just to write a few simple lines in OOP style. </p><br><br><p>  When I started learning C ++, this upgrade was too steep for me.  Fortunately, my cousin turned out to be a C ++ expert, and, taking me under his wing, he showed me some beaten tracks.  Nevertheless, I managed to make tons of children's mistakes, like this example.  Why?  One of the reasons for the inaccessibility of C ++ is a high cognitive load during its development. </p><br><br><p>  Part of the cognitive load falls on things that are inherent in programming in its essence.  You must understand the stack.  You need to know how pointers work.  But C ++ increases the load, requiring an understanding of when the value will not be completely copied, and when virtual dispatching is used, and when not used - and all this without any warnings from the compiler, if the developer does something, that "most likely is a bad idea." </p><br><br><p>  This is not an attempt to go against C ++.  Many things in Rust are implemented with the idea of ‚Äã‚Äãpreserving the philosophy of low-level and efficient abstractions taken from C ++.  You can even write code that will be <a href="https://gist.github.com/jonathandturner/a182347b763398d8ea4f">very similar to the Rust example</a> . </p><br><br><p>  What Rust is really doing is separating inheritance from polymorphism, pushing you to think in the direction of creating generalizations from the very beginning.  In this way, you begin to think in general from the first day.  However, separating inheritance from polymorphism may seem like a strange idea, especially if you are used to always using them together. </p><br><br><p>  Such a separation can cause one of the first manifestations of the Blab effect: what is the general advantage of separating inheritance and polymorphism?  And by the way, is there any inheritance in Rust? </p><br><br><p>  Believe it or not, at least in Rust 1.6 there are no special tools for inheriting structures.  Instead, their functionality is built up outside the structures themselves, with the help of a special concept of language - ‚Äútypes‚Äù.  Types allow you to add methods, require the implementation of methods, and in every way to equip data structures in existing systems.  Also types support inheritance: one type can extend another. </p><br><br><p>  If you dig around a lot, you can notice something else.  Rust does not have all the problems we had to worry about in C ++.  We can no longer think about how something is lost when a function is called in some way, and what effect virtual dispatching has on our code.  In Rust, everything works in the same style, regardless of type.  Thus, a whole class of children's mistakes just disappear. </p><br><br><p>  <i>(Note of the translation. - More information about the types can be read in the Russian-language translation of the book <a href="http://rurust.github.io/rust_book_ru/src/traits.html">"Rust Programming Language</a> . <a href="http://rurust.github.io/rust_book_ru/src/traits.html">"</a> )</i> </p><br><br><h3>  Strange garbage number 2.  I mean, no exceptions? </h3><br><p>  Since we are talking about things that are not in Rust, the next strange garbage will be the absence of exceptions.  Isn't that a step backwards?  What do we do with errors?  Can we forward them up to process everything at once in one place? </p><br><br><p>  Well, it's time to get to know the monads. </p><br><br><p>  Although ... well, kidding, this time you can do without them.  In Rust, error handling is much more straightforward.  Here is an example of how it looks in practice.  First, examples of how the function declaration will look like: </p><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> SystemTime { <span class="hljs-comment"><span class="hljs-comment">///     pub fn now() -&gt; SystemTime; ///  ,   ""   pub fn duration_from_earlier(&amp;self, earlier: SystemTime) -&gt; Result&lt;Duration, SystemTimeError&gt;; }</span></span></code> </pre><br><p>  Notice that the <code>now</code> function simply returns <code>SystemTime</code> and does not have any exceptions, while <code>duration_from_earlier</code> returns a <code>Rsult</code> type, which can be either <code>Duration</code> or <code>SystemTimeError</code> .  Thus, you immediately see all the possible outcomes of the functions, both successful and not successful. </p><br><br><p>  But all of these exceptional situations create a mess in the returned values.  Who wants to see this in their code?  It is great, of course, to always do error checks, but the point of exceptions is precisely that they allow you to handle errors not only locally, but also to forward them to the top, performing processing in one place. </p><br><br><p>  And Rust lets you do the same. </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_header</span></span></span></span>(file: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> File) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Header, io::Error&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Header { header_block: <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_u32()) }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_metadata</span></span></span></span>(file: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> File) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Metadata, io::Error&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Metadata { metadata_block: <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(file.read_u32()) }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_audio</span></span></span></span>(file: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> File) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Audio, io::Error&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> header = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(load_header(file)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> metadata = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(load_metadata(file)); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Audio { header: header, metadata: metadata }) }</code> </pre><br><p>  Although this is not completely obvious, this code uses throwing exceptions.  The whole chip in the macro <code>try!</code>  .  He does a pretty simple thing.  It calls a function.  If it succeeds, it will hand the result of the calculation to you.  If an error occurs instead, <code>try!</code>  flashing this error by completing the current function. </p><br><br><p>  This means that if <code>load_header</code> any problems when calling <code>file.read_u32</code> , the function will return <code>io::Error</code> .  Further, the same will happen in <code>load_audio</code> , and the same error will be returned from it.  And so on until the caller finally handles the error. </p><br><br><p>  <i>(Note lane. - Read more about error handling can be found in the article on Habr√© <a href="https://habrahabr.ru/post/270371/">"Error handling in Rust"</a> .)</i> </p><br><br><h3>  Strange garbage number 3.  Borrow-checker </h3><br><p>  You know, it's funny.  The first thing that many people mention when they talk about Rust is the borrow checker.  Moreover, it is often presented as the main feature of Rust, distinguishing it from other programming languages.  For example, for Andrew, the borrow checker is the ‚Äúshrewish torso‚Äù of Rust.  For me, borrow checker is just another compiler check.  Just like the type checking, the borrow checker allows you to catch most of the bugs before they occur during execution.  That's all.  Of course, at first it may seem like a monstrous thing, but I dare to argue that it‚Äôs not that Rust makes you learn some new incomprehensible type system, but that the ability to work with it builds new muscles like you programmer. </p><br><br><p>  So what mistakes does the borrow checker catch, you ask? </p><br><br><h4>  Using pointers after freeing memory </h4><br><p>  Oh yes, the classic situation, first you free up memory, and then use it again.  In most cases, this is exactly the reason why programs crash with the frightening ‚Äúnull pointer exception‚Äù. </p><br><br><p>  There are a whole bunch of ‚Äúgood practices‚Äù C ++ that allow you to avoid use-after-free: using RAII, using references or smart pointers instead of raw pointers, documenting ownership and borrowing relationships in your API, and so on.  Everything that, according to Andrew, ‚Äúmakes the process of thinking and writing code a monotonous and boring process.‚Äù  A team of well-trained C ++ programmers is able to avoid most of the use-after-free errors, doing monotonous and boring work, because such is the price - following all ‚Äúgood practices‚Äù, never read and replenish the team only with highly qualified C ++ experts. </p><br><br><h4>  Invalid iterators </h4><br><p>  Have you ever had to modify a container that you iterated into C ++ and get sudden drops of it sometime in the future?  I had to.  If you have added or removed at least one element from the container, this is enough to require reallocating the container and making your iterator invalid. </p><br><br><p>  I do not often step on this rake, but it still happens from time to time. </p><br><br><h4>  Data Race States </h4><br><p>  In Rust, the data is either shared or variable.  If the data can be changed, it cannot be shared between multiple threads, so there is no way to start changing them in two threads at the same time, thereby causing a race condition.  If the data is general, they cannot be modified, so you can read them as much as you like from any number of streams. </p><br><br><p>  If you come from the world of C ++ or any other language with many good parallel libraries, such restrictions may seem too strict.  Fortunately, this is not the whole story, but it is the basis that gives you a set of simple rules for creating more complex abstractions.  The rest of the story is being written right now.  An increasing number of <a href="http://areweconcurrentyet.com/">parallel-oriented libraries is</a> emerging in the Rust ecosystem.  If you are interested in learning more, you can learn the principles of their work. </p><br><br><h4>  Ownership tracking </h4><br><p>  This concept may seem somewhat redundant, but in fact this is exactly what C ++ is constantly fighting.  Earlier, I mentioned one of the good practices of ‚Äúdocumenting ownership and borrowing relations in your API‚Äù.  The problem is that this information is stored in the comments, instead of what is directly in the code. </p><br><br><p>  Here is the script for you: you write in C ++ and you need to call the library that someone else wrote.  Suppose this is a C library and it takes raw pointers as arguments.  Do you have to take care to delete afterwards what you transferred to this library?  Or will she take on this responsibility by storing the data in one of her structures?  Maybe you call a scripting engine like Ruby?  Who then owns the data? </p><br><br><p>  Instead of reading the documentation, Rust allows you to be confident in your expectations, all the time checking the correctness of using the library API using the borrow checker. </p><br><br><h4>  And much more </h4><br><p>  Borrow checker helps to avoid many other errors.  For example, it allows you to always count on the fact that any changeable data that you take to the function you write does not affect any external state, and you can safely change them as you see fit. </p><br><br><p>  Incidentally, this opens up broad opportunities for additional optimizations that are difficult to produce in C-like programming languages, because the compiler ensures that any value that has several aliases cannot be changeable, and vice versa - only one name always has a changeable value. </p><br><br><p>  <i>(Note of the translation. - You can read more about the concept of ownership and borrowing in the Russian-language translation of <a href="http://rurust.github.io/rust_book_ru/src/ownership.html">the Rust Programming Language</a> .)</i> </p><br><br><h3>  Strange garbage number 4.  Rules are needed to break them. </h3><br><p>  I believe that one of Rust's greatest strengths is its pragmatism.  Most of the strict constraints can be circumvented with features such as <code>unsafe</code> and <code>mem::transmute</code> .  Borrow checker is not suitable for solving your problems?  Not a problem, just turn it off. </p><br><br><p>  <i>(Note. - Strictly speaking, this is not true: in Rust there is no easy way to disable borrow checker. Even inside unsafe blocks, it works at full capacity. But borrow checker checks borrowing rules only for <code>&amp;T</code> and <code>&amp;mut T</code> , while as in <code>unsafe</code> blocks, you also have the opportunity to use the <b>raw</b> <code>*const T</code> and <code>*mut T</code> , which work almost the same way as the pointers from C. Their use is not limited by the rules of borrowing. For more information, see <a href="https://doc.rust-lang.org/nightly/nomicon/meet-safe-and-unsafe.html">The Rustonomicon: The Dark Arts of Advanced and Unsafe Rust Programming</a> . <a href="https://doc.rust-lang.org/nightly/nomicon/meet-safe-and-unsafe.html">‚Äù</a> )</i> </p><br><br><p>  This allows you to do everything that you are used to doing in C-like system programming languages.  The advantage of Rust is that it is much easier to write code that is safe from the beginning by default, and then add unsafe areas as they are needed.  It is much harder to write secure code based on what's inherently insecure. </p><br><br><p>  Although Rust gives you a choice, it pushes you not to shoot yourself in the foot. </p><br><br><h3>  So what about the legs? </h3><br><p>  Going back to his feet, did Rust miss his workouts?  Did he get one-sided?  Did he focus on the wrong things? </p><br><br><p>  Rust is growing stronger every day, and, fortunately, is well aware of how to do a squat without bending your back.  This moment is hard to overestimate.  The Rust philosophy has a solid foundation, which means the language will grow and develop. </p><br><br><p>  <i>From the translator: As always, I thank the <a href="http://gitter.im/ruRust/general">Russian-speaking Rust community</a> for their help in translating and valuable comments.</i> </p></div><p>Source: <a href="https://habr.com/ru/post/275801/">https://habr.com/ru/post/275801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275785/index.html">How to use SQL DB in student Microsoft AZURE from Dreamspark</a></li>
<li><a href="../275787/index.html">VPLS. Label Distribution with BGP</a></li>
<li><a href="../275789/index.html">Tricky C # Questions</a></li>
<li><a href="../275795/index.html">Example of creating a web application using the Vaadin libraries</a></li>
<li><a href="../275797/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ195 (January 18 - 24, 2016)</a></li>
<li><a href="../275803/index.html">Service Monitoring with Prometheus</a></li>
<li><a href="../275805/index.html">Path from prototype to industrial IoT product</a></li>
<li><a href="../275809/index.html">How IT executives work with mail</a></li>
<li><a href="../275811/index.html">As I wrote the security policy</a></li>
<li><a href="../275813/index.html">Recursion Training tasks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>