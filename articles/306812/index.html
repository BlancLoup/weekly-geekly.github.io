<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How not to keep secrets where we have to, or why we need Hashicorp Vault</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ask yourself the question - how to store the password from the database used by your service? In a separate repository with secrets? In the applicatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How not to keep secrets where we have to, or why we need Hashicorp Vault</h1><div class="post__text post__text-html js-mediator-article"><p><img src="http://pocketstudio.jp.s3.amazonaws.com/log3/wp-content/uploads/2015/07/hahsicorp-vaule-header2-670x262.png" alt="Vault header"></p><br><p>  Ask yourself the question - how to store the password from the database used by your service?  In a separate repository with secrets?  In the application repository?  In deployment system (Jenkins, Teamcity, etc)?  In the configuration management system?  Only on a personal computer?  Only on the servers your service is running on?  In a certain repository of secrets? <br>  Why think about it?  To minimize the security risks of your infrastructure. <br>  We begin the study of the issue with the definition of requirements for the storage of secrets. </p><br><a name="habracut"></a><br><h2>  Requirements for the storage of infrastructure secrets: </h2><br><ul><li>  Tweaking secrets access rules.  We give access only to those secrets that are necessary and sufficient to perform the work. </li><li>  Access Lifecycle Management.  The ability to issue, revoke, set a lifetime and reissue or extend access. </li><li>  Audit access to secrets.  Each access deed is recorded and will be verified by a third party. </li><li>  The minimum perimeter of the attack.  The less "smearing" on the system, the better. </li><li>  Fault tolerance.  No single point of failure. </li><li>  Comfortable working with secrets for people and automated systems.  Minimum time to learn and implement new tools. </li></ul><br><h2>  Let's take an example of our requirements for possible solutions: </h2><br><ul><li>  Repository storage (any): <br><ul><li>  There is no flexible configuration of access to secrets.  Access is binary - either there is or not.  There are solutions to this problem: use gpg for files.  For configuration management systems use Ansible vault, Puppet gpg-hiera, Chef encrypted data bags and so on.  Problems begin where automation occurs.  An attacker who gains access to the server where the decryption keys are stored (the master server for Puppet \ Chef, the host for automatic launch of Ansible playbooks, the host for automatic launch of tasks that need encrypted data from the repository) gains access to secrets. </li><li>  No support for full access life cycle.  You cannot give temporary access.  You cannot revoke access to secrets (you can only change access to the repository and the secrets themselves in it).  The lack of a regular access update process reduces transparency. </li><li>  No audit. </li><li>  Unpredictable "blurring" of the system.  Each appearance of this repository in the infrastructure adds points of attack to you.  Whether it‚Äôs Jenkins, different chef \ puppet servers for prod / dev / test / uat environments, or the need to run a small script from one server that is stored in this repository - you get risks in exchange for 'convenience' and the ability not to think about security. </li></ul></li><li>  Storage in the Deploy system: <br><ul><li>  There is no flexible configuration of access to secrets.  A person with access to the deployment system can use secrets in his task - and thus gain access to them.  If you use Jenkins, then secrets <a href="http://xn--thibaud-dya.fr/jenkins_credentials.html">can be pulled out at the server level</a> . </li><li>  No support for full access life cycle. </li></ul></li><li>  Manual insertion of secrets to the server: <br><ul><li>  No support for full access life cycle. </li><li>  No audit.  You do not know who and when got access to the secrets. </li><li>  No fault tolerance.  If the secret is stored on only one server - the loss of the server threatens to lose the secret. </li><li>  No convenience of work.  But this method can be used when you have a few servers and services.  With the growth of infrastructure you are waiting for the increased cost of maintenance of the process of managing secrets. </li></ul></li></ul><br><h2>  Why Vault? </h2><br><p>  <a href="https://www.vaultproject.io/">Vault</a> is a repository of secrets from the recognized "solvers" of problems of modern infrastructure - <a href="https://www.hashicorp.com/">Hashicorp</a> , the authors of Vagrant, Consul, Terraform, Otto, etc.  Secrets are stored in key-value form.  Access to the repository is carried out exclusively through the API. <br>  Main features of the Vault: </p><br><ul><li>  All data is stored in an encrypted container.  Receiving the container itself does not reveal the data. </li><li>  Flexible access policies.  You can create as many tokens to access and manage secrets as you need.  And to give them the permissions that are necessary and sufficient to perform the work. </li><li>  The possibility of listening access to secrets.  Each request to the Vault will be logged for subsequent auditing. </li><li>  Supports automatic generation of secrets for several popular databases (postgresql, mysql, mssql, cassandra), for rabbitmq, ssh and for aws. </li><li>  Support for encrypting and decrypting data without saving it.  This may be convenient for transmitting data in encrypted form over unsecured communication channels. </li><li>  Full secret life cycle support: creation / revocation / expiration / renewal. </li><li>  Uberfitch, the importance of which is difficult to overestimate, is the ability to create your own CA (Certificate Authority) to manage self-signed certificates within your infrastructure. </li><li>  Backend / cubbyhole, which allows you to create your own repository of secrets, not even available to other root-tokens. </li><li>  Ready modules and plugins for popular configuration management systems. </li></ul><br><p>  For us, Vault solves the problem of transferring secrets over unprotected channels, the problem of fault-tolerant storage of secrets, as well as problems of flexible separation and access auditing.  Plans to use Vault as your own CA. </p><br><h2>  Beginning of work </h2><br><p>  I will not translate official documentation, so here are some links: </p><br><ul><li>  Getting started is available <a href="https://www.vaultproject.io/intro/getting-started/install.html">here</a> . </li><li>  <a href="https://www.vaultproject.io/">There is</a> an interactive tutorial. </li><li>  <a href="https://www.amon.cx/blog/managing-all-secrets-with-vault/">Here</a> is another great article. </li></ul><br><p>  So, you launched Vault.  First of all, we put our key in the repository.  The official work process is: </p><br><ol><li>  For each service we create a separate master token.  This token can manage secrets in the container / secret / service_name / and can create other tokens. </li><li>  Switch to this token and create a secret. </li><li>  We release a new token to read this secret. </li><li>  We feed this token to our automation system </li><li>  ... </li><li>  PROFIT !!! <br>  Further nuances begin.  I will analyze them in more detail. </li></ol><br><h4>  About master token for each service </h4><br><p>  It turned out to be inconvenient to constantly switch tokens if you are responsible for several services. <br>  Due to the peculiarities of managing access policies (more detailed below), the overhead costs for the initial implementation of Vault in the service workflow have increased. </p><br><h4>  Pro features of managing access policies </h4><br><p>  They are described in <a href="http://www.json.org/json-ru.html">JSON</a> or <a href="https://github.com/hashicorp/hcl">HCL</a> format and are recorded in Vault using a request to the API or through cli.  For example: </p><br><pre><code class="hljs pgsql">$ vault <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> policy_name policy_file.hcl</code> </pre> <br><p>  In order for the master token you created to create new tokens, it must have a policy: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "auth/token/create" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "write" }</code> </pre> <br><p>  A master token can create tokens only with those policies it possesses. <br>  This means that it is not enough for you to issue the service_name_prod_root policy to the token: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "write" }</code> </pre> <br><p>  which has full access to secret / service_name / prod / *, but you also need to attend to it, by the service_name_prod_read policy: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "read" }</code> </pre> <br><p>  and then you can create tokens for read-only access with the command: </p><br><pre> <code class="hljs pgsql">$ vault token-<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>=service_name_prod_read</code> </pre> <br><p>  And there is a nuance: the policies are applied according to the degree of detail.  This means that if you make a root policy like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "write" }</code> </pre> <br><p>  and want to give read access to the service_name_prod_database_read policy: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/database/*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "read" }</code> </pre> <br><p>  then you will need to assign the token that manages this service to both of these policies.  When you do this, you cannot write to secret / service_name / prod / database / *: </p><br><pre> <code class="hljs pgsql">$ vault <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>/replicas \ secret_key=sha1blabla Error writing data <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>/replicas: Error making API request. URL: PUT https://vault.service.consul:<span class="hljs-number"><span class="hljs-number">8200</span></span>/v1/secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>/replicas Code: <span class="hljs-number"><span class="hljs-number">400.</span></span> Errors: * permission denied</code> </pre> <br><p>  You will have to balance each detailed reading policy to prevent this from happening.  For example, modify the service_name_prod_root policy: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "write" } <span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/database/*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "write" }</code> </pre> <br><p>  This does not make the life of operators easier, so we abandoned this approach and work with secrets only from under root keys. </p><br><h4>  About accounting and updating tokens </h4><br><p>  The Vault documentation does not say in vain about the importance of accounting for released tokens. <br>  There is no easy way to know which keys are present in the system.  If you created a token and forgot about it, without recording any information, then you will have to wait until it expires. <br>  Root tokens have no lifetime, so they will remain on your system indefinitely.  To avoid this situation, to create a new token for testing and verification purposes, specify the excellent -ttl = "1h" flag, which sets the lifetime. <br>  This will allow you to work quietly and not be afraid to increase the number of tokens without control. <br>  There is also a risk not to keep track of the expiration of the token's life and learn about it, for example, during deployment. <br>  This problem can be solved by recording tokens and monitoring the lifetime.  But writing tokens somewhere in one place is not safe.  Therefore, since Vault 0.5.2, every token after creation returns the accessor parameter, knowing which, you can interact with the token without knowing it (withdraw, update, add policies), for example </p><br><pre> <code class="hljs pgsql">$ vault token-<span class="hljs-keyword"><span class="hljs-keyword">revoke</span></span> <span class="hljs-comment"><span class="hljs-comment">--accessor b30ee2a3-ea4b-9da0-3e5c-4189d375cad9</span></span></code> </pre> <br><p>  <a href="https://www.hashicorp.com/blog/vault-0.6.html">Details here</a> . <br>  Maintaining data on issued tokens allows you to quickly audit active accesses in the system and configure monitoring for the token to expire. </p><br><h4>  About token settings </h4><br><pre> <code class="hljs sql">$ vault token-<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>=service_name_prod_root -<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>=service_name_prod_read <span class="hljs-keyword"><span class="hljs-keyword">Key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-comment"><span class="hljs-comment">--- ----- token 82c5fb97-da1b-1d2c-cfd5-23fa1dca7c85 token_accessor dd256e17-b9d9-172d-981b-a70422e12cb8 token_duration 2592000 token_renewable true token_policies [default, service_name_prod_root, service_name_prod_read ]</span></span></code> </pre> <br><p>  Go through the returned parameters: </p><br><pre> <code class="hljs 1c">token -      Vault. token_accessor - , <span class="hljs-keyword"><span class="hljs-keyword"></span></span>      , <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   .   :   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> ,  . token_duration -     . token_renewable - <span class="hljs-keyword"><span class="hljs-keyword"></span></span> true,       ,  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>          max-lease-ttl,  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-number"><span class="hljs-number">30</span></span>d.  ,  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>        <span class="hljs-number"><span class="hljs-number">30</span></span>       <span class="hljs-number"><span class="hljs-number">30</span></span> ,     <span class="hljs-keyword"><span class="hljs-keyword"></span></span> . token_policies - ,   .    ,       .</code> </pre> <br><h4>  Non-obviousness and usefulness </h4><br><p>  If the token was the parent for other tokens, then by default, when this token is revoked, all tokens and secrets created by the revoked token are recursively revoked.  This can be avoided by specifying the -mode flag.  In details </p><br><pre> <code class="hljs pgsql">vault token-<span class="hljs-keyword"><span class="hljs-keyword">revoke</span></span> -h</code> </pre> <br><p>  If you use the <a href="https://github.com/hashicorp/consul-template">consul-template</a> for automatic regeneration of configs when changing secrets, keep in mind (and you will not find this in the documentation) that the consul-template polls the change of secret in two cases: </p><br><ul><li>  Start or restart of the consul-template itself. </li><li>  Every (TimeToLive secret / 2) seconds after the start of the consul-template. </li></ul><br><p>  In order not to enter your working token all the time, you can put it in $ HOME / .vault-token or in the environment variable VAULT_TOKEN.  Here it is necessary to make a reservation, that by default I consider the admin workstation protected (encrypted disks, no guest input, auto-blocking after a minute of inactivity).  If this is not the case, then it is worth abandoning this idea. </p><br><h2>  Our work process: </h2><br><p>  We didn‚Äôt have the official process of working with Vault because of the excessive complexity of implementing Vault into service operation.  I will share our solutions and answers to your questions during the implementation of Vault. </p><br><ul><li>  Fault tolerance: <br>  We use Consul in infrastructure, so we chose it as a fault tolerant backend for Vault. </li><li>  Number of keys to print the repository: <br>  Printing is an exclusively manual process, during which an encrypted container with secrets is placed in memory and the master key for decryption is restored.  <a href="https://www.vaultproject.io/docs/concepts/seal.html">Details here</a> .  Making it possible for one person to print the repository is a risk, because if this key or keys are compromised, attackers will have access to the repository (but not yet the secrets).  It should be understood that if you do not type the necessary minimum keys for printing the storage, access to the data will be lost.  We decided that 4 key holders and 2 keys are enough for us to decrypt. </li><li>  Root tokens and their role in the system: <br>  The official position of Hashicorp is to use these tokens only to manage policies, roles, system settings, and to issue tokens for services.  The smaller the root keys in the system, the less likely the keys are compromised.  But the fewer such keys in the system, the more everything is tied to certain people who are sick, go on vacation, in general - are not available.  We started with 4 root keys for a group of 7 people.  This was inconvenient, so we departed from the official process for the first time - we issued root tokens to all operating engineers and stopped creating master tokens to manage service secrets.  All operations are performed under root tokens.  Only read-only tokens are created. </li><li>  Secrets storage scheme: <br>  For us, I chose the following scheme - keep the secrets of services in / secret / service_name / env.  And common infrastructure keys (for example, api-token for jenkins or credentials for accessing the package repository) are stored in / secret / infra / *. </li><li><p>  Naming secrets: </p><br><pre> <code class="hljs pgsql">$ vault <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span> \ base=appname \ <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>=appname \ <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>=difficult_password</code> </pre> <br><p>  or for example </p><br><pre> <code class="hljs pgsql">$ vault <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>/base <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=appname $ vault <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">login</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=appname $ vault <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">password</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=difficult_password</code> </pre> <br><p>  Resolve this issue before your list of secrets grows quickly and you begin to fasten various automation tools.  We use the first scheme. </p><br></li><li>  Keys accounting and monitoring their lifetime: <br>  By default, the maximum lifetime of a non-root token is 30 days.  We keep track of accessor keys for tokens using the repository - and this is inconvenient.  But allowed to set up monitoring, which reports the expiration of the keys for 5 days. <br>  There are plans to start a small service for registering keys and write a small wrapper for automating some actions with tokens (for example, automatic recording of a newly created token to the service). </li></ul><br><h2>  Let's return to keeping the secret from the database. </h2><br><p>  We installed and launched Vault, got a root token.  What's next? <br>  According to the latest version of the process adopted in my company, it will look like this: <br>  <a href="https://www.vaultproject.io/intro/getting-started/install.html">Install the vault</a> . <br>  Specify the location of the Vault: </p><br><pre> <code class="hljs scala">$ export <span class="hljs-type"><span class="hljs-type">VAULT_ADDR</span></span>=<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//vault.service.consul:8200'</span></span></code> </pre> <br><p>  Log in as root token: </p><br><pre> <code class="hljs go">$ vault auth <span class="hljs-number"><span class="hljs-number">82</span></span>c5fb97-da1b<span class="hljs-number"><span class="hljs-number">-1d</span></span>2c-cfd5<span class="hljs-number"><span class="hljs-number">-23f</span></span>a1dca7c85</code> </pre> <br><p>  Let's write our secret: </p><br><pre> <code class="hljs pgsql">$ vault <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span> base=appname <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>=appname <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>=difficult_password</code> </pre> <br><p>  We write the policy to read in the service_name_prod_read.hcl file: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span> "secret/service_name/prod/database*" { <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> = "read" }</code> </pre> <br><p>  Create a policy in Vault: </p><br><pre> <code class="hljs pgsql">$ vault <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> service_name_prod_read service_prod_read.hcl</code> </pre> <br><p>  Generate a token to read: </p><br><pre> <code class="hljs sql">$ vault token-<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>=service_name_prod_read <span class="hljs-keyword"><span class="hljs-keyword">Key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-comment"><span class="hljs-comment">--- ----- token cb347ae0-9eb4-85d1-c556-df43e82be4b0 token_accessor c8996492-17e3-16a7-2af1-d58598ae10d8 token_duration 2592000 token_renewable true token_policies [default, service_name_prod_read ]</span></span></code> </pre> <br><p>  Let's write token_accessor for the subsequent audit and monitoring. <br>  Check that there is read access: </p><br><pre> <code class="hljs pgsql">$ vault auth cb347ae0<span class="hljs-number"><span class="hljs-number">-9</span></span>eb4<span class="hljs-number"><span class="hljs-number">-85</span></span>d1-c556-df43e82be4b0 $ vault <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> secret/service_name/prod/<span class="hljs-keyword"><span class="hljs-keyword">database</span></span> Key <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> lease_duration <span class="hljs-number"><span class="hljs-number">2592000</span></span> base appname <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> appname <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> difficult_password</code> </pre> <br><p>  Everything works, we are ready to use our token in automation systems.  I will give examples for popular systems. </p><br><h4>  Just curl: </h4><br><pre> <code class="hljs ruby">$ curl \ -H <span class="hljs-string"><span class="hljs-string">"X-Vault-Token:cb347ae0-9eb4-85d1-c556-df43e82be4b0"</span></span> \ <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/vault.service.consul:8200/v</span></span>1/secret/service_name/prod/database</code> </pre> <br><h4>  Ansible (we use <a href="https://github.com/jhaals/ansible-vault">https://github.com/jhaals/ansible-vault</a> ): </h4><br><p>  Customize the environment: </p><br><pre> <code class="hljs objectivec">$ <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> VAULT_ADDR=https:<span class="hljs-comment"><span class="hljs-comment">//vault.service.consul:8200 $ export VAULT_TOKEN=cb347ae0-9eb4-85d1-c556-df43e82be4b0</span></span></code> </pre> <br><p>  Use variables from Vault in the role: </p><br><pre> <code class="hljs objectivec">database_password: <span class="hljs-string"><span class="hljs-string">"{{ lookup('vault', 'secret/service_name/prod/database', 'password') }}"</span></span></code> </pre> <br><p>  We make requests to vault only at the level group_vars / group_name.  This is convenient and allows you not to look for variables by role. </p><br><h4>  Chef: </h4><br><p>  Hashicorp in his blog described several ways to use secrets from Vault in their chef-kukbukah - <a href="https://www.hashicorp.com/blog/using-hashicorp-vault-with-chef.html">https://www.hashicorp.com/blog/using-hashicorp-vault-with-chef.html</a> </p><br><h4>  Puppet: </h4><br><p>  There is an excellent module for puppet <a href="https://github.com/jsok/hiera-vault">https://github.com/jsok/hiera-vault</a> , from the documentation for which the process of using secrets from Vault is clear. </p><br><h4>  Consul-template: </h4><br><p>  You must either have a token and Vault address in environment variables: </p><br><pre> <code class="hljs objectivec">$ <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> VAULT_ADDR=https:<span class="hljs-comment"><span class="hljs-comment">//vault.service.consul:8200 $ export VAULT_TOKEN=cb347ae0-9eb4-85d1-c556-df43e82be4b0</span></span></code> </pre> <br><p>  or add lines to config: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">vault</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> = <span class="hljs-string"><span class="hljs-string">"https://vault.service.consul:8200"</span></span> token = <span class="hljs-string"><span class="hljs-string">"cb347ae0-9eb4-85d1-c556-df43e82be4b0"</span></span> renew = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  and use the secrets in your templates: </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{with secret "secret/service_name/prod/database"}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{.Data.password}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{end}}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  See <a href="https://github.com/hashicorp/consul-template">readme for</a> more details. </p><br><p>  Thanks for your time, I hope this was helpful. <br>  Ready to answer your questions. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306812/">https://habr.com/ru/post/306812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306802/index.html">The digest of interesting materials for the mobile # 164 developer (July 25-31)</a></li>
<li><a href="../306804/index.html">Myths about FreeBSD</a></li>
<li><a href="../306806/index.html">"Working with a microscope": The data storage revolution</a></li>
<li><a href="../306808/index.html">Remote control server daemon do it yourself</a></li>
<li><a href="../306810/index.html">De-anonymize Windows users and get Microsoft and VPN account credentials</a></li>
<li><a href="../306814/index.html">Who cares about product bugs if it is successfully sold</a></li>
<li><a href="../306816/index.html">We write microservice on KoaJS 2 in the style of ES2017. Part I: Such Different Assynchrony</a></li>
<li><a href="../306820/index.html">Part 1. Platform DSS Universal Algorithms</a></li>
<li><a href="../306822/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ221 (July 24 - 31, 2016)</a></li>
<li><a href="../306824/index.html">DNA, new technologies and the human genome: Bioinformatics at ITMO University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>