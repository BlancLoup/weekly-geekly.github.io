<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Research of formats of game resources on the example of the game Dr. Riptide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I once asked myself to port this game to more modern platforms. But the game is understandably far from open source, and sometime back in 1994, develo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Research of formats of game resources on the example of the game Dr. Riptide</h1><div class="post__text post__text-html js-mediator-article"> I once asked myself to port this game to more modern platforms.  But the game is understandably far from open source, and sometime back in 1994, developers took as much as 25 bucks for it, and therefore all game resources needed to be either redrawn or gut a single game archive.  What I do. <br><a name="habracut"></a><br>  The game archive named RIPTIDE.DAT is a binary file of its own format.  By the way, it is not an archive, but a so-called pseudo-archive.  Those.  the files are stored in a single container without compression, and there is some primitive file system indicating how to access the files inside the container. <br>  If we open this file in any hex editor, we will see that the records of the files inside the container go at the very beginning, and then the binary data itself.  Actually, you need to know how many files the container contains and the recording format itself.  The first thing we pay attention to is the fixed length of the record, i.e.  from the beginning of the file name in one record, to the beginning in the next, for all records, the same and equal to 0x19 (25) bytes. <br><br><img src="https://habrastorage.org/storage2/72a/594/743/72a594743c58d176a264004803863570.png"><br><br>  However, the file name of the first record is slightly offset from the beginning of the file, so we will look at what is in front of it.  Since  usually in compilers using standard data of 1 (byte), 2 (word), 4 (dword), 8 (qword) bytes, we will divide the data in the mind into approximately blocks of this size.  Our attention is drawn to two dwords <code>0x00001A60</code> and <code>0x00013EEC</code> and word <code>0x010E</code> , because they can indicate the beginning of the data or the size of the data because it is smaller than the size of the file itself.  Offsets <code>0x00013EEC</code> and <code>0x000001E</code> are of no interest.  The first one points to the middle of some binary data, the second one goes to the middle of the file entries.  But <code>0x00001A60</code> indicates exactly the binary data located immediately after the last file entry.  Since this field refers to a file record, we look at the same field for the next record.  To do this, add to the offset the number 0x19, which was obtained above and which is the length of the file record: <code>0x0000000A+0x19=0x00000023</code> .  In the word for this offset is the number <code>0x0001594C</code> , which is also within the file size.  <code>0x00013EEC</code> that the number <code>0x00013EEC</code> from the first file entry is less than this number.  Check it out.  <code>0x00001A60+0x00013EEC=0x0001594C</code> .  We check it on other records and come to the conclusion that this field contains the size of the file located in the container. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><img src="https://habrastorage.org/storage2/90f/437/01b/90f43701b9a66122d590407fb03b005c.png"><br><br>  In principle, this is enough to get all the files from the container, but let's see what the other fields are for.  The numbers between the offset and the size are much larger than the size of the pseudo-archive itself, and therefore cannot be either an address or a size.  The first thing that comes to mind is that it is a checksum, because it would be logical to check the data in case the file is broken.  However, in this case, the developers acted differently.  These fields contain the time stamp of the files.  Why it took remains a mystery.  Using the example of the first file record <code>0x1CEF2292</code> turns into 07.15.1994 04:20:36 in DOS format. <br>  The last unsolved meaning remains only word 0x010E at the very beginning of the file.  It is most logical to assume that it contains the number of files in the container.  It is easy to check.  Take the offset to the first file from the first file record <code>0x00001A60</code> subtract 2 bytes on the word itself, and divide by the length of the file record in 0x19 bytes and get exactly <code>(00001A60-2)/19 = 010E</code> as required. <br>  As a result, it can be written in the form of structures in the C language as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _FILE_ITEM { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Size; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TimeStamp; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Offset; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Name[<span class="hljs-number"><span class="hljs-number">13</span></span>]; } FILE_ITEM, *PFILE_ITEM; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _HEADER { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Count; FILE_ITEM Files[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } HEADER, *PHEADER;</code> </pre><br>  After unpacking, we get 270 files with the extensions CMF, L, M, PCS, PCX, TXT, VOC. <br>  Of these extensions, there is no need to analyze TXT, PCX, which are quite common formats.  After a small search, there is no need to analyze CMF and VOC, which are sound files.  Remain L, M and PCS.  Honestly what PCS is used for, I did not find out, and there was no need for that. <br><br>  Analyzing the file names, we can assume that the L-format files contain graphics, and the M-format contains information about game levels-cards. <br><br><h5>  L format </h5><br>  Analyzing graphics, we rely on the fact that in any format somewhere the dimensions of the image must be indicated and the information itself displayed as graphics.  For animation, at least another number of frames is added and possible time intervals between frames. <br>  Again, open the file (and preferably several) in the hex editor.  What immediately catches the eye - for all graphics, which is displayed in the game statically, the first byte is the value 0x01, and in those that are animated more than one.  Thus, we make the assumption that this number indicates the number of frames in the file.  Then there are two bytes, after which in most cases there are zeros.  Suppose that this is the width and height.  Let's check - we multiply the first by the second and we get just the length of the file minus just those three bytes in the beginning. <br>  Since only one byte per color is used to describe a color, the colors are indicated by indices in the palette, and the maximum number of colors used at the same time is 256, which fully corresponds to the graphic modes of that time.  In 256-color modes, a palette of the following type is used: <br><br><img src="https://habrastorage.org/storage2/2f1/722/f11/2f1722f11b973df41402b8ecb9edbfaa.png"><br><br>  For files in which the number of frames is more than one, the sizes of each frame immediately follow the graphic data of the previous one. <br><br><img src="https://habrastorage.org/storage2/a70/304/d9d/a70304d9d972c5a60fd5e515a8efde70.png"><br><br>  In this figure, you can easily find the offset to the second frame.  We take the offset to the first frame 0x00000001 and first add 2 bytes allocated for the dimensions, and then 0x0C * 0x10 for the graphics.  We receive just <code>0x000000C3</code> . <br><br>  Remarkably, to save space, the size of the described frames may vary.  For transparent color, the value 0 is used. <br><br><h5>  M format </h5><br>  If before that the formats were simple, and were not difficult, and we knew about what to look for, now we have to act extremely intuitively. <br><br>  Again, open several M-files in the hex editor at once and try to identify similar regions. <br>  After a brief analysis, we note several main blocks in the file: <br><ul><li>  4 bytes at the very beginning of the file </li><li>  large data block sparse zeros </li><li>  a data block is always 0x8000 bytes with duplicate data strings, but almost no zero bytes </li><li>  a small block of data sparse zeros at the end of the file </li><li>  4 bytes at the very end of the file </li></ul><br><br>  The first thing that was noted was that the third block in all files is 0x8000 bytes in size.  The second thing to notice was that the second block is similar to the DWORD array, and its length is a multiple of the first four bytes of the word.  It was logical to assume that these two words set the dimensions of a two-dimensional array of dwords, followed by the array itself. <br>  We start to look at the values ‚Äã‚Äãof this array.  The low byte of any dword is in most cases non-zero, but the closer to the high-order digits, the less often non-zero values ‚Äã‚Äãoccur. <br>  It was decided to display this two-dimensional array as an image in which 2 bytes of the dword would indicate to fill the point or not. <br><br>  The result was the following picture: <br><img src="https://habrastorage.org/storage2/563/ab1/abf/563ab1abfeae93b30a0ea618a2fb00a3.png"><br><br>  Which roughly resembles map silhouettes, and at first I thought that this byte describes a map to check for collisions with walls. <br>  Then I decided to display in color the pixels for which the higher bytes of the dword are nonzero.  The third is red, the fourth is yellow. <br><br><img src="https://habrastorage.org/storage2/a6e/3c7/739/a6e3c7739cb0ca93d83e2ef7ab4feb13.png"><br><br>  The picture starts to clear up.  These values ‚Äã‚Äãdescribe static and dynamic game objects for which there is a separate graphics in the L-files. <br><br>  It became clear that the first byte of the dword stored the index number of the image in the tile map, which was supposed to be displayed in this place.  But since nowhere in the graphic files the tile maps were stored, an attempt was made to display that data block of 0x8000 bytes as an image.  Since I did not know the width of the image, a long strip of 1 pixel thickness was originally obtained.  Gradually reducing the image width, silhouettes of some map images began to appear.  With an image width of 8 pixels, I got a clear image with a pronounced square cut into tiles.  The result was an image with a width of 8 and a height of 4096 pixels. <br>  Some fragments will be presented in the picture below.  As the RGB color component, the byte value was used, so the image turned out in shades of gray. <br>  <i>By the way, in most cases all that you see in the pictures are screenshots of rendered HTML pages with huge tables, the cells of which were painted in their own color.</i>  <i>The very same parsing of binary files was carried out by means of PHP.</i>  <i>Not that I'm a pervert, it was just too lazy to look towards the libraries graphically.</i> <br><br><img src="https://habrastorage.org/storage2/01a/d68/c53/01ad68c53002ad4ef35b8001f54b0d05.png"><br><br>  If we divide the height of the tile map into 4096 pixels by 8, then we get 512, and not 256 pictures.  Thus, what I considered to be a mask for checking collisions with walls turned out to be the same image index in the map.  In this way, the developers killed two birds with one stone.  Those.  the lower 256 images for objects through which it is impossible to swim, the older ones through which it is possible.  And under the index reserved 2 bytes, not one. <br><br>  Render maps with overlaid tiles now looks like this: <br><br><img src="https://habrastorage.org/storage2/7bc/e3e/f80/7bce3ef80aabaa249687af3134d589f5.png"><br><br>  Now the whole map fits easily on one screen, and at the time of graphics with a resolution of 320x200 pixels, the background in the game smoothly scrolled. <br><br>  The purpose of the last two blocks in the format could not be found out intuitively. </div><p>Source: <a href="https://habr.com/ru/post/154781/">https://habr.com/ru/post/154781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154761/index.html">Interesting logic Random access iterators in STL containers</a></li>
<li><a href="../154767/index.html">Report on participation in Webit Congress 2012</a></li>
<li><a href="../154769/index.html">Kindle DX leaves the E-Ink reader?</a></li>
<li><a href="../154777/index.html">Internship PhD</a></li>
<li><a href="../154779/index.html">How we did the build</a></li>
<li><a href="../154785/index.html">Family Nexus</a></li>
<li><a href="../154795/index.html">How music affects productivity</a></li>
<li><a href="../154799/index.html">Metro style CSS / JS library, compatible with Twitter Bootstrap</a></li>
<li><a href="../154801/index.html">Guessing celebrity</a></li>
<li><a href="../154805/index.html">Cognitive radio - first experiences</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>