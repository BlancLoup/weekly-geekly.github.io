<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We create stub services for integration testing on Apache Camel (using Scala DSL)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the third article about using Scala in testing. Today we will consider examples of using Apache Camel to create test stubs, as well as informa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We create stub services for integration testing on Apache Camel (using Scala DSL)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/584/29f/e55/58429fe55a9d4f2c98e4cd75c66d5bbd.jpg" alt="image"><br><p><br>  This is the third article about using Scala in testing.  Today we will consider examples of using Apache Camel to create test stubs, as well as information system components. </p><br><p>  Often there is a need to emulate the work of any part of the system for integration testing, make a stub or write a simple integration component.  This can be a web service that returns the necessary answers, a test that fills the database, an application that reads a message from the queue and returns the result of processing, a generator of files and other components. </p><br><p>  For a one-time integration check, we would use a simple Java or Scala application, an Apache JMeter script, or SoapUI.  But we need a system that constantly works, responds to requests and does not require action from the tester ‚Äî launched and forgotten.  To solve this problem, we can create an application based on the Apache amel framework. <br><a name="habracut"></a>  Consider 5 examples: </p><br><ol><li>  Reading files in one encoding, writing to another; </li><li>  Request to the web service on a schedule and save the message in the data warehouse; </li><li>  Implementing a web service that returns a message depending on the GET parameter of the request; </li><li>  Reading a message from the queue and sending a message to the database; </li><li>  An example of routing by file contents. </li></ol><br><p>  Briefly describe the tools that are used to solve the problem.  Apache camel ( <a href="http://camel.apache.org/">http://camel.apache.org/</a> ) is a Java framework designed to implement the exchange of messages between individual applications, information system subsystems.  Implements an approach to the development of middleware Enterprise Integration Patterns (EIP).  It allows you to work with files, databases, queue managers, web services, and other components ‚Äî there are more than 240 types of them on the project's <a href="http://camel.apache.org/component.html">component</a> page.  Camel's application describes the so-called endpoints ‚Äî endpoints, and the rules for converting and routing messages between them. </p><br><p>  The Camel component implements the end point.  This is either the producer of the message (Producer) or the consumer (Consumer).  Some components can implement both types of points, for example, a message can be received from a file and recorded.  Some components implement only the message producer, for example, a timer, or a consumer, for example, output to a log. </p><br><p>  During the application, the message body and its headers are manipulated.  The procedure for working with Camel is as follows: </p><br><ol><li>  We describe the source of the message (file, queue, database, service, timer, etc.); </li><li>  We describe the rules for converting data and formats; </li><li>  We describe the recipient (s) of the message (file, queue, database, service, output to the console, etc.) and the routing logic; </li><li>  Run the application that listens to the source, and when a message appears, converts it and routes it to the recipients. </li></ol><br><p>  Different languages ‚Äã‚Äãare used to describe the rules for routing and converting messages.  For ourselves, we chose Scala DSL <a href="http://camel.apache.org/scala-dsl-eip.html">scala-dsl-eip</a> , because this language is well suited for simple and quick creation of component software.  For Scala, we use the <a href="http://www.scala-sbt.org/index.html">SBT</a> project build system. </p><br><p>  There is a great example of reading a message from a file and sending it to an http post request.  It is a bit outdated, but may be useful. </p><br><p>  " <a href="http">Http://www.lightbend.com/activator/template/camel-http</a> <br>  " <a href="http">Https://github.com/hilton/activator-camel-http#master</a> </p><br><p>  <strong>Preparatory work</strong> <br>  Let's create the project in idea on the basis of SBT.  An example of creating a project can be overlooked - <a href="https://habrahabr.ru/company/cit/blog/269293/">Implementation of monitoring and integration testing of an information system using Scalatest.</a>  <a href="https://habrahabr.ru/company/cit/blog/269293/">Part 1</a> <br>  In the file build.sbt we will write the settings </p><br><pre><code class="scala hljs">name := <span class="hljs-string"><span class="hljs-string">"camel-scaladsl"</span></span> version := <span class="hljs-string"><span class="hljs-string">"1.0"</span></span> scalaVersion := <span class="hljs-string"><span class="hljs-string">"2.11.8"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> camelVersion = <span class="hljs-string"><span class="hljs-string">"2.17.1"</span></span> libraryDependencies ++= <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-comment"><span class="hljs-comment">//   Camel "org.apache.camel" % "camel-core" % camelVersion, "org.apache.camel" % "camel-scala" % camelVersion, //    Camel   "org.apache.camel" % "camel-quartz" % camelVersion, "org.apache.camel" % "camel-spring-redis" % camelVersion, "org.apache.camel" % "camel-http" % camelVersion, "org.apache.camel" % "camel-jetty" % camelVersion, "org.apache.camel" % "camel-jms" % camelVersion, "org.apache.camel" % "camel-jdbc" % camelVersion, //    "ch.qos.logback" % "logback-classic" % "1.1.2", "org.slf4j" % "slf4j-api" % "1.7.7", //    xml   "org.scala-lang.modules" % "scala-xml_2.11" % "1.0.5", //   H2 "com.h2database" % "h2" % "1.4.192", "org.apache.commons" % "commons-dbcp2" % "2.1.1", //    activemq "org.apache.activemq" % "activemq-client" % "5.13.3" )</span></span></code> </pre> <br><p>  Add the src / main / resources file logback.xml file in which the logging level and message format are configured. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">appender</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STDOUT"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">encoder</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pattern</span></span></span><span class="hljs-tag">&gt;</span></span>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pattern</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">encoder</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">appender</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">level</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"INFO"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">appender-ref</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STDOUT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Otherwise, the default level will be DEBUG - too much information is displayed. </p><br><p>  <strong>Example 1</strong> <br>  Reading files in one encoding, writing to another.  This is a simple application that uses the <a href="http://camel.apache.org/file2.html">http://camel.apache.org/file2.html</a> component from the camel-core package.  It consists of an object that runs the FromFileToFileApp application and the FromFileToFileRoute class, which describes routes.  Class with routes can be put in a separate file. </p><br><p>  Contents of the src / main / scala / FromFileToFileApp.scala file </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.<span class="hljs-type"><span class="hljs-type">CamelContext</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.main.<span class="hljs-type"><span class="hljs-type">Main</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.scala.dsl.builder.{<span class="hljs-type"><span class="hljs-type">ScalaRouteBuilder</span></span>, <span class="hljs-type"><span class="hljs-type">RouteBuilderSupport</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromFileToFileApp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RouteBuilderSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Camel Main      val mainApp = new Main val context = mainApp.getOrCreateCamelContext //     mainApp.addRouteBuilder(new FromFileToFileRoute(context)) //  mainApp.run } class FromFileToFileRoute(context: CamelContext) extends ScalaRouteBuilder(context) { //         "inbox" """file:inbox?charset=utf-8""" ==&gt; { //       "outbox" to ("file:outbox?charset=Windows-1251") } }</span></span></code> </pre> <br><p>  In the FromFileToFileRoute class, there is no conversion to the contents of the message, no routing.  After launching the application, the folders ‚Äúinbox‚Äù, ‚Äúoutbox‚Äù will be automatically created in the project folder.  When you hit the "inbox" directory, the file is automatically read - disappears from the folder.  It then appears in the "outbox" directory in a different encoding.  At the same time, messages read by Camel will be stored in a separate subfolder in the "inbox" folder. </p><br><p>  <strong>Example 2</strong> <br>  Request a web service on a schedule and save the message in the data store.  In this example, the timer will collect data on the exchange rate and send it to Redis.  In order to execute actions on a message (write body and headers), there is a method "process".  For Redis, values ‚Äã‚Äãare sent using the "CamelRedis.Key" / "CamelRedis.Value" header pair.  We need to extract the message body that returns the HTTP GET request and make it a "CamelRedis.Value" header. </p><br><p>  The key will generate a unique, suitable for sorting - the current time in milliseconds. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.{<span class="hljs-type"><span class="hljs-type">Exchange</span></span>, <span class="hljs-type"><span class="hljs-type">CamelContext</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.main.<span class="hljs-type"><span class="hljs-type">Main</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.scala.dsl.builder.{<span class="hljs-type"><span class="hljs-type">ScalaRouteBuilder</span></span>, <span class="hljs-type"><span class="hljs-type">RouteBuilderSupport</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.data.redis.serializer.<span class="hljs-type"><span class="hljs-type">StringRedisSerializer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromHTTPToRedisApp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RouteBuilderSupport</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mainApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Main</span></span> <span class="hljs-comment"><span class="hljs-comment">//     stringSerializer  Redis mainApp.bind("stringSerializer",new StringRedisSerializer) val context = mainApp.getOrCreateCamelContext mainApp.addRouteBuilder(new FromHTTPToRedisRoute(context)) mainApp.run } class FromHTTPToRedisRoute (context: CamelContext) extends ScalaRouteBuilder(context) { //  ,      HTTP  """quartz:timerName?cron=0+0/1+*+*+*+?""" ==&gt; { //     log("  ") //    to("http://www.google.com/finance/info?q=CURRENCY%3aUSDRUB") //   -  edis,    process((exchange: Exchange) =&gt; { exchange.getOut.setHeader("CamelRedis.Key",System.currentTimeMillis()) exchange.getOut.setHeader("CamelRedis.Value",exchange.getIn.getBody(classOf[String])) }) //             //        (Body: [Body is null]]) to("log:FromHTTPToRedisApp") //    Redis // #stringSerializer -      to("""spring-redis://172.16.7.58:6379?serializer=#stringSerializer""") } }</span></span></code> </pre> <br><p>  To write to Redis from a remote host, permission may be needed.  For example, in the Redis console on the host where it is running, execute the command </p><br><pre> <code class="bash hljs">CONFIG SET protected-mode no</code> </pre> <br><p>  An example of displaying records in Redis is shown in the figure. </p><br><img src="https://habrastorage.org/files/fd0/460/5ca/fd04605ca8f84150b919677e834af308.png" alt="image"><br><p><br>  <strong>Example 3</strong> <br>  An implementation of a web service that returns a message depending on the GET parameter of the request.  In this example, using the Jetty component, we implement a simple HTTP server that receives a GET request with a parameter and returns xml with the parameter value or with an error. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JettyApp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RouteBuilderSupport</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mainApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Main</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context = mainApp.getOrCreateCamelContext mainApp.addRouteBuilder(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">JettyRoute</span></span>(context)) mainApp.run } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JettyRoute</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">context: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">CamelContext</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScalaRouteBuilder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">context</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      """jetty:http://0.0.0.0:1234/myapp/myservice""" ==&gt; { delay(2 seconds) process((exchange: Exchange) =&gt; { //    uuid  get    val uuidParam = exchange.getIn.getHeader("uuid") //     val pattern = """[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}""".r //        //    ,      uuid def responseText = uuidParam match { case null =&gt; "Uuid parameter not found" case pattern() =&gt; s"$uuidParam" case _ =&gt; s"Uuid parameter format is not valid" } //      xml exchange.getOut().setHeader(Exchange.CONTENT_TYPE,"text/xml; charset=utf-8") //  xml  . exchange.getOut().setBody(&lt;uuid&gt;{responseText}&lt;/uuid&gt;) //      s"&lt;uuid&gt;$responseText&lt;/uuid&gt;"   }) } }</span></span></code> </pre> <br><p>  Examples of requests for verification: <br>  " <a href="http://localhost:1234/myapp/myservice%3Fuuid%3D2a577d52-e5a1-4da5-96e5-bdba1f68e6f1">Http: // localhost: 1234 / myapp / myservice? Uuid = 2a577d52-e5a1-4da5-96e5-bdba1f68e6f1</a> ; <br>  " <a href="http://localhost:1234/myapp/myservice%3Fuuid%3D123">Http: // localhost: 1234 / myapp / myservice? Uuid = 123</a> ; <br>  ¬ª <a href="http://localhost:1234/myapp/myservice">Http: // localhost: 1234 / myapp / myservice</a> ; <br>  ¬ª <a href="http://localhost:1234/myapp/myservice%3Fguid%3D2a577d52-e5a1-4da5-96e5-bdba1f68e6f">Http: // localhost: 1234 / myapp / myservice? Guid = 2a577d52-e5a1-4da5-96e5-bdba1f68e6f</a> . </p><br><p>  Examples of service responses are presented in the figure. </p><br><img src="https://habrastorage.org/files/cf9/c9b/030/cf9c9b030a5f4e038d90d254ead5b2c6.png" alt="image"><br><p><br>  <strong>Example 4</strong> <br>  Reading a message from the queue and writing to the database.  Work with queues and DB was highlighted in a separate example.  Configuring these components requires a different approach.  If in the previous examples the setting was made using the parameters in the endpoint string, here you need to create an object in advance, make a component on its basis and use it further. </p><br><p>  For the database, create an instance of the org.apache.commons.dbcp2.BasicDataSource class and pass it the connection parameters.  For the queue, we create an instance of the javax.jms.ConnectionFactory class, in which we also save the connection parameters.  Next, a name for the end point is created for these components, and is used in the URI.  The difference is that the "camel-jdbc" component is used for the database, and a new component based on "camel-jms" is created for the queues. </p><br><p>  The table into which the record is inserted in the examples is created by the following query: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MESSAGETABLE( <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UUID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, DATETIME <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">65536</span></span>)</code> </pre> <br><p>  The following code will take messages from the queue, execute in the database a request to add a unique identifier, time and message body. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.text.<span class="hljs-type"><span class="hljs-type">SimpleDateFormat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.{<span class="hljs-type"><span class="hljs-type">UUID</span></span>, <span class="hljs-type"><span class="hljs-type">Date</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.component.jms.<span class="hljs-type"><span class="hljs-type">JmsComponent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.main.<span class="hljs-type"><span class="hljs-type">Main</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.scala.dsl.builder.{<span class="hljs-type"><span class="hljs-type">RouteBuilderSupport</span></span>, <span class="hljs-type"><span class="hljs-type">ScalaRouteBuilder</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.{<span class="hljs-type"><span class="hljs-type">CamelContext</span></span>, <span class="hljs-type"><span class="hljs-type">Exchange</span></span>} <span class="hljs-comment"><span class="hljs-comment">//       BasicDataSource import org.apache.commons.dbcp2.BasicDataSource //    -   ConnectionFactory  import org.apache.activemq.ActiveMQConnectionFactory object FromMQToDBApp extends App with RouteBuilderSupport { val mainApp = new Main //            val ds = new BasicDataSource ds.setDriverClassName("org.h2.Driver") ds.setUrl("jdbc:h2:./h2db") //  endpoint  ,       "h2db" mainApp.bind("h2db",ds) //      MQConnectionFactory val cf = new ActiveMQConnectionFactory("tcp://192.168.3.38:61616") //       mainApp.bind("amq-jms", JmsComponent.jmsComponentAutoAcknowledge(cf)) val context = mainApp.getOrCreateCamelContext mainApp.addRouteBuilder(new FromMQToDBAppRoute(context)) mainApp.run } //            class FromMQToDBAppRoute(context: CamelContext) extends ScalaRouteBuilder(context) { //    .   ,      - "amq-jms",      //         """amq-jms:queue:TESTQ""" ==&gt; { process((exchange: Exchange) =&gt; { //  uuid, / val uuid = UUID.randomUUID val time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) //    val messageBody = exchange.getIn.getBody(classOf[String]) //     exchange.getOut.setBody(s"INSERT INTO PUBLIC.MESSAGETABLE (ID, DATETIME, BODY) VALUES('$uuid', '$time', '$messageBody')") }) //      //   jdbc,    DataSource to("jdbc:h2db") } }</span></span></code> </pre> <br><p>  It should be remembered that when trying to write messages to a database larger than the field length (the table created by the query earlier has a field length of 65536 characters), an error will occur.  It can be solved by cutting the body to the desired size, or by adding an errorHandler (deadLetterChannel ("file: error")), which will send error-causing messages to the "error" folder. </p><br><p>  The example describes the interaction with the database H2.  For other databases you need to add the appropriate library to build.sbt, determine the name of the driver class, URL.  You may need other connection properties, for example, a username and password. </p><br><p>  Example description of connection details for working with Postgresql: </p><br><p>  Add library to build.sbt </p><br><pre> <code class="scala hljs"> libraryDependencies += <span class="hljs-string"><span class="hljs-string">"org.postgresql"</span></span> % <span class="hljs-string"><span class="hljs-string">"postgresql"</span></span> % <span class="hljs-string"><span class="hljs-string">"9.4.1207"</span></span></code> </pre> <br><p>  Implementation in class: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">BasicDataSource</span></span> { setDriverClassName(<span class="hljs-string"><span class="hljs-string">"org.postgresql.Driver"</span></span>) setUrl(conf.getString(<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://myhost:5432/mydb"</span></span>)) setUsername(conf.getString(<span class="hljs-string"><span class="hljs-string">"myusername"</span></span>)) setPassword(conf.getString(<span class="hljs-string"><span class="hljs-string">"mypassword"</span></span>)) }</code> </pre> <br><p>  Queuing is somewhat more complicated.  For some of the queue managers, libraries are not open to repository access.  In this case, * .jar files are used, which are stored in the project lib folder. </p><br><p>  For any queue manager, you need to create an appropriate connection factory object. <br>  For example, the code that provides interaction with IBM Websphere MQ, would be: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MQQueueConnectionFactory</span></span> { setHostName(<span class="hljs-string"><span class="hljs-string">"myhost"</span></span>) setPort(<span class="hljs-number"><span class="hljs-number">1414</span></span>) setTransportType(<span class="hljs-number"><span class="hljs-number">1</span></span>) setQueueManager(<span class="hljs-string"><span class="hljs-string">"myqmname"</span></span>) setChannel(<span class="hljs-string"><span class="hljs-string">"mychannel"</span></span>) }</code> </pre> <br><p>  For Oracle Weblogic Jms even more interesting.  If you create queues for how <a href="https://blogs.oracle.com/soaproactive/entry/how_to_create_a_simple">to Create a Simple JMS Queue in Weblogic Server 11g</a> , then the component declaration will be as follows: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> env = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> util.<span class="hljs-type"><span class="hljs-type">Hashtable</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] env.put(javax.naming.<span class="hljs-type"><span class="hljs-type">Context</span></span>.<span class="hljs-type"><span class="hljs-type">INITIAL_CONTEXT_FACTORY</span></span>, <span class="hljs-string"><span class="hljs-string">"weblogic.jndi.WLInitialContextFactory"</span></span>) env.put(javax.naming.<span class="hljs-type"><span class="hljs-type">Context</span></span>.<span class="hljs-type"><span class="hljs-type">PROVIDER_URL</span></span>, <span class="hljs-string"><span class="hljs-string">"t3://myhost:7001"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ic: <span class="hljs-type"><span class="hljs-type">InitialContext</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">InitialContext</span></span>(env) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connectionFactory = ic.lookup(<span class="hljs-string"><span class="hljs-string">"jms/TestConnectionFactory"</span></span>).asInstanceOf[<span class="hljs-type"><span class="hljs-type">QueueConnectionFactory</span></span>] <span class="hljs-comment"><span class="hljs-comment">//  jms/TestConnectionFactory - jndi  ConnectionFactory" mainApp.bind("ora-jms", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory))</span></span></code> </pre> <br><p>  and the endpoint URI will be in the following format: "ora-jms: queue: ./ TestJMSModule! TestJMSQueue", where ./ stands for the current server, "TestJMSModule" JNDI module name "TestJMSQueue" - JNDI queue name </p><br><p>  <strong>Example 5</strong> <br>  Routing the contents of the file.  In this example, consider the routing of a message depending on its content. </p><br><p>  Suppose that there is an xml message at the input, the processing of which depends on the value of the element ‚ÄúTo‚Äù. </p><br><p>  <code>&lt;To&gt;ActiveMQ&lt;/To&gt;</code> - you need to send to the queue, and <code>&lt;To&gt;H2&lt;/To&gt;</code> - process it in some way and send it to the database, <code>&lt;To&gt;someAdress&lt;/To&gt;</code> - process it in some other way. </p><br><p>  A ‚ÄúDestination‚Äù header will be added to the message with the name of the end point to which the message should be sent. </p><br><p>  If an error occurs while processing the message or there is no corresponding value in the routing table, then send the message to "direct: trash". </p><br><p>  The example uses the "???" rock construct, which allows replacing a non-existent block of code for successful compilation.  Instead of this block, you need to write processing logic. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.{<span class="hljs-type"><span class="hljs-type">Exchange</span></span>, <span class="hljs-type"><span class="hljs-type">CamelContext</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.scala.dsl.builder.<span class="hljs-type"><span class="hljs-type">ScalaRouteBuilder</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.xml.<span class="hljs-type"><span class="hljs-type">XML</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentOrientedRouting</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">context: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">CamelContext</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScalaRouteBuilder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">context</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    "direct:trash" errorHandler(deadLetterChannel("direct:trash")) //      Map val destMap = Map( "ActiveMQ" -&gt; "jms-amq:queue:inbox", "H2" -&gt; "direct:h2db", "someAdress" -&gt; "direct:outbox") //      val addRoutingAction = (exchange: Exchange) =&gt; { //    "To"  XML-,     val body = exchange.getIn.getBody(classOf[String]) val xmlBody = XML.loadString(body) val toValue = (xmlBody \\ "To").text //   endpoint,     -   "direct:trash" val dest = destMap.getOrElse(toValue,"direct:trash") //    exchange.getOut.setHeader("Destination", dest) } """direct:inbox1""" ==&gt; { process(addRoutingAction) //    "Destination" endpoint     recipients(_.in("Destination")) } //     endpoint """jms-amq:queue:inbox""" ==&gt; {???} """direct:h2db""" ==&gt; { process((exchange: Exchange) =&gt; {???}) to ("jdbc:h2db") } """direct:outbox""" ==&gt; { //         to("file:someFile", "log:Somelog") } """direct:trash""" ==&gt; {???} }</span></span></code> </pre> <br><p>  The examples show how you can implement a small application for our purposes.  Consider additional aspects.  allowing to make the development and maintenance of the application more convenient. </p><br><p>  To configure the application, we use the Typesafe <a href="https://github.com/typesafehub/config">library</a> in order not to stitch the connection parameters in the code, but to store it in the configuration file. </p><br><p>  Add to build.sbt: </p><br><pre> <code class="scala hljs">libraryDependencies += <span class="hljs-string"><span class="hljs-string">"com.typesafe"</span></span> % <span class="hljs-string"><span class="hljs-string">"config"</span></span> % <span class="hljs-string"><span class="hljs-string">"1.3.0"</span></span></code> </pre> <br><p>  in the src / main / resources folder, create an application.conf file in which we set up the settings and call them from the code. </p><br><p>  The application is launched using the sbt run command.  In some cases it may be uncomfortable. <br>  It is possible to create a jar file using the sbt-assembly plugin <a href="https://github.com/sbt/sbt-assembly">https://github.com/sbt/sbt-assembly</a> to run with the java ‚Äìjar camelapp.jar command.  The .jar file will contain all the dependencies, so the size will be large, but the launch will take place immediately, without downloading the components. </p><br><p>  To run in the background is convenient to use the nohup application. </p><br><p>  Create a script to run in the folder that is included in the $ PATH environment variable to call by name from any directory.  For example, in / usr / local / bin /.  Script to run: </p><br><p>  / usr / local / bin / camelstart </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash /usr/bin/nohup java -jar /opt/camelapp.jar&amp;</span></span></code> </pre> <br><p>  To stop: <br>  / usr / local / bin / camelstop </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash pkill -f camelapp</span></span></code> </pre> <br><p>  The launch of the application is done with the camelstart command, the stop is camelstop. </p><br><p>  We can highlight some pros and cons of using Apache Camel. <br>  Pros: </p><br><ul><li>  Quick application implementation; </li><li>  A large number of finished components; </li><li>  Multithreading, parallel processing of messages out of the box; </li><li>  Ability to select the description method in the form of XML or one of DSL; </li></ul><br><p>  Minuses: </p><br><ul><li>  Each component has its own logic of work, it takes time to understand; </li><li>  There is a threshold for entry; </li></ul><br><p>  In addition, since Apache Camel runs on the JVM, applications built on it are inherent in the pros and cons of this platform. </p><br><p>  The experience of using Apache Camel in conjunction with ScalaDSL in our company has shown its effectiveness in creating plugs, integration components and sometimes load tests. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306792/">https://habr.com/ru/post/306792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306782/index.html">Churn</a></li>
<li><a href="../306784/index.html">Shannon Communications Model (translation of Great Principles of Computing)</a></li>
<li><a href="../306786/index.html">Resource allocation in large high performance clusters. Lecture in Yandex</a></li>
<li><a href="../306788/index.html">How to display dynamic unloading from the database on Atlassian Confluence pages?</a></li>
<li><a href="../306790/index.html">Expanded commentary on the articles "Systematization of publications in the web"</a></li>
<li><a href="../306794/index.html">July update of Microsoft Azure and VNET peering</a></li>
<li><a href="../306796/index.html">Introducing 3CX Phone System v15 SP1 and test the system on a mini PC instead of a server</a></li>
<li><a href="../306798/index.html">How many neurons do you need to recognize a bridge summary?</a></li>
<li><a href="../306802/index.html">The digest of interesting materials for the mobile # 164 developer (July 25-31)</a></li>
<li><a href="../306804/index.html">Myths about FreeBSD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>