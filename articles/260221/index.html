<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A bit about unit testing and external APIs in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unit testing is one of the integral parts of the development process, and it becomes more complicated and contradictory if the main task of your code ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A bit about unit testing and external APIs in PHP</h1><div class="post__text post__text-html js-mediator-article">  Unit testing is one of the integral parts of the development process, and it becomes more complicated and contradictory if the main task of your code is to send requests to external APIs and process responses.  A lot of copies are broken about the topic, what should be the testing of the code tied to external sources, and where is the line between testing your own code and other people's API. <br><br>  At this stage, developers have to decide which requests to send to a remote server, and which ones to simulate locally.  There are many solutions for sending requests, and for their simulation.  In my post, I‚Äôll tell you how to do both using the Guzzle HTTP client. <br><br><img src="https://habrastorage.org/files/8b2/d17/0e4/8b2d170e4de74b9d91d7fa160656b8ad.jpg"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A few words about the product.  <a href="http://guzzlephp.org/">Guzzle</a> is an extensible HTTP client for PHP.  He is in active development.  Over the past year, two older versions.  Version 4.0.0 was released in March 2014, and May 2015 brought the release of version 6.0.0.  The transition between them can cause certain difficulties, because  developers in each release change the namespace and some of the principles of work. <br><br>  In addition, it may be difficult to combine various manuals, even written quite recently.  However, if you properly google and read the native documentation, you can finally find an acceptable solution. <br><br><h4>  Installation </h4><br>  Guzzle is installed as a <a href="https://getcomposer.org/">Composer</a> package.  The installation file composer.json for our needs is as follows: <br><br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"our-guzzle-test"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Guzzle setup API testing"</span></span>, <span class="hljs-string"><span class="hljs-string">"minimum-stability"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev"</span></span>, <span class="hljs-string"><span class="hljs-string">"require"</span></span>: { <span class="hljs-string"><span class="hljs-string">"guzzlehttp/guzzle"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.*"</span></span>, <span class="hljs-string"><span class="hljs-string">"guzzlehttp/log-subscriber"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"monolog/monolog"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"guzzlehttp/oauth-subscriber"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span> } }</code> </pre> <br>  For some of our tasks, you need to use 3-step OAuth authentication, so I had to stop at Guzzle 5.3.  At the time of writing, this is the latest version that supports the plugin oauth-subsctiber.  However, if you do not need OAuth, you can try to adapt the solution for version 6. *.  Naturally, first check with the documentation. <br><br><h4>  The first steps </h4><br>  First of all, you will need to connect the Composer package startup file: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">"path_to_composer_files/vendor/autoload.php"</span></span>;</code> </pre><br>  In addition, we need to specify which namespaces will be used by our scripts.  In my case, different files are responsible for sending requests and saving the results.  If necessary, you can combine them. <br><br>  <b>Sending requests and logging</b> <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   use GuzzleHttp\Client; //  OAuth use GuzzleHttp\Subscriber\Oauth\Oauth1; //  use GuzzleHttp\Subscriber\Log\LogSubscriber; use Monolog\Logger; use Monolog\Handler\StreamHandler; use GuzzleHttp\Subscriber\Log\Formatter;</span></span></code> </pre><br>  <b>Save and Simulate</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">GuzzleHttp</span></span>\<span class="hljs-title"><span class="hljs-title">Subscriber</span></span>\<span class="hljs-title"><span class="hljs-title">Mock</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">GuzzleHttp</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">GuzzleHttp</span></span>\<span class="hljs-title"><span class="hljs-title">Stream</span></span>\<span class="hljs-title"><span class="hljs-title">Stream</span></span>;</code> </pre><br><h4>  Sending requests </h4><br>  To determine the current mode of operation, we use two global variables: <br><ul><li>  <b><i>$ isUnitTest</i></b> determines whether the system is operating normally or in automatic testing mode; </li><li>  <b><i>$ recordTestResults</i></b> tells the system to save the data of all requests and responses. </li></ul><br><h5>  OAuth procedures </h5><br>  Guzzle allows you to use the same code for OAuth authorization itself (according to different schemes), and for sending signed requests. <br><br><pre> <code class="php hljs"> $oauthKeys = [ <span class="hljs-string"><span class="hljs-string">'consumer_key'</span></span> =&gt; OAUTH_CONSUMER_KEY, <span class="hljs-string"><span class="hljs-string">'consumer_secret'</span></span> =&gt; OAUTH_CONSUMER_SECRET, ]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($authStatus == <span class="hljs-string"><span class="hljs-string">'preauth'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   3- OAuth  $oauthKeys['token'] = $oauth_request_token; $oauthKeys['token_secret'] = $oauth_request_token_secret; } elseif ($authStatus == 'auth') { //   $oauthKeys['token'] = $oauth_access_token; $oauthKeys['token_secret'] = $oauth_access_token_secret; } $oauth = new Oauth1($oauthKeys);</span></span></code> </pre><br>  The <b><i>OAUTH_CONSUMER_KEY</i></b> and <b><i>OAUTH_CONSUMER_SECRET constants</i></b> are a pair of keys provided by your API provider.  Depending on the current authorization status, a token and its private key may be required.  For more information about OAuth, you can refer to relevant sources (for example, the <a href="http://oauthbible.com/">OAuth Bible</a> ). <br><br><h5>  HTTP client initialization </h5><br>  In this step, we determine whether we need to send a real request or receive a locally stored response. <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($isUnitTest) || !<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($recordTestResults)) { $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'base_url'</span></span> =&gt; $apiUrl, <span class="hljs-string"><span class="hljs-string">'defaults'</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'auth'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'oauth'</span></span>]]); $client-&gt;getEmitter()-&gt;attach($oauth); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $mock = getResponseLocally($requestUrl, $requestBody); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client(); $client-&gt;getEmitter()-&gt;attach($mock); }</code> </pre><br><ul><li>  <b><i>$ apiUrl</i></b> - the base path of your API </li><li>  <b><i>'defaults' =&gt; ['auth' =&gt; 'oauth'] is</i></b> needed only if you send OAuth requests.  The same is true for <i>$ client-&gt; getEmitter () -&gt; attach ($ oauth);</i> </li><li>  <b><i>$ requestUrl</i></b> - the full path of the request (including the base path) </li><li>  <b><i>$ requestBody</i></b> request body (may be empty) </li></ul><br>  I will describe the work of the <i>getResponseLocally ()</i> function a little later.  If you want to add logging in development mode, enter another global variable <i>$ inDevMode</i> and add the following code: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($inDevMode) { $log = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logger(<span class="hljs-string"><span class="hljs-string">'guzzle'</span></span>); $log-&gt;pushHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamHandler(<span class="hljs-string"><span class="hljs-string">'/tmp/guzzle.log'</span></span>)); $subscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogSubscriber($log, Formatter::SHORT); $client-&gt;getEmitter()-&gt;attach($subscriber); }</code> </pre><br><h5>  Sending requests and receiving responses </h5><br>  At this stage we are ready to send the request.  I have simplified the saving algorithm for myself and do not write down the HTTP response code.  If you need it, it is easy to modify the code. <br><br><pre> <code class="php hljs"> $request = $client-&gt;createRequest($method, $requestUrl, [<span class="hljs-string"><span class="hljs-string">'headers'</span></span> =&gt; $requestHeaders, <span class="hljs-string"><span class="hljs-string">'body'</span></span> =&gt; $requestBody, <span class="hljs-string"><span class="hljs-string">'verify'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]); $output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> stdClass(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $response = $client-&gt;send($request, [<span class="hljs-string"><span class="hljs-string">'timeout'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>]); $responseRaw = (string)$response-&gt;getBody(); $headers = $response-&gt;getHeaders(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { $responseRaw = $e-&gt;getResponse(); $headers = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($recordTestResults) { saveResponseLocally($requestUrl, $requestBody, $headers, $responseRaw); }</code> </pre><br><ul><li>  <b><i>$ method</i></b> - HTTP request method (GET, POST, PUT etc) </li><li>  <b><i>$ requestHeaders</i></b> - request headers (if needed) </li><li>  <b><i>$ headers</i></b> - response headers </li><li>  <b><i>$ responseRaw</i></b> - raw response (you can get the XML, JSON or whatever) </li></ul><br><h4>  Saving and Simulating Responses </h4><br>  Local copies of responses can be saved to files or a database.  Whichever option you choose, it is necessary to unambiguously match the request with the answer.  I decided to use for this purpose MD5 hashes of the <b><i>$ requestUrl</i></b> and <b><i>$ requestBody variables</i></b> .  The array of headers is parked in JSON and together with the response body is saved as a php file, which can be easily uploaded with <i>require ()</i> . <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveResponseLocally</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($requestUrl, $requestBody, $headers_source, $response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_string($requestBody)) { $requestBody = print_r($requestBody, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } $filename = md5($requestUrl) . md5($requestBody); $headers = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($headers_source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($value)) { $headers[$name] = $value[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Guzzle returns some header values as 1-element array } else { $headers[$name] = $value; } } $response = htmlspecialchars($response, ENT_QUOTES); $headers_json = json_encode($headers); $data = "</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?</span></span></span><span class="hljs-comment">\n\$data = array('headers_json' =&gt; '$headers_json', \n'response' =&gt; '$response');"; $requestData = "</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?</span></span></span><span class="hljs-comment">\n\$reqdata = array('url' =&gt; '$requestUrl', \n'body' =&gt; '$requestBody');"; file_put_contents("path_of_your_choice/localResponses/{$filename}.inc", $data); file_put_contents("path_of_your_choice/localResponses/{$filename}_req.inc", $requestData); }</span></span></code> </pre><br>  In fact, for further work, you do not need to create and save <b><i>$ requestData</i></b> .  However, this feature can be useful for debugging. <br><br>  As I mentioned, I do not save the response code, so I create all the answers with code 200. If your error handling system requires a specific HTTP code, you can easily add the appropriate feature. <br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseLocally</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($requestUrl, $requestBody)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_string($requestBody)) { $requestBody = print_r($requestBody, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } $filename = md5($requestUrl) . md5($requestBody) . <span class="hljs-string"><span class="hljs-string">'.inc'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_exists(<span class="hljs-string"><span class="hljs-string">"path_of_your_choice/localResponses/{$filename}"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"path_of_your_choice/localResponses/{$filename}"</span></span>); $data[<span class="hljs-string"><span class="hljs-string">'headers'</span></span>] = (<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>)json_decode($data[<span class="hljs-string"><span class="hljs-string">'headers_json'</span></span>]); $mockResponse = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $mockResponse-&gt;setHeaders($data[<span class="hljs-string"><span class="hljs-string">'headers'</span></span>]); $separator = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n"</span></span>; $bodyParts = explode($separator, htmlspecialchars_decode($data[<span class="hljs-string"><span class="hljs-string">'response'</span></span>]), ENT_QUOTES); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count($bodyParts) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { $mockResponse-&gt;setBody(Stream::factory($bodyParts[count($bodyParts) - <span class="hljs-number"><span class="hljs-number">1</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $mockResponse-&gt;setBody(Stream::factory(htmlspecialchars_decode($data[<span class="hljs-string"><span class="hljs-string">'response'</span></span>]))); } $mock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock([ $mockResponse ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $mock; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre><br><h4>  In conclusion... </h4><br>  I described only one of the options for simulating API responses and saving time in unit testing (in my case, testing with local answers takes about 10-20 times less time than ‚Äúcombat‚Äù requests).  Guzzle provides a <a href="http://guzzle.readthedocs.org/en/v5/testing.html">couple</a> more <a href="http://guzzle.readthedocs.org/en/v5/testing.html">ways to solve</a> this problem. <br><br>  If you need more complex testing, you can even create a local API simulator that will create the answers you need.  Whichever way you choose, you can always be sure that you save a lot of time and avoid sending too many requests to your API partners. <br><br><img src="https://habrastorage.org/files/855/bec/74f/855bec74f5de43ed99d475931be9e5f3.jpg"></div><p>Source: <a href="https://habr.com/ru/post/260221/">https://habr.com/ru/post/260221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260201/index.html">Upgrade to Middle PHP developer in 3 months</a></li>
<li><a href="../260213/index.html">Introducing OsmocomBB: 0x03 Software</a></li>
<li><a href="../260215/index.html">ReactOS has significantly improved support for themes.</a></li>
<li><a href="../260217/index.html">Async / await and the implementation mechanism in C # 5.0</a></li>
<li><a href="../260219/index.html">Semishagovy test logo Paul Rand</a></li>
<li><a href="../260223/index.html">Why Go is doomed to success (updated)</a></li>
<li><a href="../260225/index.html">Vulnerability in Mail in iOS 8.3</a></li>
<li><a href="../260227/index.html">9 anti-patterns every programmer should know about</a></li>
<li><a href="../260229/index.html">The digest of interesting materials for the mobile developer # 107 (on June 8-14)</a></li>
<li><a href="../260233/index.html">When does not help the DAC. Digital potentiometers in detail. Part one</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>