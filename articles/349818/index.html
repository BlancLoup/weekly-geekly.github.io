<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we began to talk about how you can implement asynchronous processing of incoming HTTP requests, within which you need to perf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/349728/">In the previous article,</a> we began to talk about how you can implement asynchronous processing of incoming HTTP requests, within which you need to perform asynchronous outgoing HTTP requests.  We considered the simulation of a third-party server implemented in C ++ and RESTinio, which takes a long time to respond to HTTP requests.  Now we will talk about how you can implement the issuance of asynchronous outgoing HTTP requests to this server using <a href="https://curl.haxx.se/libcurl/c/curl_multi_perform.html">curl_multi_perform</a> . <br><br><h1>  A few words about how to use curl_multi </h1><br>  <a href="https://curl.haxx.se/libcurl/c/">The libcurl library is</a> widely known in the world of C and C ++.  But it is probably the most widely known as so-called.  <a href="https://curl.haxx.se/libcurl/c/libcurl-easy.html">curl_easy</a> .  Using curl_easy is simple: first call curl_easy_init, then call curl_easy_setopt several times, then curl_easy_perform once.  And, in general, everything. <br><br>  In the context of our curl_easy story, the bad thing is that this is a synchronous interface.  Those.  every call to curl_easy_perform blocks the worker thread that caused it until the completion of the query.  What categorically does not suit us, since  we do not want to block our working threads while the slow third-party server deigns to respond.  From libcurl, we need asynchronous work with HTTP requests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And libcurl allows you to work with HTTP requests asynchronously through the so-called.  <a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html">curl_multi</a> .  When using curl_multi, the programmer still calls curl_easy_init and curl_easy_setopt to prepare each of his HTTP requests.  But it does not call curl_easy_perform.  Instead, the user creates an instance of curl_multi through a call to <a href="https://curl.haxx.se/libcurl/c/curl_multi_init.html">curl_multi_init</a> .  Then it adds to this curl_multi-instance prepared curl_easy-instances via <a href="https://curl.haxx.se/libcurl/c/curl_multi_add_handle.html">curl_multi_add_handle</a> and ... <br><a name="habracut"></a><br>  But then curl_multi gives the programmer a choice: <br><br><ul><li>  or call the <a href="https://curl.haxx.se/libcurl/c/curl_multi_perform.html">curl_multi_perform</a> call, </li><li>  or call the <a href="https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html">curl_multi_socket_action</a> call </li></ul><br>  followed by <a href="https://curl.haxx.se/libcurl/c/curl_multi_info_read.html">curl_multi_info_read</a> to determine which requests have ended. <br><br>  We show the use of both approaches.  This article will discuss working with curl_multi_perform, and in the final article in the series about working with curl_multi_socket_action. <br><br><h1>  What will be discussed today? </h1><br>  In the last article, we outlined a small demonstration consisting of delay_server and several bridge_servers, as well as detailed implementation of delay_server.  Today we will talk about bridge_server_1, which performs requests to delay_server via curl_multi_perform. <br><br><h1>  bridge_server_1 </h1><br><h2>  What does bridge_server_1 do? </h2><br>  bridge_server_1 accepts HTTP GET requests for URLs like / data? year = YYYY &amp; month = MM &amp; day = DD.  Each received request is transformed into an HTTP GET request to delay_server.  When a response comes from delay_server, this response is appropriately transformed in response to the original HTTP GET request. <br><br>  If you start delay_server first: <br><br><pre>  delay_server -p 4040 </pre><br>  then run bridge_server_1: <br><br><pre>  bridge_server_1 -p 8080 -P 4040 </pre><br>  and then query the bridge_server_1, then you can get the following: <br><br><pre>  curl -4 -v "http: // localhost: 8080 / data? year = 2018 &amp; month = 02 &amp; day = 25"
 * Trying 127.0.0.1 ...
 * TCP_NODELAY set
 * Connected to localhost (127.0.0.1) port 8080 (# 0)
 &gt; GET / data? Year = 2018 &amp; month = 02 &amp; day = 25 HTTP / 1.1
 &gt; Host: localhost: 8080
 &gt; User-Agent: curl / 7.58.0
 &gt; Accept: * / *
 &gt;
 &lt;HTTP / 1.1 200 OK
 &lt;Connection: keep-alive
 &lt;Content-Length: 111
 &lt;Server: RESTinio hello world server
 &lt;Date: Sat, Feb 24, 2018 10:15:41 GMT
 &lt;Content-Type: text / plain;  charset = utf-8
 &lt;
 Request processed.
 Path: / data
 Query: year = 2018 &amp; month = 02 &amp; day = 25
 Response:
 ===
 Hello world!
 Pause: 4376ms.<font></font>
<font></font>
 ===
 * Connection # 0 to host localhost left intact </pre><br>  bridge_server_1 takes the values ‚Äã‚Äãof the parameters year, month and day from the URL and transmits them unchanged to the delay_server.  Therefore, if the value of one of the parameters is set incorrectly, then bridge_server_1 will transmit this incorrect value to delay_server and the consequences will be visible in the response to the initial request: <br><br><pre>  curl -4 -v "http: // localhost: 8080 / data? year = 2018 &amp; month = Feb &amp; day = 25"
 * Trying 127.0.0.1 ...
 * TCP_NODELAY set
 * Connected to localhost (127.0.0.1) port 8080 (# 0)
 &gt; GET / data? Year = 2018 &amp; month = Feb &amp; day = 25 HTTP / 1.1
 &gt; Host: localhost: 8080
 &gt; User-Agent: curl / 7.58.0
 &gt; Accept: * / *
 &gt;
 &lt;HTTP / 1.1 200 OK
 &lt;Connection: keep-alive
 &lt;Content-Length: 81
 &lt;Server: RESTinio hello world server
 &lt;Date: Sat, Feb 24, 2018 10:19:55 GMT
 &lt;Content-Type: text / plain;  charset = utf-8
 &lt;
 Request failed.
 Path: / data
 Query: year = 2018 &amp; month = Feb &amp; day = 25
 Response code: 404
 * Connection # 0 to host localhost left intact </pre><br>  bridge_server_1 accepts only HTTP GET requests and only for URL / data.  All other requests bridge_server_1 rejects. <br><br><h2>  How does bridge_server_1 work? </h2><br>  bridge_server_1 is a C ++ application that runs on two threads.  RESTinio runs on the main thread (i.e., the embedded HTTP server runs on the main thread).  And on the second thread, which is started from the main () function, manipulations are performed with curl_multi (we will call this thread the curl thread).  The transfer of information from the main thread to the working curl thread is carried out through a simple homemade thread-safe container. <br><br>  When RESTinio accepts a new HTTP request, this request is sent to the RESTinio callback set at startup.  The URL of the request is checked there and, if it is a request of interest, an object is created with a description of the request received.  The created object is pushed into a thread-safe container, from which this object will be extracted by a working curl thread. <br><br>  The working curl thread periodically retrieves objects with descriptions of received requests from the thread-safe container.  For each received request, a corresponding curl_easy instance is created on this working thread.  This instance is registered with the curl_multi instance. <br><br>  The working curl thread performs processing through periodic calls to curl_multi_perform, <br>  <a href="https://curl.haxx.se/libcurl/c/curl_multi_wait.html">curl_multi_wait</a> and curl_multi_info_read, but more on this below.  When the curl thread detects that the next request has been processed (that is, a response from delay_server is received), a response is also immediately generated to the original incoming HTTP request.  Those.  it turns out that the incoming HTTP request is received on the main thread of the application, then it is sent to the curl thread, where the response to the received incoming HTTP request is formed. <br><br><h2>  Code parsing bridge_server_1 </h2><br>  Analysis of the bride_server_1 code will be performed as follows: <br><br><ul><li>  first, the main () function will be shown with the necessary explanations; </li><li>  then the code for several functions that are related to RESTinio will be shown; </li><li>  then the code that works with curl_multi will be parsed. </li></ul><br>  A number of points, for example, related to RESTinio or parsing command line arguments, were touched upon <a href="https://habrahabr.ru/post/349728/">in the previous article</a> , so we will not dwell on them here in detail. <br><br><h3>  Main () function </h3><br>  Here is the main () function code for bridge_server_1: <br><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> ** argv) { try { const auto cfg = parse_cmd_line_args(argc, argv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.help_requested_) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; //        //  . request_info_queue_t queue; //    HTTP-. auto actual_handler = [&amp;cfg, &amp;queue](auto req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(cfg.config_, queue, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(req)); }; //    ,     //      curl_multi_perform. std::thread curl_thread{[&amp;queue]{ curl_multi_work_thread(queue); }}; //         //    . auto curl_thread_stopper = cpp_util_3::at_scope_exit([&amp;] { queue.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(); curl_thread.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(); }); //     HTTP-. //     ,   //    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.config_.tracing_) { //  ,    ,   //     . struct traceable_server_traits_t : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> restinio::default_single_thread_traits_t { //     . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> logger_t = restinio::single_threaded_ostream_logger_t; }; //         . run_server&lt;traceable_server_traits_t&gt;( cfg.config_, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,     . run_server&lt;restinio::default_single_thread_traits_t&gt;( cfg.config_, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } // ,     . } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  A significant part of main () - and repeats main () from the delay_server described in the previous article.  The same analysis of command line arguments.  The same actual_handler variable for storing lambda functions with a call to a real HTTP request handler.  The same run_server call with the choice of a specific type of Traits depending on whether the HTTP server trace should be used or not. <br><br>  But there are a few differences. <br><br>  First, we need a thread-safe container to transfer information about the received requests from the main thread to the curl thread.  This container will use the variable queue, having the type request_info_queue_t.  More on the implementation of the container, we consider below. <br><br>  Secondly, we need to run an additional worker thread, on which we will work with curl_multi.  And we also need to stop this additional working thread when we are going out of main () - and get out.  All this happens here in these lines: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      curl_multi_perform. std::thread curl_thread{[&amp;queue]{ curl_multi_work_thread(queue); }}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . auto curl_thread_stopper = cpp_util_3::at_scope_exit([&amp;] { queue.close(); curl_thread.join(); });</span></span></code> </pre> <br>  We hope that the code to start the thread does not cause questions.  And to complete the working thread, we need to perform two actions: <br><br>  1. Give a signal to the working thread to complete its work.  This is done through the queue.close () operation. <br>  2. Wait until the end of the working thread.  This is due to curl_thread.join (). <br><br>  Both of these actions in the form of lambda are passed to the auxiliary function at_scope_exit () from our <a href="">utilitarian library</a> .  This <a href="">at_scope_exit ()</a> is just an uncomplicated analogue of such well-known things as BOOST_SCOPE_EXIT from Boost, defer from Go, and scope (exit) from D. D. With at_scope_exit () we automatically terminate the curl thread, regardless of what reason we exit main (). <br><br><h4>  Configuration and analysis of command line arguments </h4><br>  If anyone is interested, then below you can see how the configuration for bridge_server_1 appears.  And how this configuration is formed as a result of parsing command line arguments.  Everything is very similar to how we did in delay_server, so the details are hidden under the spoiler so as not to distract attention. <br><br><div class="spoiler">  <b class="spoiler_title">The config_t structure and the parse_cmd_line_args () function</b> <div class="spoiler_text"><pre> <code class="hljs lua">// ,   . struct config_t { // ,       . std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> address_{<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>}; // ,    . std::uint16_t port_{<span class="hljs-number"><span class="hljs-number">8080</span></span>}; // ,      . std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> target_address_{<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>}; // ,      . std::uint16_t target_port_{<span class="hljs-number"><span class="hljs-number">8090</span></span>}; //    ? bool tracing_{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}; }; //    . //     . auto parse_cmd_line_args(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> ** argv) { struct result_t { bool help_requested_{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}; config_t config_; }; result_t result; //     . using namespace clara; auto cli = Opt(result.config_.address_, <span class="hljs-string"><span class="hljs-string">"address"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-a"</span></span>][<span class="hljs-string"><span class="hljs-string">"--address"</span></span>] (<span class="hljs-string"><span class="hljs-string">"address to listen (default: localhost)"</span></span>) | Opt(result.config_.port_, <span class="hljs-string"><span class="hljs-string">"port"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-p"</span></span>][<span class="hljs-string"><span class="hljs-string">"--port"</span></span>] (fmt::<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(<span class="hljs-string"><span class="hljs-string">"port to listen (default: {})"</span></span>, result.config_.port_)) | Opt(result.config_.target_address_, <span class="hljs-string"><span class="hljs-string">"target address"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-T"</span></span>][<span class="hljs-string"><span class="hljs-string">"--target-address"</span></span>] (fmt::<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(<span class="hljs-string"><span class="hljs-string">"target address (default: {})"</span></span>, result.config_.target_address_)) | Opt(result.config_.target_port_, <span class="hljs-string"><span class="hljs-string">"target port"</span></span>)[<span class="hljs-string"><span class="hljs-string">"-P"</span></span>][<span class="hljs-string"><span class="hljs-string">"--target-port"</span></span>] (fmt::<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(<span class="hljs-string"><span class="hljs-string">"target port (default: {})"</span></span>, result.config_.target_port_)) | Opt(result.config_.tracing_)[<span class="hljs-string"><span class="hljs-string">"-t"</span></span>][<span class="hljs-string"><span class="hljs-string">"--tracing"</span></span>] (<span class="hljs-string"><span class="hljs-string">"turn server tracing ON (default: OFF)"</span></span>) | Help(result.help_requested_); //  ... auto parse_result = cli.parse(Args(argc, argv)); // ...      . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!parse_result) throw std::runtime_error(<span class="hljs-string"><span class="hljs-string">"Invalid command line: "</span></span> + parse_result.errorMessage()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result.help_requested_) std::cout &lt;&lt; cli &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br></div></div><br><h3>  Interaction details between RESTinio and curl parts </h3><br>  Information about the received incoming HTTP request is transferred from the RESTinio-part of bridge_server_1 to the curl-part via instances of the following structure: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ,        curl_multi_perform /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      . struct request_info_t { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ URL,     . const std::string url_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,         . restinio::request_handle_t original_req_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     curl-. CURLcode curl_code_{CURLE_OK}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . long response_code_{0}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      . std::string reply_data_; request_info_t(std::string url, restinio::request_handle_t req) : url_{std::move(url)}, original_req_{std::move(req)} {} };</span></span></code> </pre> <br>  Initially, only two fields are filled in it: url_ and req_.  But after the request is processed by the curl thread, the rest of the fields will be filled.  First of all, this is the curl_code_ field.  If it contains CURLE_OK, then the response_code_ and reply_data_ fields will also receive their values. <br><br>  To transfer request_info_t instances between worker threads, use the following homemade thread-safe container: <br><br><pre> <code class="hljs pgsql">//   thread-safe     //    . //           //   .       //    . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename T&gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> thread_safe_queue_t { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> unique_ptr_t = std::unique_ptr&lt;T&gt;; std::mutex lock_; std::queue&lt;unique_ptr_t&gt; content_; <span class="hljs-type"><span class="hljs-type">bool</span></span> closed_{<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: enum <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> status_t { extracted, empty_queue, closed }; <span class="hljs-type"><span class="hljs-type">void</span></span> push(unique_ptr_t what) { std::lock_guard&lt;std::mutex&gt; l{lock_}; content_.emplace(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(what)); } //  pop  -,     //     ,    . //      mutex-,  , //         ,  pop() //    . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename Acceptor&gt; status_t pop(Acceptor &amp;&amp; acceptor) { std::lock_guard&lt;std::mutex&gt; l{lock_}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(closed_) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status_t::closed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(content_.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status_t::empty_queue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!content_.empty()) { acceptor(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(content_.front())); content_.pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status_t::extracted; } } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() { std::lock_guard&lt;std::mutex&gt; l{lock_}; closed_ = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }; //        . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> request_info_queue_t = thread_safe_queue_t&lt;request_info_t&gt;;</code> </pre> <br>  In principle, thread_safe_queue_t was not necessary to make a pattern.  But it so happened that the thread_safe_queue_t template class was first made, and later it became clear that it will be used only with the request_info_t type.  But we did not begin to alter the implementation from the template to the usual class. <br><br><h3>  RESTinio-part bridge_server_1 </h3><br>  In the code bridge_server_1 there are only three functions that interact with RESTinio.  First, it is the run_server () template function, which is responsible for starting the HTTP server in the context of the main application thread: <br><br><pre> <code class="hljs pgsql">//  ,       . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename Server_Traits, typename <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> run_server( const config_t &amp; config, <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { restinio::run( restinio::on_this_thread&lt;Server_Traits&gt;() .address(config.address_) .port(config.port_) .request_handler(std::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>))); }</code> </pre> <br>  In bridge_server_1, it is even simpler than in delay_server.  And, generally speaking, one could do without it.  One could just call restinio :: run () directly in main () - e.  But it is better to still have a separate run_server (), so that if you need to change the settings of the HTTP server being started, you would have to change them in just one place. <br><br>  Secondly, this is the handler () function, which is the HTTP request handler.  It is a bit more complicated than its counterpart in delay_server, but it is also unlikely to cause difficulties with understanding: <br><br><pre> <code class="hljs pgsql">//   . restinio::request_handling_status_t <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>( const config_t &amp; config, request_info_queue_t &amp; queue, restinio::request_handle_t req) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(restinio::http_method_get() == req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().<span class="hljs-keyword"><span class="hljs-keyword">method</span></span>() &amp;&amp; "/data" == req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path()) { //    . const auto qp = restinio::parse_query(req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query()); //          //      curl_multi. auto url = fmt::format("http://{}:{}/{}/{}/{}", config.target_address_, config.target_port_, qp["year"], qp["month"], qp["day"]); auto <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> = std::make_unique&lt;request_info_t&gt;( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(url), std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(req)); queue.push(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>)); // ,         - //   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } //       . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }</code> </pre> <br>  Here we first manually check the type of the incoming request and the URL from it.  If this is not HTTP GET for / data, then we refuse to process the request.  In bridge_server_1 we have to do this check manually, whereas in delay_server due to the use of the Express router, there was no need for this. <br><br>  Further, if this is a request we expect, then we parse the query string into its components and form a URL to delay_server for our own outgoing request.  After that we create the request_info_t object in which we save the generated URL and a smart link to the received incoming request.  And we pass this request_info_t to the processing of the curl thread (by storing it in a thread-safe container). <br><br>  Well, and thirdly, the complete_request_processing () function, in which we respond to a received incoming HTTP request: <br><br><pre> <code class="hljs pgsql">//       . // curl_multi    .   http-response, //        http-request. <span class="hljs-type"><span class="hljs-type">void</span></span> complete_request_processing(request_info_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>) { auto response = <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.original_req_-&gt;create_response(); response.append_header(restinio::http_field::<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, "RESTinio hello world server"); response.append_header_date_field(); response.append_header(restinio::http_field::content_type, "text/plain; charset=utf-8"); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURLE_OK == <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.curl_code_) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.response_code_) response.set_body( fmt::format("Request processed.\nPath: {}\nQuery: {}\n" "Response:\n===\n{}\n===\n", <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.original_req_-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path(), <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.original_req_-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query(), <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.reply_data_)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> response.set_body( fmt::format("Request failed.\nPath: {}\nQuery: {}\n" "Response code: {}\n", <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.original_req_-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path(), <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.original_req_-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query(), <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.response_code_)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> response.set_body("Target service unavailable\n"); response.done(); }</code> </pre> <br>  Here we use the original incoming request, which was saved in the request_info_t :: original_req_ field.  The restinio :: request_t :: create_response () method returns an object that should be used to generate an HTTP response.  We save this object to the response variable.  The fact that the type of this variable is not recorded is clearly not accidental.  The fact is that create_response () can return different types of objects (details can be found <a href="https://stiffstream.com/en/docs/restinio/0.4/responsebuilder.html">here</a> ).  And in this case, it does not matter to us what exactly the simplest form of create_response () returns. <br><br>  Next, we fill in the HTTP response, depending on what our HTTP request to delay_server has completed.  And when the HTTP response is fully formed, we instruct RESTinio to send the response to the HTTP client by calling response.done (). <br><br>  Regarding the complete_request_processing () function, one very important thing needs to be emphasized: it is called on the context of a curl thread.  But when we call response.done (), the delivery of the generated response is automatically delegated to the main thread of the application on which the HTTP server is running. <br><br><h3>  curl-part bridge_server_1 </h3><br>  The curl-part of bridge_server_1 includes several functions that work with curl_multi and curl_easy.  We start the analysis of this part from its main function, curl_multi_work_thread (), and then consider the other functions, directly or indirectly called from curl_multi_work_thread (). <br><br>  But first, a little explanation about why we used ‚Äúbare‚Äù libcurl in our demonstration without using any C ++ wrappers around it.  The reason is more than prosaic: <s>what is there to think about, to shake it was</s> not <s>necessary</s> to waste time searching for a suitable wrapper and proceeding with what and how this wrapper does.  Given that at one time we had experience with libcurl, how to interact with it at the level of its native C-shny API we imagined.  We needed here was only a minimal set of features libcurl.  And at the same time I wanted to keep everything under my complete control.  Therefore, we decided not to use any third-party C ++ add-ons over libcurl. <br><br>  And one more important disclaimer needs to be done before parsing the curl code: in <i>order to simplify and shorten the code of the demo applications as much as possible, we didn‚Äôt do any error checking at all.</i>  <i>If we properly controlled the return codes of curl functions, then the code would be three times swollen, significantly losing clarity, but not gaining anything in functionality.</i>  <i>Therefore, in our demonstration, we expect that the calls to libcurl will always succeed.</i>  <i>This is our conscious decision for this particular experiment, but we would never do that in a real production code.</i> <br><br>  Well, now, after all the necessary explanations, let's move on to considering how curl_multi_perform allowed us to organize work with asynchronous outgoing HTTP requests. <br><br><h4>  Function curl_multi_work_thread () </h4><br>  Here is the code for the main function that runs on a separate curl thread in bridge_server_1: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ curl_multi_perform. void curl_multi_work_thread(request_info_queue_t &amp; queue) { using namespace cpp_util_3; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   curl. curl_global_init(CURL_GLOBAL_ALL); auto curl_global_deinitializer = at_scope_exit([]{ curl_global_cleanup(); }); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   curl_multi,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . auto curlm = curl_multi_init(); auto curlm_destroyer = at_scope_exit([&amp;]{ curl_multi_cleanup(curlm); }); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . int still_running{ 0 }; while(true) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     .     , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . auto status = try_extract_new_requests(queue, curlm); if(request_info_queue_t::status_t::closed == status) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,      . return; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -      , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   curl_multi_perform. if(0 != still_running || request_info_queue_t::status_t::extracted == status) { curl_multi_perform(curlm, &amp;still_running); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   - . check_curl_op_completion(curlm); } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   curl_multi_wait, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    -. if(0 != still_running) { curl_multi_wait(curlm, nullptr, 0, 50 /</span></span>*ms*<span class="hljs-regexp"><span class="hljs-regexp">/, nullptr); } else { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,   ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,     . std::this_thread::sleep_for(std::chrono::milliseconds(50)); } } }</span></span></code> </pre> <br>  It can be divided into two parts: in the first part, the necessary initialization of libcurl and the creation of an instance of curl_multi take place, and in the second part, the main loop is executed to service outgoing HTTP requests. <br><br>  The first part is quite simple.  To initialize libcurl, you need to call curl_global_init (), and then, at the very end of the work, call curl_global_cleanup ().  What we are doing with the above focus with at_scope_exit.  A similar trick is used to create / delete an instance of curl_multi.  Hopefully this code is straightforward. <br><br>  But the second part is more complicated.  The idea is this: <br><br><ul><li>  we cycle the HTTP requests service cycle until we are given a command to shut down (in the main () function, this is done by calling queue.close ()); </li><li>  At each iteration of the cycle, we first try to take new HTTP requests from the thread-safe container.  If new requests are there, then each of them is converted to a curl_easy instance, which is added to the curl_multi instance; </li><li>  after that we call <a href="https://curl.haxx.se/libcurl/c/curl_multi_perform.html">curl_multi_perform ()</a> in order to try to serve those requests that already exist and / or new requests that could only be added to the curl_multi-instance.  And after calling curl_multi_perform (), we immediately try to call <a href="https://curl.haxx.se/libcurl/c/curl_multi_info_read.html">curl_multi_info_read ()</a> in order to detect those HTTP requests that were completed by libcurl (all this is done inside check_curl_op_completion ()); </li><li>  then we either call <a href="https://curl.haxx.se/libcurl/c/curl_multi_wait.html">curl_multi_wait ()</a> to wait for the availability of IO operations if some HTTP requests are currently being serviced, or simply fall asleep for 50ms if there is nothing in the processing right now. </li></ul><br>  Roughly speaking, curl-thread works on a tact basis.  At the beginning of each cycle, new queries are retrieved and the results of active queries are checked.  After that, the curl thread falls asleep either until the IO operations are ready, or before the 50-millisecond pause expires.  At the same time, waiting for the availability of IO-operations is also limited to the 50-ms interval. <br><br>  The scheme is very simple.  But having a couple of drawbacks.  Depending on the situation, these shortcomings can be fatal, and may not be flawed at all: <br><br>  1. The function curl_multi_info_read () is called after each call to curl_multi_perform ().  Although, in principle, curl_multi_perform returns the number of requests that are currently being processed.  And based on the change of this value, it is possible to determine the moment when the number of requests decreases, and only after that call curl_multi_info_read.  However, we use the most primitive version of the work so as not to bother with the situation when one request is completed, one new one is added, while the total number of running requests remains the same. <br><br>  2. Increases the latency of processing the next request.  So, if there are currently no active requests and a new incoming HTTP request arrives, then the curl thread will receive information about it only after exiting the next call to this_thread :: sleep_for ().  With a curl_multi_work_thread () clock cycle size of 50 milliseconds, this means + 50ms to the latency of the request processing (in the worst case).  In bridge_server_1 we do not care.  But in the implementation of bridge_server_1_pipe we tried to get rid of this drawback by using an additional pipe with notifications for the curl thread.  We did not plan to analyze bridge_server_1_pipe in detail, but if someone has a desire to see such an analysis, please write down the comments, please.  If there are such wishes, we will make an additional article with analysis. <br><br>  So, in general terms, the curl thread in the example bridge_server_1 works.  If you have any questions, ask them in the comments, we will try to answer.  In the meantime, we proceed to the analysis of the remaining functions related to the curl-part of the bridge_server_1. <br><br><h4>  Functions for receiving new incoming HTTP requests </h4><br>  At the beginning of each iteration of the main loop inside the curl_multi_work_thread (), an attempt is made to pick up all new incoming HTTP requests from the thread-safe container, convert them to curl_easy instances and add these new curl_easy instances to the curl_multi instance.  This is all done with a few auxiliary functions. <br><br>  First, it is the try_extract_new_requests () function: <br><br><pre> <code class="hljs pgsql">//    ,    . //   status_t::closed,     // . auto try_extract_new_requests(request_info_queue_t &amp; queue, CURLM * curlm) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.pop([curlm](auto <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>) { introduce_new_request_to_curl_multi(curlm, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>)); }); }</code> </pre> <br>  In fact, its job is to call the pop () method of our thread-safe container and pass the desired lambda function to pop ().  By and large, this could all be written directly inside curl_multi_work_thread (), but initially try_extract_new_requests () was more voluminous.  And its presence simplifies the curl_multi_work_thread () code. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secondly, this is the function introduce_new_request_to_curl_multi (), in which, in fact, all the main work is done. </font></font> Namely: <br><br><pre> <code class="hljs pgsql">//  curl_easy    ,    //        curl_easy  curl_multi. <span class="hljs-type"><span class="hljs-type">void</span></span> introduce_new_request_to_curl_multi( CURLM * curlm, std::unique_ptr&lt;request_info_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>) { //    curl_easy    . CURL * h = curl_easy_init(); curl_easy_setopt(h, CURLOPT_URL, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;url_.c_str()); curl_easy_setopt(h, CURLOPT_PRIVATE, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()); curl_easy_setopt(h, CURLOPT_WRITEFUNCTION, write_callback); curl_easy_setopt(h, CURLOPT_WRITEDATA, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()); //  curl_easy ,     curl_multi. curl_multi_add_handle(curlm, h); // unique_ptr       . //        . <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you worked with curl_easy, then you will not see anything new for yourself here. </font><font style="vertical-align: inherit;">Is that except for the call to </font></font><a href="https://curl.haxx.se/libcurl/c/curl_multi_add_handle.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curl_multi_add_handle ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is how the transfer of control over the execution of a separate HTTP request to the curl_multi instance is performed. </font><font style="vertical-align: inherit;">If you didn‚Äôt work with curl_easy before, you will need to familiarize yourself </font></font><a href="https://curl.haxx.se/libcurl/c/libcurl-easy.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the official documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in order to figure out what curl_easy_setopt () is called for and what effect it gives.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key point in introduce_new_request_to_curl_multi () is related to managing the lifetime of the instance request_info_t. The fact is that request_info_t is passed between worker threads via unique_ptr. And in introduce_new_request_to_curl_multi () it also comes in the form of unique_ptr. So, if you do not take any special action, the request_info_t instance will be destroyed when you exit from introduce_new_request_to_curl_multi (). But we need to save request_info_t until libcurl has completed processing this request.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we save the pointer to request_info_t as private data inside the curl_easy instance. And call release () from unique_ptr so that unique_ptr stops controlling the lifetime of our object. When the request is completed, we manually retrieve the private data from the curl_easy instance and destroy the request_info_t object ourselves (this can be seen inside the check_curl_op_completion () function, which is discussed below). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This, by the way, is connected with one more thing that we didn‚Äôt get distracted in our demo application, but which will have to take some time while writing the production code: when the application completes its work, request_info_t objects, pointers to which were stored inside curl_easy instances are not deleted.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when we exit the main loop in curl_multi_work_thread (), then we do not go through the remaining live instances of curl_easy and do not wipe the request_info_t after us. </font><font style="vertical-align: inherit;">For good, it should be done. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, thirdly, the function write_callback is responsible for preparing HTTP requests, the pointer to which we save in a curl_easy instance:</font></font><br><br><pre> <code class="hljs pgsql">//     curl     //   .       // CURLOPT_WRITEFUNCTION. std::size_t write_callback( <span class="hljs-type"><span class="hljs-type">char</span></span> *ptr, size_t size, size_t nmemb, <span class="hljs-type"><span class="hljs-type">void</span></span> *userdata) { auto <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> = reinterpret_cast&lt;request_info_t *&gt;(userdata); const auto total_size = size * nmemb; <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;reply_data_.append(ptr, total_size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_size; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function is called by libcurl when a remote server sends some data in response to our outgoing request. </font><font style="vertical-align: inherit;">We accumulate this data in the field request_info_t :: reply_data_. </font><font style="vertical-align: inherit;">It also uses the fact that the pointer to the request_info_t instance is stored as private data inside the curl_easy instance.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Function check_curl_op_completion () </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we consider one of the main functions of the curl-part bridge_server_1, which is responsible for finding the executed HTTP requests and completing their processing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bottom line is that inside the curl_multi instance there is a queue of some messages generated by the libcurl during the work of the curl_multi. When curl_multi finishes processing the next request within the curl_multi_perform, a message with a special status CURLMSG_DONE is placed in this message queue. This message contains information about the processed request. Our task is to run through this queue and process all the CURLMSG_DONE messages found in it.</font></font><br><br>  It looks like this: <br><br><pre> <code class="hljs pgsql">//    ,      //  curl_multi. <span class="hljs-type"><span class="hljs-type">void</span></span> check_curl_op_completion(CURLM * curlm) { CURLMsg * msg; <span class="hljs-type"><span class="hljs-type">int</span></span> messages_left{<span class="hljs-number"><span class="hljs-number">0</span></span>}; //       curl_multi   //   CURLMSG_DONE. <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(nullptr != (msg = curl_multi_info_read(curlm, &amp;messages_left))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURLMSG_DONE == msg-&gt;msg) { //  ,   . //     unique_ptr,     // curl_easy_cleanup. std::unique_ptr&lt;CURL, decltype(&amp;curl_easy_cleanup)&gt; easy_handle{ msg-&gt;easy_handle, &amp;curl_easy_cleanup}; //    curl_multi    . curl_multi_remove_handle(curlm, easy_handle.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()); //    ,     //  . request_info_t * info_raw_ptr{nullptr}; curl_easy_getinfo(easy_handle.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), CURLINFO_PRIVATE, &amp;info_raw_ptr); //    unique_ptr,   . std::unique_ptr&lt;request_info_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>{info_raw_ptr}; <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;curl_code_ = msg-&gt;data.result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURLE_OK == <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;curl_code_) { //   ,     . curl_easy_getinfo( easy_handle.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), CURLINFO_RESPONSE_CODE, &amp;<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>-&gt;response_code_); } //     . complete_request_processing(*<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We just pull </font></font><a href="https://curl.haxx.se/libcurl/c/curl_multi_info_read.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curl_multi_info_read ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the loop </font><font style="vertical-align: inherit;">as long as there is anything in the queue. </font><font style="vertical-align: inherit;">If we retrieve a message of the CURLMSG_DONE type, then we take an instance of curl_easy from the message and:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we remove it from the curl_multi-instance, since </font><font style="vertical-align: inherit;">there he is no longer needed;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> get curl_easy pointer to request_info_t and take control of the time of his life; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We deal with the result of processing the request (i.e., we get the result of the outgoing request from curl_easy); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> form the answer to the original incoming request (the function complete_request_processing was discussed above); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we delete everything that is no longer needed (via unique_ptr). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And so for all requests that have already been completed by this point. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The conclusion of the second part </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part of the story, we looked at how you can receive incoming HTTP requests on one thread and transfer them to the processing of a second working thread, on which outgoing HTTP requests are executed using curl_multi_perform. We have tried to highlight the main points in the text of the article. But, if something remains unclear, then ask questions, we will try to answer them in the comments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, if someone is interested in reading the analysis of the implementation of bridge_server_1_pipe, which uses the notification pipe, then let us know. We will then make an article on this topic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, it remains to consider bridge_server_2, which uses a more cunning </font></font><a href="https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curl_multi_socket_action</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mechanism </font><font style="vertical-align: inherit;">. Everything is much more fun there. At least it seemed so while we were dealing with this very curl_multi_socket_action :)</font></font><br><br> <a href="https://habrahabr.ru/post/349986/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be </font><a href="https://habrahabr.ru/post/349986/"><font style="vertical-align: inherit;">continued</font></a><font style="vertical-align: inherit;"> ...</font></font></div><p>Source: <a href="https://habr.com/ru/post/349818/">https://habr.com/ru/post/349818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349804/index.html">From a series of conversations with colleagues or a grain of experience: DC Edge design</a></li>
<li><a href="../349808/index.html">How we do AB-DOC</a></li>
<li><a href="../349810/index.html">Hyperapp for Refugees with React / Redux</a></li>
<li><a href="../349812/index.html">Segregated Witness for Dummies</a></li>
<li><a href="../349816/index.html">Open webinar "Features of JavaScript"</a></li>
<li><a href="../349820/index.html">–ï–ì–ê–ò–° 3.0 - 100% readiness! Alcohol accounting markup</a></li>
<li><a href="../349822/index.html">Qt: Writing a generic model for QML ListView</a></li>
<li><a href="../349824/index.html">Drop Stack Overflow: What Happened</a></li>
<li><a href="../349826/index.html">Sleight of hand and no fraud: practical tips on accelerated design training for developers</a></li>
<li><a href="../349830/index.html">Personal experience: a selection of materials about the virtual infrastructure, information security and trends in the IaaS market</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>