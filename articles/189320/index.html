<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How GIL works in Ruby. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Five out of four developers admit that multi-threaded programming is not easy to understand. 

  Most of the time I spent in the Ruby community, the i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How GIL works in Ruby. Part 1</h1><div class="post__text post__text-html js-mediator-article">  <i>Five out of four developers admit that multi-threaded programming is not easy to understand.</i> <br><br> <a href="http://www.flickr.com/photos/kellyskustompinstriping/6844608535/"><img src="https://habrastorage.org/getpro/habr/post_images/654/406/7ba/6544067baec7a56ba284b15467b40676.jpg" align="right"></a>  Most of the time I spent in the Ruby community, the infamous GIL remained for me a dark horse.  In this article I will talk about how I finally got to know GIL better. <br><br>  The first thing I heard about GIL was nothing to do with how it works or what it needs.  All I heard is that GIL is bad because it limits concurrency, or that it‚Äôs good because it makes code thread-safe.  The time has come, I have become accustomed to multi-threaded programming and realized that everything is actually more complicated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I wanted to know how GIL works from a technical point of view.  There is no specification or documentation on GIL.  In fact, this is a feature of MRI (Matz's Ruby Implementation).  The MRI development team says nothing about how GIL works and what it guarantees. <br><br>  However, I am running ahead. <br><a name="habracut"></a><br><h3>  If you don‚Äôt know anything about GIL at all, here‚Äôs a short description: </h3><br><blockquote>  MRI has something called GIL (global interpreter lock, global interpreter lock).  Thanks to it, in a multi-threaded environment, at some point in time, Ruby code can be executed only in one thread. <br><br>  For example, if you have eight threads running on an eight-core processor, only one thread can work at some point in time.  GIL is designed to prevent race conditions from occurring, which can compromise data integrity.  There are some subtleties, but the essence is as follows. </blockquote><br>  From the 2008 article ‚Äú <a href="http://www.igvita.com/2008/11/13/concurrency-is-a-myth-in-ruby/">Parallelism is a Myth in Ruby</a> ‚Äù by Ilya Grigorik, I got a general understanding of GIL.  Here are just a general understanding does not help deal with technical issues.  In particular, I want to know whether GIL guarantees the thread safety of certain operations in Ruby.  I will give an example. <br><br><h2>  Adding an element to an array is not thread safe. </h2><br>  In Ruby, little is thread-safe at all.  Take, for example, adding an element to an array <br><br><pre><code class="ruby hljs">array = [] <span class="hljs-number"><span class="hljs-number">5</span></span>.times.map <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Thread.new <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>.times <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> array &lt;&lt; <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.each(&amp;<span class="hljs-symbol"><span class="hljs-symbol">:join</span></span>) puts array.size</code> </pre> <br>  In this example, each of the five threads adds a <b><code>nil</code></b> to the same array a thousand times.  As a result, there should be five thousand elements in the array, right? <br><br><pre> <code class="ruby hljs">$ ruby pushing_nil.rb <span class="hljs-number"><span class="hljs-number">5000</span></span> $ jruby pushing_nil.rb <span class="hljs-number"><span class="hljs-number">4446</span></span> $ rbx pushing_nil.rb <span class="hljs-number"><span class="hljs-number">3088</span></span></code> </pre><br>  = ( <br><br>  Even in such a simple example, we are faced with non-thread-safe operations.  We will understand what is happening. <br><br>  Pay attention to the fact that launching code using MRI gives the correct ( <i>perhaps in this context, you will like the word ‚Äúexpected‚Äù - lane</i> ), but JRuby and Rubinius will not.  If you run the code again, the situation will repeat, and JRuby and Rubinius will give other (still incorrect) results. <br><br>  The difference in the results is due to the existence of GIL.  Since there is a GIL in the MRI, despite the fact that five threads work in parallel, only one of them is active at any time.  In other words, there is no real parallelism here.  JRuby and Rubinius do not have GIL, so when five threads run in parallel, they are indeed parallelized between the available cores and, by executing non-thread-safe code, can violate the integrity of the data. <br><br><h2>  Why parallel threads can compromise data integrity </h2><br>  How can this be?  Thought Ruby wouldn't let that happen?  Let's see how it is technically possible. <br><br>  Whether MRI, JRuby or Rubinius, Ruby is implemented in another language: MRI is written in C, JRuby in Java, and Rubinius in Ruby and C ++.  Therefore, when performing a single operation in Ruby, for example, <b><code>array &lt;&lt; nil</code></b> , it may turn out that its implementation consists of tens or even hundreds of lines of code.  Here is the implementation of <b><code>Array#&lt;&lt;</code></b> in MRI: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> rb_ary_push(<span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> ary, <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> item) { long idx = RARRAY_LEN(ary); ary_ensure_room_for_push(ary, <span class="hljs-number"><span class="hljs-number">1</span></span>); RARRAY_ASET(ary, idx, item); ARY_SET_LEN(ary, idx + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ary; }</code> </pre><br>  Note that there are at least four different operations here: <br><br><ol><li>  Getting the current length of the array </li><li>  Check for memory for another item </li><li>  Add item to array </li><li>  Assigning the length of the old value array + 1 </li></ol><br>  Each of them refers to other functions.  I pay attention to these details in order to show how parallel streams can compromise data integrity.  We are accustomed to linear step-by-step code execution ‚Äî in a single-threaded environment, you can look at the short function in C and easily track the order in which the code is executed. <br><br>  But if we are dealing with several threads, this is not possible.  If we have two threads, they can perform different parts of the function code and have to keep track of two chains of code execution. <br><br>  In addition, since threads use shared memory, they can simultaneously modify data.  One of the threads may interrupt the other, change the general data, after which the other thread will continue to run, being unaware that the data has changed.  This is the reason why some implementations of Ruby give unexpected results by simply adding <b><code>nil</code></b> to an array.  The situation is similar to that described below. <br><br>  Initially, the system is in the following state: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32d/8ae/d30/32d8aed305130d086f857ae5cfc6a27b.png"><br><br>  We have two streams, each of which is about to begin its function.  Let steps 1-4 be the pseudo-code implementation of <b><code>Array#&lt;&lt;</code></b> in the MRI above.  The following is a possible development of events (at the initial moment of time, flow A is active): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/4fa/0ef/8714fa0ef1e5cb28811efb99e0d33ff8.png"><br><br>  To understand what is happening, just follow the arrows.  I added inscriptions reflecting the state of things in terms of each flow. <br><br>  This is just one of the possible scenarios: <br><br>  Thread A starts to execute the function code, but when the queue reaches step 3, the context switches.  Flow A pauses and a thread B turns, which executes the entire function code, adding an element and increasing the length of the array. <br><br>  After that, flow A resumes exactly from the point at which it was stopped, and this happened right before increasing the length of the array.  Stream A sets the length of the array to <b><code>1</code></b> .  That's just the flow of B has already changed the data. <br><br>  Once again: the flow B assigns the value <b><code>1</code></b> to the length of the array, after which the flow A also assigns it to <b><code>1</code></b> , despite the fact that both threads added elements to the array.  The integrity of the data is broken. <br><br><h2>  And I relied on Ruby </h2><br>  The scenario described above can lead to incorrect results, as we have seen in the case of JRuby and Rubinius.  But with JRuby and Rubinius it is still more difficult, since in these implementation the threads can actually work in parallel.  In the figure, one stream is suspended when the other is running, while in the case of true concurrency, both streams can work simultaneously. <br><br>  If you run the example above several times using JRuby or Rubinius, you will see that the result is always different.  Context switching is unpredictable.  It can happen sooner or later or not at all.  I will touch on this topic in the next section. <br><br>  Why doesn't Ruby protect us from this madness?  For the same reason that the underlying data structures in other languages ‚Äã‚Äãare not thread-safe: this is too expensive.  Implementations of Ruby might have thread-safe data structures, but this would require an overhead, which would make the code <i>even</i> slower.  Therefore, the burden of ensuring thread safety is shifted to the programmer. <br><br>  I still haven't touched on the technical details of the GIL implementation, and the main question still remains unanswered: <b>why does the launch of the code on the MRI still give the correct result?</b> <br><br>  This question was the reason why I wrote this article.  A general understanding of GIL does not provide an answer to it: it is clear that only one thread can execute Ruby code at some point in time.  But after all, context switching can still occur in the middle of a function? <br><br>  But first... <br><br><h2>  Blame the planner </h2><br>  Context switching is part of the task of the OS scheduler.  In all mentioned implementations, one native stream corresponds to one Ruby stream.  The OS must ensure that no thread will capture all available resources (CPU time, for example), so it implements scheduling so that each thread gets access to resources. <br><br>  For a flow, this means that it will pause and resume.  Each thread gets CPU time, then pauses, and the next thread gets access to resources.  When the time comes, the flow resumes, and so on. <br><br>  This is effective from the point of view of the OS, but introduces some randomness and motivates to revise the view on the correctness of the program.  For example, when executing <b><code>Array#&lt;&lt;</code></b> it should be borne in mind that a stream can be stopped at any time and another stream can execute the same code in parallel, changing common data. <br><br><h3>  Decision?  Use atomic operations </h3><br>  If you want to be sure that the stream will not be interrupted in the wrong place, use atomic operations that ensure there are no interruptions to completion.  Due to this, in our example, the stream will not be interrupted in step 3 and ultimately does not violate the integrity of the data in step 4. <br><br>  The easiest way to use an atomic operation is to resort to blocking.  The following code will give the same predictable result with MRI, JRuby and Rubinius thanks to the mutex. <br><br><pre> <code class="ruby hljs">array = [] mutex = Mutex.new <span class="hljs-number"><span class="hljs-number">5</span></span>.times.map <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Thread.new <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mutex.synchronize <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>.times <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> array &lt;&lt; <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.each(&amp;<span class="hljs-symbol"><span class="hljs-symbol">:join</span></span>) puts array.size</code> </pre><br>  If a thread starts executing the <b><code>mutex.synchronize</code></b> block, other threads are forced to wait for it to complete before starting the execution of the same code.  Using atomic operations, you get a guarantee that if the context switch happens inside the block, other threads will still not be able to enter it and change the general data.  The scheduler will notice and switch the stream again.  Now the code is thread safe. <br><br><h2>  GIL is lock too </h2><br>  We saw how locking can be used to create an atomic operation and provide thread safety.  GIL is also a lock, but does it make code thread-safe?  Does GIL <b><code>array &lt;&lt; nil</code></b> into an atomic operation? <br><br><del>  Soon the tale is affected, but it is not done soon </del>  The article is too big to read at one time, so I divided it into two parts.  In the <a href="http://habrahabr.ru/post/189486/">second part,</a> we will look at the implementation of GIL at MRI to answer the questions posed. <br><br>  <i>The translator will be happy to hear comments and constructive criticism.</i> </div><p>Source: <a href="https://habr.com/ru/post/189320/">https://habr.com/ru/post/189320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189302/index.html">The first results of the championship developer Devcup 2013: the winners in nominations</a></li>
<li><a href="../189304/index.html">Mobile version 2GIS - a fresh portion of updates</a></li>
<li><a href="../189308/index.html">Potentially dangerous asteroids</a></li>
<li><a href="../189310/index.html">Access to Netflix over IPv6 from outside the States</a></li>
<li><a href="../189314/index.html">We try Orchard CMS for a corporate site</a></li>
<li><a href="../189328/index.html">Voronezh entered into a contract with the bank, making their changes, and is going to sue 24 million rubles</a></li>
<li><a href="../189330/index.html">BitByte Festival is a meeting place for the IT community</a></li>
<li><a href="../189332/index.html">SIP client interaction. Part 2</a></li>
<li><a href="../189334/index.html">ICFPC 2013 coming soon</a></li>
<li><a href="../189338/index.html">6 ways to protect copyright</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>