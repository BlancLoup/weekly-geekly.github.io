<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we did our last amateur translation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I already wrote an article on the subject of amateur translation, where I tried to describe the cuisine of this process. But, in my opinion, this expe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we did our last amateur translation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/936/f16/cf0/936f16cf0191d7fadcc452036ede4691.jpg" align="right">  I already <a href="http://habrahabr.ru/post/140930/">wrote an article</a> on the subject of amateur translation, where I tried to describe the cuisine of this process.  But, in my opinion, this experience was not entirely successful.  Due to the large number of approaches it is impossible to describe everything, but an excessive generalization of the essence does not reflect.  Therefore, I decided to describe one particular case, quite indicative, in my opinion. <br><br>  To be honest, this is not really about our last translation.  The fact is that the idea to write this article came to me when our business was in decline and the word ‚Äúlast‚Äù really meant our final work on this scene.  But, having applied the professional approach to the project and the experience gained as a result of real work experience, I realized that you can live with this and firmly decided that we should complete another translation, which we have been looking forward to for more than two years.  So under current circumstances, this word means rather "the last at the time of this writing." <br><br>  This is not about playing on a PC, it would be too boring - because there is not that exotic and romance reverse engineering that is inherent in the insides of console games.  It's about playing on the Nintendo Wii. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I apologize in advance for an overblown article and a boring second half, but, as they say, you can‚Äôt throw words out of a song. <br><br><a name="habracut"></a><br><br><h1>  Prehistory </h1><br><img src="https://habrastorage.org/storage2/cda/b8d/f85/cdab8df85777c0f949c10d026ff84d9e.png" align="right">  It all started somewhere in 2010, the exact date is not even remember.  When I was still a student, and <a href="https://habr.com/users/dangaard/" class="user_link">Dangaard</a> (the author of the articles about <a href="http://consolgames.ru/news.php%3Fextend.27">wild geese</a> and <a href="http://shedevr.org.ru/forum/viewtopic.php%3Ft%3D3885">Little Red Riding Hood that</a> many people liked) had been doing amateur translations for quite a long time: I wrote tools, and he translated.  And we had one bad habit - to start translating any toy you like, which is why the number of abandoned projects we have quite a lot exceeds the number of completed ones.  One of our favorite gaming series was and still is the notorious Metroid, a two-dimensional walker, the founder of the <a href="http://gaming.wikia.com/wiki/Metroidvania">Metroidvania</a> genre, and I always wanted to see how well this genre was transferred to 3D in the games of the Metroid Prime series that went on the Nintendo GameCube and Wii. <br><br>  And at some point I became the proud owner of the Wii, and, of course, immediately decided to satisfy my curiosity.  I don‚Äôt know why, but in the first minutes of the gameplay, the first part of Metroid Prime didn‚Äôt impress me very much - apparently, the unusual control had an effect, and I didn‚Äôt have time to get to it, because  rather I wanted to try out other games.  However, taking into account the fact that the first two parts were only a port with the GameCube, unlike the third, which initially went on the Wii, I decided to look at it.  I stopped looking at it in about six hours, and was very impressed with the amount of information in the game - literally every object could be scanned, having received brief information or even a whole article. <br><br>  His eyes lit up with the idea, and his hands had already begun to perform the already familiar initiation ceremony - the launch of the right toolkit.  So the project of this translation was born. <br><br>  Unfortunately, I can‚Äôt tell you about the difficulties of translating game texts, so the technical and organizational aspects of the process will be mainly considered. <br><br><br><br><br><h1>  Looking for resources </h1><br>  So, the first thing was to get to the game files for the purpose of reverse engineering.  It was necessary to do this in any available way, so I already drove the corresponding request into Google.  First, the WiiScrubber program, designed to block unused areas of the game disc image with zeros, turned up first, so that it could be better compressed (more precisely, because of its encryption, it was compressed at least somehow), which also knows how to open it.  It is worth noting that this program played its role during the project, but more on that later. <br><br>  Opening the image and examining its contents, I first noticed the large files with the extension * .pak.  Undoubtedly, they were prime suspects for storing game resources, and one of the copies was already being prepared for preparation in a hex editor. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/c6b/902/ede/c6b902ede714094277c11b6e5c4f4cd4.png"></div></div><br>  At the beginning of the file, a primitive header was visible, starting with a record of the form: <br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PakHeader</span></span></span><span class="hljs-class"> </span></span>{ uint32 unknown; <span class="hljs-comment"><span class="hljs-comment">// version? uint32 totalHeaderSize; uint64 unknown; // hash? };</span></span></code> </pre> <br><br>  The following useful data began at an offset of 0x40, which made it possible to draw conclusions about the alignment of data to a block size of 64 bytes.  Some identifiers were clearly distinguished from this data: STRG, RSHD and DATA.  I didn‚Äôt have to go to the fortuneteller - it became obvious that the archive was divided into segments, or sections.  After each identifier followed by a value that is a multiple of 64, there were two obvious options: either size or offset. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/0cf/1dc/12b/0cf1dc12b874e9791db34db79f1fea9f.png"></div></div><br>  Since the next block of data had a size of 0x800 bytes, and the same value followed the identifier of the first segment, it became obvious that these were all sizes. <br><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SectionRecord { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> size; };</code> </pre><br>  With sections everything is clear, it remains to determine their purpose.  Here, on an intuitive level, identifiers helped - in the head the abbreviations themselves lined up in the words " <b>str</b> in <b>g</b> s", " <b>r</b> e <b>s</b> ource <b>h</b> ea <b>d</b> ers" and, oddly enough, " <b>data</b> ".  Having scrolled through everything and considering that the STRG section in some archives is empty, I decided to familiarize myself with the RSHD section first. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/6e9/8e6/aef/6e98e6aef012e29a0afa6337607f67bb.png"></div></div><br>  Again, it is completely self-evident that this section is a table with information about files stored in the archive.  In the data file itself, identifiers were viewed - TXTR, SCAN, STRG, etc., i.e.  files are typed and that is good.  Based on the intuition and structure of the section table, I assumed that the first 4 bytes are their number.  To verify this, I acted standard: I calculated the size of the record, calculating the distances between the beginnings of neighboring identifiers (24 bytes) and multiplying by this very value (0x1CA).  I rounded the resulting value (0x2AF0) to the multiplicity of 0x40, getting 2B00.  As expected, it matched the size shown in the section table. <br><br>  Now it remains to make out the format of the file entry itself.  With the identifier everything is clear - it indicates the type of file.  In addition to it, I expected to find at least some identifier of the file itself, as well as its size and offset in the archive. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/af7/cfb/627/af7cfb62718dee80b8771638f38b0b8b.png"></div></div><br>  By visual analysis, I identified some patterns.  The first number is always 0 or 1, therefore it is most likely that this is a boolean value.  Given that this is an archive, it is quite possible that this is a compression flag.  Next came the ID, which I figured out.  Behind it - 8 bytes of chaotic information, very similar to a certain hash and, it seems, is the file identifier.  The last two values ‚Äã‚Äãwere: both multiples of 0x40, but the latter increased with the number of records.  The conclusion asked for himself: the size and offset of the file.  Since the offset of the first file is zero, it is clear that it is indicated relative to the beginning of the segment. <br><br>  Having jumped on the specified displacements and popribavlja to them the sizes, I was convinced of the guesses and it was necessary only to write it in the form of structure: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FileRecord { <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> packed; char <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> hash[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> offset; };</code> </pre><br>  Then I was interested in the data files themselves.  Information about their position in the archive and the size was known, so I quickly sketched a simple extractor and took out the contents of one of the archives as is.  After reviewing a couple of files, I realized that they are really packed.  But I already knew the algorithm - many years of experience in such activities made themselves felt, and one glance at the hex editor was enough.  It only remained to make sure that the experience does not deceive me, and I fed one of the files to the <a href="http://www.extractor.ru/files/8646efaf987d03e05e123020cac7d07a">STUNS</a> program, which perfectly revealed some common compression algorithms.  I was not mistaken, it was <a href="http://ru.wikipedia.org/wiki/LZO">LZO</a> . <br><br>  Before writing the unpacker, it was necessary not only to determine the compression algorithm, but also to find out the data structure.  I took one of these files and began to pick it.  Thanks to STUNS, I knew the position of the compressed data stream, but other than that, there was other information in the packed file. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/57f/4cc/596/57f4cc5969612653306e7e70a50c8a0f.png"></div></div><br>  First of all, it was obvious that all such files have a signature - CMPD.  It was followed by the value that occurs in three variants - 1, 2, and very rarely - 3. I decided that this was some type or version of the format, without first attaching this value.  The next byte kept an unknown value in itself, and the next three - the file size minus 16. This gave me a reason to believe that the first 16 bytes of the file are the header.  After analyzing the values ‚Äã‚Äãof the unknown byte, I saw that only one or two bits often differ, and decided that these are some flags.  Then there were four more bytes, equal to the size of the unpacked file, spit out to me by STUNS, the conclusions are obvious, this is the size of the source data. <br><br>  16 bytes came to an end, according to STUNS, after another two bytes, the compressed stream itself began.  I was sure that this was one of the classic schemes: the size of the data portion is indicated in two bytes, then the portion of the packed data itself follows, and so on until the stream ends.  And indeed, the values ‚Äã‚Äãof these two bytes coincided with the size of the stream. <br><br>  Having processed the received information, I have made structure of heading. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompressedFileHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; uint32 type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> flags : <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> lzoSize : <span class="hljs-number"><span class="hljs-number">24</span></span>; uint32 dataSize; };</code> </pre><br>  Now it was clear how to read these files, and I climbed behind the good old <a href="http://www.oberhumer.com/opensource/lzo/">miniLZO</a> .  Thanks to its mini-framework and the widespread use of self-made abstractions for threads, the implementation of unpacking the LZO stream did not take much time or code lines. <br><br><div class="spoiler">  <b class="spoiler_title">Show code</b> <div class="spoiler_text"><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (streamSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { const uint16 chunkSize = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>-&gt;readUInt16(); streamSize -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(inBuf, chunkSize); streamSize -= chunkSize; uint32 size = <span class="hljs-number"><span class="hljs-number">0</span></span>; lzo_decompress(inBuf, chunkSize, outBuf, &amp;size); <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(outBuf, size); }</code> </pre></div></div><br>  Having raised my primitive extractor in rank to the distributor, I first made sure that I correctly understood the purpose of the Boolean field in the archive file table.  It turned out that, in fact, the files for which it is false were not packaged.  Reassured, I took it into account in the code, set the program on one of the large files and began to look at the progress with satisfaction ... <br><br>  But successfully complete the work of the program was not destined.  An attempt to unpack the first TXTR file was crowned.  It was then that I realized that it was not for nothing that there was some kind of versioning of these files.  Having opened one of the compressed textures in the hex editor, I began to look for differences. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/785/42e/8c8/78542e8c85b0ad15b476d3dea8c868bb.png"></div></div><br>  Of course, as a type there was no longer one.  The first thing that caught my eye was the difference in the size of the header: it became more than 20 bytes.  In this case, now in the header there were two values ‚Äã‚Äã12 and another 12 new bytes.  I had one guess and I climbed to look for an example of an uncompressed texture.  Having found one, I looked at its beginning and saw that it was very similar to those 12 bytes, which, along with other things, were added to the header. <br><br>  Everything became clear: compressed files of this type allow you to read a certain amount of information without resorting to unpacking - part of the data is simply stored in its original form right before the beginning of the stream.  In the case of textures, their title remained unpacked, i.e.  it was possible without extra calculations to find out the width, height, and type of such a texture.  Very resourceful, worth noting.  But I was embarrassed that the size of this data is given in duplicate.  Having gone through all the available compressed textures, I didn‚Äôt see any other option, and I realized that it doesn‚Äôt play a role, but I assumed for myself that the second number is either the amount of data taking into account alignment by 4 bytes or the position from which to start unpacking flow. <br><br>  I launched the unpacker again, and this time it managed, but due to the large number of files, it took quite a long time.  Then I added the option of selective unpacking to it, by file type, and began to run through all the files.  I was expecting another crash, because of one more type of compressed files, but it turned out that none of the files of interest were packaged in such a way and I decided not to waste time on unnecessary research - there was still a lot of work ahead and so much more. <br><br><div class="spoiler">  <b class="spoiler_title">The final version (pseudocode)</b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompressedFileType</span></span></span></span> { typeCommon = <span class="hljs-number"><span class="hljs-number">1</span></span>, typeTexture = <span class="hljs-number"><span class="hljs-number">2</span></span>, typeUnknown = <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamHeader</span></span></span></span> { unsigned flags : <span class="hljs-number"><span class="hljs-number">8</span></span>; unsigned lzo_size : <span class="hljs-number"><span class="hljs-number">24</span></span>; uint32 file_size; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompressedFileHeader</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; uint32 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commonHeader.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> == typeTexture) { uint32 uncompressedChunkSize; uint32 uncompressedChunkSize2; <span class="hljs-comment"><span class="hljs-comment">// always equals to uncompressedChunkSize } StreamHeader streamHeader; if (commonHeader.type == typeTexture) { uint8 uncompressedData[uncompressedChunkSize]; } };</span></span></code> </pre></div></div><br>  All that remains is to deal with the STRG section.  It began with a value of 0x4C, then the data alternated cyclically: a null-terminated string, a type identifier, and a hash present in the file table.  Of course, counting the number of such cycles, I received 0x4C.  Of course, these were the names of some files - apparently, for those files that are requested not by hash, but by name. <br><br><pre> <code class="hljs pgsql">struct NameRecord { <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>[]; // C-string <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; uint8 hash[<span class="hljs-number"><span class="hljs-number">8</span></span>]; };</code> </pre><br>  In essence, this entire section is a serialized display of hashes (or pairs [hash, type]) in the file name. <br><br>  Now I had access to all the necessary resources, and it was time to explore them. <br><br><br><br><br><h1>  Chasing the text </h1><br>  Next, it was first necessary to extract the text, so that Dangaard began to translate it while I continue to deal with the technical part.  Even before I figured out the archives, I tried to find signs of text in files like TXTR, but as it turned out later, TXTR does not mean ‚Äútext resource‚Äù, but only derived from the word ‚Äútexture‚Äù.  Of course, the text was stored in files of type STRG. <br><br>  I saw a lot when analyzing text data serialization techniques, therefore, opening one of these files in the hex editor, I was ready for anything.  And not for nothing, as it turned out, because the case turned out not trivial. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/689/164/e24/689164e24f0c4b032c7dd7c22d3ceb0a.png"></div></div><br>  My view immediately attracted the line "ENGLJAPNGERMFRENSPANITAL" - an enumeration of the six languages ‚Äã‚Äãsupported by the game.  Through the text in the second half of the file, it was clear that the file actually contains lines in all these languages.  All that followed before the identifiers of languages ‚Äã‚Äãlooked like a painful title, and the other files had the same picture, so I agreed on that: the first 24 bytes are the title. <br><br>  Then I began to compare the facts known to me with the values ‚Äã‚Äãof this heading.  For example, it was obvious that the file contains two lines of data for six languages, so the semantics of the values ‚Äã‚Äã6 and 2 did not cause questions.  Similarly, everything was obvious with the first four bytes: signatures are common.  However, the next 4 bytes, although they seemed to be an innocuous version of the format due to the lack of communication with any other data in the file, but after the experience with compressed files, I was still suspicious.  Just in case, I looked at a couple of dozens of files, and everywhere I saw the same three, calming down on it.  The title finished with two null values, which I wrote off to reserved fields, which are quite common in binary formats. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Header { <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> signature; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> langCount; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> stringsCount; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> reserved1; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> reserved2; };</code> </pre><br>  I dealt with the list of language identifiers.  Further, logically, followed by a table of offsets of lines, and then the lines themselves.  Well, it is necessary to pick it up.  There are six languages ‚Äã‚Äãand two lines in the file, but there are not 12, but 18 values ‚Äã‚Äãin the table - it means for each language there is one more value in addition to the offsets for two lines. <br><br>  By cyclically increasing the values, it can be seen that the offsets for each language are grouped together, and not, for example, alternate with offsets of other languages.  But each such group is preceded by an incomprehensible value, and then followed by the offset of the lines relative to the beginning of the first line.  The lines themselves are stored in the same way as is done in Delphi: first comes the length of the string, then its data.  In this case, the string is null-terminated.  Returning to an unknown value, I could not help but check one guess and summed up the lengths of all the strings of the first language.  But this is really the sum of the lengths of the lines of a language!  Now everything has become very clear. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> OffsetTable { <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> totalStringsLength; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> stringOffsets[header.stringCount]; };</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/579/100/52a/57910052a08fc63f71fe0d19035ea335.png"></div></div><br>  It's time to write a deserializer.  From the text of European languages, it was obvious that UTF-8 was used.  At that time, I didn‚Äôt jump from Delphi to C ++ not very long ago, and because of the presence of some developments in Delphi, and also because of VCL knowledge and only superficial knowledge of STL, I often sinned because I wrote some of the Delphi toolkit.  Since on the same Delphi I had an old proven library for serializing text into a readable and easily editable format, I decided to resort to this technique.  To my shame, although I tried to resort to OOP and other benefits of civilized code descriptions, I often sinned with a LAP code, so I had trouble writing this article, recalling some details. <br><br>  In general, the section of WinApi documentation required for decoding UTF-8 was studied, the deserializer was written and, after a brief debugging, tested on the prepared file.  Great, it's time to extract the game script!  I extracted all the existing STRG files from the archives and set a deserializer on them ... Of course, I was waiting for a trick, and he was.  Something I did not take into account, and again caught the crash. <br><br>  I opened the problem file, and saw that I got excited, designating some header fields as reserved. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/442/fbf/720/442fbf720a569bc5ea89b6d2a91bdbc0.png"></div></div><br>  Choice0, choice1 ... Why, it's the string identifiers!  This means that some lines can be assigned such identifiers in order to access them not by the index, but by these identifiers.  The first ‚Äúreserved‚Äù field turned out to be the number of these identifiers, and then the size of the section that was placed next followed. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Header { <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> signature; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> langCount; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> stringCount; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> idCount; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> idsSectionSize; };</code> </pre><br>  At the beginning of the section there was a table, which turned out to be a simple array of offsets and row indices for which these identifiers are intended.  The table was followed by the identifiers themselves in the form of null-terminated strings. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> IdRecord { <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> index; };</code> </pre><br>  It's time to fix the deserializer according to the new data and start the process again.  This time, the problem files were swallowed without any problems and the progress went further.  I was already preparing to celebrate the victory, but my sense of satisfaction with the work done was suddenly interrupted by another crash ... Well, no stranger.  I repeat the standard procedure again, opening the problem file in the hex editor. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/3dd/4e9/199/3dd4e9199fc1f304a26814b786c7834c.png"></div></div><br>  Still, I was not mistaken with the header field that stores the format version.  But I did not think that the other versions are generally used by the game.  I had to disassemble this version as well, since it was quite simple. <br><br>  The first 16 bytes of the header were identical to the previously investigated format.  Then immediately followed information about languages, but in a slightly different form. <br><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> LangSectionRecord { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> langId[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> size; };</code> </pre><br>  But then just followed the last 8 bytes of the header and section identifiers in the same format.  So, in that format, these 8 bytes were not part of the header. <br><br>  The latter were followed by sections with linguistic data.  At the beginning of each section was a list of row offsets.  The lines themselves this time were stored in unicode and were simply null-terminated, without specifying the length. <br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> LangData { <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> offsetTable[header.langCount]; <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> size; };</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/42a/dbe/d49/42adbed4929770b2881c9b3300c19ccc.png"></div></div><br>  I added support for this format and re-launched the deserialization process ... for the last time.  Now everything worked smoothly and I had an extracted game script in my hands. <br><br><br><br><br><h1>  Fonts </h1><br>  The texts were sent to Dangaard for review, and it was the turn of the fonts.  I have previously noticed a couple of files with the FONT type, and I have no doubt that they are the ones that store the fonts. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/db5/cc7/af4/db5cc7af42c0ce47dfb7e6eeee5bdacc.png"></div></div><br>  Typically, fonts consist of two components: a raster and information on how to display this raster.  But, after reviewing the file, I realized that there was no raster in it.  And this means that it should be stored separately - for example, in texture.  So, it was necessary to find signs of any reference to the raster. <br><br>  The first thing I began to visually analyze the contents of the file.  In the beginning, the font name ‚ÄúDeface‚Äù was well looked through, as well as the hash following it.  I decided to look for files with such a hash and really stumbled upon the texture.  Remarkably, the raster is now at hand, but you should first deal with this file. <br><br>  The title was tricky, and I decided to leave it for later.  A little further than the name of the font and texture hash noted earlier, there was data in which some periodicity was traced.  Looking more closely, I picked up the desired width of the window of the hex editor and saw that it was an array of structures. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/2aa/57c/770/2aa57c770d8c66453bea486abcdbb56f.png"></div></div><br>  Judging by the first field, where, without doubt, character codes were stored, this is information about the glyphs.  Classically, before the array itself was its size.  I began to look for characteristic elements in this array of structures, and the first thing that I noticed was the four clearly distinguishable float values ‚Äã‚Äãin the standard <a href="http://ru.wikipedia.org/wiki/IEEE_754">IEEE 754</a> format.  They are distinguished, due to the structure of the format, by the presence of 3D bytes, 3E, 3F, and other similar values ‚Äã‚Äãwith an interval of 4 bytes ‚Äî it is difficult not to notice this pattern with a large accumulation of floating-point numbers.  The values ‚Äã‚Äãthemselves ranged from 0 to 1, and it became obvious that these were texture coordinates.  I could not determine the semantics of the remaining values ‚Äã‚Äãwithout seeing the texture, so I began to decode the raster. <br><br>  Having postponed the analysis of the TXTR structure for later, I decided to just detect and process the raster.  In such cases, I always first check to see if the raster is an ordinary array of colors or indexes in the case of an image with indexed colors.  And so, opening the file in the editor and picking up color, I saw an interesting picture. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/4af/284/8c5/4af2848c5f8f7750d4fcd5615100734d.png"></div></div><br>  The image was four-bit, but it is obvious that there were two pictures.  Since the values ‚Äã‚Äãof the selected width and height were found at the very beginning of the file, i.e.  in fact, something like the texture itself should look like that, then I didn‚Äôt have to go far to the conclusion: there are two layers in the texture in a sly way.  Those.  in each pixel, instead of storing a four-bit pixel value, two different colors are stored ‚Äî one for every two bits.  The layers themselves, respectively, four-color. <br><br><img src="https://habrastorage.org/storage2/318/502/1cf/3185021cf7556df7b33c68459e48f22d.gif"><img src="https://habrastorage.org/storage2/a1f/4b5/aaf/a1f4b5aaf40ea5021559d26c5e7c460c.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each layer was a </font></font><a href="http://en.wikipedia.org/wiki/Texture_atlas"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textural atlas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - i.e. </font><font style="vertical-align: inherit;">there were many glyphs on it, and the </font></font><a href="http://ru.wikipedia.org/wiki/UV-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uv-coordinates of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> glyphs corresponding to the characters </font><font style="vertical-align: inherit;">were shown in the records </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For font editors, I have long had a blank on Delphi, inherited from a year ago in 2006 from one ‚Äúcolleague‚Äù. </font><font style="vertical-align: inherit;">I quickly sketched a raster decoder and started trying to load the font, interpreting the fields in glyph structures in different ways. </font><font style="vertical-align: inherit;">After a few days of experiments, I had some idea and even quite successfully downloaded the font.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/4a2/82d/904/4a282d90435c6f3e26eb268fa5bc2f1b.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting to convert fonts one by one, I came across another type of texture. </font><font style="vertical-align: inherit;">This time, they contained as many as four layers instead of two, but on the same principle. </font><font style="vertical-align: inherit;">The difference was that the layers were not four-color, but </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the picture gradually cleared up, and almost everything became known about the glyphs.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> right; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharRecord</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> code; Rect glyphRect; uint8 layerIndex; uint8 leftIdent; uint8 ident; uint8 rightIdent; uint8 glyphWidth; uint8 glyphHeight; uint8 baselineOffset; uint16 unknown; };</code> </pre><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/385/82b/b31/38582bb3186e36761cd5c3451f8a9920.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this knowledge, it became realistic to make out the unjustly forgotten headline. </font><font style="vertical-align: inherit;">Comparing the facts known to me, I could not figure out the purpose of the majority of its fields, but it was not important, it was possible to edit the font without them.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Header</span></span></span><span class="hljs-class"> {</span></span> uint32 maxCharWidth; uint32 fontHeight; uint32 unknown1; uint32 unknown2; uint32 unknown3; uint32 unknown4; uint16 unknown5; uint32 unknown6; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fontName[]; uint64 textureHash; uint32 textureColorCount; uint32 unknown7; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems to be all, it's time to work on preserving the font, but then I noticed not a strange addition, stored at the end of the file. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/000/fae/6b3/000fae6b362f753f9c14285c039663e0.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With some pairs of characters, there were some mapped values, most often 0, 1 and -1 ... Connoisseurs of typography probably already guessed what it was about, but I didn‚Äôt immediately understand and even raised the topic on a thematic forum. But soon, I began to guess, and, by running it, I came across the definition I was looking for ... Yes, it was </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B8%25D0%25BD%25D0%25B3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kerning</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in pixels.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KerningRecord</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> first; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> second; int32 kerning; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All these entries were sorted in ascending character codes. Now, the purpose of the last field in the glyph record has become known - it was the index of the first kerning record for this character. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you could do the organization save this font. I did not take risks and increase the size of texture atlases, so the main problem here was the placement of all the glyphs in a limited area. I asked in the topic about kerning, if anyone knows a simple algorithm for this, and in response I was given a link to </font></font><a href="http://www.gamedev.ru/pages/coriolis/articles/Packing_Lightmaps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an article on gamedev.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about the packaging of lighting maps. This was what was needed, and after the implementation of the algorithm, the fonts could be saved.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But after changing the fonts, it turned out that even with this algorithm it is not so easy to place all the characters on the available space - some of the glyphs simply did not fit. </font><font style="vertical-align: inherit;">The way out, however, was found right away: I screwed up an optimization that used the same part of the texture for characters with the same glyphs. </font><font style="vertical-align: inherit;">A little poshamaniv, I eliminated the insignificant differences between some similar characters of Cyrillic and Latin, and they began to have common glyphs, so that the fonts began to be successfully preserved. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So the next format fell to my fingers, and on this one could come to grips with the study of textures.</font></font><br><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acquaintance with textures </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The game did not contain a large number of textures that needed translation, but at that time I did not know this and worked with regard to the worst scenario. </font><font style="vertical-align: inherit;">After a bit of digging into the extracted TXTR files, I realized that font textures are a degenerate case, and most textures do not use indexed colors.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/a29/406/1a1/a294061a16569057c01c3141938e4bdd.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parse header size of 12 bytes was not difficult. </font><font style="vertical-align: inherit;">The first value was probably the texture type number, since textures with indexed colors had a different texture. </font><font style="vertical-align: inherit;">Values ‚Äã‚Äãof 640 and 480 followed, definitely very familiar numbers, didn't they? </font><font style="vertical-align: inherit;">In general, I did not doubt that there was permission in the header, but the purpose of the latter value is not so obvious. </font><font style="vertical-align: inherit;">But I was ready to swear that this is the number of </font></font><a href="http://ru.wikipedia.org/wiki/MIP-%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%2583%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mipmap-levels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which are so often found in such cases.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextureHeader</span></span></span><span class="hljs-class"> {</span></span> uint32 type; uint16 width; uint16 height; uint32 mipmapCount; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The title was studied, but the main problem was the definition of the raster format. Fortunately, visually this structure was very familiar to me - it was definitely an algorithm from the </font></font><a href="http://en.wikipedia.org/wiki/S3TC"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S3TC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> family </font><font style="vertical-align: inherit;">, familiar to many of them in </font></font><a href="http://ru.wikipedia.org/wiki/DirectDraw_Surface"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DDS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> containers </font><font style="vertical-align: inherit;">and DXTn algorithms. These formats are designed to use compressed textures in video memory, and it seems that both Wii and Gamecube are hardware supported. So, despite the emergence of associations with DirectX, there is nothing surprising here.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was easy to determine the specific algorithm: all of these formats have a strictly fixed compression ratio, and, based on the ratio of the size of the source raster to the compressed 8: 1 (or 6: 1 without alpha channel), it could only be DXT1. </font><font style="vertical-align: inherit;">The time has come just to make guesses, and I created a DDS image of the same format and resolution, replacing the raster borrowed from the texture. </font><font style="vertical-align: inherit;">But what I got when I opened the file I received was not a very meaningful image ...</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latent image</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/ccf/eb4/212/ccfeb4212a4f72b2a901ae2be3eb82ef.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is time to poraskinat brains. </font><font style="vertical-align: inherit;">Once the output turned out to be something remotely resembling an image, it was obvious that it was still DXT1, but modified. </font><font style="vertical-align: inherit;">Two factors came to mind that could affect the format: the byte order and the tile texture structure. </font><font style="vertical-align: inherit;">But in order to verify this, I had to manage the decoding procedure myself, and for this purpose I began to look for a library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortunately, I just stumbled upon a great open source library - </font></font><a href="https://code.google.com/p/nvidia-texture-tools/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA Texture Tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Not without problems, but I was still able to adjust its code for my own purposes, and began experimenting. </font><font style="vertical-align: inherit;">First of all, the first guess turned out to be true, with not whole bytes, but whole words, as well as bits in them, in a different order. </font><font style="vertical-align: inherit;">After some manipulations with their rearrangement, the image became more adequate.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latent image</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/b99/56b/084/b9956b08453e266406c3d54a1633942d.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I realized that I was not mistaken about the tiled structure. </font><font style="vertical-align: inherit;">But, considering that DXT1 itself is encoded by 4x4 blocks, I was only partially correct: a certain swizzling of tiles was used here, i.e. </font><font style="vertical-align: inherit;">they were swapped by a certain matrix. </font><font style="vertical-align: inherit;">And, of course, the image was flipped. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I was too lazy to strain the brain and restore the matrix, and I went a long way to try to find formulas for the translation of coordinates. </font><font style="vertical-align: inherit;">Honestly, I don‚Äôt know how I did it, but I acted by intuition and due to the presence of regularities in this matrix that my subconscious could feel without my participation, it eventually rolled. </font><font style="vertical-align: inherit;">And then, finally, I got the original image.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latent image</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/8fb/b9c/05e/8fbb9c05e4a322367feed9c3c806b13e.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write the encoding procedure was not a problem - the copy-paste decoding functions and, in fact, the replacement of r-value by l-value did their job. </font><font style="vertical-align: inherit;">At this all the main formats were disassembled and you could breathe a little more freely.</font></font><br><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First samples </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I could not wait to try out something in action, and I began to think about how to ensure the replacement of resources in the game. Of course, the first thing to think about repacking archives. It would be stupid to waste our time and resort to repacking unmodified files, so I started writing the reassembly function with packing only the necessary data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bottom line was this: the archive was opened and iterated over all its files. The input was a list of directories where they should look for their modified versions. If it was, then it was packed and recorded in the output file, otherwise the original packed file was copied unchanged.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, in the process of implementing this functionality, I noticed an interesting thing: not only were the same files often present in several archives, they were also often present in the plural and within the same archive! However, I was not surprised, because it is easily explained - this way you can reduce the number of movements of the drive head above the disk surface. In search of a file for reading, the game chooses the one that is closest in the direction of movement of the head, thereby reducing the wear of the drive and faster loading. In other games, for example, a technique is used when all the resources of a level are simply packed into a separate archive, which is then used within it. Of course, this leads to large amounts of duplication of data, but the language will not call it redundant, because everything is more than justified.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the necessary functionality was ready, I decided to try my luck by feeding the archive with the changed data to the game. Taking the previously mentioned WiiScrubber and rebuilding one of the least significant archives, I tried to replace it. But I was disappointed: the size of the original file was exceeded. What I wanted the least was to tackle the problems of rebuilding the image, so I began to look for workarounds. And I found them: the solution turned out to be similar to what I used in the case of fonts. Since I was not interested in data from other languages, I added the ability to set mappings of some files to others in the reassembly function.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if the next processed file was marked for display, its contents were not written anywhere, but only its entry in the file table was affected - the offset and size were changed to the offset and size of the target file. Thus, for example, I ‚Äúzamapal‚Äù all versions of the images of the initial screens in different languages ‚Äã‚Äãinto one - English-language, which was destined to become Russian-speaking.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I rebuilt the archive again, and this time it fit. And so I made the first trial run of the game with changed resources ... I can‚Äôt say that everything worked out simply and without freezing - I didn‚Äôt use that order of bytes, I forgot about portions when packing in LZO, and problems with fonts and text but in the end everything was fine-tuned and the game finally swallowed the reassembled archive without obvious problems. Hurray, earned: I saw the Russian text. But this was not the end of the road, much more was to be done.</font></font><br><br><br><br><br><h1>  Organization of the process </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was very important to adjust the translation process and create at least some semblance of a civilized approach. At that time, I knew about version control systems only by hearsay, and we decided to use </font></font><a href="https://www.dropbox.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dropbox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , creating a shared folder for the project. Meanwhile, Dangaard completed the first version of the glossary, and it was time to think about automating the process of inserting data into the game.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main problem was the replacement of files in the image. There was no question of using any script that was jerking external programs - I did not know such programs with command line support, and aesthetically I would not accept such an approach with regard to this particular operation. Moreover, from the very beginning I planned to create an executable patch for the image, so in any case I would have to resort to the software implementation of such an opportunity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, if so, then we need to look for a project with open source code and the closest to the necessary capabilities. At first my gaze fell on </font></font><a href="http://www.dolphin-emulator.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dolphin.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- A wonderful and simply the only existing Gamecube and Wii emulator. Of course, he knows how to work with images, so I downloaded his sources and began to study them. But the architecture turned out to be quite complicated, and I decided to look for alternatives. Suddenly, I had one idea, and I drove into Google's WiiScrubber sources ... Bingo! They exist!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I must say, this was the beginning of one of the most difficult stages in the history of the project. If I knew this, I would have sat down better and wrote everything myself. There is nothing worse than adapting a very, very focused code to your needs. That's when I practically fully felt the importance and necessity of following patterns and observing a culture of code. After all, I literally had to surgically cut the functionality from the graphical interface. The code was written using MFC, and the logic was integrated into the GUI, where, in addition, some data was stored - for example, file offsets were parsed from text nodes TreeCtrl. I had to replace entities and write fake classes of controls so that everything would somehow get together and work. Coupled with a code that is not entirely clean, it turned into a bloody mess of crutches, dirty hacks and antipatterns,which sooner or later would have to rake.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the goal was achieved. The code was bleeding, but it performed its task - I got the opportunity to programmatically replace the files in the game. Now I had to write an internal utility to quickly insert data into the game. And since not only I had to use it, I had to make it with a simple and clear graphical interface. I didn‚Äôt really like to deal with all kinds of frameworks or go into the wilds of MFC or WinApi, so I decided to use my knowledge again in VCL. I took Borland C ++ Builder 6.0 and started writing.</font></font><br><br><img src="https://habrastorage.org/storage2/d3c/1d7/f36/d3c1d7f36fd5eed2aad7caf6790d05b1.png" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be said that little was received from this IDE in the process. I do not know what is to blame, but without a complete reassembly of the project, every time the program did not even start. Plus, the permanent "shr√∂dingbags" did not allow to localize the place of the error, as a result of which I constantly had to revise all the horror that had to be created earlier. I had to work on the code so that Borland could understand it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having dealt with the problems of compilation, I returned to the problems of functionality. To make the process of replacing files as fast and less redundant, it was necessary to fasten the ability to select specific files for replacement. Based on the contents of the archives, I determined which of them was used in which location, and created a list of archives with corresponding marks. Now, in order to check the text in the game menu, it was not necessary to resort to a complete reassembly of everything and everything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, I sketched a script that serialized resources into game formats and put them into a folder, which was then specified as an input to the program that I just developed. Now it was possible at any time to replace the resources in the game, without exerting excessive effort.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the very least, the translation assembly process was automated. Now it was necessary to make life easier for the translator. I noticed that many files with different names (more precisely, hashes) have the same content, i.e. the text was very often duplicated. Therefore, in the output text files, I ‚Äúslammed‚Äù all such duplicates into one, giving them composite names. And when serializing it was just a bunch of files instead of one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then I drew attention to the abundance of technical data in the text. It was simply unreadable for the human eye due to the huge number of tags.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><blockquote> &amp;push;&amp;main-color=#E67E00FF;Energy Cell ID:&amp;pop; <br> SN-3871S-7 <br><br> &amp;push;&amp;main-color=#E67E00FF;Status:&amp;pop; <br> &amp;if=hasitem:Fuse7Used;Used&amp;else;&amp;if=hasitem:Fuse7;Acquired&amp;else;Unknown&amp;endif;&amp;endif;&amp;if=scan:SCAN,0x6479E69556A56AC8; <br> &amp;if=(hasitem:Fuse7Used)|(hasitem:Fuse7); <br> &amp;push;&amp;main-color=#E67E00FF;Previous Coordinates:&amp;pop;&amp;else; <br> &amp;push;&amp;main-color=#E67E00FF;Coordinates:&amp;pop;&amp;endif; <br> &amp;if=mapped:PirateCommand;04P-MET, Pirate Homeworld&amp;else;04P-MET, Unknown&amp;endif; <br><br> &amp;just=left;Data indicates Energy Cell is connected to &amp;push;&amp;main-color=#FF6705B3;processing&amp;pop; containment core.&amp;endif; <br></blockquote></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortunately, such problems had to be solved before, and I sketched an xml file describing the syntax for Notepad ++. </font><font style="vertical-align: inherit;">It was very opportune that Dangaard translated the text exactly in it, because Word and other text-based combines with its autochange and other things are capable of delivering many problems. </font><font style="vertical-align: inherit;">After these manipulations, it became very easy to perceive the text - the problem was solved.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/c6f/e6f/fca/c6fe6ffca72e8fb78820fc2e7a72598c.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Later it took a little more confusion with the text. </font><font style="vertical-align: inherit;">Dangaard asked me - it was incredibly tedious to keep a glossary of location names and use it everywhere in translation, so I was required to automate this process. </font><font style="vertical-align: inherit;">I sketched a program that read the glossary file, parsed the text files, and if the line fully corresponded to the glossary element, I replaced it with the translated version. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The translation went at full speed and the baton of the load intercepted Dangaard, translating large volumes of text of a technical nature.</font></font><br><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Imaginary finish </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time passed, progress also did not stand still. And so, at some point, Dangaard reported on the completion of the translation of the game magazine - the most complex and voluminous part of the text, because there were descriptions of almost all game objects and an extensive collection of mini-articles with more detailed consideration. This undoubtedly meant a shift in progress towards completing the transfer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At about this point, I began to look for ways to create a low-weight executable patch. The main problem was to find the means for the smooth development of a GUI application, while maintaining the small size and solidity of the executable file and decent design. In the process, I met a lot of criticism - many believed that nowadays you should not pay such attention to file size, and in general, it is better to just distribute the patched image through torrents. But for me it was a matter of principle, because the fact that the user interface of a patch takes up more memory than the patch data itself hurt my sense of aesthetics, so it became a kind of challenge. In addition, an important role was played by the legal side of the issue: I did not want to violate anyone's copyright by distributing an illegal copy of the game.For the same reason, I even bought a license disk.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little more time passed, and it was already possible to anticipate the not so far end of work. Pretty tired of the project, we decided to pre-announce a set of testers. The fact is that we discovered some problem: our translated text does not always fit in the screen space allotted to it, and therefore we decided that the earlier we begin to detect and correct such places, the better it will be for everyone. After all, the more time passed, the less enthusiasm remained in our bins.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was disappointing that only one person responded to the call. Nothing demotivates as the realization that your work is not so in demand, and the work continued with less pleasure. The situation was aggravated by the need to refactor the problem code to replace the images in the game, because if this was suitable for internal use, then releasing this into production did not allow conscience. Another stopping factor was the need to create a patcher that meets the requirements.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No one else responded, and under the weight of the circumstances, our affairs declined and everything fell, as is often the case. </font><font style="vertical-align: inherit;">There have been many attempts to return the translation to the system, but there was not enough enthusiasm for long. </font><font style="vertical-align: inherit;">Once, in the dreams of voice acting, I even made out the format in which the sound of speech was stored - it was the container of one of the versions of the </font></font><a href="http://fmod.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FMOD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, I didn‚Äôt succeed in achieving a full-fledged sounding, but the point is not complexity, but lack of necessity - I initially knew that you couldn‚Äôt do a good dubbing on the knee.</font></font><br><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Second wind </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two years have passed since then. During this time I got a job, graduated from the university and got a lot of new experience in my specialty. Unfortunately, carefree times are gone, and there was too little time and effort left for their hobbies after work. But all this time, the conscience was tormented by the thought that we have unfinished projects that were once promised to society. In the head of the vital the thought ‚Äúit is necessary‚Äù, but as soon as it reached the point, it became clear that this thought was not enough. Dangaard occasionally translated something and poked me with a wand, which also made me worry.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At some point, I again looked at my work, and decided that something had to be changed. And I began to change everything, trying to bring everything in accordance with the requirements of any adequate business process. First of all, the reorganization touched our method of data consistency. To use Dropbox for these purposes was no good, and I began to look towards version control systems. No matter what they say, but I like Subversion, so I created an svn repository on one of the hosting sites and started transferring data there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately the problem surfaced. The text was stored in unicode, since Notepad ++ did not always correctly save UTF-8, which periodically led to the corruption of some characters. Possibly due to </font></font><a href="http://ru.wikipedia.org/wiki/Byte_order_mark"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BOM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SVN recognized the files as binary, so I had to manually set the text content type. After these manipulations, the text was perceived without problems, but then again and again there were problems - then the version comparison utilities did not perceive Unicode, then in the event of conflicts, the corresponding text labels were written to files as ANSI text. But it was too late to change something, and problems of this kind did not arise so often, so everything was left as it was.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as the migration to SVN was completed, I was surprised to see that I enjoyed the process. Working with ordered data at a higher level of organization turned out to be one pleasure compared to previous experience, so I decided not to stop at this and turned my gaze to the toolkit. I decided to rewrite everything that is impossible to refactor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For one and a half years of practical experience, I really liked Qt, so it was decided to use it here. Here all the necessary projects were created and the work began to boil. At first, I even covered everything rewritten by tests, but then I got tired of it and I decided to focus on the correctness of the output, and not on the correctness of the code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All the tools were rewritten, with the exception of the font editor and the text serializer - they worked and worked fine, and there was no need to implement this functionality anywhere. </font><font style="vertical-align: inherit;">After a while, the hands reached even the bloody mess that I had to generate to be able to replace the files in the image. </font><font style="vertical-align: inherit;">After a couple of dozen commits, this code found at least some form, and I could already afford to use it to create a patcher. </font><font style="vertical-align: inherit;">Following and inserting data has been completely rewritten using Qt instead of VCL.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/9b6/d7c/f8d/9b6d7cf8db99cb7975d34dc9b70114cf.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided that I would use Qt for the patcher, and killed a lot of time, trying to build it in a static configuration with the minimum size of the resulting libraries. However, at least ‚Äúfine tuning‚Äù is maintained in the Qt build system, but in reality either my hands turned out to be crooked, or this possibility simply did not work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thoughts have already begun to come to me, and can I just cut out the code and data I do not need? And I </font></font><a href="http://habrahabr.ru/qa/20056/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asked a question</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> here on Habr√©. The hopes were justified - </font></font><a href="https://habr.com/users/mikhailedoshin/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MikhailEdoshin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saved me by </font><a href="https://habr.com/users/mikhailedoshin/" class="user_link"><font style="vertical-align: inherit;">telling</font></a><font style="vertical-align: inherit;"> me that there were flags in MSVC that would allow us to compile the code in a special way, and tell the linker to cut out unused data. After trying this method, I realized that it works fine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I created a patcher project and started developing it. </font><font style="vertical-align: inherit;">If two years ago I wanted to see in its quality something resembling a hacker craft, now it was the desire to see a solid installer, maximally protecting the authors from potential legal problems. </font><font style="vertical-align: inherit;">So I took the </font></font><a href="http://qt-project.org/doc/qt-4.8/qwizard.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QWizard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and started on the basis of it to make a patcher in the best traditions of the installer.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/f7c/d0a/b2c/f7cd0ab2c8c2559f96116fb0b56d56ae.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems that everything went well, but soon there was one unpleasant problem ... </font></font><br><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unexpected hang </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At some point, the game just began to hang after the main menu. It was terrible, because before that everything worked and anything could have caused the hang. Replacing archives via WiiScrubber gave the same effect, so I could not blame specifically the patcher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It took a lot of time to search for possible junk files using the dichotomy method, but in the end it turned out that it wasn‚Äôt time to do it and if there were any changes, the game would be hung by another file. And then I decided to check one guess, which, in principle, from the very beginning kept in my head, but was rejected as unlikely.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To uncover the essence, you must first tell a little about the device disk Wii. While a regular DVD is divided into sectors of 2048 bytes in size, the Wii disk is divided into clusters of 0x8000 bytes. Clusters, in turn, consist of a header with a size of 0x400 bytes and data with a size of 0x7C00 bytes. The clusters themselves are grouped into eight groups, which are then grouped into groups of eight groups. The cluster header stores hashes, hashes, hashes, and hashes, hashes, hashes ... well, first things first.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> uint8 Hash[<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClusterHeader</span></span></span><span class="hljs-class"> {</span></span> Hash h0[<span class="hljs-number"><span class="hljs-number">31</span></span>]; uint8 padding0[<span class="hljs-number"><span class="hljs-number">20</span></span>]; Hash h1[<span class="hljs-number"><span class="hljs-number">8</span></span>]; uint8 padding1[<span class="hljs-number"><span class="hljs-number">32</span></span>]; Hash h2[<span class="hljs-number"><span class="hljs-number">8</span></span>]; uint8 padding2[<span class="hljs-number"><span class="hljs-number">32</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cluster</span></span></span><span class="hljs-class"> {</span></span> ClusterHeader header; uint8 data[<span class="hljs-number"><span class="hljs-number">0x7C00</span></span>]; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, the header contains the table from the 31st SHA1 hash, called H0. It stores hashes of every 1024-byte data block in a cluster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second table, H1, stores the hashes of the H0 tables of each cluster in the subgroup. Since this table is in the header of each cluster, then within the same subgroup, all clusters have the same contents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also a table H2, which stores hashes of tables H1 of all subgroups in a group. Therefore, it, in turn, is the same for all clusters in a group.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, each partition on the disk has a global hash table that stores the hashes of the H2 tables of each cluster group. This table, along with the rest of the section header information, is protected by a digital signature, which along the chain also de facto protects the tables of the other levels, including eventually the cluster data themselves. By the way, they are also encrypted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For any change in the image, you must recalculate all the hashes and re-sign the global hash table. But the private key for signing is unknown to anyone other than Nintendo, so the workaround, known as the </font></font><a href="http://wiibrew.org/wiki/Signing_bug"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signing bug, is used</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that a bug was detected in the Wii firmware: when verifying the digital signature, the hashes were compared using the strncmp function. This function is designed for strings and has one feature: if there is a zero byte at the beginning of both compared data strings, they are taken as empty strings, and, as a result, are considered equal. Therefore, to launch the modified content on the Wii, a previously prepared digital signature is used, the hash of which starts from zero. To ensure that the content hash also starts from zero, the data is adjusted by changing the reserved fields.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knowing this, I wrote a validation function that counted the hashes and compared them with the specified ones. </font><font style="vertical-align: inherit;">And indeed - at some point the check failed due to an invalid hash. </font><font style="vertical-align: inherit;">The problem with the hang was that the source of the WiiScrubber had a bug, which in some cases did not update the hashes of the last processed cluster. </font><font style="vertical-align: inherit;">After removing the bug, everything began to work, and I was very pleased. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considering this unpleasant experience, I have built in the internal assemblies of the patches a mandatory check of the validity of the image and the reassembled archives themselves. </font><font style="vertical-align: inherit;">In which case the patch would simply not apply.</font></font><br><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testing and release </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem with the hang was fixed, the patch build process was automated, the translation was now really nearing completion, and we decided to re-recruit volunteers for testing. This time, quite a few people responded, although in the end only three of them actually participated, including me. I distributed the patches and the process started ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before that, I tried to prevent most technical errors by adding several tests to the patch build process. If they collapsed, the patch just was not going to. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But problems still flowed like a river. I barely had time to handle the bug reports, as new ones appeared. At the same time, it was reported not only about errors, but also about any sentences that cut ear to ear, so testing soon turned into a detailed reworking of the entire text.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out that the problem with the text that did not fit had a much larger scale than we could have imagined. </font><font style="vertical-align: inherit;">Due to the peculiarities of the Russian language, the translation was longer and simply did not fit on the screen. </font><font style="vertical-align: inherit;">Therefore, gritting my teeth, I sat down and wrote a game script editor with the possibility of approximate text visualization.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/6eb/d31/7c9/6ebd317c934964fd17c69815165c79e2.png"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the testers, a man under the nickname SonyLover, was previously a co-translator in one of our projects. </font><font style="vertical-align: inherit;">He offered his help in bringing the translation to the end, and together we began to rule literally every sentence. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meanwhile, there was one unpleasant problem with fonts: some characters seemed to be higher than others, which created the effect of ‚Äújumping‚Äù text. </font><font style="vertical-align: inherit;">Looking closely, I saw this problem in the original, but there it was less pronounced and therefore not so noticeable.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hidden screenshot</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/0ba/18c/b41/0ba18cb41e9f1b12ed00a85fd77198c8.jpg"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason turned out to be simple and </font></font><a href="http://habrahabr.ru/post/147165/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">something similar was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> already described on Habr√©: the characters adjacent to the edges of the texture were not interpolated from the adjacent side, and therefore looked clearer than the characters that were further from the edge. Visually, this created the effect of a difference in character height. However, the problem was solved by simply adding a frame of transparent pixels so that no other character would lie adjacent to the edges of the texture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this pace, we worked for a month and a half, polishing all unpleasant moments and arguing over every little thing. And so, we are very close to the release. Although at the last moment we had to resort to fairly global changes, such as changing a couple of glossary elements or finding untranslated system messages embedded in the executable game file, but there is no longer enough to check them.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, a solemn day came for us. On January 26, 2013, I made the last edits, reposted in repositories, compiled a patch with the release configuration, and announced the release of the translation. To say that the mountain fell from my shoulders - to say nothing. Of course, I did not feel indescribable joy, but then conscience had one less reason to pester me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the translation did not come out perfect - there is no limit to perfection, and immediately after the release a couple of unpleasant, but not critical moments with text formatting came to light. But to release a new version is a matter of five minutes, so this did not upset me greatly. The main thing is that we were satisfied with our work, as well as our target audience.</font></font><br><br><br><br><br><h1>  Afterword </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returning to the title, I want to talk a little about our plans. Not long ago, I was sure that I would no longer return to translation, but, apparently, I was wrong. Then I thought that this translation will most likely be my last, but then I decided that we should complete at least one more unfinished project that hundreds of people have been waiting for from us for two years - the translation of </font></font><a href="http://consolgames.ru/projects/Silent_Hill:_Shattered_Memories"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silent Hill: Shattered Memories</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And there it will be seen whether the soul will still lie to the amateur translations. Still, it‚Äôs not for nothing that very many, growing up, leave this scene.</font></font><br><br>  ,        ,         . ,    - . ,     ,   .  ,  -      . <br><br>     ,    . <br><br> <b>UPDATE</b> :  <a href="https://github.com/mbystryantsev/consolgames-tools/tree/master/game-specific/Metroid%2520Prime%25203">  github</a> . </div><p>Source: <a href="https://habr.com/ru/post/167827/">https://habr.com/ru/post/167827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167815/index.html">Developing games for Windows 8 using MonoGame: touchscreen support</a></li>
<li><a href="../167817/index.html">Sierpinski Triangle and Pascal's Triangle</a></li>
<li><a href="../167819/index.html">Yandeks.Narod: hosting moves to uCoz</a></li>
<li><a href="../167821/index.html">Impressions of the Enot V134 tablet</a></li>
<li><a href="../167823/index.html">Separate server for MySQL database - how to save traffic and speed up the application</a></li>
<li><a href="../167829/index.html">The study of the puzzle game "Minesweeper" (continued)</a></li>
<li><a href="../167831/index.html">Library morelinq: what is missing in LINQ to Objects out of the box</a></li>
<li><a href="../167833/index.html">A hybrid airship successfully passed the first tests</a></li>
<li><a href="../167835/index.html">Google patented a smartphone with 8 flashes</a></li>
<li><a href="../167837/index.html">Profiling already running programs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>