<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make C / C ++ compiler generate bad code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of the article ‚Äú How to trick C / C ++ compilers into a generating terrible code? , The author of the original - Aater Suleman. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make C / C ++ compiler generate bad code</h1><div class="post__text post__text-html js-mediator-article">  <i>This is a translation of the article ‚Äú <a href="http://www.futurechips.org/tips-for-power-coders/how-to-trick-cc-compilers-into-generating-terrible-code.html">How to trick C / C ++ compilers into a generating terrible code?</a></i>  <i>, The author of the original - Aater Suleman.</i> <br><br>  On a computer architecture course, I was told that the processor was like a car.  The steering wheel and pedals are ISA, the engine is a micro-architecture, and the program is the driver.  Continuing this analogy, I will say that using a computer is similar to controlling a machine through a remote control.  The console is a cool thing, but at the same time it is important to understand how it works.  Even in professional software, I have seen many examples of code that even the smartest compiler can confuse.  In this article I will talk about the main methods of entangling compilers. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Before I fully immerse in the reasoning about compilers, I want to add a little disclaimer: although I believe that existing compilers need improvement, I also think that compilers will always have bottlenecks where the programmer will need to help them a little.</i> <br><br><h4>  Compilers </h4><br>  The compiler takes your code in a high level language and converts it into machine code.  The scheme of the compiler looks like this: <br><br><ol><li>  Parse the code and build its intermediate representation. </li><li>  Optimize intermediate performance. </li><li>  Generate machine code. </li><li>  Perform linking. </li></ol><br><br>  Optimization of the code requires the compiler to perform quite a lengthy analysis.  A simple example is the removal of a dead code (English dead code elimination, DCE).  When running DCE, the compiler excludes code from the program, the execution of which does not affect the result of the program.  For example, the loop in lines 3 and 4 will be excluded by the compiler, because the result of the loop is not used anywhere. <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) <span class="hljs-number"><span class="hljs-number">4</span></span>: x += i; <span class="hljs-number"><span class="hljs-number">5</span></span>: }</code> </pre> <br><br>  When running DCE, the compiler performs a reverse data flow analysis (def-use) to determine which variables are not used.  It then deletes the lines that write to these unused variables.  In order for the compiler to perform DCE and other similar optimizations, it must be able to know with 100% certainty whether the variable will be accessed.  This is where the possibilities for compiler obfuscation are revealed.  We can use several well-known bottlenecks. <br><br><h4>  Function calls </h4><br>  Compiler analysis is a very complex computational task.  For reference, the code of the compiler itself is probably the most complex code in the world.  Moreover, optimization problems occur very quickly.  To keep compile time within reasonable limits, compilers often limit the scope of analysis to functions and perform limited inter-procedural analysis (eng. Inter-procedural analysis, IPA) or do not perform it at all.  In addition to this, a compiler that perceives functions as independent entities can compile several files at the same time. <br><br>  Adding multiple layers of function calls, ideally also scattered across different files, is often a good way to confuse the compiler. <br><br>  Let's look at this example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) x += bar(i); }</code> </pre><br><br>  And in another file: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br><br>  The programmer might think that the extra resources here are spent only on <code>bar()</code> calls.  However, during the compilation of <code>foo()</code> compiler cannot see that <code>bar()</code> has no side effects, such as writing to a global variable or I / O operations.  Therefore, it disables DCE, and the useless loop will now also be executed.  The result can be a significant drop in performance. <br><br><h4>  Pointers </h4><br>  I have seen many programmers use pointers unnecessarily.  In theory, for pointers, the main source of waste of resources is their dereference (if any).  In practice, they burn much more resources, because they tangle the compiler. <br><br>  The pointer, theoretically, can point to any place in memory.  As soon as the compiler encounters a pointer in the code, it can no longer be sure which variables will be accessed.  Therefore, it assumes that several variables in the scope can be accessed through a pointer.  In the eyes of the compiler, this often creates a bunch of false dependencies.  My classic example is this cycle (I found it in an image processing program): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) *a++ = *b++ + *c++;</code> </pre><br><br>  After careful study, a person can understand that the code actually does the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = b[i] + c[i]; a += N; b += N; c += N;</code> </pre><br><br>  The first code confuses the compiler.  Even if the iterations of the loop are independent, the compiler does not consider them as such;  for this reason, it cannot vectorize this piece of code.  But the second - maybe. <br><br>  <i>For reference: vectorized code runs 5 times faster.</i>  <i>The use of multi-threaded processing can give an increase of 4 times on 4 cores with little effort from the programmer.</i>  <i>The same code, automatically vectorized, gives a speed increase of 5 times without any effort.</i>  <i>I tried the Intel C Compiler (ICC) 9.1 and GCC 4.1.</i>  <i>Results are shown for ICC.</i> <br><br><h4>  If there are no more ideas, use global variables. </h4><br>  Global variables are considered evil for many reasons.  I'll bring one more.  Since they have a global scope, code using global variables cannot be fully optimized by the compiler.  For example, I noticed that the following code runs 30% faster if the variable <code>N</code> local and not global. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = b[i] + c[i];</code> </pre><br><br>  When you declare a global variable <code>N</code> , the compiler leaves it in memory and adds an instruction to the loop to load it.  If we declare <code>N</code> local, the compiler loads it into a register.  You can scold this behavior of the compiler (because N is not <code>volatile</code> ), but you have to work with what is. <br><br><h4>  Conclusion </h4><br>  It is important to remember about IPA and pointers when you write C / C ++ code.  So you can help the compiler generate code that will be executed faster. <br><br>  <b>By the way:</b> I noticed that both GCC and ICC are sensitive to the linking order, i.e.  The generated code depends on the order in which the input files are specified on the linker command line.  This can have a strong impact (up to 10%) on performance due to caching and branch prediction.  If you really appreciate the performance, you should try to play around with the linking order. </div><p>Source: <a href="https://habr.com/ru/post/160995/">https://habr.com/ru/post/160995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160983/index.html">PengPod launches dualboot Linux / Android tablets in January</a></li>
<li><a href="../160987/index.html">Eric Lippert leaves Microsoft</a></li>
<li><a href="../160989/index.html">HotKeys default in Sublime Text 2</a></li>
<li><a href="../160991/index.html">Windows 9 will be called "Windows Blue"? The first detailed assumptions about the successor to Windows 8</a></li>
<li><a href="../160993/index.html">Problems with authorization in Windows 8 Pro</a></li>
<li><a href="../160997/index.html">CSS printed page</a></li>
<li><a href="../161001/index.html">Humidifier: buy or make? Difficulties of choice</a></li>
<li><a href="../161003/index.html">Give a piece of code for Christmas</a></li>
<li><a href="../161005/index.html">HOLO - The Music Amalgamation System</a></li>
<li><a href="../161007/index.html">Google accused of plagiarism of the game Ingress</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>