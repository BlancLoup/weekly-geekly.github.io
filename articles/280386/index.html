<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flume - manage data streams. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! In this series of articles, I plan to talk about how data collection and transfer can be organized using one of the Hadoop tools, Apache Flu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flume - manage data streams. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  In this series of articles, I plan to talk about how data collection and transfer can be organized using one of the Hadoop tools, <a href="https://flume.apache.org/">Apache Flume</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8f9/b03/233/8f9b03233c1349f69b0e495ad4a47946.jpg"></div><a name="habracut"></a><br>  The first article focuses on the basic elements of Flume, their settings and how to launch Flume.  On Habr's expanses, there is already an <a href="https://habrahabr.ru/company/selectel/blog/201204/">article on how to work with Flume</a> , so some basic sections will be very similar to it. <br><br>  In the continuation of the cycle, I will try to highlight in more detail each of the components of Flume, tell you how to set up monitoring for it, write your own implementation of one of the elements and much more. <br><habracut></habracut><br><h2>  1. What is Flume? </h2><br>  Flume is a tool that allows you to manage data streams and, ultimately, transfer them to some ‚Äúdestination‚Äù (for example, to a file system or HDFS). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, organizing the transportation of data through Flume resembles the creation of such a ‚Äúpipeline‚Äù or ‚Äúwater supply system‚Äù.  This ‚Äúpipeline‚Äù consists of various sections (nodes), on which the flow of data is controlled (filtering, splitting the flow, etc.). <br><br>  Flume is a reliable and convenient tool for transporting data.  Reliability is provided first of all by transactional data transmission.  Those.  when properly configured, the Flume node chain can not be a situation in which data is lost or not fully transmitted.  Convenience is in configuration flexibility ‚Äî most tasks are solved by adding several parameters to the configuration, and more complex ones can be solved by creating your own Flume elements. <br><br>  To begin with, we denote the basic terms, and then we look at the structure of a single Flume node. <br><br><h2>  2. Basic terms </h2><br><ul><li>  <b>Event (event)</b> - a data unit with additional meta-information.  By structure, the event resembles a POST request. <br><ul><li>  <b>Headers (headers)</b> - meta-information, a set of pairs ‚Äúkey‚Äù - ‚Äùvalue‚Äù. </li><li>  <b>Content (body)</b> - in fact, the data for the transfer of which everything is started.  Transmitted as byte []. </li></ul><br></li><li>  <b>Client (client)</b> - external, in relation to the node Flume, the service that supplies data. <br><br></li><li>  <b>Source (source)</b> - is responsible for receiving data.  Flume provides two types of sources - EventDrivenSource and PollableSource.  In the first case, the source decides when to add events to the channel (for example, HTTPSource adds events as it receives HTTP requests).  PollableSource versus EventDrivenSource is passive ‚Äî Flume just periodically polls the source for new events. <br><br></li><li>  <b>Sink</b> is the component responsible for transferring data to the next stage of processing.  This could be another Flume node, file system, HDFS, etc. <br><br></li><li>  <b>Channel (channel)</b> - a component that acts as a buffer for transporting data.  The channel is a passive component; it does not independently initiate any actions.  Sources add events to the channel, while drains drain it. <br><br></li><li>  <b>Agent (agent)</b> - the process in which components of the Flume (sources, channels, drains).  JVM Instance, in general.  A single node can contain multiple agents. </li></ul><br><h2>  3. The structure of the node Flume </h2><br>  It would be more correct to call this subsection ‚ÄúFlume Agent Structure‚Äù, since  a Flume node can consist of several agents.  But within the framework of this article, all the examples will be cited as ‚Äúone node - one agent‚Äù, so I will allow myself liberty and will not separate these concepts yet. <br><br>  Consider several configurations for different life situations. <br><br>  <b>Simple knot</b> <br>  By simple node, I mean the most minimalist configuration of Flume, which can only be: <i>source ‚Üí channel ‚Üí drain</i> . <br><br>  Such a configuration can be used for simple purposes - for example, a node is closing in the chain of nodes of our ‚Äúwater supply system‚Äù and performs only one role: it receives data and writes them to a file (the sink deals with recording).  Alternatively, the node is intermediate and simply transfers data further (sometimes it is useful to do this to ensure fault tolerance ‚Äî for example, deploy such a node on a machine with a Flume client to avoid data loss in case of network problems). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/be3/420/a1e/be3420a1e1ee45c79b230d82182020e8.png"></div><br>  <b>Divider</b> <br>  A more complex example that can be used to separate data.  Here the situation is slightly different compared to a single drain: our canal is devastated by two drains.  This leads to the fact that incoming events are divided between two stocks (they are not duplicated, but they are divided).  This configuration can be used to share the load across multiple machines.  At the same time, if one of the end machines fails and the drain attached to it cannot send events to it, the other drains will continue to operate normally.  Naturally, with this machine running will have to take the rap for two. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fb6/058/dd0/fb6058dd08a948978691da0c7243b7f3.png"></div><br><br>  <font color="#999999"><i><b>Note:</b> Flume has thinner tools for load balancing between drains, for this purpose Flume Sink Processors are used.</i></font>  <font color="#999999"><i>They will be discussed in the following parts of the cycle.</i></font> <br><br>  <b>Duplicator</b> <br>  Such a Flume node allows you to send the same events to multiple stocks.  The question may arise - why two channels, can not a channel duplicate events at once into two streams?  The answer is no, because not ‚Äúthe channel is distributing events‚Äù, but ‚Äúthe drain is emptying the channel‚Äù.  Even if such a mechanism existed, the failure of one of the drains would lead to the inoperability of the others (since the channel would have to work according to the principle ‚Äúeither everyone could or no one‚Äù).  This is explained by the fact that in case of a failure at the level of a drain, the sent packet of events does not disappear ‚Äúto nowhere‚Äù, but remains to lie in the channel.  For the transaction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/517/bb4/e75/517bb4e7536441b7b92d576cc47ff157.png"></div><br>  <font color="#999999"><i><b>Note</b> : in this example, unconditional duplication is used - i.e.</i></font>  <font color="#999999"><i>everything is copied to both channels.</i></font>  <font color="#999999"><i>Flume allows not to duplicate, but to separate events according to some conditions - for this purpose Flume Channel Selector is used.</i></font>  <font color="#999999"><i>He will also be discussed in the next articles of the cycle.</i></font> <br><br>  <b>Universal Receiver</b> <br>  Another useful configuration option is multiple sources.  Extremely useful configuration when you need to ‚Äúmerge‚Äù the same type of data obtained in various ways. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2bd/88a/a25/2bd88aa251d648da93536814add437e8.png"></div><br><br>  <b>Summary:</b> <br><ul><li>  A node can have multiple sources, channels, and drains. </li><li>  One source can add events to several channels (duplicate or distribute according to a certain rule). </li><li>  Multiple sources add events to one channel. </li><li>  One stock can work with only one channel. </li><li>  Several stocks can take events from one channel (evenly or according to some balancing rule). </li></ul><br><h2>  4. Configure and launch the Flume node </h2><br>  I think it's time for practical examples.  The standard package Flume contains many implementations of sources / channels / sinks for different occasions - a description of how to configure them can be found <a href="https://flume.apache.org/FlumeUserGuide.html">here</a> .  In this article, I will limit myself to the simplest implementations of the components: <br><br><ul><li>  Memchannel (a channel that uses memory to store events). </li><li>  NetCat Source. </li><li>  Logger Sink (stock output events to the console). </li></ul><br>  Perhaps this is the simplest configuration for the Flume node: <br><br><pre><code class="apache hljs"><span class="hljs-comment"><span class="hljs-comment">### ====================   ==================== ### #    ,      : ,    # &lt;agent&gt;.sources -  ,   (    : my_source) my-agent.sources = my-source # &lt;agent&gt;.channels -     my-agent.channels = my-channel # &lt;agent&gt;.sinks -      my-agent.sinks = my-sink ### ====================  my_source ================== ### #   - netcat (    Flume   -, #          ,  ..,  ) my-agent.sources.my-source.type = netcat # ,     my-agent.sources.my-source.bind = 0.0.0.0 my-agent.sources.my-source.port = 11111 #    (  ,  ),     my-agent.sources.my-source.channels = my-channel ### ====================  my_channel ================== ### #      Flume - memory (   ,     ),      my-agent.channels.my-channel.type = memory #  , _  my-agent.channels.my-channel.capacity = 10000 #      (  ,    "") my-agent.channels.my-channel.transactionCapacity = 100 ### ====================  my_sink ================== ### #   - ,     (      ) my-agent.sinks.my-sink.type = logger #       my-agent.sinks.my-sink.channel = my-channel #      logger -         my-agent.sinks.my-sink.maxBytesToLog = 256</span></span></code> </pre> <br>  It remains now to start the node with our configuration.  This can be done in two ways: <br><br><ol><li>  On the Hadoop cluster, via Cloudera Manager ( <a href="https://habrahabr.ru/company/selectel/blog/201204/">this article</a> has a detailed description of how to do this). </li><li>  As a Java service using the Flume libraries. </li></ol><br>  Since the process of launching Flume using Cloudera Manager is covered in some detail, let's consider the second option - using Java. <br><br>  First you need to add Flume dependencies to our project.  To do this, add the Clodera repository to the pom.xml and two Flume artifacts - <b>ng-sdk</b> and <b>ng-node</b> . <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span>cloudera<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.apache.flume<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>flume-ng-sdk<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>1.5.0-cdh5.3.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.apache.flume<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>flume-ng-node<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>1.5.0-cdh5.3.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  After that create a class with an entry point: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.flume.samples; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.flume.node.Application; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlumeLauncher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Log4j       System.setProperty("log4j.configuration", "file:/flume/config/log4j.properties"); //  Flume  : Application.main(new String[]{ "-f", "/flume/config/sample.conf", //      "-n", "my-agent" //   }); } }</span></span></code> </pre> <br>  Readers familiar with Java will notice that you can not create this class at all, but simply copy the necessary dependencies for Flume into a separate folder and start Java with the necessary command line arguments.  But this is a matter of taste - I prefer that Maven himself tightens all the necessary dependencies, including the Flume components that we developed, and neatly wrapped it all up in a deb package. <br><br>  If all the paths are specified correctly, and the configuration does not contain errors, we will see such a log from Flume in the console. <br><br><div class="spoiler">  <b class="spoiler_title">Conclusion Flume, if everything worked out</b> <div class="spoiler_text"><pre>  INFO main conf.FlumeConfiguration - Processing: my-sink
 INFO main conf.FlumeConfiguration - Added sinks: my-sink Agent: my-agent
 INFO main conf.FlumeConfiguration - Processing: my-sink
 INFO main conf.FlumeConfiguration - Processing: my-sink
 INFO main conf.FlumeConfiguration - Post-validation flume configuration contains configuration for agents: [my-agent]
 INFO main node.AbstractConfigurationProvider - Creating channels
 INFO main channel.DefaultChannelFactory - Creating instance of channel my-channel type memory
 INFO main node.AbstractConfigurationProvider - Created channel my-channel
 INFO main source.DefaultSourceFactory - Creating instance of mycat source
 INFO main sink.DefaultSinkFactory - Creating instance of sink: my-sink, type: logger
 INFO main node.AbstractConfigurationProvider - Channel my-channel connected to [my-source, my-sink]
 INFO main node.Application - Starting new configuration:
 {
     sourceRunners: {
         my-source = EventDrivenSourceRunner: { 
             source: org.apache.flume.source.NetcatSource {
                 name: my-source,
                 state: IDLE
             }
         }
     } 
     sinkRunners: {
         my-sink = SinkRunner: { 
             policy: org.apache.flume.sink.DefaultSinkProcessor@77f03bb1 counterGroup: {name: null counters: {}} 
         }
     }            
     channels: {
         my-channel = org.apache.flume.channel.MemoryChannel {
             name: my-channel
         }
     }
 }
 INFO main node.Application - Starting Channel my-channel
 INFO main node.Application - Waiting for channel: my-channel to start.  Sleeping for 500 ms
 INFO lifecycleSupervisor-1-0 instrumentation.MonitoredCounterGroup - CHANNEL, name: my-channel: Successfully registered new MBean.
 INFO lifecycleSupervisor-1-0 instrumentation.MonitoredCounterGroup - Component type: CHANNEL, name: my-channel started
 INFO main node.Application - Starting Sink my-sink
 INFO main node.Application - Starting Source my-source
 INFO lifecycleSupervisor-1-1 source.NetcatSource - Source starting
 INFO lifecycleSupervisor-1-1 source.NetcatSource - Created serverSocket: sun.nio.ch.ServerSocketChannelImpl [/ 0: 0: 0: 0: 0: 0: 0: 0: 11111] </pre></div></div><br>  To make sure everything works correctly, we will send a small test file <b>test.txt to</b> our NetCat source, which contains 4 lines: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">Message</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Message</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Message</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  It is important that the file ends with a line break.  For a NetCat source, it is an event separator.  If we do not add this line break to the end of the file, the source will assume that the last event did not come completely.  As a result of this, he will persist in waiting for the separator, which, naturally, will never come.  So, we execute the command: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nc</span></span> 127<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> 11111 &lt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.txt</span></span></code> </pre> <br>  As a result, NetCat should display three ‚ÄúOK‚Äù messages as confirmation that all lines of the file have been safely sent and received by the Flume source.  At the same time, the stock should display the following messages in the console: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">sink</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LoggerSink</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Event</span></span>: { <span class="hljs-attribute"><span class="hljs-attribute">headers</span></span>:{} <span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span>: 4<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> 65 73 73 61 67 65 20 31 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Message</span></span> 1. } <span class="hljs-selector-tag"><span class="hljs-selector-tag">sink</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LoggerSink</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Event</span></span>: { <span class="hljs-attribute"><span class="hljs-attribute">headers</span></span>:{} <span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span>: 4<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> 65 73 73 61 67 65 20 32 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Message</span></span> 2. } <span class="hljs-selector-tag"><span class="hljs-selector-tag">sink</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LoggerSink</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Event</span></span>: { <span class="hljs-attribute"><span class="hljs-attribute">headers</span></span>:{} <span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span>: 4<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> 65 73 73 61 67 65 20 33 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Message</span></span> 3. }</code> </pre> <br>  <font color="#999999"><i><b>Note:</b> Flume registers its shutdownHook when it starts up, so there is no need to manually release any resources (connections, open files, etc.) - all components of the node will shut down the JVM themselves.</i></font> <br><br><h2>  5. Chain of Flume nodes </h2><br>  So, we figured out how to configure and run a single node Flume.  However, to manage the flow of data from one node is clearly not enough.  Let's try to build a small chain of three nodes that perform the task of division (essentially balancing): the first Flume node receives information from the client and sends events to the other two nodes.  At the same time, events are not duplicated on the second and third nodes, but are evenly distributed between them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0fe/596/8da/0fe5968da4e6469480ff42c841a297c3.png"></div><br>  Accordingly, for such a scheme requires several configurations (for each node - its own). <br><br><div class="spoiler">  <b class="spoiler_title">Configuration for node 1 (node1.conf)</b> <div class="spoiler_text"><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">node1</span></span>.sources = my-source node1.channels = my-channel #   2 : node1.sinks = my-sink1 my-sink2 node1.sources.my-source.type = netcat node1.sources.my-source.bind = 0.0.0.0 node1.sources.my-source.port = 11111 node1.sources.my-source.channels = my-channel node1.channels.my-channel.type = memory node1.channels.my-channel.capacity = 10000 node1.channels.my-channel.transactionCapacity = 100 #      avro,        #      ,       #      node1.sinks.my-sink1.type = avro node1.sinks.my-sink1.channel = my-channel node1.sinks.my-sink1.hostname = 127.0.0.1 node1.sinks.my-sink1.port = 11112 node1.sinks.my-sink1.batch-size = 100 node1.sinks.my-sink2.type = avro node1.sinks.my-sink2.channel = my-channel node1.sinks.my-sink2.hostname = 127.0.0.1 node1.sinks.my-sink2.port = 11113 node1.sinks.my-sink2.batch-size = 100</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Configuration for node 2 (node2.conf)</b> <div class="spoiler_text"><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">node2</span></span>.sources = my-source node2.channels = my-channel node2.sinks = my-sink #    1    avro,      avro node2.sources.my-source.type = avro node2.sources.my-source.bind = 0.0.0.0 node2.sources.my-source.port = 11112 node2.sources.my-source.channels = my-channel node2.channels.my-channel.type = memory node2.channels.my-channel.capacity = 10000 node2.channels.my-channel.transactionCapacity = 100 node2.sinks.my-sink.type = logger node2.sinks.my-sink.channel = my-channel node2.sinks.my-sink.maxBytesToLog = 256</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">Configuration for node 3 (node3.conf)</b> <div class="spoiler_text"><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">node3</span></span>.sources = my-source node3.channels = my-channel node3.sinks = my-sink #    1    avro,      avro node3.sources.my-source.type = avro node3.sources.my-source.bind = 0.0.0.0 node3.sources.my-source.port = 11113 node3.sources.my-source.channels = my-channel node3.channels.my-channel.type = memory node3.channels.my-channel.capacity = 10000 node3.channels.my-channel.transactionCapacity = 100 node3.sinks.my-sink.type = logger node3.sinks.my-sink.channel = my-channel node3.sinks.my-sink.maxBytesToLog = 256</code> </pre> </div></div><br>  The configurations for nodes 2 and 3 are identical in this example, differing only in port numbers.  Also for communication between the nodes, the standard Flume components are used here: Avro source and Avro drain.  They will be described in more detail in the following articles, but for now it‚Äôs enough for us that Avro Sink can send events over the network, and Avro Source can receive them. <br><br>  Accordingly, each node should be launched in a separate process, and the launch parameters will be as follows: <br><br><pre> <code class="java hljs">Application.main(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{<span class="hljs-string"><span class="hljs-string">"-f"</span></span>, <span class="hljs-string"><span class="hljs-string">"/flume/config/node1.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"-n"</span></span>, <span class="hljs-string"><span class="hljs-string">"node1"</span></span>}); <span class="hljs-comment"><span class="hljs-comment">//     : //Application.main(new String[]{"-f", "/flume/config/node2.conf", "-n", "node2"}); //Application.main(new String[]{"-f", "/flume/config/node3.conf", "-n", "node3"});</span></span></code> </pre> <br>  You can make sure that this configuration is working by feeding a text file with a hundred lines to the first node (small batches of data can be sent to one of the nodes in a bundle, and we will not see the desired effect of data separation). <br><br><h2>  Conclusion </h2><br>  This article is an introductory, here the examples of configuration of Flume nodes can be useful only for debugging or acquaintance with this tool.  In real projects, the Flume topology goes far beyond one or two nodes, and component configurations are much more complex. <br><br>  In the following article: <br><br><ul><li>  Using headers and channel selectors (Channel Selector). </li><li>  Flume combat components: <ul><li>  Avro Source; </li><li>  File Channel; </li><li>  Avro Sink; </li><li>  HDFS Sink; </li><li>  File Roll Sink. </li></ul></li><li>  Monitor the status of the Flume node. </li></ul><br><h2>  Used sources and useful links </h2><br><ul><li>  <a href="https://flume.apache.org/">Apache Flume official page</a> </li><li>  <a href="https://flume.apache.org/FlumeUserGuide.html">The official guide for setting up the components of Flume</a> </li><li>  <a href="https://habrahabr.ru/company/selectel/blog/201204/">Hadoop Part 2: Collecting Data with Flume |</a>  <a href="https://habrahabr.ru/company/selectel/blog/201204/">Selectel's blog</a> - an article about setting up Flume with Cloudera. </li><li>  <a href="http://shop.oreilly.com/product/0636920030348.do">Hari Shreedharan: Using Flume</a> is a good book that describes the capabilities of Flume. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/280386/">https://habr.com/ru/post/280386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280376/index.html">In simple words: We deal with "cloud" services.</a></li>
<li><a href="../280378/index.html">man! (Go => D) .concurrency</a></li>
<li><a href="../280380/index.html">We solve the problem of interception and substitution of DNS queries. DNSCrypt in Yandex Browser</a></li>
<li><a href="../280382/index.html">Yii framework code parsing</a></li>
<li><a href="../280384/index.html">Million files and one laptop</a></li>
<li><a href="../280388/index.html">Understanding multithreading in RxJava</a></li>
<li><a href="../280390/index.html">SaaS solutions to protect any device anywhere: why it‚Äôs simpler and cheaper + implementation example</a></li>
<li><a href="../280394/index.html">How to develop 1C: ERP (and not only)</a></li>
<li><a href="../280396/index.html">About type conversion in arithmetic expressions in C ++ and C #</a></li>
<li><a href="../280400/index.html">Playtests: fears and opportunities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>