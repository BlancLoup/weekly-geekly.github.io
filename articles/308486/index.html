<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From the experience of using SObjectizer: are the actors in the form of finite automata - is it bad or good?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having acquainted readers with the SObjectizer framework , its capabilities and features, you can proceed to the story of some of the lessons that we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From the experience of using SObjectizer: are the actors in the form of finite automata - is it bad or good?</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://habrahabr.ru/post/304386/">Having acquainted readers with the SObjectizer framework</a> , its capabilities and features, you can proceed to the story of some of the lessons that we have learned in more than fourteen years of using SObjectizer in developing C ++ software.  Today we will talk about when agents in the form of finite automata are not a good choice, but when they are.  The fact that the ability to create a large number of agents is not so much a solution as a problem in itself.  And how the first relates to the second ... </p><a name="habracut"></a><br><p>  So, in the three previous articles ( <a href="https://habrahabr.ru/post/306858/">one</a> , <a href="https://habrahabr.ru/post/307306/">two,</a> and <a href="https://habrahabr.ru/post/308084/">three</a> ), we watched the email_analyzer agent evolve from a very simple to a more or less complex class.  I think that many who looked <a href="">at the final version of email_analyzer</a> , the question arose: ‚ÄúBut this is very difficult, could it not be easier?‚Äù </p><br><p>  It turned out so difficult because the agents are represented as finite automata.  In order to process an incoming message, a separate method must be described - the event handler.  In order for the agent to start a new event handler, the current handler must complete.  Therefore, in order to send a request and receive a response, the agent must complete its current handler in order to give the dispatcher the ability to call the appropriate handler when a response is received.  Those.  instead: </p><br><pre><code class="hljs ruby">void some_agent::some_event() { ... /<span class="hljs-regexp"><span class="hljs-regexp">/  . send&lt; request &gt;(receiver, reply_to, params‚Ä¶); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . auto resp = wait_reply&lt; response &gt;(reply_to); ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . }</span></span></code> </pre> <br><p>  You have to write like this: </p><br><pre> <code class="hljs ruby">void some_agent::some_event() { ... /<span class="hljs-regexp"><span class="hljs-regexp">/       . so_subscribe(reply_to).event(&amp;some_agent::on_response); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . send&lt; request &gt;(receiver, reply_to, params...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    some_event  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   . } void some_agent::on_response(const response &amp; resp) { ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . }</span></span></code> </pre><br><p>  From here both such volume, and such complexity at the resulting agent email_analyzer. </p><br><p>  It is possible that in this approach there will be some tricks that would reduce the volume of writings by 20-30%, but the situation will not change fundamentally. </p><br><p>  What can significantly affect the comprehensibility and compactness is the departure from the event model based on callbacks in the direction of a linear code with synchronous operations.  Sort of: </p><br><pre> <code class="hljs markdown">void email<span class="hljs-emphasis"><span class="hljs-emphasis">_analyzer(context_</span></span>t ctx, string email<span class="hljs-emphasis"><span class="hljs-emphasis">_file, mbox_</span></span>t reply<span class="hljs-emphasis"><span class="hljs-emphasis">_to) { try { //   . auto raw_</span></span>content = request<span class="hljs-emphasis"><span class="hljs-emphasis">_value&lt; load_</span></span>email<span class="hljs-emphasis"><span class="hljs-emphasis">_succeed, load_</span></span>email<span class="hljs-emphasis"><span class="hljs-emphasis">_request &gt;( ctx.environment().create_</span></span>mbox( "io<span class="hljs-emphasis"><span class="hljs-emphasis">_agent" ), 1500ms, //     1.5s email_</span></span>file ).content<span class="hljs-emphasis"><span class="hljs-emphasis">_; auto parsed_</span></span>data = parse<span class="hljs-emphasis"><span class="hljs-emphasis">_email( raw_</span></span>content ); //  -checker-,     //   message chain,     . auto check<span class="hljs-emphasis"><span class="hljs-emphasis">_results = create_</span></span>mchain( ctx.environment() ); introduce<span class="hljs-emphasis"><span class="hljs-emphasis">_child_</span></span>coop( ctx, disp::thread<span class="hljs-emphasis"><span class="hljs-emphasis">_pool::create_</span></span>disp<span class="hljs-emphasis"><span class="hljs-emphasis">_binder( "checkers", disp::thread_</span></span>pool::bind<span class="hljs-emphasis"><span class="hljs-emphasis">_params_</span></span>t{} ), [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link"> coop_t &amp; coop </span></span>) { coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; email_</span></span>headers<span class="hljs-emphasis"><span class="hljs-emphasis">_checker &gt;( check_</span></span>results, parsed<span class="hljs-emphasis"><span class="hljs-emphasis">_data-&gt;headers() ); coop.make_</span></span>agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">email_body_checker</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>( check<span class="hljs-emphasis"><span class="hljs-emphasis">_results, parsed_</span></span>data-&gt;body() ); coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; email_</span></span>attach<span class="hljs-emphasis"><span class="hljs-emphasis">_checker &gt;( check_</span></span>results, parsed<span class="hljs-emphasis"><span class="hljs-emphasis">_data-&gt;attachments() ); } ); // ..      ,   //      . auto check_</span></span>handler = [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link"> const auto &amp; result </span></span>) { if( check<span class="hljs-emphasis"><span class="hljs-emphasis">_status::safe != result.status ) throw runtime_</span></span>error( "check failed: " + result ); } ); //     0.75s   ,  //      . auto r = receive( from( check<span class="hljs-emphasis"><span class="hljs-emphasis">_results ).total_</span></span>time( 750ms ), [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link"> const email_headers_check_result &amp; msg </span></span>) { check<span class="hljs-emphasis"><span class="hljs-emphasis">_handler( msg ); }, [&amp;]( const email_</span></span>body<span class="hljs-emphasis"><span class="hljs-emphasis">_check_</span></span>result &amp; msg ) { check<span class="hljs-emphasis"><span class="hljs-emphasis">_handler( msg ); }, [&amp;]( const email_</span></span>attach<span class="hljs-emphasis"><span class="hljs-emphasis">_check_</span></span>result &amp; msg ) { check<span class="hljs-emphasis"><span class="hljs-emphasis">_handler( msg ); } ); //     ,    . if( 3 != r.handled() ) throw runtime_</span></span>error( "check timedout" ); //      ,    . send<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">check_result</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>( reply<span class="hljs-emphasis"><span class="hljs-emphasis">_to, email_</span></span>file, check<span class="hljs-emphasis"><span class="hljs-emphasis">_status::safe ); } catch( const exception &amp; ) { send&lt; check_</span></span>result &gt;( reply<span class="hljs-emphasis"><span class="hljs-emphasis">_to, email_</span></span>file, check<span class="hljs-emphasis"><span class="hljs-emphasis">_status::check_</span></span>failure ); } }</code> </pre><br><p>  In such a case, a more compact and understandable code would turn out that would be similar to the solution of this problem in languages ‚Äã‚Äãsuch as Erlang or Go. </p><br><p>  Our experience suggests that in situations where an agent performs some linear set of operations like ‚Äúsent a request, immediately began to wait for a single answer‚Äù, its implementation in the form of a finite state machine will be disadvantageous in terms of code size and complexity.  Instead of simply waiting for a response and immediately continuing to work after receiving it, the agent needs to complete its current event handler, and all other actions have to be moved to another handler.  If an agent performs N consecutive asynchronous operations during its life, then this agent is likely to have (N + 1) handler.  What is not good, because  the development and maintenance of such an agent will take a lot of time and effort. </p><br><p>  The situation will be completely different if at each moment when the agent is waiting for something, several different messages may come to him, and the agent will have to react to each of them.  For example, an agent may wait for the result of the current operation, and at that moment requests may come to the agent to check the status of the operation and request to perform a new operation.  In this case, at each agent waiting, you will have to paint a reaction to all the expected types of messages, and this can also quite quickly turn the agent code into bulky and poorly understood noodles. </p><br><p>  Since the SObjectizer currently only supports agents in the form of finite automata, it is necessary to carefully evaluate how well the logic of the applied agents lies on the finite automata.  If not very well, then SObjectizer may not be the best choice and it makes sense to look at solutions that use coroutines.  For example, <a href="https://github.com/boostorg/fiber">boost.fiber</a> or <a href="https://github.com/gridem/Synca">Synca</a> (about the last were interesting articles on Habr√©: <a href="https://habrahabr.ru/post/201826/">‚Ññ1</a> and <a href="https://habrahabr.ru/company/yandex/blog/240525/">‚Ññ2</a> ). </p><br><p>  So the three previous articles in the SObjectizer miniseries: from simple to complex, on the one hand, show the capabilities of SObjectizer, but, on the other hand, allow you to see where you can go, there is a solution to the problem from the wrong side.  For example, if you start using agents in the form of finite automata where it would make sense to use agents in the form of coroutines. </p><br><p>  But if for many cases coroutines are more profitable than finite automata, then why does SObjectizer not support agents in the form of coroutines?  There are several serious reasons for this, both technical and organizational.  Probably, if coroutines were part of the C ++ language, coroutines in SObjectizer would already be.  But since  Coroutines in C ++ are now available only through third-party libraries and the topic is not the easiest, then we are not in a hurry with adding this functionality to SObjectizer.  Moreover, this problem has a completely different side.  But to talk about it, you need to go from afar ... </p><br><p>  A long time ago, when the first version of SObjectizer was launched, we ourselves made the same mistake as many newbies who first got a tool based on the model of actors: if you can create agents for each other, then you need to create.  The execution of any task should be presented in the form of an agent.  Even if this task is to receive only one request and send only one answer.  In general, intoxication from new opportunities because of what suddenly you begin to hold the opinion that "there is nothing in the world except agents." </p><br><p>  This resulted in several negative consequences. </p><br><p>  First, the application code turned out to be larger and more complex than we would like.  After all, asynchronous messages are prone to losses and, where one could write one synchronous call, there were bells and whistles around sending a request message, processing a reply message, counting a time-out to diagnose a loss of a request or response.  When analyzing the code, it turned out that somewhere in half of the cases the interaction on the messages is justified, since  there was a transfer of data between different workflows.  And in the remaining places it was possible to merge a bunch of small agents into one big one and carry out all the operations inside him through normal synchronous function calls. </p><br><p>  Secondly, it turned out that the behavior of an application built on agents is much more difficult to follow and even more difficult to predict.  A good analogy would be to observe the flight of a large flock of birds: although the rules of behavior of an individual are simple and clear, it is almost impossible to predict the behavior of the entire flock.  So it is in an application in which tens of thousands of agents live at the same time: each of them works in an understandable way, but the cumulative effect of their joint work can be unpredictable. </p><br><p>  What else is bad is an increase in the amount of information that is needed to understand what is happening in the application.  Take our example with email_analyzer.  A single analyzer_manager agent can supply information such as the total number of requests waiting for its queue, the total number of live agents email_analyzer, and the minimum, maximum, and average waiting times for a request in the queue (the same for requests processing times).  Therefore, monitoring the activities of analyzer_manager is not a problem.  But the collection, aggregation and processing of information from individual email_analyzer-s is already more difficult.  Moreover, the more difficult, the more of these agents and the shorter their lifetime. </p><br><p>  So, the fewer agents live in an application, the easier it is to keep track of them, the easier it is to understand what is happening and how, the easier it is to predict the behavior of the application in certain conditions. </p><br><p>  Thirdly, unpredictability, which occurs from time to time in applications with tens of thousands of agents inside, can cause the application to be partially or completely inoperable. </p><br><p>  A characteristic case: in the application under a hundred thousand agents.  They all use periodic messages to control the timeouts of their operations.  And then at one point, time-outs immediately come for, say, 20 thousand agents.  Correspondingly, on the worker threads, the message queues for processing are swelling.  These queues begin to rake, each agent receives its message and processes it.  But while these 20 thousand messages are being processed, too much time passes and another 20 thousand arrive from the timer.  This is in the appendix to the part of the old messages that are still in queues.  It is clear that everything does not have time to be processed and another 20 thousand messages arrive.  Etc.  The application seems to be honestly trying to work, but gradually degrades to complete inoperability. </p><br><p>  As a result of walking on these rakes at the very beginning of using SObjectizer in our projects, we came to the conclusion that the ability to create a million agents is more of a marketing bullet than a thing demanded in our practice <a href="https://habr.com/ru/post/308486/">*</a> .  And that the approach, which became known as <a href="https://en.wikipedia.org/wiki/Staged_event-driven_architecture">SEDA-way</a> , allows you to build applications that are much easier to control and that behave much more predictably. </p><br><p>  The essence of using the SEDA approach in conjunction with the model of actors is that instead of creating actors who perform a whole chain of successive operations, it is better to create one actor for each operation and build them into a pipeline.  For our example with email analyzers, instead of doing email_analyzer agents that sequentially load email content, parse and analyze this content, we could do several stage agents.  One stage agent would control the queue of requests.  The next stage agent would handle file download operations with email.  The next stage agent would parse the loaded content.  The next is analysis.  Etc. </p><br><p>  The key point is that in the previously shown implementations, email_analyzer itself initiates all operations, but only for one specific email.  And in the SEDA approach, we would have one agent for each operation, but each agent could do it for several emails at once.  By the way, the traces of this SEDA approach are visible even in our examples as an IO agent, which is nothing but a stage agent from SEDA. </p><br><p>  And so, when we began to actively use ideas from SEDA, it turned out that stage agents are quite conveniently implemented as finite automata, since  they at each particular moment of time have to expect different incoming actions and react to them depending on their state.  Here, in our opinion, in the long run, finite automata are more convenient than coroutines. </p><br><p>  By the way, one more thing can be noted that is often paid attention to by those who first meet with SObjectizer for the first time: verbosity of agents.  Indeed, as a rule, an agent in SObjectizer is a separate C ++ class that, at a minimum, has a constructor, will have some fields that need to be initialized in the constructor, the so_define_agent () method will be redefined, several event handlers will be defined as methods ... It is clear that for simple cases all this leads to a fair syntactic overhead (c).  For example, in Just :: Thread Pro, a simple actor logger might look like this: </p><br><pre> <code class="hljs markdown">ofstream log<span class="hljs-emphasis"><span class="hljs-emphasis">_file("..."); actor logger_</span></span>actor( [<span class="hljs-string"><span class="hljs-string">&amp;log_file</span></span>] { for(;;) { actor::receive().match<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">std::string</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>([<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">std::string s</span></span>) { log_file <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">s</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">endl</span></span></span></span><span class="xml"><span class="hljs-tag">; } ); } } );</span></span></span></span></code> </pre><br><p>  Whereas in SObjectizer, if you use the traditional approach to writing agents, you will need to do something like: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">logger_actor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : logger_actor( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ostream &amp; stream ) : <span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ctx}, stream_{stream} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self().event( &amp;logger_actor::on_message ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : ostream &amp; stream_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; s )</span></span></span><span class="hljs-function"> </span></span>{ stream_ &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; ... <span class="hljs-function"><span class="hljs-function">ofstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"..."</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; env.introduce_coop( [&amp;log_file]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent&lt; logger_actor &gt;( log_file ); } );</code> </pre><br><p>  Obviously, in SObjectizer scribbling more.  However, the paradox is that if you follow the SEDA approach, when there are not very many agents, but they can process different types of messages, the agent code swells quite quickly.  Partly because of the very logic of the agents (as a rule, more complex), partly due to the fact that agents are filled with additional things, such as logging and monitoring.  And it turns out that when the main application code of an agent has a volume of several hundred lines, or even more, the size of the syntactic overhead by SObjectizer is completely insignificant.  Moreover, the larger and more complex the agent, the more profitable is its representation in the form of a separate C ++ class.  In toy examples, this is not visible, but in the ‚Äúcombat‚Äù code one feels quite strongly (well, let's say, a <a href="http://eao197.blogspot.com.by/2016/05/progc14-sobjectizer.html">small example of a</a> not very complicated real agent). </p><br><p>  Thus, on the basis of our practical experience, we came to the conclusion that, if we properly combine the model of actors and the SEDA approach, then the representation of agents in the form of finite automata is quite a normal solution.  Of course, somewhere such a decision will lose coroutines in expressiveness.  But in general, agents in the form of finite automata work more than well and do not create any special problems.  Except, perhaps, comparisons of various approaches to the implementation of the model of actors <a href="http://eao197.blogspot.com/2016/08/progcflame-codesize-battle-justthread.html">on micro-measures</a> . </p><br><p>  At the end of the article I want to appeal to readers.  We have another article in our plans, in which we want to touch on such an important problem of the mechanism of interaction based on asynchronous messages, like agent overloading.  And at the same time, show how SObjectizer reacts to errors in agents.  But it would be interesting to know the opinion of the audience: what did you like, what did not like, what I would like to know more about.  This will greatly help us both in the preparation of the next article and in the development of the SObjectizer itself. </p><br><hr><br><p>  <b>*</b> We emphasize that we are talking about our experience.  It is obvious that other teams solving other tasks using the model of actors can successfully use a large number of actors in their applications.  And it has the exact opposite opinion. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308486/">https://habr.com/ru/post/308486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308472/index.html">How is network access control implemented within Cisco?</a></li>
<li><a href="../308474/index.html">Fujitsu World Tour 2016: Moving to Digital Transformation</a></li>
<li><a href="../308480/index.html">Instantly launch almost any OS under Linux using libvirt + qemu</a></li>
<li><a href="../308482/index.html">Blockchain and FINTECH-Hakaton at Innopolis University</a></li>
<li><a href="../308484/index.html">Static and dynamic typing</a></li>
<li><a href="../308488/index.html">Using trigrams for correcting recognition results</a></li>
<li><a href="../308490/index.html">Unexpected behavior of the WinAPI function IsWow64Process ()</a></li>
<li><a href="../308494/index.html">How to give an adequate estimate of the time when uncertainty hits the head</a></li>
<li><a href="../308498/index.html">Air Berlin: Progressive Web App Implementation</a></li>
<li><a href="../308500/index.html">Navigator 2GIS: Extrapolation of the position of the car</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>