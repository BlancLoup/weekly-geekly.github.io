<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ad Visualization 1.1 - Decisions and Conclusion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ad visualization 1.1: 

- Book 1: Overview 
- Book 2: Problems 
- Book 3: Decisions 
- Book 4: Conclusion 
 Now the fun part! Here I will present you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ad Visualization 1.1 - Decisions and Conclusion</h1><div class="post__text post__text-html js-mediator-article"><a name="III"></a><img src="https://habrastorage.org/files/f3d/7ec/2c2/f3d7ec2c25d84489ab61f7d04211187f.png" align="left">  <i>Ad visualization 1.1:</i> <ul><li>  <a href="http://habrahabr.ru/post/245713/">Book 1: Overview</a> </li><li>  <a href="http://habrahabr.ru/post/245823/">Book 2: Problems</a> </li><li>  <b>Book 3: Decisions</b> </li><li>  <a href="https://habr.com/ru/post/246133/">Book 4: Conclusion</a> </li></ul><br clear="all">  Now the fun part!  Here I will present you some solutions that I found during my research.  I hope they give you a general idea of ‚Äã‚Äãhow to optimize game resources in terms of the visualization process. <br><a name="habracut"></a><br><h4>  1. Sort </h4><br>  To begin with, you can arrange all your commands (for example, by the Render State) before filling the command buffer.  This operation will reduce the number of necessary changes to the Render State to a minimum, since you can process all the polygonal meshes of the same type. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/IgCEguihvOI%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjn1TQ8tsvrT_SsZ87ziEl6dR_eew" frameborder="0" allowfullscreen=""></iframe><br><br>  But there are still significant overhead due to the display of all polygonal meshes one by one.  To cut them, there is a useful technique called <b>Batching</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  2. Batching </h4><br>  When you sort polygonal meshes, you sort of group them together in groups.  The next step is to ask the GPU to visualize each pile at a time.  This is the essence of Batching: <br><blockquote>  Batching is a grouping of several polygonal meshes before calling API methods to visualize them.  This is done due to the fact that it takes less time to render one large polygonal mesh than for many small ones.  [ <a href="https://habr.com/ru/post/246133/">a36</a> ] <br></blockquote>  So, <b>instead of</b> calling one Draw Call to the polygonal mesh (which has the same Render State) ... <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/CUOUDhL7qKE%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhidLtW_u8w0d5zLPuUXFRAVZwJ1DA" frameborder="0" allowfullscreen=""></iframe><br><br>  ... you merge polygonal grids (with the same Render State) and display them for one Draw Call.  This is a <b>really</b> interesting topic, because you can visualize <b>different</b> grids (stone, chair or sword) <b>at the same time</b> , while they use the same Render State (in essence, this means that they use the same material settings). <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/bPCwwEvMqQ0%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjIHRZOZvH8tHdZLmqk2ssfSNKv6Q" frameborder="0" allowfullscreen=""></iframe><br><br>  It is important to remember that the integration of polygonal grids occurs in the RAM (RAM) and only then the new large mesh is transferred to the memory of the graphics card (VRAM).  It takes time!  Therefore, Batching is well suited for static objects (stones, houses ...), which are combined once and stored in memory for a long time.  Of course, you can combine dynamic objects, such as laser shots in a space game, for example.  But since they are constantly moving, you will have to create a ‚Äúcloud of shots‚Äù grid every frame and transfer it to the GPU memory! <br><br>  Another point why you should be careful ( <a href="http://www.reddit.com/r/gamedev/comments/2djgnx/what_are_draw_calls_why_do_you_care_what_makes/cjqcd2j">thanks to koyima for the reminder</a> ): if the object is not in the field of view of the camera, it can just be dropped (ignored when displayed).  But if you group several objects together, during rendering you will have to take into account the large polygonal mesh as a whole (even if only a small part of it is really visible).  In some cases, this may be the cause of performance degradation. <br><br>  A more suitable solution for handling <b>dynamic</b> objects is <b>instantiation</b> . <br><br><h4>  3. Instantiation </h4><br>  Instantiating means sending only one polygonal mesh (for example, a laser shot) instead of several, and letting the GPU duplicate it several times.  Drawing the same object in the same position with the same rotation or animation is pretty boring.  Therefore, you can transfer a stream of additional data, such as a transformation matrix, to visualize duplicates in different positions (and different poses). <br><blockquote>  Typical attributes for a copy are the transformation matrix of the ‚Äúmodel to the world‚Äù, the color of the copy, and the animation player along with the bones.  [ <a href="https://habr.com/ru/post/246133/">a37</a> ] <br></blockquote>  Do not hit me hard, but as I understand it, this data stream is just a list in RAM, to which the GPU has access. <br><br>  In total, only one Draw Call per polygonal mesh type is required!  Compared to Batching, the difference is that all instances look the same (because the same mesh is copied), while the combined mesh can consist of several different ones, provided that they use the same Render State settings. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/txIhhn0YkUE%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjhlB4TTL3MQiqh4tcyoMqgywqTeg" frameborder="0" allowfullscreen=""></iframe><br><br>  Then everything will be a little more unusual.  I think the following tricks are cool, even if they are only suitable for special occasions: <br><br><h4>  4. Shader for multi-materials </h4><br>  A shader can have access to several textures and therefore you can use not only one diffuse / normal / reflective texture, but two, for example.  Naturally, this means that you can combine the two materials in one shader.  The materials are mixed with each other, and the degree of mixing is determined by the controlling texture.  Of course, this requires additional expenses from the GPU, since mixing is an expensive operation, but it reduces the number of Draw Calls, due to the fact that you no <b>longer</b> have to ‚Äútear‚Äù the polygonal mesh into parts (see <a href="http://habrahabr.ru/post/245823/">‚Äú4. Polygonal meshes and multimaterials‚Äù</a> ). <br><br>  <a href="https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/LayeredMaterials/index.html">Read more about it here.</a> <br><blockquote>  Documentation says that more Draw Calls are still better than this expensive technique.  Nevertheless, it seemed to me very interesting and, if you need good numbers for statistics, you can argue that ‚Äúpuff‚Äù materials reduce the number of Draw Calls (let it not say anything about performance ... but shhhhh!). <br></blockquote><br><h4>  5. "Skin" polygonal mesh </h4><br>  Remember the above talked about laser shot grid?  I said that this polygonal mesh should be updated every frame, since the shots are constantly moving.  Combining them together and sending the result every frame is quite expensive.  An interesting approach to solving this problem is to automatically add bones to each shot and transfer information as ‚Äúskin‚Äù.  Thus, you can use one large polygonal mesh that can remain in memory, and you will only update bone information with each frame.  Of course, if a new shot object is made or the old one is destroyed, you will have to recreate the polygonal mesh.  But it sounds like a really interesting idea, I think. <br><br>  <a href="http://ippomed.com/unity/one-draw-call-for-each-shader-with-dynamic-meshes-in-unity-3d-the-bob-script/">Read more about it here.</a> <br><blockquote>  Feel free to send me more links about unusual solutions to reduce draw calls! <br></blockquote>  Almost all!  Now you have a certain understanding of what can be done to visualize game resources a little faster.  Do not worry, the next book will be short. <br><br>  <b>the end</b> <br><br><a name="IV"></a><img src="https://habrastorage.org/files/bb8/3a8/280/bb83a82800464f43b9ecc29d608d48e4.png" align="left">  <i>Ad visualization 1.1:</i> <ul><li>  <a href="http://habrahabr.ru/post/245713/">Book 1: Overview</a> </li><li>  <a href="http://habrahabr.ru/post/245823/">Book 2: Problems</a> </li><li>  <a href="https://habr.com/ru/post/246133/">Book 3: Decisions</a> </li><li>  <b>Book 4: Conclusion</b> </li></ul><br clear="all">  Here I will summarize what we have already learned: <br><br><h4>  Avoid small polygonal meshes. </h4><br>  Check the need for small grids or there is an opportunity to combine several small ones into one large one.  Talk to a graphic programmer to get information about the "golden mean" in the number of polygons (the maximum of triangles, the rendering of which does not result in a loss of performance).  You may want to add a few triangles to smooth out the corners.  You should also follow the multi-materials.  If you have collected one large polygonal mesh, but with 5 designated materials, then the large mesh will be broken for visualization, which means that you have 5 small grids left.  Maybe the texture atlas will help you? <br><br><h4>  Avoid too much material. </h4><br>  Speaking of materials, think about managing them.  Sharing materials between game resources may be possible if you plan this before creating a resource.  Large texture atlases can help you. <br><br><h4>  Debugging tools </h4><br>  Discuss with programmers whether it is possible to get in-game statistics to understand how problematic this or that game resource can be.  Sometimes it's hard to get a general idea of ‚Äã‚Äãthe complex game resources.  But if the tool can warn you that some resource has potential performance problems, then you will be able to solve the problem before it is fixed as final. <br><br><h4>  Ask coder </h4><br>  As you can see, this topic is very technical and strongly depends on the context (hardware, engine, driver, game prospects ...).  Therefore, of course, it is a good idea to talk to a programmer about how to configure game resources.  Or just wait, if the loss of performance is due to your resources, then programmers will find you and will poke until you optimize everything you did.  :) <br><blockquote>  Do you know any tips I should add here?  Let me know! <br></blockquote>  Wow, did you read up to here?  You are crazy!  Thank you very much!  Tell us what you think about it.  I hope you learned something new.  :) <br><br>  <b>the end</b> <br><br><hr><a name="a36"></a>  [a36] <a href="http://www.mapcore.org/page/features/_/articles/technical-breakdown-assassins-creed-ii-r24">Technical Breakdown - Assassins Creed II</a> <br><a name="a37"></a>  [a37] <a href="http.developer.nvidia.com/GPUGems2/gpugems2_chapter03.html">NVidia GPU Gems 2</a> </div><p>Source: <a href="https://habr.com/ru/post/246133/">https://habr.com/ru/post/246133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246123/index.html">Open recursive DNS server. Part 2</a></li>
<li><a href="../246125/index.html">Working with ngCordova in Cordova applications</a></li>
<li><a href="../246127/index.html">Startup team: employees must be selected as a wife</a></li>
<li><a href="../246129/index.html">The work of people with visual problems on sensory devices is no longer a perspective, but a reality</a></li>
<li><a href="../246131/index.html">Why "IT people" exhibitions and conferences</a></li>
<li><a href="../246135/index.html">Home automation system TAIYITO</a></li>
<li><a href="../246137/index.html">Alex Schulz (part 1): an introduction to growth hacking</a></li>
<li><a href="../246139/index.html">Turing A-Machine and Hoara Pit-Stop Coffee Machine</a></li>
<li><a href="../246143/index.html">BEM with a human face and backend integration</a></li>
<li><a href="../246153/index.html">Fighting packet loss in video conferencing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>