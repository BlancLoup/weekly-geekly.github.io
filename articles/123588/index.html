<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with Microsoft Kinect in C ++ Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Most recently, Microsoft released a beta version of the Kinect toolkit - Microsoft Research Kinect SDK. The toolkit includes header fil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with Microsoft Kinect in C ++ Applications</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Most recently, Microsoft released a beta version of the Kinect toolkit - Microsoft Research Kinect SDK.  The toolkit includes header files, a library, as well as usage examples in C ++ applications.  But the presence of the SDK itself does not solve the problem with the lack of intelligible examples and documentation.  It is noticeable that Microsoft is more focused on .NET developers, so, for example, on the official forum, the vast majority of topics are related to C #, and when trying to find any description of the API for Kinect, Google provides only a few links, and those to official documentation. <br><br>  This article discusses options for using Microsoft Kinect, as well as the above-mentioned software tools in C ++ applications and in conjunction with the wxWidgets library. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Beginning of work </h2><br>  To get started, you must at least download development tools.  You can do this on the <a href="http://research.microsoft.com/en-us/um/redmond/projects/kinectsdk/">Microsoft Research Kinect SDK</a> page. <br>  We will also need the wxWidgets library.  You can download it (v2.9.1) from the <a href="http://wxwidgets.org/downloads/">official website</a> or from the <a href="http://svn.wxwidgets.org/svn/wx/wxWidgets/trunk/">SVN repository</a> (I prefer SVN HEAD - there are often many new useful things that appear in the official release, but bugs often appear). <br>  For those who prefer the ‚Äúbright‚Äù side and want to develop applications using only free tools, it makes sense to download <a href="http://www.microsoft.com/visualstudio/en-us/products/2010-editions/visual-cpp-express">Visual C ++ 2010 Express</a> , as well as the <a href="http://www.microsoft.com/download/en/details.aspx%3Fid%3D8279">Microsoft Windows SDK for Windows 7</a> (or later), without it, build wxWidgets in Visual C ++ Express, most likely not work. <br><br><h2>  We collect wxWidgets </h2><br>  We will not consider the installation of Visual Studio and Kinect SDK, it all comes down to a few clicks of the Next button in the installation wizard, but we will look at the wxWidgets build process in more detail, since  further development steps of the application depend on it. <br>  After the wxWidgets source code has been downloaded and unpacked into a separate folder, you need to add the <b>WXWIN</b> environment <b>variable</b> , in the value of which you must set the path to the wxWidgets source code folder. <br>  When using source codes from SVN, you must copy the <b>% WXWIN% / include / msw / setup0.h file</b> to <b>% WXWIN% / include / msw / setup.h</b> . <br>  By default, the wxWidgets solution has several available configurations (Figure 1): <br><ul><li>  Debug </li><li>  Release </li><li>  Dll debug </li><li>  DLL Release </li></ul><br>  The first two configurations allow you to build wxWidgets in the form of static libraries, the latter in the form of several dynamically loaded modules. <br><br><img src="https://habrastorage.org/storage1/7b325de0/9eb287c0/bfd804e8/189ed5a5.png"><br><br><h3>  Building static libraries </h3><br>  Before building static libraries (Debug and Release configurations), in the properties of all projects in the solution, set the <b>C / C ++ -&gt; Code Generation -&gt; Runtime Library</b> parameter to Multi-Threaded Debug and Multi-Threaded respectively (Fig. 2). <br><br><img src="https://habrastorage.org/storage1/48b85347/6d88fc9b/aa4ac9a1/54987d8d.png"><br><br>  Setting these compilation options will eliminate the need to install Visual C ++ Redistributable on end-user machines along with our application.  After setting the compilation options, you can build a solution.  As a result, several .lib files should be created in the lib / vc_lib subdirectory, which will later be used in our application. <br><br><h3>  Building dynamic libraries </h3><br>  To build dynamic libraries, nothing needs to be changed in the compiler settings.  But there is another problem - the solution does not contain any dependencies, so the build process will need to be restarted several times, because  when linking some libraries, errors will occur.  After the build, several .DLL and .LIB files should be created in the lib / vc_dll subdirectory. <br>  I would like to note that it is necessary to build (Debug) and debug and optimized (Release) versions of libraries. <br><br><h3>  Create a test application </h3><br>  So, at the moment we have: <br><ul><li>  Visual studio 2010 </li><li>  Microsoft Research Kinect SDK </li><li>  WxWidgets Compiled Libraries <br><ul><li>  Static </li><li>  Dynamic </li></ul></li></ul><br>  You can start creating an application. <br>  In the test application we will have: <br><ul><li> Application class (derived from <code>wxApp</code> ) </li><li>  Main form class (derived from <code>wxFrame</code> ) </li><li>  Canvas class (control derived from <code>wxWindow</code> , which will display the image from the Kinect sensor) </li></ul><br>  <b>KinectTestApp.h</b> <br><blockquote> <code><font color="black">#ifndef _KINECTTESTAPP_H_ <br> <font color="#0000ff">#define</font> _KINECTTESTAPP_H_ <br> <br> #include <font color="#A31515">"wx/image.h"</font> <br> #include <font color="#A31515">"KinectTestMainFrame.h"</font> <br> <br> <font color="#0000ff">class</font> KinectTestApp: <font color="#0000ff">public</font> wxApp <br> { <br> DECLARE_CLASS( KinectTestApp ) <br> DECLARE_EVENT_TABLE() <br> <font color="#0000ff">public</font> : <br> KinectTestApp(); <br> <font color="#0000ff">void</font> Init(); <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> OnInit(); <br> <font color="#0000ff">virtual</font> <font color="#0000ff">int</font> OnExit(); <br> }; <br> <br> DECLARE_APP(KinectTestApp) <br> <br> <font color="#0000ff">#endif</font></font></code> </blockquote> <br><br>  <b>KinectTestApp.cpp</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">bool</font> KinectTestApp::OnInit() <br> { <br> <font color="#0000ff">#if</font> wxUSE_LIBPNG <br> wxImage::AddHandler( <font color="#0000ff">new</font> wxPNGHandler); <br> <font color="#0000ff">#endif</font> <br> <font color="#0000ff">#if</font> wxUSE_LIBJPEG <br> wxImage::AddHandler( <font color="#0000ff">new</font> wxJPEGHandler); <br> <font color="#0000ff">#endif</font> <br> KinectTestMainFrame* mainWindow = <font color="#0000ff">new</font> KinectTestMainFrame( NULL ); <br> mainWindow-&gt;Show( <font color="#0000ff">true</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> }</font></code> </blockquote> <br><br>  <b>KinectTestMainFrame.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> KinectTestMainFrame: <font color="#0000ff">public</font> wxFrame, <font color="#0000ff">public</font> wxThreadHelper <br> { <br> DECLARE_CLASS( KinectTestMainFrame ) <br> DECLARE_EVENT_TABLE() <br> <font color="#0000ff">public</font> : <br> KinectTestMainFrame(); <br> KinectTestMainFrame( wxWindow* parent, <br> wxWindowID id = SYMBOL_KINECTTESTMAINFRAME_IDNAME, <br> <font color="#0000ff">const</font> wxString&amp; caption = SYMBOL_KINECTTESTMAINFRAME_TITLE, <br> <font color="#0000ff">const</font> wxPoint&amp; pos = SYMBOL_KINECTTESTMAINFRAME_POSITION, <br> <font color="#0000ff">const</font> wxSize&amp; size = SYMBOL_KINECTTESTMAINFRAME_SIZE, <br> <font color="#0000ff">long</font> style = SYMBOL_KINECTTESTMAINFRAME_STYLE ); <br> <font color="#0000ff">bool</font> Create( wxWindow* parent, <br> wxWindowID id = SYMBOL_KINECTTESTMAINFRAME_IDNAME, <br> <font color="#0000ff">const</font> wxString&amp; caption = SYMBOL_KINECTTESTMAINFRAME_TITLE, <br> <font color="#0000ff">const</font> wxPoint&amp; pos = SYMBOL_KINECTTESTMAINFRAME_POSITION, <br> <font color="#0000ff">const</font> wxSize&amp; size = SYMBOL_KINECTTESTMAINFRAME_SIZE, <br> <font color="#0000ff">long</font> style = SYMBOL_KINECTTESTMAINFRAME_STYLE ); <br> ~KinectTestMainFrame(); <br> <font color="#0000ff">void</font> Init(); <br> <font color="#0000ff">void</font> CreateControls(); <br> wxBitmap GetBitmapResource( <font color="#0000ff">const</font> wxString&amp; name ); <br> wxIcon GetIconResource( <font color="#0000ff">const</font> wxString&amp; name ); <br> <font color="#0000ff">virtual</font> wxThread::ExitCode Entry(); <br> <br> wxGridBagSizer* m_MainSizer; <br> wxListBox* m_DeviceListBox; <br> KinectCanvas* m_Canvas; <br> }; <br> <br> <font color="#0000ff">#endif</font></font></code> </blockquote> <br><br>  <b>KinectTestMainFrame.cpp</b> <br><blockquote> <code>... <br> <font color="#0000ff">void</font> KinectTestMainFrame::CreateControls() <br> { <br> KinectTestMainFrame* itemFrame1 = <font color="#0000ff">this</font> ; <br> <br> m_MainSizer = <font color="#0000ff">new</font> wxGridBagSizer(0, 0); <br> m_MainSizer-&gt;SetEmptyCellSize(wxSize(10, 20)); <br> itemFrame1-&gt;SetSizer(m_MainSizer); <br> <br> wxArrayString m_DeviceListBoxStrings; <br> m_DeviceListBox = <font color="#0000ff">new</font> wxListBox( itemFrame1, <br> ID_DEVICE_LISTBOX, wxDefaultPosition, <br> wxDefaultSize, m_DeviceListBoxStrings, <br> wxLB_SINGLE ); <br> m_MainSizer-&gt;Add(m_DeviceListBox, <br> wxGBPosition(0, 0), wxGBSpan(1, 1), <br> wxGROW|wxGROW|wxALL, 5); <br> <br> m_Canvas = <font color="#0000ff">new</font> KinectCanvas( itemFrame1, <br> ID_KINECT_CANVAS, wxDefaultPosition, <br> wxSize(320, 240), wxSIMPLE_BORDER ); <br> m_MainSizer-&gt;Add(m_Canvas, wxGBPosition(0, 1), <br> wxGBSpan(1, 1), wxALIGN_CENTER_HORIZONTAL| <br> wxALIGN_CENTER_VERTICAL|wxALL, 5); <br> m_MainSizer-&gt;AddGrowableCol(1); <br> m_MainSizer-&gt;AddGrowableRow(0); <br> } <br> ... <br> wxThread::ExitCode KinectTestMainFrame::Entry() <br> { <br> <font color="#0000ff">return</font> NULL; <br> }</code> </blockquote> <br><br>  <b>KinectCanvas.h</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">class</font> KinectCanvas: <font color="#0000ff">public</font> wxWindow <br> { <br> DECLARE_DYNAMIC_CLASS( KinectCanvas ) <br> DECLARE_EVENT_TABLE() <br> <br> <font color="#0000ff">public</font> : <br> KinectCanvas(); <br> KinectCanvas(wxWindow* parent, <br> wxWindowID id = ID_KINECTCANVAS, <br> <font color="#0000ff">const</font> wxPoint&amp; pos = wxDefaultPosition, <br> <font color="#0000ff">const</font> wxSize&amp; size = wxSize(100, 100), <br> <font color="#0000ff">long</font> style = wxSIMPLE_BORDER); <br> <br> <font color="#0000ff">bool</font> Create(wxWindow* parent, <br> wxWindowID id = ID_KINECTCANVAS, <br> <font color="#0000ff">const</font> wxPoint&amp; pos = wxDefaultPosition, <br> <font color="#0000ff">const</font> wxSize&amp; size = wxSize(100, 100), <br> <font color="#0000ff">long</font> style = wxSIMPLE_BORDER); <br> ~KinectCanvas(); <br> <br> <font color="#0000ff">void</font> Init(); <br> <font color="#0000ff">void</font> CreateControls(); <br> <font color="#0000ff">void</font> OnPaint( wxPaintEvent&amp; <font color="#0000ff">event</font> ); <br> <br> wxImage * GetCurrentImage() <font color="#0000ff">const</font> { <font color="#0000ff">return</font> m_CurrentImage ; } <br> <font color="#0000ff">void</font> SetCurrentImage(wxImage * <font color="#0000ff">value</font> ) { m_CurrentImage = <font color="#0000ff">value</font> ; } <br> <br> wxBitmap GetBitmapResource( <font color="#0000ff">const</font> wxString&amp; name ); <br> wxIcon GetIconResource( <font color="#0000ff">const</font> wxString&amp; name ); <br> <br> wxImage * m_CurrentImage; <br> }; <br> <br> <font color="#0000ff">#endif</font></font> <br></code> </blockquote><br><br>  <b>KinectCanvas.cpp</b> <br><blockquote> <code><font color="black">... <br> IMPLEMENT_DYNAMIC_CLASS( KinectCanvas, wxWindow ) <br> BEGIN_EVENT_TABLE( KinectCanvas, wxWindow ) <br> EVT_PAINT( KinectCanvas::OnPaint ) <br> END_EVENT_TABLE() <br> ... <br> <font color="#0000ff">void</font> KinectCanvas::OnPaint( wxPaintEvent&amp; <font color="#0000ff">event</font> ) <br> { <br> wxAutoBufferedPaintDC dc( <font color="#0000ff">this</font> ); <br> <font color="#0000ff">if</font> (!m_CurrentImage) <br> { <br> dc.SetBackground(wxBrush(GetBackgroundColour(), wxSOLID)); <br> dc.Clear(); <br> dc.DrawLabel(_( <font color="#A31515">"No image"</font> ), wxRect(dc.GetSize()), <br> wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL); <br> } <br> <font color="#0000ff">else</font> <br> { <br> wxBitmap bmp(*m_CurrentImage); <br> dc.DrawBitmap(bmp, <br> (dc.GetSize().GetWidth()-bmp.GetWidth())/2, <br> (dc.GetSize().GetHeight()-bmp.GetHeight())/2); <br> } <br> }</font> <br></code> </blockquote><br><br>  In the source code above, there are several empty methods, as well as several methods whose use is not obvious (for example, the methods <code>GetIconResource()</code> , <code>GetBitmapResource()</code> , <code>Init()</code> ).  All this is because the <a href="http://www.dialogblocks.com/">DialogBlocks</a> form designer was used to create the application framework.  This is a paid tool, but the functionality of the trial version is enough to create our application. <br>  Before attempting to build an application, you need to change the project parameters so that they match the wxWidgets build parameters.  This means that if we want to use the wxWidgets static libraries, we need to set the same values ‚Äã‚Äãfor the Debug and Release configuration in the project properties in the <b>C / C ++ -&gt; Code Generation -&gt; Runtime Library</b> parameter.  If we need to use wxWidgets dynamic libraries, then in the project settings in the <b>C / C ++ -&gt; Preprocessor -&gt; Preprocessor Definitions</b> parameter we need to add the <code>WXUSINGDLL</code> macro.  This macro is also used when building wxWidgets dynamic libraries, and as a result, the settings of our project and wxWidgets will be the same (Fig. 3). <br><br><img src="https://habrastorage.org/storage1/7dc62997/ed799418/39b2d3ff/fd673596.png"><br><br>  Also, for the debug version of the application, it is necessary to add the macro <code>wxUSE_NO_MANIFEST=1</code> to the preprocessor directives in the resource compiler settings.  This is necessary in order to avoid conflicts of the manifest specified in the wxWidgets resource file ( <b>% WXWIN% / include / msw / wx.rc</b> ) and the manifest that Visual Studio automatically adds to the application. <br>  After completing the above steps, you can build the application.  As a result, we will have something like this (Fig. 4): <br><br><img src="https://habrastorage.org/storage1/2dcf97ed/86e6bb56/60da693a/86228bbd.png"><br><br><h2>  Using Microsoft Research Kinect SDK </h2><br>  After installing the Kinect SDK, the environment variable% MSRKINECTSDK% will appear in the system, containing the path to the folder where the SDK was installed.  In this folder there is a subdirectory inc - with header files, and lib - with a library.  The path to the header files should be added to the compiler settings in our test application, the library path should be added to the linker settings. <br><br><h3>  Getting a list of devices </h3><br>  At the moment we have all the collected dependencies and the application template.  Now you can start writing code that directly uses the Kinect SDK. <br>  In Kinect SDK there is a functionality that allows you to work with several Kinect devices connected to one computer.  This is a more universal solution when developing an application.  It is not known in advance how many devices we need.  Therefore, it would be preferable for us to use this particular API. <br>  To retrieve the device list, use the <code>MSR_NuiGetDeviceCount()</code> function, which takes a pointer to an integer variable as a parameter, which, if successfully executed, will record the number of available sensors: <br><br><blockquote> <code><font color="black">NUIAPI HRESULT MSR_NuiGetDeviceCount( <br> <font color="#0000ff">int</font> * pCount <br> );</font></code> </blockquote> <br>  Each Kinect device has its own unique identifier, which can be obtained using the <code>INuiInstance::MSR_NuiGetPropsBlob()</code> method.  This method takes as parameters: <br><ul><li>  Property ID (in the beta version of the SDK there can be only one value - <code>INDEX_UNIQUE_DEVICE_NAME</code> ) </li><li>  Pointer to a variable in which the result will be written </li><li>  The amount of memory available to record the result (for example, the length of a string).  In the beta version of the SDK, this parameter is not used. </li></ul><br><blockquote> <code><font color="black"><font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> MSR_NuiGetPropsBlob( <br> MsrNui::NUI_PROPSINDEX Index, <br> <font color="#0000ff">void</font> * pBlob, <br> DWORD * pdwInOutSize <br> );</font> <br></code> </blockquote><br>  Armed with the knowledge we have just obtained, we can realize the receipt of a list of devices in our application. <br><br>  <b>wxKinectHelper.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> #include &lt;vector&gt; <br> <br> <font color="#0000ff">interface</font> INuiInstance; <br> <br> <font color="#0000ff">class</font> KinectHelper <br> { <br> <font color="#0000ff">protected</font> : <br> typedef std::pair&lt;INuiInstance *, HANDLE&gt; InstanceInfo; <br> typedef std::vector&lt;InstanceInfo&gt; InstanceVector; <br> <font color="#0000ff">public</font> : <br> KinectHelper(); <br> <font color="#0000ff">virtual</font> ~KinectHelper(); <br> <br> size_t GetDeviceCount(); <br> wxString GetDeviceName(size_t index); <br> <br> <font color="#0000ff">bool</font> IsDeviceOK(size_t deviceIndex); <br> <font color="#0000ff">protected</font> : <br> InstanceVector m_Instances; <br> <br> <font color="#0000ff">void</font> Finalize(); <br> InstanceInfo * GetInstanceByIndex(size_t index); <br> };</font></code> </blockquote> <br>  <b>wxKinectHelper.cpp</b> <br><blockquote> <code><font color="black">#include &lt;wx/wx.h&gt; <br> #include <font color="#A31515">"msr_nuiapi.h"</font> <br> #include <font color="#A31515">"KinectHelper.h"</font> <br> <br> KinectHelper::KinectHelper() <br> { <br> } <br> <br> KinectHelper::~KinectHelper() <br> { <br> Finalize(); <br> } <br> <br> size_t KinectHelper::GetDeviceCount() <br> { <br> <font color="#0000ff">int</font> result(0); <br> <font color="#0000ff">if</font> (FAILED(MSR_NUIGetDeviceCount(&amp;result))) <font color="#0000ff">return</font> 0; <br> <font color="#0000ff">return</font> (size_t)result; <br> } <br> <br> KinectHelper::InstanceInfo * KinectHelper::GetInstanceByIndex(size_t index) <br> { <br> INuiInstance * instance = NULL; <br> <font color="#0000ff">for</font> (InstanceVector::iterator i = m_Instances.begin(); <br> i != m_Instances.end(); i++) <br> { <br> instance = (*i).first; <br> <font color="#0000ff">if</font> (instance-&gt;InstanceIndex() == ( <font color="#0000ff">int</font> )index) <font color="#0000ff">return</font> &amp;(*i); <br> } <br> <font color="#0000ff">if</font> (!instance) <br> { <br> <font color="#0000ff">if</font> (!FAILED(MSR_NuiCreateInstanceByIndex(( <font color="#0000ff">int</font> )index, &amp;instance))) <br> { <br> InstanceInfo info; <br> info.first = instance; <br> info.second = NULL; <br> m_Instances.push_back(info); <br> <font color="#0000ff">return</font> &amp;(m_Instances.at(m_Instances.size()-1)); <br> } <br> } <br> <font color="#0000ff">return</font> NULL; <br> } <br> <br> <font color="#0000ff">void</font> KinectHelper::Finalize() <br> { <br> <font color="#0000ff">for</font> (InstanceVector::const_iterator i = m_Instances.begin(); <br> i != m_Instances.end(); i++) <br> { <br> <font color="#0000ff">if</font> ((*i).first &amp;&amp; (*i).second) <br> { <br> (*i).first-&gt;NuiShutdown(); <br> MSR_NuiDestroyInstance((*i).first); <br> } <br> } <br> } <br> <br> wxString KinectHelper::GetDeviceName(size_t index) <br> { <br> BSTR result; <br> DWORD size; <br> InstanceInfo * info = GetInstanceByIndex(index); <br> <font color="#0000ff">if</font> (info != NULL) <br> { <br> INuiInstance * instance = info-&gt;first; <br> <font color="#0000ff">if</font> (instance != NULL &amp;&amp; instance-&gt;MSR_NuiGetPropsBlob( <br> MsrNui::INDEX_UNIQUE_DEVICE_NAME, &amp;result, &amp;size)) <br> { <br> wxString name = result; <br> SysFreeString(result); <br> <font color="#0000ff">return</font> name; <br> } <br> } <br> <font color="#0000ff">return</font> wxT( <font color="#A31515">"Unknown Kinect Sensor"</font> ); <br> } <br> <br> <font color="#0000ff">bool</font> KinectHelper::IsDeviceOK(size_t deviceIndex) <br> { <br> <font color="#0000ff">return</font> GetInstanceByIndex(deviceIndex) != NULL; <br> }</font></code> </blockquote> <br>  The <code>InstanceInfo</code> structure contains a pointer to an <code>INuiInstance</code> instance, with which we can get the device name, as well as a handle to the stream in which the image is captured (which will be discussed later). <br>  The <code>wxKinectHelper</code> class contains a vector of <code>InstanceInfo</code> structures and methods for getting the number of devices, as well as the name of each device.  In the <code>wxKinectHelper</code> class <code>wxKinectHelper</code> , the <code>Finalize()</code> method is called, which closes all open image capture streams and then deletes all instances of <code>INuiInstance</code> . <br>  Now you need to add functionality to get the list of devices in our application. <br><br>  <b>wxKinectHelperMainFrame.h</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">class</font> KinectTestMainFrame: <font color="#0000ff">public</font> wxFrame, <font color="#0000ff">public</font> wxThreadHelper <br> { <br> ... <br> <font color="#0000ff">void</font> ShowDevices(); <br> ... <br> KinectHelper * m_KinectHelper; <br> } <br> ...</font></code> </blockquote> <br>  <b>wxKinectHelperMainFrame.cpp</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">void</font> KinectTestMainFrame::ShowDevices() <br> { <br> size_t count = m_KinectHelper-&gt;GetDeviceCount(); <br> m_DeviceListBox-&gt;Clear(); <br> <font color="#0000ff">for</font> (size_t i = 0; i &lt; count; ++i) <br> { <br> <font color="#0000ff">int</font> item = m_DeviceListBox-&gt;Append( <br> m_KinectHelper-&gt;GetDeviceName(i)); <br> m_DeviceListBox-&gt;SetClientData(item, ( <font color="#0000ff">void</font> *)i); <br> } <br> }</font></code> </blockquote> <br>  As a result, after launching the application, we will receive a list of available Kinect devices (Fig. 5): <br><br><img src="https://habrastorage.org/storage1/4333bb7b/86451b30/71a999c1/f957fe39.png"><br><br><h3>  Getting the image from Kinect </h3><br>  Before you start capturing an image from a device, you need to initialize it.  This is done using the <code>INuiInstance::NuiInitialize()</code> method, which takes a bit mask as a parameter that describes the list of subsystems of the device that we plan to use (depth sensor, camera, or search for players in the video). <br><blockquote> <code><font color="black">HRESULT NuiInitialize( <br> DWORD dwFlags, <br> );</font></code> </blockquote> <br>  In order to receive an image from Kinect it is necessary to initialize the image capture stream.  For these purposes, the method is used <code>INuiInstance:: NuiImageStreamOpen()</code> , which takes as parameters: <br><ul><li>  Image type (color image, depth buffer, etc.) </li><li>  Resolution (from 80x60 to 1280x1024) </li><li>  Image processing flags (not used in the SDK beta) </li><li>  The number of cached frames (the maximum value of <code>NUI_IMAGE_STREAM_FRAME_LIMIT_MAXIMUM</code> is currently 4) </li><li>  Descriptor of the event that will occur when a new frame is received (optional parameter, but in fact it turned out that if you pass <code>NULL</code> , then the capture stream may not start) </li><li>  Pointer to a variable in which the handle of the image capture stream will be written upon successful completion of the function. </li></ul><br>  In order to stop capturing images from a device, you need to call the <code>INuiInstance::NuiShutdown()</code> method, and after you finish working with the <code>INuiInstance</code> instance, <code>INuiInstance</code> need to free the memory using the <code>MSR_NuiDestroyInstance()</code> function, in which parameter you must pass a pointer to an <code>INuiInstance</code> object. <br><br><h4>  Depth Buffer </h4><br>  In order to start acquiring the depth buffer, you must call the <code>INuiInstance:: NuiImageStreamOpen()</code> method and, as the first parameter, pass a value containing the <code>NUI_IMAGE_TYPE_DEPTH_AND_PLAYER_INDEX</code> or <code>NUI_IMAGE_TYPE_DEPTH</code> .  The buffer that was most suitable for subsequent processing was obtained using the <code>NUI_IMAGE_TYPE_DEPTH_AND_PLAYER_INDEX</code> flag.  In the source code, such a call would look like this: <br><blockquote> <code><font color="black"><font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiImageStreamOpen(NUI_IMAGE_TYPE_DEPTH_AND_PLAYER_INDEX, <br> NUI_IMAGE_RESOLUTION_320x240, 0, <br> 3, <br> hDepthFrameEvent, <br> &amp;info-&gt;second))) { <font color="#008000">/* Handle error here */</font> }</font></code> </blockquote> <br>  As a result of the call described above, in the variable <code>info-&gt;second</code> will be a handle to the image capture stream.  <code>hDepthFrameEvent</code> can create an <code>hDepthFrameEvent</code> event <code>hDepthFrameEvent</code> using the <code>CreateEvent()</code> function. <br><br>  When a new image is available, the <code>hDepthFrameEvent</code> event will be triggered.  Waiting for this event can be implemented using the <code>WaitForMultipleObjects()</code> function or <code>WaitForSingleObject()</code> function. <br><br>  You can get the buffer from the device itself using the <code>NuiImageStreamGetNextFrame()</code> method, which needs to be passed as parameters: <br><ul><li>  Capture Stream Handle </li><li>  Buffer timeout in milliseconds </li><li>  Pointer to a NUI_IMAGE_FRAME structure to which information about the received buffer will be written </li></ul><br><blockquote> <code><font color="black"><font color="#0000ff">virtual</font> HRESULT NuiImageStreamGetNextFrame( <br> _In_ HANDLE hStream, <br> _In_ DWORD dwMillisecondsToWait, <br> _Deref_out_ CONST NUI_IMAGE_FRAME **ppcImageFrame <br> );</font></code> </blockquote> <br>  In the resulting instance of <code>NUI_IMAGE_FRAME</code> we are currently most interested in the <code>NuiImageBuffer *pFrameTexture</code> . <br>  To work directly with the buffer data, you must call the <code>LockRect()</code> method.  The <code>LockRect()</code> method <code>LockRect()</code> four parameters, of which two are used in the beta version of the API. <br>  As the first parameter, you need to pass 0, as the second - a pointer to the <code>KINECT_LOCKED_RECT</code> structure, in which, after successful completion of the function, the data for working with the buffer will be written.  We pass <code>NULL</code> as the third parameter, and 0 as the fourth. <br><blockquote> <code><font color="black">STDMETHODIMP LockRect( <br> UINT Level, <br> KINECT_LOCKED_RECT* pLockedRect, <br> CONST RECT* pRectUsuallyNull, <br> DWORD Flags <br> );</font></code> </blockquote> <br>  Further, in the <code>KINECT_LOCKED_RECT</code> structure <code>KINECT_LOCKED_RECT</code> we are interested in the <code>pBits</code> field, which contains the depth data itself.  For each pixel of the image in the buffer 2 bytes are allocated.  Judging by the <a href="http://social.msdn.microsoft.com/Forums/en-US/kinectsdknuiapi/thread/4da8c75e-9aad-4dc3-bd83-d77ab4cd2f82">FAQ on the official forum</a> , the data format is as follows: <br>  ‚Ä¢ When using the <code>NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX</code> flag, 12 lower bits are reserved for the depth value and the remaining 3 bits are used for the player index, the upper bit is not used. <br>  ‚Ä¢ When using the <code>NUI_INITIALIZE_FLAG_USES_DEPTH</code> flag, 12 lower bits are allocated for the depth value, the rest are not used. <br>  To obtain a grayscale image, we need to normalize the depth value so that we can get a value in the range from 0 to 255. You can do it like this: <br><blockquote> <code><font color="black">USHORT RealDepth = (s &amp; 0xfff8) &gt;&gt; 3; <br> BYTE l = 255 - (BYTE)(256*RealDepth/0x0fff); <br> RGBQUAD q; <br> q.rgbRed = q.rgbBlue = q.rgbGreen = l; <br> <font color="#0000ff">return</font> q;</font></code> </blockquote> <br>  In order to complete the work with the resulting image, it is necessary to free the memory allocated for the buffer.  This can be done using the <code>NuiImageStreamReleaseFrame()</code> method, which takes a stream handle and a pointer to an instance of <code>NUI_IMAGE_FRAME</code> as parameters. <br><br>  Let's summarize what we have at the moment: <br><ul><li>  In order to start the capture, you need to initialize the device using the <code>NuiInitialize()</code> method. </li><li>  Then you need to start the capture stream using the <code>NuiImageStreamOpen()</code> method. </li><li>  When receiving a new image, an event is called, the handle of which we passed to <code>NuiImageStreamOpen()</code> . </li><li>  After calling the event, you can get a frame using the <code>NuiImageStreamGetNextFrame()</code> method. </li><li>  Then perform a buffer capture using the <code>NuiImageBuffer::LockRect()</code> method. </li><li>  After that, go through the buffer and get the color of each pixel, normalizing the depth value. </li><li>  Free the buffer using the <code>NuiImageStreamReleaseFrame()</code> method. </li><li>  In order to stop capturing images from a device, it is necessary to de-initialize it with the <code>NuiShutdown()</code> method. </li></ul><br>  Now let's see how you can put all this into practice: <br>  <b>wxKinectHelper.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> KinectHelper <br> { <br> ... <br> <font color="#0000ff">const</font> wxSize &amp; GetFrameSize(); <br> BYTE * CreateDataBuffer(); <br> <font color="#0000ff">void</font> FreeDataBuffer(BYTE * data); <br> size_t GetDataBufferLength(); <br> <br> <font color="#0000ff">bool</font> StartGrabbing(size_t deviceIndex, HANDLE hDepthFrameEvent); <br> <font color="#0000ff">bool</font> ReadKinectFrame(size_t deviceIndex, BYTE * data); <br> <br> <font color="#0000ff">bool</font> IsDeviceOK(size_t deviceIndex); <br> <font color="#0000ff">bool</font> IsGrabbingStarted(size_t deviceIndex); <br> <br> <font color="#0000ff">static</font> RGBQUAD Nui_ShortToQuad_Depth( USHORT s ); <br> <font color="#0000ff">protected</font> : <br> InstanceVector m_Instances; <br> wxSize m_FrameSize; <br> ... <br> };</font></code> </blockquote> <br>  <b>wxKinectHelper.cpp</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">void</font> ReadLockedRect(KINECT_LOCKED_RECT &amp; LockedRect, <font color="#0000ff">int</font> w, <font color="#0000ff">int</font> h, BYTE * data) <br> { <br> <font color="#0000ff">if</font> ( LockedRect.Pitch != 0 ) <br> { <br> BYTE * pBuffer = (BYTE*) LockedRect.pBits; <br> <br> <font color="#008000">// draw the bits to the bitmap</font> <br> USHORT * pBufferRun = (USHORT*) pBuffer; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y = 0 ; y &lt; h ; y++ ) <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x = 0 ; x &lt; w ; x++ ) <br> { <br> RGBQUAD quad = KinectHelper::Nui_ShortToQuad_Depth( *pBufferRun ); <br> pBufferRun++; <br> <font color="#0000ff">int</font> offset = (w * y + x) * 3; <br> data[offset + 0] = quad.rgbRed; <br> data[offset + 1] = quad.rgbGreen; <br> data[offset + 2] = quad.rgbBlue; <br> } <br> } <br> } <br> } <br> ... <br> BYTE * KinectHelper::CreateDataBuffer() <br> { <br> size_t length = GetDataBufferLength(); <br> BYTE * result = (BYTE*)CoTaskMemAlloc(length); <br> memset(result, 0, length); <br> <font color="#0000ff">return</font> result; <br> } <br> <br> size_t KinectHelper::GetDataBufferLength() <br> { <br> <font color="#0000ff">return</font> m_FrameSize.GetWidth() * m_FrameSize.GetHeight() * 3; <br> } <br> <br> <font color="#0000ff">void</font> KinectHelper::FreeDataBuffer(BYTE * data) <br> { <br> CoTaskMemFree((LPVOID)data); <br> } <br> <br> <font color="#0000ff">void</font> KinectHelper::Finalize() <br> { <br> <font color="#0000ff">for</font> (InstanceVector::const_iterator i = m_Instances.begin(); <br> i != m_Instances.end(); i++) <br> { <br> <font color="#0000ff">if</font> ((*i).first &amp;&amp; (*i).second) <br> { <br> (*i).first-&gt;NuiShutdown(); <br> MSR_NuiDestroyInstance((*i).first); <br> } <br> } <br> } <br> <br> <font color="#0000ff">bool</font> KinectHelper::StartGrabbing(size_t deviceIndex, HANDLE hDepthFrameEvent) <br> { <br> <font color="#0000ff">do</font> <br> { <br> InstanceInfo * info = GetInstanceByIndex(deviceIndex); <br> <font color="#0000ff">if</font> (!info || !info-&gt;first) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiInitialize( <br> NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiImageStreamOpen( <br> NUI_IMAGE_TYPE_DEPTH_AND_PLAYER_INDEX, <br> NUI_IMAGE_RESOLUTION_320x240, 0, <br> 3, <br> hDepthFrameEvent, <br> &amp;info-&gt;second))) <font color="#0000ff">break</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">bool</font> KinectHelper::IsDeviceOK(size_t deviceIndex) <br> { <br> <font color="#0000ff">return</font> GetInstanceByIndex(deviceIndex) != NULL; <br> } <br> <br> <font color="#0000ff">bool</font> KinectHelper::IsGrabbingStarted(size_t deviceIndex) <br> { <br> InstanceInfo * info = GetInstanceByIndex(deviceIndex); <br> <font color="#0000ff">return</font> (info != NULL &amp;&amp; info-&gt;first != NULL &amp;&amp; info-&gt;second != NULL); <br> } <br> <br> <font color="#0000ff">bool</font> KinectHelper::ReadKinectFrame(size_t deviceIndex, BYTE * data) <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (deviceIndex &lt; 0) <font color="#0000ff">break</font> ; <br> InstanceInfo * info = GetInstanceByIndex((size_t)deviceIndex); <br> <font color="#0000ff">if</font> (!info || !info-&gt;second) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">const</font> NUI_IMAGE_FRAME * pImageFrame; <br> <font color="#0000ff">if</font> (FAILED(NuiImageStreamGetNextFrame( <br> info-&gt;second, 200, &amp;pImageFrame))) <font color="#0000ff">break</font> ; <br> NuiImageBuffer * pTexture = pImageFrame-&gt;pFrameTexture; <br> KINECT_LOCKED_RECT LockedRect; <br> pTexture-&gt;LockRect( 0, &amp;LockedRect, NULL, 0 ); <br> ReadLockedRect(LockedRect, m_FrameSize.GetWidth(), <br> m_FrameSize.GetHeight(), data); <br> NuiImageStreamReleaseFrame(info-&gt;second, pImageFrame); <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> RGBQUAD KinectHelper::Nui_ShortToQuad_Depth( USHORT s ) <br> { <br> USHORT RealDepth = (s &amp; 0xfff8) &gt;&gt; 3; <br> BYTE l = 255 - (BYTE)(256*RealDepth/0x0fff); <br> RGBQUAD q; <br> q.rgbRed = q.rgbBlue = q.rgbGreen = l; <br> <font color="#0000ff">return</font> q; <br> }</font></code> </blockquote> <br>  <b>KinectTestMainFrame.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> KinectTestMainFrame: <font color="#0000ff">public</font> wxFrame, <font color="#0000ff">public</font> wxThreadHelper <br> { <br> ... <br> <font color="#0000ff">void</font> OnDEVICELISTBOXSelected( wxCommandEvent&amp; <font color="#0000ff">event</font> ); <br> ... <br> <font color="#0000ff">void</font> ShowDevices(); <br> <font color="#0000ff">void</font> StopGrabbing(); <br> HANDLE m_NewDepthFrameEvent; <br> KinectHelper * m_KinectHelper; <br> BYTE * m_pDepthBuffer; <br> wxImage * m_CurrentImage; <br> <font color="#0000ff">int</font> m_SelectedDeviceIndex; <br> };</font></code> </blockquote> <br>  <b>KinectTestMainFrame.cpp</b> <br><blockquote> <code><font color="black">... <br> BEGIN_EVENT_TABLE( KinectTestMainFrame, wxFrame ) <br> EVT_LISTBOX( ID_DEVICE_LISTBOX, KinectTestMainFrame::OnDEVICELISTBOXSelected ) <br> END_EVENT_TABLE() <br> ... <br> <font color="#0000ff">void</font> KinectTestMainFrame::Init() <br> { <br> m_NewDepthFrameEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); <br> m_KinectHelper = <font color="#0000ff">new</font> KinectHelper; <br> m_pDepthBuffer = m_KinectHelper-&gt;CreateDataBuffer(); <br> m_CurrentImage = <font color="#0000ff">new</font> wxImage( <br> m_KinectHelper-&gt;GetFrameSize().GetWidth(), <br> m_KinectHelper-&gt;GetFrameSize().GetHeight(), <br> m_pDepthBuffer, <font color="#0000ff">true</font> ); <br> m_SelectedDeviceIndex = -1; <br> m_MainSizer = NULL; <br> m_DeviceListBox = NULL; <br> m_Canvas = NULL; <br> } <br> ... <br> KinectTestMainFrame::~KinectTestMainFrame() <br> { <br> StopGrabbing(); <br> wxDELETE(m_CurrentImage); <br> m_KinectHelper-&gt;FreeDataBuffer(m_pDepthBuffer); <br> wxDELETE(m_KinectHelper); <br> } <br> ... <br> wxThread::ExitCode KinectTestMainFrame::Entry() <br> { <br> <font color="#0000ff">while</font> (!GetThread()-&gt;TestDestroy()) <br> { <br> <font color="#0000ff">int</font> mEventIndex = WaitForMultipleObjects( <br> 1, &amp;m_NewDepthFrameEvent, FALSE, 100); <br> <font color="#0000ff">switch</font> (mEventIndex) <br> { <br> <font color="#0000ff">case</font> 0: <br> { <br> wxCriticalSectionLocker <font color="#0000ff">lock</font> (m_CS); <br> m_KinectHelper-&gt;ReadKinectFrame( <br> m_SelectedDeviceIndex, m_pDepthBuffer); <br> m_Canvas-&gt;Refresh(); <br> } <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">default</font> : <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <font color="#0000ff">return</font> NULL; <br> } <br> ... <br> <font color="#0000ff">void</font> KinectTestMainFrame::OnDEVICELISTBOXSelected( wxCommandEvent&amp; <font color="#0000ff">event</font> ) <br> { <br> <font color="#0000ff">do</font> <br> { <br> StopGrabbing(); <br> size_t deviceIndex = <br> (size_t)m_DeviceListBox-&gt;GetClientData( <font color="#0000ff">event</font> .GetInt()); <br> <font color="#0000ff">if</font> (deviceIndex &lt; 0 || deviceIndex &gt; <br> m_KinectHelper-&gt;GetDeviceCount()) <font color="#0000ff">break</font> ; <br> m_SelectedDeviceIndex = deviceIndex; <br> <font color="#0000ff">if</font> (!m_KinectHelper-&gt;IsDeviceOK(deviceIndex)) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (!m_KinectHelper-&gt;IsGrabbingStarted(deviceIndex)) <br> { <br> m_KinectHelper-&gt;StartGrabbing( <br> deviceIndex, m_NewDepthFrameEvent); <br> <font color="#0000ff">if</font> (CreateThread() != wxTHREAD_NO_ERROR) <font color="#0000ff">break</font> ; <br> m_Canvas-&gt;SetCurrentImage(m_CurrentImage); <br> GetThread()-&gt;Run(); <br> } <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> } <br> <br> <font color="#0000ff">void</font> KinectTestMainFrame::StopGrabbing() <br> { <br> <font color="#0000ff">if</font> (GetThread()) <br> { <br> <font color="#0000ff">if</font> (GetThread()-&gt;IsAlive()) <br> { <br> GetThread()-&gt;Delete(); <br> } <br> <font color="#0000ff">if</font> (m_kind == wxTHREAD_JOINABLE) <br> { <br> <font color="#0000ff">if</font> (GetThread()-&gt;IsAlive()) <br> { <br> GetThread()-&gt;Wait(); <br> } <br> wxDELETE(m_thread); <br> } <br> <font color="#0000ff">else</font> <br> { <br> m_thread = NULL; <br> } <br> } <br> }</font></code> </blockquote> <br>  When the application <code>wxKinectHelper</code> , the <code>wxKinectHelper</code> Object allocates memory for the depth buffer, in accordance with the resolution (320x240x24).  The allocated memory is then transferred as an RGB buffer to the <code>m_CurrentImage</code> object. <br>  When a device is <code>m_CurrentImage</code> in the list of available devices, the image capture stream from the device is launched, and the <code>m_CurrentImage</code> object <code>m_CurrentImage</code> associated with the canvas. <br>  The <code>Entry()</code> method waits for a new image from the device.  When the image is available, the RGB buffer is filled with new values, and then the canvas is redrawn. <br>  As a result, after starting the application and clicking on the device name in the list, we will get something like this (Fig. 6): <br><br><img src="https://habrastorage.org/storage1/c5d681dd/2179297b/36488628/f3237a85.png"><br><br><h4>  Get a color image from the camera </h4><br>  To obtain an image from the device's camera, you must specify the <code>NUI_INITIALIZE_FLAG_USES_COLOR</code> flag when calling the <code>NuiInitialize()</code> method, as well as specify a resolution of at least 640x480 when you call the <code>NuiImageStreamOpen()</code> method. <br>  As a result, the code will look something like this: <br><blockquote> <code><font color="black"><font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiInitialize( <br> NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX| <br> NUI_INITIALIZE_FLAG_USES_COLOR))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiImageStreamOpen(NUI_IMAGE_TYPE_COLOR, <br> NUI_IMAGE_RESOLUTION_640x480, 0, <br> 3, <br> hDepthFrameEvent, <br> &amp;info-&gt;second))) <font color="#0000ff">break</font> ;</font></code> </blockquote> <br>  Accordingly, the data in the <code>KINECT_LOCKED_RECT</code> structure <code>KINECT_LOCKED_RECT</code> contained in the RGBA format (the <code>RGBQUAD</code> structure, available in the SDK, is quite suitable for data access).  Thus, the code to get the RGB buffer will look like this: <br><blockquote> <code><font color="black"><font color="#0000ff">if</font> ( LockedRect.Pitch != 0 ) <br> { <br> BYTE * pBuffer = (BYTE*) LockedRect.pBits; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y = 0 ; y &lt; h ; y++ ) <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x = 0 ; x &lt; w ; x++ ) <br> { <br> RGBQUAD * quad = ((RGBQUAD*)pBuffer) + x; <br> <font color="#0000ff">int</font> offset = (w * y + x) * 3; <br> data[offset + 0] = quad-&gt;rgbRed; <br> data[offset + 1] = quad-&gt;rgbGreen; <br> data[offset + 2] = quad-&gt;rgbBlue; <br> } <br> pBuffer += LockedRect.Pitch; <br> } <br> }</font></code> </blockquote> <br><h4>  Player Position Tracking (Skeleton Tracking) </h4><br>  The algorithm for obtaining and displaying segments of the "skeleton" of players differs from the acquisition of ordinary images. <br><br>  In order to enable the ability to get skeletal segments, <code>NuiInitialize()</code> needs to pass a flag containing the value <code>NUI_INITIALIZE_FLAG_USES_SKELETON</code> , and then call <code>NuiSkeletonTrackingEnable()</code> , which as a first parameter to pass the event descriptor that will be called when receiving a new piece of data with segments, and the second parameter is a set of flags (the beta version of the SDK ignores this parameter, so you can pass 0). <br><br>  To complete the stream of getting the skeletal segments, you need to call the <code>NuiSkeletonTrackingDisable()</code> method. <br>  In the code, it will look like this: <br><blockquote> <code><font color="black"><font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiSkeletonTrackingEnable(hSkeletonFrameEvent, 0))) <br> { <font color="#008000">/* error */</font> };</font></code> </blockquote> <br>  You can get a data buffer containing information about the position of players using the <code>NuiSkeletonGetNextFrame()</code> method, which takes as parameters: <br><ul><li>  Buffer timeout (in milliseconds) </li><li>  A pointer to the <code>NUI_SKELETON_FRAME</code> structure, which, if the function completes successfully, will contain a pointer to a data buffer. </li></ul><br>  After calling the <code>NuiSkeletonGetNextFrame()</code> method, we get an instance of the NUI_SKELETON_FRAME structure.  Let's look at it in more detail. <br><blockquote> <code><font color="black"><font color="#0000ff">struct</font> _NUI_SKELETON_FRAME { <br> LARGE_INTEGER liTimeStamp; <br> DWORD dwFrameNumber; <br> DWORD dwFlags; <br> Vector4 vFloorClipPlane; <br> Vector4 vNormalToGravity; <br> NUI_SKELETON_DATA SkeletonData[NUI_SKELETON_COUNT]; <br> } NUI_SKELETON_FRAME;</font></code> </blockquote> <br><ul><li>  <code>liTimeStamp</code> - the date / time of receiving the depth buffer from which the skeleton segments were obtained. </li><li>  <code>dwFlag</code> is a bitmask containing flags. </li><li>  <code>vFloorClipPlane</code> - floor coordinates (calculated inside the library), which were used to cut off everything that is below the floor. </li><li>  <code>vNormalToGravity</code> is a normal vector. </li><li>  <code>dwFrameNumber</code> - frame number. </li><li>  <code>SkeletonData</code> is an array of <code>NUI_SKELETON_DATA</code> structures, each of which contains data about the segmentation of the skeleton of one player. </li></ul><br>  As can be seen from the description of the <code>NUI_SKELETON_FRAME</code> structure, a limited number of players are supported (in the current SDK version, the value of <code>NUI_SKELETON_COUNT</code> is 6). <br><br>  Now consider the structure <code>NUI_SKELETON_DATA</code> : <br><blockquote> <code><font color="black"><font color="#0000ff">struct</font> _NUI_SKELETON_DATA { <br> NUI_SKELETON_TRACKING_STATE eTrackingState; <br> DWORD dwTrackingID; <br> DWORD dwEnrollmentIndex; <br> DWORD dwUserIndex; <br> Vector4 Position; <br> Vector4 SkeletonPositions[NUI_SKELETON_POSITION_COUNT]; <br> NUI_SKELETON_POSITION_TRACKING_STATE <br> eSkeletonPositionTrackingState[NUI_SKELETON_POSITION_COUNT]; <br> DWORD dwQualityFlags; <br> } NUI_SKELETON_DATA;</font></code> </blockquote> <br><ul><li>  <code>eTrackingState</code> is the value from the <code>NUI_SKELETON_TRACKING_STATE</code> enumeration.  It may indicate that the player was not found, only the coordinates of the player were found (without skeleton segments), or that the coordinates and skeletal segments were found. </li><li>  <code>dwEnrollmentIndex</code> - judging by the documentation (p. 20), is not used in the current version. </li><li>  <code>dwUserIndex</code> - in the current version of the SDK is always equal to <code>XUSER_INDEX_NONE</code> . </li><li>  <code>dwTrackingID</code> - number of the player being tracked. </li><li>  <code>Position</code> - the coordinates of the player. </li><li>  <code>SkeletonPositions</code> - the list of coordinates of the joints of the skeleton segments </li><li>  <code>eSkeletonPositionTrackingState</code> ‚Äî A list of flags that indicate whether skeletal segment junctions are found. </li></ul><br>  As can be seen from the description of the <code>NUI_SKELETON_DATA</code> structure, the number of supported articulations of the segments is limited to a number equal to <code>NUI_SKELETON_POSITION_COUNT</code> . <br>  Now we will consider the implementation of obtaining the coordinates of players using the API described above: <br><br>  <b>KinectHelper.h</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">struct</font> KinectStreams <br> { <br> HANDLE hDepth; <br> HANDLE hColor; <br> HANDLE hSkeleton; <br> KinectStreams() : hDepth(NULL), hColor(NULL), hSkeleton(NULL) {} <br> }; <br> ...</font></code> </blockquote> <br>  <b>KinectHelper.cpp</b> <br><blockquote> <code><font color="black"><font color="#0000ff">void</font> KinectHelper::Finalize() <br> { <br> <font color="#0000ff">for</font> (InstanceVector::const_iterator i = m_Instances.begin(); <br> i != m_Instances.end(); i++) <br> { <br> <font color="#0000ff">if</font> ((*i).first) <br> { <br> ... <br> <font color="#0000ff">if</font> ((*i).second.hSkeleton != NULL) <br> { <br> (*i).first-&gt;NuiSkeletonTrackingDisable(); <br> } <br> MSR_NuiDestroyInstance((*i).first); <br> } <br> } <br> } <br> <br> <font color="#0000ff">bool</font> KinectHelper::StartGrabbing(size_t deviceIndex, <br> HANDLE hDepthFrameEvent, <br> HANDLE hColorFrameEvent, <br> HANDLE hSkeletonFrameEvent) <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (hDepthFrameEvent == NULL &amp;&amp; <br> hColorFrameEvent == NULL &amp;&amp; <br> hSkeletonFrameEvent == NULL) <font color="#0000ff">break</font> ; <br> InstanceInfo * info = GetInstanceByIndex(deviceIndex); <br> <font color="#0000ff">if</font> (!info || !info-&gt;first) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiInitialize( <br> NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX | <br> NUI_INITIALIZE_FLAG_USES_COLOR | <br> NUI_INITIALIZE_FLAG_USES_SKELETON))) <font color="#0000ff">break</font> ; <br> ... <br> <font color="#0000ff">if</font> (hSkeletonFrameEvent != NULL) <br> { <br> <font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiSkeletonTrackingEnable( <br> hSkeletonFrameEvent, 0))) <font color="#0000ff">break</font> ; <br> info-&gt;second.hSkeleton = hSkeletonFrameEvent; <br> } <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">void</font> * KinectHelper::ReadSkeletonFrame(size_t deviceIndex) <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (deviceIndex &lt; 0) <font color="#0000ff">break</font> ; <br> InstanceInfo * info = GetInstanceByIndex((size_t)deviceIndex); <br> <font color="#0000ff">if</font> (!info || !info-&gt;second.hColor) <font color="#0000ff">break</font> ; <br> NUI_SKELETON_FRAME * frame = <font color="#0000ff">new</font> NUI_SKELETON_FRAME; <br> <font color="#0000ff">if</font> (FAILED(info-&gt;first-&gt;NuiSkeletonGetNextFrame(200, frame))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">return</font> frame; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> NULL; <br> }</font></code> </blockquote> <br><h5>  Draw the player's skeleton </h5><br>  At the moment we have information on how: <br><ul><li>  Initialize device to get players position </li><li>  Start the flow of capturing the position of players </li><li>  Get a buffer containing the coordinates of the skeletal segments of the players. </li><li>  Get to the right data in the buffer </li><li>  Stop the flow of getting the position of players. </li></ul><br>  Now we need to somehow show the received data in the application. <br>  Before you do something with data from <code>NUI_SKELETON_FRAME</code> , you need to send them for preprocessing.  The NuiTransformSmooth <code>NuiTransformSmooth()</code> method performs the <code>NuiTransformSmooth()</code> - it filters the coordinates of the segments in order to avoid jerks and sudden movements.  As parameters, the <code>NuiTransformSmooth()</code> method takes a pointer to a <code>NUI_SKELETON_FRAME</code> structure and, optionally, a pointer to a <code>NUI_TRANSFORM_SMOOTH_PARAMETERS</code> object containing the preprocessing parameters. <br><blockquote> <code><font color="black">HRESULT NuiTransformSmooth( <br> NUI_SKELETON_FRAME *pSkeletonFrame, <br> CONST NUI_TRANSFORM_SMOOTH_PARAMETERS *pSmoothingParams <br> );</font></code> </blockquote> <br>  In order to display the skeleton segments, it is necessary to convert their coordinates into image coordinates.  This can be done using the <code>NuiTransformSkeletonToDepthImageF()</code> method, which takes as parameters: <br><ul><li>  The coordinates of the junction point of the skeleton segments in the form of a <code>Vector4</code> structure. </li><li>  Pointer to a variable in which the X-coordinate will be written. </li><li>  Pointer to a variable in which the Y-coordinate will be written. </li></ul><br><blockquote> <code><font color="black">VOID NuiTransformSkeletonToDepthImageF( <br> Vector4 vPoint, <br> _Out_ FLOAT *pfDepthX, <br> _Out_ FLOAT *pfDepthY <br> );</font></code> </blockquote> <br>  After obtaining the coordinates of all the articulation points, you can display them on the canvas using ordinary graphic primitives. <br><br>  Here is how the code for displaying skeleton segments looks like in practice: <br>  <b>SkeletonPainter.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> #include &lt;wx/wx.h&gt; <br> <br> <font color="#0000ff">class</font> SkeletonPainterImpl; <br> <br> <font color="#0000ff">class</font> SkeletonPainter <br> { <br> <font color="#0000ff">public</font> : <br> SkeletonPainter(); <br> ~SkeletonPainter(); <br> <font color="#0000ff">void</font> DrawSkeleton(wxDC &amp; dc, <font color="#0000ff">void</font> * data); <br> <font color="#0000ff">private</font> : <br> SkeletonPainterImpl * m_Impl; <br> };</font></code> </blockquote> <br>  <b>SkeletonPainter.cpp</b> <br><blockquote> <code><font color="black">#include <font color="#A31515">"SkeletonPainter.h"</font> <br> <font color="#0000ff">#if</font> defined(__WXMSW__) <br> #include <font color="#A31515">"SkeletonPainterImplMSW.h"</font> <br> <font color="#0000ff">#endif</font> <br> <br> SkeletonPainter::SkeletonPainter() <br> { <br> <font color="#0000ff">#if</font> defined(__WXMSW__) <br> m_Impl = <font color="#0000ff">new</font> SkeletonPainterImplMSW; <br> <font color="#0000ff">#else</font> <br> m_Impl = NULL; <br> <font color="#0000ff">#endif</font> <br> } <br> <br> SkeletonPainter::~SkeletonPainter() <br> { <br> wxDELETE(m_Impl); <br> } <br> <br> <font color="#0000ff">void</font> SkeletonPainter::DrawSkeleton(wxDC &amp; dc, <font color="#0000ff">void</font> * data) <br> { <br> <font color="#0000ff">if</font> (m_Impl) <br> { <br> m_Impl-&gt;DrawSkeleton(dc, data); <br> } <br> }</font></code> </blockquote> <br>  <b>SkeletonPainterImpl.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> #include &lt;wx/wx.h&gt; <br> <br> <font color="#0000ff">class</font> SkeletonPainterImpl <br> { <br> <font color="#0000ff">public</font> : <br> <font color="#0000ff">virtual</font> ~SkeletonPainterImpl() {} <br> <font color="#0000ff">virtual</font> <font color="#0000ff">void</font> DrawSkeleton(wxDC &amp; dc, <font color="#0000ff">void</font> * data) = 0; <br> };</font></code> </blockquote> <br>  <b>SkeletonPainterImplMSW.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> #include <font color="#A31515">"SkeletonPainterImpl.h"</font> <br> #include <font color="#A31515">"msr_nuiapi.h"</font> <br> <br> <font color="#0000ff">class</font> SkeletonPainterImplMSW : <font color="#0000ff">public</font> SkeletonPainterImpl <br> { <br> <font color="#0000ff">public</font> : <br> ~SkeletonPainterImplMSW(); <br> <font color="#0000ff">void</font> DrawSkeleton(wxDC &amp; dc, <font color="#0000ff">void</font> * data); <br> <font color="#0000ff">private</font> : <br> <font color="#0000ff">void</font> Nui_DrawSkeleton(wxDC &amp; dc, NUI_SKELETON_DATA * data, size_t index); <br> <font color="#0000ff">void</font> Nui_DrawSkeletonSegment(wxDC &amp; dc, wxPoint * points, <font color="#0000ff">int</font> numJoints, ... ); <br> <br> <font color="#0000ff">static</font> wxPen m_SkeletonPen[6]; <br> };</font></code> </blockquote> <br>  <b>SkeletonPainterImplMSW.cpp</b> <br><blockquote> <code><font color="black">#include <font color="#A31515">"SkeletonPainterImplMSW.h"</font> <br> <br> wxPen SkeletonPainterImplMSW::m_SkeletonPen[6] = <br> { <br> wxPen(wxColor(255, 0, 0), wxSOLID), <br> ... <br> }; <br> <br> SkeletonPainterImplMSW::~SkeletonPainterImplMSW() <br> { <br> } <br> <br> <font color="#0000ff">void</font> SkeletonPainterImplMSW::DrawSkeleton(wxDC &amp; dc, <font color="#0000ff">void</font> * data) <br> { <br> <font color="#0000ff">do</font> <br> { <br> NUI_SKELETON_FRAME * frame = <br> reinterpret_cast&lt;NUI_SKELETON_FRAME*&gt;(data); <br> <font color="#0000ff">if</font> (!frame) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">int</font> skeletonCount(0); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0 ; i &lt; NUI_SKELETON_COUNT ; i++ ) <br> { <br> <font color="#0000ff">if</font> ( frame-&gt;SkeletonData[i].eTrackingState == <br> NUI_SKELETON_TRACKED ) <br> { <br> skeletonCount++; <br> } <br> } <br> <font color="#0000ff">if</font> (!skeletonCount) <font color="#0000ff">break</font> ; <br> NuiTransformSmooth(frame, NULL); <br> <font color="#0000ff">for</font> (size_t i = 0 ; i &lt; NUI_SKELETON_COUNT ; i++ ) <br> { <br> <font color="#0000ff">if</font> (frame-&gt;SkeletonData[i].eTrackingState == <br> NUI_SKELETON_TRACKED) <br> { <br> Nui_DrawSkeleton(dc, &amp;frame-&gt;SkeletonData[i], i ); <br> } <br> } <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> } <br> <br> <font color="#0000ff">void</font> SkeletonPainterImplMSW::Nui_DrawSkeleton(wxDC &amp; dc, <br> NUI_SKELETON_DATA * data, size_t index) <br> { <br> wxPoint points[NUI_SKELETON_POSITION_COUNT]; <br> <font color="#0000ff">float</font> fx(0), fy(0); <br> wxSize imageSize = dc.GetSize(); <br> <font color="#0000ff">for</font> (size_t i = 0; i &lt; NUI_SKELETON_POSITION_COUNT; i++) <br> { <br> NuiTransformSkeletonToDepthImageF( <br> data-&gt;SkeletonPositions[i], &amp;fx, &amp;fy); <br> points[i].x = ( <font color="#0000ff">int</font> ) ( fx * imageSize.GetWidth() + 0.5f ); <br> points[i].y = ( <font color="#0000ff">int</font> ) ( fy * imageSize.GetHeight() + 0.5f ); <br> } <br> <br> Nui_DrawSkeletonSegment(dc,points,4, <br> NUI_SKELETON_POSITION_HIP_CENTER, <br> NUI_SKELETON_POSITION_SPINE, <br> NUI_SKELETON_POSITION_SHOULDER_CENTER, <br> NUI_SKELETON_POSITION_HEAD); <br> Nui_DrawSkeletonSegment(dc,points,5, <br> NUI_SKELETON_POSITION_SHOULDER_CENTER, <br> NUI_SKELETON_POSITION_SHOULDER_LEFT, <br> NUI_SKELETON_POSITION_ELBOW_LEFT, <br> NUI_SKELETON_POSITION_WRIST_LEFT, <br> NUI_SKELETON_POSITION_HAND_LEFT); <br> Nui_DrawSkeletonSegment(dc,points,5, <br> NUI_SKELETON_POSITION_SHOULDER_CENTER, <br> NUI_SKELETON_POSITION_SHOULDER_RIGHT, <br> NUI_SKELETON_POSITION_ELBOW_RIGHT, <br> NUI_SKELETON_POSITION_WRIST_RIGHT, <br> NUI_SKELETON_POSITION_HAND_RIGHT); <br> Nui_DrawSkeletonSegment(dc,points,5, <br> NUI_SKELETON_POSITION_HIP_CENTER, <br> NUI_SKELETON_POSITION_HIP_LEFT, <br> NUI_SKELETON_POSITION_KNEE_LEFT, <br> NUI_SKELETON_POSITION_ANKLE_LEFT, <br> NUI_SKELETON_POSITION_FOOT_LEFT); <br> Nui_DrawSkeletonSegment(dc,points,5, <br> NUI_SKELETON_POSITION_HIP_CENTER, <br> NUI_SKELETON_POSITION_HIP_RIGHT, <br> NUI_SKELETON_POSITION_KNEE_RIGHT, <br> NUI_SKELETON_POSITION_ANKLE_RIGHT, <br> NUI_SKELETON_POSITION_FOOT_RIGHT); <br> } <br> <br> <font color="#0000ff">void</font> SkeletonPainterImplMSW::Nui_DrawSkeletonSegment(wxDC &amp; dc, <br> wxPoint * points, <font color="#0000ff">int</font> numJoints, ...) <br> { <br> va_list vl; <br> va_start(vl,numJoints); <br> wxPoint segmentPositions[NUI_SKELETON_POSITION_COUNT]; <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> iJoint = 0; iJoint &lt; numJoints; iJoint++) <br> { <br> NUI_SKELETON_POSITION_INDEX jointIndex = <br> va_arg(vl,NUI_SKELETON_POSITION_INDEX); <br> segmentPositions[iJoint].x = points[jointIndex].x; <br> segmentPositions[iJoint].y = points[jointIndex].y; <br> } <br> <br> dc.SetPen(*wxBLUE_PEN); <br> dc.DrawLines(numJoints, segmentPositions); <br> <br> va_end(vl); <br> }</font></code> </blockquote> <br>  Using the <code>SkeletonPainter</code> class in an application will look like this: <br><br>  <b>KinectTestMainFrame.h</b> <br><blockquote> <code><font color="black">... <br> <font color="#0000ff">class</font> KinectTestMainFrame: <font color="#0000ff">public</font> wxFrame, <font color="#0000ff">public</font> wxThreadHelper <br> { <br> ... <br> HANDLE m_NewSkeletonFrameEvent; <br> wxImage m_SkeletonImage; <br> ... <br> }; <br> ...</font></code> </blockquote> <br>  <b>KinectTestMainFrame.cpp</b> <br><blockquote> <code><font color="black">... <br> wxThread::ExitCode KinectTestMainFrame::Entry() <br> { <br> HANDLE eventHandles[3]; <br> eventHandles[0] = m_NewDepthFrameEvent; <br> eventHandles[1] = m_NewColorFrameEvent; <br> eventHandles[2] = m_NewSkeletonFrameEvent; <br> SkeletonPainter painter; <br> <font color="#0000ff">while</font> (!GetThread()-&gt;TestDestroy()) <br> { <br> <font color="#0000ff">int</font> mEventIndex = WaitForMultipleObjects( <br> _countof(eventHandles), eventHandles, FALSE, 100); <br> <font color="#0000ff">switch</font> (mEventIndex) <br> { <br> ... <br> <font color="#0000ff">case</font> 2: <br> { <br> <font color="#0000ff">void</font> * frame = m_KinectHelper-&gt;ReadSkeletonFrame( <br> m_SelectedDeviceIndex); <br> <font color="#0000ff">if</font> (frame) <br> { <br> wxBitmap bmp( <br> m_SkeletonImage.GetWidth(), <br> m_SkeletonImage.GetHeight()); <br> wxMemoryDC dc(bmp); <br> painter.DrawSkeleton(dc, frame); <br> m_KinectHelper-&gt;ReleaseSkeletonFrame(frame); <br> dc.SelectObject(wxNullBitmap); <br> m_SkeletonImage = bmp.ConvertToImage(); <br> m_SkeletonCanvas-&gt;Refresh(); <br> } <br> } <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">default</font> : <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <font color="#0000ff">return</font> NULL; <br> }</font></code> </blockquote> <br>  As a result of the actions described above, we should get approximately the following result (Fig. 7): <br><br><img src="https://habrastorage.org/storage1/00facb04/dbb8df50/e78499e4/97c7b107.png"><br><br><h2>  Get rid of platform-specific code in the application </h2><br><br>  The example described above is good for everyone, except that in a project for developing a user interface, a cross-platform library is used, and part of the GUI code is written using an API that is specific only to Windows. <br><br>  To work with Kinect, there are several third-party libraries, such as <a href="http://openkinect.org/wiki/Main_Page">libfreenect</a> or <a href="http://www.openni.org/">OpenNI</a> , but already at this stage we have a situation that the application code is tied to the use of the Microsoft SDK. <br><br>  In order to solve this annoying misunderstanding, you can take out the code associated with obtaining images from the device in a separate grabber class, and limit the functionality of the <code>KinectHelper</code> class to obtaining a list of devices and creating instances of the grabber: <br><br>  <b>KinectGrabberBase.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> #include &lt;wx/wx.h&gt; <br> <br> <font color="#0000ff">class</font> KinectGrabberBase <br> { <br> <font color="#0000ff">public</font> : <br> KinectGrabberBase(wxEvtHandler * handler); <br> <font color="#0000ff">virtual</font> ~KinectGrabberBase(); <br> <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> GrabDepthFrame(unsigned <font color="#0000ff">char</font> * data) = 0; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> GrabColorFrame(unsigned <font color="#0000ff">char</font> * data) = 0; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">void</font> * GrabSkeletonFrame() = 0; <br> <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> Start() = 0; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> Stop() = 0; <br> <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> IsStarted() = 0; <br> <br> <font color="#0000ff">const</font> wxSize &amp; GetDepthFrameSize(); <br> <font color="#0000ff">const</font> wxSize &amp; GetColorFrameSize(); <br> <font color="#0000ff">protected</font> : <br> wxSize m_DepthFrameSize; <br> wxSize m_ColorFrameSize; <br> wxEvtHandler * m_Handler; <br> }; <br> <br> BEGIN_DECLARE_EVENT_TYPES() <br> <br> DECLARE_LOCAL_EVENT_TYPE(KINECT_DEPTH_FRAME_RECEIVED, -1) <br> DECLARE_LOCAL_EVENT_TYPE(KINECT_COLOR_FRAME_RECEIVED, -1) <br> DECLARE_LOCAL_EVENT_TYPE(KINECT_SKELETON_FRAME_RECEIVED, -1) <br> <br> END_DECLARE_EVENT_TYPES()</font></code> </blockquote> <br>  <b>KinectGrabberBase.cpp</b> <br><blockquote> <code><font color="black">#include <font color="#A31515">"KinectGrabberBase.h"</font> <br> <br> DEFINE_EVENT_TYPE(KINECT_DEPTH_FRAME_RECEIVED) <br> DEFINE_EVENT_TYPE(KINECT_COLOR_FRAME_RECEIVED) <br> DEFINE_EVENT_TYPE(KINECT_SKELETON_FRAME_RECEIVED) <br> ...</font></code> </blockquote> <br>  <b>KinectGrabberMSW.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> #include <font color="#A31515">"KinectGrabberBase.h"</font> <br> #include <font color="#A31515">"MSR_NuiApi.h"</font> <br> <br> <font color="#0000ff">class</font> KinectGrabberMSW : <font color="#0000ff">public</font> KinectGrabberBase, <font color="#0000ff">public</font> wxThreadHelper <br> { <br> ... <br> <font color="#0000ff">private</font> : <br> <font color="#0000ff">virtual</font> wxThread::ExitCode Entry(); <br> BYTE * CreateDepthDataBuffer(); <br> BYTE * CreateColorDataBuffer(); <br> size_t GetDepthDataBufferLength(); <br> size_t GetColorDataBufferLength(); <br> <font color="#0000ff">void</font> FreeDataBuffer(BYTE * data); <br> <font color="#0000ff">bool</font> ReadDepthFrame(); <br> <font color="#0000ff">bool</font> ReadColorFrame(); <br> <font color="#0000ff">bool</font> ReadSkeletonFrame(); <br> <br> <font color="#0000ff">void</font> ReadDepthLockedRect(KINECT_LOCKED_RECT &amp; LockedRect, <br> <font color="#0000ff">int</font> w, <font color="#0000ff">int</font> h, BYTE * data); <br> <font color="#0000ff">void</font> ReadColorLockedRect(KINECT_LOCKED_RECT &amp; LockedRect, <br> <font color="#0000ff">int</font> w, <font color="#0000ff">int</font> h, BYTE * data); <br> <font color="#0000ff">static</font> RGBQUAD Nui_ShortToQuad_Depth( USHORT s ); <br> <font color="#0000ff">void</font> ResetEvents(); <br> <font color="#0000ff">void</font> StopThread(); <br> <font color="#0000ff">bool</font> CopyLocalBuffer(BYTE * src, BYTE * dst, size_t count); <br> HANDLE m_NewDepthFrameEvent; <br> HANDLE m_NewColorFrameEvent; <br> HANDLE m_NewSkeletonFrameEvent; <br> HANDLE m_DepthStreamHandle; <br> HANDLE m_ColorStreamHandle; <br> BYTE * m_DepthBuffer; <br> BYTE * m_ColorBuffer; <br> INuiInstance * m_Instance; <br> size_t m_DeviceIndex; <br> NUI_SKELETON_FRAME m_SkeletonFrame; <br> };</font></code> </blockquote> <br>  <b>KinectGrabberMSW.cpp</b> <br><blockquote> <code><font color="black">#include <font color="#A31515">"KinectGrabberMSW.h"</font> <br> <br> KinectGrabberMSW::KinectGrabberMSW(wxEvtHandler * handler, size_t deviceIndex) <br> : KinectGrabberBase(handler), m_DeviceIndex(deviceIndex), m_Instance(NULL) <br> { <br> m_DepthBuffer = CreateDepthDataBuffer(); <br> m_ColorBuffer = CreateColorDataBuffer(); <br> ResetEvents(); <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (FAILED(MSR_NuiCreateInstanceByIndex(( <font color="#0000ff">int</font> )m_DeviceIndex, &amp;m_Instance))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(m_Instance-&gt;NuiInitialize( <br> NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX | <br> NUI_INITIALIZE_FLAG_USES_COLOR | <br> NUI_INITIALIZE_FLAG_USES_SKELETON))) <font color="#0000ff">break</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> } <br> ... <br> <font color="#0000ff">void</font> * KinectGrabberMSW::GrabSkeletonFrame() <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (!GetThread() || !GetThread()-&gt;IsAlive() || <br> !m_Instance || !m_NewSkeletonFrameEvent) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">return</font> &amp;m_SkeletonFrame; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> NULL; <br> } <br> <br> <font color="#0000ff">bool</font> KinectGrabberMSW::Start() <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (!m_Instance) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (GetThread() &amp;&amp; GetThread()-&gt;IsAlive()) <font color="#0000ff">break</font> ; <br> <br> <font color="#0000ff">if</font> (CreateThread() != wxTHREAD_NO_ERROR) <font color="#0000ff">break</font> ; <br> <br> m_NewDepthFrameEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); <br> m_NewColorFrameEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); <br> m_NewSkeletonFrameEvent = CreateEvent( NULL, TRUE, FALSE, NULL ); <br> <br> <font color="#0000ff">if</font> (FAILED(m_Instance-&gt;NuiImageStreamOpen( <br> NUI_IMAGE_TYPE_DEPTH_AND_PLAYER_INDEX, <br> NUI_IMAGE_RESOLUTION_320x240, 0, <br> 3, <br> m_NewDepthFrameEvent, <br> &amp;m_DepthStreamHandle))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(m_Instance-&gt;NuiImageStreamOpen(NUI_IMAGE_TYPE_COLOR, <br> NUI_IMAGE_RESOLUTION_640x480, 0, <br> 4, <br> m_NewColorFrameEvent, <br> &amp;m_ColorStreamHandle))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(m_Instance-&gt;NuiSkeletonTrackingEnable( <br> m_NewSkeletonFrameEvent, 0))) <font color="#0000ff">break</font> ; <br> <br> GetThread()-&gt;Run(); <br> <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> ... <br> wxThread::ExitCode KinectGrabberMSW::Entry() <br> { <br> HANDLE eventHandles[3]; <br> eventHandles[0] = m_NewDepthFrameEvent; <br> eventHandles[1] = m_NewColorFrameEvent; <br> eventHandles[2] = m_NewSkeletonFrameEvent; <br> <font color="#0000ff">while</font> (!GetThread()-&gt;TestDestroy()) <br> { <br> <font color="#0000ff">int</font> mEventIndex = WaitForMultipleObjects( <br> _countof(eventHandles), eventHandles, FALSE, 100); <br> <font color="#0000ff">switch</font> (mEventIndex) <br> { <br> <font color="#0000ff">case</font> 0: ReadDepthFrame(); <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> 1: ReadColorFrame(); <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> 2: ReadSkeletonFrame(); <font color="#0000ff">break</font> ; <br> <font color="#0000ff">default</font> : <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <font color="#0000ff">return</font> NULL; <br> } <br> ... <br> <font color="#0000ff">void</font> KinectGrabberMSW::StopThread() <br> { <br> <font color="#0000ff">if</font> (GetThread()) <br> { <br> <font color="#0000ff">if</font> (GetThread()-&gt;IsAlive()) <br> { <br> GetThread()-&gt;Delete(); <br> } <br> <font color="#0000ff">if</font> (m_kind == wxTHREAD_JOINABLE) <br> { <br> <font color="#0000ff">if</font> (GetThread()-&gt;IsAlive()) <br> { <br> GetThread()-&gt;Wait(); <br> } <br> wxDELETE(m_thread); <br> } <br> <font color="#0000ff">else</font> <br> { <br> m_thread = NULL; <br> } <br> } <br> wxYield(); <br> } <br> <br> <font color="#0000ff">bool</font> KinectGrabberMSW::ReadDepthFrame() <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (m_DeviceIndex &lt; 0 || !m_Instance) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">const</font> NUI_IMAGE_FRAME * pImageFrame; <br> <font color="#0000ff">if</font> (FAILED(NuiImageStreamGetNextFrame( <br> m_DepthStreamHandle, 200, &amp;pImageFrame))) <font color="#0000ff">break</font> ; <br> NuiImageBuffer * pTexture = pImageFrame-&gt;pFrameTexture; <br> KINECT_LOCKED_RECT LockedRect; <br> pTexture-&gt;LockRect( 0, &amp;LockedRect, NULL, 0 ); <br> ReadDepthLockedRect(LockedRect, <br> m_DepthFrameSize.GetWidth(), <br> m_DepthFrameSize.GetHeight(), <br> m_DepthBuffer); <br> NuiImageStreamReleaseFrame(m_DepthStreamHandle, pImageFrame); <br> <font color="#0000ff">if</font> (m_Handler) <br> { <br> wxCommandEvent e(KINECT_DEPTH_FRAME_RECEIVED, wxID_ANY); <br> e.SetInt(m_DeviceIndex); <br> m_Handler-&gt;AddPendingEvent(e); <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">bool</font> KinectGrabberMSW::ReadColorFrame() <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (m_DeviceIndex &lt; 0 || !m_Instance) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">const</font> NUI_IMAGE_FRAME * pImageFrame; <br> <font color="#0000ff">if</font> (FAILED(NuiImageStreamGetNextFrame( <br> m_ColorStreamHandle, 200, &amp;pImageFrame))) <font color="#0000ff">break</font> ; <br> NuiImageBuffer * pTexture = pImageFrame-&gt;pFrameTexture; <br> KINECT_LOCKED_RECT LockedRect; <br> pTexture-&gt;LockRect( 0, &amp;LockedRect, NULL, 0 ); <br> ReadColorLockedRect(LockedRect, <br> m_ColorFrameSize.GetWidth(), <br> m_ColorFrameSize.GetHeight(), <br> m_ColorBuffer); <br> NuiImageStreamReleaseFrame(m_ColorStreamHandle, pImageFrame); <br> <font color="#0000ff">if</font> (m_Handler) <br> { <br> wxCommandEvent e(KINECT_COLOR_FRAME_RECEIVED, wxID_ANY); <br> e.SetInt(m_DeviceIndex); <br> m_Handler-&gt;AddPendingEvent(e); <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">bool</font> KinectGrabberMSW::ReadSkeletonFrame() <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (m_DeviceIndex &lt; 0 || !m_Instance) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (FAILED(m_Instance-&gt;NuiSkeletonGetNextFrame(200, &amp;m_SkeletonFrame))) <font color="#0000ff">break</font> ; <br> <font color="#0000ff">if</font> (m_Handler) <br> { <br> wxCommandEvent e(KINECT_SKELETON_FRAME_RECEIVED, wxID_ANY); <br> e.SetInt(m_DeviceIndex); <br> m_Handler-&gt;AddPendingEvent(e); <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">void</font> KinectGrabberMSW::ReadDepthLockedRect(KINECT_LOCKED_RECT &amp; LockedRect, <font color="#0000ff">int</font> w, <font color="#0000ff">int</font> h, BYTE * data) <br> { <br> <font color="#0000ff">if</font> ( LockedRect.Pitch != 0 ) <br> { <br> BYTE * pBuffer = (BYTE*) LockedRect.pBits; <br> USHORT * pBufferRun = (USHORT*) pBuffer; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y = 0 ; y &lt; h ; y++ ) <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x = 0 ; x &lt; w ; x++ ) <br> { <br> RGBQUAD quad = KinectGrabberMSW::Nui_ShortToQuad_Depth( *pBufferRun ); <br> pBufferRun++; <br> <font color="#0000ff">int</font> offset = (w * y + x) * 3; <br> data[offset + 0] = quad.rgbRed; <br> data[offset + 1] = quad.rgbGreen; <br> data[offset + 2] = quad.rgbBlue; <br> } <br> } <br> } <br> } <br> <br> <font color="#0000ff">void</font> KinectGrabberMSW::ReadColorLockedRect(KINECT_LOCKED_RECT &amp; LockedRect, <font color="#0000ff">int</font> w, <font color="#0000ff">int</font> h, BYTE * data) <br> { <br> <font color="#0000ff">if</font> ( LockedRect.Pitch != 0 ) <br> { <br> BYTE * pBuffer = (BYTE*) LockedRect.pBits; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y = 0 ; y &lt; h ; y++ ) <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x = 0 ; x &lt; w ; x++ ) <br> { <br> RGBQUAD * quad = ((RGBQUAD*)pBuffer) + x; <br> <font color="#0000ff">int</font> offset = (w * y + x) * 3; <br> data[offset + 0] = quad-&gt;rgbRed; <br> data[offset + 1] = quad-&gt;rgbGreen; <br> data[offset + 2] = quad-&gt;rgbBlue; <br> } <br> pBuffer += LockedRect.Pitch; <br> } <br> } <br> } <br> ...</font></code> </blockquote> <br>  <b>KinectHelper.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">#pragma</font> once <br> <br> <font color="#0000ff">class</font> KinectGrabberBase; <br> <br> <font color="#0000ff">class</font> KinectHelper <br> { <br> <font color="#0000ff">public</font> : <br> KinectHelper(); <br> ~KinectHelper(); <br> <br> size_t GetDeviceCount(); <br> wxString GetDeviceName(size_t index); <br> KinectGrabberBase * CreateGrabber(wxEvtHandler * handler, size_t index); <br> };</font></code> </blockquote> <br>  <b>KinectHelper.cpp</b> <br><blockquote> <code><font color="black">... <br> wxString KinectHelper::GetDeviceName(size_t index) <br> { <br> BSTR result; <br> DWORD size; <br> INuiInstance * instance(NULL); <br> wxString name = wxT( <font color="#A31515">"Unknown Kinect Sensor"</font> ); <br> <font color="#0000ff">if</font> (!FAILED(MSR_NuiCreateInstanceByIndex(index, &amp;instance))) <br> { <br> <font color="#0000ff">if</font> (instance != NULL) <br> { <br> <font color="#0000ff">if</font> (instance-&gt;MSR_NuiGetPropsBlob( <br> MsrNui::INDEX_UNIQUE_DEVICE_NAME, <br> &amp;result, &amp;size)) <br> { <br> name = result; <br> SysFreeString(result); <br> } <br> MSR_NuiDestroyInstance(instance); <br> } <br> } <br> <font color="#0000ff">return</font> name; <br> } <br> <br> KinectGrabberBase * KinectHelper::CreateGrabber(wxEvtHandler * handler, size_t index) <br> { <br> <font color="#0000ff">#if</font> defined(__WXMSW__) <br> <font color="#0000ff">return</font> <font color="#0000ff">new</font> KinectGrabberMSW(handler, index); <br> <font color="#0000ff">#else</font> <br> <font color="#0000ff">return</font> NULL; <br> <font color="#0000ff">#endif</font> <br> } <br> ...</font></code> </blockquote> <br>  Allocation of memory for RGB buffers, as well as code to ensure the capture of images in a separate stream, can be removed from the form class.  Now the form class will look like this: <br><br>  <b>KinectTestMainFrame.h</b> <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> KinectTestMainFrame: <font color="#0000ff">public</font> wxFrame <br> { <br> ... <br> <font color="#0000ff">void</font> OnDepthFrame(wxCommandEvent &amp; <font color="#0000ff">event</font> ); <br> <font color="#0000ff">void</font> OnColorFrame(wxCommandEvent &amp; <font color="#0000ff">event</font> ); <br> <font color="#0000ff">void</font> OnSkeletonFrame(wxCommandEvent &amp; <font color="#0000ff">event</font> ); <br> ... <br> wxImage m_CurrentImage; <br> <font color="#0000ff">int</font> m_SelectedDeviceIndex; <br> wxImage m_ColorImage; <br> wxImage m_SkeletonImage; <br> KinectGrabberBase * m_Grabber; <br> ... <br> };</font></code> </blockquote> <br>  <b>KinectTestMainFrame.cpp</b> <br><blockquote> <code><font color="black">... <br> BEGIN_EVENT_TABLE( KinectTestMainFrame, wxFrame ) <br> ... <br> EVT_COMMAND (wxID_ANY, KINECT_DEPTH_FRAME_RECEIVED, \ <br> KinectTestMainFrame::OnDepthFrame) <br> EVT_COMMAND (wxID_ANY, KINECT_COLOR_FRAME_RECEIVED, \ <br> KinectTestMainFrame::OnColorFrame) <br> EVT_COMMAND (wxID_ANY, KINECT_SKELETON_FRAME_RECEIVED, \ <br> KinectTestMainFrame::OnSkeletonFrame) <br> END_EVENT_TABLE() <br> ... <br> <font color="#0000ff">void</font> KinectTestMainFrame::OnDEVICELISTBOXSelected( wxCommandEvent&amp; <font color="#0000ff">event</font> ) <br> { <br> <font color="#0000ff">do</font> <br> { <br> size_t deviceIndex = <br> (size_t)m_DeviceListBox-&gt;GetClientData( <font color="#0000ff">event</font> .GetInt()); <br> <font color="#0000ff">if</font> (deviceIndex &lt; 0 || <br> deviceIndex &gt; m_KinectHelper-&gt;GetDeviceCount()) <font color="#0000ff">break</font> ; <br> m_SelectedDeviceIndex = deviceIndex; <br> StartGrabbing(); <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> } <br> <br> <font color="#0000ff">void</font> KinectTestMainFrame::StartGrabbing() <br> { <br> StopGrabbing(); <br> m_Grabber = m_KinectHelper-&gt;CreateGrabber( <font color="#0000ff">this</font> , m_SelectedDeviceIndex); <br> m_CurrentImage = wxImage( <br> m_Grabber-&gt;GetDepthFrameSize().GetWidth(), <br> m_Grabber-&gt;GetDepthFrameSize().GetHeight()); <br> m_ColorImage = wxImage( <br> m_Grabber-&gt;GetColorFrameSize().GetWidth(), <br> m_Grabber-&gt;GetColorFrameSize().GetHeight()); <br> m_SkeletonImage = wxImage( <br> m_Grabber-&gt;GetDepthFrameSize().GetWidth(), <br> m_Grabber-&gt;GetDepthFrameSize().GetHeight()); <br> m_DepthCanvas-&gt;SetCurrentImage(&amp;m_CurrentImage); <br> m_ColorCanvas-&gt;SetCurrentImage(&amp;m_ColorImage); <br> m_SkeletonCanvas-&gt;SetCurrentImage(&amp;m_SkeletonImage); <br> <font color="#0000ff">if</font> (!m_Grabber-&gt;Start()) <br> { <br> StopGrabbing(); <br> } <br> } <br> ... <br> <font color="#0000ff">void</font> KinectTestMainFrame::OnDepthFrame(wxCommandEvent &amp; <font color="#0000ff">event</font> ) <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (!m_Grabber) <font color="#0000ff">break</font> ; <br> m_Grabber-&gt;GrabDepthFrame(m_CurrentImage.GetData()); <br> m_DepthCanvas-&gt;Refresh(); <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> } <br> <br> <font color="#0000ff">void</font> KinectTestMainFrame::OnColorFrame(wxCommandEvent &amp; <font color="#0000ff">event</font> ) <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (!m_Grabber) <font color="#0000ff">break</font> ; <br> m_Grabber-&gt;GrabColorFrame(m_ColorImage.GetData()); <br> m_ColorCanvas-&gt;Refresh(); <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> } <br> <br> <font color="#0000ff">void</font> KinectTestMainFrame::OnSkeletonFrame(wxCommandEvent &amp; <font color="#0000ff">event</font> ) <br> { <br> <font color="#0000ff">do</font> <br> { <br> <font color="#0000ff">if</font> (!m_Grabber) <font color="#0000ff">break</font> ; <br> SkeletonPainter painter; <br> wxBitmap bmp(m_SkeletonImage.GetWidth(), m_SkeletonImage.GetHeight()); <br> wxMemoryDC mdc(bmp); <br> painter.DrawSkeleton(mdc, m_Grabber-&gt;GrabSkeletonFrame()); <br> mdc.SelectObject(wxNullBitmap); <br> m_SkeletonImage = bmp.ConvertToImage(); <br> m_SkeletonCanvas-&gt;Refresh(); <br> } <br> <font color="#0000ff">while</font> ( <font color="#0000ff">false</font> ); <br> }</font></code> </blockquote> <br>  As can be seen from the code, the grabber class, when it receives a new frame, sends a notification to the <code>wxEvtHandler</code> object (and the <code>wxFrame</code> class in wxWidgets is derived from <code>wxEvtHandler</code> ).  The form has event handlers that are called when notifications are received from the grabber. <br><br>  The reason why the <code>KinectGrabberBase::GrabSkeletonFrame()</code> method returns <code>void*</code> is also quite simple - if you make image capture implementations using various SDKs (including unofficial ones), then it‚Äôs not a fact that all these SDKs will receive information about the position of players in the form of identical data structures.  In any case, the coordinates must be sent for post-processing.  In this case, the code that receives the pointer from the grabber will know by itself what data type it needs to be converted to.  GUI about the internal structure of the grabber is not necessary to know. <br><br><h2>  In conclusion </h2><br>  In conclusion, I would like to note that, although Microsoft‚Äôs SDK is in beta, it is quite usable, although the Kinect control functionality is not fully implemented (libfreenect, for example, allows you to control the LEDs on the device, and the official SDK, according to the documentation, can not).  The library is surprisingly stable.  It is noticeable that the developers have taken care to avoid memory leaks.  If, for example, you forget to close the stream on exit, then the Visual Studio debugger will not report memory leaks, most likely everything ends correctly and is removed from memory when the library is unloaded. <br>  The source code of the test application and library can be found on Google Code - <a href="http://code.google.com/p/wxkinecthelper/">wxKinectHelper</a> . <br>  I count on the development of the project and the addition of new implementations of grabbers.  I'm currently trying to tame libfreenect.  Out of the box and without preliminary shamanism, we managed to start everything except receiving images - the LED indicators blink and the buzz with a motor turns out perfectly.  I'm trying to do the same with OpenNI. <br><br><h2>  useful links </h2><br>  <a href="http://research.microsoft.com/en-us/um/redmond/projects/kinectsdk/">Microsoft Research Kinect SDK</a> <br><br><h3>  Development Video with Kinect SDK </h3><br><ul><li>  <a href="http://channel9.msdn.com/series/KinectSDKQuickstarts">Kinect for Windows SDK Quickstarts</a> </li><li> <a href="http://channel9.msdn.com/Events/KinectSDK/BetaLaunch">Kinect for Windows SDK Beta Launch</a> </li></ul><br><h3>  SDK </h3><br><ul><li>  <a href="http://openkinect.org/">OpenKinect project (libfreenect)</a> </li><li>  <a href="http://www.openni.org/">OpenNI project</a> </li><li>  <a href="http://codelaboratories.com/nui">CL NUI Project from the NUI Group</a> </li></ul><br><h3>  ,  Kinect SDK </h3><br><ul><li> <a href="http://c4fkinect.codeplex.com/">Coding4Fun Kinect Toolkit</a> </li><li> <a href="http://kinectmouse.codeplex.com/">Kinect Mouse Cursor</a> </li><li> <a href="http://paint.codeplex.com/">Kinect Paint</a> </li></ul><br><h2>    </h2><br>        C++    Kinect SDK (  )       ,       ‚Äî     . </div><p>Source: <a href="https://habr.com/ru/post/123588/">https://habr.com/ru/post/123588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123580/index.html">Good Modding,% username%!</a></li>
<li><a href="../123581/index.html">PowerPoint haters party created in Switzerland</a></li>
<li><a href="../123582/index.html">Any student of programmer knows this.</a></li>
<li><a href="../123583/index.html">Google + and privacy. 5 useful options</a></li>
<li><a href="../123584/index.html">WebCL showed the first demos</a></li>
<li><a href="../123589/index.html">Pros and cons of cheap noname tablets</a></li>
<li><a href="../123590/index.html">Samsung Galaxy Tab 10.1 live review</a></li>
<li><a href="../123593/index.html">Using sites like Pastebin to collect information on the purpose of pentest</a></li>
<li><a href="../123594/index.html">We add informativeness to RSS feeds from RuTracker.org</a></li>
<li><a href="../123595/index.html">Car navigation in detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>