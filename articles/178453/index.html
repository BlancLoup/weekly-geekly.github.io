<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Federated Kalman Filter Generator using Genetic Algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As part of his scientific activity, he implemented the so-called Federated Kalman Filter. This article describes what Federated FC is, how it differs ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Federated Kalman Filter Generator using Genetic Algorithms</h1><div class="post__text post__text-html js-mediator-article">  As part of his scientific activity, he implemented the so-called Federated Kalman Filter.  This article describes what Federated FC is, how it differs from the generalized one, and also describes the console application that implements this filter and genetic algorithms for selecting the parameters of its mathematical model.  The application was implemented using the TPL (Task Parallel Library), so the post will be of interest not only to specialists in digital signal processing. <br><br>  <b>UPD1</b> : after reading <a href="http://habrahabr.ru/post/181149/">two</a> <a href="http://habrahabr.ru/post/178191/">recent</a> articles, I also decided to join the experiment / research / adventure (call it what you want).  At the end of the article added another survey - " <b>Would you have encouraged such narrowly specialized articles on Habrahabr? With a ruble?</b> " <br><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  On Habr√© already wrote about what the Kalman Filter (FC) is, what it is for and how it is compiled (conceptually).  Below are some of the available articles. <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/166693/">Kalman filter</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/120133/">Kalman filter - is it difficult?</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/140274/">Kalman Filter - Introduction</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/118192/">On the verge of augmented reality: what to prepare for developers (part 2 of 3)</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/114513/">Non-orthogonal SINS for small UAVs</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/135794/">Classical mechanics: on diffusers "on the fingers"</a> <br>  Also, there are quite a lot of articles on the use of various stochastic algorithms for optimizing nonlinear functions of many variables.  Here I include evolutionary algorithms, annealing imitation, population algorithm.  Links to some of the articles below. <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/112189/">Simulated annealing method</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/86777/">What is a genetic algorithm?</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/138091/">Genetic algorithms.</a>  <a href="http://habrahabr.ru/post/138091/">From theory to practice</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/66121/">Genetic algorithms, image recognition</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/128704/">Genetic algorithm.</a>  <a href="http://habrahabr.ru/post/128704/">Just about the complicated</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/111736/">Genetic algorithms for finding solutions and generating</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/111811/">Genetic algorithm using the example of Robocode bot</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/111417/">Genetic algorithms in MATLAB</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/178309/">Population based algorithm for fish school</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/110419/">Concepts of the practical use of genetic algorithms</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/84015/">Review of methods for the evolution of neural networks</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/111075/">TAU-Darwinism</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/104055/">Natural algorithms.</a>  <a href="http://habrahabr.ru/post/104055/">Bee Swarm Behavior Algorithm</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/104208/">Natural algorithms.</a>  <a href="http://habrahabr.ru/post/104208/">The implementation of the algorithm of the behavior of a swarm of bees</a> <br>  In one of my past articles ( <a href="http://habrahabr.ru/post/111078/">TAU-Darwinism: Implementation in Ruby</a> ) I presented to your attention the results of using genetic algorithms (GA) for selecting parameters of a mathematical model of a dynamic system.  This article presents the results of using GA in a more complex task - the synthesis of the Kalman Filter model.  Within the framework of this task, I have ‚Äúset off‚Äù genetic algorithms on the parameters of the dynamics in the transition matrix (aka the Transition Matrix) FC.  The GA could also be used to select the values ‚Äã‚Äãof the covariance matrices in the FC, but I decided not to do this for now.  I generated the noise myself, because the covariance matrix of measurement errors was known to me in advance.  In practice, the matrix of the noise covariances of the process is never precisely known in practice; therefore, I chose its value based on the maximum sensitivity of the PC to changes in the values ‚Äã‚Äãin the transition matrix. <br>  Anyway, it would be easy to extend the task described here to the case of optimizing the values ‚Äã‚Äãof the covariance matrices.  It will just be necessary to implement another objective function in which the covariances matrices will be generated from the values ‚Äã‚Äãof the individual's genes, and the value of the transition matrix will be set in advance.  Thus it turns out to divide into two stages the whole process of FC synthesis: <br>  1. Optimization of parameters of the mathematical model of FC <br>  2. Optimization of covariance matrix values <br>  The second stage, as I wrote above, I have not implemented yet.  However, its implementation in the plans is available. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Formulation of the problem </h4><br>  So, the task.  Suppose we have a certain measuring system consisting of several sensors (measuring channels).  As an example, take the non-orthogonal SINS, described in another of my articles ( <a href="http://habrahabr.ru/post/114513/">Non-orthogonal SINS for small UAVs</a> ).  Each of the sensors of such a system is a separate dynamic system, and at each particular time it gives one scalar measurement.  There are eight measuring channels in total (according to the number of axes of sensitivity of accelerometers in a block), and there are three required parameters (components of linear acceleration of the measuring block). <br>  What do we know about sensors?  We have only recordings of signals from sensors in static mode.  Those.  For us, someone placed a block of accelerometers somewhere in the basement and for, say, 24 hours, recorded the values ‚Äã‚Äãof the projection of free fall acceleration on the axis of sensitivity of the accelerometers.  Also, let us be given an approximate value of the matrix of the cosine guides of the sensors in the block. <br>  What is required of us?  Create an algorithm "Filter Kalmanovsky Type" (FCT), which would give optimal estimates of the linear acceleration of the measuring unit.  By optimum is meant the minimum of the variance of estimation errors and the minimum of their expectation (the minimum of the zero offset of errors). <br><blockquote>  <i>Note: the name ‚ÄúKalmanovsky Type Filter‚Äù is used, because the classic FC implies that its model coincides with the model of a real object, and the use of a different model is already called the ‚ÄúLewenberger Observing Identification Device‚Äù belonging to the FCT group.</i> </blockquote><br>  To select the parameters of the sensor models, it is proposed to use genetic algorithms.  Gene values ‚Äã‚Äãwill be used as coefficients of differential equations of sensors (see ‚ÄúIdentification Object‚Äù in Art. <a href="http://habrahabr.ru/post/111075/">TAU-Darwinism</a> ): <br><img src="https://habrastorage.org/storage2/008/7d7/031/0087d70310f4cc684137eceb7ffdd392.png"><br>  According to these coefficients, discrete models of sensors in the space-states will be built (see ‚ÄúMathematical Model‚Äù in the Art. <a href="http://habrahabr.ru/post/120133/">Kalman Filter ‚Äî is it difficult?</a> ): <br><img src="https://habrastorage.org/storage2/71c/279/3ae/71c2793ae54c965cf81bfabfc19a418f.png"><br><br>  On the basis of these models, a ‚Äúprivate‚Äù Kalman type filter will be compiled.  The assembly of several such ‚Äúprivate‚Äù filters forms a federated FCT. <br>  The fitness function of an individual will produce a unit divided by the average value of the squares of estimation errors: <br><img src="https://habrastorage.org/storage2/45f/a05/f1e/45fa05f1e5ea3458be500ecb2453fab1.png"><br>  here n is the number of steps of the filter modeling process (the number of samples in the recorded signals). <br><br><h4>  Federated Filter vs. Generalized </h4><br>  I have already described the concept of compiling a generalized FC (OFC) ( <a href="http://habrahabr.ru/post/120133/">Kalman Filter - is it difficult?</a> ).  I will not stop in detail.  The essence boils down to the fact that using the differential equations of sensors we compose models in the state space.  Next, we need to make a block diagonal matrix of the OFC, joining the matrix of sensor models diagonally.  Those.  such matrices <br><img src="https://habrastorage.org/storage2/54f/a69/afb/54fa69afbcb3cc64c6d769f77b726688.png"><br>  should give us something like this (for the transition matrix) <br><img src="https://habrastorage.org/storage2/b2e/6b3/2b1/b2e6b32b10dfb11caf93c644e640bdc2.png"><br>  where the second index of coefficients denotes the number of the sensor (measuring channel). <br>  The next important point is the state vector of the FC.  Roughly speaking, it contains the displacements of the pendulums of accelerometers (in the considered formulation of the problem) and the speeds of their displacements.  We need to calculate what acceleration should be applied to the unit in order to bring the accelerometers into the state calculated by the FK.  To do this, we must first calculate the signals of accelerometers modeled by the Kalman Filter. <br><img src="https://habrastorage.org/storage2/f35/657/a1a/f35657a1aceb1f2f86e248ec2bb1af6f.png"><br>  Where <br><table><tbody><tr><td><img src="https://habrastorage.org/storage2/1a7/5b2/267/1a75b2267f0193d6d248f91faf956c56.png"></td><td>  - block diagonal matrix composed of measurement matrices of sensor models </td></tr><tr><td><img src="https://habrastorage.org/storage2/50e/e93/207/50ee932072beb4d94380d2cbd2d8626e.png"></td><td>  - state vector of all sensors in the block </td></tr></tbody></table><br>  After we have received the vector of sensor signals, it remains for us to somehow solve the overdetermined system of eight equations with three unknowns. <br><img src="https://habrastorage.org/storage2/5c0/0ff/3a7/5c00ff3a782988210d502d9a3f809649.png"><br>  Where <br><table><tbody><tr><td><img src="https://habrastorage.org/storage2/6d1/f6b/fdb/6d1f6bfdbab2c0f9d881998f102141e4.png"></td><td>  - the direction cosines of the axes of sensitivity of accelerometers </td></tr><tr><td><img src="https://habrastorage.org/storage2/823/14a/35e/82314a35ed08f77f1c06142fc855d960.png"></td><td>  - the required acceleration of the measuring unit </td></tr></tbody></table><br>  And then suddenly ... <br><img src="https://habrastorage.org/storage2/b7b/e6a/46c/b7be6a46cbb89c93145f8a7632ed805e.jpg"><br>  We can only compute the pseudo-inverse matrix using the Gaussian-Markov least squares method: <br><img src="https://habrastorage.org/storage2/d71/7e2/9c5/d717e29c51a8b491b31e1317923bc231.png"><br>  where N is the matrix of cosine guides (see coefficients n11, n12, ..., n83 above); <br>  C is the covariance matrix of measurement errors (not to be confused with Sofk). <br>  What is wrong with the OFC algorithm?  In its transition matrix there are a lot of zeros for which you do not want to waste processor time.  This problem is precisely solved by the Federative Algorithm of the Kalman Type Filter.  The bottom line is simple.  We refuse to compile a single filter that combines all the sensors at once, and implement eight separate filters for each of the sensors.  Those.  instead of one 16th order filter, we use 8 second order filters.  Schematically it can be represented as follows. <br><img src="https://habrastorage.org/storage2/d20/83f/e98/d2083fe98aa0d3d1cbb52690f7914217.png"><br>  We, like in the case of OFC, substitute the output signals of these eight ‚Äúprivate‚Äù filters into the Gaussian-Markov OLS equation and obtain the estimates of the three components of the acceleration of the measuring unit. <br>  What is the disadvantage of Federated Kalman type filters?  They use the matrix [1x1] as the covariance matrix of measurement errors, which contains the variance of the measurement error of a single sensor.  Those.  instead of the covariance matrix, a scalar is used, equal to the noise dispersion of the specific sensor.  Thus, the covariance of noise between the measuring channels is not taken into account.  This means that such a filter should be less effective in the case of real, correlated with each other noise.  This is in theory.  In practice, the covariations of noise change over time, so there is no possibility to guarantee that the OFK will give a ‚Äúmore‚Äù optimal estimate than the federal one.  It may well be that the efficiency of the OFC will not be much higher or even equal to the effectiveness of the federated filter.  This, by the way, I have yet to explore. <br><br><h4>  Synthesis and Simulation Program </h4><br><h5>  Solution structure </h5><br>  I apologize in advance for the Anglicisms - I could not find some terms from professional jargon to find the equivalent in the ‚Äúgreat and powerful‚Äù.  So, I‚Äôll start the story about the program with an enlarged description of the structure of the solution (sorry).  Then I will describe the logic of the most interesting in my opinion methods.  In the end I will tell about how I generated the initial data for the program. <br>  The structure of the solution is presented on mind-map ( <s>flash drive with brains</s> ?) Below.  Dotted arrows indicate links of assemblies (references). <br><img src="https://habrastorage.org/storage2/112/fb2/092/112fb20929c2138f53a156ebeaff618f.png"><br>  The program uses two third-party libraries: Math.Net for matrix algebra and the generation of random numbers, as well as FileHelpers to download data from CSV files.  In addition, the implemented genetic algorithm engine is based on a third-party implementation of ‚Äú <a href="http://www.codeproject.com/Articles/3172/A-Simple-C-Genetic-Algorithm">A Simple C # Genetic Algorithm</a> ‚Äù (Barry Lapthorn).  True, from the original implementation remains a bit. <br>  The solution contains one project of a console application and four projects of type Class Library, containing the main logic. <br>  GA assembly, as the name suggests, contains an implementation of genetic algorithms.  It contains the structure Specimen (individual data structure) and the classes GA and SpecimenHelper.  SpecimenHelper is a static class and contains static methods that simplify working with individual genes (for example, GenerateGenes, Crossover, Mutate, Print).  This class also contains instances of ContinuousUniform random number generators from the Math.Net library.  This generator had to be used, because  I found out that the standard Random generator from .Net 4.5 assemblies generates normally distributed random numbers instead of uniformly distributed ones.  For gene generation, this is quite critical. <br>  The class GA is instance-oriented.  You can create multiple instances of the optimizer with different parameters and functions of adaptation.  For example, one can make the selection of the parameters of a mathematical model of sensors in one engine, and in the second one can already select the values ‚Äã‚Äãof the covariance matrices, and through the closure ‚Äúslip‚Äù into the fitness function the best at the moment assembly of the mathematical model parameters. <br>  Simulation assembly currently contains only one static class, FedKfSim.  That, in turn, contains the parameters for the simulation of a federated filter, the extension method ToFedKf for an instance of the Specimen class, which creates a federated filter for the genes of a given individual.  Also this class contains a static Simulate method, in which a federated filter is created for the transferred parameters of an individual and the process of simulation of the operation of this filter is started. <br>  Filtering assembly contains implementations of a dynamic model in the state space (class SSF), a private Kalman type filter (class KF), and a federated filter (class FedKF).  The SSF class, in addition to the instance methods, contains two static methods that allow you to generate a discrete model of the state space from the coefficients of the continuous transfer function (PF).  PF parameters are transmitted in MatLab notation, i.e. <br><img src="https://habrastorage.org/storage2/337/d34/f41/337d34f418448a29d75ff0f0cba31f0e.png"><br>  The static class KFBuilder in the Filtering assembly contains auxiliary methods for generating a state space model and a private FCT using as input data the string records of the coefficients of the numerator and denominator of the continuous SF, as well as the required sampling frequency (the value inverse of the time quantization period). <br>  The DAL assembly contains the FileParser class, used for splitting text files containing matrix data, as well as for loading signals and noise from CSV files. <br><br><h5>  Genetic Algorithm Engine </h5><br>  For its operation, it is necessary to set the fitness function (FitnessFunction), population size (PopulationSize), number of generations (GenerationsCount), number of genes in an individual (GenomeSize), probability of crossing (CrossoverRate), probability of mutation (MutationRate). <br>  The Initiation method is designed to generate the initial population of individuals.  The method code is presented below (only the most important is left): <br><div class="spoiler">  <b class="spoiler_title">private void Initiation ()</b> <div class="spoiler_text"><pre><code class="hljs ruby">private void Initiation() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... _currGeneration = new List&lt;Specimen&gt;(); var newSpecies = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, PopulationSize).AsParallel().Select(i =&gt; { var newSpec = new Specimen { Length = this.GenomeSize }; SpecimenHelper.GenerateGenes(ref newSpec); var fitness = FitnessFunction(newSpec); newSpec.Fitness = double.IsNaN(fitness) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (double.IsInfinity(fitness) ? <span class="hljs-number"><span class="hljs-number">1</span></span>e5 : fitness); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newSpec; }).OrderBy(s =&gt; s.Fitness); _currGeneration = newSpecies.ToList(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Huge load starts here <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>) _fitnessTable = new List&lt;double&gt;(); foreach (var spec <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _currGeneration) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_fitnessTable.Any()) { _fitnessTable.Add(spec.Fitness); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _fitnessTable.Add(_fitnessTable.Last() + spec.Fitness); } } TotalFitness = _currGeneration.Sum(spec =&gt; spec.Fitness); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... }</code> </pre> <br></div></div><br>  An important point here is the use of parallel LINQ.  First, an array of indices is created from 0 to the size of the population.  For this enumerable instance, a parallel query (.AsParallel ()) is created, to which a select query is already attached, in the body of which an instance of the individual will be generated and the value of its fitness will be calculated.  At the end, an ordering query (.OrderBy (...)) is attached.  All these were requests and this block of code will be executed quickly.  The values ‚Äã‚Äãwill be updated in the following line: <br> <code>_currGeneration = newSpecies.ToList(); // Huge load starts here :)</code> <br>  what the comment says.  In this case, the calculations will be performed in parallel with the use of a pool of threads; therefore, in the body of a select query, you cannot put the code to write values ‚Äã‚Äãto any common variable (for example, to a common array).  Such code will slow down the work of a parallel query (we will still face this). <br>  On the generated individuals, an individual fitness table is calculated, which will be needed for the Roulette Wheel algorithm for sampling individuals for crossing.  As can be seen from the code, each current (last) value in the table is the sum of the previous value and the current fitness.  In this way, the table is filled with segments of different lengths - the greater the fitness, the greater the length of the segment (see figure below). <br><img src="https://habrastorage.org/storage2/d17/3e9/7a5/d173e97a5c4a26a6a53a2652077aba1c.png"><br>  Due to this, using a uniformly distributed random variable ranging from zero to the sum of all adaptations, it is ‚Äúhonest to choose‚Äù individuals for crossing so that the most adapted individuals are chosen more often, but the ‚Äúlosers‚Äù also have a chance to cross.  If the random number generator will produce normally distributed values ‚Äã‚Äã(as is the case with Random in .Net 4.5), then individuals will most often be selected from the middle of the fitness table.  That is why I wrote above that using ContinuousUniform from the Math.Net package was in my case a critical moment. <br>  The next method you want to talk about is the Selection method. <br><div class="spoiler">  <b class="spoiler_title">private void Selection ()</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript">private void Selection() { var tempGenerationContainer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;Specimen&gt;(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PopulationSize / <span class="hljs-number"><span class="hljs-number">2.5</span></span>; i++) { int pidx1 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PopulationSize - i - <span class="hljs-number"><span class="hljs-number">1</span></span>; int pidx2 = pidx1; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pidx1 == pidx2 || _currGeneration[pidx1].IsSimilar(_currGeneration[pidx2])) { pidx2 = RouletteSelection(); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... var children = Rnd.NextDouble() &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CrossoverRate ? parent1.Crossover(parent2) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Specimen&gt; { _currGeneration[pidx1], _currGeneration[pidx2] }; foreach (var ch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> children.AsParallel()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (double.IsNaN(ch.Fitness)) { var fitness = FitnessFunction(ch); var newChild = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specimen { Genes = ch.Genes, Length = ch.Length, Fitness = double.IsNaN(fitness) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (double.IsInfinity(fitness) ? <span class="hljs-number"><span class="hljs-number">1e5</span></span> : fitness) }; tempGenerationContainer.Add(newChild); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tempGenerationContainer.Add(ch); } } } _currGeneration = tempGenerationContainer.OrderByDescending(s =&gt; s.Fitness).Take(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PopulationSize).Reverse().ToList(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... }</code> </pre><br></div></div><br>  In this method, selection is made.  I did not choose here both parents using the roulette wheel.  The first parent is selected in order from a little less than half of the most adapted individuals.  The second parent is already chosen randomly.  Moreover, if the second parent is close to the first in genes, the random sample is repeated until a sufficiently different parent is obtained.  Then, a crossing procedure is randomly launched, which yields two individuals with mixed genes and another one, the values ‚Äã‚Äãof which genes are selected as the average of the values ‚Äã‚Äãof the genes of the parents. <br><blockquote>  <i>TODO: probably, it is necessary to replace the calculation of the average by calculating a random number in the range between the values ‚Äã‚Äãof the parents' genes.</i> </blockquote><br>  After crossing the new individuals fitness will be double.NaN.  The actualization of the values ‚Äã‚Äãof fitness of new individuals is done again in parallel. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> children.AsParallel()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.IsNaN(ch.Fitness)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fitness = FitnessFunction(ch); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newChild = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specimen { <span class="hljs-comment"><span class="hljs-comment">//... }; tempGenerationContainer.Add(newChild); } //... }</span></span></code> </pre><br>  The last method of the GA engine that is worth telling is the RouletteSelection method. <br><pre> <code class="hljs perl">private <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RouletteSelection() { double randomFitness = Rnd.NextDouble() * TotalFitness; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> first = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">last</span></span> = this.PopulationSize - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mid = (<span class="hljs-keyword"><span class="hljs-keyword">last</span></span> - first) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idx == -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; first &lt;= <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomFitness &lt; _fitnessTable[mid]) { <span class="hljs-keyword"><span class="hljs-keyword">last</span></span> = mid; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomFitness &gt; _fitnessTable[mid]) { first = mid; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomFitness == _fitnessTable[mid]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mid; } mid = (first + <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> lies between i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">last</span></span> - first) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { idx = <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idx; }</code> </pre><br>  In this method, using the half-division method, a segment is searched for in the table of adaptations, into which a randomly chosen value falls.  Again, a random number is selected in the range from zero to the sum of all adaptations.  The greater the fitness of a particular individual, the greater the likelihood that a randomly chosen value of fitness will fall into the segment of the table corresponding to that individual.  In this way, the desired index is quite quickly. <br><br><h5>  Simulator Federated FCT </h5><br>  As written earlier, the federated filter simulator is implemented by the FedKfSim class.  The main method in it is the Simulate method. <br><div class="spoiler">  <b class="spoiler_title">public static double Simulate (Specimen spec)</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Simulate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Specimen spec</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fkf = spec.ToFedKf(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> meas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lng = Math.Min(Signals.RowCount, MaxSimLength); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[lng]; results[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3 { X = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, Y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>, Z = <span class="hljs-number"><span class="hljs-number">0.0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; lng; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sigRow = Signals.Row(i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noiseRow = Noises.Row(i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targRow = Targets.Row(i); meas[<span class="hljs-number"><span class="hljs-number">0</span></span>] = sigRow[<span class="hljs-number"><span class="hljs-number">0</span></span>] + noiseRow[<span class="hljs-number"><span class="hljs-number">0</span></span>]; meas[<span class="hljs-number"><span class="hljs-number">1</span></span>] = sigRow[<span class="hljs-number"><span class="hljs-number">1</span></span>] + noiseRow[<span class="hljs-number"><span class="hljs-number">1</span></span>]; meas[<span class="hljs-number"><span class="hljs-number">2</span></span>] = sigRow[<span class="hljs-number"><span class="hljs-number">2</span></span>] + noiseRow[<span class="hljs-number"><span class="hljs-number">2</span></span>]; meas[<span class="hljs-number"><span class="hljs-number">3</span></span>] = sigRow[<span class="hljs-number"><span class="hljs-number">3</span></span>] + noiseRow[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = fkf.Step(meas, inps.ToColumnWiseArray()); <span class="hljs-comment"><span class="hljs-comment">// inps       var errs = new double[] { res[0, 0] - targRow[0], res[1, 0] - targRow[1], res[2, 0] - targRow[2] }; err += (errs[0] * errs[0]) + (errs[1] * errs[1]) + (errs[2] * errs[2])/3.0; results[i] = new Vector3 { X = res[0, 0], Y = res[1, 0], Z = res[2, 0] }; ... } ... return 1/err*lng; }</span></span></code> </pre><br></div></div><br>  In this method, an iterative process is started.  At each step, a sample is taken of the pure values ‚Äã‚Äãof the sensor signals, the noise and the reference values ‚Äã‚Äã(the accelerations of the block without noise).  Clean signals are added to noise, and this mixture is input to the Step method of a federated filter.  There is also an estimate of the block accelerations from the previous step, but these values ‚Äã‚Äãare not used in the current implementation of the private FCT.  The step method of the federated filter returns an array of values ‚Äã‚Äã‚Äî estimates of the block accelerations.  The difference between them and the values ‚Äã‚Äãof the reference will be the current estimation error.  At the end of the current step, the average square of the estimation errors is calculated, and the resulting value is added to the sum of the errors.  At the end of the iterations, the average error value is calculated for all process steps.  The output is a number opposite to the average error. <br><br><h5>  Executable application </h5><br>  The sequence of the application is as follows.  First, the console arguments are checked.  If the argument list is not empty, then an attempt is made to execute one of the valid commands. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (cmd) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"simulate"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"simulation"</span></span>: InitializeSimulator(); FedKfSim.PrintSimResults = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specimen(); SpecimenHelper.SetGenes(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> spec, ReadSimulationGenes()); FedKfSim.Simulate(spec); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"set"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settingName = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settingValue = args[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); config.AppSettings.Settings[settingName].Value = settingValue; config.Save(ConfigurationSaveMode.Modified); ConfigurationManager.RefreshSection(<span class="hljs-string"><span class="hljs-string">"appSettings"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"'{0}' set to {1}"</span></span>, settingName, settingValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"print"</span></span>: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Current settings:"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ConfigurationManager.AppSettings.AllKeys.AsParallel()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ConfigurationManager.AppSettings[name]; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"'{0}' =&gt; {1}"</span></span>, name, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"help"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"?"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-h"</span></span>: PrintHelp(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Console.Error.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"\nARGUMENT ERROR\n'{0}' is unknown command!\n"</span></span>, cmd)); PrintHelp(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  The command ‚Äúsimulate‚Äù reads the gene values ‚Äã‚Äãfor which you want to generate a federated FCT from the configuration files.  The ‚Äúset‚Äù command is intended to change one of the values ‚Äã‚Äãin the main configuration file of the application.  The ‚Äúprint‚Äù command in the console displays the values ‚Äã‚Äãof all settings from the main configuration file.  The ‚Äúhelp‚Äù command outputs basic documentation to the console. <br>  When the application is started without arguments, the main parameters of the GA engine work are read from the configuration file, as well as the values ‚Äã‚Äãof the matrices, signals, noises and references from the data files.  After downloading all the necessary data and parameters, an instance of the optimizer is created and the evolutionary process starts. <br><pre> <code class="hljs cs">InitializeSimulator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> genCount = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"GenerationsCount"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> popSize = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"PopulationSize"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> crossOver = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"CrossoverRate"</span></span>], FileParser.NumberFormat); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mutRate = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"MutationRate"</span></span>], FileParser.NumberFormat); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxGeneVal = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"MaxGeneValue"</span></span>], FileParser.NumberFormat); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> minGeneVal = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"MinGeneValue"</span></span>], FileParser.NumberFormat); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> genomeLength = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"GenomeLength"</span></span>]); SpecimenHelper.SimilarityThreshold = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.Parse( ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"SimilarityThreshold"</span></span>], FileParser.NumberFormat); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ga = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ga(genomeLength) { FitnessFunction = FedKfSim.Simulate, Elitism = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, GenerationsCount = genCount, PopulationSize = popSize, CrossoverRate = crossOver, MutationRate = mutRate }; FedKfSim.PrintSimResults = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ga.Go(maxGeneVal, minGeneVal);</code> </pre><br>  Special attention here should be paid to the ReadSignalsAndNoises method. <br><div class="spoiler">  <b class="spoiler_title">private static void ReadSignalsAndNoises ()</b> <div class="spoiler_text"><pre> <code class="hljs javascript">private <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ReadSignalsAndNoises() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noisesPath = ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"NoisesFilePath"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> signalsPath = ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"SignalsFilePath"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetsPath = ConfigurationManager.AppSettings[<span class="hljs-string"><span class="hljs-string">"TargetsFilePath"</span></span>]; FedKfSim.Noises = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseMatrix(FileParser.Read4ColonFile(noisesPath)); FedKfSim.Signals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseMatrix(FileParser.Read4ColonFile(signalsPath)); FedKfSim.Targets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseMatrix(FileParser.Read3ColonFile(targetsPath)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> measCov = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseMatrix(<span class="hljs-number"><span class="hljs-number">4</span></span>); double c00 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c01 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c02 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c03 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c11 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c12 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c13 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c22 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c23 = <span class="hljs-number"><span class="hljs-number">0</span></span>, c33 = <span class="hljs-number"><span class="hljs-number">0</span></span>; Vector&lt;double&gt; v1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseVector(<span class="hljs-number"><span class="hljs-number">1</span></span>); Vector&lt;double&gt; v2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseVector(<span class="hljs-number"><span class="hljs-number">1</span></span>); Vector&lt;double&gt; v3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseVector(<span class="hljs-number"><span class="hljs-number">1</span></span>); Vector&lt;double&gt; v4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DenseVector(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> double[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> double[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> double[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> double[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t00 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { v1 = FedKfSim.Noises.Column(<span class="hljs-number"><span class="hljs-number">0</span></span>); s1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(v1); c00 = s1.Variance; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t11 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { v2 = FedKfSim.Noises.Column(<span class="hljs-number"><span class="hljs-number">1</span></span>); s2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(v2); c11 = s2.Variance; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t22 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { v3 = FedKfSim.Noises.Column(<span class="hljs-number"><span class="hljs-number">2</span></span>); s3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(v3); c22 = s3.Variance; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t33 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { v4 = FedKfSim.Noises.Column(<span class="hljs-number"><span class="hljs-number">3</span></span>); s4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DescriptiveStatistics(v4); c33 = s4.Variance; }); Task.WaitAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { t00, t11, t22, t33 }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t01 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> c01 = CalcVariance(v1, s1.Mean, v2, s2.Mean, FedKfSim.Noises.RowCount)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t02 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> c02 = CalcVariance(v1, s1.Mean, v3, s3.Mean, FedKfSim.Noises.RowCount)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t03 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> c03 = CalcVariance(v1, s1.Mean, v4, s4.Mean, FedKfSim.Noises.RowCount)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t12 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> c12 = CalcVariance(v2, s2.Mean, v3, s3.Mean, FedKfSim.Noises.RowCount)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t13 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> c13 = CalcVariance(v2, s2.Mean, v4, s4.Mean, FedKfSim.Noises.RowCount)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t23 = Task.Run(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> c23 = CalcVariance(v3, s3.Mean, v4, s4.Mean, FedKfSim.Noises.RowCount)); Task.WaitAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { t01, t02, t03, t12, t13, t23 }); measCov[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] = c00; measCov[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = c01; measCov[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] = c02; measCov[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = c03; measCov[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] = c01; measCov[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = c11; measCov[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] = c12; measCov[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = c13; measCov[<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] = c02; measCov[<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = c12; measCov[<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] = c22; measCov[<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = c23; measCov[<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] = c03; measCov[<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = c13; measCov[<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] = c23; measCov[<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = c33; FedKfSim.SensorsOutputCovariances = measCov; }</code> </pre><br></div></div><br>  It uses several separate double variables to store the values ‚Äã‚Äãof the covariances.  As I wrote above, if I used one array, then parallel tasks (Task) would be executed slowly.  Actually on it I also pricked with initial implementation of this method.  Within each task, I set the indices by which the resulting value of covariance should have been written in the general array.  And from this point of view, the code was, it seems, safe.  But it was performed extremely slowly.  After replacing the array with separate variables, the calculation of the covariance matrix was significantly accelerated. <br>  So what is done in this method?  For each unique combination of two rows of noise, a separate asynchronous task is created.  In these problems, the mutual variation of two random processes is calculated. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcVariance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mean1, IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mean2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zipped = v1.Take(length).Zip(v2.Take(length), (i1, i2) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { i1, i2 }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = zipped.AsParallel().Sum(z =&gt; (z[<span class="hljs-number"><span class="hljs-number">0</span></span>] - mean1) * (z[<span class="hljs-number"><span class="hljs-number">1</span></span>] - mean2)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum / (length - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  The formula is similar to the formula for calculating the variance.  Only instead of the square of deviations from the mean of one random series, the product of deviations from the mean values ‚Äã‚Äãof two separate rows is used. <br>  Initial data <br>  The initial data for the program are numerical rows with noises, sensor signals and the true values ‚Äã‚Äãof the components of the block acceleration, as well as filter parameters: the matrix of cosine guides (taken from my graduation project, corresponds to the configuration of the redundant block described in one of my past articles), covariance matrix process noise (set empirically). <br>  The reference values ‚Äã‚Äãof the block accelerations were specified as a combination of two sinusoids.  These values ‚Äã‚Äãwere recalculated into the sensor signals via the matrix of the block cosines.  Sensor noise was generated in a hybrid way.  I took a recording of a signal from a real sensor that was at rest while recording.  Having removed the constant component from this signal, I got sensor noise in statics (this is enough for debugging algorithms).  By the way, these noises turned out to be very close to white with a normal distribution.  I cut these noises into short samples of 1000 values, scaled their intensities to bring the dispersions to the range [0.05..0.15].  Thus, we can say that I used real noises in my research. <br><br><h4>  results </h4><br><img src="https://habrastorage.org/storage2/bc8/f90/ebc/bc8f90ebc1fc0499dd7871aeb062a6f1.png"><br>  The generated federated filter reduced the average noise variance by almost two times (i.e., reduced the root-mean-square error by about 1.38 times).  It was possible to achieve an even more significant decrease in the variance of errors by increasing the inertia, but then the dynamic lag would increase.  In my opinion, with the help of the GA, a quite efficient noise filter was generated. <br><br><h4>  Conclusion </h4><br>  I don‚Äôt have so much free time, therefore, when implementing the main functionality, there was no time for perfectionism.  In some places there are security holes in the code (mainly for validating arguments), and in some places the general recommendations of the C # Code Style Guide are not followed.  Surely there are blocks of code with sub-optimal performance.  But despite all its flaws, it works quite well.  I tested it on Intel Core i3 CPUs, and the optimization process was pretty fast.  In addition, due to the use of TPL, processor resources were used quite effectively.  The implemented algorithms consumed almost all the free time of the processor, but due to the normal priority of asynchronous TPL tasks, the other user programs worked without serious locks.  I started the implemented program in the console and switched to working in Visual Studio 2012 with a built-in resharper, periodically switched to Outlook and MS Word, debugged the working draft in parallel in IE and Chrome browsers, without serious brakes.  In general, it was a good experience using the asynchronous programming library TPL, a good result was immediately obtained without any serious difficulties. <br>  Thanks for attention!  I hope the article and the code will be useful to you. <br><br>  <b>Github sources</b> : <a href="https://github.com/homoluden/fedkf-ga">github.com/homoluden/fedkf-ga</a> </div><p>Source: <a href="https://habr.com/ru/post/178453/">https://habr.com/ru/post/178453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178443/index.html">Application Excellence Labs are back with a new name and in a new format on DevCon 2013</a></li>
<li><a href="../178445/index.html">Overview of the high-capacity 6400mAh battery for Galaxy Note 2 on PocketNow</a></li>
<li><a href="../178447/index.html">Overview of the updated features of Windows Azure IaaS</a></li>
<li><a href="../178449/index.html">Want to make exciting presentations? Turn off the projector!</a></li>
<li><a href="../178451/index.html">unadox.com: hello insurers</a></li>
<li><a href="../178455/index.html">A new set has been opened for the Yandex Data Analysis School</a></li>
<li><a href="../178457/index.html">What questions can be answered by analyzing 1,500,000 unique case histories?</a></li>
<li><a href="../178459/index.html">Report from InterSystems Global Summit 2013</a></li>
<li><a href="../178461/index.html">REG.RU presents ‚Äúflexible‚Äù hosting from Jelastic to Russian users</a></li>
<li><a href="../178463/index.html">Starter "from scratch", my experience, success stories</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>