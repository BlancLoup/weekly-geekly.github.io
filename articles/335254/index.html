<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How development workflow affects task decomposition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most important factors influencing the speed of development and the success of a project launch is the correct decomposition of the product...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How development workflow affects task decomposition</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/e3f/075/e9c/e3f075e9cb6e4c949c518c2a9268fb84.jpg"></p><br><p>  One of the most important factors influencing the speed of development and the success of a project launch is the correct decomposition of the product manager‚Äôs idea into tasks for programming directly.  How to do it right?  Take the script of the new features from the product and immediately start coding?  First, write acceptance tests, and then - the <a href="https://en.wikipedia.org/wiki/Test-driven_development">code that will ensure</a> their passage?  And maybe, to shift everything on the shoulders of developers - and let them decide during the <a href="https://en.wikipedia.org/wiki/Scrum_%2528software_development%2529">scrum poker</a> ? </p><br><p>  Let's think and identify the problems that may arise in the process of separation of tasks, and ways to solve them.  This post will cover the basic principles of task decomposition when working in a team.  My name is Ilya Ageev, I am the head of QA in Badoo.  Today I‚Äôll tell you how workflow influences decomposition, how different testing and layout of tasks that arise as a result of decomposition differ, and what rules should be followed for the development process to run smoothly for all participants. </p><a name="habracut"></a><br><h3 id="pochemu-eto-vazhno">  Why is it important? </h3><br><p>  It must be remembered that the development process is not only a direct session of writing code.  When we talk about development, I urge you to look at the whole process, from the formulation of the problem to the stable operation of the feature of our users.  If you do not take into account all the stages that precede coding and follow it, then it is very easy to get into a situation where everyone does something, <a href="https://en.wikipedia.org/wiki/Performance_indicator">performs their KPI</a> , receives bonuses, and the result is deplorable.  Business is bent, competitors are "stifling", but at the same time everyone is great. </p><br><p>  Why it happens?  It's simple: human psychology makes people look at situations from the point of view of <a href="https://en.wikipedia.org/wiki/Comfort_zone">their own comfort</a> .  The developer does not always want to think about what will happen to the code after it is written.  Solved the problem - and good.  He is extremely rarely interested in this (which is why we, IT professionals, work in this industry - our motivation mainly rests on the interestingness of the tasks), because in relations with people there is so much uncertainty.  Many developers feel much more comfortable sitting at a computer and concentrating on solving their own interesting task - blockchains with neural networks - they don‚Äôt want to be distracted and think about some product managers, deadlines, users who will then use their ingenious work (or else they will begin to criticize!). </p><br><p>  This is not bad and not good - we appreciate the developers precisely for thoughtful and competent solution of technical problems.  But a narrow look at problems often stops development.  And it's about the development of not only specific people, but also the company as a whole.  After all, the growth of the company and the improvement of the corporate culture are possible only with the growth of each employee.  Therefore, it is important for us to sometimes get out of the "cocoon" and force ourselves to look at problems more broadly in order to stimulate this growth. </p><br><p>  And, of course, if such an important stage, as decomposition, is entrusted to a person who looks at everything exclusively from the point of view of his own convenience, there is a real risk to sting a lot of problems at subsequent stages: when merging the results of his work with the results of others, with code review, with testing, laying out in production, etc. </p><br><p>  Thus, determining for oneself how to properly break up a particular task, estimating where to start and where to come as a result, it is important to take into account as many factors as possible, and not to look at the problem only ‚Äúfrom your bell tower‚Äù.  Sometimes in order for things to work faster and more efficiently in the next stages, you have to do something more complicated and slower at the stage for which you are responsible. </p><br><p>  A good example is writing unit tests.  Why do I need to spend my precious time writing tests, if we have testers who then test everything?  And then, that unit tests are necessary not only to facilitate the coding process - they are also needed in the subsequent stages.  And they are needed as air: with them the process of integration and verification of regression is accelerated tens, hundreds of times, the <a href="https://martinfowler.com/bliki/TestPyramid.html">automation pyramid</a> is based on them.  And this is even if you do not take into account the acceleration of your own work: after ‚Äútouching‚Äù the code in some place, you yourself need to make sure that you do not accidentally break something.  And one of the fastest ways to do this is to drive away unit tests. </p><br><h3 id="workflow">  Workflow </h3><br><p>  Many teams, to somehow formalize the relationship between the participants of the process, agree on the rules of work in a team: agree on coding standards, a common workflow in the version control system, establish a release schedule, etc. </p><br><p>  Needless to say, if you initially agree on a process, without taking into account the entire life cycle of a feature, you can get a slowdown and a ‚Äúrake‚Äù in the future?  Especially when you consider the growth of the project and the company.  We do not forget about <a href="https://shreevatsa.wordpress.com/2008/05/16/premature-optimization-is-the-root-of-all-evil/">premature optimization</a> , but if there is a process that works well on different scales, then why not use it initially? </p><br><p>  Speaking of workflow development, many who use Git, immediately recall (in vain) about some kind of "standard git-flow", considering it ideal, correct, and often embed it in themselves.  Even at conferences where I spoke, talking about workflow in Badoo, I was asked several times: ‚ÄúWhy did you invent your own, why don't you use standard git-flow?‚Äù Let's understand. </p><br><p> <a href=""><img src="https://habrastorage.org/web/e1a/2f3/762/e1a2f37621334ed0bd3cee08a9d3aab9.png"></a> </p><br><p>  <strong>First of all</strong> , usually speaking about this flow, they mean this picture.  I took it from the Vincent Driessen article <a href="http://nvie.com/posts/a-successful-git-branching-model/">‚ÄúA successful Git branching model‚Äù,</a> which describes a scheme that has worked quite successfully on several of its projects (it was back in 2010). </p><br><p>  Today, some large players in the hosting code market generally offer their flow, criticizing the <a href="https://docs.gitlab.com/ce/workflow/gitlab_flow.html">‚Äústandard git-flow‚Äù</a> and describing its flaws;  give their schemes, recommendations, techniques. </p><br><p>  If you search on <a href="https://git-scm.com/search/results%3Fsearch%3Dbranching">git-scm.com</a> (it would be good to google it at all), then you will be surprised to find that there is no recommended (and even less ‚Äústandard‚Äù) workflow.  That's because Git is, in fact, a <a href="https://habrahabr.ru/company/badoo/blog/163853/">framework</a> for storing versions of code, and how you organize this storage and collaboration, depends only on you.  You should always keep in mind that if some flow "took off" on some projects, this does not mean at all that you, too, will fully fit it. </p><br><p>  <strong>Secondly</strong> , even in our company, different teams have a different flow.  The flow of PHP server code development, C / C ++ and Go demons, the mobile command flow are different.  And we did not immediately come to this: we tried various options before dwelling on something concrete.  By the way, not only workflow differs in these teams, but also testing methodologies, setting tasks, releases and the delivery principle itself: what is delivered to your personal servers and computers (smartphones) of end users cannot be developed equally by definition. </p><br><p>  <strong>Thirdly</strong> , even accepted workflow is a recommendation rather than an indisputable rule.  The tasks of a business are different, and it‚Äôs good if you managed to choose a process covering <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B0%25D0%25BB">95% of</a> cases.  If your current task does not fit into the selected flow, it makes sense to look at the situation from a pragmatic point of view: if the rules prevent you from making effective, to hell with such rules!  But be sure to consult with your manager before making a final decision - otherwise a mess can begin.  You can tritely ignore any important points that are known to your supervisor.  And, perhaps, everything will go like clockwork - and you will be able to change the existing rules so that it will lead to progress and will be the <a href="https://www.employeeconnect.com/blog/constructive-feedback-examples/">key to growth for all</a> . </p><br><p>  If everything is so difficult, and even the flow is not a dogma, but only a recommendation, then why not use one branch for everything: Master for Git or Trunk for SVN?  Why complicate things? </p><br><p>  To those who look at the problem one-sidedly, this approach with one branch may seem very convenient.  Why bother with some branches, sweat with the stabilization of the code in them, if you can write the code, commit (push) to the common repository - and enjoy life?  And the truth is, if there are not very many people working in the team, it can be convenient, since it eliminates the need to merge branches and organize branches for release.  However, this approach has one very significant drawback: the code in the general repository may be unstable.  Vasya, working on task # 1, can easily break the code of other tasks in the common repository, flood his changes;  and until he corrects them / rolls back, the code cannot be uploaded, even if all the other tasks are ready and working. </p><br><p>  Of course, you can use tags in the version control system and <a href="https://en.wikipedia.org/wiki/Freeze_%2528software_engineering%2529">code-frieze</a> , but it is obvious that the tagging approach is not very different from the branching approach, at least because it complicates the initially simple scheme.  And the code-frieze, all the more, does not add speed to work, forcing all participants to stop development until stabilization and release calculations. </p><br><p>  So the <strong>first rule of good task decomposition</strong> is as follows: tasks should be broken down so that they fall into a common repository in the form of logically complete pieces that work by themselves and do not break the logic around them. </p><br><h3 id="feature-branches">  Feature branches </h3><br><p>  With all the variety of options for workflow in our company they have a common feature - they are all based on <a href="https://martinfowler.com/bliki/FeatureBranch.html">separate branches for features</a> .  This model allows us to work independently at different stages, to develop different features, without interfering with each other.  And we can test them and merge them into the general storage, only after making sure that they work and do not break anything. </p><br><p>  But this approach also has its drawbacks, based on the very nature of feature lobbies.  In the end, after isolation, the result of your work will need to be drained into a common place for everyone.  At this stage, you can overwhelm a lot of problems, ranging from merge conflicts and ending with very long testing / bug fixing.  After all, separating into your branch of code, you isolate not only the general storage from your changes, but also your code from changes from other developers.  As a result, when it comes time to merge their task into a common code, even if it is tested and working, ‚Äúdances with a tambourine‚Äù begin, because Vasya and Petya in their branches affected the same lines of code in the same files - conflict . </p><br><p>  Modern storage systems for code versions have a bunch of handy tools, <a href="https://git-scm.com/docs/merge-strategies">merge strategies,</a> and more.  But to avoid conflicts is still not possible.  And the more changes, the more flattering they are, the more difficult and longer these conflicts are to resolve. </p><br><p> Conflicts related to code logic are even more dangerous when SCM merges code without problems (because there are no conflicts in the lines in files), but due to the isolation of development, some common methods and functions in the code changed their behavior or were removed from the code altogether.  In compiled languages, the problem seems to be less acute - the compiler validates the code.  But the situation where the method signatures have not changed, and the logic has changed, has not been canceled.  Such problems are difficult to detect, and they further alienate the happy release and force them to retest the code many times after each merge.  And when there are a lot of developers, a lot of code, a lot of files and a lot of conflicts, everything turns into hell, because while we corrected the code and rechecked it, the main version of the code has already gone far ahead, and we need to repeat everything again.  Do you still not believe in unit tests?  Hehehehe! </p><br><p>  To avoid this, many are trying as often as possible to merge the results of general work into their branch.  But even the observance of this rule, if the feature layer is large enough, will not help to avoid problems, no matter how hard we try.  Because you are receiving someone else‚Äôs changes in your code, but <a href="https://blog.newrelic.com/2012/11/14/long-running-branches-considered-harmful/">no one sees</a> your changes <a href="https://blog.newrelic.com/2012/11/14/long-running-branches-considered-harmful/">.</a>  Accordingly, it is necessary not only to fill in someone else's code more often in your branch, but also your code in the general storage - as well. </p><br><p>  Hence, the <strong>second rule of good decomposition</strong> : feature bridges should contain as few changes as possible in order to get into the common code as soon as possible. </p><br><h3 id="parallelnaya-rabota">  Parallel work </h3><br><p>  Well, but how then to work in separate branches, if several programmers are working on the same task, divided into parts?  Or if they need changes in parts of the code common to different tasks?  Both Petya and Vasya use a common method, which in the framework of Petya's task should work according to one scenario, and in Vasya's task - according to another.  How to be? </p><br><p>  Here a lot depends on your release cycle, because we consider the moment of its completion in production as the moment of completion of the task.  After all, only this moment guarantees us that the code is stable and working.  If you did not have to roll back the changes from production, of course. </p><br><p>  If the release cycle is fast (several times a day you lay out on your servers), then it is quite possible to make the features dependent on each other in readiness stages.  In the example of Petya and Vasya, above we create not two tasks, but three.  Accordingly, the first one sounds like ‚Äúwe change the general method so that it works in two variants‚Äù (or we get a new method for Petit), and the other two tasks are the tasks of Vasya and Petit who can start work after the first task is completed without intersecting and without interfering with each other. </p><br><p>  If the release cycle does not allow you to lay out often, then the example described above will be an exorbitantly expensive pleasure, because then Vasya and Pete will have to wait days and weeks (and in some development cycles and a year) until they can start working on their tasks. </p><br><p>  In this case, you can use an intermediate branch, common to several developers, but still not stable enough to be laid out on production (Master or Trunk).  <a href="https://tech.badoo.com/ru/article/145/windows-phone-kak-eksperimentalnaya-platforma/">In our flow for mobile applications,</a> this branch is called Dev, in <a href="http://nvie.com/posts/a-successful-git-branching-model/">the</a> Vincent Driessen <a href="http://nvie.com/posts/a-successful-git-branching-model/">scheme</a> it is called develop. </p><br><p>  It is important to keep in mind that any change in the code, even the merging of branches, the injection of common branches into a stable Master, etc., must be tested (remember about conflicts by code and logic, right?).  Therefore, if you come to the conclusion that you need a common code branch, then you need to be ready for another testing stage - after the merge, you need to test how the feature integrates with another code, even if it has already been tested in a separate branch. </p><br><p>  Here you can notice that you can after all test only once - after the merger.  Why test before it, in a separate thread?  Right, you can.  But, if the task in the branch does not work or breaks the logic, this inefficient code will get into the general storage and not only will prevent colleagues from working on their tasks, breaking some parts of the product, it can also put a bomb, if there are wrong changes decides to base the new logic.  And when there are dozens of such tasks, it is very difficult to look for the source of the problem and fix the bugs. </p><br><p>  It is also important to understand that, even if we use an intermediate developmental code branch, which may not be the most stable, the tasks or their pieces in it should be more or less complete.  After all, we need to be released at some point.  And if in this thread the code of the features will break each other, then we will not be able to give everything - our product will not work.  Accordingly, after testing the integration of features, you need to fix bugs as soon as possible.  Otherwise, we get a situation similar to the one when using one branch for all. </p><br><p>  Therefore, we have the <strong>third rule of good decomposition</strong> : the tasks should be divided so that they can be developed and released in parallel. </p><br><h3 id="feature-flags">  Feature flags </h3><br><p>  But what about the situation when a new change in business logic is a big one?  Only programming such a task can take several days (weeks, months).  Let's not we merge unfinished pieces of features into the common storage? </p><br><p>  And here we will be!  There is nothing wrong with that.  An approach that can be applied in this situation is <a href="https://martinfowler.com/articles/feature-toggles.html">feature flags</a> .  It is based on the introduction of ‚Äúswitches‚Äù (or ‚Äúflags‚Äù) into the code, which enable / disable the behavior of a certain feature.  By the way, the approach does not depend on your branch model and can be used in any of the possible. </p><br><p>  A simple and understandable analogue can be, for example, a menu item for a new page in an application.  While the new page is being developed piece by piece, the menu item is not added.  But as soon as we‚Äôve finished everything and put it together, we add a menu item.  The same with the featureflag: we wrap the new logic in the condition of flag inclusion and change the behavior of the code depending on it. </p><br><p>  The last task in the process of developing a new big feature in this case will be the task ‚Äúenable featureflag‚Äù (or ‚Äúadd a menu item‚Äù in the example with a new page). </p><br><p>  The only thing you need to keep in mind when using featureflags is an increase in feature testing time.  After all, the product must be tested twice: with the feature set turned on and off.  You can save money here, but you should act extremely delicately: for example, test only the state of the flag, which is laid out to the user.  Then, during the development process (and the calculations in parts), the tasks will not be tested at all, but will be tested only during the verification of the last task ‚Äúenable feature flag‚Äù.  But here we must be prepared for the fact that the integration of the pieces of the feature after the flag is turned on may go away with problems: bugs may appear that were allowed in the early stages, and in this case, finding the source of the problem and eliminating errors can be costly. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  So, when decomposing tasks, it is important to remember three simple rules: </p><br><ol><li>  Tasks should be in the form of logically complete pieces of code. </li><li>  These pieces of code should be small and should fall into the common code as quickly as possible. </li><li>  These pieces should be developed in parallel and laid out independently of each other. </li></ol><br><p>  Where is easier?  By the way, the independent calculation, in my opinion, is the most important criterion.  One way or another, other points flow from it. </p><br><p>  I wish you good luck in developing new features! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/335254/">https://habr.com/ru/post/335254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335244/index.html">A practical guide to using CSS Modules in React applications</a></li>
<li><a href="../335246/index.html">The client is at the helm, or why should the provider give the wheel</a></li>
<li><a href="../335248/index.html">Math Detective: Finding Positive Whole Solutions to an Equation</a></li>
<li><a href="../335250/index.html">Two-factor authentication with Check Point Security Gateway</a></li>
<li><a href="../335252/index.html">A social network for film fans or how not to dig in, developing another social network</a></li>
<li><a href="../335256/index.html">Multiprotocol NAS access to Netapp resources with ACLs</a></li>
<li><a href="../335260/index.html">What happens at the junction of the database and operating system?</a></li>
<li><a href="../335262/index.html">How to avoid mistakes when changing CRM</a></li>
<li><a href="../335264/index.html">Digitalization and what kind of beast</a></li>
<li><a href="../335266/index.html">Materialize the search results, or how we released 25 processor cores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>