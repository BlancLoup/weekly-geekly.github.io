<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Avl-trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If in one of my past posts we talked about a fairly modern approach to building balanced search trees, this post is devoted to the implementation of A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Avl-trees</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/7d2/ec2/114/7d2ec21142aefa93984a3d14391572ef.jpg" align="right">  If in <a href="http://habrahabr.ru/post/145388/" title="Randomized search trees">one</a> of my past posts we talked about a fairly modern approach to building balanced search trees, this post is devoted to the implementation of <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%2592%25D0%259B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE" title="AVL-tree (Wikipedia)">AVL-trees</a> - probably the very first kind of balanced binary search trees that were <a href="http://www.math.spbu.ru/user/jvr/DA_html/add_1_15_avl_hist.html" title="History of the discovery of the AVL-tree">invented</a> in 1962 by our (then Soviet) scientists Adelson -Welsky and Landis.  You can find many implementations of AVL-trees (for example, <a href="http://www.stanford.edu/~blp/avl/" title="GNU libavl">here</a> ) in the network, but everything that I personally saw does not inspire much optimism, especially if you try to figure everything out from scratch.  Everywhere it is argued that AVL-trees are simpler than <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE-%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE" title="Red-black trees (Wikipedia)">red-black trees</a> , but looking at the <a href="">code</a> attached to this, you begin to doubt this statement.  Actually, the desire to explain on the fingers how the AVL-trees are arranged was the motivation for writing this post.  The presentation is illustrated with C ++ code. <br><br><a name="habracut"></a><br><br><h1>  The concept of the AVL-tree </h1><br><img src="https://habrastorage.org/storage2/361/64a/a86/36164aa86adb86997a04077b05407f13.png" align="left">  AVL-tree is first of all a binary search tree, the keys of which satisfy the standard property: the key of any node in the tree is not less than any key in the left subtree of this node and not more than any key in the right subtree of this node.  This means that you can use a standard algorithm to find the desired key in the AVL tree.  For simplicity, further presentation will assume that all keys in the tree are integer and not repeated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A feature of the AVL-tree is that it is balanced in the following sense: <em>for any tree node, the height of its right subtree differs from the height of the left subtree by no more than one</em> .  It is proved that this property is sufficient for the tree height to logarithmically depend on the number of its nodes: the height h of the AVL-tree with n keys lies in the range from log <sub>2</sub> (n + 1) to 1.44 log <sub>2</sub> (n + 2) - 0.328.  And since the basic operations on binary search trees (search, insertion and deletion of nodes) linearly depend on its height, we obtain a <i>guaranteed</i> logarithmic dependence of the operation time of these algorithms on the number of keys stored in the tree.  Recall that randomized search trees provide a balance only in a probabilistic sense: the probability of obtaining a highly unbalanced tree for large n, although negligible, remains <i>nonzero</i> . <br><br><h1>  Node structure </h1><br>  We will represent nodes of the AVL-tree with the following structure: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> //      </span></span>{ int key; unsigned char height; node* <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>; node* <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>; node(int k) { key = k; <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; height = <span class="hljs-number"><span class="hljs-number">1</span></span>; } };</code> </pre> <br>  The key field stores the node key, the height field is the height of the subtree with the root in this node, the left and right fields are pointers to the left and right subtrees.  A simple constructor creates a new node (height 1) with the given key k. <br><br>  Traditionally, the AVL-tree nodes store not the height, but the difference in the heights of the right and left subtrees (the so-called balance factor), which can take only three values ‚Äã‚Äã-1, 0 and 1. However, note that this difference is still stored in a variable the size of which is equal to at least one byte (if you do not invent any tricky schemes for ‚Äúefficient‚Äù packaging of such quantities).  Recall that the height h &lt;1.44 log <sub>2</sub> (n + 2), this means, for example, that with n = 10 <sup>9</sup> (one billion keys, more than 10 gigabytes of memory for storing nodes), the tree height will not exceed the value h = 44, which success is placed in the same one byte of memory as the balance factor.  Thus, the storage of heights on the one hand does not increase the amount of memory allocated for tree nodes, but on the other hand it significantly simplifies the implementation of some operations. <br><br>  We define three helper functions related to height.  The first one is a wrapper for the height field, it can work with null pointers (with empty trees): <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p?p-&gt;height:<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The second one calculates the balance factor of the specified node (and works only with non-zero pointers): <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> bfactor(node* p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height(p-&gt;right)-height(p-&gt;left); }</code> </pre><br>  The third function restores the correct value of the height field of the specified node (provided that the values ‚Äã‚Äãof this field in the right and left child nodes are correct): <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixheight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hl = height(p-&gt;left); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hr = height(p-&gt;right); p-&gt;height = (hl&gt;hr?hl:hr)+<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Note that all three functions are non-recursive, i.e.  their operation time is O (1). <br><br><h1>  Node balancing </h1><br>  In the process of adding or removing nodes in the AVL-tree, a situation may arise when the balance factor of some nodes is 2 or -2, i.e.  <em>unbalance</em> occurs subtree.  To correct the situation, we apply well-known turns around those or other tree nodes.  Let me remind you that a simple turn to the right (left) produces the following tree transformation: <br><br><img src="https://habrastorage.org/storage2/08e/55b/834/08e55b834b268b34eea7cb787094bd57.png"><br><br>  The code that implements the right rotation looks like this (as usual, every function that changes a tree returns a new root of the resulting tree): <br><br><pre> <code class="hljs erlang-repl">node* rotateright(node* p) //    p { node* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; fixheight(p); fixheight(q); return q; }</code> </pre><br>  The left turn is a symmetrical copy of the right: <br><br><pre> <code class="hljs perl">node* rotateleft(node* <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>) //    <span class="hljs-string"><span class="hljs-string">q { node* p = q-&gt;right; q-&gt;right = p-&gt;left; p-&gt;left = q; fixheight(q); fixheight(p); return p; }</span></span></code> </pre><br>  Let us now consider the situation of imbalance, when the height of the right subtree of the node p is 2 more than the height of the left subtree (the opposite case is symmetric and is implemented similarly).  Let q be the right child of a node p, and s be the left child of a node q. <br><br><img src="https://habrastorage.org/storage2/4cd/c19/f93/4cdc19f93548e73fe0d798242e572b5a.jpg"><br><br>  An analysis of possible cases within the framework of this situation shows that to correct the unbalance in the node p, it suffices to perform either a simple turn to the left around p, or a so-called <em>large turn to the</em> left around the same p.  A simple rotation is performed under the condition that the height of the left subtree of the node q is greater than the height of its right subtree: h (s) ‚â§h (D). <br><br><img src="https://habrastorage.org/storage2/db3/d40/92e/db3d4092eb12071f8b5498df0293b86c.jpg"><br><br>  A large rotation is applied under the condition h (s)&gt; h (D) and in this case it reduces to two simple ones ‚Äî first, a right rotation around q and then a left one around p. <br><br><img src="https://habrastorage.org/storage2/ffc/d49/2b6/ffcd492b6cc7252ecadd02bd30824f4c.jpg"><br><br>  The code that performs the balancing is reduced to checking the conditions and making turns: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span>* balance(node* p) //   p { fixheight(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p)==<span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p-&gt;right) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) p-&gt;right = rotateright(p-&gt;right); return rotateleft(p); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p)==<span class="hljs-number"><span class="hljs-number">-2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p-&gt;left) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) p-&gt;left = rotateleft(p-&gt;left); return rotateright(p); } return p; //    }</code> </pre><br>  The described functions of turns and balancing also do not contain either cycles or recursion, and therefore they are executed in a constant time independent of the size of the AVL-tree. <br><br><h1>  Insert keys </h1><br>  Inserting a new key into the AVL-tree is performed, by and large, just as it is done in simple search trees: we go down the tree, choosing the right or left direction of motion depending on the result of comparing the key in the current node and the key being inserted.  The only difference is that when returning from recursion (that is, after the key is inserted in either the right or left subtree, and this tree is balanced), the current node is balanced.  It is strictly proved that the imbalance arising from such an insertion in any node along the path of movement does not exceed two, and therefore the application of the above described balancing function is correct. <br><br><pre> <code class="hljs pgsql">node* <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(node* p, <span class="hljs-type"><span class="hljs-type">int</span></span> k) //   k     p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> node(k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k&lt;p-&gt;key ) p-&gt;left = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> p-&gt;right = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(p-&gt;right,k); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balance(p); }</code> </pre><br>  In order to verify the compliance of the implemented insertion algorithm with the theoretical estimates for the height of AVL trees, a simple computational experiment was carried out.  An array of randomly arranged numbers from 1 to 10,000 was generated, then these numbers were sequentially inserted into the initially empty AVL-tree and the tree height was measured after each insertion.  The results were averaged over 1000 calculations.  The following graph shows the dependence on n of the average height (red line);  minimum height (green line);  maximum height (blue line).  In addition, the upper and lower theoretical estimates are shown. <br><br><img src="https://habrastorage.org/storage2/f39/c05/4d2/f39c054d2075c8d0c04174c469252e4d.jpg"><br><br>  It can be seen that for random key sequences, the experimentally found heights fall into the theoretical limits even with a small margin.  The lower limit is reachable (at least at some points) if the original key sequence is ordered in ascending order. <br><br><h1>  Deleting keys </h1><br>  With the removal of nodes from the AVL-tree, unfortunately, everything is not as chocolate as with randomized search trees.  The method based on the merging (join) of two trees was neither possible to find nor invent. <img src="https://habrastorage.org/storage2/675/c7e/aa8/675c7eaa8e279c969f6f896d4a08a7b6.jpg" align="right">  Therefore, the variant described almost everywhere was taken as a basis (and which is usually used when removing nodes from the standard binary search tree).  The idea is as follows: we find a node p with a given key k (if we don‚Äôt find it, then nothing needs to be done), in the right subtree we find the min node with the smallest key and replace the deleted node p with the found min node. <br><br>  When implementing there are several nuances.  First of all, if the found node p does not have a right subtree, then by the property of the AVL-tree on the left this node can have only one child node (tree of height 1), or the node p can be a leaf in general.  In both of these cases, you simply need to remove the node p and return the pointer to the left child node of the node p as the result. <br><br>  Suppose now that p has a right subtree.  Find the minimum key in this subtree.  By the property of the binary search tree, this key is located at the end of the left branch, starting from the root of the tree.  Apply the recursive function: <br><br><pre> <code class="hljs erlang-repl">node* findmin(node* p) //        p { return p-&gt;left?findmin(p-&gt;left):p; }</code> </pre><br>  Another service function will be to remove the minimum element from the specified tree.  Again, by the property of the AVL-tree at the minimum element on the right, either a single node is suspended or empty.  In both cases, you just need to return the pointer to the right node and perform a balancing on the way back (when returning from recursion).  The minimal node itself is not deleted, since  he is still useful to us. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span>* removemin(node* p) //        p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( p-&gt;left==<span class="hljs-number"><span class="hljs-number">0</span></span> ) return p-&gt;right; p-&gt;left = removemin(p-&gt;left); return balance(p); }</code> </pre><br>  Now everything is ready to implement the removal of the key from the AVL-tree.  First, we find the desired node, performing the same actions as when inserting the key: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span>* remove(node* p, int k) //   k   p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) return <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k &lt; p-&gt;key ) p-&gt;left = remove(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k &gt; p-&gt;key ) p-&gt;right = remove(p-&gt;right,k);</code> </pre><br>  Once the key k is found, go to Plan B: remember the roots q and r of the left and right subtrees of the node p;  delete the node p;  if the right subtree is empty, then return a pointer to the left subtree;  if the right subtree is not empty, then we find the minimal element min there, then we extract it from there, on the left we suspend q and on the right we get what came out of r, we return min after balancing it. <br><br><pre> <code class="hljs lua"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // k == p-&gt;key { node* q = p-&gt;left; node* r = p-&gt;right; delete p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !r ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> q; node* <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> = findmin(r); <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>-&gt;right = removemin(r); <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>-&gt;left = q; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balance(<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>); }</code> </pre><br>  When you exit the recursion do not forget to perform balancing: <br><br><pre> <code class="hljs lisp"> return balance(<span class="hljs-name"><span class="hljs-name">p</span></span>)<span class="hljs-comment"><span class="hljs-comment">; }</span></span></code> </pre><br>  That's all!  The search for the minimum node and its extraction, in principle, can be implemented in one function, while having to solve (not very difficult) problem with returning a pair of pointers from the function.  But you can save on a single pass on the right subtree. <br><br>  Obviously, the insertion and deletion operations (as well as a simpler search operation) are performed in a time proportional to the height of the tree, since  in the process of performing these operations, a descent is made from the root to a given node, and at each level some fixed number of actions are performed.  And due to the fact that the AVL-tree is balanced, its height depends logarithmically on the number of nodes.  Thus, the execution time of all three basic operations is guaranteed logarithmically dependent on the number of tree nodes. <br><br>  Thank you all for your attention! <br><br><div class="spoiler">  <b class="spoiler_title">All code</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">struct</span></span> node //      { int key; unsigned char height; node* left; node* right; node(int k) { key = k; left = right = <span class="hljs-number"><span class="hljs-number">0</span></span>; height = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }; unsigned char height(node* p) { return p?p-&gt;height:<span class="hljs-number"><span class="hljs-number">0</span></span>; } int bfactor(node* p) { return height(p-&gt;right)-height(p-&gt;left); } void fixheight(node* p) { unsigned char hl = height(p-&gt;left); unsigned char hr = height(p-&gt;right); p-&gt;height = (hl&gt;hr?hl:hr)+<span class="hljs-number"><span class="hljs-number">1</span></span>; } node* rotateright(node* p) //    p { node* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; fixheight(p); fixheight(q); return q; } node* rotateleft(node* q) //    q { node* p = q-&gt;right; q-&gt;right = p-&gt;left; p-&gt;left = q; fixheight(q); fixheight(p); return p; } node* balance(node* p) //   p { fixheight(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p)==<span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p-&gt;right) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) p-&gt;right = rotateright(p-&gt;right); return rotateleft(p); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p)==<span class="hljs-number"><span class="hljs-number">-2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( bfactor(p-&gt;left) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) p-&gt;left = rotateleft(p-&gt;left); return rotateright(p); } return p; //    } node* insert(node* p, int k) //   k     p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) return new node(k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k&lt;p-&gt;key ) p-&gt;left = insert(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> p-&gt;right = insert(p-&gt;right,k); return balance(p); } node* findmin(node* p) //        p { return p-&gt;left?findmin(p-&gt;left):p; } node* removemin(node* p) //        p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( p-&gt;left==<span class="hljs-number"><span class="hljs-number">0</span></span> ) return p-&gt;right; p-&gt;left = removemin(p-&gt;left); return balance(p); } node* remove(node* p, int k) //   k   p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) return <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k &lt; p-&gt;key ) p-&gt;left = remove(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k &gt; p-&gt;key ) p-&gt;right = remove(p-&gt;right,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // k == p-&gt;key { node* q = p-&gt;left; node* r = p-&gt;right; delete p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !r ) return q; node* min = findmin(r); min-&gt;right = removemin(r); min-&gt;left = q; return balance(min); } return balance(p); }</code> </pre><br></div></div><br><br><h1>  Sources </h1><br><ul><li>  B. Pfaff, <em>Analogue</em> to Binary Search Trees and Balanced Trees - <em>libavl library description</em> </li><li>  N. Wirth, Algorithms and Data Structures - <em>Balanced Virtual trees are just AVL-trees</em> </li><li>  T. Kormen et al., Algorithms: construction and analysis - <em>about AVL-trees it is said in the exercises for the chapter about red-black trees</em> </li><li>  D. Knut, The Art of Programming - <em>section 6.2.3 is devoted to the theoretical analysis of AVL-trees</em> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/150732/">https://habr.com/ru/post/150732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150726/index.html">CAD: all arbitration courts of Russia in one Android device</a></li>
<li><a href="../150727/index.html">Internet Explorer 7-9: Choosing Tools for Maximum CSS3, HTML5 Support</a></li>
<li><a href="../150728/index.html">Acceleration 3.7 times after removing Sleep () in WebKit</a></li>
<li><a href="../150729/index.html">Surface review of javascript-enabled BaaS platforms</a></li>
<li><a href="../150730/index.html">"It is difficult about the simple." JS data types. In search of the truth of primitives and objects</a></li>
<li><a href="../150734/index.html">RailsClub'Moscow 2012. Interview with Steve Klabnik</a></li>
<li><a href="../150735/index.html">Up to 50% off on all JetBrains products</a></li>
<li><a href="../150736/index.html">The correct calculation for VDI (part 2)</a></li>
<li><a href="../150737/index.html">RailsClub'Moscow 2012. Interview with Xavier Noria (Xavier Noria)</a></li>
<li><a href="../150738/index.html">The main thing is the context!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>