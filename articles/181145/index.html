<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ActiveRecord Hacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I will share my set of not always obvious features and features of Active Record that I encountered during the development of Ruby on Rails appl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ActiveRecord Hacks</h1><div class="post__text post__text-html js-mediator-article">  Today I will share my set of not always obvious features and features of Active Record that I encountered during the development of Ruby on Rails applications or found in other people's blogs. <br><br><a name="habracut"></a><br><br>  <b>Validation bypass when using update_attributes</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The standard update_attributes method does not have a key to bypass validation, so you have to resort to assign_attributes followed by save <br><br><pre><code class="ruby hljs">@user = User.find(params[<span class="hljs-symbol"><span class="hljs-symbol">:id</span></span>]) @user.assign_attributes(<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) @user.save(<span class="hljs-symbol"><span class="hljs-symbol">validate:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><br>  Of course - it is better not to resort to this method very often :) <br><br>  <b>Division into 2 non-intersecting collections</b> <br><br>  Sometimes there is the task of dividing the selection of objects into 2 non-intersecting collections.  You can do this by using this scope. <br><br><pre> <code class="ruby hljs">Article &lt; ActiveRecord::Base scope <span class="hljs-symbol"><span class="hljs-symbol">:unchecked</span></span>, where(<span class="hljs-symbol"><span class="hljs-symbol">:checked</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">#or this, apologies for somewhat unefficient, but you already seem to have several queries scope :unchecked2, lambda { |checked| where(["id not in (?)", checked.pluck(:id)]) } end</span></span></code> </pre><br><br>  Well, accordingly, access to both collections can be obtained by <br><br><pre> <code class="ruby hljs">Article.unchecked Article.unchecked2(@unchecked_articles)</code> </pre><br><br>  <b>pluck</b> <br><br>  In the previous example, I used the pluck method.  Surely each of you used something like <br><br><pre> <code class="ruby hljs">Article.all.select(<span class="hljs-symbol"><span class="hljs-symbol">:title</span></span>).map(&amp;<span class="hljs-symbol"><span class="hljs-symbol">:title</span></span>)</code> </pre><br><br>  or even <br><br><pre> <code class="ruby hljs">Article.all.map(&amp;<span class="hljs-symbol"><span class="hljs-symbol">:title</span></span>)</code> </pre> <br><br>  So - pluck makes it easier <br><br><pre> <code class="ruby hljs">Article.all.pluck(<span class="hljs-symbol"><span class="hljs-symbol">:title</span></span>)</code> </pre> <br><br>  <b>Access to the base class</b> <br><br>  In the process of working on one project, I was faced with a great nesting of classes of models and the need to get to the root class.  The classes looked like this: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Art</span></span></span><span class="hljs-class"> &lt; ActiveRecord::Base </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Picture</span></span></span><span class="hljs-class"> &lt; Art </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlainPicture</span></span></span><span class="hljs-class"> &lt; Picture </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><br>  In order to get from PlainPicture to Art you can use the method becomes <br><br><pre> <code class="ruby hljs">@plain_pictures = PlainPicture.all @plain_pictures.map { <span class="hljs-params"><span class="hljs-params">|i|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> &lt; Art <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> i.becomes(Art) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> }.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|pp|</span></span> <span class="hljs-comment"><span class="hljs-comment">#do something with Art end</span></span></code> </pre> <br><br>  <b>first_or_create and first_or_initialize</b> <br><br>  Another great method is first_or_create.  From the title it is clear what he does, and we let's see how it can be used <br><br><pre> <code class="ruby hljs">Art.where(<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">"Black square"</span></span>).first_or_create</code> </pre> <br><br>  We can also use it in block construction. <br><br><pre> <code class="ruby hljs">Art.where(<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">"Black square"</span></span>).first_or_create <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|art|</span></span> art.author = <span class="hljs-string"><span class="hljs-string">"Malevich"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br>  And if you do not want to save - you can use first_or_initialize for example in this way <br><br><pre> <code class="ruby hljs">@art = Art.where(<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">"Black square"</span></span>).first_or_initialize</code> </pre> <br><br>  <b>scoped and none</b> <b><br></b> <br>  Pay attention to 2 more remarkable methods - scoped and none.  How they work - I will show by example, but I want to note that it is necessary to separate their behavior in rails3 and rails4, since it differs. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filter_name)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> filter_name <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:all</span></span> scoped <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:published</span></span> where(<span class="hljs-symbol"><span class="hljs-symbol">:published</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:unpublished</span></span> where(<span class="hljs-symbol"><span class="hljs-symbol">:published</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> none <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br>  How the method behaves if it is transferred to it: published and: unpublished. I hope you understand it, there are no differences in the rails versions. <br><br>  Using scoped in our example in the case of rails3 allows you to create an anonymous skop that can be used for complex compound queries.  If you try to apply it in rails4, you can see the message that the method has become deprecated and it is proposed to use Model.all instead.  In the case of rails3, Model.all returns not ActiveRecord :: Relation expected by us, but Array. <br><br>  The situation with none is similar to scoped exactly the opposite :) This method returns an empty ActiveRecord :: Relation, but it works only in rails4.  It is needed if you need to return zero results. For use in rails3 there is such a workaround: <br><br><pre> <code class="ruby hljs">scope <span class="hljs-symbol"><span class="hljs-symbol">:none</span></span>, where(<span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).where(<span class="hljs-string"><span class="hljs-string">"id IS NOT ?"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><br>  or even such (for example in initializer) <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActiveRecord::Base</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">none</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arel_table</span></span></span><span class="hljs-class">[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eq</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nil</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">and</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arel_table</span></span></span><span class="hljs-class">[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not_eq</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nil</span></span></span><span class="hljs-class">))) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><br>  <b>find_each</b> <br><br>  The find_each method is very convenient in order to process a large number of records from the database.  One could of course make a sample of <br><br><pre> <code class="ruby hljs">Article.where(<span class="hljs-symbol"><span class="hljs-symbol">published:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>).each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|article|</span></span> <span class="hljs-comment"><span class="hljs-comment">#do something end</span></span></code> </pre> <br><br>  But in this case we will have to keep the entire sample in memory in its entirety, which is very unprofitable in the case of a large amount of data.  In this case, it would be better to use this approach. <br><br><pre> <code class="ruby hljs">Article.where(<span class="hljs-symbol"><span class="hljs-symbol">published:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>).find_each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|article|</span></span> <span class="hljs-comment"><span class="hljs-comment">#do something end</span></span></code> </pre> <br><br>  which in small samples (1000 objects at a time by default) processes the data. <br><br>  <b>to_sql and explain</b> <br><br>  Two methods to help you figure out how your query works. <br><br><pre> <code class="ruby hljs">Art.joins(<span class="hljs-symbol"><span class="hljs-symbol">:user</span></span>).to_sql</code> </pre> <br><br>  will return to you the sql query that the application will compile for asking for a database, and <br><br><pre> <code class="ruby hljs">Art.joins(<span class="hljs-symbol"><span class="hljs-symbol">:user</span></span>).explain</code> </pre> <br><br>  will show technical information on request - approximate amount of time, sample size and other data. <br><br>  <b>scoping</b> <br><br>  This method allows you to make a sample within the sample, for example <br><br><pre> <code class="ruby hljs">Article.where(<span class="hljs-symbol"><span class="hljs-symbol">published:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>).scoping <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Article.first <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br>  will request type <br><br><pre> <code class="ruby hljs">SELECT * FROM articles WHERE published = <span class="hljs-literal"><span class="hljs-literal">true</span></span> LIMIT <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br>  <b>merge</b> <br><br>  Another interesting method that allows you to cross several samples.  for example <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Account</span></span></span><span class="hljs-class"> &lt; ActiveRecord::Base </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># ... # Returns all the accounts that have unread messages. def self.with_unread_messages joins(:messages).merge( Message.unread ) end end</span></span></span></span></code> </pre> <br><br>  allows you to make a selection of all accounts in which there are unread messages. </div><p>Source: <a href="https://habr.com/ru/post/181145/">https://habr.com/ru/post/181145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181127/index.html">All work Curiosity (281 sol) for 1 minute (video)</a></li>
<li><a href="../181131/index.html">New HTML5 Visual ZEN-components in Cach√© 2013.2 DBMS</a></li>
<li><a href="../181137/index.html">Life hacking from TeamLab Office 7.4</a></li>
<li><a href="../181139/index.html">Matternet wants to create a future transportation network</a></li>
<li><a href="../181143/index.html">Searchlight past events ‚Ññ3</a></li>
<li><a href="../181147/index.html">Do not do as I do. Or about your future job</a></li>
<li><a href="../181151/index.html">The algorithm of the game "sea battle": the shelling of the enemy</a></li>
<li><a href="../181159/index.html">Device of points of virtual reality Oculus Rift</a></li>
<li><a href="../181161/index.html">The new technology of noise reduction allows you to transfer 400 Gb / s over fiber for 12,800 km without signal repeaters</a></li>
<li><a href="../181165/index.html">Robotic Data Center of the Future</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>