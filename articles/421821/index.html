<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We apply Voronoi mosaic, pixelation and geometric masks in shaders to decorate the site</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a logical continuation of the introduction to programming shaders for web designers . In it, we made a template for creating various t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We apply Voronoi mosaic, pixelation and geometric masks in shaders to decorate the site</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="image"><br><br><p>  This article is a logical continuation of the <a href="https://habr.com/post/420847/">introduction to programming shaders for web designers</a> .  In it, we made a template for creating various two-dimensional effects with photos using shaders and looked at a couple of examples.  In this article, we will add a couple more textures, apply Voronoi splitting to create a mosaic of them, talk about creating different masks in shaders, pixelation, and also address some of the problems of the ancient GLSL syntax that still exists in our browsers. </p><br><p>  Just as last time, there will be a minimum of theory and a maximum of practice and reasoning in a mundane everyday language.  Beginners will find here a sequence of actions with tips and helpful comments, and experienced front-tenders will probably find a couple of ideas for inspiration. </p><a name="habracut"></a><br><p>  <em>A survey in a previous article showed that the topic of WebGL effects for sites may be of interest not only to the layout designers, but also to our colleagues of other specializations.</em>  <em>In order not to be puzzled by the latest ES chips, we intentionally confine ourselves to more traditional syntactic constructions that everyone can understand.</em>  <em>And again I draw readers' attention to the fact that CodePen‚Äôs built-in editors affect the performance of what is being done in them.</em> </p><br><p>  But let's start ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Template for working with shaders </h2><br><p>  For those who have not read the previous article - we have made the following template for working with shaders: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  It creates a plane (in our case, a square) on which the picture-texture is drawn.  No extra dependencies and a very simple vertex shader.  Then we developed this pattern, but now we will start from the moment when there is no logic in the fragment shader yet. </p><br><h2 id="mozaika">  Mosaic </h2><br><p>  Mosaic is a plane broken into small areas, where each of the areas is filled with a certain color or, as in our case, a texture.  How can we even break our plane into pieces?  Obviously, you can break it into rectangles.  But this is so easy to do with the help of SVG, to drag WebGL into this task and to lay everything out of the blue to absolutely nothing. </p><br><p>  For a mosaic to be interesting, there must be different fragments in it, both in shape and in size.  There is one very simple, but at the same time very entertaining approach to building such a partition.  It is known as the Voronoi mosaic or the Dirichlet partition, and on Wikipedia it is written that Descartes used something similar back in the distant XVII century.  The idea is something like this: </p><br><ul><li>  Take a set of points on the plane. </li><li>  For each point on the plane, find the point closest to it from this set. </li><li>  Actually that's all.  The plane is divided into polygonal regions, each of which is defined by one of the points of the set. </li></ul><br><p>  Probably better show this process with a practical example.  There are different algorithms for generating this partition, but we will act on the forehead, because calculating something for each point on the plane is just the task for the shader.  First we need to make a set of random points.  In order not to load the code of the examples we will make a global variable for them. </p><br><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(), <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()]); } }</code> </pre> <br><p>  Now we need to transfer them to the shaders.  The data is global, so we will use the <code>uniform</code> modifier.  But there is one subtle point: we simply cannot pass on an array.  It would seem that the 21st century is in the courtyard, but still nothing will come of it.  As a result, you have to transfer an array of points one by one. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Today we will not once encounter such problems of inconsistency between what is expected and what is in real browsers.  Typically, WebGL lessons use THREE.js and this library hides some of the dirt in itself, as jQuery once did in its tasks, but if it is removed, the reality hurts the brain. </p><br><p>  In the fragment shader, we have an array variable for points.  We can create only fixed-length arrays.  Let it start with 10 points: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Make sure in the performance of all this by drawing circles on the ground points.  Such drawing of various geometric primitives is often used for debugging - they can be clearly seen and you can immediately understand what is and where it is going. </p><br><blockquote>  Use the "drawing" circles, direct and other landmarks for invisible objects on which animations are built.  This will give obvious clues about how they work, especially if the algorithms are difficult to quickly understand without prior preparation.  Then all this can be commented out and left for colleagues - they will say thank you. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Good.  Let's also add a little movement to the points.  Let them move in a circle to begin with, we will return to this issue later.  The coefficients are also set by the eye, just to slow down their movement a bit and reduce the amplitude of oscillations. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; NUMBER_OF_POINTS; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">POINTS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[0]</span></span></span><span class="hljs-function"> += </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i * timeStamp / 5000.0)</span></span></span><span class="hljs-function"> / 500.0; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">POINTS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[1]</span></span></span><span class="hljs-function"> += </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i * timeStamp / 5000.0)</span></span></span><span class="hljs-function"> / 500.0; } } }</span></span></code> </pre> <br><p>  We return to the shader.  For future experiments, we will need the numbers of areas into which everything is divided.  So we find the point from the set closest to the current pixel and save the number of this point - the same as the area number. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  To test the performance again, let's paint everything in bright colors: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  The combination of the module (abs) and limited functions (in particular, sin and cos) is often used when working with similar effects.  On the one hand, this adds a bit of randomness, but on the other hand, it immediately gives a normalized result from 0 to 1, which is very convenient - we have very many values ‚Äã‚Äãthat will lie within these limits. </blockquote><p>  We also find points that are more or less equidistant from several points from the set, and paint them.  This action does not carry much payload, but it's still interesting to look at the result. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  It should turn out something like this: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  This is still a draft version, we will continue to refine it.  But now the general concept of such a separation of the plane is clear. </p><br><h2 id="mozaika-iz-fotografiy">  Mosaic of photos </h2><br><p>  It is clear that in the pure form of the benefits of such a partition is not very much.  To expand the horizons and just for the sake of interest, you can play with it, but on a real site it would be worth adding a couple more photos and making a mosaic of them.  Let's alter the texture creation function a little to make it more than one. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Nothing out of the ordinary happened, we just replaced the zeros with the <code>index</code> parameter and reused the existing code to load three textures.  In the shader, we now have an array of textures: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Now we can use the region number saved earlier to select one of the three textures.  But... </p><br><p>  But before that I would like to make a small digression.  About sore.  About syntax.  Modern Javascript (conditionally ES6 +) is a nice language.  It allows you to express your thoughts as they arise, does not limit the scope of a particular programming paradigm, completes some points for us and allows us to focus more on the idea than on its implementation.  For the creator - the most it.  Some people think that it gives too much freedom and switch to TypeScript for example.  Pure C is a stricter language.  He also allows a lot, on it you can find anything you want, but after JS, he is perceived as a little awkward, old-fashioned or something.  Nevertheless, he is still good.  GLSL as it exists in browsers is just something.  Not only is it an order of magnitude stricter than C, it still lacks many familiar operators and syntactic constructs.  This is probably the biggest problem when writing more or less complex shaders for WebGL.  Behind the horror that the code turns into, it can be very difficult to look at the original algorithm.  Some layout designers think that until they have learned C, the way to shaders is closed for them.  So: knowledge of C here does not help.  Here is a world of its own.  The world of madness, dinosaurs and crutches. </p><br><p>  How can I choose one of three textures with one number - the area number.  The remainder of dividing the number by the number of textures comes to mind.  Great idea.  Only the operator <code>%</code> , which the hands themselves are already writing, is not here.  The impression of understanding this fact is well described by the picture: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="image"></p><br><p>  Of course, you will say "yes, not a problem, there is a <code>mod</code> function - let's take it!".  But it turns out that it does not accept two integers, only fractional ones.  Ok, well, make a <code>float</code> of them.  We get <code>float</code> too, but we need an <code>int</code> .  You have to convert everything back, otherwise there is a non-illusory chance to get an error when compiling. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  And here's a rhetorical question: maybe it would be easier to implement its remainder function from dividing integers, rather than trying to assemble it from standard methods?  And this is still a simple function, and it happens that very deeply nested sequences of such transformations are obtained, in which it is not quite clear what is happening. </p><br><p>  Okay, let's leave it as it is.  Just take the color of the desired pixel from the selected texture and assign it to the variable <code>gl_FragColor</code> .  So?  We have already done this?  And then this cat appears again.  You cannot use a non-constant when referring to an array.  And all that we have calculated is no longer a constant.  Ba-dum-tsss !!! </p><br><p>  You have to do something like this: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> if (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> if (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  Agree, this code direct road to <a href="https://govnokod.ru/">govnokod.ru</a> , but nevertheless in a different way.  Even the <code>switch-case</code> operator is not here to somehow improve this outrage.  There is a truth yet another, less obvious crutch, solving the same task: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Cycle counters that increment by one can be taken by the compiler as a constant.  But with an array of textures, this could not be done - in the last Chrome there was an error saying that it is impossible to do this with an array of textures.  With an array of numbers worked.  Guess why it works with one array, but not with the other?  If you thought that the type conversion system in JS is full of magic - sort out the "constant - not constant" system in GLSL.  The funniest thing here is that the results also depend on the video card used, so that the tricky crutches that worked on the NVIDIA video card may well break on AMD. </p><br><blockquote>  It is better to avoid such decisions based on assumptions about the operation of the compiler.  They tend to break down and are difficult to test. </blockquote><p>  Sadness, sadness.  But if we want to do interesting things, we need to abstract from all this and continue. </p><br><p>  At the moment we got a mosaic of photos.  But there is one detail: if the points are very close to each other, then there is a rapid transition of two areas.  It is not very beautiful.  We need to add some algorithm that does not allow the points to come closer.  You can make a simple option, which checks the distance between points and, if it is less than a certain value, then we push them apart.  This option is not without flaws, in particular, it sometimes leads to a slight twitching of points, but in many cases it can be enough, especially since the calculations here are not very much.  More advanced options would be a system of moving charges and a "web", in which pairs of points are connected by invisible springs.  If you are interested in implementing them, then you can easily find all the formulas in the reference book on physics for secondary school. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) { let deltaX = POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.<span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(deltaX); POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.<span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(deltaY); POINTS[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.<span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(deltaX); POINTS[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.<span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(deltaY); } } }</code> </pre> <br><p>  The main problem of this approach, as well as the one we used in the shader, is a comparison of all points with all.  You do not need to be a great mathematician to understand that the number of distance calculations will be incredible if we do not 10 points, but 1000. Yes, even 100 is enough for everything to slow down.  Therefore, it makes sense to apply it only for a small number of points. </p><br><p>  If we want to make such a mosaic for a large number of points, then we can use the already familiar to us division of the plane into identical squares.  The idea is to place a single point in each square, and then carry out all comparisons only with points from neighboring squares.  The idea is good, but experiments have shown that, with a large number of points, inexpensive laptops with integrated graphics cards still fail.  Therefore, it is worth thinking ten times before deciding to make on your website such a mosaic of a large number of fragments. </p><br><blockquote>  Do not be radishes, check the speed of their crafts, not only on your mining farm, but on ordinary laptops.  Most users will have them. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Splitting a plane into parts according to the function graph </h2><br><p>  Let's look at another option of dividing the plane into parts.  He will not require large computing power.  The basic idea is to take some mathematical function and plot it.  The resulting line will divide the plane into two parts.  If we use a function of the form <code>y = f(x)</code> , we get a division in the form of a cut.  Replacing X with Y, we can change the horizontal section to the vertical one.  If we take the function in polar coordinates, then it will be necessary to convert everything to Cartesian and vice versa, but the essence of the calculations will not change.  In this case, you will not get a cut into two parts, but rather cutting a hole.  But we will see the first option. </p><br><p>  For each Y, we will calculate the value of X to make a vertical cut.  We could take for this purpose a sine wave for example, but this is too boring.  It is better to take them at once a few pieces and lay down. </p><br><p>  We take several sinusoids, each of which is tied to the Y coordinate and time, and we add them.  Physicists would call such an addition a superposition.  Obviously, by multiplying the whole result by some number, we change the amplitude.  We take it out to a separate macro.  If you multiply the coordinate - the sine parameter, the frequency will change.  We have already seen this in the last article.  We also remove from the formula the frequency modifier common to all sinusoids.  It will not be superfluous to play with time, a negative sign will give the effect of moving the line in the opposite direction. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Having made such global settings for our function, we will encounter the problem of repeating the same movement at fairly short intervals.  In order to solve this question, we need to multiply everything by the coefficients, which have the smallest common multiple and a very large one.  Something similar is used in the random number generator, remember?  In this case, we did not think and took ready numbers from some example from the Internet, but no one bothers to experiment with their values. </p><br><p>  It remains only to choose one of two textures for points above our graph of the function and the second for points below it.  More precisely, to the left and to the right, we all turned: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  What we received is reminiscent of sound waves.  More precisely, their image on the oscilloscope.  And indeed, instead of our sine waves, we could transfer data from some sound file.  But working with sound is a topic for a separate article. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  Masks </h2><br><p>  The previous examples should push on quite a logical remark: it all looks like the work of masks in SVG (if you haven't worked with them - see examples from the <a href="https://habr.com/post/349362/">SVG mask</a> article <a href="https://habr.com/post/349362/">and wow effects</a> ).  Just here we do them a little differently.  As a result, the same is obtained - some areas are painted with one texture, some with another.  Only smooth transitions have not yet been.  So let's do one. </p><br><p>  We remove all unnecessary and return the coordinates of the mouse.  Make a radial gradient with the center at the cursor location and use it as a mask.  In this example, the behavior of the shader will more closely resemble the logic of the masks in the SVG than in the previous examples.  We need a <code>mix</code> function and some function of distance.  The first will mix the color values ‚Äã‚Äãof pixels from both textures, taking as a third parameter a coefficient (from 0 to 1), which determines which of the values ‚Äã‚Äãwill prevail in the result.  As a function of distance we take the sine modulus - it will just give a smooth change in the value between 0 and 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Actually that's all.  Let's look at the result: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  The main advantage over SVG is obvious: </p><br><blockquote>  In contrast to the SVG, here we can easily make smooth gradients for various mathematical functions, and not collect them from a variety of linear gradients. </blockquote><p>  If you have a simpler task that does not require such smooth transitions or complex shapes that are calculated in the process, then most likely it will be easier to implement without using shaders.  And the performance on a weak gland is likely to be better.  Choose a tool based on your tasks. </p><br><p>  For educational purposes, let's look at another example.  To begin with, we make a circle in which the texture will remain as it is: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  And all the rest is filled with diagonal stripes: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  All the same, we multiply the parameter for the sine to increase the frequency of the strips;  we divide the obtained values ‚Äã‚Äãinto two parts;  for each of the halves we convert the color of the pixels in our own way.  It is useful to remember that drawing diagonal lines is usually associated with adding coordinates along X and Y. Note that we all also use the distance to the mouse cursor when colors change, thereby creating a kind of shadow.  In the same way you can use it in geometric transformations, we will soon look at the example of pixelation.  In the meantime, take a look at the result of this shader: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Simple and cute. </p><br><blockquote>  And yes, if you get a little confused, you can make textures not from images, but from frames from video (there are many examples in the network, you can easily figure them out), and apply all our effects to them.  Many sites from directories like Awwwards use similar effects in combination with video. </blockquote><p>  One more thought to remember: </p><br><blockquote>  No one bothers to use one of the textures as a mask.  We can take a picture and use the color values ‚Äã‚Äãof its pixels in our transformations, be it changes of other colors, side shifts or something else that comes to your mind. </blockquote><p>  But back to breaking the plane into parts. </p><br><h2 id="pikselizaciya">  Pixelate </h2><br><p>  This effect is somewhat obvious, but at the same time it is so common that it would be wrong to pass by.  We divide our plane into squares, in the same way as in the example with the noise generator, and then for all pixels inside each square we set the same color.  It is obtained by mixing the values ‚Äã‚Äãfrom the corners of the square, we have already done something similar.  For this effect, we do not need complex formulas, so we simply add all the values ‚Äã‚Äãand divide by 4 - the number of corners of the square. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Again, we tied one of the parameters to time through the sine module in order to visually see what happens when it changes. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Pixel waves </h2><br><p>            ,       . </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p>   ,       0  1;        , ,    ,     .       ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      ‚Äî  .       . </p><br><h2 id="itogi">  Results </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/421821/">https://habr.com/ru/post/421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421809/index.html">Java EE Concurrency API</a></li>
<li><a href="../421811/index.html">IETF proposed a new standard for messaging - what you need to know</a></li>
<li><a href="../421815/index.html">Liquid metal in the laptop six months later</a></li>
<li><a href="../421817/index.html">Working with forms in React.js using basic tools</a></li>
<li><a href="../421819/index.html">ELK Stack for storing Django application logs</a></li>
<li><a href="../421823/index.html">As we in x-ray x64 delivered</a></li>
<li><a href="../421827/index.html">What to read about Java right now?</a></li>
<li><a href="../421829/index.html">Anomaly Frango - a fantastic novel with real people from IT</a></li>
<li><a href="../421833/index.html">We write our simplest program for ARM Cortex-M3</a></li>
<li><a href="../421835/index.html">Interdepartmental Commission is developing a new technology to block Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>