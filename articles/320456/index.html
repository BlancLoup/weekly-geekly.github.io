<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Uncomplicated SCRUM and Image Segmentation for Highlighting Post-it Stickers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""The inspiration I‚Äôve been looking for all morning 
 caught up in the most unfortunate moment. 
 And how to explain that I'm leaving for SCRUM? 
 - Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Uncomplicated SCRUM and Image Segmentation for Highlighting Post-it Stickers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fd2/bd3/dfb/fd2bd3dfb27e412bb89340ff59cedf43.png" alt="image" align="left"><br>  <i>"The inspiration I‚Äôve been looking for all morning</i> <i><br></i>  <i>caught up in the most unfortunate moment.</i> <i><br></i>  <i>And how to explain that I'm leaving for SCRUM?</i> <i><br></i>  <i>- Come with me ?!</i>  <i>"</i> <br><br><img src="https://habrastorage.org/files/28d/2a1/299/28d2a129949a4d09a64817d05fe2f9e5.jpg" alt="image" align="right">  Communication in a team is the dire need of big projects.  It should not look like a scaffold or compulsory assembly of alcoholics anonymous.  From the team you need to participate, you need a shine in the eyes, everyone should be torn from the desire to speak, as from the pathos of this proposal.  Gradually, our team evolved into a SCRUM model, thanks in large part to simple and intuitive stickers.  What kind of SCRUM without stickers?  Almost everyone had stickers in childhood and, somewhere deep in the subconscious, memories came to us, when we, as a child, were taught to glue by the teacher and, if the sticker was glued evenly, as a reward, it didn‚Äôt take it.  But even in our carefree childhood, we had to do things that seemed dull and incomprehensible to us ‚Äî to remove toys, to scrub a wall from a pen, or to write under dictation.  Having matured, we have a choice - we can shift the work to others.  And who wants to write backlog (report) for everyone and then transfer the data to Jira?  Using Jira directly in the rally process removes the participant from the discussion, therefore, after the adoption of the UN convention on the abolition of slavery, it remains to shift this task to the robots. <br><br>  As a result, the idea was born to write a program for recognizing and tracking task cards on the SCRUM board. <br><a name="habracut"></a><br>  Setting the minimum task is seen as: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  read the image of the SCRUM board; </li><li>  select stickers; </li><li>  save images of stickers; </li><li>  determine the area of ‚Äã‚Äãthe board where the stickers are located; </li><li>  determine which task the sticker belongs to; </li><li>  create a file with information about the status of tasks. </li></ul><br>  Actually, the task looks quite elegant and simple at the same time, and we offered it this year as an educational task during our summer school on programming.  This article proposes to consider the implementation of the first three requirements. <br><br>  With the digitization of the image of the board, the rule is simple - the last person to get up from a chair photographs the board.  In the future, it should be replaced by a robot. <br><br>  Below is a picture of what a simplified SCRUM board might look like.  Very simplified. <br><br><img src="https://habrastorage.org/files/7b9/d06/d2b/7b9d06d2bf8647cb9a37a5d05d267a49.jpg"><br>  <i>Fig.1.</i>  <i>Sample SCRUM-boards.</i> <br><br>  Stickers on top for unselected tasks, below the developer tasks area (blue, green and red).  The area of ‚Äã‚Äãeach developer is divided into two parts - on the left are the tasks that are performed, on the right - completed. <br><br><h3>  Segmentation </h3><br>  Let's start with the banalities - loading the original image with a photo of the board is done using OpenCV tools: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::Mat&gt; stickers; cv::<span class="hljs-function"><span class="hljs-function">CommandLineParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( argc, argv, keys )</span></span></span></span>; String image_path = parser.get&lt;String&gt;( <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( image_path.empty() ) { help(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } cv::Mat image = cv::imread(image_path);</code> </pre> <br>  To represent images in OpenCV, the class cv :: Mat is used.  This is an interesting data structure and you can find <a href="http://docs.opencv.org/3.0-rc1/d3/d63/classcv_1_1Mat.html/">some</a> details about this class. <br><br>  Next, you need the main function to highlight sticker images: <br><br><pre> <code class="cpp hljs"> recognizeStickers(stickers);</code> </pre> <br>  In the first version, we simply save the found stickers into files named sticker1.jpg ... stickerN.jpg: <br><br><pre> <code class="cpp hljs"> saveStickers(stickers); }</code> </pre> <br>  Let us consider in more detail the function of selecting images of stickers.  The function prototype may be: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recognizeStickers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cv::Mat&gt; &amp;stickers)</span></span></span></span>;</code> </pre> <br>  The algorithm for solving the problem of selecting contrast objects on a uniform background can be implemented in various ways: <br><br><ul><li>  Algorithm 1. Selecting objects (stickers) that have a specified color using the inRange function; </li><li>  Algorithm 2. Selection of bright objects (stickers) from the S-channel of an HSV image using the threshold function; </li></ul><br><h3>  Algorithm 1 </h3><br>  Selecting stickers with inRange can be as follows: <br><br><ul><li>  determine the range of colors characteristic of the sticker (in the first implementation, we define the range explicitly, by constants); </li><li>  highlight points whose color differs from the background color using stepwise conversion; </li><li>  using the filter to combine the points of the intended sticker to obtain a solid image; </li><li>  highlight the boundaries of continuous areas; </li><li>  define the boundaries vertically and horizontally for the groups of points of the supposed stickers. </li></ul><br>  Below is a rough sketch illustrating the idea of ‚Äã‚Äãthe algorithm: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recognizeStickersByRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cv::Mat image,</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cv::Mat&gt; &amp;stickers)</span></span></span><span class="hljs-function"> </span></span>{ cv::Mat imageHsv; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::Point&gt; &gt; contours; <span class="hljs-comment"><span class="hljs-comment">//   hsv,      cv::cvtColor(image, imageHsv, cv::COLOR_BGR2HSV); cv::Mat tmp_img(image.size(),CV_8U); //      cv::inRange(imageHsv, cv::Scalar(key_light-delta_light,key_sat-delta_sat,key_hue-delta_hue), cv::Scalar(key_light+delta_light,key_sat+delta_sat,key_hue+delta_hue), tmp_img); // ""      cv::dilate(tmp_img,tmp_img,cv::Mat(),cv::Point(-1,-1),3); cv::erode(tmp_img,tmp_img,cv::Mat(),cv::Point(-1,-1),1); //    cv::findContours(tmp_img,contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE); for (uint i = 0; i&lt;contours.size(); i++) { cv::Mat sticker; //      cv::Rect rect=cv::boundingRect(contours[i]); image(rect).copyTo(sticker); //     stickers.push_back(sticker); } }</span></span></code> </pre> <br>  After a stepwise transformation and stretching of the area using a filter to combine the areas separated by noise (the cv :: dilate method), we get: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a5a/479/d4e/a5a479d4ed73453a834bb13c528eb555.jpg"></div><br>  <i>Fig.2.</i>  <i>Image after binarization.</i> <br><br>  Send the binarized image to the input of the contour extraction algorithm v :: findConturs and for each contour we find the bounding rectangle with the help of cv :: boundingRect.  For clarity, draw the bounding rectangles in green on the original image. <br><br>  As a result of the selection of areas, we obtain successfully selected stickers.  Below is the result of the algorithm on the test image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/332/1d8/787/3321d8787fcf4e5b9c7146b4ec33fe6e.jpg"></div><br>  <i>Fig.3.</i>  <i>Stickers are highlighted.</i> <br><br>  Knowing the parameters of the bounding rectangles, it is easy to cut and save images of stickers to disk as separate files: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; stickers.size();i++) { cv::imwrite(<span class="hljs-string"><span class="hljs-string">"sticker"</span></span>+toString(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)+<span class="hljs-string"><span class="hljs-string">".jpg"</span></span>,stickers[i]); }</code> </pre> <br>  As a result, sticker1.jpg ... stickerN.jpg files will be formed on the disk.  An example of the contents of the sticker file is shown below: <br><br><img src="https://habrastorage.org/files/0d3/9dc/105/0d39dc10585b42cd899cc6da157c3bbb.jpg"><br>  <i>Fig.4.</i>  <i>An image of the highlighted sticker.</i> <br><br>  It should be noted that in the above example, we did not implement the algorithm for determining the color of the sticker, but set it with key_light, key_sat, key_hue constants in HSV-space, which is not good under normal conditions.  And if suddenly the stickers are of a different color, the algorithm will need to be reconfigured.  Boundary rectangles for developer areas (blue, green, red) are not highlighted.  In principle, it is possible to set color constants, and for them to allocate a similar algorithm, which will automatically determine the boundaries of areas and determine the status of tasks. <br><br><h3>  Algorithm 2. </h3><br>  We use the function cv :: threshold, as shown in examples / 1 / and / 3 /.  To begin with, we converted the input frame to HSV format using the cv :: cvtColor function, and the result was split using cv :: split.  Result below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9fa/7dd/924/9fa7dd9242934b4c80ee42fe03776f48.jpg"></div><br>  <i>Fig.5.</i>  <i>H-channel image.</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/212/f50/8bc/212f508bce8a441a9db36796f0d2da24.jpg"></div><br>  <i>Fig.6.</i>  <i>S-channel image.</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/70c/8a4/dff/70c8a4dffcde420da523d1bf27328ebc.jpg"></div><br>  <i>Fig.7.</i>  <i>V-channel image.</i> <br><br>  As can be seen from Figure 5 - Figure 7, the S-channel of the image is of the greatest interest for processing stickers on a white background, where the value of the color-saturated stickers will be maximum and the white background will be minimum.  This is most clearly shown <a href="https://en.wikipedia.org/wiki/HSL_and_HSV">here</a> .  It can be assumed that using the cv :: threshold function with the correct value of the boundary, we obtain the desired binary image with selected stickers, from which stickers can be extracted using the cv :: findContours function, similar to algorithm 1. <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::Mat&gt; hsvPlanes; cv::split(inputHsvImage, hsvPlanes); cv::Mat image = hsvPlanes[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> thresh = <span class="hljs-number"><span class="hljs-number">110</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxValue = <span class="hljs-number"><span class="hljs-number">255</span></span>; threshold(image,image, thresh, maxValue, cv::THRESH_BINARY);</code> </pre> <br>  In the above example, the value of the boundary at 110 leads to the desired result of binarization.  As in the case of algorithm 1, we again encounter the need to choose the value of the boundary, which can be calculated by analyzing the image histogram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a2d/180/027/a2d180027c22424297c5679a356a7584.png"></div><br>  <i>Fig.8.</i>  <i>Histogram for S channel image.</i> <br><br>  Since the stickers are light, the color of the sticker corresponds to the rightmost peak on the S-channel histogram.  Defining its boundaries using the algorithm / 4 /, we obtain the desired boundary value for the stepwise transformation. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findMostRightExtremum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cv::Mat histNorm)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &gt; data; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;histNorm.rows; i++) data.push_back(histNorm.at&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(i)); <span class="hljs-comment"><span class="hljs-comment">//   . Persistence1D p; p.RunPersistence(data); //     0,002. vector&lt; TPairedExtrema &gt; Extrema; p.GetPairedExtrema(Extrema, 0,002); sort(Extrema.begin(),Extrema.end(), [](const TPairedExtrema &amp;a, const TPairedExtrema &amp;b) -&gt; bool { return (a.MaxIndex) &gt; (b.MaxIndex); } ); //         return (Extrema[0].MinIndex)*(255/histNorm.rows); }</span></span></code> </pre><br>  As a result of binarization using the function cv :: threshold, we obtain: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/896/52d/6c8/89652d6c8c534a1bba475919c6dd24c8.jpg"></div><br>  <i>Fig.9.</i>  <i>Binarization with cv :: threshold for the calculated boundary.</i> <br><br>  As you can see, both stickers and colored boundary markers are highlighted, defining the boundaries of developer areas, which will allow you to highlight areas of the board for each of the developers. <br><br>  This is the first article in a series of articles on the introduction of computer vision technology into the SCRUM process.  The following tasks remained out of consideration: <br><br><ul><li>  selection of board zones (‚Äúzone of unselected tasks‚Äù, areas ‚Äúin progress‚Äù and ‚Äúcompleted‚Äù for developers ‚Äù); </li><li>  determine the zone of the board in which the sticker is located; </li><li>  matching stickers after moving on the board; </li><li>  task text recognition; </li><li>  interaction with jira. </li></ul><br>  By the way, soon we will have a <a href="http://www.rtsoft.ru/press/events/detail.php%3FID%3D2924">series of free webinars</a> on programming in C ++ 11/14, with examples from the field of image processing and augmented reality. <br><br><h3>  Sources </h3><br><ol><li>  <a href="http://docs.opencv.org/master/db/d8e/tutorial_threshold.html">Basic Thresholding Operations</a> </li><li>  <a href="http://docs.opencv.org/master/da/d97/tutorial_threshold_inRange.html">Thresholding Operations using inRange</a> </li><li>  <a href="https://akaifi.github.io/MultiObjectTrackingBasedhOnColor">akaifi.github.io/MultiObjectTrackingBasedhOnColor</a> </li><li>  <a href="https://people.mpi-inf.mpg.de/~weinkauf/notes/persistence1d.html">Local Extremum Search Algorithm</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/320456/">https://habr.com/ru/post/320456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320446/index.html">Mapping in C # on the example of the serializer for AMF</a></li>
<li><a href="../320448/index.html">User comfort in VR: player parameters</a></li>
<li><a href="../320450/index.html">A simple version of an indoor video surveillance system using a motion sensor and Python on the Raspberry platform</a></li>
<li><a href="../320452/index.html">Developing a new application architecture for Uber passengers</a></li>
<li><a href="../320454/index.html">ITSM educational program: How to meet customer expectations</a></li>
<li><a href="../320458/index.html">Arduino on car wash</a></li>
<li><a href="../320460/index.html">Exploit Exercises: Introducing binary vulnerabilities using the example of Protostar</a></li>
<li><a href="../320462/index.html">SystemJS 0.20 - Combining with browser modules</a></li>
<li><a href="../320464/index.html">OpenJDK 10 development begins</a></li>
<li><a href="../320470/index.html">Why did you need to develop a "Russian dropbox"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>