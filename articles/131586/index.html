<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a web server in Common Lisp part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, I took up the study of Common Lisp. As it may seem, the study of a new programming language is not a very simple matter, especially i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a web server in Common Lisp part one</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, I took up the study of Common Lisp.  As it may seem, the study of a new programming language is not a very simple matter, especially if it is completely different from all the languages ‚Äã‚Äãthat have been encountered before.  So I decided to start with the <a href="http://landoflisp.com/">Land Of Lisp</a> book.  The book is very good, with interesting pictures and is very well suited for beginners.  One of the chapters described how to create a Common Lisp web server.  I decided to slightly develop this topic, and as a result I didn‚Äôt get exactly what was described in this chapter, but a very interesting web server.  Source codes can be viewed <a href="https://github.com/troydm/myweb">here</a> . <br><br>  To write it we need Linux with emacs, sbcl, slime and quicklisp installed.  Describe how to install it all, configure it and how to use it, I will not - there are many articles on the Internet about it.  Our entire web server will be in one package called myweb.  Create a folder with this name, and in it create two folders, log and web.  The log folder will contain the web server log file.  In the web folder will be html-pages and images that the web server will give to clients.  The entire web server consists of seven files. <br><a name="habracut"></a><br>  We start with the file that declares the package, and the asd file that describes the package itself. <br><br>  Create a package.lisp file: <br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">in-package</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:cl-user</span></span>) (<span class="hljs-name"><span class="hljs-name">defpackage</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:myweb</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">:use</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:cl</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:usocket</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:bordeaux-threads</span></span>) (<span class="hljs-symbol"><span class="hljs-symbol">:export</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:start-http</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:stop-http</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:list-workers</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:list-requests</span></span>)) (<span class="hljs-name"><span class="hljs-name">defpackage</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:myweb</span></span>.util (<span class="hljs-symbol"><span class="hljs-symbol">:use</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:cl</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:local-time</span></span>) (<span class="hljs-symbol"><span class="hljs-symbol">:export</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:parse-request</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:read-utf-8-string</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:response-write</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:get-param</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:get-header</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:http-response</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:file-response</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:html-template</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:log-info</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:log-warning</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:log-error</span></span>)) (<span class="hljs-name"><span class="hljs-name">defpackage</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:myweb</span></span>.handler (<span class="hljs-symbol"><span class="hljs-symbol">:use</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:cl</span></span>) (<span class="hljs-symbol"><span class="hljs-symbol">:export</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:process-request</span></span>))</code> </pre> <br>  As you can see, our web server consists of three packages: <br><ul><li>  <b>myweb</b> - will contain functions for starting and stopping the web server </li><li>  <b>myweb.util</b> - will contain functions that help process requests </li><li>  <b>myweb.handler</b> - will contain the request processing code itself </li></ul><br>  The in-package function is usually placed at the beginning of the file and indicates the name of the package in which we declare variables and functions.  In this case, since we declare the packages, we must declare them in the main package: cl-user. <br>  Pay attention to the directives <b>: use</b> and <b>: export</b> in the package advertisement.  <b>: use</b> allows us to use functions from other packages without specifying the name of the packages at the beginning of the function name, thereby reducing the amount of typed text.  <b>: export</b> sets the names of those functions that can be used outside the package.  As you can see, in our package: myweb has functions: start-http and: stop-http.  While in the: cl-user package, we will not be able to call them through myweb: start-http unless we first declare them using the: export directive. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We already have the package advertisement, now it remains to write the source code of these packages.  Create the web.lisp, util.lisp and handler.lisp files and add an in-package call to each of them.  For web.lisp - (in-package: myweb), for util.lisp (in-package: myweb.util), etc.  We will also need to create a log.lisp file with a call (in-package: cl-log).  This file is needed to run and configure the <a href="http://www.nicklevine.org/cl-log/">cl-log</a> logging system. <br><br>  The final touch to creating the file structure for the web server will be the creation of the file myweb.asd, which describes what files the asdf system should download so that everything works. <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;; myweb.asd (asdf:defsystem #:myweb :serial t :components ((:file "package") (:file "log") (:file "util") (:file "web") (:file "handler")))</span></span></code> </pre><br>  Key: serial t indicates that asdf downloads files in the same order in which they are listed. <br><br>  Now you need to write a file load.lisp, which will load our package and run the swank server for slime. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">in-package</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:cl-user</span></span>) (<span class="hljs-name"><span class="hljs-name">quicklisp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:quickload</span></span> <span class="hljs-string"><span class="hljs-string">"swank"</span></span>) (<span class="hljs-name"><span class="hljs-name">quicklisp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:quickload</span></span> <span class="hljs-string"><span class="hljs-string">"usocket"</span></span>) (<span class="hljs-name"><span class="hljs-name">quicklisp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:quickload</span></span> <span class="hljs-string"><span class="hljs-string">"bordeaux-threads"</span></span>) (<span class="hljs-name"><span class="hljs-name">quicklisp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:quickload</span></span> <span class="hljs-string"><span class="hljs-string">"trivial-utf-8"</span></span>) (<span class="hljs-name"><span class="hljs-name">quicklisp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:quickload</span></span> <span class="hljs-string"><span class="hljs-string">"cl-log"</span></span>) (<span class="hljs-name"><span class="hljs-name">quicklisp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:quickload</span></span> <span class="hljs-string"><span class="hljs-string">"local-time"</span></span>) (<span class="hljs-name"><span class="hljs-name">pushnew</span></span> '*default-pathname-defaults* asdf<span class="hljs-symbol"><span class="hljs-symbol">:*central-registry*</span></span>) (<span class="hljs-name"><span class="hljs-name">asdf</span></span><span class="hljs-symbol"><span class="hljs-symbol">:load-system</span></span> 'myweb) (<span class="hljs-name"><span class="hljs-name">swank</span></span><span class="hljs-symbol"><span class="hljs-symbol">:create-server</span></span>)</code> </pre><br>  To continue development, we need to run swank and load all the necessary libraries using quicklisp.  To do this, run sbcl, located in the myweb directory, and call the function (quicklisp: quickload "swank").  After installing swank, start the swank server by calling (swank: create-server) from the sbcl command line. <br>  Using slime-connect from emacs, connect to running sbcl and call all other functions with quicklisp from load.lisp using slime-mode in emacs and the key combination ctrl-e.  If you did everything correctly, then quicklisp will download all the necessary libraries and load them with the help of asdf for you.  Everything is ready to start developing. <br><br>  Let's start with the web server itself.  For him, we need sockets.  I decided to implement the work with sockets using the widespread <a href="http://common-lisp.net/project/usocket/">usocket</a> library.  We also need threads (threads), for which we will use <a href="http://common-lisp.net/project/bordeaux-threads/">bordeaux-threads</a> .  But first, I would like to talk about the HTTP request handling model that we are going to create.  Each request will be processed in a separate thread.  We will have worker threads that will be created depending on the number of requests.  Among them, we will have separate idle streams, which, after the completion of the processing of the request, will switch to the condition-wait state, waiting for new requests.  Thereby, it is possible to reduce the burden of creating new worker-streams.  It turns out a kind of thread pool mechanism for processing http requests. <br>  Let's start with the declaration of sockets and variables for mutexes in the web.lisp file: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> *listen-socket* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *listen-thread* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *request-mutex* (<span class="hljs-name"><span class="hljs-name">make-lock</span></span> <span class="hljs-string"><span class="hljs-string">"request-mutex"</span></span>)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *request-threads* (<span class="hljs-name"><span class="hljs-name">list</span></span>)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *worker-mutex* (<span class="hljs-name"><span class="hljs-name">make-lock</span></span> <span class="hljs-string"><span class="hljs-string">"worker-mutex"</span></span>)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *workers* (<span class="hljs-name"><span class="hljs-name">list</span></span>)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *worker-num* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *idle-workers* (<span class="hljs-name"><span class="hljs-name">list</span></span>)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *idle-workers-num* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *request-queue* (<span class="hljs-name"><span class="hljs-name">list</span></span>))</code> </pre><br>  To accept and distribute requests by threads, we will use a separate thread, a pointer to which will be stored in * listen-thread *.  Let's start with the start-http method: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start-http (<span class="hljs-name"><span class="hljs-name">host</span></span> port <span class="hljs-symbol"><span class="hljs-symbol">&amp;key</span></span> (<span class="hljs-name"><span class="hljs-name">worker-limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>) (<span class="hljs-name"><span class="hljs-name">idle-workers</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> *listen-socket*) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *listen-thread* (<span class="hljs-name"><span class="hljs-name">make-thread</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (<span class="hljs-name"><span class="hljs-name">http-acceptor</span></span> host port worker-limit idle-workers)) <span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"socket-acceptor"</span></span>)) <span class="hljs-string"><span class="hljs-string">"http server already started"</span></span>))</code> </pre><br>  This is a simple function to start a distribution flow, which in turn will call the http-acceptor function.  We also have two keys - this is worker-limit - the maximum number of workers, and idle-workers - the number of idle workers. <br>  Let's write the request distribution function itself: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> http-acceptor (<span class="hljs-name"><span class="hljs-name">host</span></span> port worker-limit idle-workers) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *listen-socket* (<span class="hljs-name"><span class="hljs-name">socket-listen</span></span> host port <span class="hljs-symbol"><span class="hljs-symbol">:reuse-address</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:element-type</span></span> '(unsigned-byte <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:backlog</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> worker-limit <span class="hljs-number"><span class="hljs-number">2</span></span>))) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">request-id</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">worker-id</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> while *listen-thread* do (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">socket</span></span> (<span class="hljs-name"><span class="hljs-name">socket-accept</span></span> *listen-socket* <span class="hljs-symbol"><span class="hljs-symbol">:element-type</span></span> '(unsigned-byte <span class="hljs-number"><span class="hljs-number">8</span></span>)))) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> request-id (<span class="hljs-number"><span class="hljs-number">1</span></span>+ request-id)) (<span class="hljs-name"><span class="hljs-name">acquire-lock</span></span> *worker-mutex*) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> *worker-num* worker-limit) (<span class="hljs-name"><span class="hljs-name">push</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> request-id socket) *request-queue*) <span class="hljs-comment"><span class="hljs-comment">;; Get worker from idle workers (if (&gt; *idle-workers-num* 0) (progn (push (cons request-id socket) *request-queue*) (condition-notify (caar *idle-workers*))) ;; Add new Worker (progn (setq worker-id (1+ worker-id)) (setq *worker-num* (1+ *worker-num*)) (setq *workers* (cons (make-thread (lambda () (worker-thread request-id socket idle-workers)) :name (concatenate 'string "socket-worker-" (prin1-to-string worker-id))) *workers*))))) (release-lock *worker-mutex*) t)))))</span></span></code> </pre><br>  The first thing we do is socket-listen to the specified address and port.  Further in the loop, we do the socket-accept, resulting in a socket on the connected client, which we must process in the worker.  Plus we assign request-id to request.  At this stage, we must decide what to do with the request and how to handle it.  First of all, we check the number of idle threads.  If all our workers are busy, we add the request to the queue for processing.  If we have a free idle worker, then again we add the request to the queue, but this time we call (condition-notify (caar * idle-workers *))).  And in the third case, we simply create a new worker and pass it a request that will be processed in the worker-thread function.  Everything is quite simple.  It remains only to write the function of processing worker-flow: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> worker-thread (<span class="hljs-name"><span class="hljs-name">request-id</span></span> socket idle-workers) (<span class="hljs-name"><span class="hljs-name">if</span></span> request-id <span class="hljs-comment"><span class="hljs-comment">;; Process request if it is not nil (progn (with-lock-held (*request-mutex*) (setq *request-threads* (cons (cons request-id (current-thread)) *request-threads*)) ) (http-worker socket) (with-lock-held (*request-mutex*) (setq *request-threads* (remove-if (lambda (x) (eq (car x) request-id)) *request-threads*)) ) )) (acquire-lock *worker-mutex*) (if *request-queue* (let ((request nil)) (setq request (car *request-queue*)) (setq *request-queue* (cdr *request-queue*)) (release-lock *worker-mutex*) (worker-thread (car request) (cdr request) idle-workers)) (if (&lt; *idle-workers-num* idle-workers) (let ((condition (make-condition-variable)) (idle-lock (make-lock)) (request nil)) (push (cons condition (current-thread)) *idle-workers*) (setq *idle-workers-num* (1+ *idle-workers-num*)) (release-lock *worker-mutex*) (list-workers) (with-lock-held (idle-lock) (condition-wait condition idle-lock) ) (with-lock-held (*worker-mutex*) (setq *idle-workers* (cdr *idle-workers*)) (setq *idle-workers-num* (1- *idle-workers-num*)) (setq request (car *request-queue*)) (setq *request-queue* (cdr *request-queue*)) ) (worker-thread (car request) (cdr request) idle-workers)) (progn (setq *workers* (remove (current-thread) *workers*)) (setq *worker-num* (1- *worker-num*)) (release-lock *worker-mutex*)))))</span></span></code> </pre><br>  If we had a call with request-id, then we need to process the request first.  We simply call the helper function http-worker and pass the client socket to it.  Next, we check that there are more processing requests: we simply remove the first request from the queue and pass it to worker-thread for processing, thereby calling the worker-thread function recursively.  A question may arise: ‚ÄúWill the recursion limit happen if the stack overflows at some point, for example, when there are a large number of requests in the queue?‚Äù Since, after calling worker-thread recursively, nothing is called in our function, recursion limit will not happen.  Almost all modern Common Lisp implementations support this optimization.  Well, if the queue is empty, then we have to check the number of idle workers.  If everything is all right with us, then we simply complete the request and remove the worker from the list of workers.  If not, then we do a condition-wait, and thus the worker becomes an idle worker. <br>  If you notice, we also call list-workers.  This auxiliary function which simply clears a sheet of workers from dead threads. <br>  It remains to write the http-worker function: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> http-worker (<span class="hljs-name"><span class="hljs-name">socket</span></span>) (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">stream</span></span> (<span class="hljs-name"><span class="hljs-name">socket-stream</span></span> socket)) (<span class="hljs-name"><span class="hljs-name">request</span></span> (<span class="hljs-name"><span class="hljs-name">myweb</span></span>.util<span class="hljs-symbol"><span class="hljs-symbol">:parse-request</span></span> stream))) (<span class="hljs-name"><span class="hljs-name">myweb</span></span>.handler<span class="hljs-symbol"><span class="hljs-symbol">:process-request</span></span> request stream) (<span class="hljs-name"><span class="hljs-name">finish-output</span></span> stream) (<span class="hljs-name"><span class="hljs-name">socket-close</span></span> socket))) (<span class="hljs-name"><span class="hljs-name">defun</span></span> list-workers () (<span class="hljs-name"><span class="hljs-name">with-lock-held</span></span> (<span class="hljs-name"><span class="hljs-name">*worker-mutex*</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *workers* (<span class="hljs-name"><span class="hljs-name">remove-if</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">w</span></span>) (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">thread-alive-p</span></span> w))) *workers*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *worker-num* (<span class="hljs-name"><span class="hljs-name">length</span></span> *workers*)) *workers*))</code> </pre><br>  Here we create a socket-stream, parse the request and pass it to myweb.handler: process-request (we'll talk about these functions in the second part).  list-workers simply returns us a list of workers, having previously cleared it of dead threads.  We call this function in worker-thread before condition-wait. <br>  The last thing we need to do is write the stop-http function, which will stop our web server: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> stop-http () (<span class="hljs-name"><span class="hljs-name">if</span></span> *listen-socket* (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">stop-thread</span></span>) (<span class="hljs-name"><span class="hljs-name">socket-close</span></span> *listen-socket*) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *listen-socket* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *request-queue* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *worker-num* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *workers* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">i</span></span>) (<span class="hljs-name"><span class="hljs-name">destroy-thread</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> i))) *idle-workers*) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *idle-workers-num* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *idle-workers* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">release-lock</span></span> *worker-mutex*) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *request-threads* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">release-lock</span></span> *request-mutex*) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *request-mutex* (<span class="hljs-name"><span class="hljs-name">make-lock</span></span> <span class="hljs-string"><span class="hljs-string">"request-mutex"</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *worker-mutex* (<span class="hljs-name"><span class="hljs-name">make-lock</span></span> <span class="hljs-string"><span class="hljs-string">"worker-mutex"</span></span>))))) (<span class="hljs-name"><span class="hljs-name">defun</span></span> stop-thread () (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> *listen-thread* (<span class="hljs-name"><span class="hljs-name">thread-alive-p</span></span> *listen-thread*)) (<span class="hljs-name"><span class="hljs-name">destroy-thread</span></span> *listen-thread*)))</code> </pre><br>  As you can see, everything is simple here - we stop the flow of the distributor, kill all workers and reset the lists. <br>  And so, everything is ready to process our requests.  We will talk about this in the <a href="http://habrahabr.ru/blogs/lisp/131780/">second part</a> . <br><br>  Thank you for your attention! <br><br>  PS Thank you <a href="http://habrahabr.ru/users/ertaquo/" class="user_link">ertaquo</a> for help with spelling and layout </div><p>Source: <a href="https://habr.com/ru/post/131586/">https://habr.com/ru/post/131586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131581/index.html">Several useful services</a></li>
<li><a href="../131582/index.html">Samsung Galaxy R - Smartphone Parsing</a></li>
<li><a href="../131583/index.html">Report on meeting Apple Developers Community # 9</a></li>
<li><a href="../131584/index.html">Deface images or you may be substituted.</a></li>
<li><a href="../131585/index.html">Client-server chat using Qt / C ++ sockets</a></li>
<li><a href="../131587/index.html">MobiUs: browser HTML5 applications for iOS</a></li>
<li><a href="../131588/index.html">What state sites show hatred towards citizens?</a></li>
<li><a href="../131589/index.html">Minimal Arduino DIY</a></li>
<li><a href="../131590/index.html">Business Forum in Skolkovo</a></li>
<li><a href="../131595/index.html">How to protect against SWF decompilers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>