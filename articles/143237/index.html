<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>But how does multithreading work? Part I: Synchronization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(post from the series ‚ÄúI have cloned my hotspot source code, let's look at them together‚Äù) 
 Everyone who faces multithreaded problems (be it performa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>But how does multithreading work? Part I: Synchronization</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/6d8/673/dcf/6d8673dcff291a24f15f8751220f6fe5.jpg" align="left" title="Java Duke pokes a finger at DiCaprio's nose, as if hinting at us: we need to go deeper" alt="picture to attract attention">  <font color="grey"><i>(post from the series ‚ÄúI have cloned my hotspot source code, let's look at them together‚Äù)</i></font> <br>  Everyone who faces multithreaded problems (be it performance or incomprehensible heisenbags), inevitably encounters in the process of solving problems like inflation, contention, membar, biased locking, thread parking and the like.  But does everyone really know what is behind these terms?  Unfortunately, as practice shows, <a href="">not all</a> . <br><br>  Hoping to correct the situation, I decided to write a series of articles on this topic.  Each of them will be built on the principle of <i>"first briefly describe what should happen in theory, and then go to the source and see how it happens there</i> . <i>"</i>  Thus, the first part is largely applicable not only to Java, and therefore developers for other platforms may find something useful for themselves. <br><br>  Before reading in-depth descriptions, it is useful to make sure that you are sufficiently familiar with the Java Memory Model.  You can study it, for example, on the <a href="http://shipilev.net/pub/talks/j1-April2012-jmm.pdf">slides of</a> Sergei <a href="https://habrahabr.ru/users/walrus/" class="user_link">Walrus</a> Kuksenko or on my <a href="http://habrahabr.ru/post/133981/">early topic</a> .  This <a href="http://shipilev.net/pub/talks/j1-April2011-performanceBoF.pdf">presentation</a> is also a great material, starting with slide # 38. <br><a name="habracut"></a><br><h1>  <font color="darkred">Theoretical minimum</font> </h1>  As you know, every object in java has its own <b>monitor</b> , and therefore, unlike the same C ++, there is no need to guard access to the objects by separate mutexes.  To achieve the effects of mutual exclusion and synchronization of threads use the following operations: <ul><li>  <b><font color="darkgreen">monitorenter</font></b> : capture monitor.  Only one stream can own a monitor at a time.  If the monitor is busy at the time of the capture attempt, the stream attempting to capture it will wait until it is free.  At the same time, there may be several threads in the queue. </li><li>  <b><font color="darkgreen">monitorexit</font></b> : monitor release </li><li> <b><font color="darkgreen">wait</font></b> : move the current thread to the so-called monitor <b>wait set</b> and wait for <code>notify</code> occur.  Exiting the <code>wait</code> method may also be false.  After the thread owning the monitor has made a <code>wait</code> , any other stream can take over the monitor. </li><li>  <b><font color="darkgreen">notify</font> (all)</b> : one (or all) threads are awakened, which are now in the monitor's wait set.  To get control, the awakened stream must successfully capture the monitor (monitorenter) </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before continuing, we define an important concept: <br><br><blockquote>  <b>contention</b> - a situation when several entities simultaneously try to own the same resource that is intended for exclusive use <br></blockquote><br><br>  How contention to owning a monitor really depends on how it is captured.  The monitor may be in the following states: <br><br><ul><li>  <b><font color="darkgreen">init</font></b> : the monitor has just been created, and so far no one has been captured </li><li>  <b><font color="darkgreen">biased</font></b> : <font color="grey">(smart optimization, which did not appear immediately) The</font> monitor is ‚Äúreserved‚Äù for the first stream that captured it.  In the future, to capture this stream does not need expensive operations, and the capture occurs very quickly.  When a capture tries to produce another stream, either the monitor is re-backed up for it ( <b>rebias</b> ), or the monitor changes to the thin ( <b>revoke bias</b> ) state.  There are also additional optimizations that act immediately on all instances of the class of an object whose monitor is trying to capture ( <b>bulk revoke / rebias</b> ) </li><li>  <b><font color="darkgreen">thin</font></b> : the monitor is trying to capture multiple streams, but there is no contention <font color="grey">(i.e., they capture it not simultaneously, or with very little overlap)</font> .  In this case, the capture is performed using a relatively cheap <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> .  If contention occurs, the monitor changes to the inflated state. </li><li>  <b><font color="darkgreen">fat / inflated</font></b> : synchronization is performed at the operating system level.  The stream parks and sleeps until it is its turn to capture the monitor.  Even if we forget about the cost of changing the context, then when the flow receives control, it also depends on the system scheduler, and therefore the time can pass significantly more than we would like.  When contention disappears, the monitor may return to the thin state. </li></ul><br><br>  This is where abstract reasoning ends, and we dive into how it is implemented in hotspot. <br><br><h1>  <font color="darkred">Object Headers</font> </h1>  Inside a virtual machine, object headers generally contain two fields: the <b>mark word</b> and a pointer to the class of the object.  In particular cases, there may be something added: for example, the length of the array.  These headers are stored in the so-called <b>oop</b> - <b>ohs</b> (Ordinary Object Pointer), and you can look at their structure in the file <code>hotspot/src/share/vm/oops/oop.hpp</code> .  We will study in more detail what the mark word is, which is described in the <code>markOop.hpp</code> file located in the same folder.  <font color="grey">(Do not pay attention to the inheritance from <code>oopDesc</code> : it is only for historical reasons)</font> In an amicable way, it should be carefully read, paying attention to detailed comments, but for those who are not very interested, below is a brief description of what is in this mark Word contains and in what cases.  You can still see <a href="http://edu.netbeans.org/contrib/slides/java-overview-and-java-se6.pdf">this</a> presentation here from the 90th slide. <br><br><h2>  <font color="darkgreen">Content mark words</font> </h2><table><tbody><tr><td>  <b>condition</b> </td><td>  <b>Tag</b> </td><td colspan="4">  <b>Content</b> </td></tr><tr><td>  unlocked thin </td><td>  01 </td><td colspan="2"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Identity</span></span> hashcode</code> </pre> </td><td><pre> <code class="hljs">age</code> </pre> </td><td><pre> <code class="hljs">0</code> </pre> </td></tr><tr><td>  locked, thin, unbiased </td><td>  00 </td><td colspan="4"><pre> <code class="hljs">    mark word</code> </pre> </td></tr><tr><td>  inflated </td><td>  ten </td><td colspan="4"><pre> <code class="hljs">   </code> </pre> </td></tr><tr><td>  biased </td><td>  01 </td><td><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">id</span></span> -</code> </pre> </td><td><pre> <code class="hljs">epoch</code> </pre> </td><td><pre> <code class="hljs">age</code> </pre> </td><td><pre> <code class="hljs">1</code> </pre> </td></tr><tr><td>  <font color="grey">marked for GC</font> </td><td>  <font color="grey">eleven</font> </td><td colspan="4"></td></tr></tbody></table><br>  Here we see several new values.  First, <b>identity hash code</b> is the object hash code that is returned when <code>System.identityHashCode</code> called.  Secondly, <b>age</b> - how many garbage assemblies survived the object.  And there is also <b>epoch</b> , which indicates the number of bulk revocation or bulk rebias for the class of this object.  To why this is necessary, we will come later. <br><blockquote>  Have you noticed that in the case of biased there was not enough space at the same time for identity hash code and threadID + epoch?  And this is true, and from here there is an interesting consequence: in hotspot, a call to <code>System.identityHashCode</code> will result in a revoke bias object. <br></blockquote>  Further, when the monitor is busy, <a href="">a mark is stored in the mark word to the place where the real mark word is stored</a> .  In the stack of each thread there are several "sections" in which different things are stored.  We are interested in the one where the lock record is stored.  This is where we copy the mark word of the object for lightweight locking.  Because, by the way, thin-locked objects are called <b>stack locked</b> .  A swollen monitor can be stored both on the thread that inflated it and in the global pool of thick monitors. <br><br>  It's time to go to the code. <br><br><h1>  <font color="darkred">A simple example of using <code>synchronized</code></font> </h1>  Let's start with this class: <table><tbody><tr><td><pre> <code class="hljs">1 2 3 4 5 6 7</code> </pre> </td><td><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SynchronizedSample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Do something } } }</span></span></code> </pre> </td></tr></tbody></table><br>  and see what it compiles into: <br><br><pre> <code class="hljs swift">javac <span class="hljs-type"><span class="hljs-type">SynchronizedSample</span></span>.java &amp;&amp; javap -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">SynchronizedSample</span></span></code> </pre> <br>  I will not give a full listing, but I will only manage with the body of the <code>doSomething</code> method, providing it with comments. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: aload_0 <span class="hljs-comment"><span class="hljs-comment">//    this 1: dup //    (this) 2: astore_1 //      (this)   1 3: monitorenter //   ,     (this) 4: aload_1 //   this   5: monitorexit //   6: goto 14 //  "catch-" 9: astore_2 // (  ,   )     2 10: aload_1 //  this    11: monitorexit //   12: aload_2 //      13: athrow //   14: return //  Exception table: from to target type 4 6 9 any //      ,   "catch-" 9 12 9 any //   ,    </span></span></code> </pre> <br><br>  Here we are interested in the instructions <b><code>monitorenter</code></b> and <b><code>monitorexit</code></b> .  You can, of course, search for what they do in the <font color="grey"><s>Yandex</s></font> search system at your discretion, but this is fraught with misinformation, and not in a patzanski way.  In addition, I have the OpenJDK sources at hand, <a href="http://habrahabr.ru/post/142447/">which you can have fun with at all</a> .  In these source codes it is quite easy to see what happens to the byte code in the interpretation mode.  There is only one caveat: Lesha <a href="https://habrahabr.ru/users/theshade/" class="user_link">TheShade</a> Shipilev <a href="http://shipilev.net/pub/talks/oracle-May2011-concurrency.pdf">said</a> that <br><blockquote>  In general, the VM helper code for some action may differ in content from that pasted by JIT.  Up to the point that some optimizations by JIT can simply not be ported to the interpreter. <br></blockquote><br>  Lesha also recommended PrintAssembly in the teeth and look at the compiled and JIT-compiled code right away, but I decided to start from a path of less resistance, and then see how it <i>really is.</i> <br><br><h2>  <font color="darkgreen">monitorenter</font> </h2><br>  The interpreter sources are in the <code>hotspot/src/share/vm/interpreter</code> daddy, and there are a lot of them.  Rereading everything at this stage is not very appropriate, therefore with the help of <code>grep</code> we will find places in which, probably, what we need happens.  First of all, it‚Äôs worth looking at the ads in <code>bytecodes.hpp</code> and <code>bytecodes.cpp</code> : <br><pre> <code class="bash hljs">./bytecodes.hpp:235: _monitorenter = 194, // 0xc2 ./bytecodes.cpp:489: def(_monitorenter, <span class="hljs-string"><span class="hljs-string">"monitorenter"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, NULL, T_VOID, -1, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  As you can easily guess, the human enum constant for bytecode <code>.hpp</code> is defined in <code>.hpp</code> , and this operation is registered in the <code>.cpp</code> using the def method.  Talking about it separately in this article makes no sense: it is enough to clarify that the monitorenter command is <code>monitorenter</code> , which is a single byte-code without parameters ( <code>b</code> ), returns nothing, pulls one value from the stack and can provoke a lock or a safepoint call ( about the latter later). <br><br>  The following is of interest file <code>bytecodeInterpreter.cpp</code> .  It has a wonderful method <code>BytecodeInterpreter::run(interpreterState istate)</code> , which takes only about 2,200 lines, and generally rotates in a loop until the body of the method being processed ends.  (In fact, another large piece deals with other useful things such as method initialization, locking, if the method is <code>synchronized</code> , and so on).  Finally, starting at line <code>1667</code> , what happens when a <code>monitorenter</code> operation is <code>monitorenter</code> .  First of all, there is a free monitor on the stream stack (if there are none, then it is requested from the interpreter using <code>istate-&gt;set_msg(more_monitors)</code> ), and an unlocked copy of the mark word is placed there.  After that, using CAS, we try to write a pointer to this copy in the mark word of the object, which is called the <b>displaced header</b> . <br><blockquote>  <b>CAS</b> - Compare-and-swap - atomically compares <code>*dest</code> and <code>compare_value</code> , and if they are equal, <code>*dest</code> and <code>exchange_value</code> places.  The initial value <code>*dest</code> returned.  <font color="grey">(This is guaranteed bilateral membar, but about them in the next article)</font> <br></blockquote><br>  If CAS is a success, then the victory (and with it the monitor) is ours, and this can be completed (the tag is contained in the pointer to the displaced header itself - optimization).  If not, then go ahead, but first pay attention to an important point: <font color="darkred"><i>we didn‚Äôt check if this monitor wasn‚Äôt biased</i></font> .  Remembering the warnings of Leshina, we understand that we encountered optimization, which did not reach the interpreter.  By the way, when processing <code>synchronized</code> methods everything is checked normally, but it will be a little later. <br><br>  If CAS did not succeed, then we check whether we are already owners of the monitor (recursive capture);  and if so, then success is with us again, the only thing we are doing is writing to the displaced header on our <code>NULL</code> stack (we will see later why this is necessary).  Otherwise, we make the following call: <br><br><pre> <code class="hljs lisp">CALL_VM(<span class="hljs-name"><span class="hljs-name">InterpreterRuntime</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:monitorenter</span></span>(<span class="hljs-name"><span class="hljs-name">THREAD</span></span>, entry), handle_exception)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  The <code>CALL_VM</code> macro <code>CALL_VM</code> all sorts of technical operations such as creating frames and performs the transferred function.  In our case, this function is <code>InterpreterRuntime::monitorenter</code> , which is located in the new <code>interpreterRuntime.cpp</code> file.  The <code>monitorenter</code> method, depending on whether <code>UseBiasedLocking</code> is <code>UseBiasedLocking</code> , calls either <code>ObjectSynchronizer::fast_enter</code> or <code>ObjectSynchronizer::slow_enter</code> .  Let's start with the first. <br><br><h3>  <font color="darkgreen">fast_enter</font> </h3><br>  First a couple of words about the feasibility of such optimization.  Some Tokyo scientists from IBM Research Labs calculated statistics by some unknown method and found that in most cases synchronization is uncontended.  Moreover, an even stronger statement was proposed: the monitors of most objects throughout their life are captured by only one stream.  And so the idea of ‚Äã‚Äãbiased locking was born: the one who stood up first, the one and the slippers.  You can read more about biased locking, for example, on <a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf">these slides</a> (although they are slightly out of date), and we will return to the hotspot sources.  Now we are interested in the <code>src/share/vm/runtime/synchronizer.cpp</code> file, starting at line 169. First we should try to do a rebias for ourselves, and if it does not work out - do a revoke and go to the usual thin slow_enter.  Optimistic attempts occur in the <code>BiasedLocking::revoke_and_rebias</code> , which is in the <code>biasedLocking.cpp</code> file.  We describe them in more detail: <br><ul><li>  <b><font color="darkred">Rebias</font></b> is a flow change that reserves the right to quickly capture a monitor.  It is permissible in simple cases: for example, when the monitor is actually still someone did not have time to capture ( <b>anonymously biased</b> ), or if bias has been preserved since the previous <b>era</b> (the number of bulk revocation for a particular class, see below), which is essentially similar the fact that the monitor is not over-bias-il.  In addition, rebiasing can be banned completely by calling <code>fast_enter</code> ( <code>attempt_rebias = false</code> ). </li><li>  <b><font color="darkred">Revoke</font></b> - disable biased locking for the monitor.  Used in most cases, especially when <code>attempt_rebias</code> set to <code>false</code> .  If the monitor is now owned by another live stream, then rebias will require this stream to stop at <b>safepoint</b> , after which it will run over the stack of this stream and fix the monitor header stored there on unbiased. </li><li>  <b><font color="darkred">Bulk rebias</font></b> - rebias of all living and later allocated instances of this class.  It is executed when the number of revocations or rebiasing operations for a given class during this epoch exceeds the <code>BiasedLockingBulkRebiasThreshold</code> .  Provokes a change of epoch, runs at a global safepoint. </li><li>  <b><font color="darkred">Bulk revoke</font></b> - revoke all live and later instances of this class.  It is executed when the number of revocations or rebiasing for this class during this era exceeds the <code>BiasedLockingBulkRevokeThreshold</code> .  Provokes a change of epoch, runs at a global safepoint. </li></ul><br><br>  Let me remind those who <i>knew, but forgot <sup>tm</sup></i> , what is a safepoint: <br><blockquote>  <b>safepoint</b> is a state of the virtual machine in which the execution of threads is stopped in safe places.  This allows for intrusive operations, such as revoke bias at the monitor, which the stream currently owns, deoptimizing or taking the thread dump. <br></blockquote><br><br>  In our case, the <code>attempt_rebias</code> parameter is always <code>true</code> , but sometimes it may turn out to be <code>false</code> : for example, in the case when the call comes from VM Thread. <br><br>  As you can guess, bulk operations are tricky optimizations that make it easy to transfer a large number of objects between threads.  If it were not for this optimization, it would be dangerous to include <code>UseBiasedLocking</code> by default, since then a large class of applications would always be engaged in revocations and rebiasing. <br><br>  If the fast path to capture the stream failed (that is, revoke bias was made), we proceed to capture the thin-lock. <br><br><h3>  <font color="darkgreen">slow_enter</font> </h3><br>  The method that interests us now is in the <code>src/share/vm/runtime/synchronizer.cpp</code> file.  Here we have several options for the development of events. <br><br><ol><li>  <b>Case one, <font color="darkgreen">‚Äúgood‚Äù</font></b> : the object monitor is currently free.  Then we try to take it with the help of CAS.  CAS is already architecture-dependent (and, as a rule, natively supported by the processor) instruction, so there is no special meaning to go deeper.  <i><font color="grey">(Although Ruslan # let <a href="https://habrahabr.ru/users/cheremin/" class="user_link">me</a> know the <a href="https://habrahabr.ru/users/cheremin/" class="user_link">cheremin</a> and was outraged that I "did not get to the running of electrons in the sources-drains of MOS transistors")</font></i> .  If CAS succeeds, then victory: the monitor is captured.  If it fails, we are filled with sadness and proceed to the third case. <br><br></li><li>  <b>The second case is also <font color="darkgreen">‚Äúgood‚Äù</font></b> : the object monitor is not free, but is occupied by the same stream that is now trying to capture it.  This is a recursive capture.  In this case, for simplicity, we write to the displaced header in our NULL stack, because we previously captured this monitor and already have information about it in our stack. <br><br></li><li>  <b>The third case, the <font color="darkred">‚Äúbad‚Äù</font> inflate</b> : So, all attempts to be cunning with the collapse failed, and we have nothing to do but to sulk, to show the vile user the language and fall off the segfault.  Haha  Joke.  However, I didn‚Äôt just say the same about inflating: in the case when you have to act ‚Äúhonestly‚Äù, resorting to OS-level primitives, they say that <i>monitor was inflated</i> .  In the code, this behavior is described in the <code>ObjectSynchronizer::inflate</code> , where we will not look particularly carefully: in fact, the method is thread safe and taking into account some technical subtleties sets the monitor a flag that it is bloated. <br><br>  After inflating the monitor it is necessary to enter it.  The <code>ObjectMonitor::enter</code> method does just that, it uses every conceivable and inconceivable trick to avoid parking the stream.  These tricks include, as you might have guessed, attempts to capture using a spin loop, using one-off CAS and other ‚Äúfree methods‚Äù.  By the way, it seems I have found a slight discrepancy between comments and what is happening.  once we try to enter the spin loop monitor, claiming that we do it only once: <br><br><table><tbody><tr><td><pre> <code class="hljs">352 353 354 355 356 357 358 359 360 361 362 363</code> </pre> </td><td><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Try one round <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> spinning *before* enqueueing Self <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> before going through the awkward <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expensive state <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> transitions. The following spin <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> strictly optional ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Note that <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we acquire the monitor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> an initial spin <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> we forgo posting JVMTI events <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> firing DTRACE probes. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { assert (_owner == Self , <span class="hljs-string"><span class="hljs-string">"invariant"</span></span>) ; assert (_recursions == <span class="hljs-number"><span class="hljs-number">0</span></span> , <span class="hljs-string"><span class="hljs-string">"invariant"</span></span>) ; assert (<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop)(object())</span></span></span><span class="hljs-function">)-&gt;</span></span>mark() == markOopDesc::encode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), <span class="hljs-string"><span class="hljs-string">"invariant"</span></span>) ; Self-&gt;_Stalled = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; }</code> </pre> </td></tr></tbody></table><br><br>  But a little further, in the called <code>enterI</code> method, <code>enterI</code> do it again, again speaking of only once: <br><br><table><tbody><tr><td><pre> <code class="hljs">485 486 487 488 489 490 491 492 493 494 495 496 497</code> </pre> </td><td><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// We try one round of spinning *before* enqueueing Self. // // If the _owner is ready but OFFPROC we could use a YieldTo() // operation to donate the remainder of this thread's quantum // to the owner. This has subtle but beneficial affinity // effects. if (TrySpin (Self) &gt; 0) { assert (_owner == Self , "invariant") ; assert (_succ != Self , "invariant") ; assert (_Responsible != Self , "invariant") ; return ; }</span></span></code> </pre> </td></tr></tbody></table><br><br>  Hmm, parking at the operating system level is so scary that we are ready for almost everything to avoid it.  Let's see what is so terrible in her. <br><br><h3>  <font color="darkgreen">Parking flows</font> <font color="grey"><s>in reverse</s></font> </h3>  I must note that we have now come to the code that was written a long time ago, and this is noticeable.  There are a lot of duplication, reengineering and other amenities.  However, the presence of comments like ‚Äúremove this crutch‚Äù and ‚Äúcombine these with that‚Äù is slightly reassuring. <br><br>  So what is parking streams?  Everyone probably heard that each monitor has a so-called <b>Entry List</b> (not to be confused with the <b>Waitset</b> ) So: he really does have it, although it is actually a queue.  After all the failed attempts to enter the monitor cheaply, we add ourselves to this queue, after which we park: <br><br><table><tbody><tr><td><pre> <code class="hljs">591 592 593 594 595 596 597 598 599 600 601</code> </pre> </td><td><pre> <code class="hljs haskell">// park self <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Responsible == <span class="hljs-type"><span class="hljs-type">Self</span></span> || (<span class="hljs-type"><span class="hljs-type">SyncFlags</span></span> &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-type"><span class="hljs-type">TEVENT</span></span> (<span class="hljs-type"><span class="hljs-type">Inflated</span></span> enter - park <span class="hljs-type"><span class="hljs-type">TIMED</span></span>) ; <span class="hljs-type"><span class="hljs-type">Self</span></span>-&gt;_ParkEvent-&gt;park ((jlong) <span class="hljs-type"><span class="hljs-type">RecheckInterval</span></span>) ; // <span class="hljs-type"><span class="hljs-type">Increase</span></span> the <span class="hljs-type"><span class="hljs-type">RecheckInterval</span></span>, but clamp the value. <span class="hljs-type"><span class="hljs-type">RecheckInterval</span></span> *= <span class="hljs-number"><span class="hljs-number">8</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">RecheckInterval</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-type"><span class="hljs-type">RecheckInterval</span></span> = <span class="hljs-number"><span class="hljs-number">1000</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">TEVENT</span></span> (<span class="hljs-type"><span class="hljs-type">Inflated</span></span> enter - park <span class="hljs-type"><span class="hljs-type">UNTIMED</span></span>) ; <span class="hljs-type"><span class="hljs-type">Self</span></span>-&gt;_ParkEvent-&gt;park() ; }</code> </pre> </td></tr></tbody></table><br><br>  Before going directly to the parking lot, note that it may be timed or not timed, depending on whether the current thread is responsible.  Responsible flows are always no more than one, and they are needed in order to avoid the so-called stranding: a sadness when the monitor is free, but all the threads in the wait set are still parked and waiting for a miracle.  When there is a person in charge, he automatically wakes up from time to time (the more time a <b>futile wakeup occurs</b> , an awakening, after which the lock cannot be captured - the longer the parking time. Note that it does not exceed 1000 ms) and tries to enter the monitor.  The rest of the streams can wait for awakening for even ages. <br><br>  Now it is time to go to the very essence of parking.  As you already understood, this is something semantically similar to <code>wait/notify</code> familiar to every java-developer, but it happens at the operating system level.  For example, in linux and bsd, as one would expect, POSIX threads are used, in which <code>pthread_cond_timedwait</code> (or <code>pthread_cond_wait</code> ) are called to wait for the release of the monitor.  These methods change the status of the Linux flow to <b>WAITING</b> and ask the system sheduler to wake them up when some event occurs (but not later than after a certain period of time, if the flow is responsible). <br><br><h4>  <font color="darkred">Thread scheduling at OS level</font> </h4>  Well, it's time to get into the linux kernel and see how the scheduler works there.  The linux sources are known to be in git, and you can clone the scheduler like this: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-rt.git</code> </pre> <br><br>  Let's go to the folder ... Okay, okay, just kidding.  The features of a sheduler in Linux up to the lines in the source code are already too deep for a harmless article, which, let me remind, began with a simple <code>synchronized</code> block :) In order to reduce hardcore, I will tell you how sheaders work in general;  both in linux and in alternative systems.  -   ,    ,  :  ‚Äî  ,      .     ‚Äî <b>quantum</b> ‚Äî  ,     ,   ,   .  linux       ,     10-200 ,      1 .  windows      ,     2-15 ,   ‚Äî  10  15 . <br><br> ,   ,       ,   .    ,   ,   (,   - I/O-),        ,     - .         - .  ,    , ,  -, ,  . <br><br>  ,  , ,   ‚Äî .  ,    ,    ,       ,    ,        ,      . <br><br>   , ,   :       ,  <b> </b> ‚Äî    ,      .  :       ,       ,      -,      . <br><br>     ,      ,  ,     .   ,   contention,          . </li></ol><br><br><h2> <font color="darkgreen">monitorexit</font> </h2><br>    biased locking ,  -,    .  ,   displaced header  NULL,   .   :         biased lock    <code>IllegalMonitorStateException</code> (      -). <br><br>    unbiased locking     <code>InterpreterRuntime::monitorexit</code> .    (,    :     <code>IllegalMonitorStateException</code> )  <code>ObjectSynchronizer::slow_exit</code> ,    ,   <code>fast_exit</code> . <font color="darkgrey">   ,       fast path</font> .        :     <b>stack-locked</b> , <b>inflating</b>  <b>inflated</b> .     :      ,      ,  .     ,  -        . <br><br>         ,   ,    -  ,      .  ,         , , <code>TrySpin</code> (. ).   ,      .   ,   ,    , . <br><br>     , ,     (   <code>Knob_QMode</code> . ,  ,     ,      <code>0</code> ,   . <i>  <sup></sup></i> , , ,  ,  ,    ), ,   .    ,   ,   ,    .         -  <code>os::PlatformEvent::unpark()</code> ,      . ,  linux  bsd  <code>pthread_cond_signal</code> . <br><br> ,       ,   ,      . <br><br><h1> <font color="darkred">NB: <code>synchronized</code> -</font> </h1><br>       java-   : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Do something }</span></span></code> </pre><br>  -     : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre><br><br>  <code>bytecodeInterpreter.cpp</code> <code>synchronized</code> - ,    <code>767</code> .    <code>if (METHOD-&gt;is_synchronized())</code> .        <code>if</code> -,   biased locking.    ,        <code>monitorenter</code> .    ,  ,    ,       ( CAS)  biased  -. <br><br> ,         ,   synchronized. <br><br><h1> <font color="darkred">Wait  notify</font> </h1><br>        <code>synchronizer.cpp</code> ,   377 .   wait/notify      inflated,  ,     ‚Äî inflate' .       <code>wait</code>  <code>notify</code> . <br><br>     wait set (   )     ,       ( ,   ;    -  notify). <br><br> <code>Notify</code>    wait set     ,    ,  -    ,    . <code>NotifyAll</code>   ,    wait set . <br><br><h1> <font color="darkred">Memory effects</font> </h1><br> ,    JMM, ,    <i>happens-before</i>     .   thin   CAS-;   inflated     <code>OrderAccess::fence();</code>  .    biased,  ,      :      program order   .  revoke HB     monitorexit,    , (    thin,  inflated),   enter (    thin,  inflated). <br><br>     wait   fence,   HB. <br><br><h1> <font color="darkred">   .</font> aka Disclaimer </h1> <i>   <sup></sup></i> ,    ,   . ,  JIT     .        . ,    ,      ¬´  hotspot¬ª   ,    . <br><br><h1> <font color="darkred">Stay tuned</font> </h1>   ,   ,    <b>memory barriers</b> ,      <i>happens-before</i>  JMM.       <code>volatile</code> ,      .      final-   ,     <a href="https://habrahabr.ru/users/theshade/" class="user_link">TheShade</a>  <a href="https://habrahabr.ru/users/cheremin/" class="user_link">cheremin</a>  <a href="http://habrahabr.ru/post/143390/"></a> <a href="http://cheremin.blogspot.com/2012/05/unsafe-publication.html"></a> ,        ( <a href="https://twitter.com/"> </a> ). , ,    <b>PrintAssembly</b>   ,    ,     JIT. <br><br><h1> <font color="darkred">And one more thing ¬©</font> </h1>   :    <a href="http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/rev/144f8a1a43cb">144f8a1a43cb</a>  jdk7u.    ,       ‚Äî .. <br><br> Biased locking       ,   <code>BiasedLockingStartupDelay</code>  (4000  ).  ,         ,          safepoints,   revoke bias   . <br><br>   safepoint   <code>ObjectSynchronizer::deflate_idle_monitors</code> ,      ,   . <br><br>    <a href="https://habrahabr.ru/users/theshade/" class="user_link">TheShade</a> , <a href="https://habrahabr.ru/users/artyushov/" class="user_link">artyushov</a> , <a href="https://habrahabr.ru/users/cheremin/" class="user_link">cheremin</a>  <a href="https://habrahabr.ru/users/alexeytokar/" class="user_link">AlexeyTokar</a>  ,   (|)   ,   ,         - ,     . </div><p>Source: <a href="https://habr.com/ru/post/143237/">https://habr.com/ru/post/143237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143230/index.html">Is it worth it for a developer to spend time on additional training not related to his direct work?</a></li>
<li><a href="../143231/index.html">Building effective business systems. Chapter 2.1 Business Processes: Vocabulary. Stream approach. Business and pipelines</a></li>
<li><a href="../143232/index.html">Video from conference # MBLT12</a></li>
<li><a href="../143234/index.html">Yandex.Disk opens API</a></li>
<li><a href="../143235/index.html">EU law on cookies</a></li>
<li><a href="../143238/index.html">Innovation or</a></li>
<li><a href="../143239/index.html">Errors of technology transfer ‚Ññ1 / "Individualization errors"</a></li>
<li><a href="../143240/index.html">The European Court decided that copyright could not apply to programming languages.</a></li>
<li><a href="../143241/index.html">Inbox.py: the simplest SMTP server</a></li>
<li><a href="../143243/index.html">WebBrowser filling the file type field in Delphi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>