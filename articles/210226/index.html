<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analyzing the source code with cppcheck</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the light of many recent articles devoted to static analysis of C ++ code, users have repeatedly been interested in the cppcheck analyzer. This is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analyzing the source code with cppcheck</h1><div class="post__text post__text-html js-mediator-article">  In the light of <a href="http://habrahabr.ru/company/infopulse/blog/209984/">many</a> <a href="http://habrahabr.ru/company/pvs-studio/blog/208920/">recent</a> <a href="http://habrahabr.ru/company/pvs-studio/blog/209286/">articles</a> devoted to static analysis of C ++ code, users have repeatedly been interested in the <a href="http://cppcheck.sourceforge.net/">cppcheck</a> analyzer.  This is a relatively young project of open source static analysis, aimed primarily at finding real errors in the code with a minimum number of false positives. <br><br>  More recently, cppcheck <a href="http://cgit.freedesktop.org/xorg/lib/libXfont/commit/%3Fid%3D4d024ac10f964f6bd372ae0dd14f02772a6e5f63">helped</a> find a vulnerability in the Xorg project that has existed there for almost 23 years!  He has already helped thousands of programmers around the world, on the official website you can find information about vulnerabilities <a href="http://sourceforge.net/apps/mediawiki/cppcheck/index.php%3Ftitle%3DFound_bugs">found</a> with cppcheck in programs, and this list is constantly growing.  So, if you want to know why <u>you need to</u> use cppcheck anytime, anywhere, please request cat. <br><a name="habracut"></a><br><h4>  Cppcat and cppcheck </h4><br>  I will begin by comparing these utilities, since this request was voiced repeatedly in the comments.  The CppCat developers have already independently <a href="http://www.viva64.com/en/b/0149/">conducted</a> such a comparison (with PVS-Studio), but since then much water has flowed, and the comparison is not very objective, since PVS-Studio (as far as I understand the whole intricacy of the phrase ‚ÄúPlease write us to get a price for PVS "Studio. Please specify interesting license type.") Is not intended for single programmers.  CppCat, like cppcheck, <s>is available to everyone</s> (with the reservation to bind to VisualStudio certain versions and a license for a year). <br><br>  It will not be easy to compare these analyzers: I do not have a single version of Visual Studio under Linux at hand.  Therefore, at first, I will limit myself to analyzing the already analyzed code <a href="http://habrahabr.ru/company/infopulse/blog/209984/">in a recent review of CppCat</a> : I set cppcheck on Notepad ++, I‚Äôll give errors / warnings statistics that can be compared with the ready-made CppCat analysis. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In parallel, I try to install CppCat in a virtual machine.  I must say that after Visual Studio 2010 was installed, the installer, without thinking twice, issued the following: <br><br><img src="http://dropi.ru/mFF.png" alt="image"><br><br>  Because of this, testing has become more difficult with a quest to find-put-Visual-Studio-2013-reinstall-IE-11-reboot-update, which on the virtual machine not burdened with updates took exactly half a day. <br><br>  What is the result?  When you open the project Notepad ++ Visual Studio hung up proudly.  An attempt to create a new project resulted in errors in the analysis of CppCat about header files not found.  By this we have to compare with what we have in the previous article.  Although I put Visual Studio almost for the first time, the ‚Äúusability‚Äù effect is obvious. <br><br><h5>  Training </h5><br>  Since cppcheck is an open source project, no one bothers to download the latest version from the <a href="https://github.com/danmar/cppcheck/">git</a> and compile it yourself.  Cppcheck is designed for developers, so compiling a program from source code should not cause any problems: <br><pre><code class="bash hljs">unzip cppcheck-master.zip <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> cppcheck-master make</code> </pre> <br>  Is done.  I deliberately took a fresh version of the gita and put it in a separate folder - it will be easier to work with it, since in the future cppcheck can be greatly improved and customized "for yourself." <br><br>  Test configuration: RHEL 6.1, i5-2400 @ 3.10GHz processor (for estimating the analyzer operation time). <br><br>  Convenience for the sake of action will be made on the command line - if desired, they can be repeated (in Linux :).  Of course, cppcheck has several plugins for popular IDEs, but this is not what is today. <br><br><h5>  Analysis Notepad ++ </h5><br>  cppcheck is designed so that all warnings are sorted by category.  By default, only one type of analysis is enabled ‚Äî error.  Errors cannot be ignored, since if cppcheck issued an error, this place will have to be rewritten in 99% of cases.  The main catch of cppcheck is memory leaks and buffer overflow, and this is already worth something. <br><br>  A reasonable question may arise - how to analyze notepad ++ in the Linux operating system, if notepad ++ uses only WInAPI?  The answer is simple - cppcheck in my memory is the only analyzer that is <u>not tied to the build environment or operating system</u> .  It uses its lexical analyzer, does not require the presence of all header files, loyally refers to the intricacies of classes, etc. This remarkable property allows you to use cppcheck anywhere and for anything, which cannot be said about CppCat (see the installation quest above) . <br><br>  Analysis using cppcheck is simple to ugliness: <br><pre> <code class="bash hljs">./cppcheck-master/cppcheck -q -j4 npp.6.5.3.src/</code> </pre><br>  While the simplest out-of-the-box analysis is being conducted.  The command defines two parameters -q (‚Äúsilent‚Äù mode - do not display progress on the screen) and -j4 - multi-stream analysis in 4 threads by the number of processor cores. <br><br>  The result of the previous command: <br><pre> <code class="bash hljs">[npp.6.5.3.src/PowerEditor/src/tools/ChangeIcon/ChangeIcon.cpp:214]: (error) Mismatching allocation and deallocation: resData [npp.6.5.3.src/PowerEditor/src/tools/ChangeIcon/ChangeIcon.cpp:216]: (error) Mismatching allocation and deallocation: resData [npp.6.5.3.src/scintilla/lexers/LexBash.cxx] -&gt; [npp.6.5.3.src/scintilla/lexers/LexBash.cxx:194]: (error) Internal error. Token::Match called with varid 0. Please report this to Cppcheck developers</code> </pre><br>  Opening hours - 5 minutes.  The error "(error) Internal error. Token :: Match called with varid 0 immediately catches your eye. Please report this to Cppcheck developers".  This means that instead of a bug in the program being analyzed, there was a bug in the analyzer itself :) Let's make a discount on the fact that the project is sharpened for Win, and cppcheck does not suspect what DWORD, LPTR, etc. means. In Win, it will show itself differently . <br><br>  Actually there was only one error (with a difference of 2 lines).  Not bad, it is possible that the author of notepad ++ uses cppcheck itself.  The section of code that caused suspicion in cppcheck: <br><br><pre> <code class="cpp hljs"> BYTE* resData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE[cbRes]; LPBYTE writePtr = resData; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!UpdateResource(hUpdate, RT_GROUP_ICON, lpResName, resLangId, resData, cbRes)) { _tprintf(_T(<span class="hljs-string"><span class="hljs-string">"Unable to update icon group\n"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> resData; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } IFDEBUG( _tprintf(_T(<span class="hljs-string"><span class="hljs-string">"Updated group %d (lang %d)\n"</span></span>), lpResName, resLangId); ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> resData; }</code> </pre><br><br>  <s>This looks like a false positive, although the source is, frankly, shocking.</s>  UPD: it‚Äôs still undefined behavior, the array needs to be freed with the help of the delete [] operator. <br><br>  But that is not all.  The fact is that the motto of cppcheck is the absence of false positives, that is, by default the scanner only looks for very critical errors - buffer overflow, memory leaks.  After all errors are found, you can re-scan by turning on warning flags: <br><br><pre> <code class="bash hljs">./cppcheck-master/cppcheck -q -j4 --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>=performance,portability,warning,style npp.6.5.3.src/ 2&gt; npp.out</code> </pre><br><br>  The --enable parameter is used, which includes the categories of checks: <br><br>  - performance - performance problems; <br>  - portability - compatibility issues; <br>  - warning - warnings - suspicious places of the program; <br>  - style - programming style errors. <br><br>  In this mode, the lion's share of stylistic / logical errors and potential bugs is caught (i.e., errors in which cppcheck is ‚Äúnot sure‚Äù).  Scanning time - 5 minutes.  I immediately sent the result to a file to collect statistics. <br><br>  Total messages: <br><pre> <code class="bash hljs">wc -l &lt; npp.out 379</code> </pre><br><br>  Small statistics on the type of errors found: <br><pre> <code class="bash hljs">tr <span class="hljs-string"><span class="hljs-string">'()'</span></span> <span class="hljs-string"><span class="hljs-string">'*'</span></span> &lt; npp.out | cut -d* -f2 | sort | uniq -c 3 error 39 performance 14 portability 211 style 112 warning</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Message statistics</b> <div class="spoiler_text"><pre> <code class="bash hljs">sort -t] -k2 npp.out | grep -v <span class="hljs-string"><span class="hljs-string">'(error)'</span></span> | cut -d\) -f2- | sed <span class="hljs-string"><span class="hljs-string">"s/'[^']*'/%{VAR}/g"</span></span> | sort | uniq -c | sort -n 1 Function parameter %{VAR} should be passed by reference. 1 memset() called to fill 0 bytes of %{VAR}. 1 scanf without field width limits can crash with huge input data. 1 The class %{VAR} does not have a constructor. 1 Unused variable: ent 1 Unused variable: loc 2 Array index %{VAR} is used before limits check. 2 Checking <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unsigned variable %{VAR} is less than zero. 2 Found duplicate branches <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> %{VAR} and %{VAR}. 2 The class %{VAR} defines member variable with name %{VAR} also defined <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> its parent class %{VAR}. 2 Unsigned variable %{VAR} can<span class="hljs-string"><span class="hljs-string">'t be negative so it is unnecessary to test it. 2 %{VAR} should return %{VAR}. 3 scanf without field width limits can crash with huge input data on some versions of libc. 4 Same expression on both sides of %{VAR}. 4 %{VAR} does not have a copy constructor which is recommended since the class contains a pointer to allocated memory. 5 Assignment of function parameter has no effect outside the function. 5 Ineffective call of function %{VAR}. Did you intend to call %{VAR} instead? 7 Consecutive return, break, continue, goto or throw statements are unnecessary. 11 Exception should be caught by reference. 11 The extra qualification %{VAR} is unnecessary and is considered an error by many compilers. 12 Variable %{VAR} is reassigned a value before the old one has been used. 22 Variable %{VAR} is assigned a value that is never used. 26 Variable %{VAR} is assigned in constructor body. Consider performing initialization in initialization list. 42 C-style pointer casting 98 Member variable %{VAR} is not initialized in the constructor. 108 The scope of the variable %{VAR} can be reduced.</span></span></code> </pre><br></div></div><br><br>  Only 28 unique messages. <br><br>  The messages ‚ÄúThe scope of the variable% {VAR} can be reduced‚Äù, ‚ÄúC-style pointer casting‚Äù, ‚ÄúVariable% {VAR} is assigned in constructor body.‚Äù Can be not considered - these are stylistic recommendations that are very characteristic of many projects written on old pros. <br><br>  A sea of ‚Äã‚Äãvariables is not initialized in the constructor: ( <b>warning</b> ) Member variable% {VAR} is not initialized in the constructor.  This error cppcheck considers a warning.  Perhaps the behavior of such code depends on the compiler, because npp works by some miracle. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//[npp.6.5.3.src/PowerEditor/src/WinControls/AnsiCharPanel/ansiCharPanel.h:46]: (warning) Member variable 'AnsiCharPanel::_ppEditView' is not initialized in the constructor. class AnsiCharPanel : public DockingDlgInterface { public: AnsiCharPanel(): DockingDlgInterface(IDD_ANSIASCII_PANEL) {}; void init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView) { DockingDlgInterface::init(hInst, hPere); _ppEditView = ppEditView; }; virtual void display(bool toShow = true) const { DockingDlgInterface::display(toShow); }; void setParent(HWND parent2set){ _hParent = parent2set; }; void switchEncoding(); void insertChar(unsigned char char2insert) const; protected: virtual BOOL CALLBACK AnsiCharPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam); private: ScintillaEditView **_ppEditView; ListView _listView; };</span></span></code> </pre><br>  The initialization of the variable is not in the constructor, but in the init function, so in my opinion the case matters. <br></div></div><br><br>  ( <b>style</b> ) Same expression on both sides of '||'.  Check the same condition.  CppCat produced the same error, however, either the version of npp is old in the article, or the error has already been fixed, but now that code looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (closeFound.success &amp;&amp; (styleAt == SCE_H_DOUBLESTRING || styleAt == SCE_H_SINGLESTRING) &amp;&amp; searchStartPoint &lt;= caret);</code> </pre><br><br>  And this is the new booty cppcheck: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(!commentLineSybol || !commentLineSybol[<span class="hljs-number"><span class="hljs-number">0</span></span>] || commentLineSybol == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>))</code> </pre><br><br>  ( <b>performance</b> ) Variable 'lineIndent' is reassigned a value before the old one has been used.  In fact - double assignment.  This is usually a consequence of copy-paste, but cppckeck characterizes such an error as a performance error.  This code is worth checking, since it is not known what the author of the program meant.  There are a lot of such double assignments, as well as unused values ‚Äã‚Äãof variables by code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineIndent = lineStart; ... lineIndent = _pEditView-&gt;execute(SCI_GETLINEINDENTPOSITION, i); _pEditView-&gt;getGenericText(linebuf, linebufferSize, lineIndent, lineEnd);</code> </pre><br><br>  This warning is usually useless - rarely, when there is an error in this part of the code, just forgot to delete the old value during refactoring. <br><br>  ( <b>portability</b> ) The extra qualification 'FunctionListPanel ::' is unnecessary.  A useful warning that is not physically present and is not planned in CppCat: portability errors between different platforms (portability).  This piece of code will not work in all compilers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> BOOL CALLBACK FunctionListPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam);</code> </pre><br><br>  This ‚Äúpolitically correct‚Äù message actually means that the code will not gather without crutches in the gcc compiler.  If you plan to run the application on more than one platform - cppcheck will be a good help. <br><br>  ( <b>style</b> ) Exception should not be caught by reference.  An interesting warning is <a href="http://stackoverflow.com/questions/2522299/c-catch-blocks-catch-exception-by-value-or-reference">to catch an exception by reference</a> , not by value: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception e) { ::MessageBoxA(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, e.what(), <span class="hljs-string"><span class="hljs-string">"Exception"</span></span>, MB_OK); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br><br>  ( <b>style</b> ) Consecutive return, break, continue, goto or throw statements are unnecessary.  Dead code: break after return: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(lpnm-&gt;wID) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REBAR_BAR_TOOLBAR: { ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  ( <b>warning</b> ) There is no effect outside the function.  Usually this is a useful warning signaling a typo - the value assigned inside the function is not transmitted anywhere.  However, here this is obviously a false positive, since value is a class variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TCHAR* _value )</span></span></span><span class="hljs-function"> </span></span>{ value = _value; }</code> </pre><br><br>  It can be used for data.  Such a habit of using scanf can lead <a href="http://cgit.freedesktop.org/xorg/lib/libXfont/commit/%3Fid%3D4d024ac10f964f6bd372ae0dd14f02772a6e5f63">to a dangerous buffer overflow</a> .  In the case of numeric variables, this is a trivial undefined behavior: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>( value.c_str(), <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, ival ) == <span class="hljs-number"><span class="hljs-number">1</span></span> )</code> </pre><br><br>  To convert numbers it is better to use a safe strtol. <br><br>  Another representative: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>( wordBuffer, <span class="hljs-string"><span class="hljs-string">"%[^.&lt;&gt;|&amp;=\\/]"</span></span>, sKeywordBuffer );</code> </pre><br><br>  There is no buffer overflow just because the wordBuffer and sKeywordBuffer are the same size. <br><br>  ( <b>style</b> ) 'TiXmlStringA :: operator =' should return 'TiXmlStringA &amp;'.  Operator = returns void: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TiXmlStringA &amp; copy);</code> </pre><br>  With such an operator, you cannot use the standard C ++ chain: <br><pre> <code class="cpp hljs">a = b = c;</code> </pre><br><br>  ( <b>warning</b> ) The class 'ControlsTab' defines a member variable with name '_isVertical' also defined in its parent class 'TabBar'.  Error of double definition of a variable in a class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControlsTab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TabBar { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _isVertical; };</code> </pre><br>  which is already defined in the parent class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabBar</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Window { ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _isVertical; };</code> </pre><br>  Not being an expert in the pros, I can not immediately answer whether it is possible to do so (protected / private). <br><br>  ( <b>style</b> ) Found duplicate branches for 'if' and 'else'.  Similar errors found and CppCat.  Extra condition: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eol_mode == SC_EOL_CRLF) extraEOLLength = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eol_mode == SC_EOL_LF) extraEOLLength = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// SC_EOL_CR extraEOLLength = 1;</span></span></code> </pre><br><br>  ( <b>style</b> ) Checking if unsigned variable 'lenFile' is less than zero.  A similar message was issued by CppCat, except that cppcheck, without finding the windows.h file, did not begin to build hypotheses about types like WPARAM.  There is a lack of non-orientation exclusively on Windows. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> lenFile = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lenFile &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><br>  I think if I had the Windows header files, you can specify the path to them through the -I parameter, then there will be much more errors. <br><br>  ( <b>style</b> ) Array index 'j' is used before limits check.  Despite the fact that the warning is of low priority, the error found represents the danger of going beyond the array: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ReturnValue; j=startcol; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(direction == <span class="hljs-number"><span class="hljs-number">1</span></span>){j++;} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(direction != <span class="hljs-number"><span class="hljs-number">1</span></span>){j--;} <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((BGHS[SI].columnwidths[j] == <span class="hljs-number"><span class="hljs-number">0</span></span>)&amp;&amp;(j&lt;=BGHS[SI].cols)&amp;&amp;(j&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre><br>  Given that the startcol parameter is external, you can fly out of the array, not to mention the index -1. <br><br>  ( <b>style</b> ) Unsigned variable "i can't be negative so it is unnecessary to test it.  The condition in the loop is always positive =&gt; infinite loop: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = position_of_click; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --i)</code> </pre><br>  This error could have been avoided when building a project with the gcc compiler and -Wall -Wextra flags.  I think that such an error often appears when a project is refactored by another compiler error - a type mismatch.  It was int - it became unsigned, and that's the result <br><br><h5>  Minor bugs </h5><br>  ( <b>style</b> ) Unused variable: ent.  Compilers are able to issue this warning, nothing interesting. <br><br>  ( <b>warning</b> )% d in format string (no. 2) requires' int 'but this argument is a DWORD {aka unsigned long}' is a very popular error, programmers in printf write a type that does not match the type of the variable.  This is also shot by most compilers. <br><br>  Class without constructor: <br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachedValue</span></span></span><span class="hljs-class"> {</span></span> generic_string fullname; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; };</code> </pre><br><br>  ( <b>performance</b> ) Function parameter 'range' should not be passed by reference.  cppcheck recommends passing a parameter by reference to avoid copying the argument: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">XYScrollPosition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XYScrollToMakeVisible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SelectionRange range, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> XYScrollOptions options)</span></span></span></span>;</code> </pre><br><br>  ( <b>warning</b> ) Ineffective call of function 'empty ()'.  Did you intend to call 'clear ()' instead?  The empty method only makes sense inside the condition and does not clear the string.  This is a false positive, cppcheck did not realize that the author would make his String class :) You should check the logic of naming methods. <br><br>  ( <b>style</b> ) 'class ByteArray' doesn‚Äôt have to be a copy constructor.  cppcheck simply recommends creating a missing copy constructor in a class in case the programmer forgot to implement it. <br><br><h4>  Conclusion </h4><br>  Both analyzers picked up a decent amount of errors, and many of them are unique to each analyzer.  In general, it would be nice to have cppcheck on hand always, since it is open, cross-platform, it really finds errors and helps to improve the programming style.  Using cppcheck is usually not a problem. <br><br>  From this analysis, we can conclude that the tools complement each other well.  For someone, the main disadvantage of cppcheck is the lack of a plug-in under Visual Studio, so the authors of cppcheck kindly suggest trying PVS-Studio.  Despite the command line interface, using cppcheck is very convenient.  No compiler, no IDE, no header files are required - this is the easiest to use static analyzer I've ever seen.  In addition, I specifically installed the cppcheck for Windows assembly in a virtual machine - it has a nice graphical interface, it installs quickly and performs analysis without any problems: <br><br><img src="http://dropi.ru/DFF.png" alt="image"><br><br>  The result of the analysis can be exported to XML and viewed in the browser. <br><br>  Both projects should wish success in development - these are really very necessary programs.  And in the development of cppcheck, you can take part on your own right now: check your projects, write to the cppcheck developer about errors found or not found, report bugs, send useful patches <a href="https://github.com/danmar/cppcheck">to github</a> .  If cppcheck could not yet find the error if (malloc ()), now it just pours messages about memory leaks - the result of the competition is obvious. <br><br>  This analysis could be greatly improved if we explicitly tell cppcheck where to look for header files, which functions allocate and free memory.  Since the article turned out to be big, how to set up cppcheck for a specific project, improve the quality of analysis and write your own rules for cppcheck next time. <br><br>  PS Please forgive one nonsense.  Cppcheck has the ability to analyze the code specifically for Windows in the settings, which is why a lot of interesting errors were missed.  It was necessary to analyze the npp with the --platform = win32A flag. </div><p>Source: <a href="https://habr.com/ru/post/210226/">https://habr.com/ru/post/210226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210212/index.html">Engineer Diploma or How to deliver a piece of Mars to Earth</a></li>
<li><a href="../210218/index.html">Enabling PostgreSQL replication on Jelastic platform in InfoboxCloud cloud</a></li>
<li><a href="../210220/index.html">Qualcomm bought out patents for webOS, iPAQ from HP</a></li>
<li><a href="../210222/index.html">LinkMeUp. Release 11. Cisco TAC, CEF, FIB</a></li>
<li><a href="../210224/index.html">IPv6 theory and practice: packet types and autoconfiguration</a></li>
<li><a href="../210228/index.html">We make web sites for PHP from scratch. Part 2. IPC</a></li>
<li><a href="../210234/index.html">We consider likes in real life or how to properly evaluate an employee (concept)</a></li>
<li><a href="../210236/index.html">Pavel Durov sold his stake in VK. Now officially</a></li>
<li><a href="../210238/index.html">Four methods for downloading images from a website using Python</a></li>
<li><a href="../210240/index.html">How statistics help make Yandex.Probki better</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>