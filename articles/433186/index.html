<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>It is not enough to count polygons to optimize 3D models.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having dealt with the basics of the mesh rendering process, you can use various techniques to optimize the rendering speed. 

 Introduction 
 How many...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>It is not enough to count polygons to optimize 3D models.</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png" alt="image"></div><br>  Having dealt with the basics of the mesh rendering process, you can use various techniques to optimize the rendering speed. <br><br><h2>  Introduction </h2><br>  How many polygons can I use?  This is a very common question that artists ask when creating models for real-time rendering.  This question is difficult to answer, because it is not only in numbers. <br><br>  I started my career as a 3D artist in the era of the first PlayStation, and later became a graphics programmer.  I would like to read this article before I first started creating 3D models for games.  The fundamentals discussed in it will be useful to many artists.  Although most of the information in this article will not significantly affect the productivity of your daily work, it will give you a basic understanding of how the graphics processing unit (GPU) draws the meshes you create. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The number of polygons in the mesh usually depends on the speed of its rendering.  However, despite the fact that the number of polygons often correlates with the frame rate per second (FPS), you may find that even after reducing the number of polygons, the mesh is still rendered slowly.  But having understood how the meshes are rendered as a whole, you will be able to apply a set of techniques to increase the rendering speed. <br><a name="habracut"></a><br><h2>  How are polygon data presented </h2><br>  To understand how the GPU draws polygons, you must first consider the data structure used to describe polygons.  A polygon consists of a set of points, called vertices, and links.  Vertices are often stored as arrays of values, for example, like Figure 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/cb1/c94/4ffcb1c945c51025a430d752e475b1c3.png"></div><br>  <i>Figure 1. Array of simple polygon values.</i> <br><br>  In this case, four vertices in three dimensions (x, y, and z) give us 12 values.  To create polygons, the second array of values ‚Äã‚Äãdescribes the vertices themselves, as shown in Figure 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/1c9/3eb/01d1c93eb3645689d0d30de75b0ea524.png"></div><br>  <i>Figure 2. Array of links to vertices.</i> <br><br>  These vertices, joined together, form two polygons.  Notice that two triangles, each with three angles, can be described by four vertices, because vertices 1 and 2 are used in both triangles.  In order for this data to be processed by the GPU, it is assumed that each polygon is triangular.  GPUs expect you to work with triangles, because they are designed to render them.  If you need to draw polygons with a different number of vertices, then you need an application that divides them into triangles before drawing to the GPU.  For example, if you create a cube of six polygons, each of which has four sides, then it is no more efficient than creating a cube of 12 polygons consisting of three sides;  these triangles will draw the GPU.  Remember the rule: you need to count not polygons, but triangles. <br><br>  The vertex data used in the previous example is three-dimensional, but this is optional.  Two dimensions may be enough for you, but it is often necessary to store other data, for example, UV coordinates for textures and normals for lighting. <br><br><h2>  Polygon drawing </h2><br>  When drawing a polygon, the GPU first determines where to draw the polygon.  To do this, it calculates the position on the screen where there should be three vertices.  This operation is called transform.  These calculations in the GPU are performed by a small program called the ‚Äúvertex shader‚Äù. <br><br>  The vertex shader often performs other types of operations, such as animation processing.  After calculating the positions of all the vertices of the polygon, the GPU calculates which pixels are in this triangle, and then starts filling those pixels with another small program called the fragment shader.  The fragment shader is usually executed once per pixel.  However, in some rare cases, it can be performed several times per pixel, for example, to improve anti-aliasing.  Fragment shaders are often called pixel shaders, because in most cases, fragments correspond to pixels (see Figure 3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/5e6/4cc/16c5e64cc4daec8ceef7264fce4b8a08.png"></div><br>  <i>Figure 3. One polygon drawn on the screen.</i> <br><br>  Figure 4 shows the order of actions performed by the GPU when drawing a polygon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/c60/8d2/87cc608d2ac63afc4c818b824bc11fb5.png"></div><br>  <i>Figure 4. The procedure for GPU rendering a polygon.</i> <br><br>  If you divide the triangle into two and draw both triangles (see Figure 5), then the procedure will be in accordance with Figure 6. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/34a/521/19a34a521bdd7ace482a8a1defb8c926.png"></div><br>  <i>Figure 5. Dividing a polygon into two.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/16c/07c/d0c16c07ce793e36aaa40e237ad60d78.png"></div><br>  <i>Figure 6. The procedure for a GPU that draws two polygons.</i> <br><br>  In this case, it takes two times more transformations and preparations, but since the number of pixels remains the same, the operation does not need to rasterize additional pixels.  This shows that doubling the number of polygons does not necessarily double the rendering time. <br><br><h2>  Using Vertex Cache </h2><br>  If you look at the two polygons from the previous example, you can see that they have two common vertices.  We can assume that these vertices will have to be computed twice, but a mechanism called vertex cache (vertex cache) allows you to use the results of calculations again.  The results of the vertex shader calculations for reuse are stored in the cache - a small memory area containing the last few vertices.  The procedure for drawing two polygons using the vertex cache is shown in Figure 7. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/272/d4a/4f0272d4aed10e3805af75688282cdc2.png"></div><br>  <i>Figure 7. Drawing two polygons using the vertex cache.</i> <br><br>  Thanks to the vertex cache, you can draw two polygons almost as quickly as one if they have common vertices. <br><br><h2>  Understanding the vertex parameters </h2><br>  In order for a vertex to be reused, it must be constant at every use.  Of course, the position should remain the same, but other parameters should not change either.  The parameters passed to the top depend on the engine used.  Here are two common parameters: <br><br><ul><li>  Texture coordinates </li><li>  Normals </li></ul><br>  When UV-imposing on a 3D object, any created seam will mean that the vertices along the seam cannot be shared.  Therefore, in general, seams should be avoided (see Figure 8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8b/75d/854/c8b75d85471cc476ba6e6f8a9425c7a7.png"></div><br>  <i>Figure 8. UV suturing texture.</i> <br><br>  For proper illumination of the surface, each vertex usually stores a normal ‚Äî a vector directed from the surface.  Due to the fact that all polygons with a common vertex are defined by one normal, their shape seems to be smooth.  This is called smooth shading.  If each triangle has its own normals, then the edges between the polygons become pronounced, and the surface appears flat.  Therefore, this is called flat shading.  Figure 9 shows two identical meshes, one with smoothed shading, and the other with a flat one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/379/ee3/41f/379ee341f3720b32dba0d4b753c88b98.png"></div><br>  <i>Figure 9. Comparison of smooth with flat shading.</i> <br><br>  This geometry with smoothed shading consists of 18 triangles and has 16 common vertices.  For flat shading of 18 triangles, 54 (18 x 3) vertices are needed, because none of the vertices is common.  Even if two meshes have the same number of polygons, the speed of their drawing will still be different. <br><br><h2>  Importance of form </h2><br>  GPUs work fast mainly because they can perform multiple operations in parallel.  GPU marketing materials often focus on the number of their pipelines (pipeline), which determine the number of operations that a GPU can perform at the same time.  When the GPU renders the polygon, it gives the task to fill the squares of pixels to multiple pipelines.  This is usually an eight by eight pixel square.  The GPU continues to do this until all the pixels are filled.  Obviously, the triangles are not squares, so some pixels of the square will be inside the triangle, and others outside.  The equipment works with all pixels of a square, even those that are outside the triangle.  After calculating all the vertices in the square, the equipment discards pixels outside the triangle. <br><br>  Figure 10 shows a triangle, which requires three squares (tiles) to be drawn.  Most of the calculated pixels (blue) are used, and those shown in red fall outside the bounds of the triangle and will be discarded. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/c2e/262/74bc2e262019ac7b5f488babc01d7298.png"></div><br>  <i>Figure 10. Three tiles for drawing a triangle.</i> <br><br>  The polygon in Figure 11 with exactly the same number of pixels, but stretched, requires more tiles to fill;  Most of the work results in each tile (red area) will be discarded. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/a9e/286/9d0a9e28607c023f81928ea60c8c386a.png"></div><br>  <i>Figure 11. Filling the tiles in a stretched image.</i> <br><br>  The number of pixels drawn is only one of the factors.  Also important is the shape of the polygon.  To increase efficiency, try to avoid long, narrow polygons and give preference to triangles with approximately equal lengths of sides, the angles of which are close to 60 degrees.  The two flat surfaces in Figure 12 are triangulated in two different ways, but look the same when rendered. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/607/5d0/965/6075d0965cddfabc1a639bc58b476bb1.png"></div><br>  <i>Figure 12. Surfaces triangulated in two different ways.</i> <br><br>  They have exactly the same number of polygons and pixels, but since the surface of the left has longer, narrower polygons than that of the right, its rendering will be slower. <br><br><h2>  Redrawing </h2><br>  To draw a six-pointed star, you can create a mesh of 10 polygons or draw the same shape from just two polygons, as shown in Figure 13. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/86b/dff/55386bdffeaeabbedb9bda0a913f2dda.png"></div><br>  <i>Figure 13. Two different ways of drawing a six-pointed star.</i> <br><br>  You can decide that two polygons are faster than 10. However, in this case, this is most likely wrong, because the pixels in the center of the star will be drawn twice.  This phenomenon is called overdraw.  In essence, it means that pixels are redrawn more than once.  Redrawing occurs naturally throughout the rendering process.  For example, if a character is partially hidden by a column, then it will be drawn entirely, despite the fact that the column overlaps a part of the character.  Some engines use complex algorithms to avoid drawing objects that are invisible in the final image, but this is a difficult task.  It is often harder for the CPU to figure out what not to draw, than the GPU to draw it. <br><br>  When working as an artist, you have to accept the fact that you cannot get rid of redrawing, but it is good practice to remove surfaces that cannot be seen.  If you are collaborating with the development team, then ask to add a debugging mode in the game engine, in which everything becomes transparent.  This will make it easier to find hidden polygons that can be deleted. <br><br><h2>  The implementation of the box on the floor </h2><br>  Figure 14 shows a simple scene: a box on the floor.  The floor consists of only two triangles, and the box consists of 10 triangles.  Redrawing in this scene is shown in red. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/227/ece/c87227ecea93c82e5870a6c68493bd00.png"></div><br>  <i>Figure 14. Standing on the floor box.</i> <br><br>  In this case, the GPU will draw a part of the floor with a box, despite the fact that it will not be visible.  If instead we had created a hole in the floor under the box, we would have received more polygons, but much less redrawing, as can be seen from Figure 15. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/202/1e4/045/2021e4045609645f18c056179196bac0.png"></div><br>  <i>Figure 15. A hole under the box to avoid redrawing.</i> <br><br>  In such cases, it all depends on your choice.  Sometimes it is worth reducing the number of polygons, having received a redraw in return.  In other situations, it is worth adding polygons to avoid redrawing.  Another example: the two figures shown below are equally looking surface meshes with spikes protruding from it.  In the first mesh (Figure 16), the tips are located on the surface. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/436/a65/569436a65cd84150968803a745098129.png"></div><br>  <i>Figure 16. Points are located on the surface.</i> <br><br>  In the second mesh in Figure 17, holes are cut in the surface under the tips to reduce the amount of redrawing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/815/692/9c2815692a63c60b9b13fb027405484c.png"></div><br>  <i>Figure 17. The holes are cut under the tips.</i> <br><br>  In this case, a lot of polygons were added to cut holes, some of which have a narrow shape.  In addition, the redrawing surface, which we got rid of, is not very large, so in this case this technique is ineffective. <br><br>  Imagine you are modeling a house standing on the ground.  To create it, you can either leave the ground unchanged, or cut a hole under the house in the ground.  Redraw more in the case when the hole is not cut under the house.  However, the choice depends on the geometry and the point of view from which the player will see the house.  If you draw the earth under the base of the house, it will create a large amount of redrawing, if you go inside the house and look down.  However, the difference will not be particularly large if you look at the house from an airplane.  In this case, it‚Äôs best to have a debugging mode in the game engine that makes the surfaces transparent so that you can see what is being drawn under the surfaces visible to the player. <br><br><h2>  When Z-buffers have a Z-conflict </h2><br>  When a GPU renders two overlapping polygons, how does it determine which one is on top of the other?  The first computer graphics researchers spent a lot of time researching this problem.  Ed Catmell (who later became president of Pixar and Walt Disney Animation Studios) wrote an article that outlined ten different approaches to this task.  In one part of the article, he notes that the solution to this problem will be trivial if the computers have enough memory to store one value of depth per pixel.  In the 1970s and 1980s, it was a very large amount of memory.  However, today most GPUs work this way: this system is called a Z-buffer. <br><br>  The z-buffer (also known as the depth buffer) works as follows: its value is associated with each pixel.  When the equipment draws an object, it calculates how far away a pixel is drawn from the camera.  It then checks the depth value of an already existing pixel.  If it is farther from the camera than the new pixel, then the new pixel is drawn.  If the existing pixel is closer to the camera than the new one, then the new pixel is not drawn.  This approach solves many problems and works even if the polygons intersect. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png"></div><br>  <i>Figure 18. Intersecting polygons processed by the depth buffer.</i> <br><br>  However, the Z-buffer does not have infinite accuracy.  If the two surfaces are almost the same distance from the camera, then this confuses the GPU and it can randomly select one of the surfaces, as shown in Figure 19. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ec2/2e9/e7fec22e99a74b0147b42bc91bf7be33.png"></div><br>  <i>Figure 19. Surfaces at the same depth display problems.</i> <br><br>  This is called Z-fighting and looks very buggy.  Often, Z-conflicts become worse the farther the surface is from the camera.  Engine developers can build patches in them to smooth out this problem, but if the artist creates reasonably close and overlapping polygons, the problem can still arise.  Another example is a wall with a poster hanging on it.  The poster is almost at the same depth from the camera as the wall behind it, so the risk of Z-conflicts is very high.  The solution is to cut a hole in the wall under the poster.  This also reduces the amount of redrawing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/4e2/536/da14e2536deb1d23b0e2a7b4de57bc33.png"></div><br>  <i>Figure 20. An example of Z-conflict overlapping polygons.</i> <br><br>  In extreme cases, Z-conflict may occur even when objects touch each other.  Figure 20 shows the box on the floor, and since we did not cut a hole in the floor under the box, the z-buffer can be confused near the edge where the floor meets the box. <br><br><h2>  Using draw calls </h2><br>  GPUs have become extremely fast - so fast that CPUs may not keep up with them.  Since GPUs are essentially designed to perform a single task, they are much easier to get to work fast.  Graphics is inherently related to the calculation of a set of pixels, so you can create equipment that calculates a set of pixels in parallel.  However, the GPU renders only what it orders to draw the CPU.  If the CPU cannot quickly ‚Äúfeed‚Äù the GPU with data, then the video card will be idle.  Every time the CPU orders the GPU to draw something, it is called a draw call.  The simplest draw call consists of drawing one mesh, including one shader and one set of textures. <br><br>  Imagine a slow processor capable of transmitting 100 draw calls per frame, and a fast GPU that can draw millions of polygons per frame.  In this case, the ideal draw call can draw 10,000 polygons.  If your meshes consist of just 100 polygons, then the GPU can only draw 10,000 polygons per frame.  That is, 99% of the time the GPU will be idle.  In this case, we can easily increase the number of polygons in the mesh, without losing anything. <br><br>  What the draw call consists of and the cost of it depends heavily on specific engines and architectures.  Some engines can combine many meshes into one draw call (execute their batching, batch), but all meshes will have to have the same shader, or they may have other restrictions.  New APIs like Vulkan and DirectX 12 are designed specifically to solve this problem by optimizing how the program communicates with the graphics driver, thus increasing the number of draw calls that can be sent in one frame. <br><br>  If your team is writing its own engine, then ask the engine developers what limitations the draw calls have.  If you are using a ready-made engine like Unreal or Unity, then perform performance benchmarks to determine the limits of the engine's capabilities.  You may find that you can increase the number of polygons without causing a decrease in speed. <br><br><h2>  Conclusion </h2><br>  I hope this article will serve as a good introduction to help you understand the various aspects of rendering performance.  In GPUs from different manufacturers, everything is implemented a bit differently.  There are many reservations and special conditions associated with specific engines and hardware platforms.  Always maintain an open dialogue with rendering programmers to use their recommendations in your project. <br><br><h2>  about the author </h2><br>  Eskil Steenberg (Eskil Steenberg) - an independent developer of games and tools, he works as a consultant, and on independent projects.  All screenshots are made in active projects using tools developed by Eskil.  You can learn more about his work on the <a href="https://www.quelsolaar.com/" rel="nofollow">Quel Solaar</a> website and in the @quelsolaar account on Twitter. </div><p>Source: <a href="https://habr.com/ru/post/433186/">https://habr.com/ru/post/433186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433176/index.html">Docker Remote API with certificate authentication with revocation checking</a></li>
<li><a href="../433178/index.html">How we recovered a corrupted .wav file</a></li>
<li><a href="../433180/index.html">Solving data type problems in Ruby or Make data reliable again</a></li>
<li><a href="../433182/index.html">Is it possible to train with reinforcements agent for trading in the stock market? R language implementation</a></li>
<li><a href="../433184/index.html">ASP.NET Core 2.2 has been released. What's new? (2 of 3)</a></li>
<li><a href="../433188/index.html">The State Duma submitted a bill on the autonomous work of the RuNet</a></li>
<li><a href="../433192/index.html">Kubernetes: an amazingly affordable solution for personal projects</a></li>
<li><a href="../433194/index.html">Night light with scheduled shutdown</a></li>
<li><a href="../433196/index.html">New Year Gift Guide</a></li>
<li><a href="../433198/index.html">10 dollars on hosting: 20 years ago and today</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>