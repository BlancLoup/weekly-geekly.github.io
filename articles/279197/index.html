<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GF (256) final field and some magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 As a student, I attend classes in cryptography. And of course this course could not ignore the standard AES . 

 When implementing this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GF (256) final field and some magic</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  As a student, I attend classes in cryptography.  And of course this course could not ignore the standard <a href="https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> . <br><br>  When implementing this algorithm, the question arises about the implementation of GF (2 ^ 8) fields, which will be covered in this article.  The following will be considered: bit magic for multiplying field elements, templates for generating tables of substitutions at the compilation stage. <br><br>  The second part assumes that the reader has access to the C ++ 14 compiler.  The first part will be written in the style of C. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">What are the final fields</b> <div class="spoiler_text">  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25B5">https://ru.wikipedia.org/wiki/Top box</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>GF (p) field</b> <br><br>  First consider how a field is formed with a simple number of elements GF (p). <br><br>  Its elements are numbers <img src="https://tex.s2cms.ru/svg/%5C%7B0%2C%201%2C%20...%2C%20p-1%5C%7D" alt="\ {0, 1, ..., p-1 \}">  .  The operations of addition and multiplication - addition and multiplication modulo p. <br><br>  For example, when p = 7: <br><br>  2 + 6 = 8% 7 = 1 <br>  4 * 3 = 12% 7 = 5 <br><br>  <b>GF (p ^ q) field</b> <br><br>  On the basis of the fields GF (p), more general fields GF (p ^ q) are constructed, p is simple, q is natural. <br><br>  The elements of such fields are polynomials over the field GF (p): <br><br><img src="https://tex.s2cms.ru/svg/%5C%7B0%2C%201%2C%202%2C%20%5Cldots%20%2C%20p-1%2C%20x%2C%20%5Cldots%20(p-1)x%2C%20...%20%2C%20x%5E%7Bq-1%7D%2C%20%5Cldots%20%2C%20(p-1)x%5E%7Bq-1%7D%5C%7D" alt="\ {0, 1, 2, \ ldots, p-1, x, \ ldots (p-1) x, ..., x ^ {q-1}, \ ldots, (p-1) x ^ {q -one}\}"><br><br>  Adding in this field will be directly adding the data of polynomials. <br><br>  For example, when p = 2, q = 3: <br><br><img src="https://tex.s2cms.ru/svg/(x%20%2B%201)%20%2B%20(x%5E2%20%2B%201)%20%3D%20(x%5E2%20%2B%20x)" alt="(x + 1) + (x ^ 2 + 1) = (x ^ 2 + x)"><br><br>  Multiplication is a bit more complicated.  In order to define it, a polynomial Q (x) of degree q irreducible over GF (p) is required (there are no two smaller polynomials in the product giving a given).  Fortunately for any p and q such a polynomial exists. <br>  When the polynomial Q (x) is chosen, in order to find the product of two elements of the a * b field, you need: <br><br><ol><li>  Find the product of their polynomials a (x) * b (x) </li><li>  Find the remainder of dividing this product by the polynomial Q (x).  This is a * b </li></ol><br>  For example, when p = 2, q = 3: <br><br>  Q (x) = x ^ 3 + x + 1 (Irreducible polynomial) <br><br>  a = x ^ 2 + 1, b = x ^ 2 <br>  a (x) * b (x) = x ^ 4 + x ^ 2 <br>  (x ^ 4 + x ^ 2)% Q (x) = (x ^ 4 + x ^ 2 - x * Q (x))% Q (x) = (x ^ 3 + x)% Q (x) = (x ^ 3 + x - Q (x))% Q (x) = 1 = a * b <br><br>  When p = 3, q ‚Äã‚Äã= 2: <br><br>  Q (x) = x ^ 2 + x + 2 (Irreducible polynomial) <br><br>  a = x + 2 <br>  b = 2x + 2 <br>  a (x) * b (x) = 2 <em>x ^ 2 + (6% 3) * x + (4% 3) = 2</em> x ^ 2 + 1 <br>  (2 <em>x ^ 2 + 1)% Q (x) = (2</em> x ^ 2 + 1 - 2Q (x))% Q (x) = ((-2% 3) x + (-3% 3))% Q (x) = x% Q (x) = x <br></div></div><br><h2>  Implementation </h2><br>  So, it is required to implement the following operations in the GF (256) field on the polynomial x ^ 8 + x ^ 4 + x ^ 3 + x + 1: <br><br><ol><li>  Multiplication </li><li>  Finding the reverse </li></ol><br>  Let's start with the product of field elements: <br><br>  The first thing that comes to mind is to implement the product of polynomials by a naive algorithm: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> polynomeMul(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b){ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> rez = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; ++i){ rez ^= a * b&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;i) <span class="hljs-comment"><span class="hljs-comment">//    2  b_i * (x^i) * a(x) } return rez; }</span></span></code> </pre> <br>  Then write the function of finding the remainder of the division by a polynomial. <br><br>  At this point, I wondered what would happen next.  And then I was waiting for an advanced Euclidean algorithm for polynomials, and although in fact it is not so bad, it was decided to think.  Is it possible to make it somehow beautiful?  It‚Äôs a pity not to use one operation to multiply two such polynomials, find the remainder of division by another. <br><br>  Is it really impossible?  Let's see what prevents us from realizing the product of polynomials through a simple product. <br><br>  According to the formula for the product of polynomials we have: <br><br><div style="text-align:center;"><img src="//tex.s2cms.ru/svg/(%5Csum_i%20a_i*x%5Ei)%20*%20(%5Csum_i%20b_i*x%5Ei)%20%3D%20%5Csum_i%20%5Csum_%7Bn%3D0%7D%5E%7Bi%7D%20a_n%20b_%7Bi-n%7D%20x%5Ei" alt="(\ sum_i a_i * x ^ i) * (\ sum_i b_i * x ^ i) = \ sum_i \ sum_ {n = 0} ^ {i} a_n b_ {i-n} x ^ i"></div><br><br>  For the product of two numbers in the binary number system, we obtain an almost analogous expression: <br><br><div style="text-align:center;"><img src="//tex.s2cms.ru/svg/(%5Csum_i%20a_i*2%5Ei)%20*%20(%5Csum_i%20b_i*2%5Ei)%20%3D%20%5Csum_i%20%5Csum_%7Bn%3D0%7D%5E%7Bi%7D%20a_n%20b_%7Bi-n%7D%202%5Ei" alt="(\ sum_i a_i * 2 ^ i) * (\ sum_i b_i * 2 ^ i) = \ sum_i \ sum_ {n = 0} ^ {i} a_n b_ {i-n} 2 ^ i"></div><br><br>  The difference is that for polynomials the expression <img src="//tex.s2cms.ru/svg/%5Csum_%7Bn%3D0%7D%5E%7Bi%7D%20a_n%20b_%7Bi-n%7D" alt="\ sum_ {n = 0} ^ {i} a_n b_ {i-n}">  determines the coefficient at <img src="//tex.s2cms.ru/svg/x%5Ei" alt="x ^ i">  . <br><br>  A similar statement for the numbers will not be true due to the fact that in the previous discharge could overflow, changing the value of the considered. <br><br>  How to get rid of overflow?  Very simple.  Consider the following entry: <br><br><div style="text-align:center;"><img src="//tex.s2cms.ru/svg/(%5Csum_i%20a_i*2%5E%7B4i%7D)%20*%20(%5Csum_i%20b_i*2%5E%7B4i%7D)%20%3D%20%5Csum_i%20%5Csum_%7Bn%3D0%7D%5E%7Bi%7D%20a_n%20b_%7Bi-n%7D%202%5E%7B4i%7D" alt="(\ sum_i a_i * 2 ^ {4i}) * (\ sum_i b_i * 2 ^ {4i}) = \ sum_i \ sum_ {n = 0} ^ {i} a_n b_ {i-n} 2 ^ {4i}"></div><br><br>  Since, when multiplying polynomials of degree not higher than 7, a polynomial of degree higher than 14 cannot be obtained, the amount of no more than 15 zeros and ones will correspond to discharge (in fact, it is easy to make sure that it is not more than 8), which means that overflow is impossible.  It remains only to convert the immediate sum to the sum modulo 2, highlighting the lower bit. <br><br>  And so, if we represent a polynomial as a number in which each block corresponds to a block of 4 bits, then the work can be written as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> polynomeMul(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> b){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b) &amp; <span class="hljs-number"><span class="hljs-number">0x1111111111111111</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &amp; 0b0001000100010001... }</span></span></code> </pre><br>  Now we analyze the product as elements of the Galois field. <br><br>  Look at the polynomial <img src="//tex.s2cms.ru/svg/x%5E8%20%2B%20x%5E4%20%2B%20x%5E3%20%2B%20x%20%2B%201" alt="x ^ 8 + x ^ 4 + x ^ 3 + x + 1">  .  In the selected view, it looks like q = 0x100011011.  The naked eye can see a large number of zero blocks immediately after the older block.  When multiplying Q (x) by a polynomial <img src="//tex.s2cms.ru/svg/x%5En(a_0%20%2B%20a_1*x%20%2B%20a_2*x%5E2%20%2B%20a_3*x%5E4)" alt="x ^ n (a_0 + a_1 * x + a_2 * x ^ 2 + a_3 * x ^ 4)">  we get a polynomial: <br><br><div style="text-align:center;"><img src="//tex.s2cms.ru/svg/x%5E%7Bn%2B8%7D(a_0%20%2B%20a_1*x%20%2B%20a_2*x%5E2%20%2B%20a_3*x%5E4)%20%2B%20%5Csum_i%5E%7Bn%2B7%7Db_i%20x%5Ei" alt="x ^ {n + 8} (a_0 + a_1 * x + a_2 * x ^ 2 + a_3 * x ^ 4) + \ sum_i ^ {n + 7} b_i x ^ i"></div><br><br>  or a polynomial whose higher blocks are <img src="//tex.s2cms.ru/svg/a_0%2C%20a_1%2C%20a_2%2C%20a_3" alt="a_0, a_1, a_2, a_3">  .  This is what we will use to write the multiplication function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> galoisMul(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> b){ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> mul = polynomeMul(a, b); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> basePolynome = <span class="hljs-number"><span class="hljs-number">0x100011011</span></span>; mul ^= polynomeMul(basePolynome, mul&gt;&gt;<span class="hljs-number"><span class="hljs-number">48</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   Q(x)      (  4 ),     12   mul ^= polynomeMul(basePolynome, mul&gt;&gt;32); //        8 ,    .         mul. return mul; }</span></span></code> </pre><br>  With the multiplication figured out.  Now you need to learn how to find the inverse element of it. <br><br>  We recall that a field without addition and 0 forms a group of 255 elements.  From this we obtain that for any element x there exists a number r equal to the size of the subgroup formed by this element, such that x ^ r = 1. Since the order of the subgroup is a divisor of the order of the group, <img src="//tex.s2cms.ru/svg/x%5E%7B255%7D%20%3D%20x%5E%7Bkr%7D%20%3D%20(x%5Er)%5Ek%20%3D%201" alt="x ^ {255} = x ^ {kr} = (x ^ r) ^ k = 1">  which in turn gives us that <img src="//tex.s2cms.ru/svg/x%20*%20x%5E%7B254%7D%20%3D%201" alt="x * x ^ {254} = 1">  .  Then, according to the definition of the inverse element, we have <img src="//tex.s2cms.ru/svg/x%5E%7B-1%7D%20%3D%20x%5E%7B254%7D" alt="x ^ {- 1} = x ^ {254}">  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> galoisPow(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> n){ <span class="hljs-comment"><span class="hljs-comment">//    . if(n==0){ return 1; }else if(n%2 == 0){ return galoisPow(galoisMul(a, a), n/2); // (a*a)^(n/2) }else{ uint64_t square = galoisMul(a, a); return galoisMul(galoisPow(square, n/2), a); // a * (a*a)^[n/2] } } uint64_t galoisInverse(uint64_t a){ return galoisPow(a, 254); }</span></span></code> </pre><br>  Everything?  Oh yes, you need to be able to convert the original bytes into an extended form, in which we perform all operations.  This can be done in the forehead cycle, but not today.  The inner voice says you need to use a dirty trick.  In the end, didn't I read the article <a href="https://habrahabr.ru/post/276957/">thoroughly about counting single bits</a> ? <br><br>  Let's denote byte as 0bABCDEFGH.  The first thing that comes to mind is the multiplication by 0b1001001 of the three lower bits: <br><br>  0bFGH * 0b1001001 = 0bFGHFGHFGH <br><br>  0bFGHFGHFGH |  0b100010001 = 0bF000G000H, or three low-order bits fell into place. <br><br>  Similarly, it is done over the middle three bits and the highest pair.  The trick was coined.  But three multiplications are like too much.  Is it possible to do the same thing in 4 bits each?  Having reviewed numerous samples of bits, I managed to find only one of the four that it works with: <br><br><img src="https://habrastorage.org/files/d72/614/72c/d7261472cb414547b8097a66d0e389f6.png" alt="image"><br><br>  Pay attention to the low bits of 7, 6, 1, 0 blocks.  They are characterized by the presence of the desired bit in its place and, equally important, the impossibility of overflow due to the younger (relative to the data) bits. <br><br>  As it was said, I did not find two paired fours bits.  Failure?  Not really.  If we are able to put seven of the eight bits in their places using 2 multiplications, we can put all 8 by hoisting the last into its place by a simple shift. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> extendToGalois(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &amp; <span class="hljs-number"><span class="hljs-number">0xC3</span></span>) * <span class="hljs-number"><span class="hljs-number">0x249249</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0x11000011</span></span> | (a &amp; <span class="hljs-number"><span class="hljs-number">0x1C</span></span>) * <span class="hljs-number"><span class="hljs-number">0x1240</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0x00011100</span></span>| (a &amp; <span class="hljs-number"><span class="hljs-number">0x20</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>; }</code> </pre><br>  With compression back things are easier.  The following multiplication shows how to compress 4 bits: <br><br><img src="https://habrastorage.org/files/6a4/eae/d93/6a4eaed930de4e1dbe3504d94d932e3d.png" alt="image"><br><br>  With this in mind, the code takes the following form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> shrinkFromGalois(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &amp; <span class="hljs-number"><span class="hljs-number">0x11110000</span></span>) * <span class="hljs-number"><span class="hljs-number">0x249</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">21</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0xF0</span></span> | (a &amp; <span class="hljs-number"><span class="hljs-number">0x00001111</span></span>) * <span class="hljs-number"><span class="hljs-number">0x249</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span> &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; }</code> </pre><br><h2>  Let compiler think </h2><br>  Why use rather expensive conversion bytes when you can use a table that has been calculated in advance?  In this section, I will explain how to calculate it at the compilation stage using the magic of patterns using the example of a table of inverse elements by addition. <br><br>  First of all, we <i>‚Äôll</i> add the <i>constexpr qualifier</i> to all previously written functions (from now on, compilation will require support from c ++ 14).  This allows you to use these functions as template arguments. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      contexpr static uint8_t inverse(uint8_t x){ return shrinkFromGalois(GaloisInverse(extendToGalois(x))); } &lt;p&gt;template&lt;int N, int‚Ä¶ Data&gt; class GaloisTable{ public: static constexpr auto&amp; data = GaloisTable&lt;N-1, inverse(N-1), Data‚Ä¶&gt;::data; }&lt;/p&gt; &lt;p&gt;template&lt;int‚Ä¶ Data&gt; class GaloisTable&lt;0, Data‚Ä¶&gt; public: static constexpr uint8_t data[] = {Data‚Ä¶}; }&lt;/p&gt; &lt;p&gt;template&lt;int‚Ä¶ Data&gt; constexpr uint8_t GaloisTable&lt;0, Data‚Ä¶&gt;::data[];&lt;/p&gt;</span></span></code> </pre><br>  Consider what happens when you try to use GaloisTable &lt;256&gt; :: data. <br><br>  The compiler finds the corresponding template specialization, in which data is defined as GaloisTable &lt;255, inverse (255)&gt; :: data.  It, in turn, is defined via GaloisTable &lt;254, inverse (254), inverse (255)&gt; :: data, and so on. <br><br>  At each step, we have a pattern of the form: GaloisTable &lt;m, inverse (m), inverse (m + 1), ..., inverse (255)&gt;.  And so on until m reaches 0. <br><br>  When m reaches 0, the compiler manages to find a more specific pattern specialization (A compiler always prefers a more specific one).  This is where the recursive task of the classes ends and from the sequence in Data ... the array itself is created, borrowed by all previous classes. <br><br>  Data ... this step will be nothing more than inverse (0), inverse (1), ..., inverse (255), which we needed. <br><br>  <b>Conclusion</b> : As a result, I would have killed significantly more time than I would have spent on a naive implementation (however, the majority of them were taken by the article itself).  So when an idea comes to think, it makes sense to think whether to think. <br><br>  Hope this article was helpful. <br><br>  <i>Update:</i> Galua prefix replaced by Galois. </div><p>Source: <a href="https://habr.com/ru/post/279197/">https://habr.com/ru/post/279197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279185/index.html">Review of the book scanner Qidenus SMART book scan 3.0 in the Odessa city archive</a></li>
<li><a href="../279187/index.html">Ixia released intelligent network packet broker - Vision ONE</a></li>
<li><a href="../279189/index.html">Do I need a microscope when connecting ‚Äúpatchcords‚Äù?</a></li>
<li><a href="../279193/index.html">What to read about promising programming languages</a></li>
<li><a href="../279195/index.html">How easy and natural to write a game in 2 years</a></li>
<li><a href="../279199/index.html">Jigsaw puzzle with regular expressions from LinkedIn</a></li>
<li><a href="../279201/index.html">Alternative Website Localization: CDN Mutating Content</a></li>
<li><a href="../279203/index.html">SonataAdminBundle: Creating an Object from a List View (Part 2)</a></li>
<li><a href="../279205/index.html">Militiamen took up whatsapp</a></li>
<li><a href="../279207/index.html">Installing applications in Cach√© using projections</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>