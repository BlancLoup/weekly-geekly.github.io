<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Servo browser engine architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator . Allow me to submit to the court of the habrasoobshchestvo translation of the documentation on the browser engine Servo. This eng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Servo browser engine architecture</h1><div class="post__text post__text-html js-mediator-article">  <i><b>From the translator</b> .</i>  <i>Allow me to submit to the court of the habrasoobshchestvo translation of the documentation on the browser engine Servo.</i>  <i>This engine is developed by the Mozilla community in the Rust language, and is perhaps the largest active project in this language.</i>  <i>This document describes the architecture of the engine, how developers use Rust in conjunction with C ++, and what difficulties they encountered during development.</i>  <i>The original is available in the <a href="https://github.com/servo/servo/wiki/Design">project wiki</a> on github.</i> <br><br>  This is a very superficial overview of the Servo architecture.  Servo remains the prototype, and some parts of the architecture are not yet represented as code.  Some important aspects of the system have not yet been considered in detail. <br><br><h1>  Overview and Goals </h1><br><img src="https://habrastorage.org/files/fbc/312/a35/fbc312a35a2d4463bea50e83fa9175a7.png"><br><a name="habracut"></a><br>  Servo is a research project to develop a new browser engine.  Our goal is to create an architecture that benefits from concurrency and at the same time eliminates common sources of bugs and vulnerabilities associated with incorrect memory management and race conditions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since C ++ is not well suited to prevent these problems, Servo is written in <a href="https://www.rust-lang.org/">Rust</a> , a new language designed specifically to meet the requirements of Servo.  Rust provides a parallel infrastructure based on tasks (task-parallel infrastructure) and a strong type system that provides memory security and freedom from race conditions. <br><br>  When making decisions during design, we give priority to the features of a modern web platform, which boil down to high-performance, dynamic, rich multimedia applications, possibly to the detriment of what cannot be optimized.  We want to know what a fast and responsive web platform is and implement it. <br><br>  Servo clearly does not claim to create a full-fledged browser (except for the needs of the demonstration or experiments).  On the contrary, it aims to create a holistic, embeddable engine.  Although Servo is a research project, it is designed to be usable for real use - the code we write must be of sufficient quality to ultimately reach users. <br><br><h2>  Concurrency and Competitiveness Strategies </h2><br>  Competitiveness is the division of tasks into parts for the alternation of execution.  Parallelism is the simultaneous execution of several parts of work to increase speed.  Some ideas in this direction that we are studying or planning to consider: <br><br><ul><li>  <i>Task based architecture</i> .  The main components of the system should be <br>  presented in the form of actors, with isolated memory, with clear boundaries for the possibility of failure and recovery.  This will also contribute to weak binding of the system components, allowing us to replace them for the purpose of experimentation and research.  Implemented. </li><li>  <i>Competitive rendering</i> .  Rendering and compositing are performed in different streams, separated from the presentation to ensure responsiveness.  The compositing stream manages its own memory to avoid garbage collections.  Implemented. </li><li>  <i>Tile based rendering</i> .  We present the screen as a grid of tiles and draw each of them in parallel.  In addition to the gains from concurrency, tiles are needed for performance on mobile devices.  Partially implemented. </li><li>  <i>Layering rendering</i> .  We divide the display list into subtrees that can be processed by the GPU and rendered in parallel.  Partially implemented. </li><li>  <i>Matching selectors</i> .  This task is surprisingly easy to parallelize.  Unlike Gecko, Servo compares the selectors separately from the construction of the display tree, which is parallelized much easier.  Implemented. </li><li>  <i>Parallel placement</i> .  We build a mapping tree using parallel DOM traversal that takes dependencies based on elements, such as float.  Implemented. </li><li>  <i>Forming text</i> .  An important part of the inline arrangement, the formation of the text (the use of italics, boldface type - approx. Lane) is quite expensive and can potentially be parallelized.  Not implemented. </li><li>  <i>Parsing</i>  We are currently writing a new HTML parser on Rust, focusing equally on security and specification compliance.  In the process. </li><li>  <i>Image decoding</i> .  Parallel decoding of multiple images is easy.  Implemented. </li><li>  <i>Decoding other resources</i> .  This is probably less important than image decoding, but anything that is loaded by a page can be processed in parallel, such as parsing style sheets or video decoding.  Partially implemented. </li><li>  <i>The JS garbage collector competes with the display</i> .  With almost any architecture, including JS and display, JS will wait for the execution of calls to the display, perhaps often.  This will be the most suitable time for garbage collection. </li></ul><br><h2>  Difficulties </h2><br><ul><li>  <i>Performance</i> .  Parallel algorithms, as a rule, require hard compromises.  It is important to really be fast.  We need to make sure that Rust itself has performance similar to C ++. </li><li>  <i>Data structures</i>  Rust has a rather innovative type system, in particular, to make parallel types and algorithms safe, and we need to figure out how to use it efficiently. </li><li>  <i>Immaturity of language</i>  The compiler Rust and language have recently stabilized.  Rust also has a smaller selection of libraries than C ++;  we can use C ++ libraries, but this requires more effort than just using header files. </li><li>  <i>Non-parallel libraries</i> .  Some third-party libraries we need behave badly in a multithreaded environment.  In particular, there were difficulties with fonts.  Even if libraries are technically and thread-safe, often this security is achieved through a single library mutex, which hurts our parallelization capabilities. </li></ul><br><h1>  Task Architecture </h1><br><h2>  Charts </h2><br><h4>  Task Supervision Chart </h4><br><img src="https://habrastorage.org/files/acf/d95/c2d/acfd95c2d85546b886e8e6dafbb41f47.png"><br><h4>  Task Interaction Chart </h4><br><img src="https://habrastorage.org/files/66d/1f5/0f5/66d1f50f588842559baf96350e5c8e0b.png"><br><ul><li>  Each rectangle represents a Rust task. </li><li>  The blue rectangles represent the main tasks from the browser pipeline. </li><li>  Gray rectangles represent auxiliary tasks for the pipeline. </li><li>  White rectangles represent work tasks.  Each such rectangle represents several such tasks, the exact number of which depends on the workload. </li><li>  Dashed lines indicate an oversight attitude. </li><li>  Solid lines represent communication links. </li></ul><br><h2>  Description </h2><br>  Each <a href="">constellation</a> instance can be viewed as a separate tab or window.  It manages the task pipeline, which accepts input, executes JavaScript for the DOM, performs element placement, builds display lists, renders display lists to tiles, and displays the final image on the surface. <br><br>  The conveyor consists of four main tasks: <br><ul><li>  <a href="">Script</a> - The main mission of the script is to create your own DOM and execute JavaScript.  It receives events from a variety of sources, including navigation events, and forwards them as required.  When the task processing the content is required to obtain information about the placement, it should send a request to the placement task. </li><li>  <a href="">The placement task</a> ‚Äî placement makes a DOM cast, calculates styles, and builds the main display data structure ‚Äî the display <a href="">tree</a> .  The display tree is used to calculate the location of the nodes, and based on this, <a href="">a display list</a> is built, which is sent to the renderer. </li><li>  <a href="">Renderer</a> - the renderer gets the display list and renders the visible parts into one or more tiles, if possible in parallel. </li><li> <a href="">Typesetter</a> - typesetter combines tiles from the renderer and sends them to the screen.  As part of the UI stream, the typesetter is the first to receive UI events, which are usually immediately sent to the content for processing (although some events, such as scrolling events, can be pre-processed by the typesetter for responsiveness). </li></ul><br>  In this pipeline, when interacting with tasks, two complex data structures are used: the DOM and the display list.  The DOM is passed from the content processing task to the placement processing task, and the display list from the placement task to the renderer.  Finding an effective and type-safe way to represent, share and / or transfer these two structures is one of the main difficulties of this project. <br><br><h2>  nwrite DOM </h2><br>  <a href="">A DOM</a> in Servo is a tree with support for versioning nodes that can be shared between one writer and several readers.  The DOM uses the copy-on-write strategy to allow the writer to modify the DOM in parallel with the work of the readers.  The content processing task is always written, and the allocation tasks or their subtasks are always read. <br><br>  DOM nodes are Rust values, whose lifetime is controlled by the JavaScript garbage collector.  JavaScript addresses the DOM nodes directly ‚Äî there is no XPCOM or similar infrastructure. <br><br>  The DOM interface is currently not type-safe - it is possible to incorrectly manipulate nodes, which will lead to dereference of incorrect pointers.  The elimination of this insecurity is a high priority and necessary goal of the project;  since the DOM nodes have a difficult life cycle, this will lead to some difficulties. <br><br><h2>  Display list </h2><br>  Servo rendering is completely controlled by the display list ‚Äî a sequence of high-level commands created by the layout task.  The Servo display list is immutable, so that it can be divided between competing renderers and it contains everything you need to display.  This is different from the WebKit renderer, which does not use the display list and the Gecko renderer, which uses the display list, but also renders additional information, such as the DOM directly, for rendering. <br><br><h1>  JavaScript and DOM bindings </h1><br>  We currently use SpiderMonkey, although plug-in engines are a long-term, low-priority task.  Each content processing task receives its own JavaScript runtime.  DOM bindings use the native API engine instead of XPCOM.  Automatic generation of bindings from WebIDL in priority. <br><br><h1>  Multi-process architecture </h1><br>  Just like Chromium and WebKit2, we intend to have a trusted process-application and several less-trusted process engines.  The high-level API will, in fact, be based on IPC, and most likely with non-IPC implementations for testing and a single-process variant, although it is assumed that the most serious users will use several processes.  The engine process will use the sandbox mechanisms provided by the operating system to limit access to system resources. <br><br>  At the moment, we do not intend to go to extremes regarding the sandbox, as the developers of Chromium, mainly because setting up on a sandbox requires a lot of developers (in particular on low-priority platforms like Windows XP or old Linux) and other aspects of the project .  The Rust Type System also adds an important level of defense against memory protection vulnerabilities.  This alone does not make the sandbox less important in terms of protection against unsafe code, bugs in the type system and third-party libraries and libraries on the local computer, but this significantly reduces the possibility for attacks on Servo compared to other browser engines.  In addition, we are concerned about performance related to some sandbox techniques (for example, proxying all OpenGL calls to a separate process). <br><br><h1>  I / O and resource management </h1><br>  Web pages depend on a variety of external resources, with a large number of mechanisms for obtaining and decoding.  These resources are cached at several levels ‚Äî on disk, in memory, and / or in decoded form.  Within the framework of a parallel browser, these resources should be distributed among competitive tasks. <br><br>  Traditionally, browsers have been single-threaded, performing input-output in the ‚Äúmain stream‚Äù, where most of the computation is also done.  This leads to problems with delays.  In Servo, there is no ‚Äúmain thread‚Äù and all external resources are loaded in a single <a href="">resource manager</a> . <br><br>  Browsers use a lot of caches, and a task-based Servo architecture means that it will probably use more caches than existing engines (we may have both a global cache based on a separate task and a local cache). which stores the results from the global cache to avoid calls through the scheduler).  Servo should have a unified caching mechanism, with customizable caches that will work in environments with low memory capacity. </div><p>Source: <a href="https://habr.com/ru/post/274815/">https://habr.com/ru/post/274815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274805/index.html">On the issue of timers in RTOS (Conclusions)</a></li>
<li><a href="../274807/index.html">High Speed ‚Äã‚ÄãFile Transfer Protocol - Aspera FASP</a></li>
<li><a href="../274809/index.html">Quick work with JSON in Swift</a></li>
<li><a href="../274811/index.html">Java and time: part one</a></li>
<li><a href="../274813/index.html">Shaders in libgdx for dummies</a></li>
<li><a href="../274819/index.html">All you need to know about the growing popularity of Malvertising</a></li>
<li><a href="../274821/index.html">How to predict a stock price: An adaptive filtering algorithm</a></li>
<li><a href="../274825/index.html">Algorithm Deflate for example PNG format</a></li>
<li><a href="../274827/index.html">Alternative memory allocators</a></li>
<li><a href="../274829/index.html">Take a step to the FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>