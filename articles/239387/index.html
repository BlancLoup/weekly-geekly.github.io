<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing embedded systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am a member of the Embox RTOS development project for embedded systems. Most often, the OS for embedded systems supports many hardware platforms, an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing embedded systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/3ff/676/da5/3ff676da5b2f4acabdd782f871f1b782.jpg" alt="image" align="right">  I am a member of the <a href="http://code.google.com/p/embox/">Embox RTOS</a> development project for embedded systems.  Most often, the OS for embedded systems supports many hardware platforms, and we are no exception.  Also in the project there are many services and libraries: ssh, telnet, Qt, etc.  All these services and libraries I would like to have in working condition on various platforms. <br><br>  I remember well the time when I had to keep Qt working.  It was a horror!  So I came to work during the day, something was broken again.  Begin to understand.  It turns out that someone has fixed a bug in the network stack and now Qt cannot create a socket.  In short, Qt broke down almost daily and for the most unexpected reasons. <br><br>  Naturally, the decision was to introduce some automated testing of various services into the project.  What is the problem to make a server that will test all this? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main problem is the specifics of embedded systems.  Namely, unlike general-purpose systems, tests have to be performed in an environment with specific hardware support.  For example, they have little memory, and it is not possible to put an integration testing tool inside such a piece of iron.  That is, you need to test "outside."  So let's get to the point. <br><a name="habracut"></a><br><h4>  Build and Run </h4><br>  As I said, we support several architectures.  Therefore, to maintain the project in working condition, first of all, it is necessary to assemble it for various platforms.  For this purpose, we use the gcc compiler, which is known to generate code for different architectures.  But to do it manually is certainly not worth it.  Fortunately, there are many different tools under the general name <a href="http://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a> - <a href="http://jenkins-ci.org/">Jenkins / Hudson</a> , <a href="http://integrityapp.com/">Integrity</a> , <a href="http://buildbot.net/">Buildbot</a> , etc., to solve the problem of assembly automation. new commits to the repository.  We use Buildbot.  When some configuration is not collected, it is marked on the buildserver.  In fact, it is still possible to automatically send angry letters to the one who broke it, but we are mostly in the same room and handle through voice communication over the air. <br><br>  The next problem that arises again due to the cross-platform project is launching on the target platform or at least the architecture.  Then another open source project, <a href="http://wiki.qemu.org/Main_Page">QEMU</a> , came to our aid; it supports all of the processor architectures we have and a fairly wide list of peripherals. <br><br>  Lyrical digression.  Initially, in QEMU for the Leon 3 processor there was a bug, and we used the tsim emulator.  But I wanted uniformity at least in order to establish automated testing.  And since the QEMU project is open, we have <a href="https://code.google.com/p/embox/wiki/SimulationQemuSparc">adjusted its source code</a> to support the Leon3 processor.  In later versions, our edits were corrected. <br><br>  QEMU allows you to set various parameters at startup (size of available physical memory, network and video cards used, plug-in drive, etc.) and we traditionally did not want to do this manually, we created a script that analyzes the configuration of our project and starts the emulator with the necessary parameters . <br><br><img src="https://habrastorage.org/files/bb7/7f0/f19/bb77f0f19fc44a87825604373b25dbbb.png" alt="image"><br><br><h4>  Unit testing </h4><br>  As everyone probably knows, testing can be of different types: Unit, regression, integration, and others.  Unit testing is applied by the developers themselves and allows you to quickly check if the functionality is broken after making changes. <br><br>  Enough at an early stage of development of the project, we realized that we would not go far without this type of testing.  And we developed, naturally after researching existing solutions, a small lightweight framework for Unit testing in the C language. When we studied existing frameworks, the most convenient syntax, in our opinion, was the <a href="http://code.google.com/p/googletest/">googletest</a> framework.  Unfortunately, this framework for the C ++ language, and we wanted to be able to write C-shnye tests, therefore, following the same syntax, we developed an analogue for C. <br><br>  This framework turned out to be very successful, because on the one hand it actually does not require anything from the platform on which it is called, the only thing is the <i>setjmp</i> and <i>longjmp</i> functions for the architecture used, and on the other hand it has a convenient syntax.  Because of the small requirements, this framework can easily be applied at the earliest stages of the development of embedded systems with virtually no working environment.  Therefore, we actively use tests not only for the developed software modules, but also for testing the hardware component, for example, hardware timers, as well as testing system functions, for example, creating a thread in the kernel. <br><br>  An example of testing the functionality of creating and executing a stream: <br><br><pre><code class="cpp hljs">TEST_CASE(<span class="hljs-string"><span class="hljs-string">"thread_create should return -EINVAL if thread function is NULL"</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">;</span></span> t = thread_create(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); test_assert_equal(err(t), -EINVAL); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And one more example.</b>  <b class="spoiler_title">The efficiency of the timer interrupt.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_timer_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sys_timer_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* timer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *param)</span></span></span><span class="hljs-function"> </span></span>{ *((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *) param) = <span class="hljs-number"><span class="hljs-number">1</span></span>; } TEST_CASE(<span class="hljs-string"><span class="hljs-string">"testing timer_set function"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">sys_timer_t</span></span> * timer; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tick_happened; <span class="hljs-comment"><span class="hljs-comment">/* Timer value changing means ok */</span></span> tick_happened = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timer_set(&amp;timer, TIMER_ONESHOT, TEST_TIMER_PERIOD, test_timer_handler, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) &amp;tick_happened)) { test_fail(<span class="hljs-string"><span class="hljs-string">"failed to install timer"</span></span>); } i = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i-- &amp;&amp; !tick_happened) { } timer_close(timer); test_assert(tick_happened); }</code> </pre></div></div><br>  I will not go into much of the description of our framework, it is beyond the scope of this topic, besides, I only used it, and developed <a href="https://habrahabr.ru/users/abusalimov/" class="user_link">abusalimov</a> , but if someone is interested, you can write a separate article about it.  I just note that the included tests run right at the start in automatic mode. <br><br><img src="https://habrastorage.org/files/5de/b15/de4/5deb15de419a47848c14f896c9230826.png" alt="image"><br><br><h4>  Integration testing </h4><br>  After the unit tests are completed, we proceed to integration tests.  As mentioned above, performing integration tests inside an embedded system is rather problematic.  Began to understand what tool to start using for testing outside.  Investigated several integration testing frameworks - <a href="http://tetworks.opengroup.org/Products/tetware_RT.htm">TETware RT</a> , <a href="http://arago-project.org/wiki/index.php/Opentest">OpenTest</a> , <a href="http://wiki.tcl.tk/1502">tcltest</a> , <a href="http://autotestnet.sourceforge.net/">autotestnet</a> , <a href="https://www.gnu.org/software/dejagnu/">DejaGnu</a> .  The following issues emerged: <br><br><ul><li>  Some tools require unix environment - utilities grep, awk and so on.  In other words, something like linux.  The problem is that not everything will fit on any board (TETware RT, OpenTest); </li><li>  Lack of built-in tools to verify the output and the result of the execution of the program under test (DejaGnu); </li><li>  Lack of funds to interact with the embedded system, that is, there is no possibility to easily verify that the result of program execution on the remote system is the expected (TclTest and its improvements - PTL, TTXN, New Test Package). </li></ul><br>  At that time I was already familiar with googletest for C ++, and I liked their syntax for writing unit tests.  Tests are written in the place of their announcement and are not registered anywhere else, there are many assertions, it is possible to define handlers that are called before and after the execution of each test.  And I thought, why not move this convenience into the scope of integration testing for embedded systems? <br><br>  Based on the knowledge of the shortcomings of existing solutions, I set myself the task of maximally combining the lightness of DejaGnu, the power of TETware RT and the aesthetics of the googletest. <br><br>  As a technology for development, I chose the Tcl language with the <a href="http://expect.sourceforge.net/">Expect</a> extension to automate testing.  Expect allows you to simply describe the process of connecting to the embedded system, send commands and process the result. <br><br>  Schematically, the principle of the framework can be described as shown below.  Most of it works on the host, and the network sends commands that are executed on the interpreter of the embedded system, after which the result is transmitted back and analyzed on the host. <br><br><img src="https://habrastorage.org/files/4e7/6a8/19c/4e76a819cb43402ebf66cd2e60016688.png" alt="image"><br><br><h5>  Hello embedded tester! </h5><br>  Let's look at what the simplest test looks like. <br><br><pre> <code class="bash hljs">package require autotest namespace import autotest::* TEST_CASE {<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúhello‚Äù <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> hello} { test_assert_regex_equal ‚Äú<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúhello‚Äù<span class="hljs-string"><span class="hljs-string">" hello }</span></span></code> </pre><br>  The first two lines mean that we include the <i>autotest</i> library that I implemented, which is a package in Tcl.  Next, a test case is announced.  The essence of the test is simple - the embedded system must correctly execute the <i>echo ‚Äúhello‚Äù</i> command by typing <i>hello</i> .  Let's see how it works. <br><br>  Immediately, I note that all tests are run only on the host system, and with the built-in we interact via TELNET.  The <i>TEST_CASE</i> procedure first establishes a connection to the embedded system.  Of course, for this, the telnetd service must be previously started inside the embedded system.  That is, the scheme is this - we start QEMU with the prepared image of our OS, and wait until telnetd starts.  Then you can connect and run tests. <br><br>  So, after the connection is established, the <i>test_assert_regexp_equal ‚Äúecho‚Äú hello ‚Äù" hello ‚Äù</i> line is <i>executed</i> . It sends the <i>‚Äú echo ‚Äúhello‚Äù</i> command to the embedded system. The embedded system executes the command and all its output goes automatically to the host (this is telnet!). The host in turn receives the result and compares it with the string <i>‚Äúhello‚Äù</i> . <br><br><h5>  Framework Overview </h5><br>  The framework contains a set of library procedures <i>test_assert_ *</i> .  All of them work in the same scenario ‚Äî send a command from the host to an embedded system, and then get the output of the command and compare it with the expected one.  Below is the <i>test_assert_regex_equal</i> procedure <i>code</i> from the example above: <br><br><pre> <code class="bash hljs">proc test_assert_regexp_equal {cmd success_output} { send <span class="hljs-variable"><span class="hljs-variable">$cmd</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cmd_name [lindex [split <span class="hljs-variable"><span class="hljs-variable">$cmd</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>] 0] expect { timeout { puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cmd_name</span></span></span><span class="hljs-string"> timeout\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 } -regexp <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cmd_name</span></span></span><span class="hljs-string">:.*"</span></span> { puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$expect_out</span></span></span><span class="hljs-string">(buffer)\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 } <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$success_output</span></span></span><span class="hljs-string">"</span></span> { } } }</code> </pre><br>  If one of the <i>test_assert_ *</i> procedures is completed on <i>exit 1</i> , then information is displayed that the test failed (the file name and line number are printed) and control is transferred to the next set of case-test. <br><br>  Infused with the convenience of googletest, I implemented the <i>TEST_SETUP</i> and <i>TEST_SUITE_SETUP procedures</i> (similarly for <i>TEARDOWN</i> ).  I want to draw attention to one feature.  These procedures exist for both the host and the embedded system - <i>TEST_SETUP_HOST</i> and <i>TEST_SETUP_TARGET</i> .  The difference is that the first one will be executed on the host, and the second one on the embedded system. <br><br><h5>  Step-by-Step Test Debugging </h5><br>  Let's imagine for a moment that our <i>‚ÄúHello embedded tester!‚Äù</i> Test failed.  That is, when it was launched, the framework gave an error that line 5 did not <i>trigger test_assert_regex_equal</i> .  I want to find out what went wrong in our embedded system.  To do this, let's modify our test as follows by adding the <i>‚Äúb‚Äù</i> character to the end of the line where the error occurred. <br><br><pre> <code class="bash hljs">package require autotest namespace import autotest::* TEST_CASE {<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúhello‚Äù <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> hello} { test_assert_regex_equal ‚Äú<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúhello‚Äù<span class="hljs-string"><span class="hljs-string">" hello b }</span></span></code> </pre><br>  Now the test will be executed up to the line with the symbol <i>‚Äúb‚Äù</i> .  This means that immediately after entering the procedure, it reports this by typing the line number, the name of the file with the breakpoint and the line itself, and then enters the mode of waiting for the input key to be pressed.  In other words, it is such a kind of breakpoint.  Now, when the test is in standby mode, it is possible to set a breakpoint inside the embedded system and then continue the test execution. <br><br>  By the way, the standard debugging tools in Tcl do not allow setting breakpoints on an arbitrary line within the procedure, and it is suggested to do with debug printing. <br><br><h5>  What to do "inside", and what "outside"? </h5><br>  So, I satisfied my curiosity and implemented the framework, attached to it a beautiful conclusion about the test results, logs, and wrote the first test for ping.  Now I had to start using it in combat conditions. <br><br>  Oh yeah, the important point is that not all integration tests make sense to perform ‚Äúoutside‚Äù the embedded system.  For example, a test for ping from the target platform to the host can be perfectly performed from the ‚Äúinside‚Äù.  To do this, simply execute the ping command and check the result of the execution of the last command (in unix, this is <i>'echo $?'</i> ).  This is implemented using the startup script.  It configures the system after it is loaded - for example, the network is configured.  At the end of the startup script, relatively simple integration tests are added that can be performed inside the embedded system. <br><br><div class="spoiler">  <b class="spoiler_title">An example of a startup script.</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"ifconfig eth0 10.0.2.16 netmask 255.255.255.0 hw ether AA:BB:CC:DD:EE:02 up"</span></span>, <span class="hljs-string"><span class="hljs-string">"route add 10.0.2.0 netmask 255.255.255.0 eth0"</span></span>, <span class="hljs-string"><span class="hljs-string">"route add default gw 10.0.2.10 eth0"</span></span>, <span class="hljs-string"><span class="hljs-string">"export PWD=/"</span></span>, <span class="hljs-string"><span class="hljs-string">"export HOME=/"</span></span>, <span class="hljs-string"><span class="hljs-string">"mkdir /mnt"</span></span>, <span class="hljs-string"><span class="hljs-string">"mkdir /mnt/fs_test"</span></span>, <span class="hljs-string"><span class="hljs-string">"test -t fs_test_read"</span></span>,</code> </pre></div></div><br>  At the end of the script there is a line <i>‚Äútest -t fs_test_read‚Äù</i> , which runs the test for the file system. <br><br>  A natural question appears: what tests cannot be performed this way and how to deal with it?  The answer is simple.  For example, to perform a test, you may need to process the output of the program using the grep and awk utilities.  Naturally, you do not want to push such utilities inside an embedded system.  Therefore, such tests are performed ‚Äúoutside‚Äù with the use of the implemented framework. <br><br>  As an example, I will give a test on ntpdate.  Ntpdate is a program that exposes the date and time through the NTP protocol.  It is implemented in our OS.  The test verifies that the time set inside the embedded system is the same as the current time on the host. <br><br><div class="spoiler">  <b class="spoiler_title">Ntpdate test</b> <div class="spoiler_text"><pre> <code class="bash hljs">namespace import autotest::* <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> host_date <span class="hljs-string"><span class="hljs-string">""</span></span> proc get_host_date {} { global host_date spawn date -u --rfc-3339=date expect -regexp {.{10}} <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> host_date <span class="hljs-variable"><span class="hljs-variable">$expect_out</span></span>(0,string) } TEST_SETUP_HOST {get_host_date} TEST_CASE {ntpdate sets current date <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> UTC format correctly} { variable host_ip global host_date test_assert_regexp_equal <span class="hljs-string"><span class="hljs-string">"ntpdate </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$host_ip</span></span></span><span class="hljs-string">\r"</span></span> <span class="hljs-string"><span class="hljs-string">":/#"</span></span> test_assert_regexp_equal <span class="hljs-string"><span class="hljs-string">"date\r"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$host_date</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0 }</code> </pre></div></div><br>  The <i>get_host_date</i> function gets the current time on a host in UTC format.  To do this, it is registered using the <i>TEST_SETUP_HOST</i> procedure, that is, it will be called on the host.  Below is <i>TEST_CASE</i> .  It first runs the <i>‚Äúntpdate $ host_ip‚Äù</i> command on the embedded system, and then the <i>‚Äúdate‚Äù</i> command and verifies that <i>$ host_date is</i> contained in the output of the command. <br><br><h4>  Results </h4><br>  As a result, the testing process described above can be schematically represented as follows: <br><br><img src="https://habrastorage.org/files/344/8a9/c08/3448a9c08cd74e51bad1d0cc6d3b381a.png" alt="image"><br><br>  And this is how our test site looks like: <br><br><img src="https://habrastorage.org/files/add/868/c13/add868c13480487884a22aa0e184dcf7.png" alt="image"><br><br>  I would be glad if someone will share their experience in organizing the process of testing embedded systems. </div><p>Source: <a href="https://habr.com/ru/post/239387/">https://habr.com/ru/post/239387/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239375/index.html">New solutions to the old problem</a></li>
<li><a href="../239377/index.html">The best gift is a book. We make a beautiful cover</a></li>
<li><a href="../239379/index.html">Study: internal threats in large companies turned out to be more dangerous than viruses</a></li>
<li><a href="../239381/index.html">Storage systems: how to choose?</a></li>
<li><a href="../239385/index.html">YouTrack 6.0, distinct and flexible. What can a new tracker?</a></li>
<li><a href="../239393/index.html">Hewlett-Packard is divided into two companies</a></li>
<li><a href="../239395/index.html">Vulnerability Yandex money or how to recover a payment password</a></li>
<li><a href="../239397/index.html">PL / SQL via dblink</a></li>
<li><a href="../239399/index.html">What technology has learned from Linus Torvalds</a></li>
<li><a href="../239401/index.html">Modifying a USB-UART converter on a CP2102 chip for use as an Arduino programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>