<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ drivers for STM8L051F3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Driver Problems and Requirements 
 Every experienced microprocessor programmer has come across writing drivers. When implementing small projects or tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ drivers for STM8L051F3</h1><div class="post__text post__text-html js-mediator-article"><h4>  Driver Problems and Requirements </h4><br>  Every experienced microprocessor programmer has come across writing drivers.  When implementing small projects or transferring a ready-made debugged code to another processor, writing and debugging drivers can take 50% or more development time.  Moreover, the process of writing a driver for a new processor, and matching the existing code can be very unpleasant due to the lack of structure and commonality in the driver.  For a programmer, this becomes a nervous routine.  We define important problems when writing a driver: <br><br><ol><li>  Lack of driver structure.  The solution to this problem allows you to better navigate the driver, therefore, debugging becomes easier. <br></li><li>  Lack of common driver.  That is, the driver interface should be the same, for at least the processor line, and ideally for similar processors from different companies.  This will allow to transfer the code tied to the driver, without changes or with minimal changes. <br></li><li>  Maintaining efficiency in driver execution speed. <br></li><li>  Optimal use of memory. <br></li></ol><br><br>  In this post, I will show how you can eliminate these problems and make the process of writing a driver a more enjoyable task using the example of two UART and DMA drivers implemented in C ++.  For this, I formulated the requirements for the driver: <br><a name="habracut"></a><br><ol><li>  The driver must be structured.  The driver will be implemented as a C ++ class, which will allow you to create a driver object.  This is convenient and logical, if in the processor, for example, there are three UART and four DMA channels, then you can create three driver objects, for each UART, and four driver objects for each DMA channel.  If only one UART is used in the project, then only one object can be created for the corresponding UART, etc. <br></li><li>  The driver must have the same interface for multiple processors.  It is very difficult to fulfill this requirement, since, in order to isolate a common interface, it is necessary for a multitude of processors to work through this multitude of processors, which will take a lot of time.  Therefore, I created an interface convenient for STM8L051F3, and then as the project appears on the new processor I will adjust this interface.  Thus, it is possible to single out the most general and optimal interface for all processors with time. <br></li><li>  The driver must be the maximum effective.  Ideally, the execution speed and the amount of occupied memory should be no more than if you write this driver directly referring to the registers.  Considerably the speed of the driver can be increased by using the template C ++.  The C ++ template allows you to access the direct memory, thereby replacing pointers, the dereference of which takes time.  But there are also costs for calling the driver interface function.  With the help of the inline operator, the call to the function could not be eliminated; this is evident from the assembler code.  Maybe when you turn on the optimizer of the compiler, this statement will affect ... Since the driver setting is performed one-time or at a slow periodicity, the cost of calling the function is not critical. <br></li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Using the driver </h4><br>  So, to begin with, consider the use of the DMA driver, and then the implementation.  Using DMA, we transfer data from RAM to the UART shift register and receive data from the UART shift register to RAM. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iostm8l051f3.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Driver_DMA.hpp"</span></span></span><span class="hljs-meta"> char UartBuffer[128]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    DMA DriverDMA&lt;EnumDMA::DMA1,EnumDMA::CHANNEL1&gt; DMAChannelTX; // DMA1  1 DriverDMA&lt;EnumDMA::DMA1,EnumDMA::CHANNEL2&gt; DMAChannelRX; // DMA1  2 void func() { DMAChannelTX.global_disable(); //    //    DMA DMAChannelTX.set_periph_addr(&amp;USART1_DR); //    DMAChannelTX.set_memory0_addr(UartBuffer); //     DMAChannelTX = EnumDMA::DATABLOCK_8bit; //  - DMAChannelTX = EnumDMA::PRIORITY_MEDIUM; //   DMAChannelTX = EnumDMA::MEMPNT_INCREMENT; //     DMAChannelTX = EnumDMA::MEMORY_TO_PHERIPH; //       UART DMAChannelTX = EnumDMA::CIRCULAR_DISABLE; //    //    DMA DMAChannelRX.set_periph_addr(&amp;USART1_DR); DMAChannelRX.set_memory0_addr(UartBuffer); DMAChannelRX = EnumDMA::DATABLOCK_8bit; DMAChannelRX = EnumDMA::PRIORITY_MEDIUM; DMAChannelRX = EnumDMA::MEMPNT_INCREMENT; DMAChannelRX = EnumDMA::PHERIPH_TO_MEMORY; //     UART   DMAChannelRX = EnumDMA::CIRCULAR_DISABLE; DMAChannelRX.set_number_of_transfers(sizeof(UartBuffer)); DMAChannelRX.channel_enable(); //    DMAChannelTX.global_enable(); //    }</span></span></span></span></code> </pre> <br><br>  As can be seen from the previous listing, the code becomes more readable, and self-documenting. <br><br><h4>  Driver interface </h4><br>  The interface is defined in the EnumDMA structure, in which enums are defined, which are used as arguments to driver methods. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumDMA</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DMASel{ DMA1 = <span class="hljs-number"><span class="hljs-number">0x5070</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ChannelSel{ CHANNEL0 = <span class="hljs-number"><span class="hljs-number">0x05</span></span>, CHANNEL1 = <span class="hljs-number"><span class="hljs-number">0x0F</span></span>, CHANNEL2 = <span class="hljs-number"><span class="hljs-number">0x19</span></span>, CHANNEL3 = <span class="hljs-number"><span class="hljs-number">0x23</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DataBlock{ DATABLOCK_8bit, DATABLOCK_16bit }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ChannelPriority{ PRIORITY_LOW, PRIORITY_MEDIUM, PRIORITY_HIGH, PRIORITY_VERYHIGH }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> MemoryPointerMode{ MEMPNT_DECREMENT, MEMPNT_INCREMENT }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CircularBufferMode{ CIRCULAR_DISABLE, CIRCULAR_ENABLE }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TransferType{ <span class="hljs-comment"><span class="hljs-comment">//    3 TRANS_TYPE_PHERIPH_TO_MEMORY, TRANS_TYPE_MEMORY0_TO_MEMORY1 }; enum TransferDirection{ PHERIPH_TO_MEMORY, MEMORY_TO_PHERIPH }; enum InterruptSelection{ INTERRUPT_HALF_TRANSACTION_COMPLETE, INTERRUPT_TRANSACTION_COMPLETE }; enum InterruptVectors{ VECTOR_DMA1_CHANNEL0_HALF_TRANSACTION_COMPLETE = DMA1_CH0_HT_vector, VECTOR_DMA1_CHANNEL0_TRANSACTION_COMPLETE = DMA1_CH0_TC_vector, VECTOR_DMA1_CHANNEL1_HALF_TRANSACTION_COMPLETE = DMA1_CH1_HT_vector, VECTOR_DMA1_CHANNEL1_TRANSACTION_COMPLETE = DMA1_CH1_TC_vector, VECTOR_DMA1_CHANNEL2_HALF_TRANSACTION_COMPLETE = DMA1_CH2_HT_vector, VECTOR_DMA1_CHANNEL2_TRANSACTION_COMPLETE = DMA1_CH2_TC_vector, VECTOR_DMA1_CHANNEL3_HALF_TRANSACTION_COMPLETE = DMA1_CH3_HT_vector, VECTOR_DMA1_CHANNEL3_TRANSACTION_COMPLETE = DMA1_CH3_TC_vector, }; };</span></span></code> </pre><br><br>  The DMASel enumeration allows you to select a DMA module, and the ChannelSel enumeration determines the memory offset between the DMA channels.  In the processor STM8L051F3 one DMA module, so the choice is not great.  The DMA1 enumeration is assigned the address of the DMA1 module. <br>  DriverDMA class design: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;EnumDMA::DMASel DMA, EnumDMA::ChannelSel DMAChannel&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DriverDMA</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DMA_struct</span></span></span><span class="hljs-class"> //   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DMA</span></span></span><span class="hljs-class">     {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> GCSR_REG GCSR; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Global configuration and status register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> GIR_REG GIR1; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Global interrupt register 1 */</span></span> }; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DMA_Channel_struct</span></span></span><span class="hljs-class"> //    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DMA</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> CCR_REG CCR; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; CHx Control register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> CSPR_REG CSPR; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; CHx Status &amp; Priority register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CNDTR; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; CHx Number of Bytes to Tranfer register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CPARH; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Peripheral Address High register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CPARL; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Peripheral Address Low register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CM0EAR; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Memory 0 Extended Address register (for channel3)*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CM0ARH; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Memory 0 Address High register */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CM0ARL; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Memory 0 Address Low register */</span></span> }; u8 number_of_transfers; u8 NumChannel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: DriverDMA(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (EnumDMA::DataBlock); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (EnumDMA::ChannelPriority); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (EnumDMA::MemoryPointerMode); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (EnumDMA::CircularBufferMode); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (EnumDMA::TransferDirection); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (EnumDMA::TransferType); <span class="hljs-comment"><span class="hljs-comment">//    3 void global_enable(); void global_disable(); void channel_enable(); void channel_disable(); void set_number_of_transfers(const u16 trans_num); void set_periph_addr(u8 volatile* addr); void set_memory0_addr(u8* addr); //    00000  01FFF void set_memory1_addr(u8* addr); //    3 bool is_busy(); u16 get_amount_of_last_transation(); void interrupt_enable(EnumDMA::InterruptSelection); void interrupt_disable(EnumDMA::InterruptSelection); void interrupt_clear_pending_flag(EnumDMA::InterruptSelection); };</span></span></code> </pre><br><br>  DMA module registers are defined in the private section, using the C ++ template, the DMA module and the module channel are selected. <br><br><h4>  Description of the driver implementation </h4><br>  Implementing a class constructor and two methods: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------------------------------------------------------------------------------------- template &lt;EnumDMA::DMASel DMA, EnumDMA::ChannelSel DMAChannel&gt; DriverDMA&lt;DMA,DMAChannel&gt;::DriverDMA() { CLK_PCKENR2_bit.PCKEN24 = 1; // DMA clock enable __DMA-&gt;GCSR.bit.TO = 31; NumChannel = (u8)DMAChannel; } //---------------------------------------------------------------------------------------------- template &lt;EnumDMA::DMASel DMA, EnumDMA::ChannelSel DMAChannel&gt; void DriverDMA&lt;DMA,DMAChannel&gt;::operator= (EnumDMA::DataBlock db) { __DMACHANNEL-&gt;CSPR.bit.TSIZE = db; } //---------------------------------------------------------------------------------------------- template &lt;EnumDMA::DMASel DMA, EnumDMA::ChannelSel DMAChannel&gt; void DriverDMA&lt;DMA,DMAChannel&gt;::global_enable() { __DMA-&gt;GCSR.bit.GEN = 1; // Global enable of DMA1 }</span></span></code> </pre><br>  where __DMA and __DMACHANNEL are defined as follows: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __DMA ((DMA_struct*) DMA) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __DMACHANNEL ((DMA_Channel_struct*) ((u32)DMA + (u32)DMAChannel))</span></span></code> </pre><br>  At first glance, a complex structure: <br><pre> <code class="cpp hljs">__DMACHANNEL-&gt;CSPR.bit.TSIZE = db;</code> </pre><br>  interpreted by the compiler as 3 assembler commands, and the command: <br><pre> <code class="cpp hljs">__DMA-&gt;GCSR.bit.GEN = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  occupies one assembly command. <br><br><h4>  Interruptions </h4><br>  To create an interrupt, you must enable it, write an interrupt function in which you need to perform handshaking.  For example, create an interrupt upon completion of a DMA transaction: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      DMAChannelTX.interrupt_enable(EnumDMA::INTERRUPT_TRANSACTION_COMPLETE) } #pragma vector = EnumDMA::VECTOR_DMA1_CHANNEL1_TRANSACTION_COMPLETE __interrupt void DMA_transaction_complete() { //    DMAChannelTX.interrupt_clear_pending_flag(EnumDMA::INTERRUPT_TRANSACTION_COMPLETE) }</span></span></code> </pre><br><br><h4>  Implementing a UART Driver with a DMA Driver </h4><br>  The UART driver is also implemented in a similar way using a class, but without using the C ++ template, since there is only one UART module in this processor.  The UART driver uses two DMA channels to transmit and receive data.  Since the driver user does not need access to DMA, we initialize the DMA in the private section: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DriverUART</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ... u8 UartBuffer[<span class="hljs-number"><span class="hljs-number">128</span></span>]; DriverDMA&lt;EnumDMA::DMA1,EnumDMA::CHANNEL1&gt; DMAChannelTX; DriverDMA&lt;EnumDMA::DMA1,EnumDMA::CHANNEL2&gt; DMAChannelRX; ...</code> </pre><br><br>  DMA configuration can be performed in the UART driver constructor, so when you create a UART object, the DMA driver will be immediately initialized and ready to go. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//----------------------------------------------------------------------- // Main DriverUART Constructor //----------------------------------------------------------------------- DriverUART::DriverUART(SELECTUART uart, u32 baud_rate, u32 sys_clock, PinconfigUART confPin) { CLK_PCKENR1_bit.PCKEN15 = 1; // UART clock enable USART1_CR1_bit.USARTD = 0; USART1_CR5_bit.DMAT = 1; // DMA enable transmitter USART1_CR5_bit.DMAR = 1; // DMA enable receiver DMAChannelTX.global_disable(); DMAChannelTX.set_periph_addr(&amp;USART1_DR); DMAChannelTX.set_memory0_addr(UartBuffer); DMAChannelTX = EnumDMA::DATABLOCK_8bit; DMAChannelTX = EnumDMA::PRIORITY_MEDIUM; DMAChannelTX = EnumDMA::MEMPNT_INCREMENT; DMAChannelTX = EnumDMA::MEMORY_TO_PHERIPH; DMAChannelTX = EnumDMA::CIRCULAR_DISABLE; DMAChannelRX.set_periph_addr(&amp;USART1_DR); DMAChannelRX.set_memory0_addr(UartBuffer); DMAChannelRX = EnumDMA::DATABLOCK_8bit; DMAChannelRX = EnumDMA::PRIORITY_MEDIUM; DMAChannelRX = EnumDMA::MEMPNT_INCREMENT; DMAChannelRX = EnumDMA::PHERIPH_TO_MEMORY; DMAChannelRX = EnumDMA::CIRCULAR_DISABLE; DMAChannelRX.set_number_of_transfers(sizeof(UartBuffer)); DMAChannelRX.channel_enable(); DMAChannelTX.global_enable(); set_sysclock(sys_clock, baud_rate); USART1_CR2_bit.TCIEN = 1; // .     USART1_CR2_bit.ILIEN = 1; // .    USART1_CR5_bit.EIE = 1; // .     __enable_interrupt(); close(); }</span></span></code> </pre><br><br>  Implementation of data transfer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DriverUART::transmit(u8 * source, u16 size) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(DMAChannelTX.is_busy()) ; select_direction(TRANSMITION); __disable_interrupt(); DMAChannelTX.global_disable(); DMAChannelTX.channel_disable(); DMAChannelTX.set_number_of_transfers(size); DMAChannelTX.set_memory0_addr(source); DMAChannelTX.global_enable(); DMAChannelTX.channel_enable(); __enable_interrupt(); }</code> </pre><br><br>  Usage example: <br><br><pre> <code class="cpp hljs">u8 buffer[] = <span class="hljs-string"><span class="hljs-string">"hello world!"</span></span> Uart1.transmit(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer));</code> </pre><br><br>  Upon reception, an interrupt is generated in which you must reset the receiving DMA channel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DriverUART::reception_handshake() { __disable_interrupt(); DMAChannelRX.global_disable(); DMAChannelRX.channel_disable(); received_size = DMAChannelRX.get_amount_of_last_transation(); DMAChannelRX.set_number_of_transfers(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(UartBuffer)); DMAChannelRX.global_enable(); DMAChannelRX.channel_enable(); __enable_interrupt(); }</code> </pre><br><br>  In the interrupt, you can get a pointer to the internal buffer in which the received data lies, and the size of the received packet.  Since in this case the interrupt is created inside the class, the handler must be implemented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-------------------------------------------------------------------------- //    //-------------------------------------------------------------------------- void DriverUART::receive_handle() { u16 size; u8* pnt; Uart1.reception_handshake(); size = Uart1.get_received_size(); pnt = Uart1.get_pointer_on_internal_buffer(); //      }</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  These drivers have a clear structure that allows you to navigate well through them, and thanks to which the driver is better remembered.  The driver is now perceived as an object that can be configured, through it you can transfer something and get something from it. <br><br>  An interface has been created in the form of C ++ lists, which helps to better understand the properties and capabilities of the driver and minimize communication with the processor.  The code thanks to this interface becomes self-documenting.  This all allows you to quickly understand a new driver and remember the essence of your own code to an experienced programmer. <br><br>  The driver code can be used as a template for writing a similar driver from another processor of this line of drivers or from other manufacturers, without significantly changing the interface. <br><br>  Through the use of the C ++ template, it was possible to significantly increase the speed of the driver, but the costs of calling a function can be neglected, where execution speed is not critical. <br><br>  DMA and UART driver files can be downloaded from this link <a href="https://github.com/SikalovYuriy/STM8L051F3_Drivers">STM8L051F3_Drivers</a> . <br><br>  In the file "Init_UART.cpp" an example of using the UART driver. </div><p>Source: <a href="https://habr.com/ru/post/225635/">https://habr.com/ru/post/225635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225625/index.html">Why success stories are so useless</a></li>
<li><a href="../225627/index.html">Useful tools for development on Laravel</a></li>
<li><a href="../225629/index.html">Translation of Unity3D documentation</a></li>
<li><a href="../225631/index.html">How we ur did</a></li>
<li><a href="../225633/index.html">DevConf 2014 - will be held this Saturday. New Storage section - will reveal all the secrets of data storage</a></li>
<li><a href="../225637/index.html">Ideas underlying responsive emails</a></li>
<li><a href="../225639/index.html">Mikrotik and GNS3</a></li>
<li><a href="../225641/index.html">New Optional class in Java 8, not a panacea for NullPointerException</a></li>
<li><a href="../225643/index.html">Antenna for Wi-Fi on your knee in 10 minutes</a></li>
<li><a href="../225645/index.html">Development of Iframe applications on VK API. From the first cones to the two millionth audience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>