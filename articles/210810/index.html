<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Processing of digital images in remote sensing (remote sensing of the earth)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© there were many articles about the use of various methods of image processing, including data classification, filtering. Many of these approa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Processing of digital images in remote sensing (remote sensing of the earth)</h1><div class="post__text post__text-html js-mediator-article">  On Habr√© there were many articles about the use of various methods of image processing, including data classification, filtering.  Many of these approaches are also used in remote sensing when processing digital images of the Earth. <br><img src="https://habrastorage.org/getpro/habr/post_images/8d2/d87/4f9/8d2d874f97003c647c69876487ccbcb3.jpg"><br>  From the moment a snapshot is taken from a satellite, to being able to analyze it, it must go through a whole cycle of procedures to bring it into a form convenient for receiving and subsequent analysis of visual information. <br>  Those who are interested in the process itself, please under the cat (traffic): <a name="habracut"></a><br><br>  Before turning to the very essence, I would like to immediately introduce a number of <s>elementary</s> concepts, which, surely, are already familiar to many, but, nevertheless, we will not deviate from reality.  Those who are confident in their competence on this issue, let them go straight to the most interesting. <br><br><h5>  The digital image itself and the process of getting it </h5><br>  As everyone knows, a <b>digital image</b> is a matrix of pixels, the value of each of which is obtained by averaging over four components: the coordinates of space (x and y), wavelength and time. <br>  The process of compiling the matrix itself goes this way: the solar radiation is reflected from the objects of the survey, the energy that falls on the sensor surface is fixed by it, then integrated, from which the integral pixel value is set.  The integer value is obtained after converting the integral value into an electrical signal.  Each pixel stores information in binary form.  The more bits (memory) is allocated per pixel, the greater the number of values ‚Äã‚Äãcorresponding to one pixel, the more accurately the original discrete signal is approximated, and the more information a picture can store. <br>  In CCD scanners, the already mentioned detectors scan the Earth and divide a continuous stream of data into pixels. <br>  Much depends on the type of scanner, it determines the method of obtaining images.  So, there are three main types of scanners: <br><img src="https://habrastorage.org/getpro/habr/post_images/967/590/f04/967590f04770ceb5ca5c47bf04768f9b.png"><br><ol><li>  <i>A linear scanner</i> (for example, AVHRR) is the simplest, it is equipped with only one detector element. </li><li>  <i>Transverse CCD scanner</i> (GOES, MODIS, TM) - uses for scanning a line of detectors located along the shooting route.  Parallel scanning of the Earth is carried out with each cycle of movement of the mirror. </li><li>  <i>Longitudinal scanners</i> (IKONOS, QuickBird, SPOT) have thousands of detectors in a CCD array, therefore, parallel scanning is carried out simply by moving the platform in orbit. </li></ol><br>  <b>Digital images are</b> displayed either using an 8-bit grayscale or 24-bit scale, which is based on mixing different R, G, B shades. The original pixel range turns into a limited range by combining color values ‚Äã‚Äãthat correspond to any three channels of a multi-spectral digital image. .  One pixel is displayed 256 ^ 3 RGB vectors, one vector - one color.  There are other options for radiometric resolution.  For example, QuickBird - 11bit / pix, Landsat-8 - 16 bit / pix. <br>  As spectral channels are formed in optical sensors: <br>  The beam of light received by the sensors is divided into several rays.  Each beam, passing its optical path, goes through a spectral filter.  Prisms and diffraction gratings can be used to separate spectral ranges. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Preliminary procedures for image processing </h5><br>  The cycle of preliminary procedures for processing a snapshot includes the following: <br><ol><li>  <i>Radiometric correction</i> - eliminates the variation of pixel brightness values, which occurs as a result of improper operation of detectors, the effect of relief and atmosphere. </li><li>  <i>Atmospheric correction</i> is a correction for the influence of the atmosphere, which determines the location of the shooting ranges at the expense of transparency windows. </li><li>  <i>Geometric correction</i> includes correction of such image distortions as banding, line dropping, and <b>geocoding</b> ‚Äî linking the image so that each point of the image is given the coordinate of the corresponding point on the ground.  Mathematically, geolocation is usually performed using power polynomials.  The accuracy of the binding increases in the presence of reference points, then the snapshot seems to be ‚Äúplanted‚Äù over them.  After geocoding, the brightness characteristics of an already transformed image are determined by various methods: the nearest neighbor, bilinear interpolation, bicubic convolution. </li><li>  <i>Orthotransformation</i> - when it eliminates image errors due to differences in the heights of the terrain, as a result, many central design flaws are eliminated in the resulting image. </li></ol><br><br><h5>  The following is a process for improving image quality, including: </h5><br><ol><li>  <i>Spectral transformations</i> that are based on the work with the <b>spectral chart</b> - a graph showing the relationship between the number of pixels of the image and the values ‚Äã‚Äãof the spectral brightness.  With spectral transformations, such a parameter as <b>contrast is</b> changed.  To enhance it, there are a number of methods, for example: <br><ul><li>  linear stretching of the histogram, which consists in the fact that all values ‚Äã‚Äãof brightness are assigned new values ‚Äã‚Äãin order to cover the entire possible range from 0 to 255: <br><img src="https://habrastorage.org/getpro/habr/post_images/43b/c1a/19a/43bc1a19aeaa90d630b0e823117b0bf0.png"></li><li>  Histogram normalization - only the most intensive (most informative) section of the diagram is stretched over the entire range of brightness values: <br><img src="https://habrastorage.org/getpro/habr/post_images/85b/644/50b/85b64450b97417bd658134ef93a0bae4.png"></li><li>  Linearization of the histogram - each pixel is assigned a new brightness value, and in such a way that each brightness level has approximately the same number of pixels: <br><img src="https://habrastorage.org/getpro/habr/post_images/198/0b8/4a7/1980b84a7b49808aca765b890dff49d9.png"></li></ul></li><li>  <i>Filtering</i> - enhances the reproduction of objects, eliminates noise, emphasizes structural lines, smooths the image and does much more - depending on the task.  The whole filtering process is based on the notion of a <b>sliding window</b> - a square matrix of weights (usually it is a 3 * 3 or 5 * 5 matrix).  Each pixel brightness value is recalculated as follows: if a pixel is located in the center of a window moving from pixel to image pixel, then it is assigned a new value calculated from the functional dependencies of the surrounding pixels.  So the window "slips" through all the pixels of the image, changing their value.  Depending on the selected weights, the properties of the resulting image change.  Habrayuser <a href="https://habrahabr.ru/users/unicksoft/" class="user_link">UnickSoft</a> described in more detail the filtering in his <a href="http://habrahabr.ru/post/142818/">post</a> . </li><li>  <i>Fourier transform</i> improves image quality by decomposing it into multiple spatial-frequency components.  The distribution of brightness characteristics in space is represented as a linear combination of periodic functions sin and cos with given characteristics in the frequency domain.  For example, to remove noise, it is enough to reveal the frequency of their appearance. </li></ol><br><br><h5>  The final stage of working with images - decoding </h5><br>  <b>Decryption</b> is the process of detecting and recognizing objects and terrain phenomena in a picture.  It can be either manual, that is based on visual (human) image evaluation, or machine (automatic).  The last, something tells me, is of greater interest to many Habrayuzerov.  Machining, in essence, comes down to different classification mechanisms.  First you need to provide all the pixels (their spectral brightness) as a vector in the space of spectral features.  When analyzing the quantitative relationships of the spectral brightness of different objects, the pixels are divided into classes.  The classification of images is divided into classification with training and classification without training. <br><br><h6>  Classification with training </h6><br>  Classification with training assumes the presence of a reference, with the brightness of which the brightness of each pixel is compared.  As a result, having several standards predetermined, we get a set of objects divided into classes.  This classification only works if the objects that are shown in the image are known in advance, the classes are clearly distinguishable and their number is small. <br>  Here are just a few of the methods that can be used in the classification with training: <br><ol><li>  <i>Minimum distance method</i> - pixel brightness values ‚Äã‚Äãare considered as vectors in the space of spectral features.  Between these values ‚Äã‚Äãand the values ‚Äã‚Äãof the vectors of the reference areas, the spectral distance is calculated as the root of the sum of the squares of the difference between the vectors of the pixel and the standard (in other words, the Euclidean distance between them).  All pixels are divided into classes, depending on whether the distance between them and the standard exceeds the specified or not.  So, if the distance is less, then the class is defined, the pixel can be attributed to the standard: <br><img src="https://habrastorage.org/getpro/habr/post_images/095/228/095/0952280953415bb42e67136c13dbc0fe.png"></li><li> <i>The Mahalanobis distance method</i> is very similar to the first method, only the classification measures not the Euclidean distance between the vectors, but the Mahalanobis distance, which takes into account the dispersion of the brightness values ‚Äã‚Äãof the standard.  In this way, if the Euclidean distance to two standards from a given pixel is equal, then the class that has a greater variance of the reference sample will win: <br><img src="https://habrastorage.org/getpro/habr/post_images/3b1/ea5/055/3b1ea5055e2618745cd784f365a9f368.png"></li><li>  <i>The method of spectral angle</i> - initially sets the maximum value of the spectral angle (the angle between the reference vector and the vector of a given pixel).  The spectral angle is located, and, as with the Euclidean distance, if the angle is less than the specified one, then the pixel falls into the standard class, with which the comparison is made: <br><img src="https://habrastorage.org/getpro/habr/post_images/e2e/fba/1c1/e2efba1c16d398b481fbea70edc0a7f8.png"></li></ol><br><br><h6>  Classification without training </h6><br>  Classification without training is based on the fully automatic distribution of pixels by class based on the statistics of the distribution of brightness pixel values.  This type of classification is used if it is not initially known how many objects are present in the image, the number of objects is large, as a result the machine itself produces the resulting classes, and we already determine which objects to put them in line with. <br><ol><li>  <i>The ISODATA (Iterative Self-Organizing Data Analysis Technique Algorithm)</i> method is based on cluster analysis using the method of successive approximations.  After considering the brightness of the pixels as vectors in the space of spectral features, the closest ones are defined in one class.  For each spectral zone, statistical parameters of the brightness distribution are calculated.  All pixels are divided into some n number of equal ranges, within each of which there is an average value.  For each pixel of the range, the spectral distance to the average value is calculated.  All pixels, the distance between which the smallest are defined in one cluster.  This is the first iteration.  In the second iteration and subsequent ones, the calculation of the already actual average values ‚Äã‚Äãfor each cluster takes place.  Each new iteration clarifies the boundaries of future classes: <br><img src="https://habrastorage.org/getpro/habr/post_images/29f/f41/4b9/29ff414b9c9e2a4778d4c741f9061b17.png"></li><li>  <i>The K-means method</i> is similar to the previous method, with the only exception that the initial average values ‚Äã‚Äãare set (this is possible only if the objects in the image are well readable). </li></ol><br><br>  All processes of preprocessing and improving the quality of images, as well as decoding, constitute a huge field for reasoning, each of them can serve as a reason for a whole article (and not just one).  If anyone is interested in a specific topic, please leave your wishes in the comments for the subsequent development of the plot.  Further, a post is planned on the use of various indices, such as vegetative NDVI, to improve the interpretation and identification of objects. <br><br>  The article used information <a href="http://www.nrcgit.ru/aster/methods/">from the site</a> , also from the following sources: <a href="http://window.edu.ru/resource/028/76028">1</a> and <a href="http://rutracker.org/forum/viewtopic.php%3Ft%3D3703416">2</a> . <br><br>  PS There is an opportunity to download digital data for free on the website <a href="http://earthexplorer.usgs.gov/">of the US Geological Survey</a> <br>  For your own experiments in the processing of images there is a <a href="http://www.scanex.com/en/software/downloads.asp">free demo software</a> (albeit with some limited functions, compared to the full version, but enough for a warm-up) and <a href="http://envi-ex.software.informer.com/4.8/">one more software</a> . </div><p>Source: <a href="https://habr.com/ru/post/210810/">https://habr.com/ru/post/210810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210796/index.html">How I knocked out a Facebook interview</a></li>
<li><a href="../2108/index.html">Russia is preparing software to fight the spread of drugs</a></li>
<li><a href="../210800/index.html">DUMP-2014 will be held in Yekaterinburg on March 14</a></li>
<li><a href="../210808/index.html">We are not building our analogue Google Calendar in 30 lines</a></li>
<li><a href="../21081/index.html">Children's access to adult sites</a></li>
<li><a href="../210812/index.html">Method of comparing algorithms and for what it may still be useful</a></li>
<li><a href="../210814/index.html">We do automatic watering of a room flower on Arduino in 15 minutes</a></li>
<li><a href="../210816/index.html">Creating and using Matlab clusters</a></li>
<li><a href="../210818/index.html">Resurrection Sharepoint or how not to burn at the stake of the Inquisition</a></li>
<li><a href="../21082/index.html">We read Aldebaran with convenience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>