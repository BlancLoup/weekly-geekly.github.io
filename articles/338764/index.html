<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making MitM using openssl on Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivation 


 It is difficult to find information on the OpenSSL API library on the Russian-language Internet. Much attention is paid to using consol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making MitM using openssl on Android</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/832/6e0/9c0/8326e09c05d3ad61d45e57578536a06d.jpg" alt="image"></p><br><h1 id="motivaciya">  Motivation </h1><br><p>  It is difficult to find information on the OpenSSL API library on the Russian-language Internet.  Much attention is paid to using console commands to manipulate self-signed certificates for web servers or OpenVPN servers. </p><br><p>  This approach is good when you need to make a couple of certificates per hour.  And if you need to create a couple of hundred in a minute?  Or write a script and parse the output from the console?  And if an error occurred in the process? </p><br><p>  Using the API, generating certificates, validating and signing is much easier.  It becomes possible to monitor and handle errors at all stages of work, as well as specify additional certificate parameters (since not all parameters can be set from the console) and fine-tune it. </p><br><p>  Separately, it is worth noting the network component.  If the certificate is and simply lies on the disk, it is useless. </p><br><p>  Unfortunately, there is very little Russian documentation on the organization of an SSL server, on how to organize an SSL client to receive data.  Official <a href="https://www.openssl.org/docs/man1.0.2/">documentation is</a> not so complete and good, so that you can immediately get involved in working with the library.  Not all functions are described in detail, you have to experiment with the parameters, in what sequence and what exactly needs to be cleaned, and what the library will remove on its own. </p><br><p>  This article is a compilation of my experience with the OpenSSL library when implementing a client-server application.  The functions described in it will work both on the desktop and on Android devices.  Attached to the article is a repository with C / C ++ code so that you can see the work of the described functions. </p><br><h1 id="cel-cut-">  purpose <a name="habracut"></a></h1><br><p>  When studying a new library or technology, I try to solve problems with the help of a new functional.  In this case, try to make <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2582%25D0%25B0%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE%25D1%2581%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0">MITM</a> <br>  to intercept traffic to the <strong>HTTPS</strong> server. </p><br><p>  Formulate the requirements for the program: <br>  Wait for port connections (SSL server) <br>  When an incoming connection appears: </p><br><ul><li>  Connect to HTTPS server </li><li>  Read client request to server </li><li>  Send the data read from the client to the server </li><li>  Read server response </li><li>  Send server response to client </li><li>  Reset connections </li></ul><br><p>  Since we will have an SSL server, we will need a certificate from a certificate authority and a certificate for our server. <br>  Let this data be generated by our program, and the CA certificate will be uploaded to a file in the working folder of the program. </p><br><p>  Development will be conducted on Ubuntu, other tools: GCC compiler 5.4.0, OpenSSL 1.0.2, curl 7.52.1, CMake 3.8.1 (the only one not from the packages). </p><br><p>  To send requests to our application, we will use <a href="https://curl.haxx.se/">curl</a> from the console.  Since we need to specify a CA certificate, the command will look like this: </p><br><pre><code class="bash hljs">curl --cacert ca.crt -v https://127.0.0.1:5566 -H <span class="hljs-string"><span class="hljs-string">"Host: taigasystem.com"</span></span></code> </pre> <br><p>  Specifying the <strong>Host</strong> header is required in order for curl to correctly compose an HTTP request.  Without this, the server will respond with an error. </p><br><h1 id="nachalo-i-zavershenie-raboty">  Start and end of work </h1><br><p>  To work with the <strong>OpenSSL</strong> library, you need to initialize it.  Use the following code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;openssl/bio.h&gt; #include &lt;openssl/ssl.h&gt; #include &lt;openssl/err.h&gt; ... void InitOpenSSL() { OpenSSL_add_all_algorithms(); ERR_load_BIO_strings(); ERR_load_crypto_strings(); SSL_load_error_strings(); SSL_library_init(); }</span></span></span></span></code> </pre> <br><p>  Before completing the application, you should clean the library, for this you can use the following code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearOpenSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EVP_cleanup(); CRYPTO_cleanup_all_ex_data(); ERR_remove_thread_state(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); ERR_free_strings(); }</code> </pre> <br><h1 id="kontekst">  Context </h1><br><p>  Most <strong>OpenSSL</strong> library operations require context.  This structure, which stores the algorithms used, their parameters and other data.  It is created using the function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">SSL_CTX *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSL_CTX_new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SSL_METHOD *method)</span></span></span></span>;</code> </pre> <br><p>  The list of methods that can be passed to this function is quite extensive, but the <a href="https://wiki.openssl.org/index.php/Manual:SSL_CTX_new(3)">documentation</a> tells us that we need to use <code>SSLv23_server_method()</code> for the server and <code>SSLv23_client_method()</code> for the client. </p><br><p>  At the same time, the library will automatically select the most secure protocol supported by the client and server. </p><br><p>  Here is an example of creating a context for a client: </p><br><pre> <code class="cpp hljs">SSL_CTX *ctx = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ctx = SSL_CTX_new(SSLv23_client_method()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  To remove the context correctly, use the <code>SSL_CTX_free</code> function. </p><br><p>  I do not really like to use <code>SSL_CTX_free</code> every time the context needs to be deleted.  You can use smart pointers with the delete function or wrap the structure in a <strong>RAII</strong> class: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;SSL_CTX&gt; m_ctx(ctx, SSL_CTX_free);</code> </pre> <br><h1 id="rabota-s-oshibkami">  Work with errors </h1><br><p>  Most of the <strong>OpenSSL</strong> library functions return <strong>1</strong> as a sign of successful execution.  Here is the usual code to check for an error: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SSL_CTX_load_verify_locations(ctx, fileName, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  However, sometimes this is not enough, and sometimes a more detailed description of the problem is needed.  To do this, <strong>OpenSSL</strong> uses a separate message queue for each stream.  To retrieve the error code from the queue, use the <code>ERR_get_error()</code> function. </p><br><p>  The error code itself is not very user-friendly, so you can use the <code>ERR_error_string</code> function to get a string representation of the error code.  If the function returns <strong>0</strong> , it means that there is no error. </p><br><p>  Here is an example of getting a string describing an error by an error code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;openssl/err.h&gt; ... // -   OpenSSL std::cerr &lt;&lt; ERR_error_string(ERR_get_error(), NULL) &lt;&lt; std::endl; ...</span></span></span></span></code> </pre> <br><p>  The second parameter of the <code>ERR_error_string</code> function is a pointer to a buffer that must be at least 120 characters long.  If you do not specify it, the static buffer will be used, which is overwritten each time this function is called. </p><br><p>  It is worth noting that for each separate thread a separate queue of error messages is created. </p><br><h1 id="klyuchi">  Keys </h1><br><p>  Now, in order to organize an OpenSSL server, we need to create a certificate of certification authority and a server certificate.  For each of them we need to create keys for the signature. </p><br><h2 id="sozdanie">  Creature </h2><br><p>  <strong>OpenSSL</strong> uses the <code>EVP_PKEY</code> structure to store the private / public key <code>EVP_PKEY</code> .  This structure is created as follows: </p><br><pre> <code class="cpp hljs">EVP_PKEY *pkey = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; pkey = EVP_PKEY_new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pkey == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  Read more about <strong>EVP</strong> <a href="https://wiki.openssl.org/index.php/EVP">here</a> . </p><br><p>  Inverse for <code>EVP_PKEY_new</code> function frees the memory and deletes the <code>EVP_PKEY</code> structure. </p><br><p>  Now it is necessary to prepare the <code>BIGNUM</code> structure for generating <strong>RSA</strong> (for more information about this structure, see <a href="https://wiki.openssl.org/index.php/Manual:Bn_internal%25283%2529">here</a> ): </p><br><pre> <code class="cpp hljs">BIGNUM *big = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; big = BN_new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (big == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  } else if (BN_set_word(big, RSA_F4) != 1) { //  BN_free(big); }</span></span></code> </pre> <br><p>  The <code>BN_set_word</code> function sets the size for the <code>BIGNUM</code> structure.  Valid values ‚Äã‚Äãare <code>RSA_3</code> and <code>RSA_F4</code> , the latter is preferred. </p><br><p>  The turn has come for key generation.  To do this, create an <code>RSA</code> structure: </p><br><pre> <code class="cpp hljs">RSA *rsa = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; rsa = RSA_new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsa == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  Now the key generation itself: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RSA_generate_key_ex(rsa, <span class="hljs-number"><span class="hljs-number">4096</span></span>, big, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  <strong>4096</strong> is the size of the key we want to receive. </p><br><p>  We finish the generation of keys by writing new keys to the <code>EVP_PKEY</code> structure: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EVP_PKEY_assign_RSA(pkey, rsa) !=<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><h2 id="pem-format">  PEM format </h2><br><p>  <strong>PEM</strong> is a fairly simple format for storing keys and certificates.  It is a text file in which records of the following type are stored sequentially: </p><br><pre> <code class="hljs delphi">-----<span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> RSA <span class="hljs-keyword"><span class="hljs-keyword">PRIVATE</span></span> KEY----- MIIJJwIBAAKCAgEAvNwgYmIyfvY6IsVZwRCkAHTOhwE3Rp/uNcUoTcPl5atOwPVW JLY3odYmILsa8se7B/aNNzO7AlvXwlzxinQ3AF7l37LqGzf8v16TFVN4kit8vrq0 V9bBXHpiWH+YQT4gBVmSkwqEMZ/wQlUOIxz4Q2M7cXRu4fRe3rt3kGHCPJ66Ybax yEp6nfdK8IKsyxqAXjBkqfC5rkdw2n7UAd/OnPRCDowyvythDb8jR1LkbJjlIatK .... yajhmBDpS11hzuWHhDmpjbrV79OMRzKQAWBKRubObtGIsFB2CzbabusV+oq/Y78y OxriZYqoRv3WB5GH/pPO9w1ptveddLU33NVBSRfFS1jyqyj/<span class="hljs-number"><span class="hljs-number">1</span></span>CqXlE4gcQ== -----<span class="hljs-keyword"><span class="hljs-keyword">END</span></span> RSA <span class="hljs-keyword"><span class="hljs-keyword">PRIVATE</span></span> KEY----- -----<span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CERTIFICATE----- MIIFkTCCA3mgAwIBAgIJAMPIqA2oVd/SMA0GCSqGSIb3DQEBCwUAMF8xCzAJBgNV BAYTAlJVMQ8wDQYDVQQIDAZNb3Njb3cxDzANBgNVBAcMBk1vc2NvdzEUMBIGA1UE ... bt9NHGnCxYcParG+YqU5UTUrCUGUfnZhJAX+qkgsVSC5c81Tk0VXTQx3EiEvdzV+ wUX9LMRLIxjy1D5AO6a29LkzNAvw+iFm36VO+ssdkJW4Q6MAYA== -----<span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CERTIFICATE-----</code> </pre> <br><p>  It is worth noting that the number of characters <strong>-----</strong> at the beginning of the title and at the end, as well as in the closing line, should be the same. </p><br><p>  In more detail this format is described here: <br>  - <a href="https://tools.ietf.org/html/rfc1421">RFC1421</a> Part I: Message Encryption and Authentication Procedures <br>  - <a href="https://tools.ietf.org/html/rfc1422">RFC1422</a> Part II: Certificate-Based Key Management <br>  - <a href="https://tools.ietf.org/html/rfc1423">RFC1423</a> Part III: Algorithms, Modes, and Identifiers <br>  - <a href="https://tools.ietf.org/html/rfc1424">RFC1424</a> Part IV: Key Certification and Related Services </p><br><h2 id="zapis-klyuchey-v-pem-formate">  Write keys in PEM format </h2><br><p>  Suppose we have a public / private key pair in the <strong>EVP_PKEY</strong> structure, then to write them to a file, use the <code>PEM_write_PrivateKey</code> and <code>PEM_write_PUBKEY</code> . </p><br><p>  Here is an example of using these functions: </p><br><pre> <code class="cpp hljs">FILE *f = fopen(<span class="hljs-string"><span class="hljs-string">"server.pem"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PEM_write_PrivateKey(f, key, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//  fclose(f); } else if (!PEM_write_PUBKEY(f, key)) { //  fclose(f); } fclose(f);</span></span></code> </pre> <br><p>  It is worth giving some explanations regarding the function </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_write_PrivateKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *fp, EVP_PKEY *x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EVP_CIPHER *enc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kstr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> klen, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>;</code> </pre> <br><p>  where <code>const EVP_CIPHER *enc</code> is a pointer to an encryption algorithm for encrypting a private key before it is saved. <br>  For example, <code>EVP_aes_256_cbc()</code> means "AES with a 256-bit key in CBC". </p><br><p>  There <a href="https://www.openssl.org/docs/man1.1.0/crypto/EVP_aes_256_cbc.html">are a lot of</a> encryption algorithms, and you can always <br>  pick something to your liking.  Relevant definitions can be found in <code>openssl/evp.h</code> <br>  <code>unsigned char *kstr</code> expects to get a pointer to a string with a password to encrypt the key, and <code>int klen</code> is the length of this string. </p><br><p>  If <code>kstr</code> and <code>klen</code> , the <code>cb</code> and <code>u</code> parameters are ignored, where: - <strong>cb</strong> is a pointer to a function of the form: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rwflag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>;</code> </pre> <br><p>  - buf - pointer to the buffer for recording the password <br>  - size - maximum password size (i.e. buffer size) <br>  - rwflag is 0 for reading and 1 for writing </p><br><p>  The result of the function is the password length or 0 in case of an error. </p><br><p>  The <code>void *u</code> parameter for both functions is used to transfer additional data.  For example, as a pointer to a window for a <strong>GUI</strong> application. </p><br><h2 id="zagruzka-klyuchey-iz-pem-fayla">  Loading keys from a PEM file </h2><br><p>  Keys are <code>PEM_read_PrivateKey</code> using the <code>PEM_read_PrivateKey</code> and <code>PEM_read_PUBKEY</code> .  Both functions have the same parameters and return value: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EVP_PKEY *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_read_PUBKEY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">EVP_PKEY *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_read_PrivateKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>;</code> </pre> <br><p>  Where: <br>  - <code>FILE *fp</code> - open file descriptor <br>  - <code>EVP_PKEY **x</code> - structure that must be overwritten <br>  - <code>pem_password_cb *cb</code> - the function to get the key decryption password <br>  - <code>void *u</code> - string with key password, ending with <code>\0</code> </p><br><p>  Here is an example of a function to get a password to decrypt a key: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pass_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rwflag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *tmp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rwflag == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)u &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    : "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pass; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; pass; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pass.empty() || pass.length() &lt;=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; len = pass.length(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; size) len = size; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(buf, pass.c_str(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len; }</code> </pre> <br><p>  Here is an example of how you can load an unencrypted private key from a file: </p><br><pre> <code class="cpp hljs">FILE *f = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; f = fopen(fileName.c_str(), <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  } EVP_PKEY *key = NULL; key = PEM_read_PrivateKey(f, NULL, NULL, NULL); if (key == NULL) { //  } fclose(f);</span></span></code> </pre> <br><h2 id="zagruzka-klyuchey-iz-pamyati">  Loading keys from memory </h2><br><p>  Sometimes it is convenient to store a key or certificate as a constant in the program.  For such cases, you can use the structure type <a href="https://wiki.openssl.org/index.php/BIO">BIO</a> .  This structure and its associated functions repeat the I / O functionality for <code>FILE</code> . </p><br><p>  This is how you can load the key from memory: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *key = <span class="hljs-string"><span class="hljs-string">"-----BEGIN RSA PRIVATE KEY-----\n"</span></span> <span class="hljs-string"><span class="hljs-string">"MIIJKAIBAAKCAgEA40vjOGzVpuJv+wIfNBQSr9U/EeRyvSy/L6Idwh799LOPIwjF\n"</span></span> ..... <span class="hljs-string"><span class="hljs-string">"zkxvkGMPBY3BcSPjipuydWTt8xE8MOe0SmEcytHZ/DifwF9qyToDlTFOUN8=\n"</span></span> <span class="hljs-string"><span class="hljs-string">"-----END RSA PRIVATE KEY-----"</span></span>; BIO *buf = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; buf = BIO_new_mem_buf(key, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buf == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  } EVP_PKEY *pkey = NULL; pkey = PEM_read_bio_PrivateKey(buf, NULL, NULL, NULL); if (pkey == NULL) { //  }</span></span></code> </pre> <br><h1 id="zapros-sertifikata">  Certificate Request </h1><br><p>  Now that we can create keys, let's see how to create certificates.  Certificates can be self-signed or have a signature from a certification authority.  To obtain a certificate signed by the certification authority, you must create a certificate request ( <strong>CSR</strong> ) and send it to the certification authority.  In response, he will send a signed certificate. </p><br><p>  In the case when we want to create a self-signed certificate or a certificate for our own certifying center, you do not need to create a <strong>CSR</strong> , you can immediately go to the <a href="https://habr.com/ru/company/infowatch/blog/338764/">Certificates</a> section. </p><br><h2 id="sozdanie-1">  Creature </h2><br><p>  <strong>Certificate Signing Request</strong> (CSR) is a message or request that the certificate issuer sends to the certification authority (CA) and which contains information about the public key, country of issue, as well as the digital signature of the creator. </p><br><p>  To create a <strong>CSR,</strong> we need the key <code>EVP_PKEY</code> created earlier.  It all starts with memory allocation for the <strong>CSR</strong> structure: </p><br><pre> <code class="cpp hljs">X509_REQ *req = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; req = X509_REQ_new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  The inverse function to <code>X509_REQ_new</code> is <code>X509_REQ_free</code> . </p><br><p>  Now you need to set the version of the certificate.  In this case, the version is 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X509_REQ_set_version(req, <span class="hljs-number"><span class="hljs-number">2</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  X509_REQ_free(req); }</span></span></code> </pre> <br><p>  According to the <a href="https://tools.ietf.org/html/rfc2459">X.509</a> standard <a href="https://tools.ietf.org/html/rfc2459">,</a> this version should be one less than the certificate version.  Those.  For certificate version 3, the number 2 should be used. </p><br><p>  Now we will set the data of the request creator.  We will use the following fields: </p><br><p>  - <strong></strong> - two-letter country code, for example, <strong>RU</strong> <br>  - <strong>ST</strong> - region, in our case <strong>Moscow</strong> <br>  - <strong>L</strong> - city, again <strong>Moscow</strong> <br>  - <strong>O</strong> - organization, for example <strong>Taigasystem</strong> <br>  - <strong>CN</strong> is a domain name, <strong>taigasystem.com</strong> will be for us </p><br><p>  This is how these fields are specified in the query: </p><br><pre> <code class="cpp hljs">X509_NAME *name = X509_REQ_get_subject_name(req); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X509_NAME_add_entry_by_txt(name, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, MBSTRING_ASC, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-string"><span class="hljs-string">"RU"</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  X509_REQ_free(req); } if (X509_NAME_add_entry_by_txt(name, "ST", MBSTRING_ASC, (const unsigned char *)"Moscow", -1, -1, 0) != 1) { //  } if (X509_NAME_add_entry_by_txt(name, "L", MBSTRING_ASC, (const unsigned char *)"Moscow", -1, -1, 0) != 1) { //  } if (X509_NAME_add_entry_by_txt(name, "O", MBSTRING_ASC, (const unsigned char *)"Taigasystem", -1, -1, 0) != 1) { //  } if (X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC, (const unsigned char *)"taigasystem.com", -1, -1, 0) != 1) { //  }</span></span></code> </pre> <br><p>  Note that we first get the <code>X509_NAME</code> structure from the CSR request structure and set the values ‚Äã‚Äãfor it. </p><br><p>  Now you need to set the public key for this request: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X509_REQ_set_pubkey(req, key) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  The final touch is the request signature: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X509_REQ_sign(req, key, EVP_sha256()) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  Unlike other <strong>OpenSSL</strong> functions, <code>X509_REQ_sign</code> <a href="https://www.openssl.org/docs/man1.1.0/crypto/X509_REQ_sign.html">returns</a> <br>  signature size in bytes, not 1, on successful completion, and 0 in the case of an error. </p><br><p>  Now the certificate request is ready. </p><br><h2 id="sohranenie-csr-v-fayl">  Save CSR to file </h2><br><p>  Saving a <strong>CSR</strong> to a file is quite simple.  You need to open the file, and then call the function <code>PEM_write_X509_REQ</code> : </p><br><pre> <code class="cpp hljs">FILE *f = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; f = fopen(<span class="hljs-string"><span class="hljs-string">"server.csr"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PEM_write_X509_REQ(f, csr) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  fclose(f); } fclose(f);</span></span></code> </pre> <br><p>  As a result, we get the following text in the <strong>server.csr</strong> file: </p><br><pre> <code class="hljs vbscript">-----BEGIN CERTIFICATE <span class="hljs-built_in"><span class="hljs-built_in">REQUEST</span></span>----- MIICnzCCAYcCAQEwWjELMAkGA1UEBhMCUlUxDzANBgNVBAgMBlJ1c3NpYTEPMA0G ... fbzFJ6EM00mbyr472lEXZpvdZgBCfxpkNDyp9nsiIQf0EyC05MgufOAKDT/fGQfa <span class="hljs-number"><span class="hljs-number">4</span></span>gWK -----<span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CERTIFICATE <span class="hljs-built_in"><span class="hljs-built_in">REQUEST</span></span>-----</code> </pre><br><h2 id="zagruzka-csr-iz-fayla">  Download CSR from file </h2><br><p>  To download <strong>CSR</strong> , use the following functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X509_REQ *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_read_X509_REQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *fp, X509_REQ **x, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">X509_REQ *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_read_bio_X509_REQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BIO *bp, X509_REQ **x, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>;</code> </pre> <br><p>  The first one loads the <strong>CSR</strong> from the file, the second one allows to load the <strong>CSR</strong> from memory. </p><br><p>  Parameters of the data function are similar to <a href="https://habr.com/ru/company/infowatch/blog/338764/">loading keys from a PEM file</a> , for <br>  with the exception of <code>pem_password_cb</code> and <code>u</code> , which are ignored. </p><br><h1 id="sertifikaty">  Certificates </h1><br><h2 id="x509-sertifikat">  X.509 certificate </h2><br><p>  <strong>X.509</strong> is one of the variations of the <a href="https://ru.wikipedia.org/wiki/ASN.1">ASN.1</a> language, standardized in <a href="https://tools.ietf.org/html/rfc2459">rfc2459</a> . </p><br><p>  You can read more about <strong>X.509</strong> format <a href="http://pro-ldap.ru/tr/zytrax/tech/ssl.html">here</a> and <a href="https://habrahabr.ru/post/194664/">here</a> . </p><br><h2 id="generaciya-sertifikata-bez-csr">  Certificate generation without CSR </h2><br><p>  You can generate a certificate without using <strong>CSR</strong> .  This is useful for creating a <strong>CA.</strong> </p><br><p>  To generate a certificate without <strong>CSR,</strong> we need a public / private key pair in the <code>EVP_PKEY</code> structure.  We start by allocating memory for the certificate structure: </p><br><pre> <code class="cpp hljs">X509 *x509 = X509_new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x509) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  The reverse for <code>X509_new</code> is <code>X509_free</code> . </p><br><p>  The certificate is created in the same way as the <strong>CSR</strong> request, with only one difference - in addition to the version and data of the publisher, you must specify the serial number of the certificate. </p><br><p>  You also need to use other functions to access certificate data: <br>  - <code>X509_set_version</code> instead of <code>X509_REQ_set_version</code> <br>  - <code>X509_get_subject_name</code> instead of <code>X509_REQ_get_subject_name</code> <br>  - <code>X509_set_pubkey</code> instead of <code>X509_REQ_set_pubkey</code> <br>  - <code>X509_sign</code> instead of <code>X509_REQ_sign</code> </p><br><p>  Thus, it becomes quite simple to distinguish by name the objects for which certain functions are intended. </p><br><p>  Now you can set the serial number of the certificate: </p><br><pre> <code class="cpp hljs">ASN1_INTEGER *aserial = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; aserial = M_ASN1_INTEGER_new(); ASN1_INTEGER_set(aserial, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X509_set_serialNumber(x509, aserial) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  For each new certificate, you must create a new serial number. </p><br><p>  Now it's time to set the certificate lifetime.  For this, two parameters are set - the beginning and the end of the certificate life: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(X509_gmtime_adj(X509_get_notBefore(cert), <span class="hljs-number"><span class="hljs-number">0</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  X509_free(cert); } // 31536000 * 3 = 3 year valid period if (!(X509_gmtime_adj(X509_get_notAfter(cert), 31536000 * 3))) { //  X509_free(cert); }</span></span></code> </pre> <br><p>  The beginning of the life of the certificate will be the moment of its release - the value <strong>0</strong> for the function <code>X509_get_notBefore</code> .  The end of the certificate life is set by the <code>X509_get_notAfter</code> function. </p><br><p>  The final touch is the signature of the certificate using the private key: </p><br><pre> <code class="cpp hljs">EVP_PKEY *key; <span class="hljs-comment"><span class="hljs-comment">// Not null if (X509_sign(cert, key, EVP_sha256()) &lt;=0) { long e = ERR_get_error(); if (e != 0) { //  X509_free(cert); } }</span></span></code> </pre> <br><p>  There is an interesting feature here: the <code>X509_sign</code> function returns the signature size in bytes, if everything went well, and <strong>0</strong> in case of an error.  Sometimes the function returns zero, even if there is no error.  Therefore, it is necessary to introduce an additional error check here. </p><br><h2 id="generaciya-sertifikata-s-csr">  Certificate Generation with CSR </h2><br><p>  To generate a <strong>CSR</strong> certificate, we need the <strong>CA</strong> private key to sign the certificate, the <strong>CA</strong> certificate to set the publisher data and the <strong>CSR</strong> request itself. </p><br><p>  Creating the certificate itself and installing the version and number are the same as for the certificate without CSR.  The difference appears when you need to extract the publisher data from the CSR request and install it in the certificate: </p><br><pre> <code class="cpp hljs">X509_REQ *csr; <span class="hljs-comment"><span class="hljs-comment">//not null X509_NAME *name = NULL; name = X509_REQ_get_subject_name(csr); if (name == NULL) { //  X509_free(cert); } if (X509_set_subject_name(cert, name) != 1) { //  X509_free(cert); }</span></span></code> </pre> <br><p>  After that, you need to fix the data of the issuer of the certificate.  This requires a <strong>CA</strong> certificate: </p><br><pre> <code class="cpp hljs">X509 *CAcert; <span class="hljs-comment"><span class="hljs-comment">//not null name = X509_get_subject_name(CAcert); if (name == NULL) { //  X509_free(cert); } if (X509_set_issuer_name(cert, name) != 1) { //  X509_free(cert); }</span></span></code> </pre> <br><p>  It can be seen that we set the data from the CSR using <code>X509_set_subject_name</code> , and the CA data using <code>X509_set_issuer_name</code> . </p><br><p>  The next step is to get the public key from the <strong>CSR</strong> and install it into the new certificate. <br>  In addition to installing the key, you can immediately check whether the <strong>CSR</strong> was signed with this key: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Get pub key from CSR EVP_PKEY *csr_key = NULL; csr_key = X509_REQ_get_pubkey(csr); if (csr_key == NULL) { //  } // Verify CSR if (X509_REQ_verify(csr, csr_key) !=1) { //  X509_free(cert); } // Set pub key to new cert if (X509_set_pubkey(cert, csr_key) != 1) { //  X509_free(cert); }</span></span></code> </pre> <br><p>  Now you can set the serial number of the certificate: </p><br><pre> <code class="cpp hljs">ASN1_INTEGER *aserial = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; aserial = M_ASN1_INTEGER_new(); ASN1_INTEGER_set(aserial, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X509_set_serialNumber(cert, aserial) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  The final touch is to sign the certificate using the <strong>CA's</strong> private key: </p><br><pre> <code class="cpp hljs">EVP_PKEY *CAkey; <span class="hljs-comment"><span class="hljs-comment">// Not null if (X509_sign(cert, CAkey, EVP_sha256()) &lt;=0) { long e = ERR_get_error(); if (e != 0) { //  X509_free(cert); } }</span></span></code> </pre> <br><p>  After signing our new certificate is ready. </p><br><h2 id="sohranenie-x509-sertifikata">  Saving an X.509 certificate </h2><br><p>  Saving is pretty simple: </p><br><pre> <code class="cpp hljs">X509 *cert; ... FILE *f = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; f = fopen(<span class="hljs-string"><span class="hljs-string">"server.crt"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PEM_write_X509(f, cert)) { <span class="hljs-comment"><span class="hljs-comment">//  fclose(f); } fclose(f);</span></span></code> </pre> <br><h2 id="zagruzka-x509-sertifikata">  Uploading X.509 Certificate </h2><br><p>  Loading takes place using two functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X509 *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_read_X509</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *fp, X509 **x, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">X509 *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PEM_read_bio_X509</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BIO *bp, X509 **x, pem_password_cb *cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u)</span></span></span></span>;</code> </pre> <br><p>  The parameters are described <a href="https://habr.com/ru/company/infowatch/blog/338764/">above</a> . </p><br><h1 id="setevaya-chast">  Network part </h1><br><h2 id="klient">  Customer </h2><br><p>  Connecting to a host using <strong>SSL</strong> sockets is not very different from a normal <strong>TCP</strong> connection. </p><br><p>  First you need to create a <strong>TCP</strong> connection to the server: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  IP   struct hostent *ip = nullptr; ip = gethostbyname(host.c_str()); if (ip == nullptr) { //  } //  int sock = socket(AF_INET, SOCK_STREAM, 0); if (sock == -1) { //  } struct sockaddr_in dest_addr; memset(&amp;dest_addr, 0, sizeof(struct sockaddr_in)); dest_addr.sin_family = AF_INET; dest_addr.sin_port = htons(port); dest_addr.sin_addr.s_addr = *(long *)(ip-&gt;h_addr); //: if (connect(sock, (struct sockaddr *)&amp;dest_addr, sizeof(struct sockaddr)) == -1) { //   }</span></span></code> </pre> <br><p>  Now you need to create a client-side <strong>SSL-</strong> context: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SSL_METHOD *method = SSLv23_client_method(); SSL_CTX *ctx = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ctx = SSL_CTX_new(method); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  Now you need to install the resulting socket in the <strong>SSL-</strong> structure.  It is derived from the context: </p><br><pre> <code class="cpp hljs">SSL *ssl = SSL_new(ctx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ssl == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  } if (SSL_set_fd(ssl, sock) != 1) { //  }</span></span></code> </pre> <br><p>  The final touch is the connection itself: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SSL_connect(ssl) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><h2 id="chtenie-dannyh">  Reading data </h2><br><p>  To read data from an <strong>SSL</strong> socket, use the function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSL_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSL *ssl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num)</span></span></span></span>;</code> </pre> <br><p>  It reads data from a socket bound to an <strong>SSL</strong> structure to the buffer.  If you need to know if there is data in the socket buffer that needs to be read, you can use the function </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSL_pending</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SSL *ssl)</span></span></span></span>;</code> </pre> <br><p>  Those.  for reading you can use the following construction: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = SSL_pending(ssl); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[size]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(buf, <span class="hljs-number"><span class="hljs-number">0</span></span>, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SSL_read(ssl, buf, size) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  As a result, already decoded data will be in the buffer. </p><br><h2 id="zapis-dannyh">  Data recording </h2><br><p>  For recording, use the function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSL_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSL *ssl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num)</span></span></span></span>;</code> </pre> <br><p>  At the entrance, it receives a pointer to the <strong>SSL</strong> structure that will record, the data itself, and their size. </p><br><p>  Here is an example of such a record: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[] = <span class="hljs-string"><span class="hljs-string">"12345678"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SSL_write(ssl, buf, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(buf)) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><h2 id="server">  Server </h2><br><p>  The server part is similar to the client part - it also needs to get <strong>SSL-</strong> context, and in it - the same functions of reading the record.  The difference is that the server must prepare the context in order to give the client a certificate, as well as arrange a <strong>handshake</strong> with the client. </p><br><p>  Let's start by preparing the context: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SSL_METHOD *method = SSLv23_server_method(); SSL_CTX *ctx = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ctx = SSL_CTX_new(method); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_new.html">Documentation</a> tells us that the choice of <code>SSLv23_server_method</code> will allow the library to independently determine the most secure version of the protocol supported by the client. </p><br><p>  If you need to enable or disable a specific version or change other settings, you can use the <code>SSL_set_options</code> function.  Documentation for it can be found <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_set_options.html">here</a> . </p><br><p>  We considered <a href="https://habr.com/ru/company/infowatch/blog/338764/">loading of the</a> <a href="https://habr.com/ru/company/infowatch/blog/338764/">X.509 certificate</a> and <a href="https://habr.com/ru/company/infowatch/blog/338764/">loading of keys</a> a bit earlier, therefore we believe that we already have a couple of these structures. </p><br><p>  Install the certificate and key for the server context: </p><br><pre> <code class="cpp hljs">X509 *serverCert; <span class="hljs-comment"><span class="hljs-comment">//not null EVP_PKEY *serverKey; //not null if (SSL_CTX_use_certificate(ctx, serverCert) != 1) { //  } if (SSL_CTX_use_PrivateKey(ctx, serverKey) != 1) { //  }</span></span></code> </pre> <br><p>  Our server is ready to accept incoming connections.  Let the usual <code>accept</code> .  We will be interested in the socket received from this function. </p><br><p>  We start with the fact that for each such socket, we need a new <strong>SSL</strong> structure: </p><br><pre> <code class="cpp hljs">SSL *ssl = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ssl = SSL_new(ctx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ssl == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>  Now we install our socket into this structure: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sock; <span class="hljs-comment"><span class="hljs-comment">//accepted tcp socket if (SSL_set_fd(ssl, sock) != 1) { //Hadle error }</span></span></code> </pre> <br><p>  The handshake mechanism itself: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SSL_accept(ssl) != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br><p>    :        ,       .         ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SSL_accept(ssl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  } if (ret &lt; 0) { unsigned long error = ERR_get_error(); if (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE || error == 0) { // ,      //   } else { //  } } if (ret == 1) { // }</span></span></code> </pre> <br><p>          -       . </p><br><h1 id="primer-raboty">  Work example </h1><br><h2 id="sborka-programmy">   </h2><br><p>        : </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build cmake .. make</code> </pre> <br><h2 id="zapusk">  Launch </h2><br><p>    (build)  : </p><br><pre> <code class="hljs">./openssl_api</code> </pre> <br><p>         ca.crt ‚Äî   <br> . </p><br><p>    ,   </p><br><pre> <code class="bash hljs">cppurl --cacert ca.crt -v https://127.0.0.1:5566 -H <span class="hljs-string"><span class="hljs-string">"Host: taigasystem.com"</span></span></code> </pre> <br><p>      CA , <strong>-v</strong>       . <strong>-H "Host: taigasystem.com"</strong> ,    <strong>GET</strong> -  Host.     ,        404- . </p><br><h2 id="vyvod-curl">  curl </h2><br><p>    <strong>curl</strong>      ( ): </p><br><pre> <code class="hljs markdown">$ curl --cacert ca.crt -v https://127.0.0.1:5566 -H "Host: taigasystem.com" <span class="hljs-bullet"><span class="hljs-bullet">* Rebuilt URL to: https://127.0.0.1:5566/ *</span></span> Trying 127.0.0.1... <span class="hljs-bullet"><span class="hljs-bullet">* Connected to 127.0.0.1 (127.0.0.1) port 5566 (#0) *</span></span> found 1 certificates in ca.crt <span class="hljs-bullet"><span class="hljs-bullet">* found 700 certificates in /etc/ssl/certs *</span></span> ALPN, offering http/1.1 <span class="hljs-bullet"><span class="hljs-bullet">* SSL connection using TLS1.2 / RSA_AES_128_GCM_SHA256 *</span></span> server certificate verification OK <span class="hljs-bullet"><span class="hljs-bullet">* server certificate status verification SKIPPED *</span></span> common name: 127.0.0.1 (matched) <span class="hljs-bullet"><span class="hljs-bullet">* server certificate expiration date OK *</span></span> server certificate activation date OK <span class="hljs-bullet"><span class="hljs-bullet">* certificate public key: RSA *</span></span> certificate version: #3 <span class="hljs-bullet"><span class="hljs-bullet">* subject: C=RU,CN=127.0.0.1,L=Moscow,O=Taigasystem,ST=Moscow *</span></span> start date: Mon, 28 Aug 2017 07:36:42 GMT <span class="hljs-bullet"><span class="hljs-bullet">* expire date: Thu, 27 Aug 2020 07:36:42 GMT *</span></span> issuer: C=RU,CN=127.0.0.1,L=Moscow,O=Taigasystem,ST=Moscow <span class="hljs-bullet"><span class="hljs-bullet">* compression: NULL *</span></span> ALPN, server did not agree to a protocol &gt; GET / HTTP/1.1 &gt; Host: taigasystem.com &gt; User-Agent: curl/7.47.0 &gt; Accept: <span class="hljs-emphasis"><span class="hljs-emphasis">*/*</span></span> &gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">HTTP</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1.1</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">200</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">OK</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Server:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">nginx</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1.4.6</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Ubuntu</span></span></span></span><span class="xml"><span class="hljs-tag">) &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Date:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Mon</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">28</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Aug</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2017</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">07:39:18</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">GMT</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Content-Type:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">html</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">utf-8</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Transfer-Encoding:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">chunked</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Connection:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">keep-alive</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Vary:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Accept-Language</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Cookie</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">X-Frame-Options:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">SAMEORIGIN</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Content-Language:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ru</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Strict-Transport-Security:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">max-age</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">604800</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">....</span></span></span></span></span></span></code> </pre> <br><p>  : -,     ; -,       . </p><br><h2 id="vyvod-programmy">   </h2><br><p>        curl   () : </p><br><pre> <code class="hljs coffeescript">$ .<span class="hljs-regexp"><span class="hljs-regexp">/openssl_api  OpenSSL      'curl --cacert ca.crt -v https:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/127.0.0.1:5566 -H "Host: taigasystem.com" '       BIGNUM    BIGNUM  RSA       EVP  .  : 512       BIGNUM    BIGNUM  RSA       EVP CSR .  : 512  .  : 512          ca.crt SSL       5566       taigasystem.com   443    taigasystem.com[188.225.73.237]:443 SSL   SSL   taigasystem.com:443   /</span></span>  <span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">###  79    ###</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span> GET / HTTP<span class="hljs-regexp"><span class="hljs-regexp">/1.1 Host: taigasystem.com User-Agent: curl/7.47.0 Accept: */</span></span>* <span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">###  4096    ###</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span><span class="hljs-comment"><span class="hljs-comment">######</span></span> HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Server: nginx/<span class="hljs-number"><span class="hljs-number">1.4</span></span><span class="hljs-number"><span class="hljs-number">.6</span></span> (Ubuntu) Date: Mon, <span class="hljs-number"><span class="hljs-number">28</span></span> Aug <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">39</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span> GMT Content-Type: text/html; charset=utf<span class="hljs-number"><span class="hljs-number">-8</span></span> Transfer-Encoding: chunked Connection: keep-alive Vary: Accept-Language, Cookie X-Frame-Options: SAMEORIGIN Content-Language: ru Strict-Transport-Security: max-age=<span class="hljs-number"><span class="hljs-number">604800</span></span> ...</code> </pre> <br><p>  Those. ,    <strong>GET</strong> -   (curl)      . </p><br><h1 id="ssylki">  Links </h1><br><ul><li> <a href="http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session">Traffic Analysis of an SSL/TLS Session</a> </li><li> <a href="https://www.openssl.org/docs/man1.0.2/ssl/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Library documentation</font></font></a> </li><li> <a href="https://wiki.wireshark.org/SSL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL examples from Wireshark</font></font></a> </li><li> <a href="https://cmake.org/cmake/help/v3.0/module/FindOpenSSL.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMake Documentation</font></font></a> </li><li> <a href="https://wiki.openssl.org/index.php/Compilation_and_Installation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Library assembly instructions</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL Server Example</font></font></a> </li><li> <a href="https://wiki.openssl.org/index.php/SSL/TLS_Client"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL client example</font></font></a> </li><li> <a href="http://fm4dd.com/openssl/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excellent set of examples in all aspects.</font></font></a> </li><li> <a href="https://pro-ldap.ru/tr/zytrax/tech/ssl.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Survival Guide - TLS / SSL and SSL Certificates (X.509)</font></font></a> </li></ul><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many thanks for the research </font></font><a href="https://habrahabr.ru/users/tomasloh/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomasloh</font></font></a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338764/">https://habr.com/ru/post/338764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338746/index.html">Hosting for a startup: designer, clouds or your own hardware?</a></li>
<li><a href="../338752/index.html">The saga of the Gulf Stream and the level of information security in a large security company</a></li>
<li><a href="../338758/index.html">How Alexey Moiseenkov reached Prisma and went further</a></li>
<li><a href="../338760/index.html">The process of release of iOS-applications in Badoo</a></li>
<li><a href="../338762/index.html">Data geometry 3. Scalar product of pairs</a></li>
<li><a href="../338766/index.html">Options in Swift</a></li>
<li><a href="../338770/index.html">Stream API & ForkJoinPool</a></li>
<li><a href="../338772/index.html">Mobile applications: what is the 2017 holiday season and how to make the most of it?</a></li>
<li><a href="../338776/index.html">How I participated in a Xiaomi bug bounty and what was it for me</a></li>
<li><a href="../338778/index.html">Text Ergonomics: A user of social networks sees about 54,000 words per day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>