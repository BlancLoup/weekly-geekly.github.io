<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blend4Web. Event system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Creating an interactive application is unthinkable without event handling, whether it's keyboard polling or timer operation. The implementation of the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blend4Web. Event system</h1><div class="post__text post__text-html js-mediator-article">  Creating an interactive application is unthinkable without event handling, whether it's keyboard polling or timer operation.  The implementation of these important actions depends on the platform, programming language.  In this article I want to talk about some of the features of using events for the Blend4Web WebGL engine.  Unfortunately, there is very little information on this topic. <br><br><img src="https://habrastorage.org/files/f0b/0ac/439/f0b0ac4395544cffa35fb20dc412c69c.jpg"><br><a name="habracut"></a><br><h4>  Simple approach </h4><br>  In any application there is a main loop, which, for example, polls the keyboard, performs certain logical actions or is responsible for the movement of objects.  So, in the popular Unity engine there is a special Update () event, which developers use for most of the above tasks.  Moreover, if we continue to consider the approaches of the Unity developers to this issue, then the paradigm ‚Äúobject - event‚Äù will be the most important, i.e.  when for each object in the scene there are control scripts and an individual ‚Äúsubscription‚Äú to events. <br><br>  Blend4Web offers a similar approach.  However, it is more based on an event model, which can also be tied to specific objects in the scene. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let us return to the beginning of the article and consider the mechanism of the ‚Äúmain cycle‚Äù. <br><br>  For those who do not want to study the event model, there is the simplest option - the <i>append_loop_cb ()</i> function from the main module. <br><br>  It is easy to use.  Call this function, for example, after initializing the engine and specify the name of the handler as a parameter: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_main= b4w.require (<span class="hljs-string"><span class="hljs-string">"main"</span></span>); m_main. append_loop_cb(update_cb); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_cb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Now the <i>cb_update ()</i> function will be called every frame.  Moreover, this event is not tied to any object.  It can be used for logical constructions, but not for polling input devices, as one would expect.  In general, a survey of the keyboard, mouse, and the like is a separate topic, which I will discuss a little later. <br><br>  The <i>append_loop_cb ()</i> function is easy to use and is suitable for simple logic.  Actually, it is considered obsolete and left in the API for compatibility with previously created applications.  Now there is a steeper mechanism based on events. <br><br>  The event model Blend4Web requires reflection and some getting used to.  But this is only at the beginning.  The main thing is to understand the principles of its work, then everything becomes clear and convenient. <br><br>  At its core is the concept of "sensor".  A sensor is a separate program unit responsible for generating an event for a specific action.  So, there are keyboard, mouse, timer, physics, etc. sensors.  To create each sensor has its own function.  By the way, the whole story of the event model is contained in the module controls. <br><br>  Let's continue consideration of creating a closed loop, but with the help of events.  For this, the set of sensors has a special function <i>create_elapsed_sensor ()</i> .  For example, you can issue its call: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_ct= b4w.require (<span class="hljs-string"><span class="hljs-string">"controls"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _elapsed_sensor = m_ctl.create_elapsed_sensor();</code> </pre><br>  The entity is created, but there is no sense.  And rightly so, because you still need to subscribe to the event.  The API engine has one, universal function, with a large number of parameters: <i>create_sensor_manifold (obj, id, type, sensors, logic_fun, callback, callback_param)</i> . <br><br>  All code in its entirety: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_ct= b4w.require (<span class="hljs-string"><span class="hljs-string">"controls"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  var elapsed_sensor = m_ctl.create_elapsed_sensor(); //‚Äù‚Äù m_ctl.create_sensor_manifold(null, "MAIN", m_ctl.CT_CONTINUOUS, [elapsed_sensor], null, main_cb); ‚Ä¶ //     function main_cb () { //  }</span></span></code> </pre><br>  After that, each frame will call the main_cb function, where you can place the necessary logic.  The result is reminiscent of append_loop_cb, isn‚Äôt it?  That just looks like this action is somewhat more complicated, but do not rush to conclusions ... <br><br>  All the highlight of working with events lies in the parameters that are passed to <i>create_sensor_manifold</i> .  Let us analyze the key points of the above code: <br><br><ul><li>  null  The first parameter is the object that ‚Äúsubscribes‚Äù to the event.  Null is specified here, i.e.  the object is the whole scene. </li><li>  ‚ÄúMAIN‚Äù.  A unique identifier that is assigned to the created set. </li><li>  m_ctl.CT_CONTINUOUS.  Type of event generation.  There are several options and in this case means that the event will be generated continuously.  For example, if you specify m_ctl.CT_SHOT, then it will occur once (simplified, further there will be explanations). </li><li>  [_elapsed_sensor].  Previously created sensor. </li><li>  main_cb.  Handler function called when an event occurs. </li></ul><br><br>  So what we have.  And we have three very powerful levers for working with events.  First, events can be tied to a specific object in the scene.  Secondly, each object can be subscribed to several different events.  That is why the link to the created sensor is transmitted as an array unit.  Third, you can control the type of event generation.  In fact, there are not two of them mentioned above, but much more.  In addition, there is a special mechanism to use complex logical constructions to respond to events. <br><br><h4>  Events in action </h4><br>  The best way to learn something new is practical work.  You can shake the air as much as you like by theory, but the result should be tangible.  I have always been touched by the immediacy of young talents who ask on the forums: ‚Äúwhich game engine to choose, which is the best programming language, how much can you earn ...‚Äù Advice - sit down and do it.  There is nothing more valuable than personally buried cones. <br><br>  Here and in this case, I preferred to test the theory in practice.  To fully explore the possibilities of the Blend4Web event model, it was decided to create a simple application and make the most of these opportunities.  But the work was so interesting that the result was a cute mini-game / Christmas card, which I even posted on the main page of my site with games.  At the end of the article you will find links to the application and all sources.  Use on health. <br><br>  The idea of ‚Äã‚Äãa New Year postcard is simple and inspired by childhood memories.  Remember the key phrase ‚ÄúOne, two, three - herringbone burn‚Äù?  Something like this, I decided to bring to life.  There are three buttons, each of which lights the bulbs on the tree of the corresponding color.  In this case, the sound of a certain pitch.  The task is to find the correct sequence of switching on the lamps.  After pressing the buttons, the program checks the result and displays a message: either a hint or a transition to the final.  Since this is still more of a New Year card than a game, after several unsuccessful attempts, the correct version is given. <br><br><img src="https://habrastorage.org/files/46b/72c/83f/46b72c83ff1c4a27bee173d8dcc9865e.jpg"><br><br>  The Blend4Web engine does not have a built-in GUI, so two options are offered: use objects in Blender or work through standard HTML features.  It's easier for me to work with Blender.  In the editor, planes with button textures were created and ‚Äúexit‚Äù animations added to them.  You can open the project file and see how it is done. <br><br>  The API engine has a special sensor <i>create_selection_sensor</i> , which is able to generate an event when an object is selected with the mouse.  For example, you can use this code to track clicks: <br><pre> <code class="javascript hljs">m_ctr = b4w.require(<span class="hljs-string"><span class="hljs-string">"controls"</span></span>); ... sel_sensor = m_ctr.create_selection_sensor(_btRed, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); m_ctr.create_sensor_manifold (_btRed, <span class="hljs-string"><span class="hljs-string">"btRed"</span></span>, m_ctr.CT_SHOT, [sel_sensor],<span class="hljs-literal"><span class="hljs-literal">null</span></span>, sel_sensor_cb, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sel_sensor_cb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Here, the sel_sensor sensor has been added to the <i>btRed</i> object (a button that turns on red light).  Event generation is limited to the <i>CT_SHOT</i> type <i>,</i> i.e.  happens once.  Now, with each mouse click on the button, the <i>sel_sensor_cb ()</i> handler function will be called, in which all the magic is concentrated: the animation of the button, the activation of the backlight around it, the activation of lamps in the scene. <br><br>  Someone, probably, has already noticed that the proposed code has one major drawback - this event is only a selection of the object, so the button always turns on.  Of course, there are no special problems.  It is enough to add a trigger variable to the program and switch ON / OFF modes depending on its value.  But the task is a bit different.  You need to press the button once and then lock it.  But after the user clicks all the buttons in the scene, you need to check the correct order and decide whether to give him another chance (turn off the lights and buttons) or turn on the final stage. <br><br>  This is where another powerful tool of the event model comes to the rescue - a logic function: <br><pre> <code class="javascript hljs">create_sensor_manifold(obj, id, type, sensors, LOGIC_FUN, callback)</code> </pre><br>  In the previous examples in its place was null.  Thus, the coming event always caused the callback handler.  In fact, this behavior is determined by the result of the operation of the logic function in conjunction with the selected type.  And since several sensors can be in the same manifold at once, then with this tool you can create very interesting behaviors. <br><br>  The API includes a lot of ready-made sensors, but there is one, the meaning of which is to store a certain variable: <i>create_custom_sensor (value)</i> .  The user with the help of special functions can change and control the value value at any time.  For example, it does not cost anything to create an event on its basis that will be generated when an explosion occurs.  In this case, the variable will store some important value, the same force of the explosion.  And already on the basis of the received data, the subscribing objects can react in one way or another.  In addition, the value value can be taken into account when building a logical function.  I used this property to block the execution of the <i>create_selection_sensor</i> sensor at the right time. <br><br>  The idea is that after the button is <i>selected</i> , the event <i>handler</i> is <i>invoked</i> only if the value of <i>custom_sensor</i> is zero.  One has only to change it to another digit and the handler is blocked. <br><br>  Creating a custom_sensor is no different from the previously discussed sensors.  In this case, you must immediately specify the initial value value: <br><pre> <code class="javascript hljs">m_ctr.create_custom_sensor(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Since it is also necessary to monitor the selection sensor, the initialization design becomes somewhat different - all sensors are combined into an array: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_ctr = b4w.require(<span class="hljs-string"><span class="hljs-string">"controls"</span></span>); ... var sel_sensor = m_ctr.create_selection_sensor(_btRed, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); _st_sens1= m_ctr.create_custom_sensor(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span> (); sens = [sel_sensor, _st_sens1];</code> </pre><br>  And the array is transferred to the manifold: <br><pre> <code class="javascript hljs">m_ctr.create_sensor_manifold (_btRed, <span class="hljs-string"><span class="hljs-string">"btRed"</span></span>, m_ctr.CT_SHOT, sens, logic_fun, sensor_cb, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br>  All the action is contained in the logic function logic_fun (it must be described before calling in the code): <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logic_fun = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>]&amp;&amp; s[<span class="hljs-number"><span class="hljs-number">1</span></span>]==<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre><br>  The call to the <i>sensor_cb</i> handler will occur if the logic_fun function returns both sensor results as true.  The logic function runs continuously and is bound to the frame update.  Therefore, the reading of sensor parameters occurs continuously.  If the user selects a button object on the screen, the sensor s [0] returns true.  However, as long as the equality s [1] == 0 is invalid, the handler will not be executed. <br><br>  Consider another example of using sensors in an application.  So, the user pressed all three buttons on the screen.  The program must decide whether this was done in the sequence and how to respond. <br><br>  I decided to assign a letter (string) to each button and store the sum of these letters in a special variable.  It is clear that the addition of letters leads to unique combinations, where only one is correct.  Thus, the program learns about the sequence of keystrokes.  But this logic itself is executed in a special handler, which is called when certain requirements are met. <br><br>  Previously, the code for blocking buttons on the screen using the <i>custom_sensor</i> sensor was <i>shown</i> .  To do this, it was enough to change the sensor value to something else in the handler using a special function: <br><pre> <code class="javascript hljs">m_ctr.set_custom_sensor(_st_sens1 , <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Thus, the sensors of all buttons received the value 1, which in fact blocked the selection of objects in the future.  But these same values ‚Äã‚Äãare taken into account further. <br><br>  In the Blender scene, several objects were created containing hints, in case the player incorrectly guesses the combination of sounds.  It is they who ‚Äúexpect‚Äù the setting of <i>custom_sensor</i> buttons to 1, after which their own handler is triggered, which displays hints on the screen. <br><br>  Here is the code that is responsible for checking: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _result_buttons = ‚Äú‚Äù; ... var logic_wrong= <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = m_ctr.get_custom_sensor(_st_sens1)+m_ctr.get_custom_sensor(_st_sens2)+m_ctr.get_custom_sensor(_st_sens3); s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum==<span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; _result_buttons !=<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>) s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } st_btWrong = m_ctr.create_custom_sensor(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); m_ctr.create_sensor_manifold (_btWrong, <span class="hljs-string"><span class="hljs-string">"btWrong"</span></span>, m_ctr.CT_SHOT, [st_btWrong], logic_wrong, wrong_cb, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrong_cb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre><br>  It uses only custom_sensor.  When initialized, its value is set to false, which allows you to turn on a kind of standby mode.  The <i>logic_wrong</i> function checks the pressing of all buttons on the screen (summed up the value of the object sensors), and also compares the sequence of pressing the buttons with the ‚ÄúABC‚Äù standard.  And only when all the requirements are met, the logic function returns true to the manifold, which in turn will launch the <i>wrong_cb</i> handler. <br><br>  If, when studying these examples, you got used to the idea that everything is clear with the event model b4w, then I hasten to ‚Äúrejoice‚Äù - there are several other nuances that need to be taken into account. <br><br>  In the examples of creating a manifold, you have already encountered the type parameter.  I usually used the CT_SHOT or CT_CONTINUOUS values.  There are five options for them in Blend4Web.  However, the main thing here is that they work in conjunction with a logic function.  So, just above, the function with the CT_SHOT type called the st_btWrong handler only if the logic function logic_wrong returned true. <br><br>  The list of possible values ‚Äã‚Äãof type and their response to the result returned by a logic function: <br><ul><li>  CT_SHOT and CT_CONTINUOUS are triggered by changing the value returned by the logic function from false to true. </li><li>  CT_LEVEL will constantly call the handler with pulse = 1 when the logic function returns true. </li><li>  CT_TRIGGER will call the handler if the function has changed its value from false to true (returns pulse = 1) or vice versa (then pulse = -1).  In other cases, the handler is not called. </li><li>  CT_CHANGE generates a pulse at any change in the value of the sensor, without taking into account the results of the logic function. </li></ul><br><br>  As you can see, the event model Blend4Web is very flexible and allows you to cost very complex logical structures.  In one article it is impossible to cover all aspects of working with it, but the basic features were disclosed.  To get acquainted with the full capabilities of the event model, I advise you to look into the official <a href="https://www.blend4web.com/api_doc/module-controls.html">API documentation</a> . <br><br>  <a href="http://www.prandgames.com/ru/new_year2016.html">Link to the application</a> <br>  <a href="">Source archive</a> </div><p>Source: <a href="https://habr.com/ru/post/271625/">https://habr.com/ru/post/271625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271597/index.html">Corporate phishing</a></li>
<li><a href="../271601/index.html">Intensive German: how ABBYY Compreno teaches new languages</a></li>
<li><a href="../271605/index.html">EOIP & DD-WRT for connecting two apartments into one network or all for Remote Play</a></li>
<li><a href="../271611/index.html">YouTube Phenomenon: Thinking Locally to Be Global</a></li>
<li><a href="../271621/index.html">About programmers</a></li>
<li><a href="../271629/index.html">Novena - a computer that guarantees full control over your security is already available to any user.</a></li>
<li><a href="../271631/index.html">We invite to Azov Developers Meetup - December 12 in Taganrog</a></li>
<li><a href="../271635/index.html">What happens in the IaaS market</a></li>
<li><a href="../271639/index.html">Mail protection</a></li>
<li><a href="../271641/index.html">Controlling Tektronix oscilloscopes from Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>