<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in ECMAScript 2017 (ES8)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alena Batitskaya, a senior graduate student and methodologist of the ‚Äú Programming ‚Äù faculty in ‚Äú Netology ‚Äù, made a review of innovations that appear...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in ECMAScript 2017 (ES8)</h1><div class="post__text post__text-html js-mediator-article">  Alena Batitskaya, a senior graduate student and methodologist of the ‚Äú <a href="http://netolo.gy/dD0">Programming</a> ‚Äù faculty in ‚Äú <a href="http://netolo.gy/dD1">Netology</a> ‚Äù, made a review of innovations that appeared in JavaScript with the release of ECMAScript 2017. We have all been waiting for this for a long time! <br><br><img src="https://habrastorage.org/web/d27/bc8/d70/d27bc8d702a948ad9eedb1c92b930f8b.jpeg"><br><br>  In the history of the development of JavaScript there were periods of stagnation and rapid growth.  Since the advent of the language (1995) and up to 2015, the updated specifications have not been issued regularly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It's good that for the third year already we know exactly when to wait for the update.  In June 2017, an updated specification was released: ES8 or, more correctly, ES2017.  Let's consider together what updates to the language occurred in this version of the standard. <br><a name="habracut"></a><br><h2>  Asynchronous functions </h2><br>  Perhaps one of the most anticipated innovations in JavaScript.  Now everything is official. <br><br><h3>  Syntax </h3><br>  To create an asynchronous function, the async keyword is used. <br><br><ul><li> Asynchronous function declaration: <code>async function asyncFunc() {}</code> </li><li>  An expression with an asynchronous function: <code>const asyncFunc = async function () {}</code> ; </li><li>  Method with an asynchronous function: <code>let obj = { async asyncFunc() {} }</code> </li><li>  Asynchronous switch function: <code>const asyncFunc = async () =&gt; {};</code> </li></ul><br><h3>  <code>async</code> operator </h3><br>  Let's see how it works.  Create a simple asynchronous function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainQuestion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre> <br>  The <code>mainQuestion</code> function returns a promise, despite the fact that we are returning a number: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = mainQuestion(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  If you have previously used generators from ES2015, then immediately recall that the generator function automatically creates and returns an iterator.  With asynchronous function is exactly the same. <br><br>  And where is the number 42 that we returned?  They are absolutely clear way resolved promis, which we returned: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); mainQuestion() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  Promis is resolved asynchronously, so we get the following output to the console: <br><br><pre> <code class="javascript hljs">  : <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br>  And what happens if our asynchronous function doesn't return anything at all? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dumbFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); dumbFunction() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  Promis will be resolved with ‚Äúnothing‚Äù, which in JavaScript corresponds to the <code>undefined</code> type: <br><br><pre> <code class="javascript hljs">  : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span></code> </pre> <br>  Despite the name, the asynchronous function itself is called and executed synchronously: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); asyncLog(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  The output to the console will be like this, although many might have expected otherwise: <br><br><pre> <code class="javascript hljs">   </code> </pre> <br>  The asynchronous function returns a promise.  <i>I hope you have already figured out what promises are.</i>  Otherwise, I recommend to pre-deal with them. <br><br>  And what will happen if we in the body of the function also return the promise? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, time = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done(message), time * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); timeout(<span class="hljs-string"><span class="hljs-string">' 5 '</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  It will join the chain to the promise, which is created automatically, as if we returned the promise inside the callback passed to the <code>then</code> method: <br><br><pre> <code class="javascript hljs">   <span class="hljs-number"><span class="hljs-number">5</span></span>  (_ <span class="hljs-number"><span class="hljs-number">5</span></span> _)</code> </pre> <br>  But if we had written not the asynchronous function, but the usual one, then everything would work exactly the same as in the example above: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, time = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done(message), time * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }</code> </pre> <br>  Then why do we need asynchronous functions?  The coolest feature of an asynchronous function is the ability in the body of such a function to wait for the result (when promise is resolved) of another asynchronous function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * (max - min + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + min; } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message = [ <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' ?'</span></span>, <span class="hljs-string"><span class="hljs-string">'  '</span></span> ][rand(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timeout(message, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> randomMessage(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); chat(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre> <br>  Notice that the body of the <code>chat</code> function looks like the body of a synchronous function, there is not even a single callback function.  But <code>await randomMessage()</code> will not return us a promise, but wait 5 seconds and return the message itself, which promises are allowed.  This is his role: ‚Äúwait for the result of the right operand‚Äù. <br><br><pre> <code class="javascript hljs">   ?</code> </pre> <br>  The message <code></code> after calling the <code>chat</code> function is displayed immediately, without waiting for the message to be displayed in the body of the <code>chat</code> function.  Therefore, it is logical to rewrite this part as: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); chat() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'   '</span></span>);</code> </pre> <br>  <code>await</code> operator <br>  <code>await</code> is a handy thing that allows you to beautifully use promises without callbacks.  But it works only in the body of an asynchronous function.  This code will generate a syntax error: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> chat(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">// SyntaxError: Unexpected token, expected ;</span></span></code> </pre> <br>  The fact that asynchronous functions can be ‚Äústopped‚Äù is another similarity with generators.  Using the <code>await</code> keyword in the body of an asynchronous function, we can wait ( <i>await</i> translates to <i>expect</i> ) the result of executing another asynchronous function, just as with the help of <code>yield</code> we ‚Äúwait‚Äù for the next call to the <code>next</code> iterator method. <br><br>  But what if we ‚Äúwait‚Äù for a synchronous function that returns a promise?  Yes, you can: <br><br><pre> <code class="javascript hljs">&lt;source lang=<span class="hljs-string"><span class="hljs-string">"javascript"</span></span>&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainQuestion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> done(<span class="hljs-number"><span class="hljs-number">42</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dumbAwait</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> number = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mainQuestion(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(number); } dumbAwait(); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre> <br>  But what if we ‚Äúexpect‚Äù a synchronous function that returns a number (string or something else)?  Yes, you can also: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainQuestion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dumbAwait</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> number = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mainQuestion(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(number); } dumbAwait(); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre> <br>  We can even "wait" for the number, although there is no special point in this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dumbAwait</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> number = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(number); } dumbAwait(); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre> <br>  The <code>await</code> operator has no difference what to expect.  It works in the same way as the <code>then</code> callback method works: <br><br><ol><li>  if promise returned: wait promise, and return the result; </li><li>  if no promise is returned: we wrap in <code>Promise.resolve</code> and onwards in a similar way. </li></ol><br>  <code>await</code> sends the asynchronous function to asynchronous swimming: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">longTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span> (<span class="hljs-number"><span class="hljs-number">10E6</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>); longTask() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">''</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'   '</span></span>);</code> </pre> <br>  Please take this example as a demonstration of the work of <code>await</code> , and not as a ‚Äúconvenient‚Äù trick.  The result of the work below: <br><br><pre> <code class="javascript hljs">       </code> </pre> <br><h3>  Error processing </h3><br>  What if the promise we are ‚Äúwaiting for‚Äù with <code>await</code> not resolved?  Then <code>await</code> will throw an exception: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">failPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">''</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catchMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> failPromise(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">`</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); } } catchMe(); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  We can catch this exception like any other, with <code>try-catch</code> and do something about it. <br><br><h3>  Application </h3><br>  The internal structure of asynchronous functions is similar to a mixture of promises and generators.  In fact, an asynchronous function is syntactic sugar for a combination of these two cool features of a language.  It is a logical replacement for related callbacks. <br><br>  In the body of the asynchronous function, we can write sequential asynchronous calls as a flat synchronous code, and this is what we were waiting for: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(url); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserPublicMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">login</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> profile = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchAsync(<span class="hljs-string"><span class="hljs-string">`/user/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${login}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messages = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchAsync(<span class="hljs-string"><span class="hljs-string">`/user/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${profile.id}</span></span></span><span class="hljs-string">/last`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> messages.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> message.isPublic); } getUserPublicMessages(<span class="hljs-string"><span class="hljs-string">'spiderman'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messages</span></span></span><span class="hljs-function"> =&gt;</span></span> show(messages));</code> </pre> <br>  Try rewriting this code in promises, and evaluate the difference in readability. <br><br>  Nicholas Bevacua in his article " <a href="https://ponyfoo.com/articles/understanding-javascript-async-await">Understanding JavaScript's async await</a> " in great detail examines the principles and peculiarities of asynchronous functions.  The article is richly seasoned with code examples and user cases. <br><br><h3>  Support </h3><br>  Today, asynchronous functions <a href="http://caniuse.com/">support all major browsers</a> .  So you can safely begin to use this feature of the language, if you have not already done so. <br><br><img src="https://habrastorage.org/web/ea5/71c/138/ea571c1389414e93b170740f04b2be7d.png"><br><br><h2>  <code>Object.values</code> and <code>Object.entries</code> </h2><br>  These new features are primarily intended to facilitate the work with objects. <br><br><h3> <code>Object.entries()</code> </h3> <br>  This function returns an array of the object's own enumerated properties in the format [key, value]. <br><br>  If the structure of the object contains keys and values, then the output will be recoded into an array containing arrays with two elements: the first element is the key, and the second element is the value.  The pairs [key, value] will be arranged in the same order as the properties in the object. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({ : <span class="hljs-number"><span class="hljs-number">1</span></span>, : <span class="hljs-number"><span class="hljs-number">2</span></span> });</code> </pre> <br>  The result of the code will be: <br><br><pre> <code class="javascript hljs">[ [ <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ], [ <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ] ]</code> </pre> <br>  If the data structure passed to <code>Object.entries()</code> does not contain keys, then in their place will be the index of the array element. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries([<span class="hljs-string"><span class="hljs-string">'n'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'t'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>]);</code> </pre> <br>  At the output we get: <br><br><pre> <code class="javascript hljs">[ [ <span class="hljs-string"><span class="hljs-string">'0'</span></span>, <span class="hljs-string"><span class="hljs-string">'n'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'t'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'3'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'4'</span></span>, <span class="hljs-string"><span class="hljs-string">'l'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'5'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'6'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span> ], [ <span class="hljs-string"><span class="hljs-string">'7'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span> ] ]</code> </pre> <br><h3>  Characters are ignored. </h3><br>  Note that the property whose key is the character will be ignored: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({ [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()]: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> });</code> </pre> <br>  Result: <br><br><pre> <code class="javascript hljs">[ [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> ] ]</code> </pre> <br><h3>  Iteration over properties </h3><br>  The appearance of the <code>Object.entries()</code> function finally gives us a way to iterate over the properties of an object using the <code>for-of</code> loop: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { : <span class="hljs-number"><span class="hljs-number">1</span></span>, : <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [x,y] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">JSON</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.stringify(x)}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">JSON</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.stringify(y)}</span></span></span><span class="hljs-string">`</span></span>); }</code> </pre> <br>  Conclusion: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><h3> <code>Object.values()</code> </h3> <br>  This function is close to <code>Object.entries()</code> .  At the output we get an array consisting only of the values ‚Äã‚Äãof our own properties, without keys.  What, in principle, can be understood from the title. <br><br><h3>  Support </h3><br><br><img src="https://habrastorage.org/web/9b5/7af/fd2/9b57affd2ab54e888ec88d97aa77f81f.png"><br><br>  Today, <code>Object.entries()</code> and <code>Object.values()</code> supported by major browsers. <br><br><h2>  "Hanging" commas in function parameters </h2><br>  Now it‚Äôs legal to leave commas at the end of the function argument list.  When calling the function, the comma at the end is also outside of crime. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> param1, param2, </span></span></span><span class="hljs-function">) </span></span>{} randomFunc( <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, );</code> </pre> <br>  Hanging commas are also allowed in arrays and objects.  They are simply ignored and have no effect on the work. <br><br>  Such a small, but certainly useful innovation! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { : <span class="hljs-string"><span class="hljs-string">''</span></span>, : <span class="hljs-string"><span class="hljs-string">''</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [ <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, ];</code> </pre> <br><h3>  Support </h3><br><br><img src="https://habrastorage.org/web/5c9/b43/eb6/5c9b43eb6eff4fe598bb60749aff415b.png"><br><br>  We'll have to wait a bit before leaving a comma at the end of the list of parameters. <br><br><h2>  "Stubs" for strings: we reach the desired length </h2><br>  In ES8, there are two new methods for working with strings: <code>padStart()</code> and <code>padEnd()</code> .  The <code>padStart()</code> method substitutes additional characters before the beginning of the line, on the left.  And <code>padEnd()</code> , in turn, on the right, after the end of the line. <br><br><pre> <code class="javascript hljs">str.padStart(, []); str.padEnd(, []);</code> </pre> <br>  Keep in mind that the length you specify as the first parameter will include the original string. <br><br>  The second parameter is optional.  If it is not specified, the string will be added with spaces (the default value). <br><br>  If the source string is longer than the specified parameter, the string will remain unchanged. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">''</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'~'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// '~~~~~' '  '.padStart(15, '--&gt;'); // '--&gt;  ' ''.padEnd(10); // ' ' ''.padEnd(10, '0123456789'); // '012345678'</span></span></code> </pre> <br><h3>  Support </h3><br><br><img src="https://habrastorage.org/web/7a1/ebd/5e1/7a1ebd5e1bbb4e4c909ec0db3c8881f3.png"><br><br>  Beautiful picture! <br><br><h2>  <code>Object.getOwnPropertyDescriptors()</code> function </h2><br>  The function returns an array with descriptors of all the object's own properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">last</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, get fullName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` ,   </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${first}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${last}</span></span></span><span class="hljs-string">`</span></span>; }, }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person));</code> </pre> <br>  Result: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">first</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">last</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">fullName</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>: get fullName], <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h3>  Application area </h3><br><ol><li>  For copying object properties, including getters, setters, write-once properties. </li><li>  Copy object.  <code>.getOwnPropertyDescriptor</code> can be used as the second parameter in <code>Object.create()</code> . </li><li>  Creating cross-platform object literals with a specific prototype. </li></ol><br>  Note that methods with <code>super</code> cannot be copied because they are closely related to the original object. <br><br><h3>  Support </h3><br><br><img src="https://habrastorage.org/web/611/3b2/3df/6113b23df252411f9a531811936d17ff.png"><br><br>  Even IE is fine. <br><br><h2>  Memory Sharing and <code>Atomics</code> Object </h2><br>  This innovation introduces the concept of shared memory in JavaScript.  The new <code>SharedArrayBuffer</code> design and the already existing <code>TypedArray</code> and <code>DataView</code> help allocate available memory.  This provides the necessary order of operations when multiple threads simultaneously use shared memory. <br><br>  The <code>SharedArrayBuffer</code> object is a primitive building block for high-level abstractions.  The buffer can be used to redistribute bytes between multiple worker threads.  It has two distinct advantages: <br><br><ol><li>  The speed of data exchange between workers is increased. </li><li>  Coordination between workers is faster and easier (compared to <code>postMessage()</code> ). </li></ol><br><h3>  Secure access to shared data </h3><br>  The new <code>Atomics</code> object cannot be used as a constructor, but it has a number of its own methods, which are designed to solve the security problem when performing various operations on <code>SharedArrayBuffer</code> typed arrays. <br><br><h3>  Support </h3><br><br><img src="https://habrastorage.org/web/453/1d0/1c1/4531d01c12bd4e0aadd0cb83f05defe4.png"><br><br>  This "update" is still bad with support.  Hope, believe, wait. <br>  Alex Raushmayer described in detail the mechanism of this language feature in the article ‚Äú <a href="http://2ality.com/2017/01/shared-array-buffer.html">ES proposal: Shared memory and atomics</a> ‚Äù. <br><br>  According to a <a href="https://insights.stackoverflow.com/survey/2017">survey</a> conducted by StackOverflow in 2017, JavaScript is the most widely used programming language.  Personally, I am very pleased with the current picture: <br><br><ul><li>  new specification every year; </li><li>  browsers quickly innovate; </li><li>  The working group consists of representatives of corporations, which allows you to quickly exchange implementation experience and promptly correct either the descriptive or technical parts. </li></ul><br>  The language lives, develops, in the eyes turns into an even more convenient, flexible and powerful tool. <br><br>  Frankly speaking, it is not always possible to keep up with this rapid growth and study, and most importantly use all the newest and most relevant in their work.  That is why it is so important to get the most up-to-date information during the initial development and to enter the labor market with a savvy and up-to-date specialist. <br><br>  My colleagues in <a href="http://netolo.gy/dD1">Netology</a> and I understand that the advantage of online education is its flexibility and ability to adapt to the ever-changing realities of the development world.  For this reason, we do not stop working on updating the materials of our courses and promptly talk about all the new features.  And now we are finalizing the ‚Äú <a href="http://netolo.gy/dD7">JavaScript: from zero to promise</a> ‚Äù <a href="http://netolo.gy/dD7">course</a> so that every student knows and knows how to work with the tools that appeared in ECMAScript 2017. <br><br>  In preparing the article used materials: <br><br><ul><li>  <a href="https://hackernoon.com/es8-was-released-and-here-are-its-main-new-features-ee9c394adf66">ES8 was Released</a> , <a href="https://hackernoon.com/%40dormoshe%3Fsource%3Dpost_header_lockup">Dor Moshe</a> </li><li>  <a href="http://exploringjs.com/es2016-es2017/index.html">Exploring ES 2016 &amp; ES 2017</a> , <a href="http://rauschma.de/">Dr.</a>  <a href="http://rauschma.de/">Axel rauschmayer</a> </li><li>  <a href="https://pawelgrzybek.com/whats-new-in-ecmascript-2017/">What's new in ECMAScript 2017</a> , <a href="https://pawelgrzybek.com/">Pawel Grzybek</a> </li><li>  <a href="https://ponyfoo.com/articles/understanding-javascript-async-await">Understanding JavaScript's async await</a> , <a href="https://ponyfoo.com/contributors/ponyfoo">Nicol√°s Bevacqua</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/333604/">https://habr.com/ru/post/333604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333594/index.html">The system of rewinding time in the style of Prince of Persia</a></li>
<li><a href="../333596/index.html">I am the cause of the emergence of the Hungarian notation in Android</a></li>
<li><a href="../333598/index.html">Cold calls for web studio. Lead for 159 rubles a reality or fantasy?</a></li>
<li><a href="../333600/index.html">Competitive Intelligence at PHDays: Spying on the Internet of Things</a></li>
<li><a href="../333602/index.html">Time of miracles, or Brakes for the end of the world</a></li>
<li><a href="../333606/index.html">7 best device farm for mobile app testing</a></li>
<li><a href="../333608/index.html">MBLTdev 2017 is coming. Registration is open</a></li>
<li><a href="../333610/index.html">TamTam: how we made a new messenger</a></li>
<li><a href="../333612/index.html">Deep Learning, now in OpenCV</a></li>
<li><a href="../333614/index.html">Why Python Networker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>