<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple sprintf-based ASN1 codec</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The ASN.1 transport syntax defines an unambiguous method for converting the values ‚Äã‚Äãof acceptable types of variables into a sequence of bytes for tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple sprintf-based ASN1 codec</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/hp/r5/am/hpr5amyaiz885olowpmujn0aad8.png" alt="image" align="left">  The ASN.1 transport syntax defines an unambiguous method for converting the values ‚Äã‚Äãof acceptable types of variables into a sequence of bytes for transmission over a network.  In ASN.1, it is called Basic Encoding Rules (BER).  The rules are recursive, so that the coding of composite objects is the creation of a chain of coded sequences of constituent objects.  The ASN.1 protocol describes the data structure in <a href="https://habr.com/ru/post/64111/">simple and understandable language</a> . <br><a name="habracut"></a><br>  Each transmitted value - both basic and derived type - consists of three fields: <br><br><ul><li>  identifier; </li><li>  the length of the data field (in bytes); </li><li>  data field. </li></ul><br>  If you always specify the length of the data field (I consider this a good tone rule), then the end field flag is not used. <br><br>  There are many different compilers for ASN.1, both paid and free, for different programming languages, but we would like to have something very simple at hand. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The overwhelming majority of software developers find the <a href="https://habr.com/ru/post/150757/">ASN.1</a> standard <a href="https://habr.com/ru/post/150757/">difficult</a> .  I thought so too until recently.  Working in the field of PKI / PKI / cryptography, almost every day you deal with ASN1 structures in the form of X509 certificates, certificate requests, certificate revocation lists.  And the list goes on.  And so, while working on the utility for creating a certificate request in PKCS # 10 format with generating a key pair on a token / smartcard PKCS # 11, I naturally had to form, in particular, an asn1 public key structure to write it to the certificate request : <br><br><pre><code class="erlang hljs">C-Sequence C-Sequence (&lt;&gt;) Object Identifier (&lt;&gt;) &lt;oid public key&gt; C-Sequence (&lt;&gt;) Object Identifier (&lt;&gt;) &lt;oid  &gt; Object Identifier (&lt;&gt;) &lt;oid &gt; Bit String (&lt;&gt;) &lt;  &gt;</code> </pre> <br>  Since we used the PKCS # 11 token with the support of Russian cryptography as the ICPP, the source material for this structure was obtained from the token in accordance with the following template: <br><br><pre> <code class="cpp hljs"> CK_BYTE gostr3410par[<span class="hljs-number"><span class="hljs-number">12</span></span>]; CK_BYTE gostr3411par[<span class="hljs-number"><span class="hljs-number">12</span></span>]; CK_ULONG gostr3410par_len; CK_ULONG gostr3411par_len; CK_BYTE pubkey[<span class="hljs-number"><span class="hljs-number">128</span></span>]; CK_ULONG pubkeu_len; CK_KEY_TYPE key_type; CK_ATTRIBUTE templ_pk[] = { . . . {CKA_GOSTR3410PARAMS, gostr3410par, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gostr3410par)}, {CKA_GOSTR3411PARAMS, gostr3411par, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gostr3410par)}, {CKA_VALUE, pubkey, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pubkey)}, {CKA_KEY_TYPE, &amp;key_type, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(key_type)} }</code> </pre> <br>  Directly from this structure, the values ‚Äã‚Äãof the CKA_VALUE attribute, which contains the value of the public key, and the values ‚Äã‚Äãof the attributes CKA_GOSTR3410PARAMS and CKA_GOSTR3411PARAMS, which contain the oid s of the signature parameter and the hash parameter, will be used to fill in asn1-publickeyinfo. <br><br>  The CKA_KEY_TYPE attribute, which can take on the values ‚Äã‚ÄãCKK_GOSTR3410 and CKK_GOSTR3410_512 (under the conditions when the signature algorithm of GOST R 34.10-2001 continues to operate) ambiguously determines the algorithm of the key pair.  If the value of the CKA_KEY_TYPE attribute is CKK_GOSTR3410_512, then, of course, it unambiguously points to the algorithm GOST R 34.10-2012 with a key length of 512 bits (oid = 1.2.643.7.1.1.1.2).  But if it is just CKK_GOSTR3410, then ambiguity arises, what type of key does this key belong to: GOST R 34.10-2001 or still it is GOST R 34.10-2012 with a key length of 256 bits.  This ambiguity helps to resolve the attribute CKA_GOSTR3411PARAMS. <br><br>  Immediately, we note that the CKA_GOSTR3410PARAMS and CKA_GOSTR3411PARAMS parameters on the token, in accordance with the recommendations of TC-26, are stored as an object identifier encoded with oid, for example: <br><br>  \ x06 \ x06 \ x2a \ x85 \ x03 \ x02 \ x02 \ x13, where the zero byte determines the type of sequence (0x06 is the object identifier, see the table below), the second byte indicates the length (in general, the length may take several bytes but about it below) data fields in which oid is stored in a binary type. <br><br>  If this parameter contains the oid of the GOST R 34.10-2012 hash algorithm with a length of 256 bits (oid = 1.2.643.7.1.1.2.2, in binary form "\ x2a \ x 85 \ x 03 \ x 07 \ x 01 \ x 01 \ x 02 \ x02 "), the key type must be set as GOST R 34.10-2012 with a key length of 256 bits.  Otherwise, this is the key GOST R 34.10-2001.  The algorithm for determining the type of key may look like this: <br><br><pre> <code class="cpp hljs">. . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (curr_attr_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; curr_attr_idx &lt; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(templ_pk)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(templ_pk[<span class="hljs-number"><span class="hljs-number">0</span></span>])); curr_attr_idx++){ curr_attr = &amp;templ_pk[curr_attr_idx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!curr_attr-&gt;pValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } swith (curr_attr-&gt;type) { . . . <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_VALUE: <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> pubkey_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_GOSTR3410PARAMS: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> gostr3410par_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_GOSTR3410PARAMS: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> gostr3411par_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_KEY_TYPE: ulattr = curr_attr-&gt;pValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ulattr == CKK_GOSTR3410) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!memmem(gostr3411par), gostr3411par_len,<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2001*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, <span class="hljs-string"><span class="hljs-string">"1.2.643.2.2.19"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1(<span class="hljs-string"><span class="hljs-string">"\x06\x06\x2a\x85\x03\x02\x02\x13"</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2012-256*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, (<span class="hljs-string"><span class="hljs-string">"1 2 643 7 1 1 1 1"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1 (<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07\x01\x01\x01\x01"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ulattr == CKK_GOSTR3410_512) { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2012-512*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, (<span class="hljs-string"><span class="hljs-string">"1 2 643 7 1 1 1 2"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1 (<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07\x01\x01\x01\x02"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"tclpkcs11_perform_pki_keypair CKK_GOSTR ERROR\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; . . . } } . . .</code> </pre> <br>  Now we have all the initial data for creating the asn1- public key structure. <br><br>  Recall that each element of the asn1-structure consists of three fields: <br><br><ul><li>  identifier; </li><li>  the length of the data field (in bytes); </li><li>  data field. </li></ul><br>  Here is the coding <a href="https://habr.com/ru/post/194664/">table</a> for some types of identifiers used in the PKI / PKI: <br><br><table width="200"><tbody><tr><th>  <b>Type Name</b> </th><th>  <b>Short description</b> </th><th>  <b>Type View in DER Encoding</b> </th></tr><tr><td>  SEQUENCE </td><td>  Used to describe a data structure consisting of various types. </td><td>  thirty </td></tr><tr><td>  INTEGER </td><td>  Integer. </td><td>  02 </td></tr><tr><td>  OBJECT IDENTIFIER </td><td>  A sequence of integers. </td><td>  06 </td></tr><tr><td>  UTCTime </td><td>  Temporary type, contains 2 digits to determine the year </td><td>  17 </td></tr><tr><td>  Generalizedtime </td><td>  Extended time type, contains 4 digits for the year. </td><td>  18 </td></tr><tr><td>  SET </td><td>  Describes the structure of data of different types. </td><td>  31 </td></tr><tr><td>  UTF8String </td><td>  Describes string data. </td><td>  0C </td></tr><tr><td>  Null </td><td>  Actually NULL </td><td>  05 </td></tr><tr><td>  BIT STRING </td><td>  A type for storing a bit sequence. </td><td>  03 </td></tr><tr><td>  OCTET STRING </td><td>  Type to store a sequence of bytes </td><td>  04 </td></tr></tbody></table><br>  When working with asn1-structures, the greatest shock for the uninitiated is the method of encoding the length of the data field, especially during its formation, but if you also take into account the computer architecture (littleendien, bigendien).  This is a whole <a href="">science</a> .  And in the process of reasoning about the algorithm for the formation of this field, it came to mind to use the sprintf function, which will take into account the architecture itself, and how the number of bytes for storing the length is determined by the function code, which prepares a buffer with a data type identifier and data length: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap_id_with_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//  unsigned long length, //  unsigned long *lenasn) //  asn1- { // unsigned long length; int buflen = 0; unsigned char *buf; char *format; char *buf_for_len[100]; const char *s; /*       */ char f0[] = "%02x%02x"; char f1[] = "%02x81%02x"; char f2[] = "%02x82%04x"; char f3[] = "%02x83%06x"; char f4[] = "%02x84%08x"; /*        */ buflen = ( length &lt; 0x80 ? 1: length &lt;= 0xff ? 2: length &lt;= 0xffff ? 3: length &lt;= 0xffffff ? 4: 5); /*   asn-*/ buf = malloc(length + buflen); // buf = malloc(buflen); /*        sprintf*/ switch (buflen - 1) { case 0: format = f0; break; case 1: format = f1; break; case 2: format = f2; break; case 3: format = f3; break; case 4: format = f4; break; } // sprintf    little  bigendian       sprintf((char*)buf_for_len, (const char *)format, type, length); length = 0; /* asn1-*/ fprintf(stderr, "ASN1 - :%s\n", buf_for_len); /*     */ for (s=(const char *)buf_for_len; *s; s +=2 ) { if (!hexdigitp (s) || (!hexdigitp (s+1) &amp;&amp; hexdigitp (s+1) != 0) ){ fprintf (stderr, "invalid hex digits in \"%s\"\n", buf_for_len); *lenasn = 0; return NULL; } ((unsigned char*)buf)[length++] = xtoi_2 (s); } *lenasn = length; return (buf); }</span></span></span></span></span></span></code> </pre> <br>  The function returns a pointer to a buffer with an asn1 structure, allocated with regard to the data length.  It remains to copy this data to the received buffer with an offset by the length of the header.  The length of the header is returned via the lenasn parameter. <br><br>  In order to check how this function works, we will write a simple utility: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define digitp(p) (*(p) &gt;= '0' &amp;&amp; *(p) &lt;= '9') #define hexdigitp(a) (digitp (a) \ || (*(a) &gt;= 'A' &amp;&amp; *(a) &lt;= 'F') \ || (*(a) &gt;= 'a' &amp;&amp; *(a) &lt;= 'f')) #define xtoi_1(p) (*(p) &lt;= '9'? (*(p)- '0'): \ *(p) &lt;= 'F'? (*(p)-'A'+10):(*(p)-'a'+10)) #define xtoi_2(p) ((xtoi_1(p) * 16) + xtoi_1((p)+1)) int main (int argc, char *argv[]) { unsigned char *hdrasn; unsigned char type; unsigned long length; unsigned long lenasn; if (argc != 3) { fprintf (stderr, "Usage: wrap_id_with_length &lt;id&gt; &lt;length&gt;\n"); exit(-1); } type = atoi(argv[1]); length = atol(argv[2]); fprintf (stderr, "&lt;id=%02x&gt; &lt;length=%lu&gt;\n", type, length); if (length == 0) { fprintf (stderr, "Bad length=%s\nUsage: wrap_id_with_length &lt;id&gt; &lt;length&gt;\n", argv[2]); exit(-1); } hdrasn = wrap_id_with_length(type, length, &amp;lenasn); fprintf (stderr, "Length asn1-buffer=%lu, LEN_HEADER=%lu, LEN_DATA=%lu\n", lenasn, lenasn - length, length); }</span></span></span></span></code> </pre> <br>  Save it together with the wrap_id_with_length function in the wrap_id_with_length.c file. <br><br>  Let's broadcast: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$cc</span></span> ‚Äìo wrap_id_with_length wrap_id_with_length.c $</code> </pre> <br>  The resulting program will run with various source data.  The data type is a decimal number. <br><br>  The resulting program will run with various source data.  The data type is a decimal number: <br><br><pre> <code class="bash hljs">bash-4.3$ ./wrap_id_with_length 06 8 &lt;id=06&gt; &lt;length=8&gt; ASN1 - :0608 Length asn1-buffer=10, LEN_HEADER=2, LEN_DATA=8 bash-4.3$ ./wrap_id_with_length 06 127 &lt;id=06&gt; &lt;length=127&gt; ASN1 - :067f Length asn1-buffer=129, LEN_HEADER=2, LEN_DATA=127 bash-4.3$ ./wrap_id_with_length 48 128 &lt;id=30&gt; &lt;length=128&gt; ASN1 - :308180 Length asn1-buffer=131, LEN_HEADER=3, LEN_DATA=128 bash-4.3$ ./wrap_id_with_length 48 4097 &lt;id=30&gt; &lt;length=4097&gt; ASN1 - :30821001 Length asn1-buffer=4101, LEN_HEADER=4, LEN_DATA=4097 bash-4.3$</code> </pre><br>  You can check the correctness of the formation of the header using any calculator: <br><br><img src="https://habrastorage.org/webt/kj/rp/4s/kjrp4sc9ddsk6fhjhkohe8tkotu.png"><br><br>  We are all ready to form any ASN1 structure.  But before we make small changes to the wrap_id_with_length function and call it <br><br><div class="spoiler">  <b class="spoiler_title">wrap_for_asn1:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap_for_asn1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *prefix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *wrap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrap_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenasn)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buflen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *format; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf_for_len[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f0[] = <span class="hljs-string"><span class="hljs-string">"%02x%02x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f1[] = <span class="hljs-string"><span class="hljs-string">"%02x81%02x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f2[] = <span class="hljs-string"><span class="hljs-string">"%02x82%04x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f3[] = <span class="hljs-string"><span class="hljs-string">"%02x83%06x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f4[] = <span class="hljs-string"><span class="hljs-string">"%02x84%08x"</span></span>; length = prefix_len + wrap_len; buflen += ( length &lt;= <span class="hljs-number"><span class="hljs-number">0x80</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xff</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xffff</span></span> ? <span class="hljs-number"><span class="hljs-number">3</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xffffff</span></span> ? <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>); buf = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length + buflen); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (buflen - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: format = f0; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: format = f1; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: format = f2; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: format = f3; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: format = f4; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// sprintf    little  bigendian    sprintf((char*)buf_for_len, (const char *)format, type, length); length = 0; for (s=buf_for_len; *s; s +=2 ) { if (!hexdigitp (s) || (!hexdigitp (s+1) &amp;&amp; hexdigitp (s+1) != 0) ){ fprintf (stderr, "invalid hex digits in \"%s\"\n", buf_for_len); } ((unsigned char*)buf)[length++] = xtoi_2 (s); } if (prefix_len &gt; 0) { memcpy(buf + length, prefix, prefix_len); } memcpy(buf + length + prefix_len, wrap, wrap_len); *lenasn = (unsigned long)(length + prefix_len + wrap_len); return (buf); }</span></span></code> </pre> <br></div></div><br>  As you can see, the changes are minimal.  As input parameters, the data itself is added, which inside the function is packaged in an asn1 structure.  Moreover, two buffers can be fed to the input at once.  It seems to us convenient. <br><br>  Before presenting a control example, let us give the codes of three more functions.  The first function <a href="https://habr.com/ru/post/398783/">oid2buffer</a> converts oid-s from dotted-decimal form to DER-encoding.  We will need this function to convert, in particular, the key pair oid-s (see above). <br><br><div class="spoiler">  <b class="spoiler_title">The function text is here:</b> <div class="spoiler_text">  static char * oid2buffer (char * oid_str, unsigned long * len) { <br>  char * curstr; <br>  char * curstr1; <br>  char * nextstr; <br>  unsigned int firstval; <br>  unsigned int secondval; <br>  unsigned int val; <br>  unsigned char buf [5]; <br>  int count; <br>  unsigned char oid_hex [100]; <br>  char * res; <br>  int i; <br>  if (oid_str == NULL) { <br>  * len = 0; <br>  return NULL; <br>  } <br>  * len = 0; <br>  curstr = strdup ((const char *) oid_str); <br>  curstr1 = curstr; <br>  nextstr = strchr (curstr, '.'); <br>  if (nextstr == NULL) { <br>  * len = 0; <br>  return NULL; <br>  } <br>  * nextstr = '\ 0'; <br>  firstval = atoi (curstr); <br>  curstr = nextstr + 1; <br>  nextstr = strchr (curstr, '.'); <br>  if (nextstr) { <br>  * nextstr = '\ 0'; <br>  } <br>  secondval = atoi (curstr); <br>  if (firstval&gt; 2) { <br>  * len = 0; <br>  return NULL; <br>  } <br>  if (secondval&gt; 39) { <br>  * len = 0; <br>  return NULL; <br>  } <br>  oid_hex [0] = (unsigned char) ((firstval * 40) + secondval); <br>  i = 1; <br>  while (nextstr) { <br>  curstr = nextstr + 1; <br><br>  nextstr = strchr (curstr, '.'); <br><br>  if (nextstr) { <br>  * nextstr = '\ 0'; <br>  } <br><br>  memset (buf, 0, sizeof (buf)); <br>  val = atoi (curstr); <br>  count = 0; <br>  if (curstr [0]! = '0') <br>  while (val) { <br>  buf [count] = (val &amp; 0x7f); <br>  val = val &gt;&gt; 7; <br>  count ++; <br>  } <br>  else { <br>  buf [count] = (val &amp; 0x7f); <br>  val = val &gt;&gt; 7; <br>  count ++; <br>  } <br>  while (count--) { <br>  if (count) { <br>  oid_hex [i] = buf [count] |  0x80; <br>  } else { <br>  oid_hex [i] = buf [count]; <br>  } <br>  i ++; <br>  } <br>  } <br>  res = (char *) malloc (i); <br>  if (res) { <br>  memcpy (res, oid_hex, i); <br>  * len = i; <br>  } <br>  free (curstr1); <br>  return res; <br>  } <br></div></div><br>  The remaining two functions allow the binary buffer to be converted to a hex count (buffer2hex) and vice versa (hex2buffer). <br><br><div class="spoiler">  <b class="spoiler_title">These functions are here:</b> <div class="spoiler_text">  static char * <br>  buffer2hex (const unsigned char * src, size_t len) <br>  { <br>  int i; <br>  char * dest; <br>  char * res; <br>  dest = (char *) malloc (len * 2 + 1); <br>  res = dest; <br>  if (dest) <br>  { <br>  for (i = 0; i &lt;len; i ++, dest + = 2) <br>  sprintf (dest, "% 02X", src [i]); <br>  } <br>  return res; <br>  } <br><br>  static void * <br>  hex2buffer (const char * string, size_t * r_length) <br>  { <br>  const char * s; <br>  unsigned char * buffer; <br>  size_t length; <br><br>  buffer = malloc (strlen (string) / 2 + 1); <br>  length = 0; <br>  for (s = string; * s; s + = 2) <br>  { <br>  if (! hexdigitp (s) ||! hexdigitp (s + 1)) { <br>  fprintf (stderr, "invalid hex digits in \"% s \ "\ n", string); <br>  } <br>  ((unsigned char *) buffer) [length ++] = xtoi_2 (s); <br>  } <br>  * r_length = length; <br>  return buffer; <br>  } <br></div></div><br>  These functions are very handy when debugging, and surely many will have them. <br><br>  And now we come back to the solution of the task, obtaining the asn1-structure of the public key.  We will write a utility that will form and save the asn1-structure of the public key in the file ASN1_PIBINFO.der. <br><br><div class="spoiler">  <b class="spoiler_title">This utility is here:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #define digitp(p) (*(p) &gt;= '0' &amp;&amp; *(p) &lt;= '9') #define hexdigitp(a) (digitp (a) \ || (*(a) &gt;= 'A' &amp;&amp; *(a) &lt;= 'F') \ || (*(a) &gt;= 'a' &amp;&amp; *(a) &lt;= 'f')) #define xtoi_1(p) (*(p) &lt;= '9'? (*(p)- '0'): \ *(p) &lt;= 'F'? (*(p)-'A'+10):(*(p)-'a'+10)) #define xtoi_2(p) ((xtoi_1(p) * 16) + xtoi_1((p)+1)) /*   oid2buffer*/ /*   buffer2hex  hex2buffer*/ /*   wrap_for_asn1*/ int main() { int fd; unsigned char *asn, *asn1, *asn2, *asn3, *pubkeyalgo; unsigned char* pubkey_bin; //  char gost3410par[] = "\x06\x7\x2a\x85\x03\x02\x02\x23\x01"; unsigned long gost3410par_len = sizeof(gost3410par) - 1; char gost3411par[] = "\x06\x8\x2a\x85\x03\x07\x01\x01\x02\x02"; unsigned long gost3411par_len = sizeof(gost3411par) - 1; unsigned char pubkey_hex[] = "9af03570ed0c54cd4953f11ab19e551022cd48603326c1b9b630b1cff74e5a160ba1718166cc22bf70f82bdc957d924c501b9332491cb3a36ce45770f05487b5"; char pubkey_oid_2001[] = "1.2.643.2.2.19"; char pubkey_oid_2012_256[] = "1.2.643.7.1.1.1.1"; char pubkey_oid_2012_512[] = "1.2.643.7.1.1.1.2"; unsigned long pubkey_len, pubkey_len_full, len10, len11, len12, lenalgo; unsigned char *pkalgo; unsigned long pkalgo_len; uint16_t x = 1; /* 0x0001 */ printf("%s\n", *((uint8_t *) &amp;x) == 0 ? "big-endian" : "little-endian"); ////pubkeyinfo //      if (!memmem(gost3411par, 8, "\x2a\x85\x03\x07", 4)) { //   34.11-94,     34.10-2001 - 1.2.643.2.2.19 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2001, &amp;lenalgo); } else if (!memcmp(gost3411par, "\x2a\x85\x03\x07\x01\x01\x02\x02", 8)){ //   34.11-2012-256,     34.10-2012-256 - 1.2.643.7.1.1.1.1 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2012_256, &amp;lenalgo); } else { //   34.11-2012-512,     34.10-2012-512 - 1.2.643.7.1.1.1.2 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2012_512, &amp;lenalgo); } pubkey_bin =(unsigned char*)hex2buffer((const char *)pubkey_hex, &amp;pubkey_len); //    asn1 = wrap_for_asn1_bin('\x04', (unsigned char *)"", 0, pubkey_bin, pubkey_len, &amp;pubkey_len); asn = wrap_for_asn1_bin('\x03', (unsigned char *)"\x00", 1, asn1, pubkey_len, &amp;pubkey_len_full); fprintf(stderr, "PUBLIC_VALUE=%s\n", buffer2hex(asn, pubkey_len_full)); free(asn1); //  asn3 = wrap_for_asn1_bin('\x30', (unsigned char*)gost3410par, gost3410par_len, (unsigned char *)gost3411par, gost3411par_len, &amp;len12); fprintf(stderr, "\nPARAMS len12=%lu, FULL=%s\n", len12, buffer2hex(asn3, len12)); //   pkalgo = wrap_for_asn1_bin('\x06', (unsigned char *)"", 0, pubkeyalgo, lenalgo, &amp;pkalgo_len); //     asn2 = wrap_for_asn1_bin('\x30', pkalgo, pkalgo_len, asn3, len12, &amp;len11); fprintf(stderr, "PubKEY=%s\n", buffer2hex(asn3, len11)); asn1 = wrap_for_asn1_bin('\x30', asn2, len11, asn, pubkey_len_full, &amp;len10); free(asn2); free(asn3); fprintf(stderr, "\n%s\n", buffer2hex(asn1, len10)); fd = open ("ASN1_PUBINFO.der", O_TRUNC|O_RDWR|O_CREAT,S_IRWXO); write(fd, asn1, len10); close(fd); free(asn1); chmod("ASN1_PUBINFO.der", 0666); }</span></span></span></span></code> </pre> <br></div></div><br>  To check the result, we use the utilities derdump and pp from the NSS package. <br><br>  The first utility will show us the asn1-structure of the public key: <br><br><pre> <code class="bash hljs">$ derdump -i ASN1_PUBINFO.der C-Sequence (102) C-Sequence (31) Object Identifier (8) 1 2 643 7 1 1 1 2 (GOST R 34.10-2012 Key 512) C-Sequence (19) Object Identifier (7) 1 2 643 2 2 35 1 Object Identifier (8) 1 2 643 7 1 1 2 2 (GOST R 34.11-2012 256) Bit String (67) 00 04 40 9a f0 35 70 ed 0c 54 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 49 53 f1 1a b1 9e 55 10 22 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 48 60 33 26 c1 b9 b6 30 b1 cf f7 4e 5a 16 0b a1 71 81 66 cc 22 bf 70 f8 2b dc 95 7d 92 4c 50 1b 93 32 49 1c b3 a3 6c e4 57 70 f0 54 87 b5 $</code> </pre> <br>  The second will show the key content: <br><br><pre> <code class="bash hljs">$ pp -t pk -i ASN1_PUBINFO.der Public Key: Subject Public Key Info: Public Key Algorithm: GOST R 34.10-2012 512 Public Key: PublicValue: 9a:f0:35:70:ed:0c:54:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:49:53:f1:1a:b1:9e:55:10: 22:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:48:60:33:26:c1:b9:b6:30:b1:cf:f7:4e:5a:16: 0b:a1:71:81:66:cc:22:bf:70:f8:2b:dc:95:7d:92:4c: 50:1b:93:32:49:1c:b3:a3:6c:e4:57:70:f0:54:87:b5 GOSTR3410Params: OID.1.2.643.2.2.35.1 GOSTR3411Params: GOST R 34.11-2012 256 $</code> </pre> <br>  Those interested can double-check, for example, the openssl utility, preferably with a <a href="https://habr.com/ru/post/415423/">connected GOST-</a> new engine: <br><br><pre> <code class="bash hljs">$ /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_static asn1parse -inform DER -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ASN1_PUBINFO.der 0:d=0 hl=2 l= 102 cons: SEQUENCE 2:d=1 hl=2 l= 31 cons: SEQUENCE 4:d=2 hl=2 l= 8 prim: OBJECT :GOST R 34.10-2012 with 512 bit modulus 14:d=2 hl=2 l= 19 cons: SEQUENCE 16:d=3 hl=2 l= 7 prim: OBJECT :id-GostR3410-2001-CryptoPro-A-ParamSet 25:d=3 hl=2 l= 8 prim: OBJECT :GOST R 34.11-2012 with 256 bit <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> 35:d=1 hl=2 l= 67 prim: BIT STRING $</code> </pre> <br>  As you can see, the resulting ASN1 structure is successfully tested everywhere. <br><br>  The proposed algorithm and utility for the formation of asn1 structures does not require the use of any ASN1 compilers and extension libraries (of the same openssl) and turned out to be very convenient to use.  We will recall them in the next article, when <a href="https://habr.com/ru/users/pas/" class="user_link">Pas‚Äôs</a> wish is fulfilled and a graphical utility is presented that does not only ‚Äúparse certificates‚Äù and check their validity, but also generates a key pair on PKCS # 11 tokens that form and sign a request for a qualified certificate.  With this request, you can safely go to the CA for a certificate.  Ahead of the questions, I will immediately note that in the latter case, the token must be certified as ICPP in the certification system of the FSB of Russia. </div><p>Source: <a href="https://habr.com/ru/post/446166/">https://habr.com/ru/post/446166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446144/index.html">The digest of interesting materials for the mobile developer # 292 (March 25 - March 31)</a></li>
<li><a href="../446148/index.html">Linux Kernel 5.0 - we write Simple Block Device under blk-mq</a></li>
<li><a href="../446150/index.html">Machine learning without Python, Anaconda and other reptiles</a></li>
<li><a href="../446152/index.html">Commando VM - an alternative to Kali Linux for Windows</a></li>
<li><a href="../446162/index.html">How to become a "sensible junior". Personal experience</a></li>
<li><a href="../446172/index.html">Limit Messages API VK - what to do</a></li>
<li><a href="../446174/index.html">Yandex.Alisa and bot Telegram for PHP with a single functionality</a></li>
<li><a href="../446176/index.html">Recognition of tanks in the video stream by machine learning methods (+2 videos on the platforms Elbrus and Baikal)</a></li>
<li><a href="../446180/index.html">Was MongoDB even the right choice?</a></li>
<li><a href="../446184/index.html">TDD applications on Spring Boot: fine-tuning tests and working with context</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>