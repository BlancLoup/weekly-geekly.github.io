<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief synopsis of javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am a .NET developer. But lately, I‚Äôve increasingly come across JavaScript. Moreover, in 50 cases I write something on it, in the remaining 50 I deal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief synopsis of javascript</h1><div class="post__text post__text-html js-mediator-article">  I am a .NET developer.  But lately, I‚Äôve increasingly come across JavaScript.  Moreover, in 50 cases I write something on it, in the remaining 50 I deal with someone else's code, and even went through minification, and sometimes obfuscation.  In this article I wanted to share those points that seemed important to me to understand the language and work effectively with it.  There will be nothing new or unknown for people who have already dealt with the language, and there will not be something that cannot be found in other sources.  For me, the article will be useful as a way to better understand the subject, for readers, I hope, as an excuse to refresh knowledge. <br><br>  Brendan Ike mentioned that JavaScript was created in 10 days.  I think the idea was nurtured longer.  Anyway, the language has turned out and since then it is only gaining popularity.  Especially after the appearance of AJAX. <br><br>  JavaScript is a language with weak dynamic implicit typing, automatic memory management and prototype inheritance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      JavaScript consists of three separate parts: <br><br><ul><li>  core (ECMAScript), </li><li>  Browser Object Model or BOM, </li><li>  document object model (Document Object Model or DOM). </li></ul><br><br>  The article mainly focuses on the core.  Of course, the code examples will use the elements of DOM and BOM, but I will not focus on them. <br><a name="habracut"></a><br><h2>  Type system </h2><br>  A javascript type diagram looks like this: <br><br><ul><li>  Number </li><li>  String </li><li>  Boolean </li><li>  Object <br><ul><li>  Function </li><li>  Array </li><li>  Date </li><li>  RegExp </li></ul></li><li>  Null </li><li>  Undefined </li></ul><br><br>  Approximately - because there are still types for errors that are not included in this diagram. <br><br>  Of these, 5 types are primitives: <br><br><ul><li>  Number </li><li>  String </li><li>  Boolean </li><li>  Null </li><li>  Undefined </li></ul><br><br>  Everything else is objects.  Boolean, String, and Number primitives can be wrapped in corresponding objects.  In this case, the objects will be instances of the Boolean, String, and Number constructors, respectively. <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Holly Golightly'</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-string"><span class="hljs-string">'Holly Golightly'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log('Holly Golightly' === new String('Holly Golightly')); // false console.log('Holly Golightly' === String('Holly Golightly')); // true</span></span></code> </pre> <br><br>  Primitives have no properties.  If we, for example, try to get the value of the length property from a String primitive, the primitive will be converted to an object, the object will receive a property value, after which it will go somewhere to the garbage collector. <br><br>  Primitives cannot add a property. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Paul Varjak'</span></span>; person.profession = <span class="hljs-string"><span class="hljs-string">'writer'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(person.profession); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br><br>  What happened?  The person primitive was converted to an object, the property was added to the object, after which it went into non-existence. <br><br><h2>  Numbers </h2><br>  Numbers in JavaScript are represented by the Number type, in the language there is no division into integers, fixed-point numbers, and floating-point numbers.  Do not forget that operations on fractional numbers are not always accurate.  For example, <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 0.30000000000000004 console.log(0.2 + 0.3); // 0.5</span></span></code> </pre><br><br>  The language has several special values ‚Äã‚Äãfor the type Number: + Infinity, -Infinity, and NaN. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> === <span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br><br>  And now, attention <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> === <span class="hljs-literal"><span class="hljs-literal">NaN</span></span>); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre><br><br>  NaN is nothing at all.  For the case of checking for NaN, the isNaN function is built into the language.  Oh yeah, the isFinite function is also there.  NaN is contagious - the result of any arithmetic operations or functions from Math with NaN is also equal to NaN.  But &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, ||, |, ^, &amp; ,!  (they are even more than arithmetic) can destroy NaN. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> || <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(0 || NaN); // NaN console.log(!NaN); // true</span></span></code> </pre><br><br>  You need to be careful with the parseInt function, in old and new browsers it behaves differently when processing strings starting from zero.  And it is better to always specify the number system.  Older browsers perceive the initial zero as a sign of the octal number. <br><br><h2>  Strings </h2><br>  Strings in JavaScript are nothing more than sequences of Unicode characters.  There is no separate type for single characters; instead, a string of length 1 is used instead. <br><br>  Strings in JavaScript are immutable.  That is, the line cannot be changed after creation; all operations on the lines create new objects.  Strings as arguments of the function are passed by reference, not by value.  But even if the same string is processed by different methods, due to the immutability of strings, the code behaves predictably. <br><br>  Do not forget that the replace function replaces only the first occurrence of a substring in a string, if the first argument is a string, and not a regular expression.  Moreover, the regular expression must be global (must have the g modifier). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"This is the house that Jack built. This is the malt That lay in the house that Jack built. This is the rat, That ate the malt That lay in the house that Jack built"</span></span>.replace(<span class="hljs-string"><span class="hljs-string">"Jack"</span></span>, <span class="hljs-string"><span class="hljs-string">"Captain Jack Sparrow"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(str); <span class="hljs-comment"><span class="hljs-comment">// This is the house that Captain Jack Sparrow built. This is the malt That lay in the house that Jack built. This is the rat, That ate the malt That lay in the house that Jack built var str = "This is the house that Jack built. This is the malt That lay in the house that Jack built. This is the rat, That ate the malt That lay in the house that Jack built".replace(/Jack/, "Captain Jack Sparrow"); console.log(str); // This is the house that Captain Jack Sparrow built. This is the malt That lay in the house that Jack built. This is the rat, That ate the malt That lay in the house that Jack built var str = "This is the house that Jack built. This is the malt That lay in the house that Jack built. This is the rat, That ate the malt That lay in the house that Jack built".replace(/Jack/g, "Captain Jack Sparrow"); console.log(str); // This is the house that Captain Jack Sparrow built. This is the malt That lay in the house that Captain Jack Sparrow built. This is the rat, That ate the malt That lay in the house that Captain Jack Sparrow built</span></span></code> </pre><br><br>  By the way, the callback function can also be passed.  The example below can keep bikes from developing. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + i; }; })(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"This is the house that Jack built. This is the malt That lay in the house that Jack built. This is the rat, That ate the malt That lay in the house that Jack built"</span></span>.replace(<span class="hljs-regexp"><span class="hljs-regexp">/Jack/g</span></span>, callback); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(str); <span class="hljs-comment"><span class="hljs-comment">// This is the house that Jack1 built. This is the malt That lay in the house that Jack2 built. This is the rat, That ate the malt That lay in the house that Jack3 built</span></span></code> </pre><br><br>  It is important to remember that regular expressions store the state, and the result of the test and exec methods depends on both the arguments and the state.  Here are a couple of examples (thanks, <a href="https://habrahabr.ru/users/sekrasoft/" class="user_link">sekrasoft</a> ): <br><br><pre> <code class="javascript hljs">/a/g.test(<span class="hljs-string"><span class="hljs-string">'aa'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// true /a/g.test('ab') // true var re = /a/; re.test('aa') // true re.test('ab') // true //  var re = /a/g; re.test('aa') // true re.lastIndex // 1,  'aa'    a,     re.test('ab') // false re.lastIndex // 0, ..    re.test('ab') // true re.lastIndex // 1</span></span></code> </pre><br><br>  Cyrillic strings are best compared with the localeCompare function. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">""</span></span> &gt; <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-comment"><span class="hljs-comment">// false "" &gt; "" // true "".localeCompare("") // 1 "".localeCompare("") // 1</span></span></code> </pre><br><br>  Premature optimization is evil.  Here are a couple of examples: <br><br>  <a href="http://jsperf.com/array-join-vs-connect">jsperf.com/array-join-vs-connect</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  1 var arr = []; for (var i = 0; i &lt; 10000; i++) { arr.push(i); } var result = arr.join(', ') //  2 var result = ''; for (var i = 0; i &lt; 9999; i++) { result += i + ', '; } result += i;</span></span></code> </pre><br><br>  On performance wins the second option. <br><br>  <a href="http://jsperf.com/heera-string-literal-vs-object">jsperf.com/heera-string-literal-vs-object</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  1 var s = '0123456789'; for (var i = 0; i &lt; s.length; i++) { s.charAt(i); } //  2 var s = new String('0123456789'); for (var i = 0; i &lt; s.length; i++) { s.charAt(i); }</span></span></code> </pre><br><br>  In this case, with a huge margin wins the first option.  The fact is that optimizations of such templates are already built into the browser engines. <br><br>  Both double quotes and single quotes can be used to frame strings.  JSON is valid only with double quotes.  The rest is to adhere to the style adopted on the project. <br><br><h2>  null and undefined </h2><br>  null and undefined are primitives that have no corresponding objects.  Therefore, an attempt to add a property to one of these primitives or get the value of a property, as opposed to strings, numbers, and boolean values, will result in a TypeError. <br>  Semantically null and undefined are similar, but there are differences.  null means no object, undefined means no value as such.  null is a keyword, undefined is a property of a global context.  True, in modern browsers to assign it another value will not work.  Any unassigned variable defaults to undefined. <br><br><h2>  Objects </h2><br>  Objects in JavaScript are associative arrays. <br><br>  An empty object can be created in several ways. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj2 = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><br>  The first method is called literal and is recommended for use. <br><br>  You can also create an object through the constructor function. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Company</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, address</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.address = address; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> company = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Company(<span class="hljs-string"><span class="hljs-string">'Sing-Sing'</span></span>, <span class="hljs-string"><span class="hljs-string">'Ossining, Westchester County, New York, United States'</span></span>);</code> </pre><br><br>  There are two main ways to access the properties of the created object. <br><br><pre> <code class="javascript hljs">obj.name = <span class="hljs-string"><span class="hljs-string">'Tiffany'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = obj.name;</code> </pre><br><br>  and <br><br><pre> <code class="javascript hljs">obj[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Tiffany'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = obj[<span class="hljs-string"><span class="hljs-string">'name'</span></span>];</code> </pre><br><br>  The key in JavaScript objects is always a string, so they cannot be used as dictionaries with arbitrary keys.  If you try to use a non-string as a key, the value used will be converted to a string. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; obj[<span class="hljs-literal"><span class="hljs-literal">null</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj[{<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}] = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = obj[{}] <span class="hljs-comment"><span class="hljs-comment">// 4 Object.getOwnPropertyNames(obj); // ["1", "null", "[object Object]"]</span></span></code> </pre><br><br>  You can see that {} and {a: 1} were converted to the same value - "[object Object]", and the number and null were converted to the corresponding lines. <br><br>  The language has the ability to create properties with getters and setters.  There are several ways to do this. <br><br>  Literal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consts = { get pi(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3.141592</span></span>; }, set pi(){ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Property is read only'</span></span>); } };</code> </pre><br><br>  Using the Object.defineProperty function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consts = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(consts, <span class="hljs-string"><span class="hljs-string">'pi'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3.14159265359</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Property is read only'</span></span>); } });</code> </pre><br><br>  Using the Object.defineProperties function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consts = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(consts, {<span class="hljs-string"><span class="hljs-string">'pi'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3.14159265359</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Property is read only'</span></span>); }}, <span class="hljs-string"><span class="hljs-string">'e'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2.71828182846</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Property is read only'</span></span>); } }});</code> </pre><br><br><h2>  Functions </h2><br>  In javascript, functions are objects of the built-in class Function.  They can be assigned to variables, passed as parameters in a function, returned as the result of a function, and access their properties. <br><br>  Functions are named: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnswer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br><br>  and anonymous: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getAnswer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br><br>  You can pass as many parameters as you want to the function.  All of them will be accessible through the arguments object.  In addition, in this object will be the property length - the number of arguments and callee - a link to the function itself. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.slice.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } toArray(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'Tiffany'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 6, "Tiffany"]</span></span></code> </pre><br><br>  A link to the function itself allows you to create recursive anonymous functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fibonacci = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee(n - <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fibonacci(<span class="hljs-number"><span class="hljs-number">22</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 17711</span></span></code> </pre><br><br>  In the latest edition of the standard, this property has been removed.  But you can write like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fibonacci = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(n - <span class="hljs-number"><span class="hljs-number">2</span></span>) + f(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fibonacci(<span class="hljs-number"><span class="hljs-number">22</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 17711</span></span></code> </pre><br><br>  The scope of variables declared via var in JavaScript is limited to a function.  The let keyword is on the way; it will set a block scope, but so far browsers support it reluctantly. <br><br>  Often do so.  This is called a self executing function or immediately invoked function expression. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(); <span class="hljs-comment"><span class="hljs-comment">// do something })();</span></span></code> </pre><br><br>  I think this is a good practice.  Thus it turns out not to clutter the global scope with unnecessary variables. <br><br><h2>  Keyword this </h2><br>  The value of this in JavaScript does not depend on the object in which the function is created.  It is determined during the call. <br><br>  In the global context: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Window</span></span></code> </pre><br><br>  As a property of an object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj= { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'Lula Mae'</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } obj.myMethod = myFun; obj.myMethod(); <span class="hljs-comment"><span class="hljs-comment">// Object {data: "Lula Mae", myMethod: function}</span></span></code> </pre><br><br>  As usual function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">myMethod</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFun = obj.myMethod; myFun(); <span class="hljs-comment"><span class="hljs-comment">// Window</span></span></code> </pre><br><br>  Execution through eval (do not use eval): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">myMethod</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"myFun()"</span></span>); } }; obj.myMethod(); <span class="hljs-comment"><span class="hljs-comment">// Window</span></span></code> </pre><br><br>  Using call or apply methods: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">someData</span></span>: <span class="hljs-string"><span class="hljs-string">"a string"</span></span> }; myFunc.call(obj); <span class="hljs-comment"><span class="hljs-comment">// Object {someData: "a string"}</span></span></code> </pre><br><br>  In the constructor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Person = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'Lula Mae'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Person {name: "Lula Mae"}</span></span></code> </pre><br><br>  By the way, constructor functions are usually called with a capital letter. <br><br>  And recently, the bind method has appeared, which binds a function to a context.  More precisely, not just binds the function to the context, it creates a new function with the specified context, unlike call and apply. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }.bind(<span class="hljs-number"><span class="hljs-number">999</span></span>); myFunc(); <span class="hljs-comment"><span class="hljs-comment">// Number {[[PrimitiveValue]]: 999}</span></span></code> </pre><br><br><h2>  Closures </h2><br>  JavaScript is designed so that nested functions have access to external function variables.  This is the closure. <br><br>  Let's go back to the Jack example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + i; }; })(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'Jack Jack Jack'</span></span>.replace(<span class="hljs-regexp"><span class="hljs-regexp">/Jack/g</span></span>, callback); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(str); <span class="hljs-comment"><span class="hljs-comment">// Jack1 Jack2 Jack3</span></span></code> </pre><br><br>  It turned out that a function that accepts argument a has access to the variables of the external function.  And each time we call the internal function, we increment the counter variable i by 1. <br><br>  An easier example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a+b; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add(<span class="hljs-number"><span class="hljs-number">5</span></span>)(<span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 12</span></span></code> </pre><br><br>  Let's see what happened. <br><br>  When a function is called, its context is created.  It is convenient to consider it just an object in which each variable of the function corresponds to a property with its name.  When invoking nested functions, they receive a reference to the context of the external function. When the variable is accessed, it is searched in the context of the function, then in the context of the external function, and so on. <br><br>  Call add (5) <br><br><ol><li>  It is created [[scope]] = {a: 5} </li><li>  The function f = function (b) {return a + b;  } </li><li>  The f function gets a reference to [[scope]] </li><li>  The link to the f function is added to [[scope]] </li><li>  A reference to the function f is returned. </li></ol><br><br>  Call add (5) (7) <br><br><ol><li>  It is created [[[scope2]] = {b: 7} </li><li>  Searches for property a in the [[scope2]] object.  Not found. </li><li>  Searches for property a in the [[scope]] object.  Found, the value is 5. </li><li>  Searches for property b in the [[scope2]] object.  Found, the value is 7. </li><li>  Stack 5 and 7. </li><li>  The result of the addition is the number 12. </li></ol><br><br><h2>  Parameter passing </h2><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'myFunc begins'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'myFunc '</span></span> + a); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'myFunc '</span></span> + b); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getArgument</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'getArgument '</span></span> + arg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg; } myFunc(getArgument(<span class="hljs-number"><span class="hljs-number">5</span></span>), getArgument(<span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// getArgument 5 // getArgument 7 // myFunc begins // myFunc 5 // myFunc 7</span></span></code> </pre><br><br>  So what?  First, it is clear that the arguments are calculated before they are passed to the function, this is the so-called strict parameter processing strategy ... Secondly, they are calculated from left to right.  This behavior is defined by the standard and does not depend on the implementation. <br><br>  Are values ‚Äã‚Äãpassed by reference or value?  Primitives, except strings, are passed by value.  Strings are passed by reference, and are compared by value.  Since strings are immutable, it saves memory and does not have any side effects.  Objects are passed by reference.  Here it should be noted that before passing the argument by reference to the function, a copy of the link is created, which exists only inside the function being called.  That is, in other words, objects are passed by reference value.  Let's look at an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ arg.data = <span class="hljs-string"><span class="hljs-string">'data'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp = x; x = y; y = tmp; } change(a); swap(a, b); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// Object {data: "data"} console.log(b); // Object {data: "bar"}</span></span></code> </pre><br><br>  It turns out that the property of the object can be changed - a copy of the link refers to the same object.  And when assigning a new value to a link, it acts only on the copy that was passed to the function, and not on the original link. <br><br><h2>  Variable pop-up and name resolution </h2><br>  Let's look at this code. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">false</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } b(); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br><br>  Why not 1?  The fact is that for variables declared via var, the scope is limited to a function, and also that there is a mechanism for the emergence of variables.  The language interpreter always takes the declaration of all variables to the beginning of the scope.  In this case, only the announcement is transferred, and the value assignment is not transferred.  The code above is equivalent to the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">false</span></span>){ a = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } b();</code> </pre><br><br>  The algorithm for finding an object by name is: <br><br><ol><li>  Search among predefined language variables.  If found, use it. </li><li>  Search among the formal parameters of the function.  If found, use it. </li><li>  Search among the declared functions of the current scope.  If found, use it. </li><li>  Search among the declared variables of the current scope.  If found, use it. </li><li>  Go to the area of ‚Äã‚Äãvisibility above and start over. </li></ol><br><br>  An exception confirms the existence of a general rule where these exceptions are not specified.  The variable arguments is just such an exception.  Although it is a variable predefined by the language, the formal arguments parameter takes precedence when searching for a value. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arguments</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } a(); <span class="hljs-comment"><span class="hljs-comment">// [] b(); // undefined</span></span></code> </pre><br><br><h2>  Inheritance </h2><br>  Unlike languages ‚Äã‚Äãsuch as Java, C #, C ++, not classes, but objects are inherited in JavaScript.  However, class is a reserved word, so it is impossible to name a variable. <br><br>  Each object contains a link to another object, which is called a prototype.  The prototype contains a link to its prototype and so on.  At some point, there is an object with a null prototype, and the chain ends. <br><br>  It is believed that the prototype model of inheritance is more powerful than class-based inheritance.  There is the following argument in favor of such a judgment: inheritance on classes is implemented on top of the prototype rather easily, but on the contrary - not. <br><br>  It has already been mentioned that objects in JavaScript are simply associative property dictionaries.  Now it turns out that there is still a hidden property; we will denote it by [[Prototype]], which cannot be used in the code, and which serves as a ‚Äúspare‚Äù source of properties.  Let's see how a property is searched for in this case. <br><br>  Let we have such a chain of prototypes <br><br>  {a: 1, b: 2} ---&gt; {b: 3, c: 4} ---&gt; null <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(oa); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br><br>  The object has its own property a, so we just take its value. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ob); <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre><br><br>  The object has its own property b, so just take its value.  In the prototype, this property also exists, but we do not check it.  This is called overlapping properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(oc); <span class="hljs-comment"><span class="hljs-comment">// 4</span></span></code> </pre><br><br>  The object has no property c.  But it is in the prototype, we use the property of the prototype. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(od); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br><br>  There is no d property in the object.  We are looking for in the prototype, there is none there either.  We continue the search in the prototype prototype, and it is null.  Stop searching, property not found, return undefined. <br><br>  With methods everything happens the same way.  Still, methods are also properties of an object.  One caveat - this keyword in the function will point to the object, and not to the prototype, even if the function is found in the prototype.  In principle, this is logical. <br><br>  How to assign a prototype object?  There are several ways. <br><br>  First, prototypes are assigned automatically when creating objects, arrays, functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// o ---&gt; Object.prototype ---&gt; null var a = ["horse", "table"]; // a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null function getRandomNumber(){ return 4; } // getRandomNumber ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span></code> </pre><br><br>  Secondly, prototypes can be assigned when creating objects through the constructor.  In this case, the prototype of the constructor becomes the prototype of the object. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'eat called'</span></span>); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; }; Cat.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(<span class="hljs-string"><span class="hljs-string">'No name cat'</span></span>); cat.eat(); <span class="hljs-comment"><span class="hljs-comment">// eat called console.log(cat.name); // No name cat console.log(cat.constructor); // Animal</span></span></code> </pre><br><br>  The [[Prototype]] property is assigned the value of Cat.prototype when new Cat () is executed.  However, the constructor property of the cat object is assigned the value Animal.  You can fix the code so that the constructor remains correct.  Add the line Cat.prototype.constructor = Cat; <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'eat called'</span></span>); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; }; Cat.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal(); Cat.prototype.constructor = Cat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(<span class="hljs-string"><span class="hljs-string">'No name cat'</span></span>); cat.eat(); <span class="hljs-comment"><span class="hljs-comment">// eat called console.log(cat.name); // No name cat console.log(cat.constructor); // Cat</span></span></code> </pre><br><br>  Third, a prototype can be assigned when creating an object using the Object.create method.  The prototype is specified in the first argument of this method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// a ---&gt; Object.prototype ---&gt; null var b = Object.create(a); // b ---&gt; a ---&gt; Object.prototype ---&gt; null console.log(ba); // 1</span></span></code> </pre><br><br>  Just so you can not assign a prototype.  prototype is a property of the constructor, not the object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; o.prototype = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ob); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br><br>  But you can change the prototypes of built-in types, for example, Object.  This is bad practice.  The only acceptable case for modifying embedded prototypes can only be emulation of capabilities from newer versions of the language. <br><br><h2>  Strict mode </h2><br>  This mode is enabled by the directive. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>;</code> </pre><br><br>  This directive means that the code will be executed in accordance with the ECMAScript 5 standard. That is, some things will work differently.  Perhaps more logical and more correct, but not in the same way as before.  The directive can be applied to the entire script or to a single function, including nested functions.  Nested means functions declared inside a function.  If the function is declared in a different place, and is only executed inside the ‚Äústrict‚Äù function, then the directive does not act on it.  The example clearly shows this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee); } (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee); } a(); <span class="hljs-comment"><span class="hljs-comment">// function a(){...} b(); // TypeError })();</span></span></code> </pre><br><br>  And the self-calling function is there for the example to work in the browser console.  ‚ÄúUse strict‚Äù in the console does not work outside the function. <br><br>  What will change?  First, the arguments.callee property will no longer be available, this has already been mentioned. <br><br>  Secondly, this will not be replaced by a global object in the case of null or undefined or turned into a constructor instance in the case of a primitive. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) a(); <span class="hljs-comment"><span class="hljs-comment">// null })(); (function() { var a = function(){ console.log(this); }.bind(null) a(); // Window })();</span></span></code> </pre><br><br>  Third, it will not be possible to create global variables without explicitly declaring them. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ReferenceError: a is not defined })();</span></span></code> </pre><br><br>  Fourth, the with (obj) {} construct will no longer be supported. <br><br>  Fifth, it will not be possible to create an object with the same keys. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">p</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// SyntaxError: Duplicate data property in object literal not allowed in strict mode })();</span></span></code> </pre><br><br>  This is not all, but I will not list everything. <br><br><h2>  Private and public </h2><br>  There are no private and public keywords in the language, but it is possible to separate private and public data.  There are several ways to do this, for example the Module Pattern: <br><br><pre> <code class="javascript hljs">blackBox = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = [<span class="hljs-string"><span class="hljs-string">'table'</span></span>, <span class="hljs-string"><span class="hljs-string">'horse'</span></span>, <span class="hljs-string"><span class="hljs-string">'pen'</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">pop</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[~~(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * items.length)]; } }; })(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(blackBox.pop()); <span class="hljs-comment"><span class="hljs-comment">// 48 console.log(blackBox.items); // undefined</span></span></code> </pre><br><br>  Or you can do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlackBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = [<span class="hljs-string"><span class="hljs-string">'table'</span></span>, <span class="hljs-string"><span class="hljs-string">'horse'</span></span>, <span class="hljs-string"><span class="hljs-string">'pen'</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pop = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[~~(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * items.length)]; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blackBox = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlackBox(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(blackBox.pop()); <span class="hljs-comment"><span class="hljs-comment">// "pen" console.log(blackBox.items); // undefined</span></span></code> </pre><br><br><h2>  Debugging </h2><br>  The debugger instruction invokes the debugger, if available.  At the same time, the execution of the script stops at the line with this instruction. <br><br>  For example, if you have to figure out where the pop-up message came from, you can run it in the console: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.alert = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">debugger</span></span>; };</code> </pre><br><br>  Now, instead of the message, the debugger starts, and the script execution stops at the place where the alert is called. <br><br>       - .    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>().stack); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ a(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ b(); } c();</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/243403/">https://habr.com/ru/post/243403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243391/index.html">Facebook's Osquery Introduction</a></li>
<li><a href="../243393/index.html">Should everyone learn programming?</a></li>
<li><a href="../243395/index.html">Moving from online to offline IDE when programming Nucleo-F401RE</a></li>
<li><a href="../243397/index.html">Well.js is another approach to modular JavaScript development.</a></li>
<li><a href="../243401/index.html">Customize viewing of individual Issue in Atlassian Jira</a></li>
<li><a href="../243405/index.html">Game hackathon, December 6-7, Moscow</a></li>
<li><a href="../243407/index.html">Odroid-W + W Docking Board LCD</a></li>
<li><a href="../243409/index.html">Secrets of setting goals for entrepreneurs</a></li>
<li><a href="../243411/index.html">Connect FB, VK, G + to Android. Light version</a></li>
<li><a href="../243413/index.html">Configuring Virtual Infrastructure: VDI Cluster Optimization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>