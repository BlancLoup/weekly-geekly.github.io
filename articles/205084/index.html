<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MacroGroovy - working with AST on Groovy has never been easier</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, you often have to work with Groovy‚Äôs powerful capabilities like Compile-time AST Transformations . 

 Since I do not like excessive dynamics...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MacroGroovy - working with AST on Groovy has never been easier</h1><div class="post__text post__text-html js-mediator-article"><img src="http://groovy.codehaus.org/download/attachments/1866/groovydukemed.jpg?version=1&amp;modificationDate=1176732937408&amp;api=v2" alt="image"><br>  Recently, you often have to work with Groovy‚Äôs powerful capabilities like <a href="http://groovy.codehaus.org/Compile-time%2BMetaprogramming%2B-%2BAST%2BTransformations">Compile-time AST Transformations</a> . <br><br>  Since I do not like excessive dynamics, most of the DSL checks for validity take place at the compilation stage, and we also use a lot of code generation.  Therefore, every day we have to deal with the compilation of ASTNodes manually. <br><br><pre><code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVariable</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstantExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"someValue"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnStatement</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( new ConstructorCallExpression( ClassHelper.make(SomeCoolClass)</span></span></span></span>, new ArgumentListExpression(someVariable) ) );</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Painfully familiar designs, is not it?  Want it to be like this? <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVariable</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> { "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someValue</span></span></span><span class="hljs-function">" } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnStatement</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeCoolClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v{ someVariable })</span></span></span></span> }</code> </pre><br><br>  Or even so? <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructorCall</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeCoolClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v{ macro { </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"someValue"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> } })</span></span></span></span> }</code> </pre><br><br>  This article focuses on my solution to this problem, as close as possible to Groovy's native solution - <a href="https://github.com/bsideup/MacroGroovy">github.com/bsideup/MacroGroovy</a> <br><br><a name="habracut"></a><br><br><h5>  Astbuilder </h5><br>  Groovy 1.7 brought such a seemingly remarkable thing as <a href="http://groovy.codehaus.org/Building%2BAST%2BGuide">AstBuilder</a> , which offers us 3 ways to build AST: <br><br><h5>  <b>AstBuilder.buildFromString</b> </h5><br><blockquote>  Pass the string with the code, at the output we have the list of ASTNodes: <br><pre> <code class="ruby hljs">List&lt;ASTNode&gt; nodes = new AstBuilder().buildFromString(<span class="hljs-string"><span class="hljs-string">"\"Hello\""</span></span>)</code> </pre><br>  <b>Benefits</b> <br><ul><li>  The input is a string that can be taken from anywhere; </li><li>  Does not require an understanding of how ASTNode works; </li><li>  Allows you to specify a CompilePhase; </li><li>  Generates almost 100% valid code; </li><li>  Reliable - does not require a change in your code if the ASTNode structure in Groovy has changed. </li></ul><br><br>  <b>disadvantages</b> <br><ul><li>  IDE will not help you with syntax checking; </li><li>  IDE refactorings will not work either; </li><li>  Some entities cannot be created - for example, a class field declaration. </li></ul><br></blockquote><br>  Some of these shortcomings are intended to correct the following method. <br><br><h6>  <b>AstBuilder.buildFromCode</b> </h6><br><blockquote>  Pass the closure (aka Closure) with the code, we have a list of nodes at the output: <br><pre> <code class="ruby hljs">List&lt;ASTNode&gt; nodes = new AstBuilder().buildFromCode { <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> }</code> </pre><br>  <b>Benefits (except the advantages of the previous method)</b> <br><ul><li>  The IDE allows you to use autocomplete, syntax checking and refactoring in the closure. </li></ul><br>  <b>Disadvantages:</b> <br><ul><li>  This method does not solve the problem of the inability to generate a number of entities; </li><li>  Compiles the code, which is why it is not always possible to use cunning constructions, or a class that does not exist; </li><li>  The main drawback for me: the call to buildFromCode <b>requires</b> that the method be called just by <b>creating</b> AstBuilder: <pre> <code class="ruby hljs">new AstBuilder().buildFromCode { ... }</code> </pre><br>  At the same time, you cannot even take AstBuilder to a separate field or local variable (therefore, the Groovy authors even <a href="https://github.com/groovy/groovy-core/blob/master/src/test/org/codehaus/groovy/ast/builder/AstBuilderFromCodeTest.groovy">had to resort</a> to AstTransformation for this AstTransformation in order not to write a lot of code) </li></ul><br></blockquote><br>  For those who lack both methods, there is a third way: <br><br><h6>  <b>AstBuilder.buildFromSpec</b> </h6><br><blockquote>  This method takes a closure (by the way, you can vote for my <a href="https://jira.codehaus.org/browse/GROOVY-6448">Issue</a> or comment <a href="https://github.com/groovy/groovy-core/pull/285">Pull Request</a> so that the beautiful <a href="http://groovy.codehaus.org/The%2B%40DelegatesTo%2Bannotation">DelegatesTo</a> annotation appears on this method), which is a DSL for building AST: <br><pre> <code class="ruby hljs">List&lt;ASTNode&gt; nodes = new AstBuilder().buildFromSpec { block { returnStatement { constant <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> } } }</code> </pre><br>  <b>Benefits</b> <br><ul><li>  Allows you to use Groovy logic to build nodes; </li><li>  Provides the ability to design almost any existing ASTNode; </li><li>  An important plus, because  The AST generation theme in Groovy is not well documented: Fully documented and has extensive use cases in <a href="http://svn.codehaus.org/groovy/trunk/groovy/groovy-core/src/test/org/codehaus/groovy/ast/builder/AstBuilderFromSpecificationTest.groovy">TestCase</a> </li></ul><br><br>  <b>disadvantages</b> <br><ul><li>  Sometimes it‚Äôs hard to understand exactly what you need to call to get the desired result; </li><li>  Less verbose than calling node constructors, but it still remains so; </li><li>  Strange implementation - for example, some methods accept Class instead of ClassNode, which reduces its use to nothing; </li><li>  Unreliable - AST can change with major releases of the language; </li><li>  You should know exactly how your AST should look like in a specific compilation phase; </li><li>  The IDE does not yet support autocomplete for this DSL (see my comment about the Pull Request). </li></ul><br></blockquote><br><br><h6>  <b>Combining methods</b> </h6><br><blockquote>  It is also worth mentioning that you can combine these methods: <br><pre> <code class="ruby hljs">List&lt;ASTNode&gt; result = new AstBuilder().buildFromSpec { method(<span class="hljs-string"><span class="hljs-string">'myMethod'</span></span>, Opcodes.ACC_PUBLIC, String) { parameters { parameter <span class="hljs-string"><span class="hljs-string">'parameter'</span></span>: String.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> } exceptions {} block { owner.expression.addAll new AstBuilder().buildFromCode { println <span class="hljs-string"><span class="hljs-string">'Hello from a synthesized method!'</span></span> println <span class="hljs-string"><span class="hljs-string">"Parameter value: $parameter"</span></span> } } annotations {} } }</code> </pre><br></blockquote><br><br><h5>  Macrogravy </h5><br>  So, after such an extensive review of opportunities, you can ask: So on ... * hm * ... need a fig MacroGroovy? <br><br>  Consider an example from the post header: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVariable</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstantExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"someValue"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnStatement</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( new ConstructorCallExpression( ClassHelper.make(SomeCoolClass)</span></span></span></span>, new ArgumentListExpression(someVariable) ) );</code> </pre><br>  See someVariable passed to the argument list constructor?  Believe me, this situation is very, very common.  And she immediately sweeps away the buildFromCode and buildFromString.  So only buildFromSpec remains, but do you remember the list of its flaws?  This is where MacroGroovy comes to the rescue: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVariable</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> { "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someValue</span></span></span><span class="hljs-function">" };</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnStatement</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeCoolClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v{ someVariable })</span></span></span></span> }</code> </pre><br><br>  <b>Benefits</b> <br><ul><li>  All the advantages of the first and second methods; </li><li>  Does not require the creation of an object for which the macro method is called ‚Äî it is available in all classes as the <a href="http://docs.codehaus.org/display/GROOVY/Creating%2Ban%2Bextension%2Bmodule">Extension Method</a> </li><li>  Inside it re-uses the code from AstBuilder, so the method is reliable and tested; </li><li>  Allows you to use Groovy logic inside the code, since  $ v takes a closure that should return what should be put in place of its call; </li><li>  Very, VERY compact :) compare: <pre> <code class="ruby hljs">macro { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mySuperVariable }</code> </pre>  and <pre> <code class="ruby hljs">(new AstBuilder()).buildFromCode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mySuperVariable }.first().expressions.first()</code> </pre></li></ul><br><br>  <b>disadvantages</b> <br><ul><li>  Unfortunately, you will also not create a class field using macro {}; </li><li>  No CompilePhase feature; </li></ul><br><br>  By the way, you can still combine buildFromSpec and macro: <br><pre> <code class="ruby hljs">List&lt;ASTNode&gt; result = new AstBuilder().buildFromSpec { method(<span class="hljs-string"><span class="hljs-string">'myMethod'</span></span>, Opcodes.ACC_PUBLIC, String) { parameters { parameter <span class="hljs-string"><span class="hljs-string">'parameter'</span></span>: String.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> } exceptions {} block { owner.expression.addAll macro { println <span class="hljs-string"><span class="hljs-string">'Hello from a synthesized method!'</span></span> println <span class="hljs-string"><span class="hljs-string">"Parameter value: $parameter"</span></span> } } annotations {} } }</code> </pre><br><br>  Leave a link to the test, which shows how MacroGroovy reduces the amount of code at times: <br>  <a href="https://github.com/bsideup/MacroGroovy/blob/master/example/basicExample/src/test/groovy/ru/trylogic/groovy/macro/examples/basic/BasicTest.groovy">github.com/bsideup/MacroGroovy/blob/master/example/basicExample/src/test/groovy/ru/trylogic/groovy/macro/examples/basic/BasicTest.groovy</a> <br><br><h5>  Conclusion </h5><br>  Each of the methods has its pros and cons, and I just tried to smooth out the cons of other methods.  I would appreciate your help with testing and your pull requests. <br><br>  The library is available in Maven Central, leaving a link where you can always find the latest version: <br>  <a href="http://search.maven.org/">search.maven.org/#search%7Cga%7C1%7Cmacro-groovy</a> <br><br>  Thank. </div><p>Source: <a href="https://habr.com/ru/post/205084/">https://habr.com/ru/post/205084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205072/index.html">Google returns to court to protect future programming</a></li>
<li><a href="../205074/index.html">We simulate a kettle in wind river simics</a></li>
<li><a href="../205076/index.html">Refinement of the ventilator or ventilation control from the carbon dioxide sensor</a></li>
<li><a href="../205078/index.html">How and why I started going to Management fights in Kiev</a></li>
<li><a href="../205082/index.html">The results of one study: a minute of inactivity of the average data center costs $ 7900</a></li>
<li><a href="../205086/index.html">POKA-YOKE design: from ‚Äúsmell‚Äù to fragrance</a></li>
<li><a href="../205088/index.html">The "smell" of design: an obsession with primitives</a></li>
<li><a href="../205092/index.html">Friday post: phone case with airbags</a></li>
<li><a href="../205096/index.html">Code "smell": automatic properties</a></li>
<li><a href="../205098/index.html">Design smell: excessive attribute Required</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>